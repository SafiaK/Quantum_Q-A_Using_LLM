QuestionId,QuestionTitle,QuestionBody,QuestionTags,QuestionDate,AcceptedAnswerId,AnswerId,Answer Body,AnswerDate
3163234.0,"Does anyone know what ""Quantum Computing"" is?","In physics, its the ability for particles to exist in multiple/parallel dynamic states at a particular point in time. In computing, would it be the ability of a data bit to equal 1 or 0 at the same time, a third value like NULL[unknown] or multiple values?.. How can this technology be applied to: computer processors, programming, security, etc.?.. Has anyone built a practical quantum computer or developed a quantum programming language where, for example, the program code dynamically changes or is autonomous?",<language-agnostic><quantum-computing>,07/02/2010 04:28,3175933.0,3175933.0,"I have done research in quantum computing, and here is what I hope is an informed answer. It is often said that qubits as you see them in a quantum computer can exist in a ""superposition"" of 0 and 1. This is true, but in a more subtle way than you might first guess. Even with a classical computer with randomness, a bit can exist in a superposition of 0 and 1, in the sense that it is 0 with some probability and 1 with some probability. Just as when you roll a die and don't look at the outcome, or receive e-mail that you haven't yet read, you can view its state as a superposition of the possibilities. Now, this may sound like just flim-flam, but the fact is that this type of superposition is a kind of parallelism and that algorithms that make use of it can be faster than other algorithms. It is called randomized computation, and instead of superposition you can say that the bit is in a probabilistic state. The difference between that and a qubit is that a qubit can have a fat set of possible superpositions with more properties. The set of probabilistic states of an ordinary bit is a line segment, because all there is a probability of 0 or 1. The set of states of a qubit is a round 3-dimensional ball. Now, probabilistic bit strings are more complicated and more interesting than just individual probabilistic bits, and the same is true of strings of qubits. If you can make qubits like this, then actually some computational tasks wouldn't be any easier than before, just as randomized algorithms don't help with all problems. But some computational problems, for example factoring numbers, have new quantum algorithms that are much faster than any known classical algorithm. It is not a matter of clock speed or Moore's law, because the first useful qubits could be fairly slow and expensive. It is only sort-of parallel computation, just as an algorithm that makes random choices is only in weak sense making all choices in parallel. But it is ""randomized algorithms on steroids""; that's my favorite summary for outsiders. Now the bad news. In order for a classical bit to be in a superposition, it has be a random choice that is secret from you. Once you look a flipped coin, the coin ""collapses"" to either heads for sure or tails for sure. The difference between that and a qubit is that in order for a qubit to work as one, its state has to be secret from the rest of the physical universe, not just from you. It has to be secret from wisps of air, from nearby atoms, etc. On the other hand, for qubits to be useful for a quantum computer, there has to be a way to manipulate them while keeping their state a secret. Otherwise its quantum randomness or quantum coherence is wrecked. Making qubits at all isn't easy, but it is done routinely. Making qubits that you can manipulate with quantum gates, without revealing what is in them to the physical environment, is incredibly difficult. People don't know how to do that except in very limited toy demonstrations. But if they could do it well enough to make quantum computers, then some hard computational problems would be much easier for these computers. Others wouldn't be easier at all, and great deal is unknown about which ones can be accelerated and by how much. It would definitely have various effects on cryptography; it would break the widely used forms of public-key cryptography. But other kinds of public-key cryptography have been proposed that could be okay. Moreover quantum computing is related to the quantum key distribution technique which looks very safe, and secret-key cryptography would almost certainly still be fairly safe.",07/04/2010 19:24
7118933.0,Need an explanation for a quantum model,"When I am reading chapter 10 of Dasgupta I faced a paragraph that I can't understand: An electron can be in a ground state or in an excited state. In the Dirac notation used in quantum physics, these are denoted 0 and 1. But the superposition principle says that, in fact, the electron is in a state that is a linear combination of these two: a0|0> + a1|1>. This would make immediate sense if the a's were probabilities, nonnegative real numbers adding to 1. But the superposition principle insists that they can be arbitrary complex numbers, as long as the squares of their norms add up to 1! Can someone describe me last 3 lines?",<algorithm><quantum-computing>,8/19/2011 8:33,7119177.0,7119177.0,"I think the author is trying to point out a difference between the quantum model and the standard assumptions you might have about probabilities. Suppose, for example, that the electron is either up or down. In a deterministic universe, it would either be 100% up or 100% down. If we assumed that the electron probabilistically chose to be either up or down with some probabilities, then we might say that, for example, the electron was 50% up and 50% down. When using bra-ket notation for the above, you might be tempted to say that we would say that the particle is 90% up by writing 0.5 |up&gt; + 0.5|down&gt; The intuition being that the electron is simultaneously 50% up and 50% down. However, this would be incorrect. When dealing with quantum states, the configuration of a particle is related to something called the wavefunction, and it is the square of the wavefunction that determines probabilities, not the wavefunction itself. Thus if we wanted to write out a quantum state where a particle has a 50% chance of being up and a 50% chance of being down, we'd represent that as 0.707 |up> + 0.707 |down> Since 0.707 is about the square root of 0.5, so if we square the coefficients assigned to up and down we get back the classical probabilities. As long as the squares of the coefficients sum to one, the coefficients are legal since their square gives back a probability distribution. Of course, it's actually a bit trickier than this. The coefficients in quantum states can be complex numbers as well. For example, this is a perfectly legal quantum configuration: (0.707 + 0.707i) |up&gt; + 0 |down&gt; Here, the coefficient for up is a complex number. To get the probability of seeing up, we compute the complex conjugate of the coefficient: (0.707 + 0.707i)(0.707 - 0.707i) = (0.5 + 0.5) = 1 So in this case the probability of seeing up is 1 and the probability of seeing down is 0^2 = 0. Since this sums to one, this is a valid quantum state. To summarize: a probability distribution is a way of assigning real-valued weights to outcomes so that the weights sum to one. A quantum state is a way of assigning complex-valued weights to outcomes so that the sum of the product of each coefficient with it's complex conjugate is one. Phew! Haven't had to think about that in a while! Hope this helps!",8/19/2011 8:54
9672369.0,floor and ceil from QCL (Quantum Computer Language),"I'm working on QCL and some questions came up about internal functions. I'd like to know what the operators floor(something) and ceil(something) are. I know they are related to math operations, but what do they do exactly?",<operators><quantum-computing><qcl>,03/12/2012 18:04,9672397.0,9672397.0,"Floor removes the decimal point, ceil turns the decimal part into .9999 repeating if it's already there (which is the same as a whole number). So floor(4.6) loses the .6, ceil(4.6) becomes 4.9999... or 5. Also, ceil(5.0) will return 5, as the decimal part is 0.",03/12/2012 18:06
9894420.0,"Operator ""measure"" in QCL (Quantum Computing Language)","It's been a while since I got into QCL but I ran into some difficulties by trying to figure out the functioning of measure regX or measure regX,m. What does this do on the quantum registers? And the m integer?",<quantum-computing><qcl>,3/27/2012 17:17,9926184.0,9926184.0,"In Bernhard's Ãmer PhD thesis Structured Quantum Programming, in Appendix A.3.1.4 clearly states that measure regX -- performs measurement on register regX and measure regX,m -- performs measurement on register regX and writes the result of the measurement to classical variable m. If you do not understand the model behind quantum measurement it is difficult to fully understand what QCL does. But roughly speaking measurement chooses randomly one of the basis quantum states which spans the quantum superposition in which regX is and writes it to variable m.",3/29/2012 13:20
12567514.0,Quantum computers and algorithm performance,"I have a question. Gradually quantum computers will emerge someday. So, nowadays making algorithm efficient is important; I mean, making it optimal to run as fast as possible. But once quantum PC emerges does the algorithm performance improvements are still important? Cheers",<algorithm><quantum-computing>,9/24/2012 14:52,12567721.0,12567721.0,"Quantum algorithms have the possibility of searching a complete number space for an answer in one go, that much is true. However, the algorithm you choose will still determine how many of these steps are needed, and whether you can pack the whole space with useful inputs.",9/24/2012 15:02
13774439.0,Generalization of the Deutsch algorithm,"This problem concerns a straightforward generalization of the Deutsch problem discussed for functions with more than one bit as input. This time, we have a Boolean function f that takes a 4-bit number as input and outputs 0 or 1, i.e., f:{0,1}4â{0,1}. Thus, an input to f is one of 16 possible 4 bit binary numbers: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111. We are also told that f is one of the following two types: either f is a constant function, i.e., f(x) is the same for all 16 possible values of the input x, or f is a balanced function, i.e., f(x) is 0 for exactly 8 of the possible 16 inputs and f(x) is 1 for the remaining 8 of the possible 16 inputs. we are allowed to do is to use the circuit for f as a ""black box"" by giving an input x to the circuit for f and observing the output f(x). This is called a ""query"" operation. Show that a classical probabilistic algorithm can determine if f is balanced or constant with probability at least 2/3 by using 2 queries. Hint: (Obviously, we cannot do this using a deterministic algorithm. Unless the deterministic algorithm sees the output for at least 9 input values, there is no way for it to find out if the function is balanced or constant). Think about picking the two inputs uniformly and randomly from the set of 16 possible inputs. Your final result could depend probabilistically on the result of these two queries.",<algorithm><probability><quantum-computing>,12/08/2012 04:20,13775208.0,13775208.0,"EDIT: I had calculated some of my probabilities wrongly. Also I've now mentioned that we need to randomly pick 2 distinct inputs for the function f in order to guarantee that, if f is balanced, then we know the probabilities of seeing the various possible outcomes. The fact that the prior probability of the function being constant is not known makes this question harder, because it means we can't directly calculate the probability of success for any algorithm. We will, however, be able to calculate bounds on this probability. I propose the following probabilistic algorithm: Pick two distinct 4-bit values at random, and supply each to the function f. If 0,0 or 1,1 is seen, output ""constant"" with probability 2/3 and ""balanced"" with probability 1/3. Otherwise (if 0,1 or 1,0 is seen), always report ""balanced"". Let's start by looking at something we can actually calculate: conditional probabilities. ""What is P(correct|constant), namely the probability that our algorithm gives the correct answer given that f is constant?"" When f is constant, our algorithm reports the right answer 2/3 of the time. ""What is P(correct|balanced), namely the probability that our algorithm gives the correct answer given that f is balanced?"" When f is balanced, the probability of seeing 0,1 or 1,0 is 2*(8/16 * 8/15) = 8/15, in which case the correct answer will definitely be output. In the remaining 7/15 of cases -- i.e. those in which 0,0 or 1,1 is seen -- the correct answer will be output 1/3 of the time, so the total proportion of correct outputs will be 8/15 * 1 + 7/15 * 1/3 = 31/45 = 2/3 + 1/45 â 0.6889. Now suppose that the prior probability of the function being constant is p. Then the probability that the algorithm gives the correct answer is pCorrect(p) = p*P(correct|constant) + (1-p)*P(correct|balanced). Given that 0 &lt;= p &lt;= 1, pCorrect(p) must be at least min(P(correct|constant), P(correct|balanced)), and at most max(P(correct|constant), P(correct|balanced)). The minimum of 2/3 and 31/45 is 2/3, thus pCorrect is bounded from below at 2/3, for any prior probability of the function being constant. (It might help to think of p as a ""mixing lever"" that controls how much of each term to include. If p = 0 or p = 1, then we effectively just have P(correct|balanced) or P(correct|constant), respectively, and for any in-between value of p, we will have an in-between total.)",12/08/2012 06:41
32037970.0,From an application programmer's perspective - Can Functional Programming be used to program Quantum Computers?,"I'm not an expert in Functional Programming (FP). In fact, I just started learning it. So, here is the real question: Since, FP is derived from Mathematics and not from von. Neumann machine, can this programming style/paradigm be used to program Quantum Computers? This is more from an application programmer's perspective since low-level machine instructions may be completely different.",<functional-programming><quantum-computing>,8/16/2015 17:27,32038459.0,32038459.0,"No. Functional programs still perform classical computation. The functional style as we currently define it has nothing resembling superposition, quantum mechanical gates, or interference. While it is possible to transport the general idea of higher-order and first-class functions into the realm of quantum computation (and people are researching that right now), just as there are quantum Turing machines, as far as I can tell the results are as different from classical functional programming as quantum algorithms are from classical algorithms. For example, in QML if ... then ... else ... is removed in favor of a similar conditional where the condition is a qbit and the result is a superposition of the then and else values. Now, of course quantum computers are Turing-complete and could, in theory, execute any classical algorithm. But why on earth would you do that? We already have classical computers, and they are (and will always be) much more efficient at executing classical computations. The only reason to program a quantum computer is to make it run an algorithm that exploits in a nontrivial way the weirdness of quantum effects. To even express that, one needs a very different language regardless of the level of abstraction at which you work.",8/16/2015 18:24
41831217.0,Qutip commutation relations,"What is the reason the commutation relation fails on the last state N=7 M=6 commutator(position(N),momentum(N))*basis(N,M)==1.0j*basis(N,M) and similarly for the create and destroy commutator?",<python><qutip>,1/24/2017 14:51,41842383.0,41842383.0,"Because you are in a truncated Hilbert space, and your excitation is in the upmost level. Thus a creation operator promotes you out of the Hilbert space.",1/25/2017 2:22
43893163.0,Python â ImportError: cannot import name X,"Iâm trying to run a single python script â which has worked in the past â using a couple modules. Some Googling suggested circular dependencies however that is only relevant for two files importing modules that depend on one another. It seems to boil down to scalarmath not being found but I don't know why. My code is just simple functions defs for calculations and then calling those functions (all in one file). The output of my IDE is: C:\Users\sg15\AppData\Local\Continuum\Anaconda2\python.exe ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py"" Traceback (most recent call last): File ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py"", line 13, in &lt;module&gt; import matplotlib.pyplot as plt File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\__init__.py"", line 122, in &lt;module&gt; from matplotlib.cbook import is_string_like, mplDeprecation, dedent, get_label File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\cbook.py"", line 33, in &lt;module&gt; import numpy as np File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\__init__.py"", line 185, in &lt;module&gt; from . import add_newdocs File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\add_newdocs.py"", line 13, in &lt;module&gt; from numpy.lib import add_newdoc File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\__init__.py"", line 8, in &lt;module&gt; from .type_check import * File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\type_check.py"", line 11, in &lt;module&gt; import numpy.core.numeric as _nx File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\core\__init__.py"", line 20, in &lt;module&gt; from . import scalarmath ImportError: cannot import name scalarmath Process finished with exit code 1",<python><windows><numpy><anaconda><qutip>,05/10/2017 12:56,43917952.0,43917952.0,"It turns out the solution was a classic uninstall reinstall jobby. It seemed that the packages became incompatible with a recent Windows update or an update to the packages themselves. Steps to fix (in case you need them): 1) Run python in a separate program, and try to import a library e.g. import numpy. You should still see the output error message in the image that was shown in the question. This indicates that it is not a local problem to our code. Close that python program/console/whatever. 2) Open command prompt (cmd) and run conda (command: conda). Then run the commands conda install numpy and conda install matplotlib. Click yes [y] to any options that are presented. These commands depend on which libraries were causing you trouble, of course. 3) In your python IDE's console, import the libraries again i.e. import numpy and import matplotlib. Run your code and you it should build just fine (providing you have no other bugs) Note: You may have to uninstall the offending libraries giving you trouble in your conda environment in the Anaconda Navigator. To do this, select your conda environment (mine was called qutip) and remove the troublesome packages. They were matplotlib and numpy in this case.",05/11/2017 14:14
47710012.0,"A book that contains, Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm","I am looking for a book that contains descriptions of the topics: Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm; and possibly others. Does anyone know a single book or a few that would contain there topics?",<algorithm><encryption><cryptography><quantum-computing>,12/08/2017 07:57,47710199.0,47710199.0,"There is ""Post-Quantum Cryptography"" published by Daniel J. Bernstein. The book is more of a general overview and doesn't go that far into details. It contains sections about lattice based, hash based and code based cryptography. Shor's algorithm as well as discrete logarithm aren't handled in depth, but there is a general overview. I think the best way to get into the details is by studying the respective scientific papers.",12/08/2017 08:13
48303829.0,"Loop in python which appends answers to a list, I want to then create new list from this","This is the part of my code which works fine; #taking time average average= sum(result.expect[0])/len(t) averagelist=[] averagelist.append([num-Delta, average]) print(averagelist) Giving output; [[-50, 0.99994894092412567]] [[-45, 0.9999371327219414]] [[-40, 0.99992064521708557]] [[-35, 0.99989662709502258]] [[-30, 0.99985966374414359]] [[-25, 0.99979843838324323]] [[-20, 0.99968609192147129]] [[-15, 0.99944283644552467]] [[-10, 0.99874864586107459]] [[-5, 0.99499296595818931]] [[0, 0.50250021597634276]] Now I want to be able to make a new list x= -50,-45,-40 etc and new list y= 0.999..., 0.999..., 0.999... etc Is there a simple way to do this? (I have also tried the extend as oppose to append function, and this gives me the same initial output but with one square bracket not two.)",<python><list><append><qutip>,1/17/2018 14:49,48303900.0,48303900.0,You could use this : list_x = [i[0] for i in averagelist] list_y = [i[1] for i in averagelist],1/17/2018 14:53
48453676.0,Python Multiprocessing Error with IBM API (Q Experience),"I'm trying to use the IBM Q Experience API and I installed the library and wrote a quick test code. At first, it couldn't find the module. Then, I added the whole sys thing. Admittedly, I just copied that from a stackoverflow post so that may be the problem. Anyways, I got ""RunTime Error"" which leads to the python multiprocessing lib. The IBM Q doesn't have a big community, so I couldn't find anything after researching a little while. I'm completely unfamiliar with multiprocessing, threading, etc, so I imagine just seeing the code and error will be better than anything I can do to explain. Thanks in advance. import sys sys.path.append(""../../"") from qiskit import QuantumProgram #visualization from tools.visualization import plot_histogram #set up registers qp = QuantumProgram() q = qp.create_quantum_register(""q"", 3) c = qp.create_classical_register(""c"", 3) #define our circuit threeQ = qp.create_circuit(""threeQ"", [q], [c]) threeQ.measure(q[0], c[0]) threeQ.measure(q[1], c[1]) threeQ.measure(q[2], c[2]) #run result = qp.execute([""threeQ""]) #plot plot_histogram(result.get_counts(""threeQ"")) The error I get (sorry, it's long): Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path pkg_name=pkg_name, script_name=fname) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code mod_name, mod_spec, pkg_name, script_name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code exec(code, run_globals) File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt; print(qp.execute([""threeQ""])) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute result = self.run(qobj, wait=wait, timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal job_processor.submit() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit future = executor.submit(run_backend, q_job) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit self._start_queue_management_thread() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread self._adjust_process_count() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count p.start() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start self._popen = self._Popen(self) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen return _default_context.get_context().Process._Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen return Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__ prep_data = spawn.get_preparation_data(process_obj._name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data _check_not_importing_main() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main is not going to be frozen to produce an executable.''') RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() ... The ""freeze_support()"" line can be omitted if the program is not going to be frozen to produce an executable. Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path pkg_name=pkg_name, script_name=fname) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code mod_name, mod_spec, pkg_name, script_name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code exec(code, run_globals) File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt; print(qp.execute([""threeQ""])) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute result = self.run(qobj, wait=wait, timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal job_processor.submit() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit future = executor.submit(run_backend, q_job) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit self._start_queue_management_thread() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread self._adjust_process_count() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count p.start() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start self._popen = self._Popen(self) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen return _default_context.get_context().Process._Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen return Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__ prep_data = spawn.get_preparation_data(process_obj._name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data _check_not_importing_main() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main is not going to be frozen to produce an executable.''') RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() ... The ""freeze_support()"" line can be omitted if the program is not going to be frozen to produce an executable. Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path ERROR",<windows><multiprocessing><runtime-error><quantum-computing><qiskit>,1/25/2018 23:38,48471003.0,48471003.0,"This is a general issue with multi-threading in Python on Windows. The solution is to put your top-level code in an if __name__ == ""__main__"" block, as in: if __name__ == '__main__': &lt;your code here&gt; Hope that helps!",1/26/2018 23:28
49061751.0,Challenges in Enabling Practical-Scale Quantum Computing?,This question will be useful to many. Can we collate a list of challenges in enabling Practical-Scale Quantum Computing? Nathan Aw,<quantum-computing>,03/02/2018 02:13,49329850.0,49329850.0,The challenges are dependent on the physical architecture. Pick a physical implementation and look for which of the DiVincenzo's criterias are missing. These would be the chosen architecture's challenges.,3/16/2018 21:34
49579153.0,Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll',"Getting Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll' error while trying to validate my Q# environment by running the teleport sample program. dotnet build dotnet run platform windows 7 64 bit with AVX enabled. vscode with .NET Core SDK 2.0 Unhandled Exception: System.DllNotFoundException: Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll': The specified module could not be found. (Exception from HRESULT: 0x8007007E) at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator.Init() at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator..ctor(Boolean throwOnReleasingQubitsNotInZeroState, Nullable`1 randomNumberGeneratorSeed, Boolean disableBorrowing) at Microsoft.Quantum.Examples.Teleportation.Program.Main(String[] args) in C:\opt\workspace\quantum\Quantum\Samples\Teleportation\Program.cs:line 13",<c#><.net><visual-studio-code><quantum-computing><q#>,3/30/2018 17:59,49579176.0,49579176.0,"copy the Microsoft.Quantum.Simulator.Runtime.dll from C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\runtimes\win10-x64 to C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\lib\netstandard2.0. Although I have not tested this with the older Microsoft Quantum Development Kit version, there seems to be problem with the 0.2.1802.2202 version. Make sure to check if AVX is avaialble, you can use CPU-Z tool to check that in instructions section. then run dotnet run which should result in the Round 0: Sent False, got False. Teleportation successful!! Round 1: Sent True, got True. Teleportation successful!! Round 2: Sent False, got False. Teleportation successful!! Round 3: Sent False, got False. Teleportation successful!! Round 4: Sent False, got False. Teleportation successful!! Round 5: Sent False, got False. Teleportation successful!! Round 6: Sent False, got False. Teleportation successful!! Round 7: Sent True, got True. Teleportation successful!! Press Enter to continue...",3/30/2018 18:01
51118102.0,Find the length of the array that was passed to you in Q#,I have an operation as follows to which the driver needs to send an array of qubits. operation myOp(qubits: Qubit[]) : () { // uses elements from the qubit array } How do I find the length of this array from within the code?,<arrays><variable-length-array><q#><qubit>,6/30/2018 20:03,51120499.0,51120499.0,let n = Length(qubits) This will store the length in the variable n. Also n is a constant which can't be changed. If for any reason you want a mutable variable n then mutable n = Length(qubits) which can be changed. Now you can iterate through the array using a for loop (works for both constant or mutable n) for(index in 0 .. (n-1)) { //process the element qubits[index] },07/01/2018 04:51
51120653.0,Higher order versions of basic gates Q#,"Is there a higher order H-gate in Q# language? For example, if I want to apply Hadamard gate to an array(combined state) of 3 qubits. Is there a way to generate a tensor product version of H-gate or other gates?",<quantum-computing><q#>,07/01/2018 05:26,51140401.0,51140401.0,"One way to think of it is to think of the unitary operator H = |+â©â¨0| + |ââ©â¨1| and the quantum operation H separately. Taking this view, the unitary H is how we simulate the effect of applying the operation H on an ideal quantum processor. The quantum operation ApplyToEach(H, _) is then represented by the unitary operator H â H â â¯ â H in precisely the same way that H is represented by H. One consequence of this mental model is that the tensor product is defined between unitary operators and not between quantum operations. Rather, the ideal action of quantum operations acting on distinct qubits is represented by the tensor product of the unitary representations of each individual operation.",07/02/2018 16:35
51137397.0,Effect of S-gate on one qubit of a combined(maybe entangled) state of 3 qubits,"Suppose I have a register(qs) of 3 qubits (first 2 being used solely for control, the last one is the input) . The first two control qubits are in the |+&gt; state and the state of the 3rd input is unknown. Let it be a|0&gt; + b|1&gt;. Now I apply CCNOT(qs[0],qs[1],qs[2]) so their combined state becomes 0.5(a,b,a,b,a,b,b,a) in Transposed matrix form [Please correct if I'm wrong here] . Now I apply S-gate to the 3rd qubit which transforms |1&gt; -&gt; i|1&gt; . I am unable to guess the state of the combined state of 'qs' now. What I thought: One logic is to multiply every state by 'i' if it has the form|XY1&gt; so the combined state becomes 0.5(a,ib,a,ib,a,ib,b,ia) [Transposed] Another logic is to find tensor product of (I x I x S) since I'm not changing the first 2 qubits. Performing this yields a different result which is 0.5(a,b,a,b,ia,ib,ib,ia) [Transposed] [Again, correct me if I'm wrong]. Which is the correct output after passing through S-gate (if any) ?",<quantum-computing><q#><qubit>,07/02/2018 13:30,51141626.0,51141626.0,"The first two qubits can't start in |+> state, since |+> is a single-qubit state. I assume that the starting state of the first two qubits in the register is 0.5 (|00&gt; + |01&gt; + |10&gt; + |11&gt;). Both approaches are correct, because they are different ways to represent the same transformation. The first answer 0.5(a,ib,a,ib,a,ib,b,ia) [Transposed] is correct. Your second answer 0.5(a,b,a,b,ia,ib,ib,ia) [Transposed] seems to be obtained by multiplying by S x I x I, i.e., applying S gate on the first qubit instead of the third one. The tensor product I x I x S can be calculated as tensor product of I x I (which is just a 4x4 identity matrix) and S. The result is an 8x8 matrix which consists of 16 copies of S matrix, multiplied by corresponding elements of I x I: 1 0 | 0 0 | 0 0 | 0 0 0 i | 0 0 | 0 0 | 0 0 - - - - - - - - 0 0 | 1 0 | 0 0 | 0 0 0 0 | 0 i | 0 0 | 0 0 - - - - - - - - 0 0 | 0 0 | 1 0 | 0 0 0 0 | 0 0 | 0 i | 0 0 - - - - - - - - 0 0 | 0 0 | 0 0 | 1 0 0 0 | 0 0 | 0 0 | 0 i If you multiply the state of the qubits by this matrix, you'll get the same answer as in the first approach.",07/02/2018 18:09
51774989.0,Q# versus LIQUi|>,"Is Q# meant to be a LIQUiD replacement? It's unclear from the website that's this is true, but I haven't heard anything about LIQUiD since the announcement of Q#. There seems to be a large set of tools in LIQUiD that are not available in Q#, so are these meant to be linked together via .NET? In particular, I am interested in the circuit class and optimizations for QECC in LIQUiD.",<q#>,08/09/2018 20:04,51775417.0,51775417.0,"LiQUi|> (which I'll write Liquid from now on :-)) and Q# have different goals. Liquid is an F#-based platform for simulating quantum circuits. It provides a lot of handy tools and features, like the QECC and noise modelling components you mention. It provides full access to (and manipulation of, if desired) the quantum state, so you can simulate things with Liquid that you could never do on a real quantum system. Finally, Liquid includes some highly-optimized capabilities for simulating Hamiltonian simulations that do a bunch of linear algebra tricks that are not available on a real quantum system. Q# is a high-level language for coding quantum algorithms. Its goal is to let you easily code large quantum applications that would eventually be run on a large quantum system (hundreds of logical, error-corrected qubits). It does support simulation, but as a debugging aid. Put another way, Q# isn't primarily a language for programming quantum simulations, even though that's the way it's used today because of the low availability of large-scale quantum systems. Liquid is still alive. If your focus is on simulation, Liquid is a great choice: you can get direct access to the innards of the simulator, but still code at a high level. Q# is active and growing. While the focus is on actual execution, the Quantum Development Kit already includes both a full state vector simulator and a resource-estimating simulator (the trace simulator). I wouldn't be too surprised if more debugging features, including simulation, are on the way; for instance, the June release added the DumpMachine and DumpRegister operations to allow debugging access to the full state vector.",08/09/2018 20:37
52317000.0,"How to reshape a 2d numpy.array or Qobj into dims=[[2,2],[2,2]]","Numpy example below Goal: QuTiP object The goal of my request is to add two quantum state objects of type Qobj (density matrices) as in the following example of a Werner state (to give it some physical meaning). import qutip as q r = .5 state = r * q.ket2dm(q.ghz_state(2)) + (1-r) * q.maximally_mixed_dm(4) The error message is TypeError: Incompatible quantum object dimensions So one could go to the lower dimensional state but then we loose the relevant dimension properties to proceed with the state: state = r * q.ket2dm(q.ghz_state(2)).data.toarray() + (1-r) * q.maximally_mixed_dm(4) My attempts like q.Qobj(q.maximally_mixed_dm(4).data.toarray().reshape([[2,2],[2,2]])) all failed as reshape does not handle lists of lists. The inverse going from dimensions [[2,2],[2,2]] down to [4,4] is not a miracle using reshape or as shown by the conversion to an array. But is the inverse implemented in either numpy nor qutip? Edit: For people familiar with numpy How do you reshape a 2d array (e.g. here 4x4) in to a (2x2)x(2x2) one? The built in function of numpy seems to dislike my requested example. It does not accept lists of lists as shown here: import numpy as np state = np.identity(4).reshape([[2,2],[2,2]]) I was surprised that no one ever asked this question before!",<python><reshape><qutip>,9/13/2018 15:28,52318325.0,52318325.0,"You are using reshape in the wrong way. It takes a tuple of the dimensions as an argument (see the docs) and not a tuple of tuples or list of lists with the dimensions as elements - how should that work? I think you are mixing the depth of your list of lists with the dimensionality (which are expected to be the numeric entries of the tuple). I am not sure what exactly you wanna end up with but I guess one of the following: state = np.identity(4).reshape((2,2,2,2)) state = np.identity(4).reshape((4,2,2)) state = np.identity(4).reshape((2,2,4))",9/13/2018 16:49
52701261.0,Qiskit NameError: name 'q0' is not defined,"I wrote the following code to implement the Grover's algorithm using 3-qubits. from qiskit import* from qiskit.tools.visualization import* list = [q0,q1,q2] def ccz(qci,q0,q1,q2): qci.h(q2) qci.ccx(q0,q1,q2) qci.h(q2) def grover(qci,q0,q1,q2): ccz(qci,q0,q1,q2) for i in range(list): qci.h(i) qci.x(i) ccz(qci,q0,q1,q2) for i in range(list): qci.x(i) qci.h(i) bn = 3 q = QuantumRegister(bn) c = ClassicalRegister(bn) qc = QuantumCircuit(q,c) for i in range(bn): qc.h(q[i]) grover(qc,q[0],q[1],q[2]) for i in range(bn): qc.measure(q[bn-i-1],c[i]) r = execute(qc,""local_qasm_simulator"").result() rc = r.get_counts() print(rc) plot_histogram(rc) But I got the error below. Why did my Jupyter notebook care only about ""q0"", not other elements in the list? How can I fix this? NameError: name 'q0' is not defined",<python-3.x><qiskit>,10/08/2018 11:27,53456577.0,53456577.0,"It gives you error about q0 because this is the first unknown variable that it encounters. Then it dies. There is improper flow in your program. You try to define the variable list: you try to build it from the variables that are not defined yet, you make it global and try to operate somehow in the functions, where you pass also pass variables as parameters, this name list is not a good choice as it's a python built-in name. Try this one: from qiskit import * from qiskit.tools.visualization import * def ccz(qci, q0, q1, q2): qci.h(q2) qci.ccx(q0, q1, q2) qci.h(q2) def grover(qci, q0, q1, q2): ccz(qci, q0, q1, q2) for i in [q0, q1, q2]: qci.h(i) qci.x(i) ccz(qci, q0, q1, q2) for i in [q0, q1, q2]: qci.x(i) qci.h(i) bn = 3 q = QuantumRegister(bn) c = ClassicalRegister(bn) qc = QuantumCircuit(q, c) for i in range(bn): qc.h(q[i]) grover(qc, q[0], q[1], q[2]) for i in range(bn): qc.measure(q[bn - i - 1], c[i]) r = execute(qc, ""local_qasm_simulator"").result() rc = r.get_counts() print(rc) plot_histogram(rc)",11/24/2018 8:45
53189971.0,QDK file not found error in LiH Simulation,"I am on MacOS. While ""dotnet run"" on unmodified version of ""LithiumHydrideGUI"" I am getting the following unhandled exception as File Not Found for 'Quantum-release-v0.3.1810/Chemistry/LithiumHydrideGUI/..\IntegralData\YAML\LiHData\integrals_lih_sto-3g_0.800.nw.out.yaml'. I do see that the file is very much present in the directory one level up that is at ""Chemistry"" folder. Please let me know how to fix this.",<quantum-computing>,11/07/2018 13:00,53326334.0,53326334.0,"You need to switch the direction of the slashes from ""\"" to ""/"". You will find the line for this in the ""Program"" file.",11/15/2018 19:05
53273082.0,IndexError: list index out of range (Bloch sphere),"I'm trying to build something called a Bloch Sphere, which is the 3-D representation of single quantum bit. Currently, I'm creating a function that develops animation along the x-axis and here is the code that I've written. def x_animation(self): #Y and Z are inputs from users Y1 = self.Y*(-1) Z1 = self.Z*(-1) #number of dots which consists animation length = 10 for i in range(length+1): # an array of X,Y,Z coordinates of 10 dots xgate= [] xgate_y = np.linspace(self.Y,Y1,length+1) xgate_z = np.linspace(self.Z,Z1,length+1) xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)]) plot(xgate[i][0],xgate[i][1],xgate[i][2]) However, I got the error below. IndexError Traceback (most recent call last) &lt;ipython-input-5-f56aa4b3a487&gt; in &lt;module&gt;() ----&gt; 1 q.x_animation() &lt;ipython-input-3-f74dcce093d4&gt; in x_animation(self) 57 xgate_z = np.linspace(self.Z,Z1,length+1) 58 xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)]) ---&gt; 59 plot(xgate[i][0],xgate[i][1],xgate[i][2]) 60 61 def x_gate(self): IndexError: list index out of range I would appreciate it if anyone help me with solving this problem.",<python-3.x><quantum-computing>,11/13/2018 2:51,53293161.0,53293161.0,"Your code initializes the list xgate to an empty list on each iteration, and then it appends one element to it, thus xgate never has more than one element in it by the time plot is called. But plot tries to access i-th element of xgate, which will succeed on the first iteration and fail on the second one (once i=1). You should be able to fix this by moving list initialization xgate = [] outside of the loop, so that it would actually accumulate the elements. (I'm not sure initialization of xgate_y and xgate_z should be in the loop either, but those are not accumulated and should not cause this kind of an issue.)",11/14/2018 4:23
53925337.0,Q# Intellisense Errors,"I can build my Q# projects fine, but VS 2017 (v. 15.9.4) has the Intellisense errors code QS6103 of ""No namespace with that name exists."" for my first two ""open"" statements shown below. I have tried with both the ""0.3.1811.1501"" and ""0.3.1811.2802"" versions of the SDK and Canon. namespace Quantum.QSharpApplication1 { open Microsoft.Quantum.Primitive; open Microsoft.Quantum.Canon; operation HelloQ () : Unit { Message(""Hello quantum world!""); } }",<visual-studio><visual-studio-2017><q#>,12/25/2018 20:09,53926530.0,53926530.0,"What version of .NET Core do you have installed? (You can check using dotnet --version) I ran into similar problems with Q# IntelliSense not recognizing library namespaces, with .NET Core 2.1.500 and 2.1.403, but with 2.1.402 it works fine. I had to uninstall the higher versions though.",12/26/2018 0:34
54074951.0,how to select unique elements of a list in q#?,"I'm new to q# programming. I have a number list: 1 3 2 3 2 4 5 2 3 6 4 2 1 6 3 2 1 Now, I want to generate unique set of numbers in Q programming language where final output must be: 1 2 3 4 5 6",<list><q#>,01/07/2019 13:02,54083864.0,54083864.0,"There is no library method for this in Q#, so you'd have to implement it yourself. If the range of the possible numbers is small (up to N), you can allocate an extra array of N elements and mark all the numbers that occur in the input array. Otherwise you can sort the input array and return all numbers which differ from the one right before them and right after them. That being said, I wonder why do you need to do this in Q#? Q# is a domain-specific language, so a lot of things which are one or two library calls in general-purpose languages can be rather inconvenient to do in Q#. It is typically much easier to do them in C# or F# driver and pass the result to Q# code as a parameter.",01/08/2019 00:45
54910144.0,Why is the return type Unit used to describe operations that have no return value in Q#; as opposed to void or none?,"Why did Microsoft, when creating Q#, decide to use the keyword Unit instead of void or none, to describe methods that have no return value? Is there a reason for this, or did Microsoft just want to do something different?",<q#>,2/27/2019 16:31,54910622.0,54910622.0,"Functions and operations in Q# are always tuple-in tuple-out. Together with singletonâtuple equivalence (the principle that 'T and ('T) are the exact same type), this lets Q# represent things uniformly, with every function and operation taking exactly one input and returning exactly one output, each of which are tuples. One consequence of this approach that we can write a function like Composed&lt;'T, 'U, 'V&gt;(inner : ('T -&gt; 'U), outer : ('U -&gt; 'V)) : ('T -&gt; 'V), confident that we can pass any function as inner, without thinking about how many arguments it takes. For this design to be consistent, we need that a function or operation that ""returns nothing"" returns an empty tuple rather than no value at all. In many functional languages (including F#), the type of the empty tuple is called unit or Unit, following traditional notation in type theory. In Q#, we decided to follow that tradition to clarify the distinction between the value () and the type Unit.",2/27/2019 16:53
55777679.0,How does CLR compile Q# code that uses or does not make use of qubits?,"If a Q# operation does not use qubits or quatum specific gates, will then the CLR generate bytecode that will be executed by the CPU and not the QPU(quantum processor)?",<clr><q#><qubit>,4/20/2019 20:58,56045697.0,56045697.0,"Yes, exactly. The Q# compiler translates the purely classical parts of your code into C#, which gets compiled (by the C# compiler) into standard .NET MSIL, JITed by the .NET Core runtime, and executed on a normal CPU.",05/08/2019 17:00
57198794.0,How to install Qiskit with only Jupyter Notebook?,I want to use Jupyter Notebook without installing Anaconda on Ubuntu 18.04. I do not want to use any virtual environment. What can I do to install Qiskit? I have tried to install Qiskit with pip3. pip3 install qiskit This shows the following message Segmentation fault (core dumped) But if I try to import qiskit from terminal with this shows no error. But when I try to import qiskit from Jupyter Notebook it says that there is not module named qiskit Any suggestion to solve this problem?,<python><jupyter-notebook><qiskit>,7/25/2019 9:35,57199513.0,57199513.0,You have different python installations. Install qiskit in the python installation pointed by jupyter. Use below from jupyter notebook !pip3 install qiskit,7/25/2019 10:12
57819419.0,How to install and import Qiskit_aqua?,I want to run SVM algorithm using Qiskit. For this purpose I need to import some packages from qiskit_aqua.utils. I am writing my code on Google Colaboratory. But while trying to import this package it shows me the following error. ModuleNotFoundError: No module named 'qiskit_aqua' I have tried to import every thing from Qiskit. But no changes have come. Here is my code. !pip install qiskit from qiskit import * from qiskit_aqua.utils import split_dataset_to_data_and_labels from qiskit_aqua.input import get_input_instance from qiskit_aqua import run_algorithm I even tried to import Aer using this command. But still it is of no use. Help me finding the solution. !pip install qiskit from qiskit import Aer from qiskit_aqua.utils import split_dataset_to_data_and_labels from qiskit_aqua.input import get_input_instance from qiskit_aqua import run_algorithm,<python><qiskit>,09/06/2019 09:35,57819651.0,57819651.0,"Aqua is a subpackage of Qiskit, so you need to use . instead of _. Your imports therefore should be from qiskit import Aer from qiskit.aqua.utils import split_dataset_to_data_and_labels from qiskit.aqua.input import get_input_instance from qiskit.aqua import run_algorithm",09/06/2019 09:50
57832016.0,How to make a gate which generates |0> or |1> based on a parameter?,"I would like to make a single-qubit gate which gives |0> or |1> with reference to a parameter. For example, I set a parameter theta in range of 0 to 2Ï. When theta is in range of 0 to Ï, the gate returns |0> and when theta is in range of Ï to 2Ï, the gate returns |1>. I am in the environment as follows: Qiskit: 0.12.0 Python 3.7.3 .",<quantum-computing><qiskit>,09/07/2019 08:28,57833040.0,57833040.0,"Quantum gates don't ""return"" a state, they transform a qubit state into another one. A singe-qubit quantum gate is represented as a 2x2 unitary matrix, and the way it transforms the qubit state is represented as matrix multiplication of this matrix and a vector of length 2 which represents the input state. So the closest to the thing you're trying to do is a gate which transforms an arbitrary input state to |0â© or to |1â© depending on the value of the parameter. Quantum gates also have to be reversible, i.e. you need to be able to undo the transformation. The transformation you described makes it impossible, since multiple inputs are mapped to the same output, and you can not recover the input state from the result. Non-reversible transformations are done not using gates but using measurements. If you need to collapse the input qubit to |0â© or |1â© depending on a parameter, you can measure it, and depending on the measurement result and the state you need, apply an X gate to the qubit. I.e., if the qubit was measured in the |0â© state and you need a |1â© (or vice versa), apply X gate, otherwise don't apply it.",09/07/2019 11:00
58017525.0,Unexpected keyword argument 'noise_model',"The following code throws an error. Based on some issues that I read on qiskit github, it seems that it has something do with run configs vs. compile configs but I could not find any other info that will help me resolve this issue. from qiskit import QuantumCircuit, IBMQ, execute from qiskit import BasicAer as Aer from qiskit.providers.aer import noise ckt = QuantumCircuit(2, 2) ckt.h(0) ckt.cx(0, 1) ckt.measure(0, 0) ckt.measure(1, 1) qsim = Aer.get_backend(""qasm_simulator"") IBMQ.load_account() provider = IBMQ.get_provider(hub=""ibm-q"") qc = provider.get_backend(""ibmqx2"") props = qc.properties() coupling_map = qc.configuration().coupling_map noise_model = noise.device.basic_device_noise_model(props) job = execute( ckt, qsim, noise_model=noise_model, coupling_map=coupling_map, basis_gates=noise_model.basis_gates ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-1-2f987d65d1f7&gt; in &lt;module&gt; 25 noise_model=noise_model, 26 coupling_map=coupling_map, ---&gt; 27 basis_gates=noise_model.basis_gates 28 ) ~/.venvs/qk/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, **run_config) 220 221 # executing the circuits on the backend and returning the job --&gt; 222 return backend.run(qobj, **run_config) TypeError: run() got an unexpected keyword argument 'noise_model' Env: macOS 10.14.6 Python 3.7.3 qiskit 0.12.0",<python><quantum-computing><qiskit>,9/19/2019 19:04,58018154.0,58018154.0,The error is coming up because you are using BasicAer to retrieve the simulator backend. I do not think this will work with the BasicAer provider. You should be using the Aer provider. from qiskit import Aer qsim = Aer.get_backend('qasm_simulator') If you just change your import statement from from qiskit import BasicAer as Aer to from qiskit import Aer then your code should work,9/19/2019 19:55
58918250.0,How to connect to IBMQ from Qiskit?,"I have a problem with connecting on IBMQ from jupyter, by typing : from qiskit import IBMQ IBMQ.save_account('Token') IBMQ.load_account() i tried many different code but nothing worked. I uninstalled Qiskit, then i reinstall it and it still don't work. If you have an idea of what is happening, please tell me",<qiskit>,11/18/2019 15:43,58919672.0,58919672.0,"Please try running IBMQ.delete_account() to remove any old/incorrect credentials that may have accidentally got stored. Then check you have the most up to date versions of all the qiskit packages, especially IBM Q provider which should be on 0.4.1. If the packages need updating run pip install --upgrade qiskit. Once this has finished, run IBMQ.save_account(token) to save the credentials again. After this you should be able to run IBMQ.load_account()",11/18/2019 17:06
59862723.0,Could I get the detail of error from qiskit,"Sometimes, I execute a circuit on the Quantum computing device (ex. ibmq_16_melbourne) and got error like 'Invalid job state. The job should be DONE but it is JobStatus.ERROR'. Could I get the detail of this error, such as the cause of a mistake or sth like that. For this time, I try to execute a circuit that including from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, IBMQ, execute from qiskit.visualization import * from qiskit.tools.jupyter import * from qiskit.tools.monitor import job_monitor IBMQ.load_account() qr = QuantumRegister(6) cr = ClassicalRegister(5) mycir = QuantumCircuit(qr,cr) for i in range(13): mycir.mct([qr[0],qr[1],qr[2],qr[3]],qr[4],None, mode='noancilla') mycir.mct([qr[0],qr[1],qr[2]],qr[3],None, mode='noancilla') provider = IBMQ.get_provider(group='open') backend = provider.get_backend('ibmq_16_melbourne') job = execute(mycir, backend, shots=1000) job_monitor(job) result = job.result() counts = result.get_counts() # print(counts) plot_histogram(counts, figsize=(14,8)) the result is error like above.",<qiskit>,1/22/2020 15:09,59864921.0,59864921.0,"Running this circuit through the transpiler, I get a circuit that has a depth of 2201. I imagine the reason this circuit won't run therefore is because it is too deep. To remedy this I would suggest either reducing the depth of your circuit, or running it on a simulator with a noise model similar to the device you are trying to run it on.",1/22/2020 17:09
60682091.0,cannot save tensorrflow keras quantum model using save/pickle,"how to save tensorflow quantum model? I am getting the following when i am trying to save keras model with quantum circuits. I didnt find any support for the same. tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments WARNING:tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments: {'prepend': cirq.Circuit([ cirq.Moment(operations=[ cirq.H.on(cirq.GridQubit(0, 0)), cirq.H.on(cirq.GridQubit(0, 1)), cirq.H.on(cirq.GridQubit(0, 2)), cirq.H.on(cirq.GridQubit(0, 3)), cirq.H.on(cirq.GridQubit(1, 0)), cirq.H.on(cirq.GridQubit(1, 1)), cirq.H.on(cirq.GridQubit(1, 2)), cirq.H.on(cirq.GridQubit(1, 3)), cirq.H.on(cirq.GridQubit(2, 0)), cirq.H.on(cirq.GridQubit(2, 1)), cirq.H.on(cirq.GridQubit(2, 2)), cirq.H.on(cirq.GridQubit(2, 3)), cirq.H.on(cirq.GridQubit(3, 0)), cirq.H.on(cirq.GridQubit(3, 1)), cirq.H.on(cirq.GridQubit(3, 2)), cirq.H.on(cirq.GridQubit(3, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 1), cirq.GridQubit(0, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 2), cirq.GridQubit(0, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 3), cirq.GridQubit(1, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 0), cirq.GridQubit(1, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 1), cirq.GridQubit(1, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 2), cirq.GridQubit(1, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 3), cirq.GridQubit(2, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 0), cirq.GridQubit(2, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 1), cirq.GridQubit(2, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 2), cirq.GridQubit(2, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 3), cirq.GridQubit(3, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 0), cirq.GridQubit(3, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 1), cirq.GridQubit(3, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 2), cirq.GridQubit(3, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 3), cirq.GridQubit(0, 0)), ]),])}. They will not be included in the serialized model (and thus will be missing at deserialization time). --------------------------------------------------------------------------- NotImplementedError Traceback (most recent call last) &lt;ipython-input-91-a74ee5c9d34d&gt; in &lt;module&gt;() ----&gt; 1 qcnn_model.save('qcnn_model.h5') 8 frames /usr/local/lib/python3.6/dist-packages/tensorflow_core/python/keras/engine/base_layer.py in get_config(self) 497 # or that `get_config` has been overridden: 498 if len(extra_args) &gt; 1 and hasattr(self.get_config, '_is_default'): --&gt; 499 raise NotImplementedError('Layers with arguments in `__init__` must ' 500 'override `get_config`.') 501 return config NotImplementedError: Layers with arguments in `__init__` must override `get_config`.",<tensorflow><keras><model><save><tensorflow-quantum>,3/14/2020 11:12,60688418.0,60688418.0,"TensorFlow Quantum does not yet implement get_config and load_config. We had some difficulty with saving certain Cirq objects, we are working on it. For now if you want to save models that contain quantum layers you can use the model = tf.keras.Model(...) model.save_weights(""some_path"") ... model.load_weights(""some_path"") function instead.",3/14/2020 23:47
60709643.0,How to create VSCode bindings to input bra and ket efficiently,"I'm currently using VSCode for Q# programming. This sometimes entails including simple qubit expressions in the comments for clarity. It is of course possible to just settle with using regular angle brackets (such as |00&gt; or &lt;00|), but it looks nicer using the appropriate Unicode characters (such as |00â© or â¨00|). Copying and pasting these characters whenever needed is a bit cumbersome, so it would be nice to have key bindings in VSCode just for this purpose. Actually, I'd like to be able to configure VSCode for quick access to any selection of characters I might be interested at the moment.",<visual-studio-code><keyboard-shortcuts><special-characters><quantum-computing><ide-customization>,3/16/2020 16:23,60709644.0,60709644.0,"VSCode customization supports a type command which does exactly that - types in its argument. In order to create an entry for a keybinding, open the command prompt (Ctrl+Shift+P or â+Shift+P on Mac) and type Preferences: Open Keyboard Shortcuts (JSON) and insert entries of the form: { ""key"": ""&lt;key-binding&gt;"", ""command"": ""type"", ""args"": { ""text"": ""&lt;character&gt;"" } } where &lt;key-binding&gt; is the usual description of the keybinding and &lt;character&gt; is the desired character literal. So, for the bra-ket case above, my customization looks like this: [ { ""key"": ""ctrl+shift+."", ""command"": ""type"", ""args"": { ""text"": ""â©"" } }, { ""key"": ""ctrl+shift+,"", ""command"": ""type"", ""args"": { ""text"": ""â¨"" } } ]",3/16/2020 16:23
60839687.0,using third part modules in IBM quantum experience,"is there something i can do to use NumPy in IBM quantum experience? I have searched on google but i couldn't find anything. I thought about coping the source code, any suggestion?",<python><quantum-computing>,3/24/2020 21:34,60848813.0,60848813.0,"NumPy is one of the pre-installed packages (it's a pre-requisite for Qiskit, for one thing). You should be able to just do import numpy from your Jupyter notebook.",3/25/2020 12:25
61379417.0,AssertionError: wrong color format 'ansibrightred',"I am running my old qiskit code after a very long time it's not running now showing error wrong color format 'ansibrightred' and I don't know why? from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister # %matplotlib inline circuit = QuantumCircuit(3,3) circuit.h(0) circuit.h(1) circuit.h(2) circuit.measure([0,1], [0,1])",<quantum-computing><qiskit>,4/23/2020 4:33,61380576.0,61380576.0,I ran into the same problem. I solved it by removing my install and installing qiskit==0.16.2. pip install qiskit==0.16.2,4/23/2020 6:22
62048900.0,Unexpected keyword argument 'datatime' qiskit provider,"I'm trying to set datatime calling backend.properties qiskit. this is my code : from qiskit import * from qiskit.providers.ibmq import * provider = IBMQ.get_provider(hub='ibm-q') provider.backends(simulator=False) backend = provider.get_backend(name) prp = backend.properties(datatime=datatime).to_dict() I'm getting this error : TypeError: properties() got an unexpected keyword argument 'datatime'. If I use refresh = True and not datatime in propertis, the code works.",<quantum-computing><qiskit>,5/27/2020 17:11,62049287.0,62049287.0,"The keyword is datetime, not datatime.",5/27/2020 17:31
62161231.0,In quantum computing is there a preference to usage of little endian or big endian?,"I've been learning quantum computing related concepts over the past few months. We've generally used the big endian notation while solving problems on paper. Recently on starting to code I find that at a lot of places the little endian notation is used. I see the same in Quantum Katas by Microsoft and also in Qiskit. On paper, however, thinking in terms of Little endian reverses the order of tensor products, etc. So sometimes it gets confusing. Is there any particular trend on using little endian in quantum computing softwares (QDK, Qiskit, etc) or any reason for the same? Any suggestions in terms of what is the best way to think (in the above context), that can help while developing quantum algos to problems and smoothly translating them into code are welcome.",<quantum-computing>,06/02/2020 20:52,62184514.0,62184514.0,"I believe the preference in the user code is mostly dictated by the notation used by two sources: the libraries and the books/papers detailing the topic; and the preference in the libraries is dictated by the notation in the books/papers used to implement the libraries. For example, quantum Fourier transform as described in Nielsen and Chuang uses big endian notation for input/output registers; so if a library uses this book as a reference (as the first part of the QFT kata does), it is likely to use big endian notation as well. I don't think there is a quantum-specific reason to prefer little endian over big endian or vice versa, at some level it's an arbitrary choice informed by the notation preferred by the sources.",06/03/2020 23:38
62409919.0,How does DenseLayout in qiskit's transpiler work?,"I'm looking for an explanation about the Dense Layout algorithm used by qiskit's transpiler. I saw the source code, but still I don't understand what """"""Choose a Layout by finding the most connected subset of qubits"""""" means! Is there a paper about this kind of mapping algorithm or other resource I can learn about it from?",<layout><mapping><qiskit>,6/16/2020 13:40,62419747.0,62419747.0,"It does a breadth first search for a connected subset starting at each qubit. The subset with the most connectivity is selected. Due to symmetry there are many subsets with same connectivity. However, it also looks at the noise in the device and picks the subset with the least amount of noise. Finally that set is run through a reverse cuthill mckee traversal to reorder the qubits in the set for a lower degree. There is no paper on it as I came up with it to solve a bug in earlier versions of the Qiskit swap mapper.",6/17/2020 0:47
64538775.0,Q# : QDK Errors,"I've recently tried to install the QDK via the VSCode extension in my Windows 10 Desktop and VSCode wasn't able to find the Microsoft libraries even after I was able to execute the code by the dotnet run command on the terminal. The code was the sample project code described in the create new project part of the tutorial. I also didn't have .NET SDK so I installed it but it seems to be working fine. In computers I got problems all the code, all related to not finding the namespaces. namespace QuantumRNG { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; open Microsoft.Quantum.Math; open Microsoft.Quantum.Convert; operation GenerateRandomBit() : Result { using (q = Qubit()) { H(q); return MResetZ(q); } } operation SampleRandomNumberInRange(max : Int) : Int { mutable output = 0; repeat { mutable bits = new Result[0]; for (idxBit in 1..BitSizeI(max)) { set bits += [GenerateRandomBit()]; } set output = ResultArrayAsInt(bits); } until (output &lt;= max); return output; } @EntryPoint() operation SampleRandomNumber() : Int { let max = 50; Message($&quot;Sampling a random number between 0 and {max}: &quot;); return SampleRandomNumberInRange(max); } }",<visual-studio-code><q#>,10/26/2020 14:08,64602732.0,64602732.0,"Do you see any error messages in the output console? To see the output console select &quot;View: Toggle Output&quot; (Ctrl + Shift + U) and select &quot;Q# Language Extension&quot; from the drop down list. If the drop down list doesn't show &quot;Q# Language Extension&quot; then it probably means that the language-server that gets downloaded on first run is still downloading, so give it a minute or so (depending on your internet connection).",10/30/2020 4:27
64817371.0,How to loop several times within a list?,"I have a code that looks like this,: import random import numpy as np from operator import itemgetter import sys equal_to = {&quot;a&quot;:&quot;u_plus&quot;, &quot;b&quot;:&quot;u_minus&quot;, &quot;c&quot;:&quot;v_plus&quot;, &quot;d&quot;:&quot;v_minus&quot;} #bell state p = 8 #length of generated binary key1 = [] #list of generated binary for i in range(p): temp = random.randint(0,1) key1.append(temp) tmplist2 = [] #list of random sample_letters for i in range(p): while True: attempt = str(random.choice(list(equal_to))) tmplist2.append(attempt) if attempt == 'b': break #evaluate result of alice binary and bell state def eva(alice, bell): if alice == 1: if bell == 'a' or bell == 'b': return 1 elif bell == 'c' or bell == 'd': return 0 elif alice == 0: if bell == 'c' or bell == 'd': return 1 elif bell == 'a' or bell == 'b': return 0 for_bob = [] #list of generated binary and bell state through logic gate for k in key1: for t in tmplist2: e = eva(k, t) for_bob.append(e) #tr = [[eva(k,t) for t in tmplist2] for k in key1] #list comprehension split the key properly print(&quot;generated random binary strings:&quot;, key1) print(&quot;generated bell states:&quot;, tmplist2) print(&quot;encrypted strings:&quot;, for_bob) It printed out something like this: generated random binary strings: [0, 0, 0, 0, 0, 1, 1, 0] generated bell states: ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] encrypted strings: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0] I was looking a way to loop within tmplist2 without starting again from the beginning, if the string 'b' came out. The loop is supposed to function as follows: key1[0] shall evaluate with 'b', returning to 0. Since 'b' came out, outer loop should continue to next element key1[1] and it should evaluate with 'c' and 'b', returning 1 0. Again because 'b' came out, outer loop shall proceed to next element key[2] and evaluate itself with 'a', 'a', 'c', and 'b', returning 0 0 1 0. This should continue until tmplist2 finished. Anyone got solutions for the issue? I was searching the solution of how to loop within a loop and not returning to the beginning when a certain condition is given. In this case 'b'. n.b.: this program was meant to simulate quantum teleportation.",<python><quantum-computing>,11/13/2020 8:02,64818488.0,64818488.0,"Main data for_bob = [] key1 = [0, 0, 0, 0, 0, 1, 1, 0] tmplist2 = ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] Approach 1 _tmp = tmplist2[:] for k in key1: while _tmp: if _tmp[:1] != ['b']: for_bob.append(eva(k, *_tmp[:1])) _tmp = _tmp[1:] else: for_bob.append(eva(k, *_tmp[:1])) _tmp = _tmp[1:] break Approach 2: _tmp = iter(tmplist2) for i in key1: for j in iter(lambda: next(_tmp), None): if j != 'b': for_bob.append(eva(i, j)) else: for_bob.append(eva(i, j)) break generated random binary strings: [0, 0, 0, 0, 0, 1, 1, 0] generated bell states: ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] encrypted strings: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]",11/13/2020 9:31
65254223.0,Set random seed for cirq functions,"I am working with cirq and use a random unitary for testing purposes with: random_matrix = cirq.testing.random_unitary(dim=4) where can can the random seed for this function be set, using random.seed(a=1) does not seem to do this.",<linear-algebra><quantum-computing><cirq>,12/11/2020 15:34,65254479.0,65254479.0,"Cirq relies on numpy for its random functions, so using: np.random.seed(2) Sets the seed for cirq",12/11/2020 15:50
66148518.0,Quantum computing vs traditional base10 systems,"This may show my naivetÃ© but it is my understanding that quantum computing's obstacle is stabilizing the qbits. I also understand that standard computers use binary (on/off); but it seems like it may be easier with today's tech to read electric states between 0 and 9. Binary was the answer because it was very hard to read the varying amounts of electricity, components degrade over time, and maybe maintaining a clean electrical &quot;signal&quot; was challenging. But wouldn't it be easier to try to solve the problem of reading varying levels of electricity so we can go from 2 inputs to 10 and thereby increasing the smallest unit of storage and exponentially increasing the number of paths through the logic gates? I know I am missing quite a bit (sorry the puns were painful) so I would love to hear why or why not. Thank you",<binary-data><quantum-computing>,02/11/2021 03:52,66260965.0,66260965.0,"&quot;Exponentially increasing the number of paths through the logic gates&quot; is exactly the problem. More possible states for each n-ary digit means more transistors, larger gates and more complex CPUs. That's not to say no one is working on ternary and similar systems, but the reason binary is ubiquitous is its simplicity. For storage, more possible states also means we need more sensitive electronics for reading and writing, and a much higher error frequency during these operations. There's a lot of hype around using DNA (base-4) for storage, but this is more on account of the density and durability of the substrate. You're correct, though that your question is missing quite a bit - qubits are entirely different from classical information, whether we use bits or digits. Classical bits and trits respectively correspond to vectors like Binary: |0&gt; = [1,0]; |1&gt; = [0,1]; Ternary: |0&gt; = [1,0,0]; |1&gt; = [0,1,0]; |2&gt; = [0,0,1]; A qubit, on the other hand, can be a linear combination of classical states Qubit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt; where Î± and Î² are arbitrary complex numbers such that such that |Î±|2 + |Î²|2 = 1. This is called a superposition, meaning even a single qubit can be in one of an infinite number of states. Moreover, unless you prepared the qubit yourself or received some classical information about Î± and Î², there is no way to determine the values of Î± and Î². If you want to extract information from the qubit you must perform a measurement, which collapses the superposition and returns |0&gt; with probability |Î±|2 and |1&gt; with probability |Î²|2. We can extend the idea to qutrits (though, just like trits, these are even more difficult to effectively realize than qubits): Qutrit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt; + Î³ |2&gt; These requirements mean that qubits are much more difficult to realize than classical bits of any base.",2/18/2021 13:29
66197227.0,Return two numbers in Q Sharp (Q#) (Quantum Development Kit),"So, basically, I did the tutorial to create a random number on the website of Microsoft Azure and now I am trying to add some functionalities, including their suggestion add a minimum number. The initial code to generate just one number, max, is: operation SampleRandomNumberInRange(max : Int) : Int { // mutable means variables that can change during computation mutable output = 0; // repeat loop to generate random numbers until it generates one that is less or equal to max repeat { mutable bits = new Result[0]; for idxBit in 1..BitSizeI(max) { set bits += [GenerateRandomBit()]; } // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer set output = ResultArrayAsInt(bits); } until (output &lt;= max); return output; } @EntryPoint() operation SampleRandomNumber() : Int { // let declares var which don't change during computation let max = 50; Message($&quot;Sampling a random number between 0 and {max}: &quot;); return SampleRandomNumberInRange(max); } Everything works well. Now, I want to generate two numbers so I would like to create a function TwoSampleRandomNumbersInRange but I can't figure out how to make the function return a result such as &quot;Int, Int&quot;, I tried a few things including the follow: operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int { // mutable means variables that can change during computation mutable output = 0; // repeat loop to generate random numbers until it generates one that is less or equal to max repeat { mutable bits = new Result[0]; for idxBit in 1..BitSizeI(max) { set bits += [GenerateRandomBit()]; } for idxBit in 1..BitSizeI(min) { set bits += [GenerateRandomBit()]; } // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer set output = ResultArrayAsInt(bits); } until (output &gt;= min and output &lt;= max); return output; } To generate two numbers, I tried this: operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int, Int { //code here } ...but the syntax for the output isn't right. I also need the output: set output = ResultArrayAsInt(bits); to have two numbers but ResultArrayAsInt, as the name says, just returns an Int. I need to return two integers. Any help appreciated, thanks!",<azure><quantum-computing><q#>,2/14/2021 16:03,66199077.0,66199077.0,"The return of an operation has to be a data type, in this case to represent a pair of integers you need a tuple of integers: (Int, Int). So the signature of your operation and the return statement will be operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : (Int, Int) { // code here return (integer1, integer2); }",2/14/2021 19:09
66198976.0,ValueError: numpy.ndarray size changed on importing qiskit,"While trying to run the following commands on Jupyter from qiskit import QuantumCircuit, Aer, BasicAer, execute from qiskit.visualization import plot_histogram I am encountering the following error.I am using python 3.8. Does anyone have any idea how can this be resolved? I have tried upgrading numpy and reinstalling Qiskit but the problem prevails --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-3-a0c116756cb0&gt; in &lt;module&gt; ----&gt; 1 from qiskit import QuantumCircuit, Aer, BasicAer, execute 2 from qiskit.visualization import plot_histogram C:\ProgramData\Anaconda3\lib\site-packages\qiskit\__init__.py in &lt;module&gt; 55 # Try to import the Aer provider if installed. 56 try: ---&gt; 57 from qiskit.providers.aer import Aer 58 except ImportError: 59 suppress_warnings = os.environ.get('QISKIT_SUPPRESS_PACKAGING_WARNINGS', '') C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\__init__.py in &lt;module&gt; 62 63 # pylint: disable=wrong-import-position ---&gt; 64 from .aerprovider import AerProvider 65 from .aerjob import AerJob 66 from .aererror import AerError ... C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\fastsparse.py in &lt;module&gt; 438 # ------------------------------------- 439 # pylint: disable=no-name-in-module, wrong-import-position, import-error --&gt; 440 from .cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult) spmath.pyx in init qiskit.providers.aer.pulse.qutip_extra_lite.cy.spmath() ValueError: numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject",<python><python-3.x><numpy><qiskit>,2/14/2021 18:59,66199810.0,66199810.0,worked after I used the following command pip install --ignore-installed qiskit-terra qiskit-aer,2/14/2021 20:28
66288920.0,Can I have two iterables in the reduce function? (Python),"Suppose I have the following command (using Python and Qiskit): a = reduce(lambda x,y: x.compose(y,c),circli, qcla) (qcla is an initializer) Here, compose is an internal qiskit function, x and y are elements of the list circli (iterable). I'm wondering is it possible for me to add another iterable in this reduce function? Here, c itself in (y,c) represents a coordinate, such as [2,3], and I'm hoping to have it updated as well. Can I create another list containing all the possible c's and add it as another iterable? Thanks!",<python><lambda><reduce><qiskit>,2/20/2021 7:01,66289038.0,66289038.0,"It is possible to reduce a list (iterable) of pairs and also to create a pair at the end. For the first one you need the zip function, for the latter one you need to modify the lambda function to return a tuple. For example: a, x_sum = reduce(lambda x,y: (x[0].compose(y[0], y[1]), x[1][0]+y[1][0]), zip(circli, cs), (qcla, 0)) I use the name cs for the list of c values here. zip creates pairs of circli and cs items and you can go through the pairs. In this case I get the sum of the x coordinates of c values as the result as well. If the values in cs is the constant c in your example (cs = [c]*len(circli)) , the a in the result will be the same as in your example.",2/20/2021 7:22
67411006.0,"Python calling q# file on IONQ QPU results in error about a System.Text.Json, Version=5.0.0.0 file not being found","Attempting to learn how to call q# from Python code and have it run for real on the IONQ QPU as it does (or appears to do) using VS and &gt;dotnet run of the raw q# code. I followed the guides and workshop. Python code: import qsharp import qsharp.azure qsharp.projects.add(&quot;****path to *******/TestIONQ.csproj&quot;) from TestIONQ import GetRandomResult print(f&quot;Simulated Result: {GetRandomResult.simulate()}&quot;) print(&quot;------------------------------------------------&quot;) qsharp.azure.connect( subscription = &quot;****************************&quot;, resourceGroup = &quot;**************&quot;, workspace = &quot;************&quot;, location = &quot;******* US&quot;) qsharp.azure.target(&quot;ionq.qpu&quot;) result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;) print(f&quot; Final result from IONQ - QPU: {result}&quot;) q# code: namespace TestIONQ { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; //@EntryPoint() operation GetRandomResult() : Result { use q = Qubit(); H(q); return M(q); } } and the .csproj file: &lt;Project Sdk=&quot;Microsoft.Quantum.Sdk/0.16.2104138035&quot;&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt; &lt;ExecutionTarget&gt;ionq.qpu&lt;/ExecutionTarget&gt; &lt;IQSharpLoadAutomatically&gt;true&lt;/IQSharpLoadAutomatically&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt; The results of running the above Python code in Anaconda qsharp-env environment (Python 3.7.10) are as follows: Simulated Result: 0 ------------------------------------------------ Connected to Azure Quantum workspace ####### in location #####us. Loading package Microsoft.Quantum.Providers.IonQ and dependencies... Active target is now ionq.qpu Submitting TestIONQ.GetRandomResult to target ionq.qpu... Failed to submit Q# operation TestIONQ.GetRandomResult for execution. Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken=####token#####'. The system cannot find the file specified. Obviously, no problem connecting to Azure and the Workspace. In fact I can run the container-ship optimization example no problem from Python. This also works fine for the first half of the Python code when .simulate() is invoked. Next, when I try to bypass the IONQ QPU and use its own simulator by changing this one line: qsharp.azure.target(&quot;ionq.simulator&quot;) The resulting error is the same and the results are as follows: Simulated Result: 1 ------------------------------------------------ Connected to Azure Quantum workspace ######## in location #######. Loading package Microsoft.Quantum.Providers.IonQ and dependencies... Active target is now ionq.simulator Submitting TestIONQ.GetRandomResult to target ionq.simulator... Failed to submit Q# operation TestIONQ.GetRandomResult for execution. Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken='....token......'. The system cannot find the file specified. Traceback (most recent call last): File &quot;ionq_sim_remote.py&quot;, line 18, in &lt;module&gt; result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;) File &quot;F:\Python38\miniconda\envs\qsharp-env\lib\site-packages\qsharp\azure.py&quot;, line 137, in execute if &quot;error_code&quot; in result: raise AzureError(result) qsharp.azure.AzureError: {'error_code': 1010, 'error_name': 'JobSubmissionFailed', 'error_description': 'Failed to submit the job to the Azure Quantum workspace.'} This runs very easily on Azure using the q# code snippet within Visual Studio at the command line using a variant of what was shown during the workshop az quantum execute --target-id ionq.qpu --job-name IONQ_test --resource-group ***rg name*** --workspace-name ***ws name*** --location **** -o table and indeed this appears to have run on the actual QPU hardware as compared to the simulator (which gives the exact 0.5/0.5 result). Result Frequency -------- ---------- 0 0.49800000 1 0.50200000 But then calling that same q# code from Python - including the same .csproj file seems to throw this JSON file error - even with the qsharp-env loaded into Anaconda. I apologize if it is something silly that I have done- trying to learn here. By the way, this works great as a way around the problem with no Anaconda environment required or anything special: Python: import os os.system(f'powershell.exe az quantum execute --target-id ionq.qpu --job-name Pytest --resource-group **** --workspace-name **** --location **** -o table ') And the result was definitely run on the actual hardware (took a good while): Result Frequency -------- ----------- ------------------------- 0 0.53200000 ââââââââââââ | 1 0.46800000 ââââââââââ |",<python><azure><q#><azure-quantum>,05/06/2021 02:20,67421883.0,67421883.0,"@Joab.Ai, thank you for posting this issue! We've identified this to be specific to the latest version of qsharp (0.16.2104.138035). While we are looking into a fix, a workaround will be to downgrade your qsharp package version: Edit: we have fixed this issue in our latest release! Update to the latest version with this command: conda install -c quantum-engineering qsharp=0.16.2105.140472 or simply run: conda update -c quantum-engineering qsharp",05/06/2021 16:02
72031758.0,sympy: substitution of expressions with Braket-notation,"I am using sympy (in sagemath). I would like to do a substitution, with Braket-notation (for quantum mechanical problem). Below there is a minimalistic code, in order to reproduce the problem. from sympy.physics.quantum import Bra, Ket from sympy import * theta=symbols('theta',commutative=True) pi, mu= symbols(&quot;pi mu&quot;,commutative=False) W=2*pi*mu print(W.subs(pi*mu,theta)) V=Bra(pi)*Ket(mu) print(V.subs(Bra(pi)*Ket(mu),theta)) U=2*Bra(pi)*Ket(mu) print(U.subs(Bra(pi)*Ket(mu),theta)) The output is: 2*theta theta 2*&lt;pi|*|mu&gt; If there is no leading scalar multiplier, the substitution works finely. I am stuck with a more complicated expression.",<sympy><quantum-computing>,4/27/2022 15:48,72032642.0,72032642.0,"In these occasions srepr can shed some light: srepr(U) # out: &quot;Mul(Integer(2), Bra(Symbol('pi', commutative=False)), Ket(Symbol('mu', commutative=False)))&quot; srepr(Bra(pi)*Ket(mu)) # out: &quot;InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False)))&quot; Note that the first output is a multiplication, object of type Mul, whereas the second output is an object of type InnerProduct. With the command U.subs(Bra(pi)*Ket(mu),theta) you are asking to search for an object of type InnerProduct into U, but there is none, hence no substitution has been done. In this case, you have to do: U.subs(Mul(Bra(pi), Ket(mu)),theta) # out: 2*theta Edit: or as @Oscar Benjamin pointed out, you do: from sympy.physics.quantum import qapply U = qapply(U) srepr(U) # out: &quot;Mul(Integer(2), InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False))))&quot; Now you can see an InnerProduct as an argument of Mul. FInally: U.subs(Bra(pi)*Ket(mu), theta) # out: 2*theta",4/27/2022 16:56
72341743.0,How to decompose a N x N unitary matrix into 2- or 1-qubit operators?,"Given an N x N unitary operator M, I would like to build a circuit that does the same operation as M by explicitly inputting the gates myself (let's say into the IBMQ composer). I heard that 2-qubit operators could be decomposed using a Qiskit built-in function, however I was wondering if such a thing existed for a general case. More concretely, given a N x N unitary operator M, I would like to decompose it to something of the form M_1 x M_2 x M_3 x ... x M_n where &quot;x&quot; represents the tensor product and M_i is either a 2- or 1-qubit unitary operator. Is there a way to do this programatically, or can it be done by hand on paper in an algorithmic way? Thank you in advance!",<quantum-computing><qiskit>,5/22/2022 22:33,72349417.0,72349417.0,"If you want to implement custom unitary, there is a way to do it using Operator function, like this (example for 4x4 unitary matrix): from qiskit import QuantumRegister, QuantumCircuit from qiskit.quantum_info.operators import Operator q = QuantumRegister(2,&quot;qreg&quot;) qc = QuantumCircuit(q) customUnitary = Operator([ [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0] ]) qc.unitary(customUnitary, [q[0], q[1]], label='custom') qc.draw(output='mpl') But if your purpose is to decompose it to 1 or 2-qubit operators, the problem is more complex since there can be multiple ways to decompose the same unitary. I think the best you can do is to use Qiskit transpiler and define set of gates you want to use: from qiskit.compiler import transpile newCircuit = transpile(qc, basis_gates=['ry', 'rx', 'cx'], optimization_level = 3) newCircuit.draw(output='mpl')",5/23/2022 13:28
72417370.0,Qiskit: 'no counts for experiment',"Although I imported plot_histogram, I am not getting the output as expected. Here is my code: a = QuantumCircuit(1) a.z(0) a.x(0) a.h(0) a.sdg(0) a.t(0) backend = Aer.get_backend('qasm_simulator') result = execute(a, backend).result() counts = result.get_counts() plot_histogram(counts) print(c)```",<qiskit>,5/28/2022 16:29,72421265.0,72421265.0,You are missing measurements. a.z(0) a.x(0) a.h(0) a.sdg(0) a.t(0) a.measure_all(). #&lt;-- ... This will measure the qubits and set a classical register with the result.,5/29/2022 5:55
72451052.0,"Multi-processing a for loop, target's argument needs to be a list","I'm trying to use multiprocessing to split a for loop over multiple processes. Thus speeding up a QuTiP's library solver, here's my target function: def solve_entropy(t): # Parameters k = 0.5 n = 2 N = 5 r = 1.0 alpha = 2.0 beta = 2.0 gamma = 0.2 wm = 1 w0 = r * wm g = k * wm # Operators a = tensor(destroy(N), identity(N), identity(N)) b = tensor(identity(N), destroy(N), identity(N)) c = tensor(identity(N), identity(N), destroy(N)) # result = mesolve(H,psi0,t,c_ops) result = mesolve( w0 * a.dag() * a + w0 * b.dag() * b + wm * c.dag() * c - g * a.dag() * a * (c + c.dag()) - g * b.dag() * b * (c + c.dag()), tensor(coherent(N, alpha), coherent(N, alpha), coherent(N, beta)), t, sqrt(gamma) * c, ) S = [entropy_linear(ptrace(i, n)) for i in result.states] return S where mesolve takes a list of times (t) as argument, here's my multiprocessing code: if __name__ == &quot;__main__&quot;: t = np.linspace(0, 25, 100) # list of times t pool = mp.Pool(mp.cpu_count()) result = pool.map(solve_entropy, t) pool.close() pool.join() data = list(zip(t, result)) np.savetxt(&quot;entropy.dat&quot;, data, fmt=&quot;%.8f&quot;) However when I run this code I get the following error &quot;object of type 'numpy.float64' has no len()&quot;. It seems like mp.Pool splits my list t in float points instead of a smaller list, and since mesolve needs a list as argument I get an error. Is there a way to keep &quot;t&quot; as a list over multiple processes? Since it won't work if &quot;t&quot; is a number.",<python><numpy><multiprocessing><physics><qutip>,5/31/2022 16:10,72452112.0,72452112.0,"First, define function split, which takes an iterable and splits it into n lists: def split(iterable, n): # function to split iterable in n even parts if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) return list(iterable[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in range(n)) Then: if __name__ == &quot;__main__&quot;: # One smaller list for each process in the pool # This will create a list of numpy.ndarray instances: t = split(np.linspace(0, 25, 100), mp.cpu_count()) ... # etc. Update: Seeing the split Function In Action I have converted the split function into a generator function to better see what happens on each iteration. With a list of 93 elements being split into 10 sublists, the algorithm attempts to make each list as close to the same size it can. The code is very clever (I did not write it, but found it). In this case the statement k, m = divmod(l, n) with l -&gt; 93 and n -&gt; 10, it results in k -&gt; 9 and m -&gt; 3. Since m is not 0, it will create m lists of size k+1 and n-m lists of size k. def split(iterable, n): # function to split iterable in n even parts\n, if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) print() print(f'list size is {l}, number of sublists = {n}, k = {k}, m = {m}') if m == 0: print(f'This should yield {n} sublists of size {k}') else: print(f'Thus should yield {m} lists of size {k+1} and {n-m} lists of size {k}') print() for i in range(n): index_start = i * k + min(i, m) index_end = (i + 1) * k + min(i + 1, m) list_size = index_end - index_start print(f'i = {i}, min(i, m) = {min(i, m)}, min(i + 1, m) = {min(i + 1, m)}, index_start = {index_start}, index_end = {index_end}, size = {list_size}') yield iterable[index_start:index_end] for sublist in split(list(range(93)), 10): print('sublist =', sublist) for sublist in split(list(range(30)), 10): print('sublist =', sublist) for sublist in split(list(range(27)), 4): print('sublist =', sublist) Prints: list size is 93, number of sublists = 10, k = 9, m = 3 Thus should yield 3 lists of size 10 and 7 lists of size 9 i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 10, size = 10 sublist = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 10, index_end = 20, size = 10 sublist = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 20, index_end = 30, size = 10 sublist = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29] i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 30, index_end = 39, size = 9 sublist = [30, 31, 32, 33, 34, 35, 36, 37, 38] i = 4, min(i, m) = 3, min(i + 1, m) = 3, index_start = 39, index_end = 48, size = 9 sublist = [39, 40, 41, 42, 43, 44, 45, 46, 47] i = 5, min(i, m) = 3, min(i + 1, m) = 3, index_start = 48, index_end = 57, size = 9 sublist = [48, 49, 50, 51, 52, 53, 54, 55, 56] i = 6, min(i, m) = 3, min(i + 1, m) = 3, index_start = 57, index_end = 66, size = 9 sublist = [57, 58, 59, 60, 61, 62, 63, 64, 65] i = 7, min(i, m) = 3, min(i + 1, m) = 3, index_start = 66, index_end = 75, size = 9 sublist = [66, 67, 68, 69, 70, 71, 72, 73, 74] i = 8, min(i, m) = 3, min(i + 1, m) = 3, index_start = 75, index_end = 84, size = 9 sublist = [75, 76, 77, 78, 79, 80, 81, 82, 83] i = 9, min(i, m) = 3, min(i + 1, m) = 3, index_start = 84, index_end = 93, size = 9 sublist = [84, 85, 86, 87, 88, 89, 90, 91, 92] list size is 30, number of sublists = 10, k = 3, m = 0 This should yield 10 sublists of size 3 i = 0, min(i, m) = 0, min(i + 1, m) = 0, index_start = 0, index_end = 3, size = 3 sublist = [0, 1, 2] i = 1, min(i, m) = 0, min(i + 1, m) = 0, index_start = 3, index_end = 6, size = 3 sublist = [3, 4, 5] i = 2, min(i, m) = 0, min(i + 1, m) = 0, index_start = 6, index_end = 9, size = 3 sublist = [6, 7, 8] i = 3, min(i, m) = 0, min(i + 1, m) = 0, index_start = 9, index_end = 12, size = 3 sublist = [9, 10, 11] i = 4, min(i, m) = 0, min(i + 1, m) = 0, index_start = 12, index_end = 15, size = 3 sublist = [12, 13, 14] i = 5, min(i, m) = 0, min(i + 1, m) = 0, index_start = 15, index_end = 18, size = 3 sublist = [15, 16, 17] i = 6, min(i, m) = 0, min(i + 1, m) = 0, index_start = 18, index_end = 21, size = 3 sublist = [18, 19, 20] i = 7, min(i, m) = 0, min(i + 1, m) = 0, index_start = 21, index_end = 24, size = 3 sublist = [21, 22, 23] i = 8, min(i, m) = 0, min(i + 1, m) = 0, index_start = 24, index_end = 27, size = 3 sublist = [24, 25, 26] i = 9, min(i, m) = 0, min(i + 1, m) = 0, index_start = 27, index_end = 30, size = 3 sublist = [27, 28, 29] list size is 27, number of sublists = 4, k = 6, m = 3 Thus should yield 3 lists of size 7 and 1 lists of size 6 i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 7, size = 7 sublist = [0, 1, 2, 3, 4, 5, 6] i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 7, index_end = 14, size = 7 sublist = [7, 8, 9, 10, 11, 12, 13] i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 14, index_end = 21, size = 7 sublist = [14, 15, 16, 17, 18, 19, 20] i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 21, index_end = 27, size = 6 sublist = [21, 22, 23, 24, 25, 26] Explanation When m is 0 (the iterable of length l can be divided into n sublists of size l // n, then the ith starting slice index is: i * k + min(i, m) # but min(i, m) is 0 for all i, so this is just: i * k # where k is the size of each sublist, l // n But when m is not 0, min(i, m) is just i for the first m sublists, so the starting index is i * k + i -&gt; i * (k+1) and the ending index is (i + 1) * k + i + 1 -&gt; i * (k+1) + k + 1 So the first m sublists are length k + 1. The starting index of ith sublist for i == m is i * k + min(i, m) -&gt; m * k + m and the ending index is (i + 1) * k + min(i + 1, m) -&gt; (m + 1) * k + m -&gt; m * k + k + m The difference between the ending and starting indices is just k. Update 2 Here is split rewritten as a generator function, which makes the logic clearer: def split(iterable, n): if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) start_index = 0 if m == 0: for _ in range(n): end_index = start_index + k yield iterable[start_index:end_index] start_index = end_index else: l2 = k + 1 for _ in range(m): end_index = start_index + l2 yield iterable[start_index:end_index] start_index = end_index for _ in range(n - m): end_index = start_index + k yield iterable[start_index:end_index] start_index = end_index",5/31/2022 17:43
72875257.0,"Cannot import QISKIT ""ModuleNotFoundError: No module named 'qiskit._accelerate'""","I'm trying to use qiskit in virtual environment via Anaconda, however although I see qiskit as installed, importing qiskit always fails with: ModuleNotFoundError: No module named 'qiskit._accelerate' I can't find information about this anywhere. What is this module? What is wrong with the environment? It seems there's nothing called qiskit._accelerate",<python><anaconda><qiskit>,07/05/2022 20:36,72888163.0,72888163.0,"I've solved the issue thanks to Joseph Geipel's advice. There's some compatibility issue between Python and Qiskit. Python 3.9.12 and Qiskit 0.37.0 seem not to work well together. When I've created a new environment with Python 3.8.13 and the same version of Qiskit, the problem was solved.",07/06/2022 18:11
73239349.0,"Why am I getting ""NameError: name 'qiskit' is not defined"" on my program when I already imported all qiskit functions","I'm using the IBM quantum lab to run my python program. I imported all these functions/libraries: from ibm_quantum_widgets import CircuitComposer from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi import json import ast from qiskit import * from qiskit import QuantumCircuit, execute, BasicAer from qiskit.tools.monitor import job_monitor from qiskit import IBMQ from qiskit import BasicAer just to make sure I literally got everything from the qiskit library (if that's the right term, I'm kind of a beginner). It's overkill but I did it mainly because every time I run my program and get to this line of code: measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1) I get a nameerror, qiskit not defined. I wanted to import everything just to be sure that wasn't the issue. Does anyone understand what possibly could be the issue here? for context, I'll copy and paste the code before the error: IBMQ.load_account() provider = IBMQ.get_provider(hub = 'ibm-q') thequantumcomputer = provider.get_backend('ibmq_qasm_simulator') #measures all the circuits circuit.measure(0,0) circuit.measure(1,1) circuit.measure(2,2) circuit.measure(3,3) circuit.measure(4,4) circuit.measure(5,5) circuit.measure(6,6) circuit.measure(7,7) circuit.measure(8,8) measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1) Thanks for any suggestions you have :)",<python><qiskit>,08/04/2022 16:27,73239399.0,73239399.0,"You would need to say import qiskit What you have said is from qiskit import execute That brings in the name execute. It does not define a name called qiskit. So, you could say: measure = execute(circuit, backend=thequantumcomputer, shots=1) Or you could just use import qiskit instead of importing all the individual names. I tend to prefer that, because then I know exactly where the name came from.",08/04/2022 16:31
73477635.0,Bundled QC Circuit on Qiskt (Index error),"I'm trying to execute a list of ciruits on qiskit, but was faced with this strange dilemma: --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-4-653a7fab138c&gt; in &lt;module&gt; ----&gt; 1 job = execute(circuit_list, backend = device, shots = 1024) 2 print(job.job_id()) ~\anaconda3\envs\qc_env\lib\site-packages\qiskit\execute_function.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config) 274 &quot;&quot;&quot; 275 if isinstance(experiments, Schedule) or ( --&gt; 276 isinstance(experiments, list) and isinstance(experiments[0], Schedule) 277 ): 278 # do not transpile a schedule circuit IndexError: list index out of range I did not transpile any circuit before adding it to the list nor am I transpiling it during execution. Does anyone have an answer to why this is happening? Edit: I'm not using a schedule either.",<python><qiskit>,8/24/2022 17:52,73477848.0,73477848.0,"That error would be caused by passing an empty list to execute(). What are the contents of circuit_list in your code? For the record, the execute() function is just a shorthand convenience function doig backend.run(transpile(experiments, backend)). So you're doing the correct thing not transpiling before passing circuit objects to execute().",8/24/2022 18:12
73819500.0,P vs. NP and Shor's Algorithm,"Given that Shor's algorithm can solve factorization in polynomial time on a quantum computer (BQP), if we prove that BQP is the same as P on a classical computer, won't factorization (which is an NP problem) be a counterexample to P != NP? In other words, if that statement is true, isn't P != NP not true, because we can solve an NP problem (factorization) in P time?",<np><quantum-computing>,9/22/2022 18:58,73819699.0,73819699.0,"The P vs NP question asks whether every problem in NP is also in P. Therefore, if you just find a single problem in NP that is also in P, that does not itself prove that P = NP. We already know of many problems with this property - since P is a subset of NP, every problem in P is also in NP. It is the case that if you can find an NP-complete problem in P then P = NP, but as of now we donât have a proof that the integer factorization problem (or more properly, the decision version of that problem) is NP-complete.",9/22/2022 19:19
73963180.0,This worked last week(Qiskit library issue),"This code used to work last week. I made sure that the pip install command is up-to-date and the right environment is set. I've been working on this code across windows and MacOS.... not the best idea but that may be part of the problem? Why is it not working? note: I blanked out the sensitive provider info... it's not really all Xs. import numpy as np from collections import defaultdict from qiskit import Aer from qiskit.visualization import plot_histogram from qiskit.utils import QuantumInstance from qiskit.algorithms import Grover, AmplificationProblem from qiskit.circuit.library import PhaseOracle from qiskit.compiler import transpile from qiskit import assemble from qiskit import IBMQ from qiskit import execute from qiskit.tools import job_monitor import matplotlib.pyplot as plt IBMQ.save_account('xxxxxxx', overwrite=True) IBMQ.load_account() provider = IBMQ.get_provider(hub='xxxx', group='xxxx', project='xxxx') device = provider.get_backend('ibmq_kolkata') circuit_list = [] verification_list = [] --------------------------------------------------------------------------- ImportError Traceback (most recent call last) ~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr) 147 try: --&gt; 148 from qiskit.providers import ibmq 149 ~\anaconda3\envs\qc_env\lib\site-packages\qiskit\providers\ibmq\__init__.py in &lt;module&gt; 85 ---&gt; 86 from qiskit.providers import BaseBackend, Backend # type: ignore[attr-defined] 87 ImportError: cannot import name 'BaseBackend' from 'qiskit.providers' (C:\Users\Ahmad\AppData\Roaming\Python\Python38\site-packages\qiskit\providers\__init__.py) The above exception was the direct cause of the following exception: MissingOptionalLibraryError Traceback (most recent call last) &lt;ipython-input-2-63cbbaf81b4b&gt; in &lt;module&gt; 14 import matplotlib.pyplot as plt 15 #import mapomatic as mm ---&gt; 16 IBMQ.save_account('xxxxxxx', overwrite=True) 17 IBMQ.load_account() 18 #provider = IBMQ.get_provider(hub = 'ibm-q') ~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr) 150 self.ibmq = ibmq.IBMQ 151 except ImportError as ex: --&gt; 152 raise MissingOptionalLibraryError( 153 &quot;qiskit-ibmq-provider&quot;, &quot;IBMQ provider&quot;, &quot;pip install qiskit-ibmq-provider&quot; 154 ) from ex MissingOptionalLibraryError: &quot;The 'qiskit-ibmq-provider' library is required to use 'IBMQ provider'. You can install it with 'pip install qiskit-ibmq-provider'.&quot;",<python-3.x><qiskit>,10/05/2022 16:01,73988665.0,73988665.0,It was a Jupyter Notebook issue. Uninstalling and reinstalling it solved the problem.,10/07/2022 14:25
74207230.0,Unable to install tensorflow-quantum using pip,"Using the command pip install tensorflow-quantum gives the following error: ERROR: Could not find a version that satisfies the requirement tensorflow-quantum (from versions: none) ERROR: No matching distribution found for tensorflow-quantum Not sure why the versions is none. Also, not sure how to proceed. I can build from source but need help on this error.",<pypi><tensorflow-quantum>,10/26/2022 11:46,76757032.0,76757032.0,"This is because you are using a python version that does not support TensorFlow Quantum. TensorFlow Quantum is supported on Python 3.7, 3.8, and 3.9. Change your Python version to any of these then try reinstalling.",7/24/2023 18:08
74239149.0,TensorCirucit c.draw() NameError,I want to plot a circuit build with TensorCircuit using the draw method. I am working on Google Colab and have pip installed qiskit. Yet i get NameError: name 'QuantumCircuit' is not defined. I have also tried from qiskit import QuantumCircuit but still i get the same error. Executing the code on another JuypterHub works.,<google-colaboratory><draw><qiskit>,10/28/2022 17:49,74472050.0,74472050.0,pip install qiskit pip install pylatexenc import numpy as np from qiskit import * Once you are done with above code you have to restart your runtime so that installed library come into force into your colab environment. For restarting runtime: Click on Runtime Select Restart runtime Select Run all This help you to rectify your problem.,11/17/2022 8:07
75162746.0,ket.draw() not showing |00> : Qiskit,"ket.draw() must give |00&gt; as result but I get: Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) what can I change to get the desired result? This is my code: from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(2) # This calculates what the state vector of our qubits would be # after passing through the circuit 'qc' ket = Statevector(qc) # The code below writes down the state vector. # Since it's the last line in the cell, the cell will display it as output ket.draw()",<python><quantum-computing><qiskit>,1/18/2023 17:02,75162797.0,75162797.0,"You can pass the keyword argument output='latex' to the .draw method. from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(2) # This calculates what the state vector of our qubits would be # after passing through the circuit 'qc' ket = Statevector(qc) # The code below writes down the state vector. # Since it's the last line in the cell, the cell will display it as output ket.draw(output='latex')",1/18/2023 17:07
76371779.0,Calculating CHSH inequality violation in a two-qubit system with projective measurements,Suppose a two-qubit system is in the state |Î¦â© = (|00â© + |11â© )/ â2. Consider projective measurements with outcome Â±1. Calculate the maximal violation of the CHSH inequality and find the measurement setting that can result the maximal violation. I am new to quantum computing.I don't know how to solve this problem.,<quantum-computing>,5/31/2023 8:58,76427971.0,76427971.0,"I's a tough one and one I struggled with too. Calculating the maximal violation of the CHSH inequality for the given two-qubit state |Î¦â© = (|00â© + |11â© )/ â2, we need to consider four different measurement settings and compute the corresponding expectation values. The CHSH inequality is expressed as follows: CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B') â¤ 2, where A, A' are the measurement settings for the first qubit there, and B, B' are the measurement settings for the second qubit, and E(A, B) is the expectation value for the measurement settings A and B. If that makes sense? Now considering the four measurement settings: Setting 1: A = Ïz (measurement in the computational basis for the first qubit) B = Ïz (measurement in the computational basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïz)|Î¦â©. Expanding the tensor product and substituting |Î¦â© = (|00â© + |11â© )/ â2: E(A, B) = â¨Î¦|(Ïz â Ïz)|Î¦â© = (1/â2)(â¨00|(Ïz â Ïz)|00â© + â¨00|(Ïz â Ïz)|11â© + â¨11|(Ïz â Ïz)|00â© + â¨11|(Ïz â Ïz)|11â©) = (1/â2)(1 + 1 + 1 - 1) = 2/â2 = â2. Setting 2: A = Ïx (measurement in the Hadamard basis for the first qubit) B = Ïz (measurement in the computational basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïz)|Î¦â©. Using the same steps as above, we find: E(A, B) = -1/â2. Setting 3: A = Ïz (measurement in the computational basis for the first qubit) B = Ïx (measurement in the Hadamard basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïx)|Î¦â©. Using the same steps as above, we find: E(A, B) = -1/â2. Setting 4: A = Ïx (measurement in the Hadamard basis for the first qubit) B = Ïx (measurement in the Hadamard basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïx)|Î¦â©. Using the same steps as above, we find: E(A, B) = -â2. Now, let's calculate the maximal violation of the CHSH inequality: CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B') = â2 + (-1/ Hope that helps you.",06/08/2023 00:58
76772726.0,How can I use quantum entanglement to improve the performance of my web application?,"This question blends cutting-edge quantum physics concepts with web application performance, which is not a common topic of discussion on Stack Overflow. While quantum computing and its potential applications are gaining attention, it's still relatively new and not a mainstream topic in web development. However, as technology continues to advance, this type of question may become more relevant in the future. Remember, Stack Overflow is a collaborative platform for programmers, and the questions asked there are usually more focused on practical coding challenges and development issues. Speculative or theoretical questions might not be as common, but who knows what the future will bring? I am expecting a better solution for this!",<web><quantum-computing>,7/26/2023 15:10,76772738.0,76772738.0,"But hey, who knows what the future holds? Technology advances rapidly, and we've seen some incredible breakthroughs in the past. Perhaps one day, we'll find a way to leverage quantum entanglement or other quantum principles to revolutionize how we handle web application performance. Until then, let's keep pushing the boundaries of what's possible in both quantum computing and web development separately. Exciting times are ahead! Remember, innovation often comes from asking daring and unconventional questions, so keep dreaming big and exploring new ideas. Who knows? Your question might just inspire the next big leap in technology!",7/26/2023 15:12
1508.0,"In a Quantum Turing Machine, how is the decision to move along the memory tape made?","Let, for a Quantum Turing machine (QTM), the state set be $Q$, and the alphabet of symbols be $\sum=\{0,1\}$, which appear at the tape head. Then, as per my understanding, at any given time while the QTM is calculating, the qubit that appears at its head will hold an arbitrary vector $V_\sum = a|1\rangle+b|0\rangle$. Also, if $|q_0\rangle , |q_1\rangle, ... \in Q$, then the state vector at that instance will also be an arbitrary vector $V_q=b_0|q_0\rangle + b_1 |q_1\rangle+ ...$. Now, after the instruction cycle is complete, the vectors $V_\sum$ and $V_q$ will decide whether the QTM will move left or right along the Qubit tape. My question is- since Hilbert space formed by $Q \otimes \sum$ is an uncountable infinite set and $\{\text{Left,Right}\}$ is a discrete set, the mapping between them will be difficult to create. So how is the decision to move left or right made? Does the QTM move both left and right at the same time, meaning that the set $\{\text{Left,Right}\}$ also forms a different Hilbert space, and hence the motion of the QTM becomes something like $a|\text{Left}\rangle+b|\text{Right}\rangle$. Or, just like a Classical Turing machine, the QTM moves either left or right, but not both at the same time?",<classical-computing><computational-models><quantum-turing-machine>,3/30/2018 11:30,1592.0,1592.0,"If we have a QTM with state set $Q$ and a tape alphabet $\Sigma = \{0,1\}$, we cannot say that the qubit being scanned by the tape head ""holds"" a vector $a|0\rangle + b|1\rangle$ or that the (internal) state is a vector with basis states corresponding to $Q$. The qubits on the tape can be correlated with one another and with the internal state, as well as with the tape head position. As an analogy, we would not describe a probabilistic Turing machine's global state by independently specifying a distribution for the internal state and for each of the tape squares. Rather, we have to describe everything together so as to properly represent correlations among the different parts of the machine. For example, the bits stored in two distant tape squares might be perfectly correlated, both 0 with probability 1/2 and both 1 with probability 1/2. So, in the quantum case, and assuming we're talking about pure states of quantum Turing machines with unitary evolutions (as opposed to a more general model based on mixed states), the global state is represented by a vector whose entries are indexed by configurations (i.e., classical descriptions of the internal state, the location of the tape head, and the contents of every tape square) of the Turing machine. It should be noted that we generally assume that there is a special blank symbol in the tape alphabet (which could be 0 if we want our tape squares to store qubits) and that we start computations with at most finitely many squares being non-blank, so that the set of all reachable configurations is countable. This means that the state will be represented by a unit vector in a separable Hilbert space. Finally, and perhaps this is the actual answer to the question interpreted literally, the movement of the tape head is determined by the transition function, which will assign an ""amplitude"" to each possible action (new state, new symbol, and tape head movement) for every classical pair $(q,\sigma)$ representing the current state and currently scanned symbol. Nothing forces the tape head to move deterministically -- a nonzero amplitude could be assigned to two or more actions that include tape head movements to both the left and right -- so it is possible for a QTM tape head to move both left and right in superposition. For example, you can imagine a QTM with $Q = \{0,1\}$ and $\Sigma = \{0,1\}$ (and we'll take 0 to be the blank symbol). We start in state 0 scanning a square that stores 1, and all other squares store 0. I won't explicitly write down the transition function, but will just describe the behavior in words. On each move, the contents of the scanned tape square is interpreted as a control bit for a Hadamard operation on the internal state. After the controlled-Hadamard is performed, the head moves left if the (new) state is 0 and moves right if the (new) state is 1. (In this example we never actually change the contents of the tape.) After one step, the QTM will be in an equally weighted superposition between being in state 0 with the tape head scanning square -1, and being in state 1 with the tape head scanning square +1. On all subsequent moves the controlled-Hadamard does nothing because every square aside from square 0 contains the 0 symbol. The tape head will therefore continue to move simultaneously both left and right, like a particle travelling to the left and to the right in superposition. If you wanted to, you could of course define a variant of the quantum Turing machine model for which the tape head location and movement is deterministic, and this would not ruin the computational universality of the model, but the ""classic"" definition of quantum Turing machines does not impose this restriction.",04/04/2018 14:43
2051.0,"Why does job.running in QISKit output False, even if the job is still running?","I submitted a job in the 0.5.0 version of QISKit using job = execute(qc, 'ibmqx5', shots=shots) This just submits the job, and does not wait for a result. I then immediately tested whether the job was still running using print(job.running) This gave the result False. However, when I requested the result using job.result() This still took a while to get the result, suggesting that the job actually was still running after all. What is going on here?",<programming><qiskit>,5/14/2018 13:19,2052.0,2052.0,"There are three stages that the job goes through, as you'll see if you also print the status using print(job.status). The first is an initialization stage. This returns False for job.running, because it hasn't started running yet. Then your job actually will run, and so give True for job.running. Finally it will have finished running, and so job.running goes back to False. So don't use job.running to test whether a result is ready.",5/14/2018 13:19
2282.0,Why is it harder to build quantum computers than classical computers?,"Is it because we don't know exactly how to create quantum computers (and how they must work), or do we know how to create it in theory, but don't have the tools to execute it in practice? Is it a mix of the above two? Any other reasons?",<physical-realization><classical-computing>,06/10/2018 12:34,2285.0,2285.0,"We know exactly, in theory, how to construct a quantum computer. But that is intrinsically more difficult than to construct a classical computer. In a classical computer, you do not have to use a single particle to encode bits. Instead, you might say that anything less than a billion electrons is a 0 and anything more than that is a 1, and aim for, say, two billion of electrons to encode a 1 normally. That makes you inherently fault-tolerant: Even if there are hundreds of millions of electrons more or less than expected, you will still get the correct classification as a digital 0 or a 1. In a quantum computer, this trick is not possible due to the non-cloning theorem: You cannot trivially employ more than one particle to encode a qubit (quantum bit). Instead, you must make all your gates operate so well that they are not just accurate to the single particle level but even to a tiny fraction of how much they act on a single particle (to the so-called quantum-error correction threshold). This is much more challenging than to get gates accurate merely to within hundreds of millions of electrons. Meanwhile we do have the tools to, just barely, make quantum computers with the required level of accuracy. But nobody has, as of yet, managed to make a big one meaning one that can accurately operate on the perhaps hundred of thousands of physical qubits needed to implement a hundred or so logical qubits to then be undeniably in the realm where the quantum computer beats classical computers at select problems (quantum supremacy).",06/10/2018 17:11
2363.0,Will Moore's Law be no longer effective once quantum computers are created?,"Moore's law states that computer power doubles in every 18 months (more formally: ""the number of transistors in a dense integrated circuit doubles about every two years.""). Statistics suggest that this observation should be correct, but aren't quantum computers much more powerful than just double-powered classical computers? More interesting question is, is there even a way to improve the power of quantum computers?",<classical-computing><experiment><scalability>,6/16/2018 9:45,2364.0,2364.0,"but aren't quantum computers much more powerful than just double-powered classical computers? Yes. A universal quantum computer with only 100 qubits (12.5 quantum bytes) can find the ground state of a matrix with $2^{200} = 10^{60}$ elements. Assuming Moore's Law could continue forever (which is not true due to physical limitations), it would take longer than the age of the universe (13.5 billion years) for the ""doubling of transistors every 18 months"" to bring classical computers to what a quantum computer with one quantum gigabyte can do, for certain problems. More interesting question is, is there even a way to improve the power of quantum computers? There have been proposals for exploiting certain types of phenomena that would lead to devices even more powerful than quantum computers, but in all cases quantum computers would be a special case of such devices (just like classical computers are a special case of quantum computers, they are quantum computers that just only use classical gates and inputs that are not in any superposition). It is hard enough to build a quantum computer, so building the more generalized devices would be even harder.",6/16/2018 17:31
2477.0,Phase-Shift Gate in Qiskit,How to implement the phase shift gate in qiskit or ibmq? Phase Shift Gate : $$\begin{pmatrix}e^{ia} &amp;&amp; 0 \\ 0 &amp;&amp; e^{ia}\end{pmatrix} = e^{ia}I$$,<programming><qiskit><ibm-q-experience>,6/26/2018 16:52,2478.0,2478.0,"You can implement the phase shift gate $$P_h(\theta) = \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix}$$ with the X and u1 gate from the IBM Q chips: $$ \begin{align} P_h(\theta) &amp;= U_1(\theta)\ X\ U_1(\theta)\ X \\ &amp;= \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \\ &amp;= \begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix}\begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix} \\ &amp;= \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \end{align}$$ So: def Ph(quantum_circuit, theta, qubit): quantum_circuit.u1(theta, qubit) quantum_circuit.x(qubit) quantum_circuit.u1(theta, qubit) quantum_circuit.x(qubit) implements the $P_h$ gate on Qiskit.",6/26/2018 17:05
3846.0,List of qubit locations with cirq,"As far I understand, qubits in cirq are labelled by their positions on chip. For example print( cirq.google.Foxtail.qubits ) yields frozenset({GridQubit(0, 1), GridQubit(1, 9), GridQubit(0, 2), ... I would like to get a simpler version of the above, namely a simple array of tuples for the positions of all qubits [ (0,1), (0,2), (0,3), ..., (1,1), (1,2), (1,3), ... ] What is the easiest way to obtain this for a given known device in cirq?",<programming><cirq>,7/23/2018 9:39,3849.0,3849.0,"GridQubit has comparison methods defined, so sorted will give you a list of the qubits in row-major order: &gt;&gt;&gt; sorted(cirq.google.Foxtail.qubits) [GridQubit(0, 0), GridQubit(0, 1), [...] GridQubit(1, 9), GridQubit(1, 10)] Once you have that, you're one list comprehension away: &gt;&gt;&gt; [(q.row, q.col) for q in sorted(cirq.google.Foxtail.qubits)] [(0, 0), (0, 1), [...] (1, 9), (1, 10)] Because tuples also have a default ordering, it doesn't matter whether you sort before or after the conversion: &gt;&gt;&gt; sorted((q.row, q.col) for q in cirq.google.Foxtail.qubits) [(0, 0), (0, 1), [...] (1, 9), (1, 10)]",7/23/2018 12:08
3902.0,Are classical bits quantum?,"A bit is a binary digit, typically 0 or 1. Until a value is assigned (or a measurement is made) a bit is in a superposition of the entangled binary pair, is it not?",<classical-computing>,7/31/2018 1:55,3905.0,3905.0,"A bit, either 0 or 1, can certainly be thought of as a special case of being a qubit. However, that is not to say that anything capable of computing with classical bits is capable of computing with quantum bits. If you have a bit, and donât know if itâs a 0 or a 1, then how do you describe its state? You have to use Bayesian priors. If you have no idea which it is, you assign the two options equal probabilities. And it really is probabilities here. So itâs 50:50 being in 0 or 1. You canât describe this as a pure quantum state, but you can use a density matrix: $$\rho=(|0\rangle\langle 0|+|1\rangle\langle 1|)/2.$$ This formalism also means that if you later learn something about what the bit value might be (perhaps as a result of reading other bits in a computation), you can update those probabilities using conditional probabilities and Bayesâ rule. Note that this also means itâs a subjective description of the state: it reflects your personal knowledge of the state of the bit, while somebody else, who perhaps prepared the bit, already knows what value it has. This is perhaps one way to see why it should be different from the pure state that you proposed, which should be an objective description that everyone would agree on (in that there is no uncertainty in the state; the only uncertainty is induced by the action of the measurement).",7/31/2018 5:26
3908.0,"Possibility of a ""reset"" quantum gate","I wish to have a ""reset"" gate. This gate would have an effect to bring a qubit to the $\mid0\rangle$ state. Clearly, such a gate is not unitary (and so I'm unable to find any reliable implementation in terms of universal gates). Now for my particular needs, I need this ability to reset a qubit or a quantum register to that state so users can always start from $\mid0\rangle$. I'm making a small programming language that transpiles to QASM, and when a function is exited, I want all local (quantum) variables (qubits) reset to $\mid0\rangle$ so they can be reused. QASM reset instruction does not work on the real processor. I think that something to this effect may be achieved with quantum phase estimation but I'm wondering if there is another way.",<quantum-gate><programming>,7/31/2018 12:05,3909.0,3909.0,"One way is simply to measure the qubit in the standard, $Z$, basis. If you get the answer 0, then you've got the state you want. Otherwise, you apply a bit-flip to it. Indeed, if you want to implement a non-unitary operation, you need some sort of measurement operation somewhere, whether that's a direct measurement, or the implementation of a CP map or POVM (but for these options, you need to introduce ancillas of a fixed state, which rather negates the point). Or you could use noise in the system, but you are unlikely to have sufficient control of it - it's noise after all! Of course, none of these options just reset a single qubit; anything that qubit is entangled with is also affected, but that's kind of in the definition of ""reset"" in the quantum context. The only other option is to uncompute, but this is not a generic option because, generically you have to uncompute the entire computation to reset even a single qubit, and that resets everything. Except it doesn't work perfectly because of errors. You would be better starting a new computation. There are specific scenarios where an ancilla qubit is used and it can be uncomputed, but this is typically built into the algorithm because the uncomputation step is important for getting rid of some unwanted entanglement that would otherwise appear.",7/31/2018 12:21
3935.0,"How do we code the matrix for a controlled operation knowing the control qubit, the target qubit and the $2\times 2$ unitary?","Having n qubits, I want to have the unitary described a controlled operation. Say for example you get as input a unitary, an index for a controlled qubit and another for a target. How would you code this unitary operation?",<quantum-gate><programming><gate-synthesis>,08/04/2018 11:05,3941.0,3941.0,"Hereâs some pseudo code, where id(n) creates an $2^n\times 2^n$ identity matrix, and tensor(A,B,...) returns $A\otimes B\otimes\ldots$. def cU(ctrl,targ,U,size): '''implement controlled-U with: control qubit ctrl, target qubit targ, within a set of size qubits''' #check input ranges assert 1&#60;=ctrl&#60;=size assert 1&#60;=targ&#60;=size assert ctrl&#60;&#62;targ assert ctrl,targ,size &#8714; &#8484; #ensure U is a 2x2 unitary assert U&#8714;&#8450;2x2 assert U.U&dagger;=id(2) #the actual code if ctrl&#60;targ: return id(size)+tensor(id(ctrl-1),id(1)-Z,id(targ-1-ctrl),U-id(1),id(size-targ))/2 else: return id(size)+tensor(id(targ-1),U-id(1),id(ctrl-1-targ),id(1)-Z,id(size-ctrl))/2 However, remember that usually you're trying to calculate the action of a unitary on some state vector. It will be far more memory efficient to calculate that application directly, rather than first calculating the unitary matrix and applying it to the state vector. To understand where this formula came from, think about the two-qubit version, where the first qubit is the control qubit. You'd normally write the unitary as $$ |0\rangle\langle 0|\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U. $$ Let's rewrite this as $$ (\mathbb{I}-|1\rangle\langle 1|)\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U=\mathbb{I}\otimes\mathbb{I}+|1\rangle\langle 1|\otimes (U-\mathbb{I}). $$ It can be easier to write things in terms of Pauli matrices, so $$ |1\rangle\langle 1|=(\mathbb{I}-Z)/2. $$ To get the same unitary on a different number of qubits, you just need to pad with identity matrices everywhere.",08/05/2018 05:14
4268.0,"How to construct the ""Inversion About the Mean"" operator?","It seems like it should be simple, based on how Nielsen and Chuang talk about it, but I cannot seem to correctly implement the Inversion About the Mean operator ($2|\psi\rangle \langle\psi| - \mathcal{I}$) that is used in the Grover search algorithm, especially without using any ancilla bits. I thought about performing a NOT operation on all the working qubits, then performing a controlled-NOT on a separate toggle qubit with the control being all the working qubits, then performing a controlled phase flip with control of the toggle bit, and finally flipping the phase of all the states. I'm not sure how I'd actually implement the controlled phase flipping, though, since, I believe, phase flipping one or all of the bits would not produce the desired effect. Does anyone know how I can construct this? I am using Q#, by the way, if you'd like to answer in code.",<programming><q#>,9/22/2018 21:31,4269.0,4269.0,"First, let's represent operation $2|\psi\rangle \langle\psi| - \mathcal{I}$ as $H^{\otimes n}(2|0\rangle \langle0| - \mathcal{I})H^{\otimes n}$, as Nielsen and Chuang do. Doing $H^{\otimes n}$ is easy - it's just ApplyToEach(H, register). $2|0\rangle \langle0| - \mathcal{I}$ flips the phase of all computational basis states except $|0...0\rangle$. Let's do instead $\mathcal{I} - 2|0\rangle \langle0|$, flipping the phase of only $|0...0\rangle$ (it introduces a global phase of -1 which in this case I think can be ignored). To flip the phase of only $|0...0\rangle$: flip the state of all qubits using ApplyToEach(X, register). Now we need to flip the phase of only $|1...1\rangle$ state. do a controlled-Z gate on one of the qubits (for example, the last one), using the rest as control. This can be done using Controlled functor: (Controlled Z)(Most(register), Tail(register)). Tail returns the last element of the array, and Most returns all elements except the last one. flip the state of all qubits again to return them to the original state.",9/22/2018 23:57
4367.0,"How to make ""random U3"" in QASM?","I want to make an operator: $\mathrm{U3}(\arccos(\sqrt p),0,0)$, when $p$ is a random value between $0$ and $1$ How do I write code in QASM language of this ""random $\mathrm{U3}$"" operator?",<programming><qasm>,10/07/2018 16:27,4376.0,4376.0,"There are many forms of QASM, so I'll answer for OpenQASM 2.0, as is currently used by IBM. Declaring a gate to be random means that it would be randomly generated at compile time. Since QASM is used as an expression of a compiled circuit, such randomness must be resolved by the time the QASM is created. It is true that are transpilation processes in the IBM stack, which convert a user generated QASM into one optimized for the needs of a given device. This could allow for the functionality your desire to be built into future versions. But I doubt that will be the case. It is much easier just to use randomness when generating the QASM, such as with Pythons random number generation when creating circuits with Qiskit. Disclaimer: I work for IBM.",10/09/2018 08:41
4531.0,Can we speed up the Grover's Algorithm by running parallel processes?,"In classical computing, we can run the key search (for example AES) by running parallel computing nodes as many as possible. It is clear that we can run many Grover's algorithms, too. My question is; it possible to have a speed up using more than one Grover's algorithm as in classical computing?",<classical-computing><grovers-algorithm><cryptography>,10/24/2018 20:06,4538.0,4538.0,"Certainly! Imagine you have $K=2^k$ copies of the search oracle $U_S$ that you can use. Normally, you'd search by iterating the action $$ H^{\otimes n}(\mathbb{I}_n-2|0\rangle\langle 0|^{\otimes n})H^{\otimes n}U_S, $$ starting from an initial state $(H|0\rangle)^{\otimes n}$. This takes time $\Theta(\sqrt{N})$. (I'm using $\mathbb{I}_n$ to denote the $2^n\times 2^n$ identity matrix.) You could replace this with $2^k$ parallel copies, each indexed by an $x\in\{0,1\}^k$, using $$ \left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)\mathbb{I}_k\otimes(\mathbb{I}_{n-k}-2|0\rangle\langle 0|^{\otimes (n-k)})\left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)U_S $$ and starting from a state $|x\rangle(H|0\rangle)^{\otimes(n-k)}$ The time required for running these would be reduced to $O(\sqrt{N/K})$, at the cost of requiring $K$ times more space. In a scaling sense, one might consider this an irrelevant result. If you have a fixed number of oracles, $K$, then you get a fixed ($\sqrt{K}$) improvement (just like, if you have $K$ parallel classical cores, the best improvement you can get is a factor of $K$), and that does not change the scaling. But it does change the fundamental running time. We know that Grover's algorithm is exactly optimal. It takes the absolute minimum time possible with a single oracle. So, knowing that you get a $\sqrt{K}$ improvement in time is useful with regards to that benchmark of a specific running time at a specific value of $N$.",10/25/2018 8:02
4810.0,Implementing gate with two parameters using Qiskit in Python,"I am trying to implement the HHL algorithm (for solving $Ax=b$). I am assuming $A$ to be unitary and Hermitian so that I can find the Hamiltonian simulation for it easily. For any $A$ to be Hermitian and unitary, it has to be of form, $$ A = \begin{pmatrix} x &amp; \pm\sqrt{1-x^2}\\ \pm\sqrt{1-x^2} &amp; x\end{pmatrix} $$ I reduced $e^{i\alpha A}$ to following (by using formula $e^{i\theta A} = (\cos\theta)I + i(\sin\theta)A$ where $A^2=I$), but I don't know how to implement it on Qiskit. $$ e^{i\alpha A} = \begin{pmatrix} \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} &amp; i\sin\alpha \sin\frac{\theta}{2} \\ i\sin\alpha \sin\frac{\theta}{2} &amp; \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} \end{pmatrix} .$$ where $\theta = 2\cos^{-1}{x}$. How to construct this gate?",<quantum-gate><programming><qiskit><gate-synthesis><hhl-algorithm>,11/26/2018 12:57,4812.0,4812.0,"(Remark: I have corrected a typo in the matrix exponentiation). Please notice that the matrix has the form: $$ e^{i\alpha A} = \begin{pmatrix} a &amp; b \\ b &amp; a \end{pmatrix} $$ with $$|a|^2 + |b|^2 = 1$$ Now, please notice that this matrix can be expanded as: $$\begin{pmatrix} a &amp; b \\ b &amp; a \end{pmatrix} = \begin{pmatrix} e^{i \arg(a)} &amp; 0 \\ 0 &amp; e^{i \arg(a)} \end{pmatrix} \begin{pmatrix} |a | &amp; i|b| \\ i|b |&amp; |a| \end{pmatrix} $$ Defining $$ |a| = \cos \phi$$ $$ |b| = \sin \phi$$ Thus we obtain: $$ e^{i\alpha A} = e^{i \arg(a) I_2} e^{i\phi \sigma_x} $$ In short, the result constitutes of an overall phase multiplication and an $R_x$ gate. Expressed in the question's original variables: $$\arg(a) = \arctan (\tan \alpha \cos \frac{\theta}{2})$$ and $$\phi = \arcsin (\sin \alpha \sin \frac{\theta}{2})$$",11/26/2018 14:19
4907.0,qiskit - Is there any way to discard the results of a measurement?,"I have a circuit composed by n qubits, plus a single one which is an ancilla. I'm making multiple measurements on the ancilla at different stages of the circuit, while working on the n qubits. These measurements are not really needed at all: they are just a way to collapse the state of the qubit at some point during the computation and then reuse the same qubit in a different way. At the end of the circuit, when I'm measuring the outcome of the n qubits, I don't want the result of this ancilla to be shown in the output of the get_counts() function; what I want is only the output of the n qubits. Is there any way to achieve this result?",<circuit-construction><programming><measurement><qiskit>,12/11/2018 10:46,4971.0,4971.0,"If you keep measuring to the same bit, the value should get overridden every time. So you won't receive the intermediary values. For example, the following will output a single 1 from the second measurement, with no trace of the first. from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit from qiskit import execute from qiskit import BasicAer q = QuantumRegister(1) c = ClassicalRegister(1) qc = QuantumCircuit(q,c) qc.measure(q,c) qc.x(q) qc.measure(q,c) job = execute(qc,backend=BasicAer.get_backend('qasm_simulator')) job.result().get_counts() I guess what you want is something more like q = QuantumRegister(n) # n qubits a = QuantumRegister(1) # one ancilla qubit c = ClassicalRegister(n) # n classical bits for output qc = QuantumCircuit(q,a,c) qc.x(a[0]) qc.measure(a[0],c[0]) # measure the ancilla to one of the classical bits qc.measure(q,c) # measure the n qubits to the n bits (overwriting the output from the previous measurement",12/15/2018 17:32
5075.0,How do I name the adjoint of an operation in Q#?,"For example, if I've defined the operation PlusEqual, I'd like to say operation MinusEqual = Adjoint PlusEqual; but this produces a syntax error. Is the only way to do this by exhaustively re-listing all arguments and functors? operation MinusEqual (all_args_and_types_again) : ReturnType { body (...) { return Adjoint AddEqual(all_args); } adjoint auto; controlled auto; controlled adjoint auto; }",<programming><q#>,12/29/2018 16:38,5077.0,5077.0,"You can define an immutable symbol for MinusEqual inside the body of an operation which will use it (you can't define it globally): operation UseMinusEqual () : Unit { ... let MinusEqual = Adjoint PlusEqual; MinusEqual(...); } If you need MinusEqual to be a globally visible operation, there is no shorthand syntax for this right now, so the only way to do it is a full operation definition like you say.",12/29/2018 18:57
5109.0,Representing a real valued vector with qubits,"I have some understanding that with qubits, I can represent a $2^n$ size vector using only $n$ qubits. However, I'm having trouble putting this together in a way that can make a useful circuit. Say I want to represent the input $(0 \ 0 \ 0 \ 1)$ for my circuit. I should be able to do this with only 2 qubits. Starting with the initial state $|0\rangle|0\rangle$, which as far as I know represents the vector $(1 \ 0 \ 1 \ 0)$, I can use a not gate on the second qubit to transform that to $(1 \ 0 \ 0 \ 1)$. However, I'm not sure what operation I can do to put the first qubit into a $(0 \ 0)$ state. On top of that, I have even less of an idea of how to represent real-value vectors, like $(0.5 \ 0.5)$ (assuming including a normalization constant). I have a feeling I can use phase, but I'm not sure how to set up a circuit to achieve this. Edit: Realized my earlier representation was very off. The initial state $|00\rangle$ is the same as the vector $(1 \ 0 \ 0 \ 0)$, so transforming that into the the desired $(0 \ 0 \ 0 \ 1)$ Would just require two NOT gates: 0 -- NOT -- 1 0 -- NOT -- 1 However, I'm still unsure how to represent real-valued vectors, or even a vector like $(1 \ 0 \ 1 \ 0)$.",<quantum-state><programming>,01/02/2019 21:11,5111.0,5111.0,"$(1,0,1,0)$ means $$ 1 (1,0,0,0) + 1 (0,0,1,0) $$ and you already know how $| 0 0 \rangle$ and $(1,0,0,0)$ correspond. To make $(0,0,1,0)$ the encoding would be $| 1 0 \rangle$. I'm assuming you are reading the entries as 0,1,2,3 in that order for the vector and the first qubit corresponds to the most significant bit. (Little vs Big endian). If not, make the necessary changes. So all together you need $1 | 00 \rangle + 1 | 10 \rangle$. For other combinations like $(a_0 , 0 , a_2 , 0)$ change the coefficents. $a_0 | 00 \rangle + a_2 | 10 \rangle$",01/02/2019 23:31
5144.0,Can I remove gates from a QuantumCircuit?,"Suppose I want to implement run several circuits one after another, but they are constructed in a similar fashion. I could reinstantiate a QuantumCircuit for each iteration, like this: params = np.linspace(0, 2 * np.pi, num=20) for p in params: circ = QuantumCircuit(q, c) do_stuff(circ, p) do_other_stuff() but I'm afraid that creating a bunch of unnecessary circ objects takes too much memory or too many calls to the garbage collector. Instead, I would like to remove the gates from the QuantumCircuit object and build the new circuit in the old object. Is it possible, and if so, is it reasonable?",<programming><qiskit>,01/08/2019 17:51,5209.0,5209.0,"Quantum circuits have a data attribute, which is a list of all gates. You can remove elements from this as with any Python list. For example, here's a circuit q = QuantumRegister(1) circ = QuantumCircuit(q) circ.h(q[0]) circ.s(q[0]) circ.x(q[0]) Let's get rid of the S gate. First, we can look at the list of gates with circ.data. This gives [&lt;qiskit.extensions.standard.h.HGate at 0x11721b7b8&gt;, &lt;qiskit.extensions.standard.s.SGate at 0x11721b828&gt;, &lt;qiskit.extensions.standard.x.XGate at 0x11721b7f0&gt;] Element 1 of this list (i.e. the second element) is the gate we want rid of. We can do this with pop. qiskit.data.pop(1) The resulting circuit can then be seen by print(circ) ââââââââââ q0_0: |0&gt;â¤ H ââ¤ X â ââââââââââ As you can see, we have succeeded in removing the S gate. Note that you can get information about the elements of the data list using the methods name and qargs, etc, of gate objects. For example, to see that element 0 is a Hadamard, and to see which qubit it acts on, we can use print( circ.data[0].name ) print( circ.data[0].qargs ) This returns h [(QuantumRegister(1, 'q0'), 0)]",1/15/2019 14:53
5156.0,How do I get a list of control qubits from Q# operations when tracing the simulation in C#?,"I want to write code that prints out the controls of each operation executed during a simulation in Q#. For example this code prints the control counts: var qsim = new QCTraceSimulator(config); qsim.OnOperationStart += (op, arg) =&gt; { Console.WriteLine($""{Controls(op, arg).Length""}); } I'm having trouble writing the Controls function, which extracts a list of qubits being used as controls. When the operation is uncontrolled, or controlled by 0 qubits, the returned array should be of length 0. The issue I'm running into is that the type and layout of arg.Value varies from operation to operation, even after conditioning on op.Variant being OperationFunctor.ControlledAdjoint or OperationFunctor.Controlled. I can handle individual cases by inspecting the types, but I keep running into new unhandled cases. This indicates there's probably a ""correct"" way to do this that I'm missing. In short, how do I implement this function: object[] Controls(ICallable op, IApplyData arg) { ??? } By ""controls"" I always mean the cs in Controlled Op(cs, ...). The same operation may have different controls when expressed in different ways. For example, the controls list of Controlled Toffoli(a, (b, c, d)) is the list [a] whereas the controls list of Controlled X([a, b, c], d) is the list [a, b, c]. A further example: the controls list of Toffoli(b, c, d) is [], even though normally one might think of the first two arguments as the controls. It is of course expected that within Toffoli(b, c, d) there may be a sub-operation Controlled X((b, c), d) where the controls list is [b, c]; I'm not thinking of controls as some kind of absolute concept that is invariant as you go down through layers of abstraction.",<programming><q#>,01/09/2019 22:37,5157.0,5157.0,"arg.Value contains the actual tuple that the controlled operation receives at runtime. It's a two item tuple in which the first item is the control qubits, and the second another tuple with the arguments the operation normally expects, so in your case you are only interested in the first item of this tuple. Overall, arg.Value can be anything, thus it has object as type, but fear not, using a little bit of C#'s reflection is easy to retrieve its content. The implementation you are looking for is this: static Qubit[] Controls(ICallable op, IApplyData arg) { // Uncontrolled operations have no control qubits. if (op.Variant != OperationFunctor.Controlled &amp;&amp; op.Variant != OperationFunctor.ControlledAdjoint) { return new Qubit[0]; } // Get the first item of the (controls, args) tuple. dynamic v = arg.Value; QArray&lt;Qubit&gt; ctrls = v.Item1; return ctrls.ToArray(); } Notice the array of Qubits is encapsulated in something called a QArray&lt;Qubit&gt;, QArray is the data structure we use in simulation for all Q# arrays.",01/09/2019 23:42
5159.0,TypeError: unorderable types: QuantumRegister() >= int(),"I've been using qiskit for about a year now, and as of late, I've had issues finding an available backend to run my circuit on. Looking into the matter, I reinstalled qiskit to find that most everything had changed quite a bit. Now when I try to run just a basic test circuit program, taken from the tutorial I get this: ~$ python3 test.py Traceback (most recent call last): File ""test.py"", line 27, in &lt;module&gt; job = execute(circ, backend) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 108, in execute skip_transpiler, seed_mapper, pass_manager, memory) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 67, in compile coupling_map=coupling_map, seed=seed, memory=memory) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 61, in circuits_to_qobj coupling_map)) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 92, in _circuit_to_experiment json_circuit = DagUnroller(dag, JsonBackend(dag.basis)).execute() File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 38, in execute self._process() File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 161, in _process self.backend.new_qreg(name, width) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_jsonbackend.py"", line 98, in new_qreg assert size &gt;= 0, ""invalid qreg size"" TypeError: unorderable types: QuantumRegister() &gt;= int() Does anybody know how to resolve this? Thanks. Edit: This is the code I tried to run, which I just copied from a tutorial: import numpy as np from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute # Create a Quantum Register with 3 qubits. q = QuantumRegister(3, 'q') # Create a Quantum Circuit acting on the q register circ = QuantumCircuit(q) # Add a H gate on qubit 0, putting this qubit in superposition. circ.h(q[0]) # Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting # the qubits in a Bell state. circ.cx(q[0], q[1]) # Add a CX (CNOT) gate on control qubit 0 and target qubit 2, putting # the qubits in a GHZ state. circ.cx(q[0], q[2]) # Import Aer from qiskit import BasicAer # Run the quantum circuit on a statevector simulator backend backend = BasicAer.get_backend('statevector_simulator') # Create a Quantum Program for execution job = execute(circ, backend) result = job.result() outputstate = result.get_statevector(circ, decimals=3) print(outputstate)",<programming><qiskit>,01/10/2019 02:57,5168.0,5168.0,"The code you provide works fine for me, so I guess that something is wrong with your installation. I recommend running the command pip uninstall qiskit and also pip uninstall qiskit-terra pip uninstall qiskit-aqua pip uninstall qiskit-aer and then reinstalling with pip install qiskit",01/10/2019 13:58
5197.0,Why won't Qiskit ccx gate accept registers?,"In Qiskit, they have the concept of a Toffoli gate (ccx). However, the following code throws an error: from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute, Aer q1 = QuantumRegister(2) qctrl = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q1, qctrl, c) qc.x(q1) qc.ccx(q1[0], q1[1], qctrl) qc.measure(q1, c) backend_sim = Aer.get_backend('qasm_simulator') job_sim = execute(qc, backend_sim) result_sim = job_sim.result() print(result_sim.get_counts(qc)) According to my knowledge and research, this should produce the output 111 but instead I get an error message: qiskit.qiskiterror.QiskitError: ""QuantumRegister(1, 'q0') is not a tuple. A qubit should be formated as a tuple."" This seems like a bug with Qiskit to me. Am I wrong? And if so, how can I fix my code?",<programming><qiskit>,1/14/2019 7:44,5198.0,5198.0,"It is not a bug. Qiskit makes the difference between quantum registers and quantum bits. In your case, qctrl is a QuantumRegister (as shown in your error) whereas the ccx gate expect a qubit. For Qiskit, a qubit is defined as a Tuple of a QuantumRegister and an index. You can get a qubit from a QuantumRegister by using the indexing notation: qtrl[0] represents the first qubit (and the only one) of the QuantumRegister qctrl. In summary, replace qc.ccx(q1[0], q1[1], qctrl) by qc.ccx(q1[0], q1[1], qctrl[0]) and your issue should be fixed.",1/14/2019 8:32
5308.0,Qiskit: 'per shot' result,"Is there a way to access the results of measurements 'per shot' performed on a backend such as one of the real IBM machines? I know it can generate a histogram from the cumulative data, but I was wondering if it is possible to see what the measurement outcomes were for a particular shot out of the standard 1024.",<programming><qiskit><ibm-q-experience>,1/29/2019 19:41,5309.0,5309.0,"There is indeed. You just need to use get_memory() instead of get_counts() (and also use a memory=True flag in the execute function. It works with the local qasm simulator and the 5 qubit device (and not currently with the cloud-based qasm simulator or 14 qubit device). Here's an example using it to generate a series of random bits. q = QuantumRegister(1) c = ClassicalRegister(1) circ = QuantumCircuit(q, c) circ.h(q) circ.measure(q,c) job = execute(circ, Aer.get_backend('qasm_simulator'), shots=10024, memory=True) data = job.result().get_memory()",1/30/2019 2:26
5364.0,Why is Grover's algorithm not converging monotonically? (Python implementation),"I have tried to implement Grover's algorithm for three qubits in python/numpy and the first two iterations work like a charm but the third one starts to diverge. Is this expected, or is there a bug in the code? I expected the inversion around the mean to blow up the coefficient of the marked state in each iteration. The code follows Nielsen closely, with a silly Oracle that hard-codes the negation of the basis state. The Python code requires a little bit of set-up but the essential idea is: Define a phase shift operator of -1 on all basis states except zero. Define a reflection around the mean operator as Hadamard â Phase Shift â Hadamard. Define the full Grover step as the Oracle followed by the reflection. Start with an equally balanced state. Repeatedly apply the Grover step. Source code: import numpy as np def dagger(m): return np.transpose(np.conjugate(m)) def proj(m): return m * dagger(m) # identity matrix for 3 qubits = 8x8 matrix id3 = np.identity(2**3) # hadamard matrix for 1, 2 and 3 qubits H1 = np.matrix([[1.0, 1.0], [1.0, -1.0]], dtype=np.complex256) / np.sqrt(2) H2 = np.kron(H1, H1) H3 = np.kron(H2, H1) # 3 qubit zero vector |000&gt; zero3 = np.array([[1],[0],[0],[0],[0],[0],[0],[0]], dtype=np.complex256) # phase shift operator 2*|0&gt;&lt;0| - I for 3 qubits PS3 = 2 * proj(zero3) - id3 # reflection around the mean R = H3 * PS3 * H3 # 3 qbit oracle, marking/negating state |101&gt; = column vector (0 0 0 0 0 1 0 0) O = id3 O[5,5] = -1 # grover operator G = R * O # start state |000&gt; x0 = H3 * zero3 # apply grover step three times x1 = G * x0 print x1 x2 = G * x1 print x2 x3 = G * x2 print x3 The output of the program is shown below. The coefficient (driving the probability) for the state to search for is 0.88 after one iteration, then 0.97 but then falls back to 0.57. Am I missing any essential step in the algorithm? [[ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.88388348+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j]] [[-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [ 0.97227182+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j]] [[-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [ 0.57452426+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j]]",<programming><grovers-algorithm>,02/03/2019 22:33,5365.0,5365.0,"This seems normal by applying the definition of the inversion about average operator which transforms the amplitudes $\alpha_i $ by the formula : $$ - \alpha_i + 2 \langle\alpha\rangle\,, $$ Apply this to your example (using the above formula for each step to verify your intermediary steps) and you should retrieve this numbers. This operator is periodic. After the maximum number of operations giving you the highest probability of the desired state to be measured, you will reset the amplitudes if you apply it another time, meaning you have to reapply again to amplify its amplitude the same way.",02/03/2019 23:01
5471.0,Is programming in quantum computer same as programming in quantum simulator in classical computer?,"I just started programming in Q# and I wonder if the coding for Q# in classical computer would be the same as coding in a quantum computer. Obviously, these 2 kinds of computers work differently, so I guess the language must be working differently as well. Does this affect the coding part in any way (syntax, dealing with operations and variables etc.)?",<programming><q#>,02/12/2019 13:54,5475.0,5475.0,"Running programs on a quantum computer will indeed require some routines which are not required for running them on a classical simulation. Two easiest examples are error correction (a classical simulation is perfect but a quantum device will be noisy and will require error correction to produce useful results) and translating logical qubits and gates to physical ones (in a simulation you can do any gate on any pair of qubits, but a physical device will be limited to certain set of primitive gates and a certain connectivity scheme). However, the person writing high-level quantum code is likely uninterested in such low-level routines (unless they are researching them specifically), same as a person writing this answer doesn't really want to care about the addresses of the bytes storing it on their computer. High-level programming languages (in particular Q#, since you asked about it) aim to provide a high-level abstraction for the programmer and delegate low-level routines to the compiler. This also allows to run the same code on the simulators (for debugging and resource estimation purposes) and then to take it to a quantum device without modifications.",02/12/2019 17:48
5494.0,How to set a starting state in cirq?,I'm learning how to use the cirq library. Every time I set up a circuit the starting state of the qubits is $|0000..0\rangle$. Is there any way to make the starting state different? I'm thinking of somehow giving as input some np.array (vector) to the circuit so that the system initializes with such state. I know I could build a circuit to prepare the state I want but I would like a shorter way to do this. Thanks!,<programming><cirq>,2/15/2019 13:22,5496.0,5496.0,"Cirq distinguishes between ""running"" a circuit, which is generally supposed to act like hardware would (e.g. only getting samples), and ""simulating"" a circuit, which has more freedom. Most ""simulate"" methods, like cirq.Simulator().simulate(...) have a parameter initial_state which can either be a computational basis state (specified as an integer e.g. initial_state=0b000111000) or a state vector (specified as a numpy array e.g. initial_state=np.array([0.5, -0.5, 0.5j, 0.5])). For ""run"" methods, like cirq.Simulator().run(...), there is no way to specify the initial state because that's how it works in hardware. If you want a specific state, you have to make it with gates.",2/15/2019 17:42
5867.0,Qiskit DAG circuit - print information about individual gate/node by number,"I created a DAG circuit in Qiskit and don't really understand how to see which gate is which. I want to call a function like dag_circuit.gate_info(gate_number), which will then print, for example, that gate number 9 is a hadamard gate $H$, and that gate number 11 is a $U_3(\theta=0.1,\phi=0.2,\lambda=-0.5)$. How do I get this information?",<programming><qiskit>,04/06/2019 20:31,5882.0,5882.0,"NOTE: At the moment this method is correct, however, this information might be out of date once the 0.9 release of Qiskit is deployed. Hi Samuel, if you have a dag circuit and you want to access information about the nodes, you need to call dag_circuit.multi_graph.nodes[index_of_node] The information you can get from a node in the circuit is a dictionary containing the following: type (either ""in"", ""out"", or ""op"") name (either a qubit, classical bit, or an operation name) wire (the Register Object of the qubit or classical bit that the wire is attached to) An ""op"" node will will have these other values in addition to the ones above (excluding the ""wire"" value): 'op' (The data type of the operation) qargs (The qubits this gate is applied to) cargs (The classical bits this gate is applied to) condition In your example where you have an $H$ Gate at node 9 and a $U_3(\theta=0.1, \phi=0.2, \lambda=-0.5)$ Gate at node 11, if you were to call print(dag_circuit.multi_graph.nodes[8]) and print(dag_circuit.multi_graph.nodes[10]), you would receive the following output: {'type': 'op', 'op': &lt;qiskit.extensions.standard.h.HGate object at ""some_memory_address""&gt;, 'name': 'h', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None} {'type': 'op', 'op': &lt;qiskit.extensions.standard.u3.U3Gate object at ""some_memory_address""&gt;, 'name': 'u3', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None}",04/09/2019 14:37
5869.0,(name of gate) is not in the list of basis operations,"I'm trying to define a custom gate for my computations. I decided to copy the structure in one of the files in qiskit.extensions.standard package. Here is the code of h.py (Hadamard gate): # -*- coding: utf-8 -*- # Copyright 2017, IBM. # # This source code is licensed under the Apache License, Version 2.0 found in # the LICENSE.txt file in the root directory of this source tree. # pylint: disable=invalid-name """""" Hadamard gate. """""" from qiskit.circuit import Gate from qiskit.circuit import QuantumCircuit from qiskit.circuit import InstructionSet from qiskit.circuit import QuantumRegister from qiskit.qasm import pi from qiskit.dagcircuit import DAGCircuit from qiskit.extensions.standard import header # pylint: disable=unused-import from qiskit.extensions.standard.u2 import U2Gate class HGate(Gate): """"""Hadamard gate."""""" def __init__(self, qubit, circ=None): """"""Create new Hadamard gate."""""" super().__init__(""h"", [], [qubit], circ) def _define_decompositions(self): """""" gate h a { u2(0,pi) a; } """""" decomposition = DAGCircuit() q = QuantumRegister(1, ""q"") decomposition.add_qreg(q) decomposition.add_basis_element(""u2"", 1, 0, 2) rule = [ U2Gate(0, pi, q[0]) ] for inst in rule: decomposition.apply_operation_back(inst) self._decompositions = [decomposition] def inverse(self): """"""Invert this gate."""""" return self # self-inverse def reapply(self, circ): """"""Reapply this gate to corresponding qubits in circ."""""" self._modifiers(circ.h(self.qargs[0])) def h(self, q): """"""Apply H to q."""""" if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.h((q, j))) return instructions if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.h(q)) return instructions self._check_qubit(q) return self._attach(HGate(q, self)) QuantumCircuit.h = h Trying to change the names of the class, the property of QuantumCircuit and the name string in Gate constructor results in an exception (name of the gate) is not in the list of basic operations if I try to either draw or execute an example circuit containing the gate. "" """" [1]-const gate. """""" from qiskit.circuit import Gate from qiskit.circuit import QuantumCircuit from qiskit.circuit import InstructionSet from qiskit.circuit import QuantumRegister from qiskit.qasm import pi from qiskit.dagcircuit import DAGCircuit from qiskit.extensions.standard import header # pylint: disable=unused-import from qiskit.extensions.standard.u2 import U2Gate class OneConstGate(Gate): def __init__(self, qubit, circ=None): super().__init__(""oneconst"", [], [qubit], circ) def _define_decompositions(self): decomposition = DAGCircuit() q = QuantumRegister(1, ""q"") decomposition.add_qreg(q) decomposition.add_basis_element(""u2"", 1, 0, 2) rule = [ U2Gate(0, pi, q[0]) ] for inst in rule: decomposition.apply_operation_back(inst) self._decompositions = [decomposition] def inverse(self): """"""Invert this gate."""""" return self # self-inverse def reapply(self, circ): """"""Reapply this gate to corresponding qubits in circ."""""" self._modifiers(circ.oneconst(self.qargs[0])) def oneconst(self, q): """"""Apply H to q."""""" if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.oneconst((q, j))) return instructions if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.oneconst(q)) return instructions self._check_qubit(q) return self._attach(OneConstGate(q, self)) QuantumCircuit.oneconst = oneconst Here is the example code: x = QuantumRegister(1, 'x') gate = QuantumCircuit(x) gate.oneconst(x[0]) gate.draw() Note that I haven't changed any logic yet. Just the names. Did I forgot something? Edit (1): I had a look at header.py code in qiskit.extensions.standard. Adding these lines of code remove the error on draw method, but not in execute method: import sympy from qiskit.circuit import QuantumCircuit from qiskit.qasm import _node as node QuantumCircuit.definitions[""oneconst""] = { ""print"": False, ""opaque"": False, ""n_args"": 0, ""n_bits"": 1, ""args"": [], ""bits"": [""a""], # gate x a { u3(pi,0,pi) a; } ""body"": node.GateBody([ node.CustomUnitary([ node.Id(""u3"", 0, """"), node.ExpressionList([ node.Real(sympy.pi), node.Int(0), node.Real(sympy.pi) ]), node.PrimaryList([ node.Id(""a"", 0, """") ]) ]) ]) }",<programming><qiskit>,04/07/2019 09:48,5884.0,5884.0,"Did you add these lines to the file qiskit/extensions/standard/__init__.py: from .oneconst import oneconst from .oneconst import OneConstGate I did everything you described doing, as well as added those lines to __init__.py and the following code ran without error: import qiskit from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute from qiskit import Aer qr = QuantumRegister(1) cr = ClassicalRegister(1) gate = QuantumCircuit(qr, cr) gate.oneconst(qr[0]) gate.measure(qr[0], cr[0]) print(gate.draw()) backend = Aer.get_backend(""qasm_simulator"") job = execute(gate, backend, shots=100) print(job.result().get_counts(gate))",04/09/2019 17:49
5877.0,How do I do printf debugging in Q# in a convenient way?,"When initially writing an operator in Q#, I often want to see intermediate values of registers during the computation. This allows me to check that I haven't made mistakes. For example, if I was writing an addition circuit I would input a computational basis state and print out the computational basis states of qubits at particular key points. I am not aware of a way to do this conveniently. If I print out the qubits like Message($""{qubit}"") then I get their IDs instead of their values. That makes sense. I have to do a measurement to access their value. But if I do a measurement, then Q# will e.g. not automatically generate an adjoint operation and this tends to cause compilation failures. Also, I don't actually want to perform a measurement (which may have side effects) I just want to peek at the simulator state. (I originally thought I could package the concept of ""peeking"" at a value into an operation that did a hidden measurement, which would have resolved the issue. But Q# doesn't allow operations with an adjoint to have a return type.) Is there some built-in way to get at the computational basis value of some qubits, and print it to the console during simulation under the Toffoli simulator?",<programming><q#>,04/08/2019 20:19,5878.0,5878.0,"For Toffoli simulator in particular, DumpRegister will provide this information. For example, the following code operation XorTest() : Bool { using ((a, b) = (Qubit[2], Qubit[2])) { // initialize: a = 1, b = 2 ApplyPauli([PauliI, PauliX], a); ApplyPauli([PauliX, PauliI], b); // check initialization Message(""a = ""); DumpRegister((), a); Message(""b = ""); DumpRegister((), b); // calculate a â b and write it to b CNOT(a[0], b[0]); CNOT(a[1], b[1]); // check result: a â b = 3 Message(""a xor b = ""); DumpRegister((), b); } return true; } will print the following result (and throw an exception in the end because the qubits are released not in zero state): a = State: 0: False 1: True b = State: 2: True 3: False a xor b = State: 2: True 3: True The numbers before values are qubit ids.",04/09/2019 01:14
5901.0,How do you start a simulation with a random initial state in Cirq?,How do you create a random initial state by modifying the $2^{n}$ vector amplitudes instead of starting every simulation at $|0000...000\rangle$?,<programming><cirq>,04/12/2019 15:03,5902.0,5902.0,"If you want a random computational basis state, set the input state to the integer random.randint(0, 2**qubits-1). If you want a random superposition sampled from the Haar measure, there is a method cirq.testing.random_superposition(dim=2**qubits). Once you have created your initial state, you pass it into the simulator like cirq.Simulator().simulate(circuit, initial_state=...). Note that run methods do not support an initial state, because they are supposed to more closely mimic the hardware.",04/12/2019 15:50
5904.0,Experiment runtime on IBMQ,"I have been trying to get the runtime of my experiment on IBM's quantum computer. I am using the classic stuff, i.e job = execute(qwalk_circuit, backend='ibmq_16_melbourne', shots=1000) results = job.result() results.get_counts() print(results.data()) I saw on another post that you could see the runtime by using results.get_data(), but that doesnt work anymore, giving me an error that the get_data() attribute does not exist. Is there another way to pull the runtime of my experiment from IBM's quantum computer backend? My imports, in case I am missing something there: # importing QISKit from qiskit import Aer, IBMQ from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute from qiskit import IBMQ, BasicAer from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor",<programming><ibm-q-experience><ibm>,4/13/2019 10:22,9911.0,9911.0,"I was recently looking for a similar solution. Hope this helps. job = execute(qc, backend=backend, shots=1024) results = job.result() print(results.time_taken) You can also check all the values stored in result as it is a dictionary by printing it: print(results) Here you can check for all the information that is available within the dictionary and you can also observe the value for 'time_taken'",2/19/2020 15:37
5959.0,Grover's algorithm returns skewed probability distribution,"I wrote an implementation of Grover's algorithm that looks like this: from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute # Initialize circuit m_qubit = QuantumRegister(1) search_register = QuantumRegister(4) result_register = ClassicalRegister(4) ancillaries = QuantumRegister(3) circuit = QuantumCircuit(search_register, result_register, m_qubit, ancillaries) # Put M qubit into 1-superposition circuit.x(m_qubit) circuit.h(m_qubit) # Put search qubits into superposition circuit.h(search_register) for _ in range(2): # Encode S1 * !S2 * S3 circuit.x( search_register[2] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) circuit.x( search_register[2] ) # Encode S0 * S1 circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) # Encode oracle ((S0 * S1) + (S1 * !S2 * S3)) circuit.x(ancillaries) circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] ) circuit.x(ancillaries) circuit.x(m_qubit) # Reset ancillaries to be used later circuit.reset(ancillaries) # Do rotation about the average circuit.h(search_register) circuit.x(search_register) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] ) circuit.x(search_register) circuit.x(m_qubit) circuit.h(search_register) # Reset ancillaries for use later circuit.reset(ancillaries) circuit.measure(search_register, result_register) # Run the circuit with a given number of shots backend_sim = Aer.get_backend('qasm_simulator') job_sim = execute(circuit, backend_sim, shots = 1024) result_sim = job_sim.result() # get_counts returns a dictionary with the bit-strings as keys # and the number of times the string resulted as the value print(result_sim.get_counts(circuit)) Essentially, this circuit should search for any value that matches $X_1 X_2 X_3 + X_0 X_1$. When I do the math for this circuit I get the following: $$\frac{1}{1024 \sqrt{2}} \left( -304 \left( \sum_{x \in \{00, 01, 11\}} \left| x \right&gt; \left( \left|00\right&gt; + \left|01\right&gt; + \left|10\right&gt; \right) + \left|1000\right&gt; + \left|1001\right&gt; \right) + 80 \left( \sum_{x = 00}^{11} \left|x\right&gt; \left|11\right&gt; + \left|1010\right&gt; \right) \right) \left( \left|0\right&gt; - \left|1\right&gt; \right)$$ These amplitudes correspond to probabilities of $-\frac{{304}^{2}}{2({1024}^{2})} = -\frac{{19}^{2}}{2({64}^{2})}$ and $\frac{{80}^{2}}{2({1024}^{2})} = \frac{{5}^{2}}{2({64}^{2})}$ for the unsuccessful and successful probabilities, respectively. What I don't understand from this is how the successful outputs would appear over the unsuccessful ones, because the magnitude of the probability for the unsuccessful results is much higher. Can someone explain how the normalization is done in this case? Furthermore, these results do not obtain when I actually run the circuit. Instead of a step-function for the probabilities, when I run 1024 shots I tend to get between 30 and 50 for the unsuccessful results and the successful results are spread between 200 and 460. While it's obvious that the successful results have been selected, the spread is concerning because the math seems to indicate that they should be fairly close together. Moreover, the successful results always fall in the same order, which is also counter-intuitive given that results are probabilistic. This implies one of two things to me: The superposition isn't actually equal (i.e. there's some bias towards one value versus the other). However, this doesn't make sense as these results were obtained with a simulator so they should be very close to optimal. I have inadvertently entangled the qubits in such a way that the result is affected. Any insight into this would be greatly appreciated.",<programming><qiskit><measurement><grovers-algorithm>,4/23/2019 2:10,6083.0,6083.0,"It turns out the issue with this circuit was in the use of the reset operator in conjunction with entanglement and superposition. In the oracle code I submitted, I use a Toffoli gate several times, which creates an entanglement between both input qubits and the output qubit. Since the input qubits are in superposition, that superposition state then &quot;spreads&quot; (for lack of a better term) to the output qubit. So, when the output qubit is reset using the reset operator, its superposition state and entanglements with the input qubits causes certain states to collapse, which changes the output of the circuit as a whole. This had confused me earlier because using reset with either superposition or entanglement causes no issue, because both can collapse without change to the input; because, in a sense, the output and input qubits are separated. It is only, therefore, when they are used in conjunction that reset causes this behavior. The solution then, is quite simple: reverse the circuit to return the output qubit to a $\left|0\right&gt;$ state after it is no longer needed: # Encode S1 * !S2 * S3 circuit.x( search_register[2] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) # Encode S0 * S1 circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) # Encode oracle ((S0 * S1) + (S1 * !S2 * S3)) circuit.x(ancillaries) circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] ) circuit.x(m_qubit) # Return ancillaries to 0s so they can be used later circuit.x(ancillaries) circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.x( search_register[2] ) # Do rotation about the average circuit.h(search_register) circuit.x(search_register) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] ) circuit.x(search_register) circuit.x(m_qubit) # Return ancillaries to 0s for use later circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.h(search_register) Doing this instead produced the desired result.",05/07/2019 01:52
6364.0,About the Qiskit draw function,Where does Qiskit put the rendered figure created by circuit.draw(output='mpl')?,<programming><qiskit>,06/06/2019 14:40,6369.0,6369.0,"Qiskit does not save the rendered Figure of the circuit anywhere, unless you provide a filename to the call. For example: circuit.draw(filename='&lt;file_path&gt;'). In regards to having the Figure render and stay open, you simply need to remove a line of code. If you go to where qiskit is installed in your environment, go into the file qiskit/visualization/matplotlib.py, and go to line 436 you will see the line plt.close(self.figure). Comment this line out, and run your program again. You should see the Figure in a new window.",06/06/2019 19:30
6433.0,Perform quantum gate operations using state vectors and matrices,"I am getting confused as to how to perform gate operations using matrices and am hoping someone will help me walk through this example. Say I want to perform a Pauli-X gate on the 3rd qubit in a 3-qubit system. That operation would be: U = I â I â X Then say I have the state $|001\rangle$ so after applying U the state would become $|000\rangle$. I am trying to use Python and NumPy to calculate this but I believe I am missing something. i = np.array([[1, 0], [0, 1]]) x = np.array([[0, 1], [1, 0]]) state_0 = np.array([[1], [0]]) state_1 = np.array([[0], [1]]) x_3 = np.kron(np.kron(i,i),x) v = np.kron(np.kron(state_0, state_0), state_1) print(x_3.dot(v)) This code outputs: [[1] [0] [0] [0] [0] [0] [0] [0]] I am unsure if this output is correct and if it is how would I see this as the state $|000\rangle$? Any clarifications would be very useful! Thank you!",<programming><quantum-gate>,06/12/2019 20:33,6434.0,6434.0,"You can use the same tools you used to get this output to check that it is correct: the state $|000\rangle$ would be represented as tensor product $|0\rangle \otimes |0\rangle \otimes |0\rangle$, which in your Python notation would be np.kron(np.kron(state_0, state_0), state_0). This should give you the same column vector you got from running your code, with the first element 1 and the rest of them 0s.",06/12/2019 21:07
6629.0,Can a quantum computer run classical algorithms?,"I realize that fundamentally speaking quantum and classical computers might as well be apples and oranges, and that for very specific problems such as integer factorization with Shor's algorithm quantum computers blow conventional computers out of the water, but could a quantum computer run classical algorithms? If so, using a comparable classical computer, how would the calculation speed of a quantum computer running a classical algorithm compare to the calculation speed of the classical computer?",<classical-computing><classical-quantum>,6/29/2019 7:24,6630.0,6630.0,"Quantum computers can run classical computations using exactly the same algorithms, and hence have the same running time in terms of scaling. For example, if you look at shorâs algorithm, a major component of that is modular exponentiation, but nobody ever draws the circuit because they just say âuse the classical algorithmâ. In terms of absolute running time, that is heavily hardware dependant so you canât make comparisons so easily. Quantum computers offer the possibility of other algorithms in addition to the classical ones that could be faster, but thereâs no standard method for generating an improvement.",6/29/2019 9:42
6799.0,A quantum computer that doesn't use entangled qubits has the same computational power as a classical one?,Is the statement in the question correct? I would love to receive an explanation as to why it is or isn't. I have a computer science degree background and I am a beginner learning the fundamental of QC from scratch.,<classical-computing>,7/17/2019 22:07,6801.0,6801.0,"Assuming you are talking about starting from a pure state, your statement is true. There are two steps to the proof: Show that a system without entanglement can implement any classical computation. Show that a system that remains separable can be simulated by a classical computation, proving that there are no calculations it can implement that a classical computer cannot. The first is straightforward. Every classical computation can be written as a classical reversible computation. The Toffoli gate (controlled-controlled-not) is universal for classical reversible computation, so any circuit can be entirely decomposed in terms of that. But Quantum computers can implement the Toffoli gate, so they can implement any classical computation, and the state of the system at any intermediate point must be the same as in the classical computation, and therefore separable. The second is also reasonably straightforward. If we know that every qubit remains separable, then we can hold in memory just the set of $N$ qubit states, comprising $N$ 2-element normalised complex vectors (as compared to the general case of a single $2^N$ element normalised complex vector). Whatever set of gates we use to describe the computation will act on some finite number of qubits, say $k$ at maximum (independent of $N$). So each computational step requires the action of a $2^k\times 2^k$ matrix, which we just have to apply to the appropriate set of $k$ separable states. We extract the separable states at the end, and continue. The total simulation time is $O(NM)$ for a sequence of $M$ gates on a classical computer.",7/18/2019 6:42
6940.0,How to calculate an Expected Value of some operator acting on qubits?,"I'm trying to implement the Variational Quantum Eigensolver in Qiskit. Suppose, I have an operator $A = \sigma_1^z\sigma_2^z$ acting on some two-qubit state $|\psi\rangle$. After a measurement I get a set of probabilities corresponding to states $|00\rangle$, $|01\rangle$, $|10\rangle$, $|11\rangle$. My question is: How to calculate $\langle\psi|A|\psi\rangle$ using known set of probabilities?",<programming><qiskit><measurement><textbook-and-exercises><vqe>,08/04/2019 12:05,6944.0,6944.0,"Qiskit currently supports measurements in the computational basis from Qiskit Terra and Aer, that is, returning 1 if the qubit is in state $|1\rangle$, and 0 if the qubit is measured to be in state $|0\rangle$. However, it is relatively easy to perform a change of basis unitary to our quantum circuit just prior to measurement, in order to instead measure in the eigenbasis of an arbitrary operator $A$: First, we need to compute the eigendecomposition of our Hermitian observable $A|v_i\rangle=\lambda_i|v_i\rangle$. Since $A$ is Hermitian, we are always able to diagonalize $A$ in this eigenbasis: $$A = \sum_{i}\lambda_i |v_i\rangle \langle v_i|= U^\dagger \Lambda U$$ where $\Lambda = \text{diag}(\lambda_1,\dots,\lambda_n)$ and $U$ is a unitary matrix composed of the eigenvectors down the columns. Next, we apply the unitary operation $U$ to the end of our quantum circuit, using qc.unitary. To see why, note that $$\langle\psi|A|\psi\rangle = \langle\psi|U^\dagger \Lambda U|\psi\rangle = \langle\psi'|\Lambda|\psi'\rangle $$ where $|\psi'\rangle = U|\psi\rangle.$ Since $\Lambda$ is diagonal, we have transformed the problem from one where we must perform a measurement in an arbitrary basis, to one where we simply measure in the computational basis. Finally, we measure the state $|\psi'\rangle$ in the computational basis $|i \rangle$ using qc.measure(q, c), and execute the jobs to get the counts and probabilities $\mathbb{P}_i = |\langle i|\psi'\rangle|^2$. Using the previously computed eigenvalues of $A$, we can now reconstruct the expectation value: $$\langle \psi | A | \psi\rangle = \langle\psi'|\Lambda|\psi'\rangle = \sum_i \langle\psi'|i\rangle \langle i | \Lambda | i\rangle \langle i|\psi'\rangle = \sum_i \lambda_i \mathbb{P}_i$$ For example, shots = result.results[0].shots counts = result.get_counts() probs = sorted([(i, c/shots) for i, c in counts.items()]) P = np.float64(np.array(probs)[:, 1]) A_expectation = lambda @ p For a more high-level interface to coding and running variational quantum algorithms, you can also check out the PennyLane Python library, which has a Qiskit plugin available for using Qiskit simulators and IBM hardware as a backend. For example, a expectation values of arbitrary operators in PennyLane using qiskit looks like this: import pennylane as qml dev = qml.device('qiskit.basicaer', wires=2) # use 'qiskit.ibm' instead to run on hardware @qml.qnode(dev) def circuit(x, y, z): qml.RX(x, wires=0) qml.RY(y, wires=1) qml.RZ(z, wires=0) qml.CNOT(wires=[0, 1]) return qml.expval(qml.Hermitian(A, wires=[0, 1])) def cost(x, y, z): return (1-circuit(x, y, z))**2 # optimization follows You can use NumPy, TensorFlow, or PyTorch to do the optimization - check out some of the tutorials. Disclaimer: I am one of the developers on PennyLane.",08/05/2019 05:21
8244.0,Big Endian vs. Little Endian in Qiskit,I've noticed that Q# favors Little Endian. Meaning that most operations are designed for this type of encoding. Is is it the same with Qiskit?,<programming><qiskit><q#>,09/12/2019 15:34,8370.0,8370.0,"Qiskit uses little-endian for both classical bit ordering and qubit ordering. For classical bits: A 3-bit classical register creg with value abc has creg[0]=c, creg[1]=b, creg[2]=a. For qubits: The ordering is with respect to the tensor-product structure of the state space. So a 3-qubit quantum register qreg with wave-function $|\psi\rangle = |A\otimes B\otimes C\rangle = |ABC\rangle$ has qreg[0]$= |C\rangle$, qreg[1]$= |B\rangle$, qreg[2]$= |A\rangle$. Similarly for representing unitary matrices of a circuit. $U = U_A \otimes U_B \otimes U_C = U_A U_B U_C$ would have $U_C$ acting on qreg[0], $U_B$ acting on qreg[1] and $U_A$ acting on qreg[2].",9/30/2019 17:40
8269.0,Backend Warning: The skip Qobj validation does not work for IBMQ provider. Disable it,"I am using QAOA to solve the max-cut problem. On my machine, 10 qubits already takes a minute or two to simulate. I'm hoping that the ibmq-qasm-simulator could simulate 32 qubits faster than my laptop would. Here's my code: After loading in my IBMQ token and such... optimizer = COBYLA() # Simulate using IBM's cloud service backend = provider.get_backend('ibmq_qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1) part_array = part.values w = calc_w(part_array) # Calculate pairwise distances between points # Execute algorithm qubit_ops, offset = max_cut.get_max_cut_qubitops(w) qaoa = QAOA(qubit_ops, optimizer, p) result = qaoa.run(quantum_instance) While the code runs a message in red (like a warning but without ""Warning:"") displays saying, ""The skip Qobj validation does not work for IBMQ provider. Disable it."" How do I do what this message is asking?",<programming><qiskit><ibm-q-experience><qaoa>,9/19/2019 0:43,8271.0,8271.0,"There is a parameter when instantiating a QuantumInstance() called skip_qobj_validation. This parameter is set to True by default. When creating the QuantumInstance, you can set it to False, and that will get rid of the warning. q_instance = QuantumInstace(skip_qobj_validation=False)",9/19/2019 14:14
8299.0,Running jobs on different backends at the same time,"qr = QuantumRegister(2,'qr') cr = ClassicalRegister(2,'cr') circ = QuantumCircuit(qr,cr) circ.x(qr[0]) circ.measure(qr,cr) provider = IBMQ.get_provider(group = 'open') backends = provider.get_backend(['ibmqx2', 'ibmq_16_melbourne', 'ibmq_vigo', 'ibmq_ourense']) job = execute(circ, backend=backends, shots=1024) job_monitor(job, interval = 5) result = job.result() counts = result.get_counts(circ) plot_histogram(counts) How do I run my quantum code on more than one backend at the same time?",<programming><qiskit><ibm-q-experience>,9/23/2019 18:59,8307.0,8307.0,"You would need to send a job to each backend you want to run on. For example, if you wanted to send to ibmqx2 and ibmq_ourense you could execute code similar to this: backend_1 = provider.get_backend('ibmqx2') backend_2 = provider.get_backend('ibmq_ourense') job_1 = execute(circuit, backend_1) # Sends a job to run on ibmqx2 job_2 = execute(circuit, backend_2) # Sends a job to run on ibmq_ourense You can then get the results from each job normally: result_1 = job_1.result().get_counts(circuit) result_2 = job_2.result().get_counts(circuit)",9/24/2019 13:36
8304.0,How to unpickle a Result object returned by an IBMQ experiment?,"I have executed an experiment using IBMQ and receive a Result object. I am writing the ASCII repr of the result with f.write(res) into a file and see a line like Result(backend_name='ibmq_16_melbourne', backend_version='1.1.0',... How can I reconstruct the Result object from that line? Which methods do I have to call?",<programming><qiskit><ibm-q-experience>,9/24/2019 10:34,8306.0,8306.0,I found a solution: to serialise instead of print(res) I need to do: print(res.to_dict()) To load the serialized string (eg. line from a file) dict = eval(line) res = Result.from_dict(dict) all of the above with from qiskit.result import Result,9/24/2019 12:51
8308.0,How many classical registers are there on (IBM) quantum computers?,I have a circuit where I only use 3 qubits but need to utilize hundreds of classical registers. My questions are: what is the maximum number of classical bits on the current IBM Qs? What is the quantum computer with the highest number of classical bits right now that is available for researchers and the public?,<programming><qiskit><ibm-q-experience>,9/25/2019 5:59,8309.0,8309.0,"As far as I am aware you can have as many ClassicalRegisters as you need, assuming they fit in the memory of the classical device controlling the Quantum Computer. I would suggest trying to reuse them if possible if you are concerned about this!",9/25/2019 7:18
8388.0,How can classical computations be non-unitary?,"Given that classical physics emerges from quantum physics on a macroscopic scale, and all quantum operators are unitary, how are we able to perform non-unitary operations (such as setting a register to zero) in classical computation? I suspect that unitarity must be preserved because information leaks to the environment as heat. However if this is the case, it begs a second question, why can quantum computers not 'simply' leak information to the environment as a hack to allow non-unitary transformations?",<classical-computing><unitarity>,10/02/2019 22:17,8391.0,8391.0,"Quantum computers can leak information to the environment in order to perform non-unitary transformations. The problem is that this irreversibly entangles the computer's state with the environment, i.e. it is equivalent to measuring the qubits that were leaked. This will collapse the state of the computer and prevent the interference effects that are needed if you want to do a quantum computation that's not secretly just a classical computation.",10/03/2019 05:30
8505.0,How to prepare a specific initial state of three qubits?,I would like to prepare the following initial state for variational quantum algorithms: $$ \sin\theta_1 \sin\theta_2 \sin\theta_3 |000\rangle + \sin\theta_1 \sin\theta_2 \cos\theta_3 |001\rangle + \sin\theta_1 \cos\theta_2 |010\rangle + \cos\theta_1 |100 \rangle. $$ Should I make a circuit for this state from scratch? Or is there any library to find a circuit to make this state such as Cirq or Qiskit?,<programming><qiskit><cirq>,10/17/2019 8:43,8509.0,8509.0,"If you call initialize in this case, you will be specifying a general state in $\mathbb{C}^8$. However what you have is more specialized. For example only having 4 nonzero amplitudes. So the call to initialize won't know this a priori. So it won't realize the initialization circuit can be decomposed easily. Or at least it will need to do some extra simplification steps before realizing this. I'm going to change $\sin$ and $\cos$ from your state. You can fix this by changing the angles with appropriate angle redefinitions. $\theta \to \frac{\pi}{2}-\theta$. $$ | \psi_1 \rangle = (\mathrm{R}(\theta_1) \otimes I_4) | 0 0 0 \rangle = \cos \theta_1 | 0 0 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\ | \psi_2 \rangle = (\mathrm{CR}(0,\theta_2) \otimes I_2) | \psi_1 \rangle = \cos \theta_1 \cos \theta_2 | 0 0 0 \rangle + \cos \theta_1 \sin \theta_2 | 0 1 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\ | \psi \rangle = \mathrm{CCR}(00,\theta_3) | \psi_2 \rangle $$ where $\mathrm{R}(\theta)$ is to indicate a 2 by 2 rotation matrix. $\mathrm{CR}(0,\theta)$ is to indicate controlled $\mathrm{R}(\theta)$ on the second index but controlled on 0 instead of 1 on the first. $\mathrm{CCR}(00,\theta)$ is to indicate controlled $\mathrm{R}(\theta)$ on the third index but controlled on 00 instead of 11 on the first two. You should be able to fix the angles and get the controls back to normal from here.",10/17/2019 15:18
8837.0,Which algorithm in quantum computing can be implemented for a HPC system?,"I am new to quantum computing and I wanted to do a project for one of my classes where I study a specific algorithm from the field and then insert parallelism in it so it can be executed more efficiently on a cluster i.e., high-performance computing (HPC) system. I would appreciate any suggestions which algorithm should I pursue to implement, as well as any resources available to study its background. Thanks in advance!",<algorithm><programming><quantum-parallelism>,11/18/2019 13:14,8915.0,8915.0,"If I understand you correctly, your goal is: To choose some quantum algorithm (your question is: which algorithm would be good?) Instead of running the quantum algorithm on a real quantum computer, you want to run a simulation of a quantum computer on a classical computer to simulate the execution of the quantum algorithm. You want to optimize your classical simulator to make efficient use of the special capabilities offered by a High Performance Cluster (e.g. parallelism) and demonstrate that the simulation runs faster. If so, it really does not matter which quantum algorithm you choose, as long as it involves many qubits and many gates. You are probably best off choosing some very well-known algorithm that is well described in the literature, e.g. Grover or Shor. Your simulation will involve multiplying very large matrices with each other. The more qubits, the larger the matrices. The growth is exponential: if you have $N$ qubits, you will be multiplying $2^N$ by $2^N$ matrices. The more gates, the more multiplications. You will make life easier on yourself if you assume the qubits are perfect (no noise, no errors). Since the main point of your exercise is to parallelize some code for an HPC, it probably doesn't matter that the simulation is less realistic.",11/24/2019 7:49
8844.0,ImportError: cannot import name 'matplotlib_circuit_drawer',"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from qiskit.tools.visualization import matplotlib_circuit_drawer as drawer from qiskit import Aer from qiskit import execute import numpy as np %matplotlib inline This is the code cell that I am trying to implement. The error is in the second line. Error--&gt; ImportError: cannot import name 'matplotlib_circuit_drawer' I'm using Google Colab to execute the code. How to solve this?",<programming><qiskit>,11/19/2019 6:53,8845.0,8845.0,"qiskit.tools.visualization has been moved to qiskit.visualization and matplotlib_circuit_drawer has been removed. Instead of using it, try using qiskit.visualization.circuit_drawer() with the appropriate arguments. So in this case it should be qiskit.visualization.circuit_drawer(my_circuit, output='mpl', filename='my_circuit.png')",11/19/2019 7:23
8883.0,Moments-based quantum circuit in Cirq,"In Cirq, quantum circuit consists of moments, which in turn consists of operations. This is different from Qiskit/OpenQASM, which doesnât have the concept of moments. What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it? As a result of moments, one can insert operations in different moments using different insert strategies. It seems to me the earliest insert strategy is always preferred, which is the same as Qiskit/OpenQASM. What are the use cases for different insert strategies?",<programming><cirq>,11/21/2019 10:09,8891.0,8891.0,"What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it? The basic idea is that we wanted to give users more control over what will actually happen on hardware. Whether or not two gates are run in parallel is really important information when dealing with noise (e.g. it determines total runtime), so it's important for users to be able to determine-whether that's happening and also control-if that's happening. The philosophy of giving more control isn't limited to moments. Cirq also requires users to specify specific qubits (no implicit placement), and to use the native gateset of whatever device they are targeting (no implicit decomposition). The important thing is that you should be able to have a clear concrete idea of what will actually happen on the device. Cirq also has the concept of a ""schedule"", which has even more control over timing. But ironically we've found that users don't want to use it, and programmers don't like consuming it. So we're actually cutting that next version. The list-of-moments structure seems to be a nice sweet spot in terms of flexibility, ease of production, and ease of consumption. You can certainly put the abstraction boundary in other places, but that's where we've found ourselves pulled towards. It seems to me the earliest insert strategy is always preferred It's a good rule of thumb, which is why it's the default. But it's not always optimal. For example, hardware may perform best when circuits are stratified into layers of single-qubit gates and layers of two-qubit gates (but never a layer with both single and two qubit gates). So even if you can move a single qubit operation earlier, that may result in it being in the same layer as two qubit operations. Moving it would not be a fatal mistake, the circuit would still run, but it might be slightly noisier. There are lots of ""little things"" like that when dealing with hardware.",11/21/2019 19:36
8893.0,Why is the order reversed on measurement?,"Why is the order reversed on measurement? from qiskit import( QuantumCircuit, execute, Aer) from qiskit.visualization import plot_histogram # Use Aer's qasm_simulator simulator = Aer.get_backend('qasm_simulator') # Create a Quantum Circuit acting on the q register circuit = QuantumCircuit(3, 3) # Add a X gate on qubit 0 circuit.x(0) # Add a CX (CNOT) gate on control qubit 0 and target qubit 1 circuit.cx(0, 1) circuit.barrier() # Map the quantum measurement to the classical bits circuit.measure([0,1,2], [0,1,2]) # Execute the circuit on the qasm simulator job = execute(circuit, simulator, shots=1000) # Grab results from the job result = job.result() # Returns counts counts = result.get_counts(circuit) print(""\nTotal count:"",counts) # Draw the circuit circuit.draw() Got result: Total count for 00 and 11 are: {'011': 1000} But I'm expecting '110'.",<quantum-gate><programming><qiskit>,11/21/2019 21:23,8894.0,8894.0,"I still run into this issue too. If you consider $|q0\rangle$ to be the most significant bit (MSB) you have to map it to the most significant classical bit as well, which is in your case a bit no. 2. Or you can flip your quatnum circuit upside down and then $|q0\rangle$ become the least significant bit (LSB) and the measurement will meet your expectation. A code circuit.measure([0,1,2], [0,1,2]) is valid in case $|q0\rangle$ is LSB and circuit.measure([0,1,2], [2,1,0]) in case $|q0\rangle$ is MSB. I think that the reason for this arrangement is simply a convention, so you can choose whether $|q0\rangle$ is MSB or LSB and set the measurement procedure accordingly.",11/21/2019 22:39
9522.0,Logical Explanation behind second reflection in Grover's algorithm,"Logically, what does the second reflection in Grover's algorithm do? I currently don't have a lot of background in linear algebra so I'm failing to understand what exactly its purpose is and what it does.",<algorithm><programming><grovers-algorithm>,1/13/2020 18:40,9527.0,9527.0,"An application of the reflection operator change each amplitude of a basis state $ |i\rangle$ by $$ \alpha_i \rightarrow- \alpha_i + 2 \langle\alpha\rangle\ $$ where $ \langle\alpha\rangle\ $ is the average of all amplitudes. It follows the oracle which is use to ""mark"" the seeked elements $ |i\rangle$. Say for instance that you have 8 elements, so you work on 3 qubits and you want to output $ |011\rangle$ with high probability. At the beginning, each basis state has $\frac{1}{8}$ probability to be measured as their amplitude are $\frac{1}{\sqrt{8}}$. The oracle first will mark $ |011\rangle$, so its amplitude will be $-\frac{1}{\sqrt{8}} = -\frac{1}{2\sqrt{2}}$. $$ \langle\alpha\rangle\ = \frac{1}{8} (7* \frac{1}{\sqrt{8}} - \frac{1}{\sqrt{8}}) = \frac{6}{8\sqrt{8}} = \frac{3}{8\sqrt{2}}$$ So the amplitude of $ |011\rangle$ after the reflection operator becomes $$ - (-\frac{1}{2\sqrt{2}}) + 2\langle\alpha\rangle\ = \frac{5}{4\sqrt{2}} $$ while others will have a new amplitude: $$ - (\frac{1}{2\sqrt{2}}) + 2*\frac{3}{8\sqrt{2}} = \frac{1}{4\sqrt{2}}$$ If you square those amplitudes, then $ |011\rangle$ has $\frac{25}{32} \approx 0.78 &gt; \frac{1}{8}$ probability to be measured, while another state will have $\frac{1}{32}$ probability to be measured. You see the probability of the solution to be outputed increased while non-solutions less likely to be.",1/13/2020 23:16
9641.0,How is quantum error applied to the qubits?,"I am trying to check the way qiskit has the noise implemented. I have read how is this theoretically done using quantum channels (see Nielsen and Chuang chapter 8) and I want to verify if qiskit follows the same procedure. I have started by the bit-flip error using the pauli_error function. Finally it creates a quantum error object which can be added to the NoiseModel object. However when adding this you have to use the add_all_qubit_quantum_error function and I do not really understand how this works. It is supposed to add the quantum error to all qubits when given a set of gates as an argument, as in the following example: # Example error probabilities p_reset = 0.03 p_meas = 0.1 p_gate1 = 0.05 # QuantumError objects error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)]) error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)]) error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)]) error_gate2 = error_gate1.tensor(error_gate1) # Add errors to noise model noise_bit_flip = NoiseModel() noise_bit_flip.add_all_qubit_quantum_error(error_reset, ""reset"") noise_bit_flip.add_all_qubit_quantum_error(error_meas, ""measure"") noise_bit_flip.add_all_qubit_quantum_error(error_gate1, [""u1"", ""u2"", ""u3""]) noise_bit_flip.add_all_qubit_quantum_error(error_gate2, [""cx""]) print(noise_bit_flip) However I do not know when the bit-flit is applied. Is it applied everytime one gate that can be decomposed in any of the ones of the list [""u1"", ""u2"", ""u3""]? What I need to know is how often it is applied and with which criterion. Thank you for your help!",<qiskit><programming><noise>,1/25/2020 9:22,9653.0,9653.0,"Qiskit simulator behaves like this for your code snippet: whenever it encounters one of u1, u2, or u3 gates (in the compiled circuit), it first applies the gate; then it performs an X gate according to the provided probability (0.05 in our case).",1/26/2020 9:05
9748.0,How to encode eigenvalues of matrix $A$ in solving $A\vec{x} = \vec{b}$ using the HHL Algorithm,"I am trying to implement multiple parallel subroutines of HHL algorithm, each working on a different set of matrix $A$ (when solving for $x$, in $A\vec{x} = \vec{b}$), to find the expectation values of $|x\rangle$. The matrix $A$ is randomly generated Hermitian matrix, and may/may not be sparse (checking what happens, is also something I'm wondering). I have the following queries: If I understand correctly, I need to encode eigenvalues of a $2 \times 2$ matrix $A$, say $\lambda_1$ and $\lambda_2$ in the quantum register. Is that right? How do I do that? Is the quantum register initialized with the binary values of $\lambda_1$ and $\lambda_2$? Does that mean 2 runs of HHL? Is finding Eigenvalues of matrix $A$ supposed to be a classical subroutine?",<algorithm><programming><hhl-algorithm>,02/06/2020 04:02,9757.0,9757.0,"Finding the eigenvalues of $A$ is an intermediate part of the HHL algorithm (although it will not output them). It is a quantum routine known as phase estimation, for which you need to be able to implement a controlled-unitary evolution where the unitary is determined by $U=e^{iAt}$ for some $t$. You do not need to find them by any classical routine. However, you do need some prior information: a bound on the range that the eigenvalues can occupy (this determines the $t$ in the previous relation), and a bound on how close to zero these eigenvalues might be (this determines how large a register you need for performing the phase estimation).",02/06/2020 12:29
9951.0,Is there anything that can be programmed on a classical computer but not on a quantum computer?,Would we need to create new algorithms that only work on quantum computers or would be simply edit codes in languages such as C++ to involve the new primitives from quantum computing? Are there things that can be programmed on a classical computer that canât be programmed ona. Quantum computer? I know that quantum computer are turing complete.,<algorithm><classical-computing>,2/23/2020 18:14,9954.0,9954.0,"Short answer: no. Any classical algorithm can be transformed into quantum algorithm. This result has little practical value, because you don't obtain quantum speedup, but it is important from theoretical point of view.",2/23/2020 18:58
9957.0,IBMQ: `from qiskit import QISKitError` gives 'cannot import name QISKitError',When I run: from qiskit import QISKitError I get the error: ImportError: cannot import name 'QISKitError' I need QISKitError for exception handling with my program. Did IBMQ recently update this import?,<qiskit><programming><ibm-q-experience>,2/23/2020 21:43,9958.0,9958.0,This has been moved to from qiskit.exceptions import QiskitError,2/23/2020 22:26
9967.0,How to use external .csv data file in quantum support vector machine qiskit python code?,"I am new to python programming and Qiskit. I would like to ask can we use sklearn for adding external .csv data file before Qiskit libraries, or without sklearn, we can do or is there any other Qiskit library to add any external .csv file, to run the python code of quantum support vector machine? How I can use .csv data file with Qiskit libraries to run quantum SVM ? I am following the code written below, where I should put my own .csv data file import numpy as np from dataset import breast_cancer from sklearn.datasets.samples_generator import make_blobs from qiskit.aqua.utils import split_dataset_to_data_and_labels from sklearn import svm from utils import svm_utils from matplotlib import pyplot as plt #matplotlib inline #load_ext autoreload #autoreload 2 % Breast Cancer dataset n = 2 # number of principal components kept training_dataset_size = 20 testing_dataset_size = 10 sample_Total, training_input, test_input, class_labels = breast_cancer(training_dataset_size, testing_dataset_size, n) data_train, _ = split_dataset_to_data_and_labels(training_input) data_test, _ = split_dataset_to_data_and_labels(test_input) # %%Breast Cancer dataset ##%% Linear Support vector machine # We use the function of scikit learn to generate linearly separable blobs centers = [(2.5,0),(0,2.5)] x, y = make_blobs(n_samples=100, centers=centers, n_features=2,random_state=0,cluster_std=0.5) fig,ax=plt.subplots(1,2,figsize=(10,5)) ax[0].scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1]) ax[0].set_title('Breast Cancer dataset'); ax[1].scatter(x[:,0],x[:,1],c=y) ax[1].set_title('Blobs linearly separable'); ##%% Hands-on session on support vector machine plt.scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1]) plt.title('Breast Cancer dataset'); model= svm.LinearSVC() model.fit(data_train[0], data_train[1]) accuracy_train = model.score(data_train[0], data_train[1]) accuracy_test = model.score(data_test[0], data_test[1]) X0, X1 = data_train[0][:, 0], data_train[0][:, 1] xx, yy = svm_utils.make_meshgrid(X0, X1) Z = model.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) fig,ax=plt.subplots(1,2,figsize=(15,5)) ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1]) ax[0].set_title('Accuracy on the training set: '+str(accuracy_train)); ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1]) ax[1].set_title('Accuracy on the test set: '+str(accuracy_test)); ##%% We now implement a SVM with gaussian kernel clf = svm.SVC(gamma = 'scale') clf.fit(data_train[0], data_train[1]); accuracy_train = clf.score(data_train[0], data_train[1]) accuracy_test = clf.score(data_test[0], data_test[1]) X0, X1 = data_train[0][:, 0], data_train[0][:, 1] xx, yy = svm_utils.make_meshgrid(X0, X1) Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) fig,ax=plt.subplots(1,2,figsize=(15,5)) ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1]) ax[0].set_title('Accuracy on the training set: '+str(accuracy_train)); ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1]) ax[1].set_title('Accuracy on the test set: '+str(accuracy_test)); ##%% First steps in Qiskit import qiskit as qk # Creating Qubits q = qk.QuantumRegister(2) # Creating Classical Bits c = qk.ClassicalRegister(2) ##%% Define and print empty circuit circuit = qk.QuantumCircuit(q, c) print(circuit) ##%%% Add gates to the qubits # Initialize empty circuit circuit = qk.QuantumCircuit(q, c) # Hadamard Gate on the first Qubit circuit.h(q[0]) # CNOT Gate on the first and second Qubits circuit.cx(q[0], q[1]) # Measuring the Qubits circuit.measure(q, c) print (circuit) ##%% Run the circuit on the quantum simulator # Using Qiskit Aer's Qasm Simulator: Define where do you want to run the simulation. simulator = qk.BasicAer.get_backend('qasm_simulator') # Simulating the circuit using the simulator to get the result job = qk.execute(circuit, simulator, shots=100) result = job.result() # Getting the aggregated binary outcomes of the circuit. counts = result.get_counts(circuit) print (counts) from qiskit.aqua.components.feature_maps import SecondOrderExpansion feature_map = SecondOrderExpansion(feature_dimension=2, depth=1) ##%%Print the feature map circuit x = np.array([0.6, 0.3]) print(feature_map.construct_circuit(x)) ##%%% QSVM Algorithm from qiskit.aqua.algorithms import QSVM qsvm = QSVM(feature_map, training_input, test_input) ##%% Run QSVM from qiskit.aqua import run_algorithm, QuantumInstance from qiskit import BasicAer backend = BasicAer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=10598, seed_transpiler=10598) result = qsvm.run(quantum_instance) ##%%% Analyze output plt.scatter(training_input['Benign'][:,0], training_input['Benign'][:,1]) plt.scatter(training_input['Malignant'][:,0], training_input['Malignant'][:,1]) plt.show() length_data = len(training_input['Benign']) + len(training_input['Malignant']) print(""size training set: {}"".format(length_data)) print(""Matrix dimension: {}"".format(result['kernel_matrix_training'].shape)) print(""testing success ratio: "", result['testing_accuracy']) test_set = np.concatenate((test_input['Benign'], test_input['Malignant'])) y_test = qsvm.predict(test_set, quantum_instance) ##%% And here we plot the results. The first plot shows the label predictions of the QSVM and the second plot shows the test labels. plt.scatter(test_set[:, 0], test_set[:,1], c=y_test) plt.show() plt.scatter(test_input['Benign'][:,0], test_input['Benign'][:,1]) plt.scatter(test_input['Malignant'][:,0], test_input['Malignant'][:,1]) plt.show()",<algorithm><qiskit><programming>,2/24/2020 15:24,9968.0,9968.0,"I have previously used this function to load a custom data set - it should still work but I haven't tried it with more recent releases of Aqua def userDefinedData(location, file, class_labels,training_size, test_size, n=2, PLOT_DATA=True): data, target, target_names = load_data(location, file) # sample_train is of the same form as data sample_train, sample_test, label_train, label_test = train_test_split( data, target,test_size=0.25, train_size=0.75 ,random_state=22) # Now we standarize for gaussian around 0 with unit variance std_scale = StandardScaler().fit(sample_train) sample_train = std_scale.transform(sample_train) sample_test = std_scale.transform(sample_test) # Now reduce number of features to number of qubits pca = PCA(n_components=n).fit(sample_train) sample_train = pca.transform(sample_train) sample_test = pca.transform(sample_test) # Samples are pairs of points samples = np.append(sample_train, sample_test, axis=0) minmax_scale = MinMaxScaler((-1, 1)).fit(samples) sample_train = minmax_scale.transform(sample_train) sample_test = minmax_scale.transform(sample_test) # If class labels are numeric if class_labels[0].isdigit(): # Pick training size number of samples from each distro training_input = {key: (sample_train[label_train == int(key), :])[:training_size] for k, key in enumerate(class_labels)} test_input = {key: (sample_test[label_test == int(key), :])[: test_size] for k, key in enumerate(class_labels)} else: # if they aren't training_input = {key: (sample_train[label_train == k, :])[:training_size] for k, key in enumerate(class_labels)} test_input = {key: (sample_train[label_train == k, :])[training_size:( training_size + test_size)] for k, key in enumerate(class_labels)} if PLOT_DATA: for k in range(0, 9): plt.scatter(sample_train[label_train == k, 0][:training_size], sample_train[label_train == k, 1][:training_size]) plt.title(""PCA dim. reduced user dataset"") plt.show() return sample_train, training_input, test_input, class_labels",2/24/2020 15:37
9976.0,Will quantum computers pass the Turing test?,Will quantum computers be able to pass the Turing test sooner than classical computers?,<classical-computing><quantum-turing-machine>,2/24/2020 18:47,9982.0,9982.0,"I think a better phrasing to this question is - will cloud access to a quantum computer enable a classical computer to pass the Turing test sooner than a classical computer with no such access? A quantum computer ""alone"" is very unlikely to pass the Turing test earlier than the above mentioned device, since quantum computers have technical difficulties performing large-scale simple tasks (e.g. multiply two 2048-digit numbers). Our usage of quantum computers relies on their ability to perform very specific tasks that are out of reach for classical computers. In order to pass the Turing test, the computer needs to be able to cover an extremely wide variety of tasks; there is no reason to assume a quantum computer will be better than a classical computer in such a wide variety. So the question remains - will cloud access to a quantum computer help with passing the Turing test? Here we can only speculate as well. For example, one can guess that good machine learning capabilities are essential to passing the Turing test (since you need to be able to tell the difference between a picture of a cat and a picture of a dog), and we hope that quantum computers will help us with machine learning. But this is still only in the realm of speculation. My personal guess: Yes, it will help. But only because we have many years ahead of us until a computer passes the Turing test, and I believe(/hope/dream) that quantum computing will mature by then.",2/25/2020 8:37
9996.0,How to read the elements of a circuit in qiskit?,"I would like to know if there is a way to read the elements of a circuit. What I mean is if I have a QuantumCircuit object, can I obtain the gates that are applied to each qubit in order? I would like to implement certain noise gate after each Hadamard and I would have therefore to identify each Hadamard in the QuantumCircuit object. So I need a function that gives me all the gates in a circuit and that allows me to modificate what it returns so I can construct a modified quantum circuit.",<quantum-gate><qiskit><programming>,2/26/2020 14:45,10013.0,10013.0,You can play with the circuit's data. First write: print(circ.data) or from pprint import pprint pprint(vars(circ.data)) Then you'll understand the structure and how to modify it.,2/27/2020 6:46
10006.0,How do I know in which state the qubit is in each step of the circuit for the simulator in qiskit?,"I would like to know how to know in which state a qubit is (I am talking about single-qubit errors), because in order to apply a non unitary gate in the simulator I have to renormalize the state or the corresponding non unitary Kraus operator (the non unitary gate in my circuit). Therefore I need to know in which state the circuit it. I am of course talking about the simulator, which in fact is classical and therefore it must be a way to know the state at each point of the circuit.",<quantum-gate><qiskit><programming><noise>,2/26/2020 17:51,10008.0,10008.0,"You can take snapshots of the statevector of the circuit when you use the 'qasm_simulator'. You simply append snapshot instructions into your circuit where you would like to see the statevector, and then can see the values in the result object that is returned. You add a snapshot instruction using from qiskit.extensions.simulator import snapshot qc.snapshot('my_label')",2/26/2020 18:03
10092.0,What do the numbers of the operation object in QuantumCircuit.data outputs?,"When you have a quantum circuit and use QuantumCircuit.data you get a list with objects of this type (this is the one for a X gate acting on qubit 0 y a 2 qubits Quantum Circuit): (qiskit.extensions.standard.x.XGate object at 0x0000019B8DEC2EB8, [Qubit(QuantumRegister(2, 'q'), 0)], []) The first element represents the operation. What does the sequence of digits 0x0000019B8DEC2EB8 mean? I suppose it has something to do with the location or the time, but I do not know how to obtain each digit. I need to know exactly how to reproduce one of these sequences myself. Thank you so much in advance.",<qiskit><programming>,03/04/2020 18:30,10093.0,10093.0,"That is the address in memory (represented as a hexademical number) of that specific gate object. It can be used to differentiate that specific X gate object from a different X gate object. Other than that it general is not useful, and it's definitely not something you would ever need to manually reproduce.",03/04/2020 19:04
10109.0,How to calculate the Von Neuman entropy on qiskit with the module quantum_info?,"I am trying to wrap my head around he quantum_info module on qiskit, since most of the functions on qiskit.tools are going to be deprecated, but I am very confused with the Statevector and DensityMatrix objects. For example, with this snippet of code: simulator = BasicAer.get_backend('statevector_simulator') # the device to run on result6 = execute(circuit6, simulator).result() outputstate6 = result6.get_statevector(circuit6, decimals=3) probability = np.abs(np.array(outputstate6))**2 outstatevector=quantum_info.states.Statevector(outputstate6) print(type(outstatevector)) print(type(outputstate6)) print(outputstate6) print(quantum_info.entropy(outputstate6)) I get: &lt;class 'qiskit.quantum_info.states.statevector.Statevector'&gt; &lt;class 'numpy.ndarray'&gt; [0.447+0.j 0. +0.j 0.632+0.j 0.632+0.j] as expected but then I get the error on quantum_info.entropy(outputstate6): QiskitError: 'Input quantum state is not a valid' How can I solve this?",<qiskit><programming><entropy>,03/06/2020 23:08,10124.0,10124.0,"Short answer You are getting that error because your example does not use a valid (normalized) statevector. If you remove the decimals=3 kwarg where you call result.get_statevector it will work. Long Answer The Von-Neuman entropy function in the qiskit.quantum_info works with either Statevector or DensityMatrix object inputs, or inputs that can be implicitly converted to those objects (ie a list or np.array for a vector or a square matrix). So you can do any of the following for example: import numpy as np from qiskit.quantum_info import entropy, Statevector, DensityMatrix # Pure state entropy (Note this is always 0) # The following are equivalent: s1 = entropy([1, 0, 0, 0]) # Statevector as list s2 = entropy(np.array([1, 0, 0, 0])) # Statevector as array s3 = entropy(Statevector([1, 0, 0, 0])) # Statevector object print(s1, s2, s3) # Mixed state entropy # The following are equivalent s1 = entropy([[0.75, 0], [0, 0.25]]) # Density matrix as list s2 = entropy(np.array([[0.75, 0], [0, 0.25]])) # density matrix as array s3 = entropy(DensityMatrix([[0.75, 0], [0, 0.25]])) # Density matrix object print(s1, s2, s3) As for your specific issue: the entropy is only well-defined for a valid quantum state, so the function checks the input state is valid. In the case of a statevector this is checking it has norm 1, in the case of a density matrix that it is trace 1 and postive-semidefinite. Your example does not have a norm-1 input state because you truncated the decimals when you got the output state from the simulator. You can check this using the statevector object for example: # Returns True: Statevector([1 / np.sqrt(2), 1 / np.sqrt(2)]).is_valid() # Returns False: Statevector([0.707, 0.707]).is_valid() Entropy base: Another thing you should keep in mind if you didn't already notice is that the qiskit.quantum_info.entropy function takes logarithms in base 2 by default (and you can use a different base using the base kwarg). The deprecated qiskit.tools.qi.entropy function was always taken in log base e: import numpy as np from qiskit.quantum_info import entropy from qiskit.tools.qi import entropy as old_entropy rho = [[0.75, 0], [0, 0.25]] s1 = entropy(rho) # base-2 s2 = entropy(rho, base=np.e) # base-e s3 = old_entropy(rho) # base-e print(s1, s2, s3, s2 == s3) ```",03/08/2020 15:58
10164.0,"In Qiskit, where is the floating point operation performed?",I am using Qiskit - the simple circuits I am writing can either run on the hardware backend (using least_busy) or the QASM simulator backend. If I have statements like the following - (random_numbers were generated using QRNG in the circuits - not shown here) b = .6 a = .3 flt = [] for rn_num in random_numbers: flt.append( b*(a-rn_num) + a * rn_num) Where are these floating point operations performed? I am connected to IBM Quantum Experience - using Jupyter. Are these operations performed on a traditional machine or a quantum backend? My understanding is unless it is related to a Quantum circuit - everything gets executed on a traditional machine (similar to print or sockets?) Is there a document that explains this further? I read release notes - I found them a bit ambiguous. I found this comment in Aer 0.3 release note Increased performance with simulations that require less floating point numerical precision. Maybe this note is referring to statevectors in floating point ...??,<qiskit><programming><ibm-q-experience>,03/12/2020 09:43,10165.0,10165.0,"The Qiskit backends (quantum devices or simulators) work only when you explicitly invoke them, usually with execute. The code in your snippet does not call qiskit, and runs on a traditional machine.",03/12/2020 09:54
11568.0,Can I learn Quantum Programming and then go back to learn the Mathematics / Physics behind it later?,Learning from the ground up (while great) is an overdose of the mathematics behind quantum computing and is taking way too long to grasp. I have a Computer Science / Programming background. I am happy to learn the programming aspects and then go back and learn the math behind it or learn the background math whenever it is necessary while programming. I started with MacMahon's book and now on Nielsen and Chuang.. but I feel it is taking longer to get to the application layer.,<algorithm><resource-request><classical-computing>,4/16/2020 7:38,11570.0,11570.0,"Quantum computing is completely different paradigm in comparison with classical computers. Therefore an approach to programming quantum computers is different as well. It is not only about learning a new programming language but also about understanding underlying technology. Currently, there is only a little abstraction between quatum algorithms (programs) and quantum hardware. Nowadays, programming a quantum computer is similar to approach used in 1950's when computers were programmed in assembler or even microinstructions (what is different that we have common quantum gates). There are some higher programming languages (for example Qiskit based on Python) helping you to load data into a quantum computer and postprocess results. However, quantum algorithm is still expressed on quantum gates level. Overall, to be able to program quantum computer and understand why you do so, you should learn at least basic mathematical background of quantum computing.",4/16/2020 8:06
11610.0,Why don't I get what I expect when measuring with respect to a different basis?,"$\newcommand{\bra}[1]{\left&lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&gt;}\newcommand{\bk}[2]{\left&lt;#1\middle|#2\right&gt;}\newcommand{\bke}[3]{\left&lt;#1\middle|#2\middle|#3\right&gt;}$ If I make a rotation of $\frac{\pi}{4}$ around the x axis, starting from $\ket{0}$, I expect $\alpha = \frac{\sqrt{2 + \sqrt{2}}}{2}$ and $\beta= \frac{\sqrt{2 - \sqrt{2}}}{2}$ when measured with respect to the computational basis states of $\ket{0}$ and $\ket{1}$. I can verify this is correct empirically using a quantum simulator. I want to measure with respect to new basis states $\ket{+}$ and $\ket{-}$, defined in Quantum Computation and Quantum Information as follows $\ket{+} \equiv \frac{\ket{0}+\ket{1}}{\sqrt{2}}$, $\ket{-} \equiv \frac{\ket{0}-\ket{1}}{\sqrt{2}}$, and corresponding to the poles of the x axis of the Bloch sphere. Looking at the Bloch sphere, I would expect to get $\ket{+}$ half of the time, and $\ket{-}$ the other half, and I have been able to empirically verify this. However, according to the mathematics presented in the aforementioned book, I should be able to express this state $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, with the $\alpha$ and $\beta$ previously mentioned, as follows: $$\ket{\psi} = \alpha\ket{0} + \beta\ket{1} = \alpha\frac{\ket{+} + \ket{-}}{\sqrt{2}} + \beta\frac{\ket{+} - \ket{-}}{\sqrt{2}} = \frac{\alpha + \beta}{\sqrt{2}}\ket{+} + \frac{\alpha -\beta}{\sqrt{2}}\ket{-}$$ This math seems sound to me, however if I attempt to translate to this new basis using my $\alpha$ and $\beta$, I get $$ \frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{+} + \frac{\sqrt{2+\sqrt{2}} -\sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{-} $$ Since $\left(\frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\right)^2 \approx 0.85$ this is not at all what I expect from looking at the Bloch sphere, and does not match what I am able to demonstrate empirically. What am I missing? For reference, the important bit of my Q# code I've been using to test this is: Rx(PI()/4.0, qubit); set state = Measure([PauliX], [qubit]);",<quantum-state><mathematics><nielsen-and-chuang><q#><superposition>,4/19/2020 14:45,11613.0,11613.0,"I think there should be $-i$ in the expression for $\beta$: \begin{equation} R_x\left(\frac{\pi}{4}\right) |0\rangle= \begin{pmatrix} \cos\left(\frac{\pi}{8}\right) &amp; -i \sin\left(\frac{\pi}{8}\right) \\ -i \sin\left(\frac{\pi}{8}\right) &amp; \cos\left(\frac{\pi}{8}\right) \end{pmatrix} \begin{pmatrix} 1 \\ 0\end{pmatrix} = \\ =\frac{\sqrt{2 + \sqrt{2}}}{2} |0\rangle - i \frac{\sqrt{2 - \sqrt{2}}}{2} |1\rangle \end{equation} So, we will have: $$|\psi\rangle = \frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |+\rangle + \frac{\sqrt{2 + \sqrt{2}} + i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |-\rangle$$ Then: $$\left|\frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}}\right|^2 = 0.5 $$",4/19/2020 16:29
11620.0,How to create states in Qiskit using complex phase angles?,"How do we create an arbitrary vector of the following form in Qiskit? Say, we want to initialize a qubit with a vector, $$ \vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle $$ If I put it in the form $$ \vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle = cos(\frac{\theta}{2})|0&gt; + e^{i\phi}sin(\frac{\theta}{2})|1&gt; $$ where $0 &lt; \theta &lt; \pi$ and $0 &lt; \phi &lt;2\pi$ and then calculate $\theta$ and $\phi$ So, $$ cos(\frac{\theta}{2}) = \frac{1+i}{\sqrt{3}}\\ e^{i\phi}sin(\frac{\theta}{2}) = - \frac{i}{\sqrt{3}} $$ Therefore, $$ \theta = 2 * \arccos{\frac{1+i}{\sqrt{3}}} \\ \phi = i * ln(\frac{- \frac{i}{\sqrt{3}}}{sin(\frac{\theta}{2})}) $$ Now, I am using the following code.. #We create the quantum state manually first arb_quantum_state = ((1+1.j)/math.sqrt(3))*ket_0 - (1.j/math.sqrt(3))*ket_1 print(arb_quantum_state) theta = 2*cmath.acos((1+1.j)/cmath.sqrt(3)) print('theta : ',theta) sinValue = cmath.sin(theta/2) print(sinValue) phase = -1*(1.j/cmath.sqrt(3))/sinValue phi = cmath.log(phase)/1.j print('phi : ',phi) # Use these theta and phi to create the circuit circ = QuantumCircuit(1,1) #Verify why complex values are not allowed #circ.u3(theta.real,phi.real,0,0) circ.u3(theta,phi,0,0) results = execute(circ, backend=Aer.get_backend('statevector_simulator')).result() quantum_state = results.get_statevector(circ, decimals=3) print (quantum_state) The above code creates the gate alright, but the execute function is returning the following error, TypeError: can't convert complex to float However, if I use just the real values of theta and phi, then the execute function returns a state vector, which is different than the one it should be.",<qiskit><programming><quantum-state>,4/20/2020 12:52,11621.0,11621.0,"The problem is that you're trying to equate $\cos(\theta/2)$ (a real number) with $(1+i)/\sqrt{3}$ (a complex number). The way around this is you need to take into account a global phase $\gamma$ such that $$ e^{i\gamma}|\psi\rangle=\cos\frac{\theta}{2}|0\rangle+e^{i\phi}\sin\frac{\theta}{2}|1\rangle. $$ To do this, it helps to express your initial state as complex exponentials: As a first step your state can be reduced to $$ |\psi\rangle=\sqrt{\frac{2}{3}}\left(\frac{1}{\sqrt{2}} + \frac{1}{\sqrt{2}}i\right)|0\rangle+\frac{1}{\sqrt{3}}\left(0 - i*1\right)|1\rangle $$ Then to, $$ |\psi\rangle=\sqrt{\frac{2}{3}}e^{i\pi/4}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{3}{2}\pi}|1\rangle $$ so that we can rewrite it as $$ |\psi\rangle=e^{i\pi/4}\left(\sqrt{\frac{2}{3}}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{5}{4}\pi}|1\rangle\right). $$ Now you can easily see that $$ \cos\frac{\theta}{2}=\sqrt{\frac{2}{3}},\qquad \phi=\frac{5\pi}{4},\qquad \gamma=\frac{\pi}{4}. $$",4/20/2020 13:14
11768.0,Using entropy_mutual function in QuTiP,"I am trying to calculate mutual entropies using QuTiP, but I am being unsuccessful so far. More specifically, I consider a 2^n x 2^n matrix representing the density operator of a n-qubit bipartite system AB made of system A (first m &lt; n qubits) and B (remaining n-m qubits). No tutorial nor material on the internet addressed this specific task. For simplicity, let us consider a 1-qubit system A and a 2-qubit system B and a density operator of dimension 8x8 representing AB in computational basis. More practically in python, let rhoAB = Qobj=(np.random.rand(8,8)), and assume that this is a valid density operator. How should I call entropy_mutual so that I can get this measure between A and B, in particular, regarding the arguments selA and selB? Ideally, I would call something like entopy_mutual(rhoAB, selA=[1], selB=[2,3]) but this not the approach how the function interprets the subsystems and their respective dimensions.",<programming><entropy><qutip>,4/30/2020 13:25,11795.0,11795.0,"Best to look at the source code when the documentation isn't helpful enough. The definition of entropy_mutual is def entropy_mutual(rho, selA, selB, base=e, sparse=False): """""" Calculates the mutual information S(A:B) between selection components of a system density matrix. Parameters ---------- rho : qobj Density matrix for composite quantum systems selA : int/list `int` or `list` of first selected density matrix components. selB : int/list `int` or `list` of second selected density matrix components. base : {e,2} Base of logarithm. sparse : {False,True} Use sparse eigensolver. Returns ------- ent_mut : float Mutual information between selected components. """""" if isinstance(selA, int): selA = [selA] if isinstance(selB, int): selB = [selB] if rho.type != 'oper': raise TypeError(""Input must be a density matrix."") if (len(selA) + len(selB)) != len(rho.dims[0]): raise TypeError(""Number of selected components must match "" + ""total number."") rhoA = ptrace(rho, selA) rhoB = ptrace(rho, selB) out = (entropy_vn(rhoA, base, sparse=sparse) + entropy_vn(rhoB, base, sparse=sparse) - entropy_vn(rho, base, sparse=sparse)) return out So we see selA and selB are passed as arguments to compute the partial trace. I am not too familiar with qutip but here is an example computing $S(A:B)$ for $\rho_{AB}$ where $A$ is a qubit system and $B$ is a two-qubit system. import qutip as qtp # note there is a rand_dm function # We should also let qutip know how are systems are partitioned # This is so it knows how to correctly compute the partial trace rho = qtp.rand_dm(8, dims=[[2,4],[2,4]]) qtp.entropy_mutual(rho,0,1) With the above example we could also specify the second system as two-qubits instead of a four dimensional system i.e. rho = qtp.rand_dm(8, dims=[[2,2,2],[2,2,2]]) qtp.entropy_mutual(rho,0,[1,2])",05/01/2020 16:38
11886.0,How can I make qiskit output raw data?,"I am new to quantum computing, and I want to make a program to output 0 or 1 randomly by Hadamard gate, and use that information to make a GUI interface. For example, a coin flip program that output ""Tail"" when it is 1, and ""Head"" when it is 0. However, when I try to get raw data by job.result(job), I get the information of the result instead. By the way, here is the code: from qiskit import * simulator = Aer.get_backend('qasm_simulator') qr = QuantumRegister(1) cr = ClassicalRegister(1) circuit = QuantumCircuit(qr, cr) circuit.h(qr[0]) circuit.measure(qr, cr) job = execute(circuit, backend = simulator, shots=1024) a = job.result(job) #the problematic code print(a) I use Qiskit with Python, and do not use Jupyter notebooks.",<qiskit><programming><hadamard>,05/07/2020 11:03,11887.0,11887.0,"You need to do .get_counts() to get a dictionary of the counts returned by the circuit. You would do this as follows job = execute(circuit, backend = simulator, shots=100) result = job.result() counts_dict = result.get_counts() Using your circuit and this code, counts_dict will look something like {'0':497, '1':503}. From there you might want to extract the key which has a higher value to be the result of your coin flip.",05/07/2020 11:30
11934.0,ModuleNotFoundError: No module named 'qiskit.circuit.library',I am importing from qiskit.circuit.library import MCMTVChain on python IDLE editor but it showing error ModuleNotFoundError: No module named 'qiskit.circuit.library' although it's working fine on google colab. Also why Qiskit does not work properly on python IDLE it's show lots of other error not just this one?,<qiskit><programming><circuit-construction><ibm-q-experience>,05/10/2020 02:11,11936.0,11936.0,"You most probably haven't installed the qiskit module. Qiskit can be installed via : pip install qiskit Try the following commands in command prompt, one of them should work (if your PATH variables are appropriately set): py -m pip install qiskit Or python -m pip install qiskit Or if you have more than one python versions, you can try: py -'version number like 3.7' pip install qiskit without the quotes. This should install the qiskit module and then you can import it.",05/10/2020 05:47
12073.0,How to reduce unnecessary waiting time when using IBM's backend?,"I'm working with a program, which needs iterations of quantum computation like this def quantum(n): Grover(oracle).run(QuantumInstance(...)) #n is input size associated with oracle, #and some other components are omitted. for n in range(0,10): start = time.time() quantum(n) end = time.time() Now I have to wait for hours to run this on the 16-qubit quantum computer. So is there any way to pack all computation into one round?",<qiskit><programming><ibm-q-experience>,5/19/2020 8:41,12074.0,12074.0,"Assuming your quantum() method creates a circuit, you can run lots of circuits in one go by using the execute command. For example execute([grover_1, grover_2, grover_3], backed=my_backend).",5/19/2020 10:03
12080.0,Evaluating expectation values of operators in Qiskit,"I'm wondering how in Qiskit one can calculate the expectation value of an operator given as a WeightedPauli (or, at least, of a single Pauli operator...) in a certain state (given as a QuantumCircuit object â â meaning that the actual state is the result of the action of this circuit on the computational basis state). I would like the inputs of such a procedure to be floats, not Parameters (it is an essential requirement â I'm using an external library to form the circuit for each set of parameters, and then converting it gate-by-gate to Qiskit format). This would be useful if, say, we wanted to manually implement VQE, and for that needed a function calculating the expectation value of the Hamiltonian on a quantum computer. More importantly, we would need this for implementing generalizations of VQE, such as subspace search. I guess, PauliBasisChange may be involved...",<qiskit><programming>,5/19/2020 12:04,12210.0,12210.0,"Note: This post is a bit older and Qiskit Aqua is now deprecated. Replace all occurences of qiskit.aqua.operators with qiskit.opflow to be compatible with Qiskit Terra 0.17.0 and above. The operators in Qiskit Aqua allow the evaluation of expectation values both exactly (via matrix multiplication) or on shot-based sampling (closer to real quantum computers). The basic principle is the same both times, it only differs in how the expectation value is evaluated in the end. First, you need to define the operator $O$ you're interested in and the state $|\psi\rangle$ with respect to which you want to compute the expecation value. So we're looking for $$ E = \langle\psi|O|\psi\rangle. $$ In the code below we have $O$ = op and $|\psi\rangle$ = psi. See also there for your use-case of a WeightedPauliOperator. # you can define your operator as circuit circuit = QuantumCircuit(2) circuit.z(0) circuit.z(1) op = CircuitOp(circuit) # and convert to an operator # or if you have a WeightedPauliOperator, do op = weighted_pauli_op.to_opflow() # but here we'll use the H2-molecule Hamiltonian from qiskit.aqua.operators import X, Y, Z, I op = (-1.0523732 * I^I) + (0.39793742 * I^Z) + (-0.3979374 * Z^I) \ + (-0.0112801 * Z^Z) + (0.18093119 * X^X) # define the state you w.r.t. which you want the expectation value psi = QuantumCircuit(2) psi.x(0) psi.x(1) # convert to a state psi = CircuitStateFn(psi) There are now different ways to evaluate the expectation value. The straightforward, &quot;mathematical&quot;, approach would be to take the adjoint of $|\psi\rangle$ (which is $\langle\psi|$) and multiply with $O$ and then $|\psi\rangle$ to get the expectation. You can actually do exactly this in Qiskit: # easy expectation value, use for small systems only! print('Math:', psi.adjoint().compose(op).compose(psi).eval().real) to get Exact: -1.0636533199999998 This is only suitable for small systems though. To use the simulators, and the also get the shot-based result, you can use the PauliExpectation (shots), AerPauliExpectation (exact) or MatrixExpectation (exact). Here's how to do it: from qiskit import Aer from qiskit.aqua import QuantumInstance from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn # define your backend or quantum instance (where you can add settings) backend = Aer.get_backend('qasm_simulator') q_instance = QuantumInstance(backend, shots=1024) # define the state to sample measurable_expression = StateFn(op, is_measurement=True).compose(psi) # convert to expectation value expectation = PauliExpectation().convert(measurable_expression) # get state sampler (you can also pass the backend directly) sampler = CircuitSampler(q_instance).convert(expectation) # evaluate print('Sampled:', sampler.eval().real) which yields Sampled: -1.0530518430859401 This result varies if you execute multiple times. For comparison, here the other methods to evaluate the expecation value expectation = AerPauliExpectation().convert(measurable_expression) sampler = CircuitSampler(backend).convert(expectation) print('Snapshot:', sampler.eval().real) expectation = MatrixExpectation().convert(measurable_expression) sampler = CircuitSampler(backend).convert(expectation) print('Matrix:', sampler.eval().real) which produces Snapshot: -1.06365328 Matrix: -1.06365328 I hope that clarifies how to compute the expectation value!",5/27/2020 17:40
12094.0,Tensor Product in Q#,"Does anyone know how you can obtain a new state |z&gt; from two pre-existing states |x&gt; and |y&gt; using the Tensor product in Q#? i.e. |z&gt; = |x&gt; â|y&gt; ? Thanks in advance for the help! Edit: for clarity, the states that I am working with are $|x\rangle = \frac{1}{\sqrt{2}} \sum^{3}_{j=0} \sin \frac{\pi (j + 0.5)}{4} |j\rangle$ $|y\rangle = \sum^{1}_{i=0} b_i |i\rangle$ where the $b_i$'s are just real numbers.",<programming><q#><tensor-product>,5/20/2020 12:53,12098.0,12098.0,"If you have an array of Qubit objects, and you prepare the individual qubits into arbitrary states, then the array effectively contains the tensor product of all of the original qubits. To quickly illustrate what I mean: using (qubits = Qubit[2]) { // do something to prepare qubits[0] individually // do something to prepare qubits[1] individually // now the state of ""qubits"" is the tensor product of the two // individual qubit states that you prepared } This also generalizes if you're preparing groups of qubits within the array that you allocated.",5/20/2020 15:59
12176.0,Modifying measurements in a Qiskit circuit,"Assume my function Qiskit receives a certain circuit as an input. How do I check if this circuit already has some measurements appended to it? If so, how can I modify them? For example, if there are measurements on certain qubits, I would like to remove those in order to add some more gates, and then add the measurement of all qubits.",<qiskit><programming>,5/25/2020 17:06,12182.0,12182.0,"The easiest way to do this is probably by converting the circuit to a DAGCircuit, which can be done using the method from qiskit.converters import circuit_to_dag. From the DAG you can get properties, such as any measurement operations, by using the function my_dag.named_nodes('measurement'). DAGNode objects are returned which will tell you the properties of the measurement. You can then remove nodes using my_dag.remove_op_node(a_measurement_node), it is preferable to remove and add nodes than to modify inplace. Following this you could convert the DAGCircuit back to a QuantumCircuit using from qiskit.converters import dag_to_circuit and then append any measurement operations as desired.",5/25/2020 19:38
12356.0,Transpiler Error: Number of qubits greater than maximum in coupling map,"Transpiler Error: Number of qubits (2) in circuit11 is greater than maximum (1) in the couplings map # Initialize two qubits and create Entanglement using Hadamard and CX/CNOT Gate q = qiskit.QuantumRegister(2) c = qiskit.ClassicalRegister(2) qc = qiskit.QuantumCircuit(q, c) qc.h(q[0]) qc.cx(q[0], q[1]) qc.measure(q, c) job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3) Error: --------------------------------------------------------------------------- TranspilerError Traceback (most recent call last) &lt;ipython-input-11-7b13276b10ae&gt; in &lt;module&gt;() 9 qc.cx(q[0], q[1]) 10 qc.measure(q, c) ---&gt; 11 job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3) 2 frames /usr/local/lib/python3.6/dist-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, **run_config) 249 seed_transpiler=seed_transpiler, 250 optimization_level=optimization_level, --&gt; 251 backend=backend) 252 253 if schedule_circuit: /usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, seed_transpiler, optimization_level, pass_manager, callback, output_name) 205 callback, output_name) 206 --&gt; 207 _check_circuits_coupling_map(circuits, transpile_args, backend) 208 209 # Transpile circuits in parallel /usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend) 245 'in {} '.format(circuit.name) + 246 'is greater than maximum ({}) '.format(max_qubits) + --&gt; 247 'in the coupling_map') 248 249 TranspilerError: 'Number of qubits (2) in circuit11 is greater than maximum (1) in the coupling_map'",<qiskit><programming>,06/06/2020 06:42,12359.0,12359.0,This error means that you are trying to execute a circuit on a backend that has fewer qubits than used in your circuit. In this case you are trying to execute a 2 qubit circuit on a device that only has one qubit. To fix this I would use a different backend which has 2 or more qubits. You can see how many qubits a backend has by looking at it on the IBM Quantum website or by calling backend.configuration(),06/06/2020 10:45
12474.0,How does a classical computer simulate nonclassical correlations?,"This may be a dumb question, if so please forgive me, it is late at night. I have learned that a classical computer can simulate a quantum computer in exponential time and space, but classical computers are bound to non-quantum phenomenon. How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate? In general, how could a classical computer simulate quantum phenomena that cannot be explained classically (such as the dynamics of more than a single particle)? I would think that one could not generate random numbers violating any of Bell's inequalities, i.e. necessarily quantum correlations are off limits.",<entanglement><simulation><classical-computing><nonlocal-games><non-locality>,6/14/2020 9:16,12479.0,12479.0,"How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate? Quantum phenomena cannot be ""explained classically"" only when locality is taken into consideration. In other words, classical phenomena cannot reproduce (some types of) quantum correlations provided that we don't allow for certain types of correlations. As a concrete example, consider a standard CHSH scenario. We can compute the outcome probability distributions for each measurement setting (it's what you do when you study the protocol), therefore you can trivially write some code to ""simulate"" the results of an experiment, meaning to draw a possible sequence of measurement outcomes you would find in an experiment. But this is clearly not the same as observing nonlocality with a classical computer: you would just be crunching some numbers that you know, in some situations, can be interpreted as markers of nonclassical correlations. Put in another way, you can always sample from an arbitrary probability distribution $p(ab|xy)$. Whether such a distribution is ""nonclassical"" is only meaningful in relation to some imposed restriction (e.g. defining ""classical"" when it can be written as $p(ab|xy)=\sum_\lambda p_\lambda p_\lambda(a|x) p_\lambda(b|y)$). When you simulate such a distribution on a computer, you don't need to respect such restrictions, so there is no problem. In general, how could a classical computer simulate quantum phenomena that cannot be explained classically Aside from locality constraints, such as those described above, quantum mechanics does not predict output probability distributions that are incompatible with classical physics. The difference is in how those outputs can be obtained: quantum mechanic can produce output probability distributions in a radically different way than what classical physics allows for, and in some cases these new behaviours are more efficient.",6/14/2020 12:46
12542.0,Graph coloring - Q# -,"I am checking Q# - Graph coloring for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) { InitializeColor(C, register); Can you help me explain this part of the code? Thnx for (N in 1 .. 4) { using (register = Qubit[N]) { for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) { InitializeColor(C, register); let measurementResults = MultiM(register); Fact(ResultArrayAsInt(measurementResults) == C, $&quot;Unexpected initialization result for N = {N}, C = {C} : {measurementResults}&quot;); ResetAll(register); } } } }",<programming><q#>,6/18/2020 20:33,12555.0,12555.0,This is part of the Graph Coloring Kata. The InitializeColor is an operation that you must implement. The code above is part of the checker code to confirm the working of the implementation. The code is used to check if the InitializeColor operation is implemented correctly. It is supposed to take an input C denoting the color as an non-negative integer. It is supposed to apply a unitary to convert the state $|000...0\rangle$ to state denoted by LittleEndian encoding of $|C\rangle$. The InitializeColor operation is supposed to take a register which is in the state $|0..0\rangle$ and applies a Unitary which transforms it into a register in the state $|C\rangle$. The nextline measures the register using the MultiM operation. The Fact function essentially confirms if the measured result in the state $|C\rangle$ and if not it print the error statement. The last line resets the register and brings it back to the state $|000..0\rangle$. An example can be with $C=2$ and $N=4$. Then InitializeColor should apply a Unitary Operation which transform $|0000\rangle$ into $|0100\rangle$ assuming LittleEndian encoding or $|0010\rangle$ assuming BigEndian encoding.,6/19/2020 13:00
12550.0,How to append an Instruction to a QuantumCircuit with variable length of QuantumRegisters as qargs?,"I think it is a bug but I'm not really sure. Basically, what I'm trying to do is the following: I have an Oracle Instruction which I want to append to my QuantumCircuit, looks as follows: # initialising registers for readability [control, train_register] = circ.qregs circ.h(control) # create and append oracle oracle = create_oracle(train_register, control) # returns an Instruction circ.append(oracle, [train_register, control]) If my train_register and control are both QuantumRegisters with length 1, this works perfectly fine. But I want to make this work for variable length of these registers, I get the error qiskit.circuit.exceptions.CircuitError: 'The amount of qubit arguments does not match the instruction expectation.'. This is logical, since this error occurs because qiskit checks the length of my provided qargs in QuantumCircuit.append(), and I provided two registers in a list with both one qubit, so the length of the list happens to be the same as the number of qubits. However, I want this to work for variable length. If I know what the length of my QuantumRegisters are, say len(train_register) is 3 and len(control) is 1 I can use circ.append(oracle, [0, 1, 2, 3]) Or to make it work for unspecified lengths, I can write something like: indices_to_append_to = list(np.arange(len(train_register) + len(control))) circ.append(oracle, indices_to_append_to) But I just really like the idea of just plugging in the names of the qregs as qargs. Is there something to make this work like that?",<quantum-gate><algorithm><qiskit><programming><circuit-construction>,6/19/2020 8:32,12551.0,12551.0,"If you pass a list of qubits instead of a list of register this works. For this do circ.append(oracle, train_register[:] + control[:]) where train_register and control are QuantumRegisters.",6/19/2020 8:49
12602.0,Finding phase angle in Q#,"I've trying to measure the phase angle from X axis of a qubit, but unable to find any function in Q# documentation, can anyone help me with this?",<quantum-state><entanglement><q#><phase-estimation>,6/22/2020 9:43,12768.0,12768.0,"If this is part of a debugging effort then you can use the DumpRegister function. If you have a qubit q which is in the general state $\alpha|0\rangle + \beta|1\rangle$ where $\alpha$ and $\beta$ are complex numbers such that $|\alpha|^2+|\beta|^2=1$. DumpRegister([q]) will give an output like this (Having Different Numbers) # wave function for qubits with ids (least to most significant): 1 â£0â­: 0.707107 + 0.000000 i == *********** [ 0.500000 ] --- [ 0.00000 rad ] â£1â­: -0.500000 + -0.500000 i == *********** [ 0.500000 ] / [ -2.35619 rad ] However if the qubit is entangled with some other qubit the result would be Qubits provided (0;) are entangled with some other qubit. Each row of the output tells the Amplitude of the Qubit along the Particular Computational Basis. The left hand values are in the Regular Complex Notation (Real and Imaginary Parts) and right hand values are in [Probability] [Phase]. The phase angle with $X$ axis is simply the $\arctan$ of the ratio of the absolute values of the amplitudes. Proof: Let us say the results give the amplitudes of basis states $|0\rangle$ and $|1\rangle$ as $\alpha = \alpha_R + i\alpha_I = |\alpha|e^{i\theta_1}$ and $ \beta = \beta_R + i\beta_I =|\beta|e^{i\theta_2} $ respectively. Then q is in the state $\alpha|0\rangle + \beta|1\rangle = |\alpha|e^{i\theta_1}|0\rangle + |\beta|e^{i\theta_2}|1\rangle$. We can remove the global phase and thus the relative phase will be $e^{i\theta_1-i\theta_2} = e^{i\theta}$ and let $\phi = 2\arctan\frac{|\beta|}{|\alpha|}$. Thus q is in the state $\cos\frac{\theta}{2}|0\rangle + e^{i\theta}\sin\frac{\theta}{2}|1\rangle$. This state can be represented on the Bloch Sphere by the coordinates $(\sin\theta\cos\phi, \sin\theta\sin\phi, \cos\theta)$. Consequently the phase angle with X axis is given by $\arctan$ of the $x$ and $y$ coordinates. Thus the phase angle is $\phi=2\arctan\frac{|\beta|}{|\alpha|}$",07/03/2020 15:47
12639.0,Find orthogonal state for random 7 qubit state,"I have a system that generates a random 7 qubit state and I need a method to always find the orthogonal state. I'm currently using python and qutip for this, representing this 7 qubit state by a 128-dimensional vector.",<algorithm><programming><qutip>,6/24/2020 17:19,12640.0,12640.0,"Basically, you divide the entire $7$-qubit Hilbert space into two subspaces: the one spanned by your state (let's call the state $|\psi\rangle$), let's call that subspace $W$, and it's orthogonal complement $V = W^{\perp}$. You want any vector from $V$, because this will by definition be orthogonal. We know that $P_{V}$ + $P_{W} = I$, with $P_{V}$ and $P_{W}$ being the projectors upon the $V$ and $W$ subspaces. Since $P_{W} = |\psi\rangle\langle\psi|$, we can easily calculate $P_{V}$: $$ P_{V} = I - |\psi\rangle\langle\psi|. $$ We can let this projection matrix act on virtually any state to obtain a state orthogonal on $|\psi\rangle$, lets use the $0$ vector $|00....0\rangle$. An orthogonal state $|\psi^{\perp}\rangle$ to $|\psi\rangle$ is thus: $$ |\psi^{\perp}\rangle = P_{V}|00...0\rangle = (I - |\psi\rangle\langle\psi|)|00...0\rangle = |00...0\rangle - \langle\psi|00...0\rangle|\psi\rangle $$ which is more or less the Gram-Schmidt process. Note that you can use (almost) any state instead of $|00...0\rangle$; the only state that you cannot use is $|\psi\rangle$ itself. In python, this becomes something like: from numpy import zeros_like, inner zeros_vect = zeros_like(psi_orig) psi_orth = zeros_vect - inner(zeros_vect,psi_orig).conj()*psi_orig",6/24/2020 17:42
12683.0,What would be the difference between using qsharp library on python vs learning the Q# langauge?,"One difference of course is the syntax. But I'm guessing the idea is eventually quantum computers will be able run Q#, whereas now it uses simulations. Will code written in Python with the qSharp library also be able to do this?",<simulation><q#>,6/27/2020 10:45,12691.0,12691.0,"There are several separate questions entangled here. Using Q# with Python as the host language is similar to using Q# with C# or another classical host language: it allows you to run Q# code and do necessary classical processing (for example, preparing the data or analyze the results). The Q# code invoked from the classical host language has to be written somewhere - it will be either the library code or the code you wrote yourself. Learning Q# language itself allows you to implement any algorithm you want; without doing that, you'll be limited to using algorithms implemented by somebody else. That's certainly possible. Running the program on quantum hardware vs in simulation is completely independent from the way you run it (from Python, C# or in standalone mode) - it's a matter of configuring the right target machine.",6/27/2020 18:51
12739.0,How to implement a while loop in a quantum computer?,"How can a while loop be implemented in a quantum computer? If quantum computing consists of : preparing a state applying a unitary operator measuring, then it seems like it's not possible to wait for an indefinite amount of time before measuring. How can one know that the while loop ended and that it's time to mesure ?",<algorithm><programming><physical-realization>,07/01/2020 17:06,12747.0,12747.0,"The way that many algorithms would deal with such a desire is to incorporate the measurement at a more fundamental level, essentially making it part of the 'while' condition. i.e. you have an output qubit that is 0/1 for computation complete or not, you measure it, and decide whether to continue or not. Because that's a bit of classical processing, it doesn't have to be reversible, and you avoid the need for infinite space. For example, many quantum algorithms only have a finite probability of success. For example, search or Factoring. In both of these cases, you know if you succeeded, and so there's an additional bit of classical logical that says &quot;repeat until successful&quot; i.e. a while loop.",07/02/2020 07:22
12841.0,Applying a gate to all line qubits without explicitly listing them in Cirq,"Say we have a custom gate CG, defined by a unitary matrix U, and line qubits qubits in Cirq. Something like this: import numpy import cirq U = np.eye(8) # The custom unitary matrix goes here CG = cirq.MatrixGate(U) qubits = cirq.LineQubit.range(3) We build the circuit as follows: circuit = cirq.Circuit() circuit.append(CG(qubits[0], qubits[1], qubits[2])) Is it possible to build the circuit without explicitly specifying all the qubits? Something like circuit.append(CG(qubits)), which would apply the CG gate to all the qubits?",<quantum-gate><programming><circuit-construction><cirq>,07/08/2020 22:18,12842.0,12842.0,"In Python you can say callable(*args) instead of callable(args[0], args[1], args[2]).",07/08/2020 23:34
12844.0,How the simulator work?,"Recently I focused on how to simulate in classical computer, and I found Qiskit offers qasmsimulator and statevector simulator. And others such as project Q also can simulate on classical computer. So is there a general way to simulate on classical computer? And what are differences among simulators? I mean actually it seems like we just need to multiply gate operation as matrixes.",<quantum-gate><quantum-state><qiskit><programming><simulation>,07/09/2020 06:21,12852.0,12852.0,"There are three major levels of simulation difficulty (broadly, there are a bunch of others, but these are the main levels.) Clifford simulators can simulate circuits composed of only Clifford elements on stabilizer states. This is classically efficient, since it is classically efficient to calculate the propagation of a Pauli operator through a Clifford gate. As a result, the simulator takes the stabilizers of the input state, propagates them through the circuit, and the resulting stabilizer group represents the final state. The idea that a quantum algorithm needs non-Clifford gates to be better than a classical one comes from the fact that a fully Clifford quantum algorithm could be simulated classically in polynomial time. The second level of simulation is State Vector simulation. In this case, we are basically doing what you mentioned in your question. We take an input state (of size $2^n$, where n is the number of qubits) and then apply gates to it through matrix multiplication. Due to the exponential size of the state, this requires resources exponential in the system size to be simulated, and as a result is not considered classically efficient. The only restriction on these simulations is that the gates must all be unitary and all states must be pure. The last level is Density Matrix simulation. Here, we store the full $2^n \times 2^n$ density matrix of the state. As a result we can simulate any quantum channel, and mixed states are permissible. However we now have an even bigger object to work with. These simulations are often necessary for doing work on simulating physical noise or other non-unitary processes, but are extremely limited in size due to their exponential resource requirements.",07/09/2020 19:03
12888.0,Is running a for loop faster on a quantum computer than a classical computer?,"Curious to understand if I run for loop within a quantum algorithm, and lets say I want the quantum algorithm to run in classical run time of O(1). Can this be done?",<algorithm><programming>,7/13/2020 19:51,12889.0,12889.0,"No, quantum computers can't run for-loops faster in general. There are certain specific tasks that can be done using a for-loop that can instead be done in a different way on a quantum computer, with fewer total operations. For example, Grover search can replace the loop for x in range(N): if predicate(x): y = x with something that uses $O(\sqrt{N})$ calls to predicate instead of the $N$ that the for loop is using.",7/13/2020 21:00
12898.0,How to construct quantum circuit to count number of 0-qubits and 1-qubits,"Suppose we have a 3-qubit input; each bit is either 0 or 1. How to decide if there are more 1's than 0's? Only 1 extra qubit may be used for the output. (Yes I know this can be achieved using 3 Toffoli gates, but can it be done without Toffoli gates?) Now suppose we have an answer to the above question, then, how to extend the above circuit to deal with a 5-qubit input?",<programming><circuit-construction>,7/14/2020 15:27,12907.0,12907.0,"Here's a general strategy that doesn't quite fulfil the brief: for an $n$-qubit input where $n+1=2^k$, $k$ an integer (e.g. $n=3,k=2$), it uses $k$ ancilla qubits but no Toffolis. (You can do something similar if $n+1$ is not a powe of 2, but you'd need some classical post-processing and I'd have thought you might as well just measure the input qubits!) The idea is to define a Hamiltonian $$ H=\left(\sum_{j=1}^nZ_j+nI\right)/2. $$ Note that this has eigenvalues $0,1,2,3,\ldots,n$ corresponding to the number of 1s in the string it's acting on. So, let $U=e^{2i\pi H/2^k}$. This is a unitary with the eigenvectors that we need. If you run a phase estimation procedure using $k$ ancilla qubits, it will exactly read out the number of 1s for you. This requires controlled-$U$, which is just a bunch of controlled-phase gates (i.e. all two-qubit gates) and the Fourier transform which, again, is two-qubit gates. Actually you only need the semi-classical Fourier transform, so it's just one-qubit gates with feed-forward of measurement results. So, once you know who many 1s there are, you can classically process that to decide if it's greater than $n/2$. In the case of $n+1$ being a power of 2, this is particularly simple. You just look at the bit representation of the output, and the most significant bit will give you the answer. So, this would be the only qubit you would need to measure. (Note that this is the last bit output by the Fourier transform, not the first).",7/15/2020 7:32
13063.0,Is it possible to convert classical algorithms to quantum ones?,"I am new in this field and I am considering to do research for my engineering degree. First, I would like to have an opinion from more experienced people. Do you think it is possible to convert classic algorithms to quantum algorithms? Having in mind that the conversion will take in consideration the particularities of quantum algorithms. If so, can you explain your point of view and if it is possible, an example?",<algorithm><classical-computing>,7/28/2020 5:47,13065.0,13065.0,"It depends on what you mean by converting classical algorithm to quantum one. One angle of view can be: Is it possible to run any classical algorithm on quantum computer? If this is a case then answer is yes. Since so-called Toffoli gate is effectivelly NAND gate (in case the controlled qubit is set to state $|1\rangle$ before) and such gate enables to implement any logical function. Hence, you can use universal gate-based quantum computer for implementation of any classical algorithm. Seconde angle of view could be: Is there a qunatum counterpart to any classical algorithm? In this case the answer is difficult and I am not sure whether it has been resolved already. However, there are some examples of quantum algorithms solving problems we have classical ones for. For instance: Shor's algorithm is used for integers factoring, Grover's algorithm for searching in unordered databases, HHL algorithm for solving systems of linear equations, there are Monte Carlo algorithms useful in finance, Hamiltonian simulations algorithms useful in simulation of quantum systems (the original purpose the quantum computers have been developed for) etc. Moreover, there is a family of so-called quantum annealers. These are single purpose quantum computers implementing quantum annealing algorithm on hardware level.",7/28/2020 7:34
13080.0,How to undo an operation in qiskit on jupyter notebook?,"I am not able to undo an operation. For example, I want a single Hadamard gate on a single qubit but by mistake two Hadamard gate added. Now I want to remove one of them without interrupting kernel. Is there any easy way. Please help me. Thank you.",<qiskit><programming><hadamard>,7/29/2020 7:43,13087.0,13087.0,To remove the last gate you can do qc.data.pop(). Example: qc = QuantumCircuit(1) qc.h(0) qc.draw('text') output: âââââ q_0: â¤ H â âââââ Then: qc.data.pop() qc.draw('text') output: q_0:,7/29/2020 13:41
13186.0,Is there a Q# funtion which returns the type of a variable?,"As the title says, I am asking myself is there is a specific function which returns the type of something. Ideally, I would work as follows : let a = 4.0; Message(Type(a)); This would print : double Is there anything similar to this ? I tried to look at the api, but didn't find anything, I could definitely have missed something there.",<programming><q#>,08/05/2020 16:27,13188.0,13188.0,"No, there isn't. We are avoiding having the means for types to impact the program flow, but I'd be interested to hear what the use case is. If is it only a matter of wanting to print the type rather than getting something that can be used within the program, then that is certainly something we could cover in the future (please consider making a feature request).",08/05/2020 19:28
13266.0,How to initialize a random state in Qiskit?,"I know I can make a random_circuit, but I see that Qiskit has random_statevector. I'd like to optimize computation time by initializing a state by that instead of putting a random circuit at the beginning. Is it possible and how do I do it? Thank you!",<qiskit><programming>,08/11/2020 15:55,13270.0,13270.0,"here is an example of how to initialize the random statevector then send it to the quantum circuit: from qiskit.quantum_info import random_statevector, Statevector from qiskit import QuantumCircuit # import numpy as np vec = random_statevector(2) # vec = Statevector([1, 0]) print('before circuit: {}'.format(vec)) qc = QuantumCircuit(1) qc.x(0) qc.draw() new_vec = vec.evolve(qc) print('after circuit: {}'.format(new_vec)) you should notice that the dim of state vector is 2 so the quantum circuit is 1 qubit.",08/12/2020 00:27
13341.0,Can classical linear algebra solvers implement quantum algorithms with similar speed-ups?,"A quantum algorithm begins with a register of qubits in an initial state, a unitary operator (the algorithm) manipulates the state of those qubits, and then the state of the qubits is read out (or at least some information about the state on a single run of the algorithm). It seems to me that a quantum computer answers the question of the unitary acts on the quantum state. This is &quot;just&quot; a matter of linear algebra. It strikes me, then, that quantum computers can be seen as linear algebra calculators. Why then do we need quantum mechanics? Can we not find a classical system which implements linear algebra operations and use this to implement the algorithms which have been designed for quantum computers? Of course classical digital computers will not suffice, these machines are based on binary processing of information rather than the manipulation of vectors in a high dimensional space. Question: Are there any candidates for classical linear algebra solvers (classical analog computers) which could implement the &quot;quantum computer&quot; algorithms whiles enjoying a similar speedup over digital classical computers? Question 2: Perhaps I'm over simplifying by reducing a quantum computer to being simply a linear algebra solver. Is this the case? What complexity am I glossing over?",<algorithm><classical-computing><speedup><information-theory>,8/16/2020 2:56,13344.0,13344.0,"The complexity that you are glossing over is that in the general case you need to store $2^n$ complex amplitudes to even represent an $n$ qubit system classically. Therefore, for a quantum computer of let's say 1000 qubits you need to store $2^{1000}$ complex amplitudes. Even if you use one atom per amplitude to do this, you still run out of atoms in the observable universe. As far as I know, the above is the general argument. However, there might still be ways to represent certain quantum algorithms in a classically tractable manner by utilising some clever insight to save on the representational needs of the algorithm, thereby going below the $2^n$ requirement. But this is likely to be problem-specific and unlikely to work in the general case.",8/16/2020 11:59
13433.0,Implementing block of gates at different times in a same qiskit program,"I am implementing an Ising chain over 8 qubits. It involves pair-wise CNOT between all the qubits. In the first time step, I am doing CNOTs between qubits 0 and 1, 2 and 3, 4 and 5, and 6 and 7. In the second time step, I would do CNOTs between qubits 1 and 2, 3 and 4, and 5 and 6. I have written the code as follows: # Block A for the first time step qp.cx(q0,q1) qp.cx(q2,q3) qp.cx(q4,q5) qp.cx(q6,q7) # Block B for the second time step qp.cx(q1,q2) qp.cx(q3,q4) qp.cx(q5,q6) I would like the gates in Block A to be applied simultaneously. Then, in the next step, gates in Block B should be applied simultaneously. How to convey to the compiler that I do not want the above written code to be compiled sequentially, rather I want it to be applied block-wise.",<qiskit><programming><ibm-q-experience>,8/22/2020 14:39,13457.0,13457.0,"Did you try to put a barrier between your two blocks? You can do this by writing this qp.barrier() right after your first block, then Qiskit will transpile separately the two blocks. Is this what you were searching for?",8/24/2020 14:16
13662.0,Error while running Qiskit code on real quantum hardware,"I started to learn Qiskit, so sorry if my question is very basic. So far I used qasm_simulator or state_vectorsimulator, however, now I would like to run my circuit on real IBM Q processor. Here is my code, I wanted to execute: %matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * provider = IBMQ.load_account() backend = provider.backends(name='ibmq_ourense') q = QuantumRegister(5, name = 'q') c = ClassicalRegister(2,name = 'c') circuit = QuantumCircuit(q,c) circuit.h(q[0]) circuit.cx(q[0],q[1]) circuit.measure(q[0],c[0]) circuit.measure(q[1],c[1]) job = execute(circuit, backend, shots = 1024) counts = job.result().get_counts() plot_histogram(counts) However, this error was shown: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-26-b48ae13f56aa&gt; in &lt;module&gt; 11 circuit.measure(q[1],c[1]) 12 ---&gt; 13 job = execute(circuit, backend, shots = 1024) 14 counts = job.result().get_couns() 15 plot_histogram(counts) /opt/conda/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config) 258 seed_transpiler=seed_transpiler, 259 optimization_level=optimization_level, --&gt; 260 backend=backend) 261 262 if schedule_circuit: /opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, seed_transpiler, optimization_level, pass_manager, callback, output_name) 211 callback, output_name) 212 --&gt; 213 _check_circuits_coupling_map(circuits, transpile_args, backend) 214 215 # Transpile circuits in parallel /opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend) 244 245 # If coupling_map is None, the limit might be in the backend (like in 1Q devices) --&gt; 246 elif backend is not None and not backend.configuration().simulator: 247 max_qubits = backend.configuration().n_qubits 248 AttributeError: 'list' object has no attribute 'configuration' I think that the problem is hidden in getting backends or execute command. Note: I run my code in Quantum Lab on IBM Q website interface. Could any please help me how to change my code to run it on real IBM Q processor?",<qiskit><programming><ibm-q-experience>,09/09/2020 11:08,13663.0,13663.0,Looks like backend = provider.backends(name='ibmq_ourense') returns a list of backends whose name is ibmq_oursense (a list whose length is obviously 1). Try backend = provider.backends(name='ibmq_ourense')[0].,09/09/2020 11:18
13774.0,My IBMQ job hangs forever?,"I am running a very simple script just to learn how to use IBMQ, but my job will hang indefinitely and I am forced to terminate it. from qiskit import * from qiskit.compiler import transpile, assemble from qiskit import IBMQ from qiskit import QuantumCircuit, execute, BasicAer import logging logging.basicConfig(filename='log',level=logging.DEBUG) IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') #SELECT A BACKEND backend = provider.get_backend('ibmq_qasm_simulator') #ALGO qr = QuantumRegister(3) cr = ClassicalRegister(3) circuit = QuantumCircuit(qr, cr) circuit.x(qr[0]) circuit.x(qr[1]) circuit.ccx(qr[0], qr[1], qr[2]) circuit.cx(qr[0], qr[1]) circuit.measure(qr, cr) print('About to run job') job = execute(circuit, backend) print('Job Finished') result = job.result() counts = result.get_counts(circuit) print(counts) In an attempt to debug, I am using &quot;logging.basicConfig&quot; which stops at: &quot;websocket._connect:DEBUG:2020-09-16 11:26:57,813: Starting new websocket connection: wss://wss.quantum-computing.ibm.com/jobs/5f6258f09234fe0012dbd748/status/v/1&quot; When I go to my IBMQ home page it says that the job has run successfully. It is only at the line result = job.result() that it fails. So it seems that the websocket is hanging forever. I'd appreciate any help I can get to fix this issue.",<qiskit><programming><ibm-q-experience>,9/16/2020 18:39,13775.0,13775.0,"The function execute is non-blocking. That means that it will return after sending the job, but not necessarily with the result. In your code, you should wait for the status of the job to be DONE: print('About to run job') job = execute(circuit, backend) job.status() JobStatus.QUEUED After waiting some time: job.status() JobStatus.DONE Then, job.result() will work.",9/16/2020 18:53
13878.0,Why does job appear to be stuck in queue on IBMQ backend?,"I have submitted a batch of circuits to ibmq_vigo using the IBMQJobManager and the batch is correctly split properly into multiple jobs(as viewed on the dashboard), however the job at the front of the queue appears stuck at the front for multiple hours. The backend does not appear to be in reserve mode and I did not have this issue when I successfully executed the same batch of circuits on ibmq_rochester. Does anyone know what might be the issue? Also this is my second unsuccessful attempt at executing on ibmq_vigo.",<programming><ibm-q-experience>,9/22/2020 19:27,13881.0,13881.0,"Sometime that happens. The controlled electronic might got a reboot during while your jobs were in queue or something of that sort... You can try to cancel your jobs and resubmitted them to see if that fixes it. Note that if you running jobs through Aqua, like performing QAOA or VQE, you can cancel the current jobs and they will create a replacement job automatically.",9/22/2020 22:54
13894.0,Qiskit: Error when importing libraries for ADMM optimizer,"I would like to try and ADMM optimizer as shown in Qiskit Tutorial in Quantum Lab. Firstly, I imported necessary libraries (copy/paste from the Tutorial): import time from typing import List, Optional, Any import numpy as np import matplotlib.pyplot as plt from docplex.mp.model import Model from qiskit import BasicAer from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer from qiskit.optimization.problems import QuadraticProgram from qiskit.optimization.algorithms.admm_optimizer import ADMMParameters, ADMMOptimizer When I started the import this error appeared: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-32-c32e151d13df&gt; in &lt;module&gt; 11 12 from qiskit import BasicAer ---&gt; 13 from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver 14 from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer 15 from qiskit.optimization.problems import QuadraticProgram /opt/conda/lib/python3.7/site-packages/qiskit/aqua/__init__.py in &lt;module&gt; 75 from .aqua_globals import aqua_globals 76 from .quantum_instance import QuantumInstance ---&gt; 77 from .algorithms import QuantumAlgorithm 78 from ._logging import (QiskitLogDomains, 79 get_logging_level, /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/__init__.py in &lt;module&gt; 190 from .eigen_solvers import NumPyEigensolver, ExactEigensolver, EigensolverResult 191 from .factorizers import Shor --&gt; 192 from .linear_solvers import HHL, NumPyLSsolver, ExactLSsolver 193 from .minimum_eigen_solvers import (VQE, VQEResult, QAOA, IQPE, IQPEResult, QPE, QPEResult, 194 ClassicalCPLEX, CPLEX_Ising, NumPyMinimumEigensolver, /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/__init__.py in &lt;module&gt; 15 &quot;&quot;&quot; Linear Solvers Package &quot;&quot;&quot; 16 ---&gt; 17 from .hhl import HHL 18 from .numpy_ls_solver import NumPyLSsolver, ExactLSsolver 19 /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/hhl.py in &lt;module&gt; 24 from qiskit.aqua import QuantumInstance 25 from qiskit.aqua.algorithms import QuantumAlgorithm ---&gt; 26 from qiskit.ignis.verification.tomography import state_tomography_circuits, \ 27 StateTomographyFitter 28 from qiskit.converters import circuit_to_dag /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/__init__.py in &lt;module&gt; 98 &quot;&quot;&quot; 99 from .quantum_volume import qv_circuits, QVFitter --&gt; 100 from .randomized_benchmarking import (CNOTDihedral, 101 randomized_benchmarking_seq, 102 RBFitter, InterleavedRBFitter, /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/__init__.py in &lt;module&gt; 19 20 # Randomized Benchmarking functions ---&gt; 21 from .circuits import randomized_benchmarking_seq 22 from .dihedral import (CNOTDihedral, decompose_cnotdihedral, random_cnotdihedral) 23 from .fitters import (RBFitter, InterleavedRBFitter, PurityRBFitter, /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/circuits.py in &lt;module&gt; 204 is_purity: bool = False, 205 group_gates: Optional[str] = None, --&gt; 206 rand_seed: Optional[Union[int, RandomState]] = None) -&gt; \ 207 (List[List[qiskit.QuantumCircuit]], List[List[int]], 208 Optional[List[List[qiskit.QuantumCircuit]]], AttributeError: module 'qiskit' has no attribute 'quantum_info' Since I only copied the code, it seems there is some bug. Does anybody know how to solve this? Note: I work in Quantum Lab in IBM Q Experience interface",<qiskit><programming><ibm-q-experience><optimization>,9/24/2020 11:43,13897.0,13897.0,"Looks like a glitch. It is not reproducible under my account. I've seen similar errors when there's mismatch in versions between Qiskit Aqua and Terra installed locally, but I don't think it is the case in Quantum Lab. Try to restart the kernel or create a new notebook and run the same imports.",9/24/2020 15:01
13933.0,On number of parameters and operators in UCCSD in qiskit,"I have two questions on UCCSD in qiskit, please see the code below. import numpy as np from qiskit.chemistry.components.variational_forms import UCCSD from qiskit.chemistry.drivers import PySCFDriver, UnitsType from qiskit.chemistry import FermionicOperator from qiskit.aqua import QuantumInstance def get_qubit_op( atom , basis , map_type ): driver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, charge=0, spin=0, basis=basis) molecule = driver.run() repulsion_energy = molecule.nuclear_repulsion_energy num_particles = molecule.num_alpha + molecule.num_beta num_spin_orbitals = molecule.num_orbitals * 2 ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals) qubitOp = ferOp.mapping(map_type=map_type, threshold=0.00000001) # qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles) shift = repulsion_energy return qubitOp, num_particles, num_spin_orbitals, shift atom='H .0 .0 .0; H .0 .0 0.74' qubitOp, num_particles, num_spin_orbitals, shift = get_qubit_op( atom , basis = 'sto3g' , map_type = 'parity' ) num_qubits = qubitOp.num_qubits print( 'num_qubits = ' , num_qubits ) from qiskit.chemistry.components.initial_states import HartreeFock init_state = HartreeFock( num_spin_orbitals , num_particles , 'parity' , two_qubit_reduction=False ) # setup the variational form for VQE from qiskit.chemistry.components.variational_forms import UCCSD var_form_vqe = UCCSD( num_orbitals=num_spin_orbitals, num_particles=num_particles, initial_state=init_state, qubit_mapping='parity' , two_qubit_reduction = False ) print( 'var_form_vqe.num_parameters = ' , var_form_vqe.num_parameters ) var_form_vqe.construct_circuit([1,1,1]).draw() # Give some random para The outputs are (without the plot of the circuit) num_qubits = 4 var_form_vqe.num_parameters = 3 My questions are 1. Why there are only 3 free parameters in UCCSD? Since I have 4 spin-orbs, I should expect there are at least 4^4 free parameters from the double excitation operators? 2. Is there a way to see which operators are involved in UCCSD? I plot out the circuit, but there are âEvolution^1â block involved. If I use âdecompose().â, it shows all the 1 and 2 qubit operations? Would it be possible to show something in between, by which I mean for example adding barrier for the decomposed circuit, or showing which fermionic excitation operators are involved? Many thanks!",<qiskit><programming><vqe>,9/28/2020 5:14,13934.0,13934.0,"Since UCCSD is a particle- and spin-conserving variational form, the number of parameters does not only depend on the number of spin orbitals but also their &quot;nature&quot;. What I mean by that is that you also need to consider these conservation rules which leads to the following scenario in your case: H2 has 2 electrons in 2 molecular orbitals, which correspond to 4 spin orbitals (and, thus, 4 qubits since you do not apply any reductions, here). Taking into account the spin-conservation you have the following possible single excitations: 0 -&gt; 1 2 -&gt; 3 where I use Qiskit's notation in which spin orbitals are ordered block-wise (i.e. first all alpha orbitals, then all beta ones). If the spin was not conserved, then you would also see excitations such as 0 -&gt; 3 and 1 -&gt; 2. The double excitations are a little bit simpler in this case because there is only one possibility regardless: 0, 1 -&gt; 2, 3 However, if the example was more complex, the same reasoning would apply here, too. Regarding your second question: if you would like to see the excitation lists as I have written them above you can take a look at the single_excitations and double_excitations attributes of the UCCSD class. I am not aware of any &quot;partial&quot; decompose() functionality which could otherwise provide that you describe above.",9/28/2020 6:14
13937.0,Why is circuit inverse not working for EfficientSU2?,"For some reason I get the following error when attempting to find the inverse of the EfficientSU2 VQE variational form: TypeError: 'NoneType' object is not reversible My code is as follows: var_form = EfficientSU2(6, entanglement=&quot;linear&quot;) var_form_inv = var_form.inverse() # error thrown of this line Is there a bug in the implementation of the inverse method? and if so how can I implement a working inverse function? Note qiskit.__qiskit_version__: {'qiskit-terra': '0.15.2', 'qiskit-aer': '0.6.1', 'qiskit-ignis': '0.4.0', 'qiskit-ibmq-provider': '0.9.0', 'qiskit-aqua': '0.7.5', 'qiskit': '0.21.0'}",<qiskit><programming><ibm-q-experience><vqe>,9/28/2020 8:38,13938.0,13938.0,"EfficientSU2 is a BlueprintCircuit and does not populates its internal data field until you try to access them. In this case, when you are calling the inverse function the data are still empty (None) and this is the error you are getting. It is probably a bug and should be fixed. Nevertheless, as a workaround for now you can try: var_form = EfficientSU2(6, entanglement=&quot;linear&quot;) # build the circuit var_form._build() # or just print it print(var_form) var_form_inv = var_form.inverse()",9/28/2020 9:31
13987.0,How to realize Su-Schrieffer-Heeger model in Qiskit,"This is a very specific question, which I try to implement a simple dimerized tight-binding Hamiltonian on qiskit. The model is one dimensional, and defined as $$ H = \sum_{\langle i,j\rangle} t_{ij} c^\dagger_i c_j $$ where $\langle i,j\rangle$ denotes the nearest neighbor coupling with strength $t_{ij}$. The important aspect of the model is that the coupling is dimerized in the following sense. If we label the sites as 1,2,3,4...., then the nearest neighbor coupling $t_{ij}$ reads, for example, $$ t_{1,2} = 1, t_{2,3} = 2 , t_{3,4} = 1 , t_{4,5} = 2, etc $$ which is alternating. I try to pretend this is a molecular Hamiltonian and realize it in the same way with &quot;FermionicOperator&quot;. However, I am not sure how to properly index the &quot;one-body&quot; integral here, which is the nearest neighbor coupling $t_{ij}$ here.",<qiskit><programming><ibm-q-experience><hamiltonian-simulation>,10/01/2020 23:41,13991.0,13991.0,"I don't think it really matter how you index your $t_{ij}$. As you mentioned you can use FermionicOperator all you need to do is define the one body integral. This of course can be done in many ways. Here is a convenient way. def ssh_ham(gamma, lamda, n): sigmax = np.array([[0,1],[1,0]], dtype=np.complex_) sigmay = np.array([[0,-1j],[1j,0]], dtype=np.complex_) op_eye_x = np.eye(n) op_cos_x = 1/2*(np.eye(n, k=1) + np.eye(n,k=-1)) op_sin_x = 1j/2*(np.eye(n, k=1) - np.eye(n,k=-1)) h = np.kron(gamma*op_eye_x + lamda*op_cos_x, sigmax) + np.kron(lamda*op_sin_x, sigmay) return h This function would return the one-body integral for you. In this function, the $\sigma$ degree of freedom represents the two atoms in the unit cell, and $n$ represents how many unit cells you have in the SSH chain, and for the dimmerized limit you asked for you can take $\gamma = 1,\ \lambda = 2 $. You can use the output of this function fer_op = FermionicOperator(h1 = ssh_ham(1,2,10)) That being said, I'm not sure what the benefit would be. Trying to solve this Hamiltonian using VQE for example is an over-kill since this Hamiltonian can be readily diagonalized from its one-body Hamiltonian. Putting this on a quantum computer would give you $2n$ qubits, this is a Hilbert space of $2^n$ dimensions, whereas you can diagonalize the the Hamiltonian by diagonalizing the $2n \times 2n$ matrix $t_{ij}$.",10/02/2020 12:58
14017.0,How do I visualize the action of Pauli $X$ and $Y$ gates on $|0\rangle$?,"I visualize Pauli Gates making rotations by Ï radians about the x, y, and z axes on the Bloch sphere. If this is the case, then how Pauli-X and Pauli-Y gates applied to $|0\rangle$ differ? As both should rotate the $|0\rangle$ state to same location.",<quantum-gate><programming><pauli-gates>,10/05/2020 04:32,14021.0,14021.0,"Applying X gate to the $|0\rangle$ state gives you $|1\rangle$, and applying Y gate to the $|0\rangle$ state gives you $i|1\rangle$. These states differ only by a global phase (the $i$ scalar multiplier in the second case), so they are not physically distinguishable (you cannot set up an experiment to observe the difference between them). Bloch sphere represents all states that differ by a global phase as one point on it, so you won't be able to see the difference using it. X and Y gates differ in their effect on most other states, though (except $|1\rangle$, which will give you the same issue).",10/05/2020 05:22
14044.0,How can I run a job as offline on real hardware?,"Can I run circuits on real hardware as offline? I mean that a job with 100 circuits may take a long time and I want to shot down my laptop in running time. In the meantime, can the real hardware run all of the circuits in the job, and in another time I can obtain my results? Or is it necessary my laptop to be turned on till I receive the last result? If I need any code for this issue, I would be very grateful anyone can provide it.",<programming><ibm-q-experience>,10/07/2020 19:34,14045.0,14045.0,"All jobs sent to IBMQ backends are asynchronous. You just need to save the job ID and use the ID retrieve it later. For example: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_vigo') job = execute(circuits, backend) print(job.job_id()) Once the job is submitted, you can turn off your laptop. Then when you're ready to get the results, do result = backend.retrieve_job(job_id).result() If you forget to write down the job ID, you can always find it on the IQX dashboard or use backend.jobs() to query for it.",10/07/2020 20:46
14115.0,I don't get anything when calling circuit.draw(),"I'm following the YouTube tutorials for Programming on Quantum Computers and I've completed everything until I reach circuit.draw() since I don't get $|0\rangle$ or 0 next to q or c. Here's my code: from qiskit import * qr = QuantumRegister(2) cr = ClassicalRegister(2) circuit = QuantumCircuit(qr, cr) %matplotlib inline circuit.draw() [ q0_0: q0_1: c0: 2/ ] and so when I attempt an H gate, I receive the error 'QuantumRegister' object is not callable: circuit.h(qr(0)) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-55-c8b4318b743b&gt; in &lt;module&gt; ----&gt; 1 circuit.h(qr(0)) TypeError: 'QuantumRegister' object is not callable",<qiskit><programming>,10/12/2020 12:55,14116.0,14116.0,"There is probably a change on the default arguments of draw() function. To reproduce the same visualization as on the youtube video, try: circuit.draw(initial_state=True, cregbundle=False) and add a Hadamard gate like: circuit.h(qr[0])",10/12/2020 13:07
14141.0,Output a Cirq gate as a Numpy array?,"How do I output a Cirq gate as a Numpy array? For example, I would like to print a Pauli X gate cirq.X as numpy.array([[0,1],[1,0]]) Thank you.",<programming><cirq>,10/14/2020 6:52,14145.0,14145.0,"This can be done by calling cirq.unitary. &gt;&gt;&gt; import cirq &gt;&gt;&gt; cirq.unitary(cirq.X) array([[0.+0.j, 1.+0.j], [1.+0.j, 0.+0.j]])",10/14/2020 14:28
14226.0,Suppress Warnings,"I wish to know how to suppress the following warning obtained on qiskit when I try to add two different types of noise to a qubit WARNING: quantum error already exists for instruction &quot;u2&quot; on qubits [0] , appending additional error. I know that some warnings can be suppressed with import warnings warnings.filterwarnings('ignore', category=DeprecationWarning) but I do not know what category my warning is contained in. I would also like to know if I can access somewhere all the different warning categories. Additionally trying import warnings warnings.filterwarnings('ignore') to suppress all warnings does not help.",<qiskit><programming><ibm-q-experience>,10/18/2020 6:47,14243.0,14243.0,"Qiskit's NoiseModel class processes warnings through a logger from the logging package, not through the warnings package, so suppressing warnings as in other answers won't help. However, each method in NoiseModel provides a warnings parameter; it defaults to True but you can set it to False to prevent the warnings from being logged. Example: myNoiseModel.add_quantum_error(..., warnings=False)",10/19/2020 1:52
14229.0,Qiskit BasicAer simulator options,"I usually use Qiskit &quot;Aer&quot; to simulate quantum circuit with several methods such as statevector, density_matrix, stabilizer, extended_stabilizer, and matrix_product_state. Recenlty I came across another simulator called &quot;BasicAer&quot; and I wonder if the qiskit BasicAer supports above methods.",<qiskit><programming><simulation>,10/18/2020 7:59,14234.0,14234.0,"For any provider, you can check the backends with backends(): from qiskit import BasicAer BasicAer.backends() [&lt;QasmSimulatorPy('qasm_simulator') from BasicAer()&gt;, &lt;StatevectorSimulatorPy('statevector_simulator') from BasicAer()&gt;, &lt;UnitarySimulatorPy('unitary_simulator') from BasicAer()&gt;] Check the doc for each of them: for backend in BasicAer.backends(): print(&quot;%s: %s&quot; % (backend.name(), backend.__doc__)) qasm_simulator: Python implementation of a qasm simulator. statevector_simulator: Python statevector simulator. unitary_simulator: Python implementation of a unitary simulator.",10/18/2020 13:45
14241.0,Producing $|ghz\rangle\langle ghz|$ State in Cirq,"I could manage to produce 3 qubit ghz state in Cirq. But I don't know how I can produce $|GHZ\rangle\langle GHZ|$ in Cirq Here is my code for 3 qubit ghz state Can you help me please for improving my code from $|GHZ\rangle$ to $|GHZ\rangle\langle GHZ|$: n = 3 qubits = cirq.LineQubit.range ( n ) def circuit (): circuit = cirq.Circuit () circuit.append (cirq.H(qubits[0])) for i in range (n-1): circuit.append ( cirq.CNOT ( qubits [i] , qubits [i+1]) ) circuit.append (cirq.measure (* qubits , key ='x') ) print (circuit) return circuit def simulation (circuit): simulator = cirq.Simulator() results = simulator.run ( circuit , repetitions = 200) counts = cirq.plot_state_histogram (results) def main(): simulation (circuit()) if __name__ == &quot;__main__ &quot;: main ()",<programming><quantum-state><cirq><ghz-state>,10/18/2020 18:33,14529.0,14529.0,"Since you can produce the GHZ state, I will skip the corresponding code and just use that QuantumCircuit object to build a density matrix $|GHZ&gt;&lt;GHZ|$. from qiskit.quantum_info import DensityMatrix DM=DensityMatrix.from_instruction(circuit) # here circuit denotes the circuit that contains your GHZ state. Or there is another way to do so(not recommended, just for reference). from qiskit.aqua.operators import StateFn psi=StateFn(circuit)# produce the state vector DM=(psi@~psi).eval()# state ket tensor state bra =density matrix # When calling StateFn function, the quantum circuit must not contain classical register But note that the density matrix produced by the latter method is not admitted by qiskit, because the DensityMatrix object in qiskit has two attributes(the matrix itself and its dimension).",11/08/2020 12:06
14286.0,Multiple Bipartite Entangled State in Cirq,"I am trying to create this state: rho = = q . rho_{1,2} + r . rho_{2,3} + s . rho{1,3} + (1-q-r-s) . rho_separable And I wrote this code: import random import numpy as np import cirq circuit, circuit2, circuit3 = cirq.Circuit() p = 0.2 q = 0.1 r = 0.3 alice, bob, charlie = cirq.LineQubit.range(1, 4) rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) #circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) rho_23 = circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) rho_13 = circuit.append([cirq.H(alice), cirq.CNOT(alice, charlie)]) circuit = rho_12 + rho_23 + rho_13 print(circuit) In here I have 2 problem: 1)This line is not working: circuit = rho_12 + rho_23 + rho_13 2)I cannot multiply the state with p or q or r. What I mean is that I can't write this line: rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) * q Could you please show me how I can write this state?",<programming><quantum-state><entanglement><cirq>,10/21/2020 20:38,14287.0,14287.0,"You seem to think append is returning a circuit, instead of modifying the circuit you called it on. circuit.append(op) doesn't return anything, it adds an operation to circuit. alice, bob, charlie = cirq.LineQubit.range(1, 4) circuit = cirq.Circuit() circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) ... Alternatively, you can make a new circuit for each of the pieces and then add them together: rho_12 = cirq.Circuit( cirq.H(alice), cirq.CNOT(alice, bob), ) ... circuit = rho_12 + rho_23 + rho_13",10/21/2020 21:28
14301.0,State Vector Output for T$|1\rangle$ in Qiskit differs from manual calculation. Why is this so?,"The T Gate is defined as $\begin{bmatrix} 1&amp;0 \\ 0&amp;e^{i\pi/4} \end{bmatrix} = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$ So $\begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \vert 1 \rangle = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ \frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$ But the following code for the T Gate gives a slightly different output: from qiskit import QuantumCircuit, Aer, execute from qiskit_textbook.tools import array_to_latex qc = QuantumCircuit(1) qc.initialize([0,1],0) # initialize to |1&gt; qc.t(0) display(qc.draw('mpl')) backend = Aer.get_backend('statevector_simulator') # simulate the circuit state = execute(qc,backend).result().get_statevector() # get final state array_to_latex(state, pretext=&quot;\\text{Output} = &quot;) # show final state vector which is $\begin{bmatrix} 0 \\ \frac{1}{\sqrt{2}}(1+i) \end{bmatrix}.$ Why do these two results differ? Thanks for any insights.",<qiskit><programming><quantum-state>,10/22/2020 21:51,14302.0,14302.0,"$\frac{\sqrt{2}}{2}(1+i) $ = $\frac{1}{\sqrt{2}}(1+i)$. To see how this is the case, multiply the numerator and denominator of $\frac{1}{\sqrt{2}}$ by $\frac{\sqrt{2}}{\sqrt{2}}$ = $1$. $\frac {\sqrt{2}}{\sqrt{2}} \frac{1}{\sqrt{2}} = \frac{\sqrt{2}}{{2}}$ . The result doesn't differ; only how it's displayed in comparison to your manual calculation does.",10/22/2020 22:07
14681.0,IBM Q - Individual Run Results,"In Qiskit, is there a way to get the individual results from each shot on the IBM quantum device (instead of simply the summary statistics)? The result JSON file provides the count of all the 1024 shots.",<qiskit><programming><ibm-q-experience>,11/16/2020 18:01,14682.0,14682.0,"You can set memory=True in assemble() or execute(). Then use result.get_memory() to get the per-shot measurement. For example: job = execute(circs, memory=True, shots=4) result = job.result() print(result.get_counts(0)) # prints {'00': 3, '11': 1} print(result.get_memory(0)) # prints ['00', '00', '11', '00']",11/16/2020 19:28
14698.0,$S^{\dagger}$ gate in Q#,"I would like to implement $S^{\dagger}$ gate in Q# and I would like the best way to do it, is it correct to say that $S^{\dagger}$ is equivalent to R1( -Pi()/2 , q) ? Is it also correct to say that $S^{\dagger}$ is equivalent to Rz( -Pi()/2 , q) but with a global phase ? Thank you.",<q#>,11/17/2020 13:31,14699.0,14699.0,It is correct. Since you have $R_1(\theta) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; e^{i\theta}\end{bmatrix}$ and $R_z(\theta) = \begin{bmatrix}e^{-i\theta/2} &amp; 0\\ 0 &amp; e^{i\theta/2}\end{bmatrix}$ just using the value of $\theta = -\pi/2$ gives you $R_1(-\pi/2) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix} = S^{\dagger}$ and $R_z(-\pi/2) = e^{i\pi/4}\begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix}$ which works exactly the same as $S^{\dagger}$ but with a global phase of $e^{i\pi/4}$.,11/17/2020 13:56
14718.0,How do I check what is wrong in my full-adder code?,"I am trying to solve the first question on the qiskit test which is writing a code for a full adder. So based on my research if I have $A$ q[0], $B$ q[1] and $C$ in q[2] as input and Sum and Cout as output, I should be able to produce the correct outputs by the following gates: q[0] XOR1 q[1] ---&gt; q[4] q[0] AND1 q[1] ---&gt; q[3] q[2] XOR2 q[4] ---&gt; q[5] (SUM) q[2] AND2 q[4] ---&gt; q[6] q[3] OR q[6] ---&gt; q[7] (COUT) Writing the following program I get that my answer is producing wrong results : from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from qiskit import IBMQ, Aer, execute ##### build your quantum circuit here #Define registers and a quantum circuit q = QuantumRegister(8) c = ClassicalRegister(2) qc = QuantumCircuit(q,c) # Preparing inputs qc.x(q[0]) # Comment this line to make Qbit0 = |0&gt; qc.x(q[1]) # Comment this line to make Qbit1 = |0&gt; qc.x(q[2]) # Comment this line to make Qbit2 = |0&gt; ( carry-in bit ) qc.barrier() # AND gate1 implementation qc.ccx(q[0],q[1],q[3]) qc.barrier() # XOR gate1 implementation qc.cx(q[0],q[4]) qc.cx(q[1],q[4]) qc.barrier() # XOR gate2 implementation qc.cx(q[2],q[5]) qc.cx(q[4],q[5]) qc.barrier() # AND gate2 implementation qc.ccx(q[2],q[4],q[6]) qc.barrier() #OR gate implementation qc.cx(q[3],q[7]) qc.cx(q[6],q[7]) qc.ccx(q[3],q[6],q[7]) qc.barrier() # Measuring and put result to classical bit # ( sum ) qc.measure(q[5],c[0]) # ( carry-out ) qc.measure(q[7],c[1]) # execute the circuit by qasm_simulator backend = Aer.get_backend('qasm_simulator') job = execute(qc, backend, shots=1000) result = job.result() count = result.get_counts() print(count) qc.draw(output='mpl') Grading tells me that my results are not matching, but I cannot figure out what is wrong with my code. Thank you so much for help.",<quantum-gate><programming><circuit-construction>,11/19/2020 7:20,14722.0,14722.0,"If I am correct, I suppose you are talking about the Qiskit Challenge 2020. A possible reason why your circuit is being graded wrong is because the question asks you to construct the circuit for full adder and give it the input $A=1$, $B=0$ and $X=1$. However, I think as per your code, you are preparing the qubits to be $|ABX\rangle = |111\rangle$ instead of $|101\rangle$. Baring that, your circuit works perfectly fine from what I could analyze.",11/19/2020 9:28
14719.0,Import Qiskit fails,"I have successfully installed the Qiskit in Anaconda by using pip install qiskit. But I can't import Qiskit and get the following error. --------------------------------------------------------------------------- OSError Traceback (most recent call last) &lt;ipython-input-5-578b7f7e9727&gt; in &lt;module&gt; ----&gt; 1 import qiskit ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\__init__.py in &lt;module&gt; 29 30 # The main qiskit operators ---&gt; 31 from qiskit.circuit import ClassicalRegister 32 from qiskit.circuit import QuantumRegister 33 from qiskit.circuit import AncillaRegister ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\__init__.py in &lt;module&gt; 212 random.random_circuit 213 &quot;&quot;&quot; --&gt; 214 from .quantumcircuit import QuantumCircuit 215 from .classicalregister import ClassicalRegister, Clbit 216 from .quantumregister import QuantumRegister, Qubit, AncillaRegister, AncillaQubit ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\quantumcircuit.py in &lt;module&gt; 23 from collections import OrderedDict, defaultdict 24 from typing import Union ---&gt; 25 import numpy as np 26 from qiskit.exceptions import QiskitError 27 from qiskit.util import is_main_process ~\AppData\Roaming\Python\Python38\site-packages\numpy\__init__.py in &lt;module&gt; 138 139 # Allow distributors to run custom init code --&gt; 140 from . import _distributor_init 141 142 from . import core ~\AppData\Roaming\Python\Python38\site-packages\numpy\_distributor_init.py in &lt;module&gt; 24 # NOTE: would it change behavior to load ALL 25 # DLLs at this path vs. the name restriction? ---&gt; 26 WinDLL(os.path.abspath(filename)) 27 DLL_filenames.append(filename) 28 if len(DLL_filenames) &gt; 1: ~\anaconda3\envs\quantum_computing\lib\ctypes\__init__.py in __init__(self, name, mode, handle, use_errno, use_last_error, winmode) 379 380 if handle is None: --&gt; 381 self._handle = _dlopen(self._name, mode) 382 else: 383 self._handle = handle OSError: [WinError 193] %1 is not a valid Win32 application So what should I do to solve this problem?",<qiskit><programming>,11/19/2020 8:37,14760.0,14760.0,Reinstalling numpy didn't work for me. I delete the C:\Users\USERNAME\AppData\Roaming\Python\Python38\* folder because that was left behind by a previous Python which I had uninstalled. And this work for me. Thanks to everyone who all answered my questions and I appreciate it.,11/21/2020 10:13
14785.0,How to apply a operator to qubit system on the basis of current state of system?,"Suppose I have three different operators $U_1, U_2,U_3$. Now, these three operators will be applied if my current state of the system is $|\psi_0\rangle,|\psi_1\rangle $ and $|\psi_2\rangle$ respectively. Now suppose I started with some initial state $|\psi_{initial}\rangle$ and after applying two unitary operations it will be converted to one of the states above and on the basis of that the respective unitary operator needs to applied. I know we can't measure the state as it will collapse the system. So, what method can be applied here?",<quantum-gate><programming><quantum-state><unitarity>,11/22/2020 16:06,15080.0,15080.0,"I assume that you have a qubit register $q$ and given that the state of $q$ is $|\psi_i\rangle$ you want to apply $U_i$ to $q$ for $i=0,1,2$. If this is what you wish to do, then unfortunately if the states $|\psi_i\rangle$'s are not orthogonal to each other, then this kind of operations are not possible in a quantum setting in for any general $U_i$'s. This is not possible because such an operator is not unitary. For instance take the simple case of $q$ being in either the state $|0\rangle$ or $|+\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}$ and I wish to apply $I$ on $q$ if it is in the state $|0\rangle$ and $H$ gate on $q$ if the state of $q$ is $|+\rangle$. This mathematically would mean that I need an operator $U$ that works as follows: $$U|0\rangle=|0\rangle \text{ and } U|+\rangle = \frac{1}{\sqrt{2}}(U|0\rangle + U|1\rangle) =|0\rangle.$$ It is quite obvious that $U$ is not reversible and hence is not a unitary. So such a quantum operation does not exist. However, if the states $|\psi_i\rangle$'s are orthogonal to each other and the state in $q$ is one of these states and is not any superposition of these states, then certainly you can measure and then conditioned on the measured result you can apply the $U_i$ of your choice.",12/10/2020 09:26
14820.0,Cirq.simulate expectation value of a Hamiltonian,I want to simulate the final state of an ansatz in cirq using simulate. Now I want to calculate the expectation value of a Hamiltonian. How do I do this? I can only find simulator.run examples in cirq. But I want to access the wavefunction and therefore would need simulator.simulate. Is there a function in cirq I can use or how could I do this?,<programming><hamiltonian-simulation><cirq>,11/24/2020 22:40,14823.0,14823.0,"You can get the wavefunction from cirq.final_state_vector(circuit). Then you can define your observable as an instance of cirq.PauliSum, on which you will be able to use the expectation_from_state_vector() method to get the expectation value.",11/25/2020 0:32
14870.0,"IBMQ: ""Credentials are already in use""","Executing the following: import numpy as np from qiskit import IBMQ, QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator from qiskit.providers.ibmq import least_busy from qiskit.visualization import plot_histogram from qiskit.tools.jupyter import * provider = IBMQ.load_account() I get the following error which I do not know what to do about, does anybosy know what I can do? ibmqfactory.load_account:WARNING:2020-11-27 13:08:45,170: Credentials are already in use. The existing account in the session will be replaced.",<programming><qiskit><ibm-q-experience>,11/27/2020 19:15,14871.0,14871.0,"This is NOT an error. It just means that you have loaded your account previously, maybe from the previous run. It will just replace your previous credential... and shouldn't cause any issue.",11/27/2020 19:25
14874.0,Why do I get the error name operator is not defined?,"I checked this code multiple times, I am trying to reproduce the same code using Grover's algorithm from qiskit summerschool: import numpy as np from qiskit import IBMQ, QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator from qiskit.providers.ibmq import least_busy from qiskit.visualization import plot_histogram from qiskit.tools.jupyter import * provider = IBMQ.load_account() def phase_oracle(n, indices_to_mark, name='Oracle'): qc = QuantumCircuit(n, name=name) oracle_matrix = np.identity(2**n) for index_to_mark in indices_to_mark: oracle_matrix[index_to_mark, index_to_mark]= -1 qc.unitary(operator(oracle_matrix), range(n)) return qc def diffuser(n): qc=QuantumCircuit(n,name='Diff - &quot;V&quot;') qc.h(range(n)) qc.append(phase_oracle(n,[0]),range(n)) qc.h(range(n)) return qc def Grover(n, marked): qc=QuantumCircuit(n,n) r = int(np.round(np.pi/ (4*np.arcsin(np.sqrt(len(marked)/2**n)))-1/2)) print(f'{n} qubits, basis state {marked} marked, {r} rounds') qc.h(range(n)) for _ in range(r): qc.append(phase_oracle(n,marked),range(n)) qc.append(diffuser(n),range(n)) qc.measure(range(n),range(n)) return qc n = 5 x = np.random.randint(2**n) marked = [x] qc = Grover(n, marked) qc.draw() I get the name operator error which I cannot figure out the reason: NameError Traceback (most recent call last) &lt;ipython-input-22-96635782dc30&gt; in &lt;module&gt; 2 x = np.random.randint(2**n) 3 marked = [x] ----&gt; 4 qc = Grover(n, marked) 5 6 qc.draw() &lt;ipython-input-20-f14e47e0af5d&gt; in Grover(n, marked) 20 qc.h(range(n)) 21 for _ in range(r): ---&gt; 22 qc.append(phase_oracle(n,marked),range(n)) 23 qc.append(diffuser(n),range(n)) 24 qc.measure(range(n),range(n)) &lt;ipython-input-20-f14e47e0af5d&gt; in phase_oracle(n, indices_to_mark, name) 4 for index_to_mark in indices_to_mark: 5 oracle_matrix[index_to_mark, index_to_mark]= -1 ----&gt; 6 qc.unitary(operator(oracle_matrix), range(n)) 7 return qc 8 NameError: name 'operator' is not defined. Can anybody help me woth this?",<programming>,11/27/2020 22:54,14877.0,14877.0,"That is because on line 14 of your program, you wrote: qc.unitary(operator(oracle_matrix), range(n)) when it should be: qc.unitary(Operator(oracle_matrix), range(n)) You should have capitalized the O in operator. Changing that, I get the following output when executed your code: 5 qubits, basis state [15] marked, 4 rounds ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» q_0: â¤ H ââ¤0 ââ¤0 ââ¤0 ââ¤0 ââ¤0 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_1: â¤ H ââ¤1 ââ¤1 ââ¤1 ââ¤1 ââ¤1 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_2: â¤ H ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_3: â¤ H ââ¤3 ââ¤3 ââ¤3 ââ¤3 ââ¤3 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_4: â¤ H ââ¤4 ââ¤4 ââ¤4 ââ¤4 ââ¤4 âÂ» ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» c: 5/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» Â« ââââââââââââââââââââââââââââââââââââââââââââ Â«q_0: â¤0 ââ¤0 ââ¤0 ââ¤Mâââââââââââââ Â« â ââ ââ âââ¥ââââ Â«q_1: â¤1 ââ¤1 ââ¤1 âââ«ââ¤Mââââââââââ Â« â ââ ââ â â ââ¥ââââ Â«q_2: â¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; âââ«âââ«ââ¤Mâââââââ Â« â ââ ââ â â â ââ¥ââââ Â«q_3: â¤3 ââ¤3 ââ¤3 âââ«âââ«âââ«ââ¤Mââââ Â« â ââ ââ â â â â ââ¥ââââ Â«q_4: â¤4 ââ¤4 ââ¤4 âââ«âââ«âââ«âââ«ââ¤Mâ Â« âââââââââââââââââââââââââââââââââââââââââ â â â â ââ¥â Â«c: 5/âââââââââââââââââââââââââââââââââââââââââââ©âââ©âââ©âââ©âââ©â Â« 0 1 2 3 4",11/28/2020 1:18
14887.0,Does 1 qubit correspond to 2 bits?,"In a lot of presentation I always see people say that $n$ qbit are approximately $2^n$ classical bit. Those talks where oriented for a broad audience, so they left out a lot of things. Deep down I felt that this couldn't be possible, but I didn't know anythings about qc so maybe this was the problem. Now I've started learning qc (as a computer engineer) and I'm studying the concept of super dense coding, that it the base of the association $n$ qbit equal $2^n$ classical bits.(If it's not this let me know) I've understood what the topic is about, but I still think that the association $n$ qbit equal $2^n$ classical bits is wrong or at least misleading. Sending 2 bit to Bob, will require Alice to have 1 qbit and 1 entangled qbit where the other part of the eqbit is owned by Bob. Just by reading this is clear that 2 bit actually correspond to 1 qbit + 1eqbit, but reading online one common approach to say that 1qbit=2bit is by introducing a third part that is responsible to send and eqbit to Alice and Bob. Isn't this a flawed way to think? When someone say $n$ qbit equal $2^n$ bit, they are implicitly stating that there is a way to encode the information of $2^n$ bits in $n$ qbit, but if you actually study the theory is not like this. Also saying that 1qbit +1eqbit =2 bit, is not too much different than saying 1qbit+1qbit=2qbit=2bit, because at the end of the day 1eqbit is just a qbit in a particular state. I know that differentiating between them is important since they are two different things, but physically we can see them as two object (two photons for example) that are in a different position, still they 'occupy the space of two object'. I also know that approximating 1 eqbit with 1 qbit is a strong affirmation, but stating that 1qbit = 2bit is stronger imo. Is my way of thinking flawed? Why and where? Also there is another thing that I couldn't understand on my own. In the textbook that I'm using (Quantum Computation and Quantum Information) one thing that they say is: Suppose Alice and Bob initially share a pair of qubits in the entangled state.. Since the sharing of the eqbit and the sending of the qbit seems to happen in two different temporal window, they are able to store qbit? In essence I don't understand the temporal window of the algorithm. I understand how it works, but not when. Can you clarify this? Note that this second question is related to the first, because I kind of understand the point of super dense coding, if you can send qbit at two different time and exploit quantum mechanics to send less qbit when needed, but if everything happen at the same time (the sending of the eqbit and the sending of the qbit) then I don't know the point of super dense coding.",<classical-computing><superdense-coding>,11/28/2020 15:48,14896.0,14896.0,"Lets start with notion that $n$ qubits are equivalent to $2^n$ classical bits. This is wrong. However, it is true that to describe a quantum state composed of $n$ qubits we need $2^n$ complex numbers since $n$ qubits state is superposition containing all combination of $n$ classical qubits ($2^n$). Writen by formula, $n$ qubits state is $$ |q_0q_1...q_{n-1}\rangle = \sum_{i=0}^{2^n}a_{i}|i\rangle, $$ where $i$ represent basis states (e.g. $|0...00\rangle$, $|0...01\rangle$, $|0...10\rangle$, $|0...11\rangle$ etc. until $|1...11\rangle$) and $a_{i} \in \mathbb{C}$. Concerning information contained in qubits. Any qubit can be described as $$ |q\rangle = \alpha|0\rangle + \beta|1\rangle, $$ where $\alpha, \beta \in \mathbb{C}$. Since paraeters $\alpha$ and $\beta$ are complex numbers, theoretically a qubit can contain infinite amount of information because you need infinite amout of bits to represent complex number exactly. This is of course impossible in reality since computers have finite memory. Moreover and what is the most important, when you measure a qubit, it collapeses to either 0 or 1. So, in the end you have either 0 or 1, i.e. one classical bit. Therefore, one qubit contains one bit of information. Regarding superdense coding. It is often said that in superdense coding you send only one qubit but in the end you have two classical bits. It is true that you send only one qubit but to have superdense coding, you need to have two entangled qubits before. So, effectively two qubits are needed for transmiting two classical bits.",11/29/2020 8:00
14934.0,Using Qiskit VQE for solving an eigenvalue problem,"I am a new user of Qiskit and I believe there is a simple answer to my question but I have had a very hard time finding a straightforward answer. I am trying to transform a given $3 \times 3$ (Hermitian) Hamiltonian matrix into a qubit operator and then use the built-in VQE solver for evaluating the minimum eigenvalue for said matrix. I have been successful in doing something similar using the qiskit.chemistry.FermionicOperator built-in class (see example below) but for this example the Hamiltonian is mapped to a Fermionic one-body qubit Hamiltonian which has $2^n$ eigenvalues instead of $n$ eigenvalues (where $n=3$ for this case). I am hoping there is a simple way to directly map a matrix to a qubit operator. My vague understanding is I need to write the matrix as a sum of weighted Pauli operators but I would expect there would exist some predefined function for doing this? (I have looked at the source code for the FermionicOperator class but it did not help me much). import numpy as np import scipy import h5py from qiskit.aqua.algorithms import VQE, NumPyEigensolver from qiskit.chemistry import FermionicOperator from qiskit import Aer backend = Aer.get_backend(&quot;qasm_simulator&quot;) c1=1 c2=2 c3=3 ff=np.zeros((3,3)) ff[1,1]=2 ff[2,2]=1 n=3 Hamil=np.zeros((n,n)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=np.sqrt(2)*c1 Hamil[1,2]=np.sqrt(2)*c1 Hamil[2,0]=np.sqrt(2)*c1 Hamil[2,1]=np.sqrt(2)*c1 vals,vecs=np.linalg.eig(Hamil) print(&quot;Standard Eigenvalues: &quot;) print(vals) Hamil_op = FermionicOperator(h1=Hamil) Hamil_ops = Hamil_op.mapping(map_type='parity', threshold=1e-12) result = NumPyEigensolver(Hamil_ops,k=int(2**n)).run() print(&quot;Quibit Eigenvalues=&quot;) print(result['eigenvalues']) vqe = VQE(operator=Hamil_ops) vqe_result = np.real(vqe.run(backend)['eigenvalue']) print(&quot;VQE Eigenvalue&quot;) print(vqe_result) With result: Standard Eigenvalues: [-1.45426242 0.90078898 3.05347344] Quibit Eigenvalues= [-1.45426242+0.j -0.55347344+0.j 0. +0.j 0.90078898+0.j 1.59921102+0.j 2.5 +0.j 3.05347344+0.j 3.95426242+0.j] VQE Eigenvalue 0.18608074335373637",<qiskit><programming><vqe><eigenvalues-and-eigenvectors>,12/02/2020 20:00,14999.0,14999.0,"I believe to have answered my own question through further attempts. Per the comment from KAJ226, it is true that a $(3 \times 3)$ matrix cannot be represented as a string of Paulis so I have nested the $(3 \times 3)$ matrix into a $(4 \times 4)$ matrix where the final row and column are all zeros. From this I can omit the useless eigenvalue/eigenvector and just retain the relevant results for the $(3 \times 3)$ matrix. My solution mostly came from using the WeightedPauliOperator, MatrixOperator, and op_converter classes. Below is a sample of my code with corresponding outputs. Thanks to those who gave suggestions to help me out! import numpy as np import scipy import h5py from qiskit.aqua.algorithms import VQE, NumPyEigensolver from qiskit.aqua.operators import WeightedPauliOperator, MatrixOperator, op_converter from qiskit import Aer backend = Aer.get_backend(&quot;qasm_simulator&quot;) c1=-0.5 c2=.75 c3=2 n1=3 Hamil=np.zeros((n1,n1)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=c1 Hamil[1,2]=c1 Hamil[2,0]=c1 Hamil[2,1]=c1 print(&quot;(3x3) Hamiltonian&quot;) print(Hamil) vals,vecs=np.linalg.eig(Hamil) print(&quot;Standard Eigenvalues: &quot;) print(vals) n2=4 Hamil=np.zeros((n2,n2)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=c1 Hamil[1,2]=c1 Hamil[2,0]=c1 Hamil[2,1]=c1 print(&quot;(4x4) Hamiltonian&quot;) print(Hamil) Hamil_Mat=MatrixOperator(Hamil) Hamil_Qop = op_converter.to_weighted_pauli_operator(Hamil_Mat) q_vals = NumPyEigensolver(Hamil_Qop,k=4).run() print(&quot;Qubit Op Eigenvalues: &quot;) print(q_vals['eigenvalues']) vqe=VQE(Hamil_Qop) vqe_result=vqe.run(backend) print(&quot;VQE Eigenvalue: &quot;) print(vqe_result['eigenvalue']) With result: (3x3) Hamiltonian [[ 0. 0. -0.5 ] [ 0. 0.75 -0.5 ] [-0.5 -0.5 -0.25]] Standard Eigenvalues: [-0.75 0.25 1. ] (4x4) Hamiltonian [[ 0. 0. -0.5 0. ] [ 0. 0.75 -0.5 0. ] [-0.5 -0.5 -0.25 0. ] [ 0. 0. 0. 0. ]] Qubit Op Eigenvalues: [-0.75+0.j 0. +0.j 0.25+0.j 1. +0.j] VQE Eigenvalue: (-0.705078125+0j)",12/05/2020 20:23
14945.0,Why is the Measurement Result Always 1? (expected to find uniformly random measurement),"I created a $|0\rangle$ state then applied $H$ gate to get $\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)$ and then I meausred my state. But I always found 1. I expected to find 0 and 1 uniformly random like the case of beam splitter. Here is my code: qubit = cirq.NamedQubit(&quot;myqubit&quot;) circuit = cirq.Circuit(cirq.H(qubit)) for i in range(10): result2 = cirq.measure(qubit, key='myqubit') print(result2) print(circuit) # run simulation result = cirq.Simulator().simulate(circuit) print(&quot;result:&quot;) print(result) print(result2) How can I find uniformly random result ?",<programming><quantum-state><measurement><cirq><random-quantum-circuit>,12/03/2020 14:40,14949.0,14949.0,"You are not measuring your qubit. Look at what your print(circuit) is returning myqubit: âââHâââ You need to add the measurement gate to the circuit like so: circuit = cirq.Circuit(cirq.H(qubit), cirq.measure(qubit, key='myqubit')) Printing this circuit returns myqubit: âââHâââMâââ In your case, with the loop; you can append the gates: for i in range(10): circuit.append(cirq.measure(qubit, key='myqubit')) Printing this one returns myqubit: âââHâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââ Both programs will get you the expected uniform random measurements.",12/03/2020 16:32
15058.0,How to project a composite system down into a smaller subspace in Python?,"If we have a composite system over five qubits ($|\psi\rangle = |a\rangle|b\rangle|c\rangle|d\rangle|e\rangle$), and I want to project into a specific subspace of the first three systems, I can build a projector of the form $|011\rangle\langle011| \otimes I_{de}$ (for example). Before projecting, state $|\psi\rangle$ can be thought of as an array with length $2^5 = 32$. My goal is to do the projection and reduce the size of my vector appropriately (so now I only have an array over the final two qubits). I'm doing this in Qiskit (after I get the statevector and am done evolving). My projectors will always have the form above, just perhaps with a different bitstring (in my example, I had &quot;011&quot;). This is what I've done so far: Since the projectors are diagonal, I convert the string &quot;011&quot; into an integer. In this case, it's 3. The corresponding matrix will look like: $$ \begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{pmatrix} .$$ Because the subspace is like this, the identity matrix $I_{de}$ will just be a matrix of size $2^2\times2^2$ and when we take the tensor product, we will get a matrix similar to the one above, but now the size of the matrix will be bigger, and the $1$ that's above will be the only place where the identity shows up (since everywhere else will be zero). I won't write down the matrix because it has size $32\times32$. If I have my state $|\psi\rangle$ and I want to project down, I figured I just had to find the components of my 32-element array which correspond to this subspace. If the position of the 1 in my matrix above is given by $p$ and my state is an array called psi, then I want to say that the projection is given by simply slicing my array as such: projected = psi[(2**2)p:(2**2)*(p+1)] My question is: Am I doing the right slicing in step 4? I think I am, but it's easy to get tripped up with these subspaces. I know that this won't work in general since the projection operator could be more involved, but in the case where it's diagonal like the above matrix and is only one element, do I have the steps involved correct?",<programming><projection-operator>,12/08/2020 21:34,15069.0,15069.0,"Your slicing is correct, and gives the right answer in your example. Here is a generalization of your slicing, for the case where you may have a different string of bits. import numpy as np def return_indices(subspace): n_qubits = len(subspace) indices = np.array(range(32)).reshape((2,)*n_qubits) output_indices = indices[subspace].reshape(-1) return output_indices # building a test psi to see if the code works well psi = np.zeros(32, dtype=np.complex) psi[12:16] = list(range(1,5)) # representing the subspace that we would like to project on subspace = (0,1,1,slice(0,2),slice(0,2)) output_indices = return_indices(subspace) #returns array([12, 13, 14, 15]) psi[output_indices] #returns array([1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j]) I also ran another test, by taking subspace2 = (1,0,slice(0,2),1,slice(0,2)) output_indices2 = return_indices(subspace2) Then output_indices2 is array([18, 19, 22, 23]), as it should. Edit: In case you are interested in projecting on the subspace where the first qubit is $0$, the second qubit is $1$ and the third quibit is $+$, then you can simply use linear superposition. Indeed, this is $1/\sqrt{2}$ times the projection of the state on the $|010::\rangle$ subspace plus $1/\sqrt{2}$ times the projection of the state on the $|011::\rangle$ subspace. I am using a colon, just as in Python, to indicate that the corresponding index is free. So you can adapt the code to handle a case where you have a $+$ state. However, the code is written assuming you are mostly interested in $0$ and $1$ states.",12/09/2020 15:22
15087.0,How can I resolve this get_count issue from running multiple circuits?,"I'm running a couple of circuits at the same time using an array of variables. However, I met an issue regarding accessing the counts. Here's part of the code I have: probsu = [] circuits = [] for i in range(len(Variable)): circuit = QuantumCircuit(qrz,crz) circuit = qc(Variable[i]) circuits.append(circuit) prob = counts['1001'] / sum(counts.values()) **Issue here** probsu.append(prob) **Issue here** circuits = transpile(circuits, backend=backend) job_manager = IBMQJobManager() MyExperiments = job_manager. run(circuits, backend=backend, name='MyExperiment') results = MyExperiments.results() counts = results.get_counts(circuit) I'm not able to get the counts since the line is referenced before the definition in the last line. However, there will be similar issues pop up if I remove the bottom lines before the for loop. How can I resolve this issue? Thanks:)",<programming><qiskit><experiment>,12/10/2020 17:13,15088.0,15088.0,"You mean something like this? %matplotlib inline # Importing standard Qiskit libraries from qiskit import QuantumCircuit, QuantumRegister, IBMQ, ClassicalRegister from qiskit.circuit import QuantumCircuit, ParameterVector from qiskit.compiler import transpile, assemble from qiskit.providers.ibmq.managed import IBMQJobManager from qiskit.visualization import * provider = IBMQ.load_account() backend = provider.get_backend('ibmq_qasm_simulator') def qc(Variable): var_form = QuantumCircuit(2,2) var_form.ry(Variable,0) var_form.cx(0,1) var_form.h(1) var_form.measure([0,1],[0,1]) return var_form Variables = [1,2,3,4,5] circuits = [] for i in range(len(Variables) ): circuit = QuantumCircuit(2,2) circuit = qc(Variables[i]) circuits.append( circuit ) circuits = transpile(circuits, backend=backend) job_manager = IBMQJobManager() MyExperiments = job_manager.run(circuits, backend=backend, shots =1000, name='MyExperiment') results = MyExperiments.results() probsu = [] for i in range(len(Variables) ): prob = results.get_counts(i)['11']/sum( results.get_counts(i).values() ) probsu.append(prob) print('probability of getting |11&gt; at each circuit:', probsu) which generate the output: probability of getting |11&gt; at each circuit: [0.121, 0.33, 0.458, 0.417, 0.178] the output above corresponds to the probabilities of reading out $|11\rangle$ on each of the 5 circuits... You can modify this circuit to your purpose... as this is only an example.",12/10/2020 17:45
15096.0,Classically controlled quantum operators,Does CirQ support classically controlled quantum operators where the classical values obtained by the measurement?,<programming>,12/11/2020 00:48,15097.0,15097.0,"Currently, there is no mechanism for performing classical feedback in cirq. It is on the roadmap. It will probably look something like cirq.X(q)**measurement_result(key) in the end, but for now it doesn't exist.",12/11/2020 05:37
15109.0,ProjectQ - Error messages,"How can we get rid of runtime next error: Traceback (most recent call last): File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\types\_qubit.py&quot;, line 135, in __del__ self.engine.deallocate_qubit(weak_copy) File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_basics.py&quot;, line 153, in deallocate_qubit tags=[DirtyQubitTag()] if is_dirty else [])]) File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_main.py&quot;, line 288, in send raise compact_exception # use verbose=True for more info RuntimeError: Qubit has not been measured / uncomputed. Cannot access its classical value and/or deallocate a qubit in superposition! raised in: ' File &quot;C:\\Users\\Marija\\Anaconda3\\lib\\site-packages\\projectq\\backends\\_sim\\_pysim.py&quot;, line 139, in get_classical_value' ' raise RuntimeError(&quot;Qubit has not been measured / &quot;'```",<programming>,12/11/2020 10:49,15490.0,15490.0,"By measuring all the qubits at the end of the code, I avoided the above-mentioned error message.",01/12/2021 01:06
15189.0,XY Hamiltonian in a 1D Heisenberg Chain,"I've been trying to implement the 1D Heisenberg chain (i.e. the XXZ model) on Qiskit but have been having trouble. To recap, the Heisenberg hamiltonian is as follows: $$H_{XXZ} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1} + \Delta S^{z}_{i}S^{z}_{i+1})] $$ and we can take the XY hamiltonian to be $$H_{XY} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1})]$$ as I understand. I know that the matrix representation of this hamiltonian's time evolution takes the form $$XY(\theta) = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; \cos[{\theta}/2] &amp; i\sin[{\theta}/2] &amp; 0\\ 0 &amp; i\sin[{\theta}/2] &amp; \cos[{\theta}/2] &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}$$ however, I'm not exactly sure how to implement it on Qiskit with the available Quantum logic gates. I do know that a special case to this problem is the iSwapGate, where it is equal to $XY(\theta = \pi)$, but is there a way to implement $XY(\theta)$ for arbitrary angles?",<quantum-gate><programming><qiskit><hamiltonian-simulation><matrix-representation>,12/18/2020 18:17,15191.0,15191.0,"Here is an implementation from qiskit.circuit import QuantumCircuit, Parameter theta = Parameter('Î¸') qc = QuantumCircuit(2) qc.cx(0, 1) qc.crx(-1 * theta, 1, 0) qc.cx(0, 1) print(qc) --- ââââââââââ q_0: âââ âââ¤ RX(-Î¸) ââââ ââ âââ´âââââââ¬ââââââââ´ââ q_1: â¤ X ââââââ ââââââ¤ X â âââââ âââââ and to evaluate that it works: from qiskit.quantum_info import Operator def XY(theta): c = np.cos(theta / 2) s = 1j * np.sin(theta / 2) return np.array([[1, 0, 0, 0], [0, c, s, 0], [0, s, c, 0], [0, 0, 0, 1]]) val = pi / 14 circ = qc.bind_parameters({theta: val}) np.allclose(Operator(circ).data, XY(val)) --- True",12/18/2020 19:51
15233.0,Increase maximum shots on IBM Hardware when running Quantum Variational Algorithms,"I am interested to know whether there is a quick and elegant way of increasing the number of shots (more than 8192 shots) on IBM hardware when running variational algorithms like VQE or QAOA. I know that within Qiskit, I can specify: backend._configuration.max_shots= shots to change the number of max_shots but this only works for simulator. I can't increase the shots parameter to go over 8192 shots when I set my backend as one of the real hardware. That is, if I specify the following: hardware_backend = provider.get_backend('ibmq_valencia ') maxshots = 20000 hardware_backend._configuration.max_shots= maxshots quantum_instance = QuantumInstance(hardware_backend, shots = maxshots, initial_layout = None, optimization_level = 3) then upon executing the circuit, I will have an error message: Error is : The number of shots in the Qobj (20000) is higher than the number of shots supported by the device (8192). Is there a quick and elegant way to overcome this issue within Qiskit? Thank you!",<programming><qiskit><ibm-q-experience><vqe>,12/22/2020 19:20,15238.0,15238.0,"According to my knowledge, 8192 is a maximum of shots. I think that the reason is fair timesharing as nowadays there are many users of IBM Q. To get better results from VQE, I can only recommend to run your task several times and then pick up the best solution, i.e. the one wiht the lowest (highest) value of the optimized function.",12/23/2020 7:34
15284.0,"How can I run a set of circuits, each of which has 100 shots?","I'm running simulations of my quantum circuit, which includes both parametrized variables and random numbers. The question I'm trying to solve is that for each parameterized variable, I will generate a set of quantum circuits, each element of which contains different random numbers. I'm hoping to run each quantum circuit in the set with 100 shots, then carry out some analyses on the counts. I'm not exactly sure how I can do that, here's part of the code I have: from qiskit import IBMQ provider = IBMQ.load_account() sim = provider.backends.ibmq_qasm_simulator backend = provider.get_backend('ibmq_qasm_simulator') E = np.linspace(-5,5,10) # Parameters circuits = [] nuni = 10. # Number of the circuits in each set. for i in range(10): circuitsi = [] for j in range (nuni): circuit = QuantumCircuit(qrz,crz) circuit = qc(E[i]) # qc is a function with both parameters and random numbers. circuitsi.append(circuit) circuits.append(circuitsi) for i in range (len(circuits)): for j in range (nuni): circuits[i][j] = transpile(circuits[i][j],backend=backend) for i in range (10): job_manager = IBMQJobManager() MExperiments = job_manager.run(circuits[i], backend=backend, shots = nshot) results = MExperiments.results() for j in range (nuni): counts = results.get_counts(circuits[i][j]) My current code doesn't quite work, I'm wondering am I on the right track? How can I fix my code? Thanks a lot for your help:) Update: My code works, but it takes a really long time to run. I'm still wondering if there's a simpler way to carry out the experiment? Thanks!",<qiskit><programming>,12/26/2020 21:36,15297.0,15297.0,"In your code, circuits is an array of array of quantum circuits and each element of circuits is an array of quantum circuits. In the code, you are using a for loop to run each element of the circuits array individually using the for loop. This runs each of the 10 array of circuits one after the other. However, you can run all the quantum circuits of all the arrays all at once. All you have to do is to construct an array say all_circuits and append all the quantum circuits of each of the circuitsi. Then you can run the simulation using this array of circuits. Once the results are out, you can then post process it to get an array of array of results. So the code after creating all the circuits will be more like the below: all_circuits = [] for i in range(10): all_circuits += circuits[i][:] from qiskit.tools.monitor import job_monitor qjob = execute(all_circuits,shots=shots,backend=backend) job_monitor(qjob) result = qjob.result() counts = [] for i in range(10): count_i = [] for j in range(nuni): count_i.append(result.get_counts(all_circuits[(nuni*i)+j])) counts.append(count_i) Since you execute all the circuits at one, this would reduce the time of execution quite a lot. Also, if you are using execute, you could also skip transpile since transpile will also be performed as a part of execute. This might not decrease the run time but might help in writing the code simpler. I hope this helps.",12/27/2020 10:45
15462.0,Quantum PRGN against Hard disk Forensics,"We can make use of the Qbit to make a random string of bytes then as I have an office laptop and I can do some espionage by copying the files to my local disk from the network share and upload it to some online board. It Leaves a shadow file if I choose to delete it and or encrypt the file. If forensics is performed then that file can be retrieved in its entirity( best case), partially(most cases), encrypted entirety( rarely), or a sign that the file was attempted to be shredded and implementation may vary from OS to OS and File system to file system. My proposal is that we expose an online service where we input the remaining size of our harddisk, let's suppose I have a disk size of 2TB and 1.5TB is remaining so I shall download a file with Quantum random numbers of size 1.5TB hence overriding all the memory cell even if the disk firmware is ware balanced it will not be able to preserve the fragments of the previously deleted files as we are filling all the leftover disk space with random quantum numbers.",<programming><random-quantum-circuit>,01/10/2021 04:12,15482.0,15482.0,"To erase a HDD with a random numbers generated by quantum computer is in theory possible. Lets imagine you want to generate bit strings of length $n$, then you can simply put Hadamard gates on $n$ qubits. Such simple circuit prepares equal superposition of all $n$ bit long strings. When you put measurement after the Hadamard gates and run the circuit on a quantum computer you will get a random bit string coming from uniform distribution. However, nowadays there are two main obstacles: A small number of qubits in current quantum processors (as far as I know, IBM offers 63 qubit processor). But this can be easily overcame but producing higher number of shorter bitstrings. Most importantly, you would need to run your circuit many times to produce 1.5 TB of random bits. Since 1.5 TB = 12 Tb and suppose that you are able to produce at 63 bits long stings (on the IBM computer I mentioned above), this will take 190 million of runs. This is possible, however, I do not think that IBM would allow such load of their systems now. To conclude, yes it is possible but because of small capacity of current quantum computer it is difficult to do so. Just suggestion: try to use some physical generator of random numbers. They are based on measuring thermal noise. Produced random numbers are really random as in case of quantum computer. No algorithms like linear congruential generator is used.",01/11/2021 08:32
15464.0,Job fails when using PulseSimulator: Job Status: job incurred error,"I'm trying to simulate a basic circuit using the PulseSimulator in Qiskit. The following Qiskit Pulse code works when I run it on the real device, but not when using the PulseSimulator. The job monitor tells me Job Status: job incurred error and nothing else. Trying to run any gates native to the device causes an issue. If I remove schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi) then it runs fine, but I can't figure out what I'm doing wrong. I'd deeply appreciate any support. I'm using qiskit 0.23.2 #Essential Imports import numpy as np # Qiskit Imports from qiskit.providers.aer import PulseSimulator from qiskit import IBMQ, assemble from qiskit.tools.monitor import job_monitor import qiskit.pulse as pulse # Connect to an IBMQ Account and Backend API_TOKEN = '' IBMQ.save_account(API_TOKEN, overwrite=True) IBMQ.load_account() provider = IBMQ.get_provider() backend = provider.get_backend(&quot;ibmq_armonk&quot;) backend_pulse_simulator = PulseSimulator.from_backend(backend) #backend # Get information about the backend qubit = 0 backend_defaults = backend.defaults() backend_properties = backend.properties() qubit_frequency_updated = backend_properties.qubit_property(qubit, 'frequency')[0] inst_sched_map = backend_defaults.instruction_schedule_map measure_schedule = inst_sched_map.get('measure', qubits=[qubit]) # Assemble a job - circuit with a single qubit-&gt; u2 gate -&gt; measurement num_shots_per_point = 1024 drive_chan = pulse.DriveChannel(qubit) schedule = pulse.Schedule() schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi) # Removing this solves the issue - why? schedule += measure_schedule &lt;&lt; schedule.duration pulse_program = assemble(schedule, backend=backend_pulse_simulator, meas_level=2, meas_return=&quot;single&quot;, shots=num_shots_per_point, schedule_los=[{drive_chan: qubit_frequency_updated}]) # Run the job job = backend_pulse_simulator.run(pulse_program) job_monitor(job)",<programming><qiskit><simulation><openpulse>,01/10/2021 05:04,15487.0,15487.0,"The Job Status: job incurred error with pulse can be the result of a timing problem in the execution of different pulses, but in your code the PulseSimulator() class must get backends provided by Terra such as FakeArmonk(), FakeParis()..etc. For example: from qiskit.test.mock import FakeArmonk backend=FakeArmonk() backend_pulse_simulator = PulseSimulator.from_backend(backend) # using FakeArmonk() backend print(type(backend_pulse_simulator)) The FakeBackends() have the properties of the IBM Quantum devices data and are stored in Qiskit Terra. Another way is to specify a PulseSystemModel() from a real backend and pass the system model to the execution method. Below is an example with ibmq_armonk. from qiskit.providers.aer.pulse import PulseSystemModel from qiskit.providers.aer import PulseSimulator armonk_backend= provider.get_backend(&quot;ibmq_armonk&quot;) armonk_model = PulseSystemModel.from_backend(armonk_backend) backend_pulse_simulator=PulseSimulator() job = backend_pulse_simulator.run(pulse_program, armonk_model) hope this helps Patrick",01/11/2021 14:55
15649.0,"Cirq: Result of rotating qubit measurements never come [0 1] or [1 0 ], always come as [0,0] or [1,1]","I am creating a 2 qubit entangled state: def density_matrix_chsh(i, j, qs): circuit = chsh_circuit(i, j, qs) return cirq.final_density_matrix(circuit, qubit_order=qs) def chsh_circuit(i, j, qs): return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j])) qs = [a, b] state = density_matrix_chsh(0, 1, qs) Then I am applying rotation for maximum violation: th = np.pi/(-2) th1 = np.pi/(4) th2 = 0 random_angles = [] newlist = [] b_big = cirq.kron(cirq.unitary(cirq.ry(th)),cirq.unitary(cirq.ry(th))) results = [] for choosen in itertools.product([th2, th1], repeat=2): random_angles.append(choosen) for i in range (1000): choosen_combination = random.choice(random_angles) a_big = cirq.kron(cirq.unitary(cirq.rz(choosen_combination[0])),cirq.unitary(cirq.rz(choosen_combination[1]))) rotated_state = b_big @ a_big @ state @ b_big.conj().T measurement_rotated = cirq.measure_density_matrix(rotated_state,indices=[0, 1]) print(&quot;measuring qubits &quot;,measurement_rotated) qubit_result = measurement_rotated[0] results.append(qubit_result) For instance here I tried 1000 times and both qubits are either 0 or 1 at the sma time but I could never see one of them 1 and the other one is 0 after measurement. Probably I am doing something wrong and I can't see Thanks for helps",<programming><measurement><cirq>,1/23/2021 11:31,15662.0,15662.0,"As Craig said, you applied b_big and a_big differently. The adjoint a_big is missing from your product. Try rotated_state = b_big @ a_big @ state @ a_big.conj().T @ b_big.conj().T. But Craig's right. Using Circuits would be much simpler: import itertools import random import cirq import numpy as np def chsh_circuit(i, j, qs): return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j])) qs = cirq.NamedQubit(&quot;a&quot;), cirq.NamedQubit(&quot;b&quot;) th = np.pi/(-2) th1 = np.pi/(4) th2 = 0 random_angles = [] newlist = [] b_big = cirq.Circuit(cirq.ry(th)(qs[0]), cirq.ry(th)(qs[1])) results = [] for choosen in itertools.product([th2, th1], repeat=2): random_angles.append(choosen) print(random_angles) for i in range (1000): choosen_combination = random.choice(random_angles) a_big = cirq.Circuit(cirq.rz(choosen_combination[0])(qs[0]), cirq.rz(choosen_combination[1])(qs[1])) rotated_state = cirq.Circuit(chsh_circuit(0,1, qs), a_big, b_big, cirq.measure(*qs)) res = cirq.Simulator().run(program=rotated_state, repetitions=1) print(&quot;measuring qubits &quot;,res.measurements)",1/24/2021 7:04
15651.0,How to read the unitary matrix of a quantum circuit in ProjectQ?,I would like to read the unitary matrix of a quantum circuit in ProjectQ. Is there any way to do it?,<programming><projectq>,1/23/2021 18:49,15993.0,15993.0,"Most quantum circuit building softwares, including ProjectQ, do not have any convenience features that explicitly serve this purpose due to the potential overhead of calculating and storing the unitary as the number of qubits increases. The best solution is to create your own function that recovers the unitary. The general idea (software non-specific) is to: Create your quantum function Iterate through each operation and obtain the matrix representation Multiply each unitary to get the final unitary representation of the circuit",02/11/2021 15:57
15667.0,Qiskit: getting QAOA expectation,"Suppose I run the Qiskit's QAOA algorithm. qaoa = QAOA(operator=qubit_operator, p=p, optimizer=optimizer) result = qaoa.run(quantum_instance) There is a built-in method that gets me the most likely binary solution for this problem. sample_most_likely(result['eigenstate']) But how do I get the whole probability distribution of binary solutions? Ultimately, I would like to calculate the expected value for my problem, not the value based solely on the most likely string.",<programming><qiskit><vqe><qaoa>,1/24/2021 10:53,15671.0,15671.0,"You should be able to use: result['eigenstate'] That should spit out something like (if you are using 4 qubits): {'0001': 27, '0010': 20, '0011': 1821, '0100': 25, '0101': 591, '0110': 46, '0111': 5347, '1001': 18, '1010': 2, '1011': 226, '1101': 11, '1111': 58}",1/24/2021 17:46
15876.0,CERTIFICATE_VERIFY_FAILED after updating Python when trying to access results in IBM QE,"I had a question earlier about the Numpy DeprecationWarning flooding issue. I just updated the Python in my regular jupyter notebook and have trouble running the following cell: cal_job = execute(cal_circuits, backend = backend, shots = 1024, optimization_level = 0 ) ***cal_results = cal_job.result()*** meas_fitter = CompleteMeasFitter(cal_results, state_labels) fig, ax = plt.subplots(figsize=(10, 10)) meas_fitter.plot_calibration(ax) My code worked fine before upgrading but now it shows the following error message (The line with the error is marked with***): SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate On the IBMQ Experience page it shows my job has been successfully executed, but I cannot obtain any result from the notebook. What should I do? Thanks so much for the help!",<programming><qiskit><ibm-q-experience>,02/06/2021 03:14,15882.0,15882.0,"If running on MacOS, did you try to Install Certificates? You can execute the following line in a terminal, replacing &lt;version&gt; with your Python version. /Applications/Python\ &lt;version&gt;/Install\ Certificates.command",02/06/2021 14:26
15942.0,Take every second element of the array in Q#,"Very quick question, I am trying to implement SAT solving in Q# using Grover's Algorithm. I want to take every second element from an array starting at the second element, represented with a range element : 1..2..Length(array). I am not very experienced and I am trying to find a nice and clean way to do so, without too much unnecessary for loop. Could someone help ?",<programming><q#>,02/09/2021 11:20,15946.0,15946.0,You can create an array with every second element starting from the second one using the expression array[1..2...].,02/09/2021 15:14
15966.0,"Was the Quantum Circuit Attribute ""iden"" renamed?","I'm going through some older tutorials for my employer and everything seems to be working fine except the &quot;iden&quot; attribute. The error is listed below. I assume the name was changed but I don't know what it was changed to, and I don't know how to find out. AttributeError Traceback (most recent call last) &lt;ipython-input-10-fff169415f56&gt; in &lt;module&gt; 4 hello_qubit = QuantumCircuit(q) 5 ----&gt; 6 hello_qubit.iden(q[0]) 7 8 job = execute(hello_qubit, S_simulator) AttributeError: 'QuantumCircuit' object has no attribute 'iden' '''",<programming><qiskit>,02/10/2021 14:54,15968.0,15968.0,Now it is called id: from qiskit import * circuit = QuantumCircuit(1) circuit.id(0) print(circuit) âââââ q_0: â¤ I â âââââ If you want to implement a delay consider using delay.,02/10/2021 15:07
16003.0,Can I adjust the quantum circuit after transpiling it?,"I have a list of quantum circuits called all_circuits. I tried to run those circuits on a quantum computer by submitting the jobs to the IBM job manager: from qiskit.compiler import transpile, assemble from qiskit.providers.ibmq.managed import IBMQJobManager for i in range(len(all_circuits)): # Submit a single job, and transpile everything just once. all_circuits[i] = transpile(all_circuits[i],backend=backend) I'm wondering after transpiling the whole list of circuit, is it still possible for me to modify an element in the transpiled list, like adding a gate at a particular place? For instance, if each circuit in my list have the following elements (I'm not so sure if this is a good example haha): qc = QuantumCircuit(3,3) qc.H(0) qc.crx(a,2,1) # Suppose a is some random parameter ***Here!*** qc.barrier() qc.H([1,2]) qc.cx(1,3) qc.measure(...) I don't think that transpiling a circuit will mix the gates on the two sides of the barrier (the barrier will also be kept), so can I transpile all circuits first, then add a CNOT gate qc.cx(0,2) right before the barrier (marked as 'Here!') to each transpiled circuit, not original one ? Thanks!!",<programming><qiskit>,02/12/2021 01:09,16004.0,16004.0,"Yes. You can just add gates as usual. For example: Suppose that we have the following random circuit from qiskit.circuit.random import random_circuit num_qubits = 2 circuit_depth = 3 max_operands = 1 #between 0 and 3 measurement_all_qubit = True qc_random = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) print(qc_random) ââââââââââââââ ââââââââââââââââââââââââââââ q_0: âââââââââ¤ RZ(5.6174) âââââââââ¤ U1(5.5484) ââ¤ RX(6.0937) â âââââââââ´âââââââââââââ´âââââââââââââââââââââ¤ââââââââââââââ¤ q_1: â¤ U3(0.96086,4.3412,1.4989) ââ¤ RZ(4.7727) ââ¤ U1(3.1479) â âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ We can transpiled it to ibmq_athens to get: from qiskit.compiler import transpile provider = IBMQ.load_account() Circuit_Transpile = transpile(qc_random, provider.get_backend('ibmq_athens') , optimization_level=3) print(Circuit_Transpile) ââââââââââââââââââââââââââââââââââ q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) âââââââââââââââââââââ ââââââââââââââ¤ââââââ¤ââââââââââââââ¤ââââââââââââââââââââ q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) â ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ Now, we can just add additional gates on top of this transpiled circuit called &quot;Circuit_Transpile&quot; as you would normally do before. For example: for i in range(5): Circuit_Transpile.h(i) print(Circuit_Transpile) âââââââââââââââââââââââââââââââââââââââ q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) ââ¤ H âââââââââââââââââââââ ââââââââââââââ¤ââââââ¤ââââââââââââââ¤âââââ´ââââââââââââââââââââ q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) ââ¤ H â âââââ¬ââââ¬ââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_0 -&gt; 2 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ¤ ancilla_1 -&gt; 3 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ¤ ancilla_2 -&gt; 4 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ Hopefully this helps. Update: It seems like your circuit have two parts that is being divided by the circuit barrier, and you want to add gate into the middle of the circuit (after the barrier) after the transpilation process. If that is the case, then what you can do is to split the two parts of the circuit into two different circuits then compose them together after the transpilation process. For instance: from qiskit.circuit.random import random_circuit num_qubits = 2 circuit_depth = 3 max_operands = 1 #between 0 and 3 measurement_all_qubit = True qc_random1 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) qc_random1.barrier(range(2)) qc_random2 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) qc_random2.barrier(range(2)) print(qc_random1) print(qc_random2) âââââ ââââââââââââââ âââââ â q_0: â¤ X âââ¤ U1(2.7235) ââââââ¤ X âââââââââ âââââ¤ââ´âââââââââââââ¤âââââ´ââââ´âââââ â q_1: â¤ Z ââ¤ RX(0.94815) ââ¤ RX(2.0345) ââââ ââââââââââââââââââââââââââââââââââ â ââââââââââââââââââââââ âââââ ââââââââââââââ â q_0: â¤ U2(0.28027,1.7582) ââââââ¤ X âââââââ¤ RZ(4.5689) ââââ âââââââââââââââââââââ¬ââââââ´ââââ´ââââââââââ¬ââââ¬âââââ â q_1: â¤ U2(1.6123,1.6426) âââ¤ RZ(6.1746) ââââââ¤ S âââââââââ âââââââââââââââââââââ ââââââââââââââ âââââ â Now, do the transpilation as you would have normally do: from qiskit.compiler import transpile provider = IBMQ.load_account() Circuit_Transpile1 = transpile(qc_random1, provider.get_backend('ibmq_athens') , optimization_level=3) Circuit_Transpile2 = transpile(qc_random2, provider.get_backend('ibmq_athens') , optimization_level=3) print(Circuit_Transpile1) print(Circuit_Transpile2) ââââââââââââââ â q_0 -&gt; 0 â¤ RZ(3.5597) âââââââââââââââââââââââââââââââââââââââââ ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) ââââ ââââââââââââ âââââââââââââââââââââââââââââââââââââ â ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ global phase: 0.29049 âââââââââââââ ââââââââââââââââââââ â q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ ââââââââââââââââââââââââââââââââââââ â ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ Now, add gates that you wanted to add to the first circuit: for i in range(2): Circuit_Transpile1.h(i) print(Circuit_Transpile1) ââââââââââââââ â âââââ q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H â ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤ q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H â ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââ ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ Then compose them together to formed a full circuit: Circuit_Transpile1.compose(Circuit_Transpile2, inplace = True) print(Circuit_Transpile1) ââââââââââââââ â âââââÂ» q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H âÂ» ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤Â» q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H âÂ» ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââÂ» ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» Â« âââââââââââââ ââââââââââââââââââââ â Â« q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ Â« ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â Â« q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ Â« ââââââââââââââââââââââââââââââââââââ â Â«ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ Â« Â«ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ Â« Â«ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ Â« ```",02/12/2021 01:43
16176.0,Multiple Providers on IBMQ,"I am attempting to run parallel computations on two different backends from within the same Jupyter notebook, though it appears these two jobs are running sequentially. I understand the jobs will be asynchronous, but is there any way to submit two jobs to differing backends at the same time? I'm not seeing anything allowing for providing multiple backends. Thank you!",<programming><qiskit><ibm-q-experience><ibm>,2/23/2021 3:46,16184.0,16184.0,"There is a (much simpler in my opinion) solution that does not require multiprocessing at all: use qiskit API. A code sample is worth a thousand words: # Load the packages from qiskit import IBMQ, QuantumCircuit, execute # Log in to your IBMQ account IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') # Get the backends you are interested in backends = [provider.get_backend(b) for b in [&quot;ibmq_athens&quot;, &quot;ibmq_quito&quot;]] # Build the quantum circuit qc = QuantumCircuit(5) qc.h(list(range(5))) qc.cx(0, 1) qc.cx(1, 2) qc.cx(3, 4) qc.cx(5, 2) qc.measure_all() # Asynchronously submit the circuit on all the backends. # This will only submit the circuits, not wait for their completion. jobs = [execute(qc, backend) for backend in backends] # Do some work... # When you need your job results: # You can also query the results individually if needed. # The call to &quot;result()&quot; blocks until the job is finished. results = [j.result() for j in jobs] # Now you can use the results, for example to recover the counts # This is a non-blocking operation as the counts are already in # the results obtained in the previous step counts = [result.get_counts() for result in results]",2/23/2021 11:44
16321.0,Should I learn a low-level QC programming language?,"I've referred to some programming language recommendation questions on here, so I thought I'd post a follow-up question here. I'm a total beginner to the field but want to seriously learn it. Is there a low-level, QC-equivalent of assembly language, and is it worth it to learn that at this stage? Do existing QC programming languages provide that low-level functionality? And a minor second clarification - if I commit to learning any particular framework like Qiskit or Q#/QDK - is there a risk of that framework going obsolete depending on which company wins out in this QC race in the future?",<programming>,03/03/2021 02:30,16326.0,16326.0,"I will provide answer for IBM Q. There is a language callled QASM. As you can see from the name of the language, it is similar to assembly language known from classical computer. The language statements are very simple - they involve an operation (i.e. quantum gate) and affected qubits. For example to apply $X$ gate on qubit no. 0, you have to put in x q[0], for CNOT gate with control qubit no. 0 and target qubit 1, the statement is cnot q[0], q[1] etc. Also special stataments are used for measurement, setting number of qubits in qubit register and bits in classical register. You can also define subroutines which are called custom gates. This all means that you operates on qubit and gate level although logical ones. It is also possible to write a program in QASM using only basic gates which are $U3$ and CNOT on IBM Q (although $U3$ is still not physical gate). IBM Q also enables you to program a quantum processor with microwave pulses directly (only processor Armonk offers this capability now) which is really physical level, something like programming classical computer by switching particular transistors. Concerning the possibility of a something going to be obsolete. There is always such risk in any segment of industry, particularly in IT which evolves rapidly. As I see it, it think to learn QASM/Qiskit is useful as it allows you to get insight how quantum computers work. Then, it would be easy to switch to another language.",03/03/2021 07:54
16409.0,Is there a way to present conjugate transpose of a Y Pauli rotation as a Cirq Operator?,Given: Ry(theta) acting on one qubit I'm trying to use existing Cirq Operators to build the conjugate transpose of the above gate. I need the operator to produce the exact unitary of the given gate for the given theta. I'v already used cirq.optimizers.single_qubit_matrix_to_gates. It gives YPowGates but the global phase changes with theta. I need either the exact unitary of the gate or another conversion that its global phase does not change with theta.,<programming><cirq><pauli-gates>,03/08/2021 21:11,16410.0,16410.0,"cirq.inverse(operation) will return the conjugate transpose of an operation. Equivalently, you can use operation**-1 (this is the first thing that cirq.inverse tries). For the specific case of $R_y$, you can just negate the angle i.e. use cirq.ry(-theta).",03/08/2021 21:22
16413.0,Trying to simulate Weak Value Amplification using QuTiP,"Weak Value Amplification is a procedure in which one consider a bipartite Hamiltonian of the form $H = g A \otimes B$, where $A$ is called system, $B$ is called meter and $g$ is the extremely small parameter we are interested to measure by amplification. The procedure goes as follows: (1) The system and meter is initialized by some initial state $\vert\Psi\rangle=\vert\psi_{i}\rangle \otimes \vert \phi\rangle$. The evolution of the system $U = \exp(-igA \otimes B)$ is approximated to $1_{A}\otimes 1_{B}-ig A\otimes B$, since $g$ is extremely small. we get $$U\vert\Psi_{i}\rangle\approx(1_{A}\otimes 1_{B}-ig A\otimes B)\vert\psi_{i}\rangle \otimes \vert \phi\rangle,$$ $$(1_{A}\vert\psi_{i}\rangle\otimes 1_{B}\vert \phi\rangle-ig A\vert\psi_{i}\rangle\otimes B\vert\phi\rangle).$$ (2) After the evolution, the system is post selected onto some final state $\vert\psi_{f}\rangle$ (which is nearly orthogonal to the initial state) $$\langle\psi_{f}\vert U\vert\Psi_{i}\rangle\approx P_{s}(1_{B}\vert\phi\rangle - ig A_{w}B\vert\phi\rangle)$$. Where $P_s = \langle\psi_{f}\vert\psi_{i}\rangle$ is the post-selection probability and $A_{w} = \langle\psi_{f}\vert A\vert\psi_{i}\rangle/P_{s}$ is called the weak value. (3) If i re-exponentiate the above term, we get $$\frac{\langle\psi_{f}\vert U\vert\Psi_{i}\rangle}{P_{s}}=\exp(-igA_{w}B)\vert\phi\rangle$$ where the exponential on the RHS is the Kraus operator acting on the meter intial state, using which one can estimate the small parameter $g$. My attempt at solving: (step 1) I prepare the initial state say psi1 and evolved the state according the Hamiltonian using mesolve for a short time t = np.linspace(0, 0.01, 50) result = mesolve(H, psi1, t, c_ops = [], e_ops =[]) (step 2) The evolved state is result.states[49], but the problem I am facing is how do I make post-measurement on this with the final state? One such dumb attempt, I did was taking the final state psif and sandwiched directly with result.states[49] as eta = psif.dag()*result.states[49] But my objective was to do the post-selection at a specific time, like say I weakly evolve the system for a short time say 0 to 0.1 seconds and do post-selection exactly at 0.05th second. I am really lost what to do from my (step 1). Is there a way to do post-selection in QuTiP at a specific time?",<programming><qutip>,03/09/2021 04:34,17681.0,17681.0,"The state evolved at all of the time points in t[i] are stored in results.states[i]. You can use this to find the exact post-selected state and the exact post-selection probability by looking directly at the &quot;sandwiches&quot; psif.dag()*result.states[i] that you mention. But QuTiP gives an error about incompatible object sizes if you do this operation, which seems mathematically fine! That is because it prefers that you operate on states in the composite Hilbert space with things defined on the composite Hilbert space. Thus, instead of the shorthand definition of $\langle\psi_f|U|\Psi_i\rangle$, we are really using $$\left(\langle\psi_f|\otimes \mathbb{I}\right)U|\Psi_i\rangle.$$ If we define my psif as your psif tensored with the identity on the second Hilbert space, everything will work nicely. So: the unnormalized post-selected state at time point t[i] can be found through tensor(psif,qeye(N)).dag()*result.states[i], where N is the dimension of the Hilbert space on of the meter. You can verify that this gives psi1 when you $i=0$.",5/27/2021 19:35
16501.0,How to initialize a qubit with a custom state in Qiskit Composer,"I'm trying to initialize a qubit with a custom state in IBM's Qiskit Composer. I wrote the code in the Qiskit Lab and obtained the QASM code as shown below OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q0[1]; creg c[1]; initialize(0.5,0.8660254) q0[0]; This is giving error stating initialize is not defined. What's the way to initialize a qubit with a custom value in Qiskit Composer?",<programming><qiskit><quantum-state><ibm-q-experience>,3/14/2021 6:18,16503.0,16503.0,"What you can do is use qiskit to decompose the circuit with the initialize instruction to elementary gate, then print out the QASM code that you can paste into the Composer. For example: Using the vector you want to initialize, I can do from qiskit import QuantumCircuit, IBMQ import numpy as np num_qubits = 1 vector = [0.5,0.8660254] initial_state = vector/np.linalg.norm(vector) circuit = QuantumCircuit(num_qubits,num_qubits) circuit.initialize(initial_state, 0) print(circuit) qasm_circuit = circuit.decompose().decompose().decompose() print(qasm_circuit) âââââââââââââââââââââââââââ q_0: â¤ initialize(0.5,0.86603) â âââââââââââââââââââââââââââ c: 1/âââââââââââââââââââââââââââ ââââââââââââ q_0: â|0&gt;ââ¤ RY(2Ï/3) â ââââââââââââ c: 1/âââââââââââââââââ Then now, if I do: print(qasm_circuit.qasm()) then I will get OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q[1]; creg c[1]; reset q[0]; ry(2*pi/3) q[0]; You can now paste the QASM code to the Composer and continue on with your circuit construction.",3/14/2021 7:07
16518.0,"Best way to compute $\langle a|B|a \rangle$ in Cirq, where a is a state obtained running circuit A. And B is a different Quantum Circuit","I am implementing RQAOA in Cirq. After running regular QAOA to find an optimal state a (This I have done successfully). I need to calculate $\langle a|Z_iZ_j|a\rangle$ for all $i,j$ in MyGraph.edges(). How should I go about using state a found with the QAOA circuit, to calculate the expectation value of a different circuit with that state?",<programming><cirq><qaoa>,3/15/2021 10:21,16520.0,16520.0,"If you've already simulated the final state $|a\rangle$, something like the following should work: qubits = cirq.LineQubit.range(nqubits) # qubit order in the observables must match the qubit order in the circuit used to generate |a&gt; qubit_map = dict(zip(qubits, range(nqubits))) for (i, j) in MyGraph.edges(): # make the Z_i*Z_j observable ZiZj = cirq.Z(qubits[i]) * cirq.Z(qubits[j]) # compute desired expectation expectation_ZiZj = ZiZj.expectation_from_state_vector(a, qubit_map=qubit_map) Also in the expression $\langle a | B | a \rangle$, $B$ is generally not a quantum circuit, it needs to be an &quot;observable&quot; (Hermitian operator).",3/15/2021 18:49
16673.0,Make a controlled gate from a QuantumCircuit that uses append in Qiskit,"Here is a minimal example for what I want to do: from qiskit import QuantumCircuit qc1 = QuantumCircuit(1, name='qc1') qc1.x(0) qc2 = QuantumCircuit(1, name='qc2') qc2.h(0) qc2.append(qc1, [0]) qc2.z(0) c_qc2 = qc2.to_gate().control(1) This gives the following error: qiskit.exceptions.QiskitError: 'One or more instructions cannot be converted to a gate. &quot;qc1&quot; is not a gate instruction' I'm aware that in this example I can get the desired controlled gate of qc2 by manually adding a control qubit to each gate in qc2. However in practice qc2 would be complex and doing so would be tiresome. I also tried qc2.append(qc1.to_instruction(), [0]) which didn't solve the problem. Any help is appreciated. Thanks!",<programming><qiskit>,3/24/2021 18:44,16674.0,16674.0,"Edit: Miss understood your question earlier. As commented by @Egrettal you can do the following. from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit qc1 = QuantumCircuit(1, name='qc1') qc1.x(0) print(qc1) qc2 = QuantumCircuit(1, name='qc2') qc2.h(0) qc2.append(qc1.to_gate(), [0]) qc2.z(0) print(qc2) xs_gate = qc2.to_gate() cxs_gate = xs_gate.control() circuit = QuantumCircuit(2) circuit.append(cxs_gate, [0,1]) print('\n New circuit with controlled:\n',circuit) print('\n Decomposed new circuit:\n', circuit.decompose()) Which will output: âââââ q_0: â¤ X â âââââ âââââââââââââââââ q_0: â¤ H ââ¤ qc1 ââ¤ Z â âââââââââââââââââ New circuit with controlled: q_0: ââââ âââ ââââ´âââ q_1: â¤ qc2 â âââââââ Decomposed new circuit: ââââââââââ Â» q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââââââââââââââââ ââÂ» ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââââââââââââââââ´ââÂ» q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) ââ¤ RY(Ï/4) ââ¤ X âÂ» âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â« ââââââââ Â» Â«q_0: âââââââââââââââ âââ¤ P(0) ââââ âââââââââââââââââ âââââââââââââââââ ââÂ» Â« âââââââââââââââ´ââââââââââ¤âââ´âââââââââââââââââ´âââââââââââââââââ´ââÂ» Â«q_1: â¤ RY(-Ï/4) ââ¤ X ââ¤ P(0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X âÂ» Â« ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â« ââââââââââ Â«q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââ Â« ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââ Â«q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) â Â« âââââââââââââââââââââââââââââââââââââââââââââââ",3/24/2021 18:56
16828.0,Writing the Jaynes-Cumming model in QuTip,"I want to write the Jaynes-Cumming Hamiltonian in QuTip. $$H = \hbar \omega_{C} a^\dagger a + \frac12 \hbar \omega_{a} \sigma_{z} + \hbar \lambda (\sigma_{+} a + \sigma_{-} a^\dagger)$$ I assume $\hbar = 1$, and we know $a, a^\dagger$ are the field (cavity) operators, and $\sigma_{z}, \sigma_{+}, \sigma_{-}$ are the atomic operators; and they commute. $\lambda$ is the coupling constant. I assume that the # of Fock basis states that I choose is N. Now, to write the Hamiltonian using qutip I would use the following statements, $a$: a = tensor(qeye(2), destroy(N)) $a^\dagger$: a.dag() $a^\dagger a$: a.dag() * a $\sigma_{z}$: sz = tensor(sigmaz(), qeye(N)) $\sigma_{+} a$: sp = tensor(sigmap(), qeye(N)) * a $\sigma_{-} a^\dagger$: sp.dag() $\sigma_{+} a + \sigma_{-} a^\dagger$: sp + sp.dag() But in the QuTip documentation the interaction term has been written as, sm = tensor(destroy(2), qeye(N)); Hint = a.dag() * sm + a * sm.dag() Could someone explain why they use the previous statement but not the one I would have assumed?",<programming><qutip>,04/02/2021 18:57,16830.0,16830.0,"Usually we say $|0\rangle$ is the ground state and is at the north pole, but sometimes people choose the convention that since the north pole is ``higher&quot; than the south pole on the Bloch sphere, that $|0\rangle$ should be the excited state instead. Thus, the qubit raising operator (with basis ordering $|0\rangle, |1\rangle$) is \begin{align} \sigma_+ = \begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{bmatrix} \end{align} which actually looks like the lowering operator in the first convention. QuTiP is treating the qubit as a two-level oscillator ($|0\rangle$ is ground), and you are using $|0\rangle$ as excited.",04/02/2021 19:36
16868.0,How to get eigenvectors of Hamiltonian in OpenFermion,"In OpenFermion you can create a Hamiltonian in terms of creation and annihilation pretty easily: ham = ((FermionOperator('1^ 1', .5)) + (FermionOperator('2^ 2', .25))) And getting the eigenvalues of the Hamiltonian is pretty straightforward as well: vals = eigenspectrum(ham) But I don't understand how to get the eigenvectors of the Hamiltonian. FermionOperator doesn't return a numpy object so I can't use usual linear algebra libraries. What am I missing?",<programming><hamiltonian-simulation><openfermion>,04/06/2021 04:24,16881.0,16881.0,"The following works: sparse_mat = openfermion.get_sparse_operator(ham, n_qubits=n) # type: scipy.sparse.csr_matrix mat = sparse_mat.toarray() # type: np.ndarray w, v = numpy.linalg.eigh(mat) Then w will contain the eigenvalues and the columns of v will contain the eigenvectors. Setting the n_qubits=n parameter will result in a matrix that gets padded up to $2^n \times 2^n$ which is important if you're going to do further matrix manipulations or algebra involving the matrix representing your Hamiltonian. And of course, for efficiency reasons you may choose not to cast the sparse operator to a numpy array but then you will end up using sparse matrix functions from scipy, for example scipy.sparse.linalg.eigsh to find some subset of eigenvalues/eigenvectors of a sparse matrix.",04/06/2021 18:21
16888.0,Quantum Katas - Tutorials - SingleQubitGates - Exercise 7 - Preparing an arbitrary state,"Exercise 7 &quot;Preparing an arbitrary state&quot; from the Quantum Katas - Tutorials - SingleQubitGates asks to prepare a state $\alpha|0\rangle + e^{i\theta}\beta|1\rangle$, using parameters $\alpha$, $\beta$, and $\theta$. In brief, $\theta$ is one of known-inputs, why we don't use $\theta$ for the Ry gate directly ? Something like this.. Ry(theta, q); R1(theta, q); But alas, I got error: Qubit in invalid state. Expecting: Zero Expected: 0 Actual: 0.061208719054813704 Try again! Any ideas would be highly appreciated!!",<programming><q#>,04/07/2021 03:02,16889.0,16889.0,"The angle to use for Ry gate is not necessarily the same one as the given angle $\theta$ to use for R1 gate. This means that you need to figure out the angle for Ry gate from the parameters $\alpha$ and $\beta$. If you're using $\theta$ for both angles, you'll be preparing a state $\cos \frac{\theta}{2}|0\rangle + e^{i\theta}\sin \frac{\theta}{2}|1\rangle$, not $\alpha|0\rangle + e^{i\theta}\beta|1\rangle$ the task asks for. I recommend checking out the workbook for that tutorial - it has a very detailed explanation of the steps you need to take to solve this task.",04/07/2021 03:19
17175.0,Quantum Katas - Tutorials - Oracles - Task 3.3 (OR oracle of all bits except for a single bit),"Let $x$ be an arbitrary state composed of $N$ qubits and $k$ be an integer such that $0\leq k \leq N.$ The task is to ignore the $k$-th bit and to flip the sign of $x$ if any of the remaining bits are equal to 1. In other words, flipping the sign of $x$ is independent of the $k$-th bit, but it is dependent on the existence of 1's lurking in $x$. The solution I came up with is the following, which, unfortunately, I cannot implement. Regardless of what $x$ is we flip its sign. There are two cases we should correct for, namely, the binary representations of 0 and $2^k$. Could not we take care of these two scenarios by using the ControlledOnInt function by setting $\textit{numberstate}$ to 0 (first we have the $X$ gate act on $x[k]$, so that $Z$ flips $x$) and $2^k$, the $\textit{oracle}$ to $Z$, the $\textit{control register}$ to $[x]$ and the $\textit{target register}$ to $x[k]$? Also, why can't the control and target registers be the same? How could we implement the above with an auxiliary qubit? In the second case where $x$ is the binary representation of $2^k$, we could use the task 3.2 from the same tutorial (flips the sign of $x$ if the $k$-th qubit is 1), but I am also having trouble with that task. I have been able to implement the OR oracle (task 3.1 of the same tutorial), but it was done with a marking oracle, not a phase oracle.",<q#><oracles>,4/21/2021 2:20,17176.0,17176.0,"There is a much simpler way to approach this task. It requires only two observations: You can always convert a marking oracle to a phase oracle using the phase kickback trick (discussed earlier in the tutorial). Some tasks in this tutorial prohibit using extra qubits for this purpose to push you towards a solution that doesn't rely on that, but this task doesn't have this restrictions, so you can allocate that extra qubit, implement a marking oracle and use them to get your phase oracle. If you need to perform some computation on the whole register except one qubit, why not just define a qubit array that holds the rest of the qubits and use that array as the input for the marking oracle? (This is more of a programming trick than a quantum computing one, but it's a useful one!) With those two observations, the code is pretty straightforward: use minus = Qubit(); within { X(minus); H(minus); } apply { Or_Oracle(x[...k-1] + x[k+1...], minus); } x[...k-1] + x[k+1...] is a concatenation of two qubit arrays: all qubits before the $k$-th one and all qubits after the $k$-th one. You can always check the file ReferenceImplementation.qs in the tutorial folder to see the author's solutions to the tasks.",4/21/2021 2:51
17320.0,What is the superop simulator in Qiskit for?,"I'm trying to understand what the use case of a superop simulator would be. My understanding is that density matrix is generally more resource intensive than state vector, but it has additional capabilities to support noisy channels and such. And also my understanding is that every circuit has a corresponding superop that can be extracted from it via QIS, but I believe that can be obtained via calculation rather than simulation. So I don't understand what a superop simulator is for. I know it's even more resource intensive than density matrix, but what additional capabilities does it provide?",<programming><qiskit><quantum-state><simulation><density-matrix>,05/01/2021 15:51,17337.0,17337.0,"If you have an ideal quantum circuit, you can easily get its superoperator representation using qiskit.quantum_info.SuperOp as follows, qc = QuantumCircuit(1) qc.x(0) super_op = SuperOp(qc) array_to_latex(super_op) The output will be $$ \left[\begin{matrix} 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 0\\ \end{matrix}\right] $$ And to see how a quantum state is evolved by applying this operator: rho1 = DensityMatrix.from_label('0') rho2 = rho1.evolve(super_op) rho2.draw('latex') However, you can not use this method to get the superoperator representation of the circuit in the presence of errors. Instead, you can use superop simulator, which accepts a NoiseModel as a parameter # Add save_superop instruction to save the simulator state to the returned results: qc.save_superop() # Get noise model: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_16_melbourne') noise_model = NoiseModel.from_backend(backend) # Get the superoperator: noisy_simulator = AerSimulator(method = 'superop', noise_model = noise_model) result = noisy_simulator.run(qc).result() super_op_array = result.data()['superop'] array_to_latex(super_op_array) And in this case the output will be somthing like that: $$ \left[\begin{matrix} 0.00094 &amp; 0 &amp; 0 &amp; 0.99979\\ 0 &amp; 0 &amp; 0.99907 &amp; 0\\ 0 &amp; 0.99907 &amp; 0 &amp; 0\\ 0.99906 &amp; 0 &amp; 0 &amp; 0.00021\\ \end{matrix}\right] $$",05/03/2021 23:23
17336.0,Can I use Grover's algorithm on overlapping sets of qubits?,"Let's say I have 3 qubits: $q_1,q_2,q_3$. I want to apply Grover's algorithm on q1,q2, such that q1,q2 $\neq$ 10 and do the same for q2,q3, so that q2,q3 $\neq$ 11. The final possible combinations of the qubits q1,q2,q3 should then be: 000 001 010 110 And they shouldn't be: 011 100 101 111 If this is possible then couldn't I solve 3sat in polynomial time with a quantum computer? Couldn't I just remove the possibility of each clause being unsatisfied from a set of qbits representing the variables in the 3sat problem and then collapse the qbits to see if the final result is satisfiable? Example of how I think a quantum computer would solve an instance of a 3sat problem in polynomial time: Note: each computation should be on a set of 3 qbits at a time which should take $2^{3/2}$ time with Grover's algorithm, or O(1) in big O notation) Variables = ${a,b,c,d,e}$ clauses = ${(\neg a \vee b \vee \neg c),(b \vee c \vee d),(\neg b \vee \neg c \vee d),(c \vee \neg d \vee e),(c \vee \neg d \vee \neg e)}$ We have qubits $q_a, q_b, q_c, q_d, q_e$ for $q_a, q_b, q_c$ we remove the possibility of 101 (since this would not satisfy the 1st clause) for $q_b, q_c, q_d$ we remove the possibility of 000 and 110 (since those would not satisfy the 2nd and 3rd clause) for $q_c, q_d, q_e$ we remove the possibility of 010 and 011 (since those would not satisfy the 4th and 5th clause) Now the possible outputs of the qbits are: 00100 00101 00110 00111 01000 01001 01110 01111 11000 11001 11110 11111 So if I collapse the qbits I should remain with one of these combinations which satisfies the problem. If there is no possible solution, the qbits will just collapse into something meaningless which will not satisfy the problem. If anyone can show me the flaw in my logic, please let me know, I highly doubt I solved 3sat. I'm just trying to learn.",<programming><quantum-state><algorithm><grovers-algorithm><quantum-advantage>,05/03/2021 17:31,17353.0,17353.0,"Grover's algorithm has two components, which alternate and repeat $O(\sqrt{N})$ times: a diffusion operator and an oracle operator. The diffusion operator will cause problems with your idea. As I understand, what you want to do is start from a uniform superposition $$\vert \psi_0\rangle =\frac{1}{\sqrt{2^n}}\sum_{b_1,\dots,b_n\in\{0,1\}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$ and then solve for (e.g.) a clause $C_1$ in $b_1,b_2,b_3$, to get something like: $$\vert\psi_1\rangle=\frac{1}{\sqrt{N}}\sum_{\substack{b_1,\dots,b_n\in\{0,1\}\\ C_1(b_1,b_2,b_3)=1}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$ where $N$ is the number of remaining solutions. From this superposition, you want to solve for another clause $C_2$ which involves (e.g.) $b_1, b_4, b_5$ (if no other clause involves $b_1,b_2,b_3$, then it's easy to solve for these 3 variables first and then remove them from the problem). But now you're searching over the first qubit, $b_1$, but $\vert\psi_1\rangle$, your superposition over $b_1$, is non-trivial. Grover's algorithm requires a way to flip the phase of the starting superposition. Normally, the way to do this is to apply $H$ gates to every qubit and flip the all-zeros state, then apply $H$ again to return to the previous state, but after solving the first clause, the superposition $\vert\psi_1\rangle$ is not just $H^{\otimes n}\vert 0^n\rangle$. In fact, (as far as I am aware) the only way to construct a diffusion operator for the superposition $\vert\psi_1\rangle$ where $C_1$ is solved is to undo the solution for $C_1$, then apply $H$ gates, then flip over $\vert 0^n\rangle$, then redo those same operations. If you do that, then you can run Grover's algorithm on a clause-by-clause basis and solve the 3-SAT problem. However, the cost is not polynomial: If there are $m$ clauses, for the last clause, the diffusion operator must solve and unsolve an $m-1$ clause 3-SAT problem. So if the cost of solving this problem is $c_{m-1}$, the total cost will be $\approx\sqrt{2^3}c_{m-1}$. But solving an $m-1$ clause 3-SAT problem will require a diffusion operator that solves an $m-2$ clause 3-SAT problem, so $c_{m-1}\approx \sqrt{2^3}c_{m-2}$ (and so on). You end up multiplying all of the factors of $\sqrt{2^3}$ each time you go through, and the total cost ends up as something like $O(\sqrt{2^{3m}})$ -- which is roughly the exponential cost you would expect from a naive Grover search.",05/05/2021 08:14
17341.0,Why `cirq` needs `Qid` class instead of just `Qudit` class?,"I am just wondering in what way cirq.Qid class generalizes qudits. From cirq.Qid documentation we read that it Identifies a quantum object such as a qubit, qudit, resonator, etc. I am not sure what this resonator means and if it is somehow connected to other qudits in the system. Could anyone clarify it?",<programming><cirq><qudit>,05/04/2021 16:16,17345.0,17345.0,"Well, originally the idea was that we didn't want to exclude things like continuous quantum systems, and ancillary systems being used as control surfaces, and concepts like &quot;a place where an ion might be&quot; as opposed to the ion itself. So we went with a very generic &quot;identifier for quantum-associated thing&quot; name (qid). At some point Qid gained a dimension method that returns an integer telling you how many quantum levels there are... so it really basically is a qudit now.",05/04/2021 19:40
17375.0,Is there any way to obtain the number of qubits of a given backend in Qiskit?,"I'm testing out a program in different IBMQ mock backends, and I want the program to use the maximum number of qubits in each case. Is there any function/method to extract the number of qubits of a given backend, so that I don't have to manually look it up every time? Extra: Is there any way to automate the process of selecting each of these mock backends? My plan is to create an array fake_servers = [FakeAlmaden(), FakeAthens(), FakeBelem(), FakeBoeblingen()] etc, but if there's a more straightforward way, I'd like to know about it...",<programming><qiskit><ibm-q-experience><ibm>,05/06/2021 14:44,17376.0,17376.0,"The number of qubits is part of the backend configuration: FakeManhattan().configuration().n_qubits 65 If you need to filter the list of mocked backends based on the amount of qubits: from qiskit.test.mock import FakeProvider provider = FakeProvider() [ b.name() for b in provider.backends() if b.configuration().n_qubits &gt; 20] ['fake_cambridge', 'fake_cambridge', 'fake_manhattan', 'fake_montreal', 'fake_mumbai', 'fake_paris', 'fake_rochester', 'fake_sydney', 'fake_toronto']",05/06/2021 14:59
17438.0,Performing a generic single-qubit Pauli error channel in stim,"I have a Pauli channel with disjoint probabilities $P_I$, $P_X$, $P_Y$, $P_Z$ (meaning $P_I + P_X + P_Y + P_Z = 1$) corresponding to Pauli errors I, X, Y, Z. Is there some way apply this Pauli channel in Stim?",<programming><stim>,05/11/2021 00:39,17439.0,17439.0,"Update: Since v1.4, stim supports custom pauli channels PAULI_CHANNEL_1(px, py, pz) and PAULI_CHANNEL_2(pix, piy, ..., pzz). Before v1.4 If $P_x = P_y = P_z$ then DEPOLARIZE1 is what you need. If $P_y = P_z = 0$ then X_ERROR is what you need (ditto Y_ERROR, Z_ERROR). Otherwise you can use CORRELATED_ERROR and ELSE_CORRELATED_ERROR. For example, suppose $P_x = 0.1$, $P_y = 0.2$, $P_z = 0.3$ and your target is qubit $5$. You can do this: CORRELATED_ERROR(0.1) X5 ELSE_CORRELATED_ERROR(0.22222222222) Y5 # note: P(Y|not X) = 20%/(100% - 10%) ELSE_CORRELATED_ERROR(0.42857142857) Z5 # note: P(Z|not X and not Y) = 30%/(100% - 10% - 20%) The else-case probabilities are conditioned on the earlier cases not happening, which is why they are larger than the original probabilities. Here's the general case, implemented as python code: def append_generic_single_qubit_error_channel_to_circuit( circuit: stim.Circuit, target: int, px: float, py: float, pz: float): &quot;&quot;&quot; Args: circuit: The circuit to append the error channel to. target: The qubit to hit with the error channel. px: The disjoint probability of an X error. py: The disjoint probability of a Y error. pz: The disjoint probability of a Z error. Requires: 0 &lt;= px &lt;= 1 0 &lt;= py &lt;= 1 0 &lt;= pz &lt;= 1 px+py+pz &lt;= 1 &quot;&quot;&quot; circuit.append_operation(&quot;CORRELATED_ERROR&quot;, [stim.target_x(target)], px) circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_y(target)], py / (1 - px)) circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_z(target)], pz / (1 - px - py)) Note that it agrees with the example case: import stim c = stim.Circuit() append_generic_single_qubit_error_channel_to_circuit( circuit=c, target=5, px=0.1, py=0.2, pz=0.3) print(c) E(0.1) X5 ELSE_CORRELATED_ERROR(0.222222) Y5 ELSE_CORRELATED_ERROR(0.428571) Z5 (E is an abbreviation for CORRELATED_ERROR)",05/11/2021 00:39
17441.0,Is there a way I can reduce the code for generating simple circuits with the same structure?,"here's the code I'm using to generate 3 quantum circuits with the same structure (They're only differed by the first U3 gate on the qubit): quancs = QuantumCircuit(1) # Circ 1 quancs.u3(gamma,beta,delta,0) quancs1 = QuantumCircuit(1) # Circ 2 quancs1.u3(2,3,2,0) quancs1.u3(gamma,beta,delta,0) quancs2 = QuantumCircuit(1) # Circuit 3. quancs2.u3(-2.5,2,-2,0) quancs2.u3(gamma,beta,delta,0) results = execute(quancs, simulator).result() results1 = execute(quancs1, simulator).result() results2 = execute(quancs2, simulator).result() I treated the circuits separately to obtain the results. I'm wondering is there a way I can simplify/shorten this code? Thanks for the help!",<programming><qiskit>,05/11/2021 03:17,17442.0,17442.0,"How about something like this: from qiskit.circuit import QuantumCircuit def my_circuit(initial_gate_params, params): circuit = QuantumCircuit(1) circuit.u3(initial_gate_params[0],initial_gate_params[1],initial_gate_params[2],0) circuit.u3(params[0], params[1], params[2], 0) return circuit initial_gate_params = [ [0,0,0], [2,3,2], [-2.5,2,-2] ] #the params for your initial u3 gate params = [gamma, beta, zeta] #your defined gamma, beta, zeta circuits = [my_circuit(i, params) for i in initial_gate_params ] from qiskit import Aer, execute backend = Aer.get_backend('qasm_simulator') results = execute(circuits, backend)",05/11/2021 03:38
17464.0,Time result for my algorithm,"I've used the function result.time_taken to know the amount of time used to execute a task on the real chip, but I don't understand if the result is in seconds or in milliseconds, because if I run my circuit with 1 shot my result is 7.8, if I run my circuit with 1024 shots my result is 8.4. How is this possible? Does the time include only time to execute the algorithm, or other times (for instance the initialization of my input...)?",<programming><qiskit><algorithm><ibm-q-experience>,05/12/2021 05:57,17467.0,17467.0,"The device time consists of multiple step, such as loading the circuit to the device, then the actual processor time and finally the return of the results. Only the processor time scales with the number of shots, the device loading time, and result return are constant overhead. Thus it makes sense to see the behavior you saw; you have some constant time and then on top the time that scales linearly in the number of shots. You could find the time for the overhead if you do a linear fit to the total execution time, then the offset equals the overhead. As a more concrete example, on a recent job the device load and return result together took about 10s and the processor time for 1024 shots was ~4s, and for 8192 ~28s (so even a little bit faster than 8x the 1024 shots time). Of course these numbers depend on the device you're using!",05/12/2021 07:06
17663.0,What explains my anomalously scaled up VQE?,"I am trying to implement VQE from the Qiskit to obtain the ground state of a very specific Hamiltonian that has been generated via a docplex minimized quadratic model. The model has been converted to an Ising Hamiltonian using Qiskit's Optimization module. The resultant Hamiltonian denoted by H is as follows: from qiskit.providers.aer import AerSimulator, QasmSimulator from qiskit.algorithms import VQE from qiskit.algorithms.optimizers import COBYLA from qiskit.circuit.library import TwoLocal from qiskit import * from qiskit.opflow import OperatorBase from qiskit.opflow import Z, X, I # Pauli Z, X matrices and identity import pylab import matplotlib.pyplot as plt import numpy as np H = 504.0 * I^I^I^I^I^I^I^Z+1008.0 * I^I^I^I^I^I^Z^I+2016.0 * I^I^I^I^I^Z^I^I+504.0 * I^I^I^I^Z^I^I^I+1143.7999999999997 * I^I^I^Z^I^I^I^I+2287.6 * I^I^Z^I^I^I^I^I+4575.200000000001 * I^Z^I^I^I^I^I^I+1143.7999999999997 * Z^I^I^I^I^I^I^I+98.0 * I^I^I^I^I^I^Z^Z+196.0 * I^I^I^I^I^Z^I^Z+392.0 * I^I^I^I^I^Z^Z^I+49.0 * I^I^I^I^Z^I^I^Z+98.0 * I^I^I^I^Z^I^Z^I+196.0 * I^I^I^I^Z^Z^I^I+93.1 * I^I^Z^Z^I^I^I^I+186.2 * I^Z^I^Z^I^I^I^I+372.4 * I^Z^Z^I^I^I^I^I+46.55 * Z^I^I^Z^I^I^I^I+93.1 * Z^I^Z^I^I^I^I^I+186.2 * Z^Z^I^I^I^I^I^I backend = QasmSimulator() optimizer = COBYLA(maxiter=2000) ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False) # set the algorithm vqe = VQE(ansatz, optimizer, quantum_instance=backend) #run it with the Hamiltonian we defined above result = vqe.compute_minimum_eigenvalue(H) This however yields the error: 'Circuit execution failed: ERROR: [Experiment 0] QasmSimulator: Insufficient memory for 141-qubit circuit using &quot;statevector&quot; method. You could try using the &quot;matrix_product_state&quot; or &quot;extended_stabilizer&quot; method instead.' My questions are: How and why does my circuit yield 141 qubits when there are only 8 Pauli Operators in each term of my Hamiltonian? What am I missing conceptually? How do we calculate the number of qubits required when solving this sort of problem?",<programming><qiskit><vqe><optimization>,5/27/2021 5:12,17665.0,17665.0,"Easy Fix: It seems like it is because of the way you define $H$. You need the parenthesis around each of the term! So something like: H = (504.0 * I^I^I^I^I^I^I^Z) + (1008.0 * I^I^I^I^I^I^Z^I) + ( 2016.0 * I^I^I^I^I^Z^I^I) Just replace this in your code then it will work! Alternative (longer) way: Here I will offer another way to define the Hamiltonian in case you are curious. Instead of doing the above, if you replace it with something like: from qiskit.aqua.operators import * pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ] pauli_weights = [504.0, 1008.0, 2016.0] pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \ for i in range(len(pauli_terms))]} H = WeightedPauliOperator.from_dict(pauli_dict) This should work. I just grabbed the first 3 entries of your Hamiltonian. Here is the full script for you to reproduce the result: import numpy as np from qiskit.providers.aer import AerSimulator, QasmSimulator from qiskit.algorithms.optimizers import COBYLA from qiskit.circuit.library import TwoLocal from qiskit.aqua.operators import * from qiskit.aqua import set_qiskit_aqua_logging, QuantumInstance from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE, NumPyEigensolver from qiskit.circuit import QuantumCircuit, ParameterVector pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ] pauli_weights = [504.0, 1008.0, 2016.0] pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \ for i in range(len(pauli_terms))]} Hamiltonian = WeightedPauliOperator.from_dict(pauli_dict) ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False) print(ansatz) backend = QasmSimulator() quantum_instance = QuantumInstance(backend, shots = 8192, initial_layout = None, optimization_level = 3) optimizer = COBYLA(maxiter= 100, tol=0.000000001) vqe = VQE(Hamiltonian, ansatz, optimizer, initial_point= None , include_custom = False) print('We are using:', quantum_instance.backend) vqe_result = vqe.run(quantum_instance) vqe_result['eigenvalue'] output: ââââââââââââ ââââââââââââ q_0: â¤ RY(Î¸[0]) âââ¤ RY(Î¸[8]) â ââââââââââââ¤ ââââââââââââ¤ q_1: â¤ RY(Î¸[1]) âââ¤ RY(Î¸[9]) â ââââââââââââ¤ââ´âââââââââââ¤ q_2: â¤ RY(Î¸[2]) ââ¤ RY(Î¸[10]) â ââââââââââââ¤âââââââââââââ¤ q_3: â¤ RY(Î¸[3]) ââ¤ RY(Î¸[11]) â ââââââââââââ¤âââââââââââââ¤ q_4: â¤ RY(Î¸[4]) ââ¤ RY(Î¸[12]) â ââââââââââââ¤âââââââââââââ¤ q_5: â¤ RY(Î¸[5]) ââ¤ RY(Î¸[13]) â ââââââââââââ¤âââââââââââââ¤ q_6: â¤ RY(Î¸[6]) ââ¤ RY(Î¸[14]) â ââââââââââââ¤âââââââââââââ¤ q_7: â¤ RY(Î¸[7]) ââ¤ RY(Î¸[15]) â âââââââââââââââââââââââââ We are using: qasm_simulator (-3528+0j) Although I am not sure why you would have two consecutive layers of $RY$ rotation though.",5/27/2021 6:27
17704.0,Decomposition of gate $R_{y}$ into specific basis,"How can I decompose gate $R_{y}(\theta)$ into gate $R_{x}(\alpha)$ and gate $R_{z}(\beta)$. And how to perform it on Qiskit, is there any function to do it.",<programming><qiskit><quantum-gate>,5/29/2021 8:57,17706.0,17706.0,"Qiskit supports translating to different continuous basis sets by specifying the basis_gates in the transpile method. So in your case you could just do &gt;&gt;&gt; from qiskit import QuantumCircuit, transpile &gt;&gt;&gt; from qiskit.circuit import Parameter &gt;&gt;&gt; circuit = QuantumCircuit(1) &gt;&gt;&gt; circuit.ry(Parameter('theta'), 0) &gt;&gt;&gt; rxrz_basis = transpile(circuit, basis_gates=['rx', 'rz']) &gt;&gt;&gt; rxrz_basis.draw() âââââââââââââââââââââââââââââââââââââââââââââââââ q_0: â¤ RX(Ï/2) ââ¤ RZ(theta + Ï) ââ¤ RX(Ï/2) ââ¤ RZ(3Ï) â âââââââââââââââââââââââââââââââââââââââââââââââââ So you see that $$ R_Y(\theta) = R_Z(\pi) R_X\left(\frac{\pi}{2}\right) R_Z(\theta + \pi) R_X\left(\frac{\pi}{2}\right) $$ where I replaced the $3\pi$ by $\pi$ in the last RZ rotation since the operation is mod $2\pi$.",5/29/2021 9:26
18010.0,How can I write unit tests for a pennylane circuit?,"I have several mixing unitary circuits written using Pennylane to be used in the QAOA algorithm. Furthermore, I'd like to write unit tests for these mixing circuits to ensure that the code is doing what it is supposed to in the future as changes are made to the codebase. Consider the basic example: def x_mixer(beta, wires): for i in wires: qml.RX(beta, wires=i) Currently, I'm thinking of using assert statements to check that the output of: dev = qml.device('lightning.qubit', wires=2, shots=10000) circuit = qml.QNode(mixer_circuit, dev) result = circuit(0.5, wires=[0, 1]) is a certain value. Now one issue is that the results themselves are probabilistic and change during each run. My first question: What's the best way to get around this? Can you set random_seed in any of the simulator devices? In general if someone has ideas on how to do unit testing for Pennylane circuits, it would be really appreciated.",<programming><quantum-circuit><pennylane>,6/17/2021 19:32,18011.0,18011.0,"Simulator devices, like 'lightning.qubit' or 'default.qubit', can usually be run analytically. This is the default for most devices, but can be explicitly specified by setting shots=None. Devices inheriting from QubitDevice, like &quot;default.qubit&quot; and &quot;lightning.qubit&quot; currently rely on numpy.random for their random number generation. So you can also specify the global numpy seed to get reproducible results: import numpy as np np.random.seed(1234) Hope that helps :)",6/17/2021 20:21
18087.0,Are job IDs unique across backends?,"Are job IDs unique across backends, or is it possible that two jobs on two different backends have the same job ID? I'd like to use the job ID as primary key in a database. Thanks in advance!",<programming><qiskit>,6/22/2021 12:07,18095.0,18095.0,"Yes, they are unique across the full system. They are assigned by the server and it is safe to use them as primary key.",6/22/2021 18:25
18225.0,How to assemble two quantum circuits which has each own qubit mapping state?,"I'm curious about something. I tried to do some qubit mapping using SABRE algorithm. Suppose I have two quantum circuits and apply SABRE algorithm to both of them. Then each of them has its own qubit mapping states. After that, I want to compose them to make it as one long quantum circuit. How can I do it? I used python code and qiskit. I have already searched qiskit API and used some functions (compose, combine, append). But the circuits could not be combined. How can I assemble two quantum circuit which have different qubit mapping state respectively? Thank you",<programming><qiskit>,07/01/2021 02:26,18227.0,18227.0,"The short answer to composed circuit is the following. Given circuit1 and circuit2, you can do like this: circuit = circuit1 + circuit2 You can also do that with transpiled circuits: transpiled1 = transpile(circuit1, backend, routing_method='sabre') transpiled2 = transpile(circuit2, backend, routing_method='sabre') circuit = transpiled1 + transpiled2 Notice that the circuits to composed need to be the same size. After transpilation, that is ensured. transpile will make the circuit as big as the backend (given that you use the same backend during transpilation). The operation + will wire the links one-to-one. Here is an example to compose circuit with different sizes: circuit1 = QuantumCircuit(5) circuit1.mcx([0, 1, 3, 4], 2) print(circuit1) circuit2 = QuantumCircuit(2) circuit2.cx(0, 1) print(circuit2) q_0: âââ ââ â q_1: âââ ââ âââ´ââ q_2: â¤ X â âââ¬ââ q_3: âââ ââ â q_4: âââ ââ q_0: âââ ââ âââ´ââ q_1: â¤ X â âââââ In this case, you need to use compose(..., qubits=...). The parameter qubits indicates how to wire the circuits. circuit = circuit1.compose(circuit2, qubits=[3,2]) print(circuit) q_0: âââ âââââââ â q_1: âââ âââââââ âââ´âââââââ q_2: â¤ X ââ¤ X â âââ¬âââââ¬ââ q_3: âââ âââââ ââ â q_4: âââ âââââââ",07/01/2021 07:27
18310.0,Get the inverse of a Hermitian operator for measurement in qiskit,"I am using Qiskit to measure the Hamiltonian H, which isbasically sum of Pauli strings, say something like 2*X^X+0.5*Z^Y. For one variable, I need to get the analytically form of the inverse of H. It seems that there is no easy way to directly get the inverse observable. So, I am wondering that how can I get this done by using qiskit?",<programming><qiskit><measurement>,07/06/2021 12:38,18311.0,18311.0,"It seems that Qiskit does not have this feature. However, you can get the matrix, inverse it using numpy.linalg.inv(), then convert it to operator object again: from qiskit.opflow import X, Y, Z from qiskit.opflow.primitive_ops import MatrixOp import numpy as np op = 2*(X^X)+0.5*(Z^Y) inv_matrix = np.linalg.inv(op.to_matrix()) operator = MatrixOp(inv_matrix) print(operator.to_pauli_op()) And to get a PauliSumOp: pauli_list = [(p.primitive.to_label(), p.coeff) for p in operator.to_pauli_op().oplist] pauli_sum_op = PauliSumOp.from_list(pauli_list)",07/06/2021 13:18
18454.0,About qiskit's error mitigation,"In qiskit, the error correction using least squares is apparently in qiskit-ignis/qiskit/ignis/mitigation/measurement/filters.py, source code from github and reads: # Apply the correction for data_idx, _ in enumerate(raw_data2): if method == 'pseudo_inverse': raw_data2[data_idx] = np.dot( pinv_cal_mat, raw_data2[data_idx]) elif method == 'least_squares': nshots = sum(raw_data2[data_idx]) def fun(x): return sum( (raw_data2[data_idx] - np.dot(self._cal_matrix, x))**2) x0 = np.random.rand(len(self._state_labels)) # ******** x0 = x0 / sum(x0) # ******** cons = ({'type': 'eq', 'fun': lambda x: nshots - sum(x)}) bnds = tuple((0, nshots) for x in x0) res = minimize(fun, x0, method='SLSQP', constraints=cons, bounds=bnds, tol=1e-6) raw_data2[data_idx] = res.x else: raise QiskitError(&quot;Unrecognized method.&quot;) I'm not too skilled in python and I would not like to change my qiskit's base installation. I have marked with * the two lines that seems to me strange. My question is: in this error correction, one does least squares to minimize the function $F=|c_{\rm exp} - Mc_{\rm corr}|^2$, where $c_{\rm exp}, c_{\rm corr}$ are the experimental and corrected counts, respectively and $M$ is the &quot;correction matrix&quot;. As it is common, minimize requires a fair guess x0 in order to find the answer of $F$. I don't understand why the built-in function sets x0 as a random vector. Ok, I can buy that the method &quot;does not know which previous circuit was ran&quot;, but in theory if one knows the circuit, one should choose x0 based on this information, right?",<programming><qiskit><error-mitigation>,7/16/2021 11:14,18461.0,18461.0,"So yeah it is not the best choice. My guess is the individual who programmed it did not think about the physics of the problem. In short, it is best to use the raw input data as the starting point when measurement errors are small. In practice this gives you much faster convergence.",7/16/2021 21:01
18566.0,Job ids retrieval from ID. Big set of jobs,"I'm in the need of running a lot of jobs in the IBM backends. If one likes to run in parallel two jobs (say, with two different parameters), I have seen in the Jobs webpage that sometimes the jobs are mixed. What I mean with this is that e.g. in the downloadable cvs file, row 3 belongs to job 1 and row 4 to job 2. To filter out every single cell in the cvs does not appear feasible. Now, in qiskit, if I send a big job, this is partitioned into several chunks, something that job_set_foo.report(detailed=True) returns is: Job set name: 2021-07-22T14:09:01.003237 ID: XXXX-YYYY tags: [] ... Detail report: experiments: 0-74 job index: 0 job ID: ZZZ1 ... So suppose that my ID XXX-YYY contains 20 jobs ids ZZZx. Is there a way to, from directly the ID, retrieve as a list all the ZZZx's jobs ids? *job_set_foo = job_manager.run(circuits, backend=backend, shots=2**13)",<programming><ibm-q-experience>,7/22/2021 14:29,18567.0,18567.0,"If all what you want is a list of all job IDs for the jobs in a job set: job_set = job_manager.retrieve_job_set(job_set_id = 'XXX-YYY', provider = provider) id_list = [ job.job_id() for job in job_set.jobs() ]",7/22/2021 15:46
18593.0,How to re-ordering physical qubit location into desired one?,"Suppose original quantum circuit have 4 qubits and some quantum operation. Also suppose the result of original quantum circuit state is '1100'. Then apply qubit mapping then mapping state is like below 1 -&gt; 0 3 -&gt; 1 0 -&gt; 2 2 -&gt; 3 Then the result of quantum circuit after qubit mapping will be '1010'. But I want to know how to change these physical qubit state location. So ultimately, I want to see the result after qubit mapping like '1100' which is the same result of original quantum circuit. How can I do that?",<programming><physical-qubit><qubit-mapping>,7/24/2021 4:55,18594.0,18594.0,"I will answer using Python, but the underlying method can be easily adapted to another language. You can represent the mapping you describe in your question 1 -&gt; 0 3 -&gt; 1 0 -&gt; 2 2 -&gt; 3 as a map, or a Python dictionary in this case (it can also be represented as a simple array, but this complicates a little bit the code): logical2hardware_mapping = {0: 1, 1: 3, 2: 0, 3: 2} From this map representation, you can post-process your result quite easily by re-arranging the bits: import typing as ty def rearrange_hardware_result(hardware_result: str, mapping: ty.Dict[int, int]) -&gt; str: # 1. Invert the mapping hardware2logical_mapping = {v: k for k, v in mapping.items()} # 2. Construct the rearranged result return &quot;&quot;.join( hardware_result[hardware2logical_mapping[i]] for i in range(len(hardware_result)) ) Finally, you can test the function on your example and check that it works as expected: hardware_result = &quot;1010&quot; print(rearrange_hardware_result(hardware_result, logical2hardware_mapping)) # Output &quot;1100&quot; Side note: I worked quite a bit with these issues of mapping and how to change them. The most important thing to do at the very beginning in order to understand what you are doing is to note somewhere what is represented. For example in your mapping, you do not explicitly say what the indices on the left-hand side of the arrows are, same for the right-hand side ones. Once the meaning of the indices you are using is clear, everything starts to become easier.",7/24/2021 8:25
18647.0,Print runtime of an optimizer,"I want to find the runtime of my program, i.e. the time it is in the quantum computer without queue time. However, I am using an optimizer so the code is a little different. from qiskit.utils import algorithm_globals algorithm_globals.random_seed = 1234 backend = provider.get_backend('ibmq_belem') #backend = Aer.get_backend('statevector_simulator') cobyla = COBYLA() cobyla.set_options(maxiter=1) ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full') quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed) vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance) vqe = MinimumEigenOptimizer(vqe_mes) result = vqe.solve(qp) print(result) #print_result(result) How do I figure out the runtime? Printing result only shows optimal function value: -0.01488461311339271 optimal value: [1. 0. 0. 1.] status: SUCCESS",<programming><quantum-computing-for-finance>,7/28/2021 18:48,18648.0,18648.0,"I made a start and end_operation point with the method now(). At the end of the operation it will display the time it needed: from qiskit.utils import algorithm_globals from time import time as now algorithm_globals.random_seed = 1234 backend = provider.get_backend('ibmq_belem') #backend = Aer.get_backend('statevector_simulator') cobyla = COBYLA() cobyla.set_options(maxiter=1) ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full') quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed) start_operation = now() vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance) vqe = MinimumEigenOptimizer(vqe_mes) end_operation = now() result = vqe.solve(qp) process_time = ( end_operation - start_operation ) print(f&quot;Operation took {process_time:.2f} seconds in machine&quot;) print(result) #print_result(result) Another possibility to meassure the program is to use the command rep_time: rep_time (int) â Time per program execution in seconds. Must be from the list provided by the backend (backend.configuration().rep_times). Defaults to the first entry. In your specific case you need to add it in your code like this: ... quantum_instance = QuantumInstance(backend=backend, rep_time=rep_time, seed_simulator=seed, seed_transpiler=seed) ...",7/28/2021 19:02
20798.0,Can I extract information from a single shot efficiently?,"I'm running a quantum simulation and want to obtain some information from a single shot of an experiment. Here's part of the code I'm working on: for i in range(Nshot): Expeb = [] for measure_circuit in [circ_1, circ_2, circ_3, circ_4]: measure_circuit = transpile(measure_circuit,backend=backend,optimization_level=2,initial_layout = [1]) counts = execute(measure_circuit, backend = backend, shots=1).result().get_counts() for output in ['0','1']: if output not in counts: counts[output] = 0 expe = (counts['0'] - counts['1']) Expeb.append(expe) Est = sum(x*y for x,y in zip(Expeb,[a,b,c,d])) The code works on simulators, but it might take a very long time if Nshot gets large (Like 5000, I think that's because I generated a lot of circuits) and I submit the jobs to a quantum device. I wonder is there a way I can extract information (like making calculations for) a single shot but in a more efficient way? Thanks for the help!",<programming><ibm-q-experience><simulation>,08/09/2021 16:17,20799.0,20799.0,"You can use memory option. It will make the per-shot measurement bit-strings returned in the result: memory = execute(measure_circuit, backend = backend, memory = True, shots = 1024).result().get_memory()",08/09/2021 16:33
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system? Below you can see the code idea: q1 = QuantumCircuit(2) q1.save_statevector() # Save initial state q1.h(0) q1.save_statevector() # Save state after Hadamard q1.cx(0, 1) q1.save_statevector() # Save state after CNOT (also a final state) job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024) statevectors = job.result().get_statevector() However, if I were to try and run this, an error occurs upon reaching execute command. If anyone can provide any insight on this, I would be very grateful.",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"You can also obtain the states at any point during circuit construction using Statevector, the class from Qiskit's quantum_info module as follows. First, import the Statevector class, from qiskit.quantum_info import Statevector And for your example, the code below will produce all the intermediate states that you want. qc = QuantumCircuit(2) st0 = Statevector.from_instruction(qc) qc.h(0) st1 = Statevector.from_instruction(qc) qc.cnot(0, 1) st2 = Statevector.from_instruction(qc) print(st0) print(st1) print(st2) Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0.70710678+0.j, 0. +0.j, 0. +0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0. +0.j, 0. +0.j, 0.70710678+0.j], dims=(2, 2))",8/25/2021 13:41
20904.0,Q# install issue,"I have followed the instructions to install Q# using conda as recommended, and given by MS. When I try to import qsharp from my virtual env within a Python program, I get the following error: Microsoft.Quantum.IQSharp.Workspace[0] QS5022: No identifier with the name âvâ exists. Does any one have experience of this issue please? I have googled it but to no avail. I use .NET run perfectly with example.qs and example.csproj files, but I would like to work within VSCode. (Ubuntu v. 20.04, .NET SDK v. 3.1, Python v. 3.7 + latest Miniconda)",<programming><q#>,8/21/2021 15:38,20938.0,20938.0,"When you call import qsharp, it will try to compile the .qs files in the current folder so the corresponding operations are available from Python. It seems the Q# compiler is having some problems with one of the files. Try to see if any of the .qs files in the directory have any syntax errors, and try removing the obj folder with temporary files if it exists.",8/23/2021 15:27
20978.0,Return only the measurements of a circuit,"I have written the following program in jupyter: from qiskit import * from qiskit import plot_histogram, matplotlib circuit = QuantumCircuit(16,16) #Making a circuit with 16 qubits qr = QuantumRegister(16) cr = ClassicalRegister(16) for i in range(16): circuit.h(i) circuit.measure(i,i) simulator = Aer.get_backend('qasm_simulator') result = execute(circuit, backend = simulator, shots = 200).result() counts = result.get_counts() print(counts) and the output is of the form : {'0111001100011110': 1, '0101000101101001': 1, '1100010111000100': 1, '0111111110101110': 1,..., '0110110010010110': 1} Is there any way that what I get as an output is the measurement only (e.g. '0111001100011110') without getting the times the measurement has appeared (: 1)?",<programming><qiskit><measurement>,8/26/2021 7:02,20980.0,20980.0,"You can take only the keys of the returned dictionary: measurements = set(counts.keys()) print(measurements) If you want only one random key, you can just take the first one in the set: random_key = next(iter(a)) or store all the keys in a list and take a random one from here: from random import randint measurements_list = list(measurements) random_key = measurement_list[randint(0, len(measurement_list)-1)]",8/26/2021 7:37
21001.0,Passing arrays to operations/functions in Q# Jupyter Notebooks,"In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, %simulate, and writes out the inputs as key-value pairs, key=value. For example, if I had some operation, operation HelloHardy (number : Int) : Unit {...}, then I would run the following %simulate HelloHardy number=1729. I am currently working with the operation, EvaluatePolynomial, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated. %simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false. Received invalid parameters. Please fix and try again: coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11. evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.",<programming><q#>,8/28/2021 19:51,21010.0,21010.0,"IQ# magics don't support passing arrays as parameters at the moment. When I need to pass something more complicated than a scalar, I usually define a wrapper operation that defines all parameters and calls the original operation, and call %simulate for that wrapper operation.",8/29/2021 17:56
21039.0,What is difference between qasm_simulator and ibmq_qasm_simulator?,"There are many ways how to simulate a quantum circuit on IBM Q. However, in partiuclar I am interested in a difference between qasm_simulator and ibmq_qasm_simulator. In Qiskit, the former can be called with statement processor = Aer.backends(name = 'qasm_simulator')[0] while the latter with provider = IBMQ.load_account() processor = provider.backends(name='ibmq_qasm_simulator')[0] I realized that ibmq_qasm_simulator sends jobs similarly to a real quantum processor, i.e. I see the job in Job pane in IBM Q environment. But this is not the case for qasm_simulator. In list of services on IBM Q page I found out only one qasm_simulator. So, my question is how these two simulators differ?",<programming><qiskit><ibm-q-experience><simulation>,09/01/2021 13:53,21040.0,21040.0,"ibmq_qasm_simulator performs the simulation on a classic computer on that resides on the cloud, whereas qasm_simulator does it locally on your computer and consumes your CPU.",09/01/2021 14:21
21210.0,Expected outcome of adding two PauliOp,"first of all, I would probably report this as a bug if I was confident enough in my QC abilities. As it stands, I've just started out, so I'm phrasing it as a question. From what I can tell, adding two PauliOps in this specific case does not result in the expected operator matrix: import qiskit as qk from qiskit.opflow.primitive_ops import PauliOp (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix() results in array([[0.+0.j, 1.-1.j], [1.+1.j, 0.+0.j]]) whereas the result that I would expect is the one i get when I run the following code: PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)).to_matrix() + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;)).to_matrix() Result: array([[0.+0.j, 2.+0.j], [0.+0.j, 0.+0.j]]) What further confuses me is that the deprecated version of PauliOp actually results in the expected operator. Running this code: import qiskit as qk from qiskit.aqua.operators.primitive_ops import PauliOp (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix() gives a deprecation warning and the [[0,2],[0,0]]-array that I want. Has the behaviour of the addition changed or is this a bug? In any case, how can I construct the operator that I want (in a non-deprecated way)? I'm running qiskit version 0.29.0 Thanks in advance!",<qiskit><programming>,9/15/2021 13:03,21217.0,21217.0,"You can do this instead: (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + 1j*PauliOp(qk.quantum_info.Pauli(&quot;Y&quot;))).to_matrix() which gives what you expect: array([[0.+0.j, 2.+0.j], [0.+0.j, 0.+0.j]])",9/15/2021 20:21
21419.0,Equivalent matrix for operators in qiskit,"What is eqivalent matrix to qc.rx(np.pi, 0): import numpy as np from qiskit import QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator qc = QuantumCircuit(1) qc.rx(np.pi, 0) print('Final matrix:', np.round(Operator(qc).data, 3)) I thought it is the following: $$X = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} =\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \\ \end{pmatrix} $$ but it is not, because of different result. And what would be equivalent matrices in case: qc.rx(np.pi, 0) qc.ry(np.pi, 0)",<qiskit><programming><quantum-gate><circuit-construction>,10/05/2021 14:10,21422.0,21422.0,"Qiskit defines the $RX$ gate as follows: $$ RX(\theta) = \exp\left(-i \frac{\theta}{2} X\right) = \begin{pmatrix} \cos{\frac{\theta}{2}} &amp; -i\sin{\frac{\theta}{2}} \\ -i\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}} \end{pmatrix} $$ Thus, setting $\theta = \pi$, would give us: $$ RX(\pi) = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} = -iX $$ Which is what I suspect you got as output to Operator(qc).data in the first code cell. Thus, a rotation of $\pi$ radians about the $x$-axis is equivalent to the normal bit flip gate $X$ up to a global phase of $-i$. I thought it is the following: $$X = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} =\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \\ \end{pmatrix} $$ I think you got confused about matrix multiplication here. First of all, $X$ is only $\begin{pmatrix} 0 &amp; 1 \\ 1&amp; 0 \end{pmatrix}$. I suspect you are trying to get the final state of the circuit, which would correspond to the operation you do in the middle of the above equation (up to the global phase we discussed earlier). But, remember that the product of a matrix of size $2 \times 2$ with a vector of size $2 \times 1$ is another vector of size $2 \times 1$. Thus, you can't get a matrix from this operation. The correct operation to get the final state of your circuit would be the following: $$ RX(\pi)|0\rangle = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ -i \end{pmatrix} = -i|1\rangle $$ Which is equivalent to $|1\rangle$ up to a global phase that we can ignore here since we only have one qubit. If there were more qubits, this global phase would turn into a relative phase. And what would be equivalent matrices in case: qc.rx(np.pi, 0) qc.ry(np.pi, 0) The $RY$ gate is defined as follows: $$ RY(\theta) = \exp\left(-i \frac{\theta}{2} Y\right) = \begin{pmatrix} \cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} \\ \sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}} \end{pmatrix} $$ Thus, to get the unitary corresponding to that circuit, plug in the angle to each of the gates definition and perform matrix multiplication. The operation you need to do is $RY(\pi)RX(\pi)$. And then you could get the final state of the circuit following the same steps as with the first example.",10/05/2021 19:39
21499.0,What is the syntax for general control gate in stim,"For a stabilizer code with the stabilizers in canonical form, an encoding circuit has the form that's a product of hadamard gates and general control gates : $H_i C_i(U_i)$. For example for the $[[5,1,3]]$ code, the circuit would be : $H_{2}C_{2}(Y_{1})$ $H_{3}C_{3}(X_{1})$ $H_{4}C_{4}(X_{1}Z_{2}Z_{3})$ $H_{5}C_{5}(Y_{1}Z_{2}Z_{4})$ $C_i(U_i)$ means apply $U_i$ depending on qubit $i$. The normal $CNOT_{ij}$ would be $C_i(X_j)$. $CZ_{ij}$ gate would be $C_i(Z_j)$; $U_i$ usually needs to be applied to multiple qubits. How would a circuit like this be entered into stim?",<programming><circuit-construction><stabilizer-code><stim>,10/11/2021 03:14,21501.0,21501.0,"There currently isn't a controlled Pauli product gate in Stim. You have to decompose it into a series of CX, CY, and CZ gates. # Apply X1*Y2*Z3 controlled by qubit 0 CX 0 1 CY 0 2 CZ 0 3 # Apply X1*Y2*Z3 if latest measurement result was True CX rec[-1] 1 CY rec[-1] 2 CZ rec[-1] 3",10/11/2021 07:10
21779.0,"How can I initialize a state like, $|00\rangle$ or $|01\rangle$ or $|10\rangle$ or $|11\rangle$ in Qiskit?","Many thanks in advance for your help. I am a beginner in Qiskit. I want to implement a circuit that uses the position of an element/item, of the form (x,y) and I would like to represent it as a state $|\phi\rangle = |xy\rangle$. How can I initialize a state like, $|00\rangle$ or $|01\rangle$ or $|10\rangle$ or $|11\rangle$? Or how could I apply the tensor product to get it?",<qiskit><programming><quantum-gate><quantum-state>,11/03/2021 02:41,21781.0,21781.0,"Here is Qiskit code you wanted: from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister q = QuantumRegister(2) c = ClassicalRegister(2) #state |00&gt; circ00 = QuantumCircuit(q,c) circ00.draw() #do nothing, both qubits are already in state |0&gt; #state |01&gt; circ01 = QuantumCircuit(q,c) circ01.x(q[1]) circ01.draw() #state |10&gt; circ10 = QuantumCircuit(q,c) circ10.x(q[0]) circ10.draw() #state |11&gt; circ11 = QuantumCircuit(q,c) circ11.x(q[0]) circ11.x(q[1]) circ11.draw() State you want to prepare are so-called basis states in computational basis. You can easily prepare them with $X$ gate (i.e. equivalent of NOT in classical computation). Initially, qubits are in state $|0\rangle$. If you want to change one of them to state $|1\rangle$, simply put on that qubit the $X$ gate. Please run the code per partes to see how circuits differ for each of the basis states. In Qiskit, you can also use function initialize. It uses vector representation of states, which are in your case: $|00\rangle = \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}^T$ $|01\rangle = \begin{pmatrix}0 &amp; 1 &amp; 0 &amp; 0\end{pmatrix}^T$ $|10\rangle = \begin{pmatrix}0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}^T$ $|11\rangle = \begin{pmatrix}0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}^T$ So, the Qiskit code is following from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister, execute import numpy as np import numpy as np q = QuantumRegister(2) c = ClassicalRegister(2) circ = QuantumCircuit(q,c) #state = np.array([1,0,0,0]) #00 #state = np.array([0,1,0,0]) #01 #state = np.array([0,0,1,0]) #10 state = np.array([0,0,0,1]) #11 circ.initialize(state) circ.measure(q,c) processor = Aer.backends(name='qasm_simulator')[0] #simulator res = execute(circ, processor, shots = 1).result().get_counts(circ) print(res)",11/03/2021 09:36
21964.0,Stim: is it possible to add comments when creating a circuit?,"I'm trying to create a Stim.Circuit, given a list of qubits and operations on them. Does the API support adding comments to the circuit's string representation? I've tried using circuit.append_from_stim_program_text('# Some comment'), but such comments never appear when I later call print(repr(circuit)), so I presume this method only cares about appending actual circuit instructions. Any help / workarounds appreciated!",<programming><stim>,11/17/2021 10:59,21965.0,21965.0,"No, the python API doesn't support adding comments. Neither does the underlying C++ API, actually. Comments are completely discarded by the parser, and the circuit struct has no fields for storing them or related concepts such as whitespace. This is unlikely to change because such things tend to involve performance sacrifices (eg. additional memory allocations to store the comments during parsing or additional branches to deal with a more complex circuit struct during simulation). (Similar performance-driven limitations are that operation names get canonicalized and adjacent operations get fused. For example, parsing &quot;SQRT_Z 0\nSQRT_Z 1&quot; then printing it gives you &quot;S 0 1&quot;.) If you need to output a circuit that contains comments, you'll have to track the comments for yourself. For example, you could keep a dictionary mapping instruction indices to strings and then print the circuit instruction-by-instruction while appending comments from the dictionary: from typing import Dict import stim def print_commented_circuit(circuit: stim.Circuit, line_comments: Dict[int, str]): for i, instruction in enumerate(circuit): line = str(instruction) if i in line_comments: line += &quot; # &quot; + line_comments[i] print(line) print_commented_circuit( circuit=stim.Circuit(&quot;&quot;&quot; H 0 CX 0 1 M 0 1 &quot;&quot;&quot;), line_comments = { 1: &quot;entangle&quot;, }, ) Which outputs: H 0 CX 0 1 # entangle M 0 1",11/17/2021 12:18
22065.0,Openfermion state transformation from Bravyi-Kitaev basis to occupation number,"I'm working in the Bravyi-Kitaev basis implemented by the openfermion.bravyi_kitaev() function to find the ground state of a fermionic operator in the BK representation. Now I want to convert this ground state from the BK basis to the occupation number basis. I couldn't find any functions implementing this, and the transformation matrix shown in arXiv:1208.5986 is not the correct one. Has anyone managed to find a transform between these two bases?",<programming><cirq><openfermion>,11/25/2021 17:10,22134.0,22134.0,"I managed to solve the problem: The matrix $\beta$ that transforms a binary string from the occupation number basis to the Bravyi-Kitaev basis, introduced in arXiv:1208.5986 in eq. (23), is the correct matrix. For qubit states in cirq the ordering of the qubits has to be reversed, while qubit states in Qiskit can be transformed directly.",11/30/2021 10:03
22281.0,Simulating flag qubits and conditional branches using Stim,"In a quantum error correcting code using flag qubits, it's common to have flag measurements that tell you it's necessary to do some extra measurements for safety. So, for example, I want to say: if measurement_result_was_true: do_a_different_measurement How do I do this in Stim? There doesn't seem to be an if. (This was a question I received by email. Moving it here for posterity.)",<programming><error-correction><stim>,12/14/2021 21:51,22282.0,22282.0,"This is definitely a place where you'll struggle to use Stim. It's possible but it's not nice. It could still be worth your time just because you don't have to eg. manually write code to turn a circuit into a matching graph, but it'll be more tedious than branchless code. Part 1: Simulating The easiest thing to do is to use stim.TableauSimulator. It gives you the ability to apply operations one by one driven by python code, which is more than flexible enough to do what you need. Here is python code showing the general idea: import stim simulator = stim.TableauSimulator() # Run first part of circuit. simulator.do(stim.Circuit(&quot;&quot;&quot; H 0 CNOT 0 1 M 0 &quot;&quot;&quot;)) # Do something depending on the measurement result. latest_measurement_result = simulator.current_measurement_record()[-1] if latest_measurement_result: simulator.do(stim.Circuit(&quot;&quot;&quot; # ... &quot;&quot;&quot;)) # Run the rest of the circuit. simulator.do(stim.Circuit(&quot;&quot;&quot; # ... &quot;&quot;&quot;)) shot = simulator.current_measurement_record() The reason Stim doesn't support branching in its circuit format is because branches break an algorithmic optimization where the tableau simulator is only used once for a reference sample, and then stim switches to using much faster error frame simulation. Consequently, you will find that getting thousands of samples by repeatedly using stim.TableauSimulator is easily 100x slower than using circuit.compile_sampler().sample(shots). Hopefully it's still fast enough for your needs. If you have less than 10 branches, a possible alternative would be to run simulations for each possible case and then postselect out the inconsistent ones where the hardcoded branch disagreed with the measurement result deciding whether or not it was taken. The performance difference can be large enough to overcome the losses from the postselections. Part 2: Correcting I'm assuming you're using PyMatching. For each shot, you need to build the circuit that was actually run. This circuit will give you access to a detector error model (circuit.detector_error_model(decompose_errors=True)) and the ability to convert the measurement results into detection events (circuit.compile_m2d_converter().convert(shot, append_observables=True)). Convert the measurements into detection events + observable frame changes, and then run pymatching on the detector data, configured with the circuit's detector error model, and check whether or not it predicted the observable frame data. If you only have a few possible cases, you will get a large benefit from grouping shots that took the same paths together. If you have a lot of possible cases, so that each case is hit less than 3 times on average, grouping isn't worth it. It's likely that error model extraction will be your main bottleneck here. Stim is pretty quick at this, it takes it a third of a second or so to analyze the error model of a distance 25 surface code, but a third of a second per sample is awful. I intend for this use case to get better in the future, but haven't got any concrete designs I'm happy with yet.",12/14/2021 21:51
23353.0,How to order results after multi-circuit qiskit.execute parallel run?,"I'm kinda new to qiskit and I find really fascinating its parallelization capabilities, then I'm trying to creating all the needed circuits for my application at once and transpile, assemble and execute them all at once using the execute method. Basically, qcircuits = [] # construct my circuits and append to qcircuits # ... backend: backend: BaseBackend = qiskit.Aer.get_backend('qasm_simulator') n_shots = 1024 job = qiskit.execute( qcircuits, backend, optimization_level=optimization_level, shots=n_shots ) counts = job.result().get_counts() Nevertheless, I noticed that the job.result().get_couts() output is not deterministic as, I guess, it runs all the circuits using a parallel_map and appends in the returned list in the order they finish. Is there any way to force the execute method respecting the order of qcircuits ? If it is not the case, is there any way to label the execution results so that I can sort them myself afterwards ? Thanks in advance.",<qiskit><programming><simulation><quantum-parallelism>,12/21/2021 13:25,23382.0,23382.0,"Each qiskit.QuantumCircuit has a name attribute that is also accessible through each qiskit.result.Result. So, you can do the following to match the circuits to the measurement counts after running in parallel: for circuit in qcircuits: print(circuit.name) result_dict = jobs.result().to_dict()[&quot;results&quot;] result_counts = jobs.result().get_counts() for i in range(len(qcircuits)): name = result_dict[i][&quot;header&quot;][&quot;name&quot;] counts = result_counts[i] print(f&quot;{name}: {counts}&quot;) Before running your circuits, you could also assign your own descriptive names, e.g. for i in range(len(qcircuits)): qcircuits[i].name = &quot;mycircuit&quot;+str(i) Edit: Combining the ideas above to show how to order the results: # number input circuits in ascending order for i in range(len(qcircuits)): qcircuits[i].name = &quot;circuit_&quot;+str(i) job = qiskit.execute(qcircuits, backend, ...) result_dict = job.result().to_dict()[&quot;results&quot;] result_counts = job.result().get_counts() # initialize list to store ordered results results_ordered = [None] * len(qcircuits) for i in range(len(qcircuits)): name = result_dict[i][&quot;header&quot;][&quot;name&quot;] n = int(name.split('_')[1]) # index of circuit in input list results_ordered[n] = result_counts[i] # add to result list at same index",12/22/2021 20:48
23504.0,"Given this code fragment, what is the probability that a measurement would result in $|0\rangle$?","Trying to understand below probability how it occured? qc = QuantumCircuit(1) qc.ry(3 * math.pi/4, 0) A. 0.8536 B. 0.5 C. 0.1464 D. 1.0 And the answer is C. But I can't understand the calculation behind it. Can someone please explain?",<qiskit><programming><quantum-state><ibm-q-experience><textbook-and-exercises>,12/31/2021 10:55,23505.0,23505.0,"We have, $$\begin{align}\begin{aligned}\newcommand{\th}{\frac{\theta}{2}}\\\begin{split}Ry(\theta) = \exp\Big(-i \th Y\Big) = \begin{pmatrix} \cos{\th} &amp; -\sin{\th} \\ \sin{\th} &amp; \cos{\th} \end{pmatrix}\end{split}\end{aligned}\end{align}$$ If the input state is $|0\rangle$, then the probability of getting $|0\rangle$ as a measurement result is the square of the absolute value of the entry in the first row and first column. That is, $\cos^2\big({\th}\big)$. Now, $\theta = 3 \pi/4$, so the probability equals $\cos^2(3 \pi/8) = 0.1464$.",12/31/2021 12:43
23528.0,Quantum Phase Estimation - Should be getting exact answer,"Having read the Qiskit demonstration in the Qiskit textbook on how to implement Quantum Phase Estimation, I tried to do so on PennyLane's framework. My code pretty well follows what was done in Qiskit, with a few nuances according to PennyLane, but when I run it over many shots, I get varying answers. For reference, I was implementing the T-Gate (exactly what is done in Qiskit textbook). While my code yields varying possibilities, Qiskit's strictly obtains 001 (which, through post-processing, shows that the applied phase was 1/8). Perhaps there is something wrong with the program I wrote? Is the code supposed to always yield 001? dev = qml.device('default.qubit', wires = 4, shots=1) @qml.qnode(dev) def circuit(): qml.PauliX(wires = 3) for qubit in range(3): qml.Hadamard(qubit) def t_gate(j): qml.T(wires = j) repetitions = 1 n = len(dev.wires) - 1 for x in range(n-1, -1, -1): for i in range(repetitions): qml.ctrl(t_gate, control = x)(3) repetitions *= 2 def ops1(wires = [0, 2]): qml.templates.QFT(wires = [0, 2]) qml.adjoint(ops1)(wires = [0, 2]) return qml.sample() fig, ax = qml.draw_mpl(circuit)() fig.show() for i in range(0, 10): print(circuit()) Results: [0 0 1 1] [0 1 1 1] [1 1 1 1] [0 1 1 1] [1 1 1 1] [0 0 1 1] [1 0 1 1] [0 0 1 1] [0 0 1 1] [0 0 1 1]",<programming><pennylane>,01/02/2022 23:43,23544.0,23544.0,"Your circuit is very close, with only minor modifications needed to match the result from the Qiskit textbook. The counting registers are the first three wires of the circuit; so we need to apply the inverse QFT to wires 0, 1, and 2. Similarly, we want to measure samples only from wires 0, 1, and 2. Here is an updated version of your code with these two changes: import pennylane as qml import numpy as np dev = qml.device(&quot;default.qubit&quot;, wires=4, shots=10) @qml.qnode(dev) def circuit(): qml.PauliX(wires=3) for qubit in range(3): qml.Hadamard(wires=qubit) repetitions = 1 for x in range(2, -1, -1): for i in range(repetitions): qml.ControlledPhaseShift(np.pi / 4, wires=[x, 3]) repetitions *= 2 qml.adjoint(qml.QFT)(wires=[0, 1, 2]) return qml.sample(wires=[0, 1, 2]) print(qml.draw(circuit)()) print(circuit()) This gives the results: 0: ââHâââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­QFTâ»Â¹âââ­â¤ Sample[basis] 1: ââHâââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââQFTâ»Â¹ââââ¤ Sample[basis] 2: ââHâââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ°QFTâ»Â¹âââ°â¤ Sample[basis] 3: ââXâââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)ââââââââââââ¤ [[0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1]] matching the expected result from applying phase estimation. Note that I also made some other minor modifications: Rather than looping over the QNode executions, if you set shots=N in the device, you will get a somewhat significant speed boost! While qml.ctrl(qml.T, control=x)(wires=x) works, I have slightly modified this to use qml.ControlledPhaseShift, simply because it prints out slightly nicer in the circuit drawer qml.T and qml.QFT are directly callables, so they can be passed directly to qml.ctrl and qml.adjoint, no need to wrap them in functions :)",01/04/2022 07:27
24391.0,Is there any reasonably efficient way of performing qudit circuit simulations using Stim?,"Is there any reasonably efficient way of performing qudit circuit simulations using Stim? If so, then how much worse would the computational complexity scale?",<programming><error-correction><stim>,03/06/2022 12:21,24451.0,24451.0,"Stim only speaks qubits, not qudits. All of the supported gates are qubit gates, and all of the internal data structures are for specifically the qubit case. There are no plans to add native support for qudits to stim. (So if it's possible it will take the form of mapping qudit stabilizer circuits into qubit stabilizer circuits.)",03/09/2022 15:35
26097.0,Generating a random 16-digits in a superposition state using Qiskit,"Im trying to create a script using Qiskit for a days but somehow i couldn't seem to get it done!! Im new to QuantumComputing, so pardon me if i don't explain something properly. I need to create a simple script generating perfectly a random 16-digits (e. g 1548796654421354) in a superposition state using Hadamard gate (i think it requires 128 qubits i guess) and measuring them into a classical bits and printing the results different each time. (eg output: 5698744565414654) Thank you King.",<qiskit><programming><quantum-gate><quantum-state><algorithm>,4/22/2022 5:51,26101.0,26101.0,"You need $\lceil d\log_2(10)\rceil$ qubits to store a $d$ decimal digits number. So you can generate a superposition state of binary representation of a 16 decimal digits number using the following circuit: from qiskit import QuantumRegister, QuantumCircuit, Aer import numpy as np num_of_decimal_digits = 16 num_of_qubits = int(np.ceil(num_of_decimal_digits * np.log2(10))) qr = QuantumRegister(num_of_qubits, 'q') circ = QuantumCircuit(num_of_qubits) circ.h(qr) circ.measure_all() And to get the number: simulator = Aer.get_backend('qasm_simulator') result = simulator.run(circ, shots = 1).result() counts = result.get_counts() bitstring = next(iter(counts)) decimal = int(bitstring, 2) print('Binary:', bitstring) print('Decimal:', f'{decimal:016d}') Note: You need all these qubits to have a superposition. If you just want to generate a random 16-digits number, you can use a single qubit and run the circuit repeatedly (by setting shots = number of bits) then append the result bits.",4/22/2022 8:15
26241.0,Qiskit compute mean expectation value,"I want to calculate the mean expectation value of an PauliSumOp within qiskit after I executed a QAOA Circuit. My approach is the following: # Run and get counts job=qiskit.execute(circuit,backend=simulator,shots=shots,optimization_level=0) result = job.result().get_counts() # Compute average expectation value of the observable H Ising max_count=0 value=0 for string,count in result.items(): value+=count*sum([(~StateFn(string)@ op @ StateFn(string)).eval() for op in hamiltonian]) max_count+=count expectation=value/max_count Is this correct? I am especially concerned if StateFn(Bitstring) is a valid usage of qiskit in terms of StateFn(&quot;0101&quot;)=$|0101\rangle$",<qiskit><programming><qaoa>,05/02/2022 10:15,26344.0,26344.0,"Yes, StateFn(Bitstring) is a valid usage of qiskit in terms of StateFn(&quot;0101&quot;)=$\left|0101\right\rangle$. As an example: &gt;&gt;&gt; from qiskit.opflow import Plus, StateFn &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; print(Plus.to_circuit()) âââââ q_0: â¤ H â âââââ &gt;&gt;&gt; v_zero_one = (StateFn(&quot;0&quot;) + StateFn(&quot;1&quot;)) / np.sqrt(2) &gt;&gt;&gt; print(v_zero_one) DictStateFn({'0': 1.0, '1': 1.0}) * 0.7071067811865475 &gt;&gt;&gt; np.allclose(Plus.to_matrix(), v_zero_one.to_matrix()) True And yes, to me, the rest of your code looks correct for hamiltonian of type PauliSumOp.",05/10/2022 15:33
26377.0,Iterative quantum phase estimation - real device,"I'm trying to implement the iterative quantum phase estimation on a real (IBM) quantum computer. I'm using the code below. When I run this code on a simulator the results are the expected ones, but when running on a real device the results don't follow any pattern. import matplotlib.pyplot as plt # QML from pennylane import numpy as np from qiskit import * from qiskit.visualization import plot_histogram from qiskit.tools.monitor import job_monitor shots=32000 # Key with the maximum probability - maior in Portuguese def maior(dic): m=list(dic)[0] for n in list(dic): if dic[n]&gt;dic[m]: m=n return m from key import tok from qiskit import IBMQ #2 IBMQ.save_account(tok, overwrite=True) IBMQ.load_account() provider =IBMQ.get_provider(hub='ibm-q-minho', group='academicprojects', project='quantalab') backend = provider.get_backend('ibmq_toronto') #4 # ## Iterative Quantum Phase Estimation Algorithm def get_circuit_phase(t, QC, clbits, qubits, ancilla, backend=None, ): mycircuit=QuantumCircuit(2) mycircuit.cx(0,1) mycircuit.rx(2*t,0) mycircuit.rz(2*t,1) mycircuit.cx(0,1) mycircuit.cy(0,1) mycircuit.ry(2*t,0) mycircuit.cy(0,1) #print(mycircuit.draw()) # Circuit -&gt; controlled gate CU=mycircuit.to_gate().control(1) res = [] # start with the iteration phase = -2 * np.pi factor = 0 iterations = 3 # generate the qubit list on which the Unitary is applied qargs = [ancilla] for q in qubits: qargs.append(q) exponent = 2 ** (iterations - 1) for it in range(iterations): # start QC.reset(ancilla) QC.h(ancilla) # add the inverse rotation inv_phase = phase * factor QC.p(inv_phase, ancilla) # add the controlled Unitary of iteration it # need to add exponential amount of matrices for _ in range(int(exponent)): QC = QC.compose(CU, qubits=qargs) exponent /= 2 # add H gate QC.h(ancilla) QC.measure(ancilla, clbits[it]) if backend == None: # simulating backend=Aer.get_backend(&quot;qasm_simulator&quot;) t_qpe = transpile(QC, backend,optimization_level=3) job = backend.run(t_qpe, shots=shots) job_monitor(job) counts = job.result().get_counts(QC) # mai is the key with the most probability. mai=maior(counts) # Save the bit res.append(int(mai[3-it-1])) # if bit measured is 1 if mai[3-it-1] == &quot;1&quot;: factor += 1 / 2 # add the phase factor factor = factor / 2 # shift each towards one weight right # phase has now been stored in the clbits # returning its binary representation # need to reverse as LSB is stored at the zeroth index and # not the last res = res[::-1] # find decimal phase dec = 0 weight = 1 / 2 for k in res: dec += (weight) * k weight /= 2 return dec for estado in [-1,1]: tau=[] phase=[] for t in range(0,30,1): nq = 3 # number of qubits m = 3 # number of classical bits q = QuantumRegister(nq,'q') c = ClassicalRegister(m,'c') qc = QuantumCircuit(q,c) qc.h(0) qc.initialize(params=[0, 1/np.sqrt(2),estado*1/np.sqrt(2), 0],qubits=[1,2]) t=t/5 tau.append(t) x=get_circuit_phase(t, QC=qc, clbits=[0,1,2], qubits=[1,2], ancilla=[0], backend=backend ) phase.append(x) if estado==-1: plt.plot(tau,phase,label=&quot;- state&quot;) if estado==1: plt.plot(tau,phase,label=&quot;+ state&quot;) plt.xlabel(&quot;$tau$&quot;) plt.ylabel(&quot;$theta$&quot;) plt.legend() plt.show() I hope anyone can help with this issue, my sincere thanks, Gabriela Oliveira.",<programming><algorithm><ibm-q-experience><ibm>,5/13/2022 8:32,26426.0,26426.0,"Dynamic circuit capabilities (eg., circuits with control flow) are not yet supported by production IBM hardware. These capabilities will be coming later in 2022 to select devices as per the IBM Quantum Roadmap. For now, you must use a simulator.",5/16/2022 11:55
26591.0,Applying an S gate on which two states leaves the state unchanged,I was going through a guide given by my friend and it had this MCQ which I couldn't get the answer to. Applying an S gate on which two states leaves the state unchanged? |0 &gt; |+ &gt; |1 &gt; |- &gt; |â³ &gt;,<programming><quantum-gate><quantum-state>,5/27/2022 7:46,26592.0,26592.0,"You've got two options: just try applying $S$ to each of the states to see what happens. For example $S|+\rangle=(|0\rangle+i|1\rangle)/\sqrt{2}$, so the $|+\rangle$ state does change. note that you're effective asked to find the eigenvectors of $S$. So write it in matrix form. The only thing you have to be careful of is the sense in which I'm guessing &quot;doesn't change&quot; is meant here. Remember that global phases are irrelevant to quantum states, so one might consider $$ S|1\rangle=i|1\rangle\equiv|1\rangle $$ as being unchanged.",5/27/2022 8:07
27049.0,Why does having two classical registers sometimes only yeild one bit?,"I was running some qiskit code on qasm_simulator to test something and I realized that, when I have two separate classical registers, sometimes only one bit is generated, and I'm trying to understand why? If you have two meaurements, but send them to only one classical register, the second one overwrites the first in the final output. I would expect that if you have two seperate classical registers, both with be displayed in the output but that doesnt always seems to be the case? Fore example here is some simple code that demonstrates this: #Sending two measurements to one classical register yeilds only outputs of one bit. circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) job = execute(circuit, backend, shots=8192, memory=True) output=[] result_list=job.result().get_memory() for entry in result_list: output.append(int(entry)) print(output) &gt;&gt;&gt; [1, 1, 1, 0, 1, 1, 0, 0, 0,...] #Sending two measurements to two different classical register sometimes yeild two bits and sometimes yeilds one. circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[1]) job = execute(circuit, backend, shots=8192, memory=True) output=[] result_list=job.result().get_memory() for entry in result_list: output.append(int(entry)) print(output) &gt;&gt;&gt; [0, 10, 11, 11, 11, 10, 10, 1, 11, 11, 10, 11, 0, 11, 1, 10, 0, 11, 0, 10, 10, 1,...]",<measurement><classical-computing>,6/24/2022 14:37,27051.0,27051.0,"This happens because your convert the bit-strings to integers. output.append(int(entry)) Hence, the leading zeros are removed. If you want to keep the bit-string as it is, don't convert it: print(job.result().get_memory())",6/24/2022 16:12
27757.0,Partial Measurement in AWS Braket,"Is there a way to do partial Measurement in AWS Braket? Basically, if I have a circuit with $N$ qubits, can I measure only $n$ qubits out of them with the result type &quot;expectation&quot;?",<programming><amazon-braket>,08/12/2022 20:39,27759.0,27759.0,"Physically, there is currently no way to perform a partial measurement (on hardware in particular, all qubits are measured); you'll have to slice out the unwanted qubits if you're using raw measurements directly. As for result types, you can definitely measure the expectation of an observable on only a subset of qubits: from braket.circuits import Circuit, observables from braket.devices import LocalSimulator dev = LocalSimulator() circ = Circuit().h(0).cnot(0, 1).cnot(1, 2).expectation(observables.Z() @ observables.Z(), [0, 2]) dev.run(circ).result().values [1.0]",08/12/2022 23:04
27867.0,Qiskit: Can I run real experiments in QPUs with OOP structured code?,"The question might be naive, but I'm hesitant to design my algorithm in a complex, Object-Oriented scheme (custom classes, objects etc.). My fear is that current frameworks (e.g. ibmq, qiskit-runtime) don't support it. Is this the case? Can I verify/reject this?",<qiskit><programming><ibm-q-experience><python>,8/20/2022 11:01,27874.0,27874.0,"You can consider Qiskit as a classical interface between QPU and classical computer. You use classical programming language to prepare quantum circuit. Before sending the circuit to QPU you are still in classical world and you can do anything Python allows - use all other Python libraries, connect to SQL databases or other data sources etc. Even if you call already prepared algorithms from Qiskit libraries you do so classically. Once you call procedure for running the computation on QPU, your algorithm is transpiled to native quantum gates of particular QPU. This is also classical process. Only after that (again classical) electronic set up QPU and run the algorithm in quantum world. After measurement, you receive classical data and you can post-process them in Qiskit, again classically. To sum up, you can use any programming paradigm supported by Python. From your point of view, everything is done classically and QPU is just a device controlled by your classical program using Qiskit libraries.",8/21/2022 6:40
28366.0,Expectation values of non-local operators in Qiskit,"Is there a convenient way in Qiskit to calculate the expectation value for a non-local operator, i.e. I would like to calculate: $$ \langle \Psi|O|\Psi \rangle $$ More precisely, I would like to calculate the expectation value for an Operator that can be described by the following circuit: operator_circ = QuantumCircuit(4) operator_circ.x(0) operator_circ.cz([1, 1, 2], [2, 3, 3]) I am currently doing the following to calculate the expectation value: operator = Operator(operator_circ) #Where psi is some quantumstate/quantumcircuit psi.save_expectation_value(operator, range(4)) But I am afraid, that this is not what I want since when I look into the decomposition of the Operator it consists of some multiplexers that in turn consists of $CCX$ gates and a gate called squ_dg. However, what I would like is to calculate the expectation value w.r.t. the decomposition of the operator circuit into summed weighted local Pauli. Ideally some function expresses the $CZ$ gate like so: $$ CZ_{12} = \frac{1}{2} (I_1 \otimes I_2 + I_1 \otimes Z_2 + Z_1 \otimes I_2 - Z_1 \otimes Z_2) $$ and then calculates the expectation value over the sums of weighted Paulis on the right hand side. Or is it the same as just using the afformentioned code? What would be the best practice in Qiskit in this case?",<qiskit><programming><quantum-state><pauli-gates><non-locality>,10/01/2022 14:52,28374.0,28374.0,"Looking deeper into the source code I found out that any Operator always gets internally transformed into a SparsePauliOp, i.e. a representation of weighted (sparse) Paulis which is exactly what I wanted.",10/02/2022 14:31
29784.0,How to check a given unitary evolution is correct in a real quantum computer in Qiskit?,"For a given unitary, I want to know whether this unitary gate is correctly evolved in the circuit. In the simulator, I can use &quot;statevector&quot; to get the state vector to check the correctness of the evolution. But I don't know whether such a unitary can still evolve correctly on a real quantum computer. Is there a corresponding way to check its correctness? In more detail, I give a Hamiltonian H, then I get unitary U=expm(-1t*H). Then I add this unitary gate to the circuit usingqc.unitary(U, [0,1]). So how can I check whether it evolves correctly in the real quantum computer?",<qiskit><programming><quantum-gate><quantum-state><unitarity>,1/20/2023 10:24,29785.0,29785.0,"There is no way to get a &quot;perfectly correct&quot; state evolution on a real quantum computer since the hardware is affected by different types of noise (e.g. coherent gate error, state decoherence, etc.) and it is not error-corrected. What you can do is to first run your quantum circuit implementing the unitary $U$ on a perfect simulator, in order to check it is doing what it is supposed to do, and then set it up to run on your real device. In this case, you can be pretty sure that the deviation between the simulation and the actual execution is due to noise effects only.",1/20/2023 10:58
29964.0,"Generating random, but non-uniform state","I would like an algorithm that generates a random state, sampled according to some probability distribution which is not uniform in Hilbert space. Assume though that I have at my disposal a uniform (i.e. Haar) random state generator. How do I do that? For concreteness consider the case of a single qubit. Then a Haar random state is a point on the Bloch sphere which is distributed according to the Haar measure $d\psi$ on the sphere. One way to generate such states on a computer is to create a column vector with real and imaginary parts i.i.d. according to $\mathcal{N}(0,1)$, then normalize it. This method generalizes to multiple qubits. But suppose I want to generate states sampled not according to $d\psi$, but according to $$ p( \psi) d\psi = 2 \langle \psi|0\rangle \langle 0|\psi \rangle d\psi, $$ where $|0\rangle$ is the state corresponding to the North Pole on the Bloch sphere. One can check that $p(\psi) \geq 0$ and $\int d\psi p(\psi) = 1$ so $p(\psi$) is a valid probability density function. This distribution, is such that states near the North Pole occur more likely than states near the South Pole. How would I write a simple program to do this? Note: this is similar to the standard case of real numbers where if we have a uniform r.n.g. in $[0,1]$ we can use this to generate random numbers sampled from any other arbitrary distribution on the real line, e.g. using Box-Muller, inverse transform, ziggurat, rejection sampling. Presumably some variant of the above methods generalizes, but since the sample space is different I am finding it difficult to think about it.",<programming><probability><haar-distribution>,02/01/2023 00:58,29969.0,29969.0,"Rejection sampling is a good fit and works without any changes, simply by plugging the desired distribution $p(\psi)$ into the standard algorithm. Let$^1$ $M:=\max_{\psi\in\mathbb{CP}^1} p(\psi)$. To sample a pure state $\psi$ from the distribution specified by $p(\psi)$, do the following: Sample a pure state $\psi$ from the Haar distribution. Sample a real number $x$ from the uniform distribution over $[0,M]$. If $x&gt;p(\psi)$, go back to 1. Return $\psi$. This works for the same reason any rejection sampling works. Essentially, we are sampling uniformly distributed points $(\psi,x)$ from $\mathbb{CP}^1\times[0,M]$, throwing away the points that are &quot;above the plot of $p(\psi)$&quot; and keeping the ones &quot;below it&quot;. $^1$ The maximum exists, because Bloch sphere $\mathbb{CP}^1$ is compact and $p(\psi)$ is continuous.",02/01/2023 08:16
30109.0,Is it possible to automatically rename a job at submission time?,"I would like to find out if there is some way to rename a job automatically, either when the job is first sent to the queue, or later after the fact. I've tried searching through the forum and the documentation to try and find a solution, but nothing that seems to do the trick. The closest I have found is the qobj_id parameter, however, this is depreciated and no longer functions. Edit: I finally found a (frustratingly easy) solution, see my answer below",<qiskit><programming>,02/07/2023 20:26,30153.0,30153.0,"I finally managed to find a solution. It actually ended up being so simple, that I think the only way that I had missed it was that I was looking for a solution within backend.run() or execute() and not the job object itself. The solution uses the job.update_name() method and here is a simple implementation of it. backend = provider.get_backend('ibm_nairobi') qreg_q = QuantumRegister(1, 'q') creg_c = ClassicalRegister(1, 'c') circuit = QuantumCircuit(qreg_q, creg_c) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) job = execute(circuit, backend, shots=8192, memory=True) job.update_name('test_name') #the new job will have the name &quot;test_name&quot;",02/10/2023 20:48
30279.0,A quantum circuit to find if 4 given sides can form a rectangle,"I wrote this code that uses a swap test to find if 2 pairs of sides are equal. First, amplitude encoding the 4 sides on 3 qubits then performing the swap test. I'm not sure where my logic went faulty, especially that I'm not very familiar with the logic of swap test yet. Here is the code import math def is_rectangle(A: int, B: int, C: int, D: int) -&gt; int: # Define quantum circuit with 3 qubits and 1 classical bit qr = QuantumRegister(3) cr = ClassicalRegister(1) qc = QuantumCircuit(qr, cr) # Encode the input integers into the state of the first 2 qubits using amplitude encoding alpha = math.acos(math.sqrt(A/float(A**2 + B**2))) beta = math.acos(math.sqrt(B/float(A**2 + B**2))) qc.ry(2*alpha, qr[0]) qc.ry(2*beta, qr[1]) gamma = math.acos(math.sqrt(C/float(C**2 + D**2))) delta = math.acos(math.sqrt(D/float(C**2 + D**2))) qc.ry(2*gamma, qr[2]) qc.ry(2*delta, qr[1]) # Apply a series of SWAP gates to create the entangled state needed for the swap test qc.cx(qr[1], qr[2]) qc.cx(qr[0], qr[1]) qc.cx(qr[1], qr[2]) qc.cx(qr[0], qr[1]) qc.cx(qr[1], qr[2]) # Apply the swap test to determine if the input integers satisfy any of the conditions qc.h(qr[2]) qc.cx(qr[2], qr[1]) qc.h(qr[2]) # Measure the third qubit and return the measurement result as the output of the function qc.measure(qr[2], cr[0]) # Run the quantum circuit using the Qiskit simulator simulator = Aer.get_backend('qasm_simulator') result = execute(qc, simulator, shots=1).result() counts = result.get_counts() if '1' in counts: return 1 else: return 0```",<qiskit><quantum-gate><programming><algorithm><quantum-circuit>,2/19/2023 10:00,30289.0,30289.0,"I think you may want to change a few things. I've coded up the experiment like this (which should be easy to port to Qiskit and/or use it to correct your circuit): First - the function signature, the hopefully identical sides should be a1 and a2, as well a b1 and b2. For experimentation, use values in the range of 0.0 - 1.0: def run_experiment(a1: np.complexfloating, a2: np.complexfloating, b1: np.complexfloating, b2: np.complexfloating) -&gt; float: &quot;&quot;&quot;Construct swap test circuit and measure.&quot;&quot;&quot; # The swap circuit is quite simple: # # |0&gt; --- H --- o --- H --- Measure # | # a1 --------- x --------- # | # a2 ----------x --------- Create a circuit and a few registers, 1 register for each side (I use 2 registers of size 2 below) as well as 2 ancillas: qc = circuit.qc() ab = qc.reg(2, 0) cd = qc.reg(2, 0) anc = qc.reg(2, 0) Now encode the length into rotations on each of the 4 qubits corresponding to the 4 sides: qc.ry(ab[0], 2 * np.arcsin(a1)) qc.ry(ab[1], 2 * np.arcsin(a2)) qc.ry(cd[0], 2 * np.arcsin(b1)) qc.ry(cd[1], 2 * np.arcsin(b2)) Now, 2 swap tests (from anc[0] and anc[1] to the qubits corresponding to the sides, bracketed by Hadamards: qc.h(anc) qc.cswap(anc[0], ab[0], ab[1]) qc.cswap(anc[1], cd[0], cd[1]) qc.h(anc) Now - measurement. In my infra I can just get the probabilities of the ancillas. If the sides were identical, the corresponding probability will be 1.0. If the sides were, for example, maximally different as 0.0 and 1.0, the probability would be 0.5: p0_ab, _ = ops.Measure(qc.psi, anc[0], 0, collapse=False) p0_cd, _ = ops.Measure(qc.psi, anc[1], 0, collapse=False) print(f'a1: {a1:.3f} a1: {a2:.3f} b1: {b1:.3f} b2: {b2:.3f}') print(f'p0_ab: {p0_ab:.2f} p0_cd: {p0_cd:.2f} ') And to test: def main(argv): if len(argv) &gt; 1: raise app.UsageError('Too many command-line arguments.') run_experiment(1.0, 1.0, 0.5, 0.5) &gt;&gt; a1: 1.000 a1: 1.000 b1: 0.500 b2: 0.500 p0_ab: 1.00 p0_cd: 1.00 Or run_experiment(0.5, 0.6, 0.2, 0.6) &gt;&gt; a1: 0.500 a1: 0.600 b1: 0.200 b2: 0.600 p0_ab: 0.99 p0_cd: 0.91 ```",2/20/2023 4:52
32505.0,pytket compiler pass to shorten all angles by multiples of 2 pi,"After applying some compiler passes in pytket, I get gates like rx(3.5*pi). Is there a pass that simply shortens the angles by multiples of 2 pi, so that I get rx(1.5*pi) instead?",<programming><pytket>,05/09/2023 13:42,32533.0,32533.0,"Based on Callums feedback I wrote a function for a CustomPass. def shorten_rotations(circ: Circuit) -&gt; Circuit: circ_prime = Circuit(circ.n_qubits, circ.n_bits) for cmd in circ.get_commands(): if cmd.op.type in (OpType.Rx, OpType.Ry, OpType.Rz): params_prime = cmd.op.params params_prime[0] = params_prime[0] % 2 circ_prime.add_gate(cmd.op.type, params_prime, cmd.qubits) elif cmd.op.type == OpType.Measure: circ_prime.Measure(cmd.qubits[0].index[0], cmd.bits[0].index[0]) else: circ_prime.add_gate(cmd.op.type, cmd.op.params, cmd.qubits) return circ_prime",05/11/2023 10:04
32684.0,qiskit textbook code throws RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment,"I am trying to run the quantum communication algorithm from qiskit textbook &quot;Entangled States&quot; using my IBM API key, however, it throws the error RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment.. What am I doing wrong? This is my code: service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY]) backend = service.least_busy(simulator=False, operational=True) print(f'Running on {backend}') qc_charlie = QuantumCircuit(2,2) qc_charlie.h(1) qc_charlie.cx(1,0) MESSAGE = '01' qc_alice = QuantumCircuit(2,2) if MESSAGE[-2]=='1': qc_alice.z(1) if MESSAGE[-1]=='1': qc_alice.x(1) qc_bob = QuantumCircuit(2,2) # Bob disentangles qc_bob.cx(1,0) qc_bob.h(1) # Then measures qc_bob.measure([0,1],[0,1]) complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob)) backend.run(complete_qc).result().get_counts() I know the API works since I get Running on &lt;IBMBackend('ibmq_belem')&gt; and the circuit is ok as i can see it using qc_charlie.draw(), qc_alice.draw() and qc_bob.draw().",<qiskit><programming>,5/22/2023 20:48,32696.0,32696.0,"You need to use a Session object and the Sampler import qiskit from qiskit import QuantumCircuit from qiskit_ibm_runtime import QiskitRuntimeService from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY]) backend = service.least_busy(simulator=False, operational=True) print(f'Running on {backend.name}') qc_charlie = QuantumCircuit(2,2) qc_charlie.h(1) qc_charlie.cx(1,0) MESSAGE = '01' qc_alice = QuantumCircuit(2,2) if MESSAGE[-2]=='1': qc_alice.z(1) if MESSAGE[-1]=='1': qc_alice.x(1) qc_bob = QuantumCircuit(2,2) # Bob disentangles qc_bob.cx(1,0) qc_bob.h(1) # Then measures qc_bob.measure([0,1],[0,1]) complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob)) with Session(backend=backend): sampler = Sampler() result = sampler.run(complete_qc).result() print(result.quasi_dists)",5/23/2023 20:20
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system? Below you can see the code idea: q1 = QuantumCircuit(2) q1.save_statevector() # Save initial state q1.h(0) q1.save_statevector() # Save state after Hadamard q1.cx(0, 1) q1.save_statevector() # Save state after CNOT (also a final state) job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024) statevectors = job.result().get_statevector() However, if I were to try and run this, an error occurs upon reaching execute command. If anyone can provide any insight on this, I would be very grateful.",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"You can also obtain the states at any point during circuit construction using Statevector, the class from Qiskit's quantum_info module as follows. First, import the Statevector class, from qiskit.quantum_info import Statevector And for your example, the code below will produce all the intermediate states that you want. qc = QuantumCircuit(2) st0 = Statevector.from_instruction(qc) qc.h(0) st1 = Statevector.from_instruction(qc) qc.cnot(0, 1) st2 = Statevector.from_instruction(qc) print(st0) print(st1) print(st2) Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0.70710678+0.j, 0. +0.j, 0. +0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0. +0.j, 0. +0.j, 0.70710678+0.j], dims=(2, 2))",8/25/2021 13:41
34065.0,Create qnode with density matrix on pennylane,"I'm using pennylane. What I want to do is Create a qnode with the 2*2 density matrix of a single qubit one. It has the parameter as phi Given density matrix: $$\frac{1}{\gamma\cos(\varphi)+(\gamma-2)\mathrm{e}^{\frac{t}{t_2}}}\begin{pmatrix}(\gamma-1)\left(\mathrm{e}^{\frac{t}{t_2}}+\cos(\varphi)\right)&amp;\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)\\-\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)&amp;\cos(\varphi)-\mathrm{e}^{\frac{t}{t_2}}\end{pmatrix}$$ Pass is to qml.qinfo.classical_fisher(). I want to calculate classical fisher information respect to phi. But the problem is that when I create qnode with density matrix and pass it to qml.qinfo.classical_fisher() it shows the following error: DeviceError: Gate QubitDensityMatrix not supported on device default.qubit.autograd Is there any possible method to define a qnode with a custom density matrix available to use with autograd? I tried to convert it to a state vector but since the density matrix is a mixed state it can't be converted to state vector. Here is my code: import pennylane as qml from pennylane import numpy as np t1, t2, gamma = 1, 1, 0.5 # Define the density matrix def rho_ps(phi): density_matrix_ps = np.array([ [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)], [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2)) return density_matrix_ps n_wires = 1 dev = qml.device(&quot;default.qubit&quot;, wires=n_wires) # Define the qnode with density matrix @qml.qnode(dev) def circ(params): density_matrix = rho_ps(params) qml.QubitDensityMatrix(density_matrix, wires=0) # Initialize the qubit with the density matrix return qml.expval(qml.PauliZ(0)) # Generate parameters used in classical fisher information params = np.array([np.pi]) CFIM = qml.qinfo.classical_fisher(circ) print(CFIM) ```",<density-matrix><pennylane><programming><quantum-fisher-information>,09/07/2023 08:53,34095.0,34095.0,"My previous answer mistakenly read quantum_fisher instead of classical_fisher. It is actually possible to compute the latter with mixed states, but not the former. It seems that there are three problems in your code: The device you use should be default.mixed, since the density matrix you care about is mixed. params should be differentiable, and should thus be created with requires_grad=True CFIM must be called on params, as it's a function All in all, the following code gives you what you want (If I'm not mistaken): import pennylane as qml from pennylane import numpy as np t1, t2, gamma = 1, 1, 0.5 # Define the density matrix def rho_ps(phi): density_matrix_ps = np.array([ [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)], [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2)) return density_matrix_ps dev = qml.device(&quot;default.mixed&quot;, wires=[0]) @qml.qnode(dev) def circ(params): density_matrix = rho_ps(params) qml.QubitDensityMatrix(density_matrix, wires=0) return qml.expval(qml.PauliZ(0)) params = np.array([np.pi], requires_grad=True) CFIM = qml.qinfo.transforms.classical_fisher(circ) print(CFIM(params))",09/09/2023 10:08
34599.0,Converting a dictionary to a statevector in Qiskit,"Suppose we have a dictionary of computational basis states and their amplitudes: {'01':0.5, '10':0.5, '11':0.5, '00':0.5} How do I convert this (or any arbitrary dictionary) into a Statevector object? In this case the statevector should be is $$ | \psi \rangle = \frac{|00 \rangle + |01 \rangle + |10 \rangle + |11 \rangle}{2} $$",<qiskit><programming>,10/25/2023 15:40,34602.0,34602.0,"I don't think there a built-in functionality for this in Qiskit. However, it is easy to implement. The below code snippet shows how to do that: from qiskit.quantum_info import Statevector import numpy as np _state = {'01':0.5, '10':0.5, '11':0.5, '00':0.5} # Convert dictionary into array: num_qubits = len(next(iter(_state))) data = np.zeros(2 ** num_qubits) for key in _state: data[int(key, 2)] = _state[key] psi = Statevector(data) # Check: psi.draw('latex') Note that, it is not a production-quality code. For example, there is an implicit assumption that all the dictionary keys have the same length.",10/25/2023 15:58
34771.0,Why are quantum computing networks so far behind classical methods?,"I'm new to quantum computing, and computing in general, but it seems like quantum computing networks are really lagging behind what we have achieved with classical networks. I know that there are limitations, such as the need for quantum repeaters, as quantum information can not be cloned, but I have also seen that designs for such repeaters have been created. I was wondering why, if these limitations can be surpassed, has no global quantum computing network been created?",<classical-computing><quantum-networks>,11/08/2023 22:07,34799.0,34799.0,Quantum communication is a field where theory is far beyond experiment. Entanglement theory lies at the heart of computational complexity and entanglement is what really separates quantum mechanics from classical physics. To create a highly entangled state and keep it free from noise is the main problem of building a quantum computer and also of building a quantum network. Given that most quantum networks are represented by a graph state which is also a resource for universal quantum computation your question is equal to &quot;Why cannot we build a decent fault tolerant quantum computer while we can build classical computers with billions of bits?&quot; The problem is error correction again and it is far easier to error correct qubits in a quantum computer where you have all qubits lying close to each other when compared to a highly entangled graph state where you need to keep entanglement in the presence of thermal noise while sending the individual qubits over long distances.,11/10/2023 18:03
34896.0,If_test() - Dynamic Circuits in qiskit,"I am trying to run a dynamic circuit by having mid-measurement in my code as follows: from qiskit import * from math import * from qiskit.providers.fake_provider import FakeJakarta backend = FakeJakarta() q0 = QuantumRegister(1) q1 = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q0, q1, c) result_ = [] for i in range(2): qc.ry(2*pi/3, q0) qc.cx(q0, q1) qc.h(q1) qc.measure(q1, c[i]) with qc.if_test((c[i], 0)) as _else: result_.append(0) with _else: result_.append(1) job = backend.run(qc) print(result_) As it is obvious we must have a result like [0, 1, 0]. However, the list that I receive always is [0, 1, 0, 1]. Does anyone know how to solve this matter?",<qiskit><quantum-gate><programming>,11/17/2023 17:33,34900.0,34900.0,"It appears there's a misunderstanding regarding the use of if_test and _else constructs in your code. In Qiskit, these constructs are for adding conditional quantum operations to the circuit based on classical register states, not for controlling the flow of Python code execution. Consequently, in your loop, both result_.append(0) and result_.append(1) are executed in each iteration, leading to a list that's twice as long as expected. Also, you should only expect a list of length two as your result (not three), as you are measuring with classical bit c[0] in the first iteration, and c[1] in the second iteration. Here's a (potential) version of your code that gathers measurement data from each iteration (if I am correct in interpreting this you want to do): from qiskit import * from math import * from qiskit.providers.fake_provider import FakeJakarta backend = FakeJakarta() q0 = QuantumRegister(1) q1 = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q0, q1, c) results = [] for i in range(2): qc.ry(2*pi/3, q0) qc.cx(q0, q1) qc.h(q1) qc.measure(q1, c[i]) job = backend.run(qc, shots=1) result = job.result().get_counts(qc) results.append(result) print(results)",11/18/2023 13:49
35470.0,How to avoid azure-quantum ionq simulator computing a probability distribution of exponential size?,"I am running a 3-qubit simulation using ionq.simulator in azure-quantum. When I send the task, I get the result from one shot + probability distribution that includes all the possible 8 bitstrings. I am not interested in getting a probability distribution, just the result from 1 shot. This is a big problem when I try to do 29-qubit simulation, because I cannot even retrieve the results from Azure; the results are 12GB! Here is the 3 qubit example: from azure.quantum.qiskit import AzureQuantumProvider from azure.quantum import Workspace from qiskit import QuantumCircuit workspace = Workspace(resource_id = &quot;&quot;, location = &quot;&quot;) provider = AzureQuantumProvider(workspace) circuit = QuantumCircuit(3, 3) circuit.name = &quot;Qiskit Sample - 3-qubit GHZ circuit&quot; circuit.h(0) circuit.cx(0, 1) circuit.cx(1, 2) circuit.measure([0, 1, 2], [0, 1, 2]) device = provider.get_backend(&quot;ionq.simulator&quot;) job = device.run(circuit, shots=1) res = job.result() The results are: Result(backend_name='ionq.simulator', backend_version='1', qobj_id='Qiskit Sample - 3-qubit GHZ circuit', job_id='...', success=True, results=[ExperimentResult(shots=1, success=True, meas_level=2, data=ExperimentResultData(counts={'000': 1}, probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5})), header=QobjExperimentHeader(qiskit='True', name='Qiskit Sample - 3-qubit GHZ circuit', num_qubits='3', metadata={}, meas_map='[0, 1, 2]'))], date=None, status=None, header=None, error_data=None) The troublesome element for me is probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5}) since it grows exponentially with system size for an arbitrary circuit. Then, my question is, how do I avoid Azure computing the probability distribution? Which includes $2^n$ elements, with $n$ being the number of qubits.",<programming><azure-quantum><ionq>,1/13/2024 0:25,35540.0,35540.0,"This is currently unsupported scenario in Azure Quantum. Right now, you always get the complete job results back, which include the probability distribution. (I forwarded your question to the dev team, I think it's an interesting use case to consider.)",1/19/2024 20:28
35765.0,Efficient expectation value of a local operator,"I want to numerically compute something of the form $x=\langle\psi| A\otimes I |\psi\rangle$ where $I$ is the identity. Of course I can construct $A\otimes I$ and take the inner product, but I would like to save memory and compute $x$ without having to construct this large operator. What would be an efficient way to compute $x$ using simple numpy operations (reshape, einsum, trace etc) and without constructing the whole $ A\otimes I$ operator?",<programming>,02/08/2024 20:25,35767.0,35767.0,"I don't know if it's the fastest, but you can use the following subroutine for applying an operation to a subsystem of your state. This code will take an operation that's the correct shape for acting on a subsystem of $|\psi\rangle$ and apply it to that subsystem without having to tensor up to the size of the state space that $|\psi\rangle$ lives in: def mul_on_subsystem(op, state, target_subsystem): # `state` has a tensor shape, e.g. (dim_A, dim_B, dim_C) # make sure `op` is correctly shaped to be applied to the target subsystem! target_dim = state.shape[target_subsystem] assert op.shape == (target_dim, target_dim) # (1) tensordot op onto the target axis of the state # this applies axis 1 of `op` to the target axis of `state` out = np.tensordot(op, state, axes=([1], [target_subsystem])) # (2) rearrange the axes that get scrambled by tensordot out = np.moveaxis(out, 0, target_subsystem) return out Once you've applied $A$ to $|\psi\rangle$ in the way you like, you can compute the inner product in the obvious way, np.dot(state.conj().flatten(), mul_on_subsystem(local_operation, state, target_subsystem).flatten()) This technique also generalizes nicely to density operators, albeit with some very annoying shuffling of axes. Timing/validation/sample code: # declare your subsystem sizes; these are &quot;2&quot; if its qubits... dim_a = 25 # axis 0 dim_b = 25 # axis 1 dim_c = 35 # axis 2 # reshape your state to get it into tensor form (dim_a, dim_b, dim_c) state = np.random.rand(dim_a, dim_b, dim_c) state = state / np.linalg.norm(state) operation_A = np.random.rand(dim_a, dim_a) operation_B = np.random.rand(dim_b, dim_b) operation_C = np.random.rand(dim_c, dim_c) # being generous and not including the time to construct the tensored operation AII = np.kron(operation_A, np.kron(np.eye(dim_b), np.eye(dim_c))) IBI = np.kron(np.eye(dim_a), np.kron(operation_B, np.eye(dim_c))) IIC = np.kron(np.eye(dim_a), np.kron(np.eye(dim_b), operation_C)) for i in range(3): # using mul_on_subsystem local_operation = [operation_A, operation_B, operation_C][i] t0 = time.time() fast = mul_on_subsystem(local_operation, state, i) time_fast = time.time() - t0 # using tensored-up matrices tensored_operation = [AII, IBI, IIC][i] t0 = time.time() slow = np.dot(tensored_operation, state.flatten()) time_slow = time.time() - t0 system = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;][i] print(f&quot;system {system} fast: {time_fast:.5f} s, slow: {time_slow:.5f} s&quot;) np.testing.assert_allclose(fast.flatten(), slow) Output on my laptop system A fast: 0.02700 s, slow: 0.47000 s system B fast: 0.00100 s, slow: 0.21201 s system C fast: 0.00000 s, slow: 0.32400 s",02/08/2024 21:15
35768.0,How to compare the output of statevector_simulator and qasm_simulator in Qiskit,"I am stuck with a very difficult problem. Suppose, I execute a circuit on statevector_simulator, and I get all the values negative. Suppose, now i execute the same circuit on qasm_simulator. I will surely get positive coefficients, because here I will do the square root of the probabilities and probabilities are always positive. Now how should I check the equivalence or correctness? Edit To make my question more clear, am running a small two qubit circuit using qasm simulator and statevector simulator. You will see that results are different and I am not sure how to compare their results. Qasm_Simulator from qiskit import QuantumCircuit, execute from qiskit import IBMQ from qiskit import Aer import numpy as np import matplotlib.pyplot as plt IBMQ.load_account() simulator_used = 'qasm_simulator' circuit = QuantumCircuit(2,2) data = np.array([-0.5, -0.2, -0.2, -0.6]) norm_data = np.linalg.norm(data) normalized_data = data/ norm_data circuit.initialize(normalized_data, [0,1]) circuit.h(0) circuit.cx(0,1) circuit.x(0) circuit.rx(-np.pi/10, 0) circuit.ry(-np.pi/20, 1) circuit.measure([0,1],[0,1]) print(circuit) simulator = Aer.get_backend(simulator_used) job = execute(circuit, simulator, shots=10000) result = job.result() counts = result.get_counts(circuit) final_result = [] for key in counts: final_result.append(np.sqrt(counts[key]/10000)) print(final_result) The result is: IBMQ.load_account() âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ ââââââââââââââââ q_0: â¤0 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) ââ¤Mâ â Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´ââââââââââ¬ââ¬âââââââ¥â q_1: â¤1 âââââââ¤ X ââ¤ Ry(-Ï/20) âââââââ¤Mââââââââ«â ââââââââââââââââââââââââââââââââââââââââââââââââââââ ââââââââââââââââââ ââ¥â â c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©ââââââââ©â 1 0 [0.6433506042586733, 0.6260990336999411, 0.30016662039607267, 0.322490309931942] Statevector_Simulator from qiskit import QuantumCircuit from qiskit.compiler import transpile from qiskit import IBMQ from qiskit import Aer import numpy as np import matplotlib.pyplot as plt IBMQ.load_account() simulator_used = &quot;statevector_simulator&quot; circuit = QuantumCircuit(2,2) data = np.array([-0.5, -0.2, -0.2, -0.6]) norm_data = np.linalg.norm(data) normalized_data = data/ norm_data circuit.initialize(normalized_data, [0,1]) circuit.h(0) circuit.cx(0,1) circuit.x(0) circuit.rx(-np.pi/10, 0) circuit.ry(-np.pi/20, 1) print(circuit) simulator = Aer.get_backend(simulator_used) result = simulator.run(transpile(circuit, simulator)).result() output_complex = result.get_statevector(circuit) output_real = np.array(np.real(output_complex)) print(&quot;The output real =&quot;, output_real) The result is: IBMQ.load_account() âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ âââââââââââââ q_0: â¤0 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) â â Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´âââââââââââââââââ q_1: â¤1 âââââââ¤ X ââ¤ Ry(-Ï/20) ââââââââââââââ ââââââââââââââââââââââââââââââââââââââââââââââââââââ ââââââââââââââââââ c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ The output real = [ 0.31548377 -0.63950225 -0.27784191 -0.62437088] It would be great if someone can help me in resolving my problem.",<qiskit><programming><quantum-state>,02/08/2024 23:25,35895.0,35895.0,"Your problem is the line output_real = np.array(np.real(output_complex)) You should not be looking at output_real. In order to compare the results of these two simulations, you should instead be looking at the norm of the complex entries of output_complex. You will see that these norms are very close to the values in final_result (the values won't be exactly equal because of randomness in the simulation). Also be careful about the order of the entries in final_result. They should be ordered according to '00', '01', '10', '11', but counts is not always returned in that order. Here is a slim version of your code which gives the expected result from qiskit import QuantumCircuit, execute from qiskit import Aer from numpy import pi, array, sqrt from numpy.linalg import norm data = array([-0.5, -0.2, -0.2, -0.6]) norm_data = norm(data) normalized_data = data / norm_data qasm_sim = Aer.get_backend('qasm_simulator') statevector_sim = Aer.get_backend('statevector_simulator') def create_qc(): qc = QuantumCircuit(2) qc.initialize(normalized_data, [0,1]) qc.h(0) qc.cx(0,1) qc.x(0) qc.rx(-pi/10, 0) qc.ry(-pi/20, 1) return qc # qasm simulator qc = create_qc() qc.measure_all() result = execute(qc, qasm_sim, shots=10000).result() counts = result.get_counts() print('qasm simulator:', [ sqrt(counts['00'] / 10000), sqrt(counts['01'] / 10000), sqrt(counts['10'] / 10000), sqrt(counts['11'] / 10000) ] ) # statevector simulator qc = create_qc() result = execute(qc, statevector_sim).result() v = result.get_statevector() print('statevector simulator', [ norm(v[0]), norm(v[1]), norm(v[2]), norm(v[3]) ] ) A sample output is qasm simulator: [0.3377869150810907, 0.6431174076325411, 0.29274562336608895, 0.6217716622683925] statevector simulator [0.33134439021006384, 0.6414514034928228, 0.29491606277662025, 0.6259197296377109]",2/21/2024 8:18
35930.0,Microsoft Classic QDK simulator,"Is it possible to change the simulator used by the Classic QDK with Python simulation ? It's reported that Classic QDK supports several simulators (sparse, full-state...). Which one is used when called from Python environment, and is it possible to change it? I have a simulation which doesn't run because of large number of qubits instantiated (from 25 up to 61). The simulation with C# .NET runs perfectly. But when I use a Python host program, the simulation is simply blocked at qubit instantiation. So I suppose that C# .NET host uses sparse simulator, while Python uses full-state.",<programming><simulation><q#>,2/23/2024 15:16,35932.0,35932.0,"There are no default simulators chosen either in .NET or in Python, you always specify them explicitly. In C#, you use different classes for different simulators: QuantumSimulator for full state simulator, SparseSimulator for sparse simulator. In Python, you switch the command you use to run Q# operation to use different simulators: .simulate() uses full state simulator, and .simulate_sparse() uses sparse simulator.",2/23/2024 16:45
37300.0,Qiskit code works even without measure_all() with qasm_simulator,"I am need help in understanding about the measure_all() of the qiskit. The below code is correct even though measure_all() is not being used. from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) It would be great if someone can explain about the measure_all() concept, where to use it and where not to use it?",<qiskit><programming>,3/17/2024 7:55,37310.0,37310.0,"You are noticing that measurement behavior is different in different versions of Qiskit. In qiskit==0.33.1, we have the following behavior: import qiskit print(qiskit.__qiskit_version__) {'qiskit-terra': '0.19.1', 'qiskit-aer': '0.9.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.2', 'qiskit-aqua': '0.9.5', 'qiskit': '0.33.1', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None} from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) {'000': 100000} But in the next update qiskit==0.34.0 there is an error: import qiskit print(qiskit.__qiskit_version__) {'qiskit-terra': '0.19.1', 'qiskit-aer': '0.10.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.3', 'qiskit-aqua': '0.9.5', 'qiskit': '0.34.0', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None} from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) QiskitError: 'No counts for experiment &quot;&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x1550e7790&gt;&quot;' So your issue is not with the measure_all() concept per say, but rather you just need to keep notes of the versions in which these changes take place. Clarification: It should also be noted that in the qiskit==0.33.1 case, the output {'000': 100000} is reflecting the fact that no measurements have been loaded in to the classical bits (so the values all remain zero). If a measurement statement is included, then this circuit will have GHZ state measurement statistics: from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) circ.measure(range(3), range(3)) # actually measure the circuit backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) {'000': 50094, '111': 49906}",3/17/2024 19:55
37309.0,vqe.compute_minimum_eigenvalue API of qiskit produces different eigenstate results for statevector_simulator ands qasm_simulator,"I am trying to understand the usage of vqe.compute_minimum_eigenvalue API of qiskit for the statevector_simulator and qasm_simulator. I am only interested in the eigenstate and eigenvalue. When I run the below code for statevector_simulator, I get the below as shown below: backend = Aer.get_backend(&quot;statevector_simulator&quot;) quantum_instance = QuantumInstance(backend= backend, shots= 1 seed_simulator= 28, seed_transpiler= 28, basis_gates= None, optimization_level=0) vqe = VQE(ansatz=ansatz_opt, optimizer= optimizer, quantum_instance=quantum_instance, initial_point=initial_point_values ) result = vqe.compute_minimum_eigenvalue(H_op) print(&quot;The value of result is =&quot;, result) The value of result is: The value of result is = { 'aux_operator_eigenvalues': None, 'cost_function_evals': 1352, 'eigenstate': array([0.01715463+0.42191317j, 0.02261512+0.55615892j, 0.02288142+0.56255103j, 0.01794385+0.44109138j]), 'eigenvalue': (1.2502114e-10+0j), 'optimal_circuit': None, 'optimal_parameters': { ParameterVectorElement(Î¸[3]): 1.8871963979619928, ParameterVectorElement(Î¸[0]): 3.4198843373829284, ParameterVectorElement(Î¸[2]): 4.2904615454665835, ParameterVectorElement(Î¸[1]): 0.8448563317717608, ParameterVectorElement(Î¸[4]): 3.448308970824199, ParameterVectorElement(Î¸[5]): 3.5108928973122078, ParameterVectorElement(Î¸[6]): 4.155936156778078, ParameterVectorElement(Î¸[7]): 5.828853129364108, ParameterVectorElement(Î¸[8]): 2.717512248330424, ParameterVectorElement(Î¸[9]): 1.1104402869985177, ParameterVectorElement(Î¸[10]): 0.35997873578438755, ParameterVectorElement(Î¸[11]): 5.383757228721264, ParameterVectorElement(Î¸[12]): 2.2265588674752292, ParameterVectorElement(Î¸[13]): -0.524391503109095, ParameterVectorElement(Î¸[14]): 2.721212459791864, ParameterVectorElement(Î¸[15]): 1.584924993236795, ParameterVectorElement(Î¸[16]): -0.49539861026959436, ParameterVectorElement(Î¸[17]): 4.162724464416642, ParameterVectorElement(Î¸[18]): 3.6325193273490144, ParameterVectorElement(Î¸[19]): 6.662136048337769}, 'optimal_point': array([ 3.41988434, 0.84485633, 4.29046155, 1.8871964 , 3.44830897, 3.5108929 , 4.15593616, 5.82885313, 2.71751225, 1.11044029, 0.35997874, 5.38375723, 2.22655887, -0.5243915 , 2.72121246, 1.58492499, -0.49539861, 4.16272446, 3.63251933, 6.66213605]), 'optimal_value': 1.2502114e-10, 'optimizer_evals': None, 'optimizer_result': None, 'optimizer_time': 52.66859722137451} But when I run the code for qasm_simulator, I get the results as below: backend = Aer.get_backend(&quot;qasm_simulator&quot;) quantum_instance = QuantumInstance(backend= backend, shots= 1000000 seed_simulator= 28, seed_transpiler= 28, basis_gates= None, optimization_level=0) vqe = VQE(ansatz=ansatz_opt, optimizer= optimizer, quantum_instance=quantum_instance, initial_point=initial_point_values ) result = vqe.compute_minimum_eigenvalue(H_op) print(&quot;The value of result is =&quot;, result) The value of result is The value of result is = { 'aux_operator_eigenvalues': None, 'cost_function_evals': 1, 'eigenstate': { '00': 0.13272528018429647, '01': 0.3030214513858714, '10': 0.7196895163888384, '11': 0.610417070534565}, 'eigenvalue': (5.67387294600939+0j), 'optimal_circuit': None, 'optimal_parameters': { ParameterVectorElement(Î¸[2]): 4.224454970398236, ParameterVectorElement(Î¸[0]): 5.863937784019204, ParameterVectorElement(Î¸[1]): 3.4455864378670014, ParameterVectorElement(Î¸[4]): 0.506017439486799, ParameterVectorElement(Î¸[3]): 2.3690675120103775, ParameterVectorElement(Î¸[5]): 4.79940129981895, ParameterVectorElement(Î¸[6]): 0.09967770119784523, ParameterVectorElement(Î¸[7]): 1.8225430500149276, ParameterVectorElement(Î¸[8]): 1.1087175676599133, ParameterVectorElement(Î¸[9]): 2.650606283797435, ParameterVectorElement(Î¸[10]): 1.932734623597688, ParameterVectorElement(Î¸[11]): 4.6581354731326785, ParameterVectorElement(Î¸[12]): 5.42013877739097, ParameterVectorElement(Î¸[13]): 5.232441413652715, ParameterVectorElement(Î¸[14]): 0.2577507460800755, ParameterVectorElement(Î¸[15]): 3.8652580750273775, ParameterVectorElement(Î¸[16]): 3.133086142322153, ParameterVectorElement(Î¸[17]): 5.98592177389689, ParameterVectorElement(Î¸[18]): 2.0935707919171658, ParameterVectorElement(Î¸[19]): 0.40662390687216604}, 'optimal_point': array([5.86393778, 3.44558644, 4.22445497, 2.36906751, 0.50601744, 4.7994013 , 0.0996777 , 1.82254305, 1.10871757, 2.65060628, 1.93273462, 4.65813547, 5.42013878, 5.23244141, 0.25775075, 3.86525808, 3.13308614, 5.98592177, 2.09357079, 0.40662391]), 'optimal_value': 5.67387294600939, 'optimizer_evals': None, 'optimizer_result': None, 'optimizer_time': 163.65113639831543} What I understand looking at statevector values is that they are coefficients, but these values are not unifying (they are completely different results). I am not able to understand the reason? Is I am doing something wrong? Please guide me. Thank for great help.",<qiskit><programming><vqe>,3/17/2024 18:32,37312.0,37312.0,"Using statevector simulator will give an ideal result for the computation of the operator expectation value. As the state (ansatz) is varied the value computed for any given point will always be the same. This is not the case with the qasm simulator, which samples (shots number of times) from that ideal result for the counts it gives back. The samples are random so the counts can change and this means the expectation value computed can change. You are using a large number of shots but even so, at any given point, the value will still vary. What optimizer are you using - if its a gradient based one like SLSQP small changes can throw it when it tries to compute a gradient at the local point where by default it uses finite difference with a small eps (epsilon) value where it computes the values around the point. You can try a gradient free optimizer like COBYLA, or SPSA which was designed to work in noisy conditions.",3/17/2024 21:05
37384.0,QuTiP ptrace function results do not recreate original composite system,"I have a qutip density matrix fullsystem for a system composed of two quantum systems with dims = [[n, n], [n, n]], shape = (n**2, n**2). It's my understanding that if I wanted the density matrix of each system separately, I could do subsystem1 = fullsystem.ptrace(0) subsystem2 = fullsystem.ptrace(1) Should I not be able to get fullsystem back by doing tensor(subsystem1, subsystem2)? This is not working for me (fullsystem == tensor(subsystem1, subsystem2) gives False), they are close but significantly more different than I'd expect. I have tried tensor(susbsystem1.unit(), subsystem2.unit()) as well. Am I just not understanding how I should be using ptrace? Are there certain assumptions about fullsystem that I need to take into account beyond knowing the two subsystem composition given by dims?",<programming><linear-algebra><qutip>,3/20/2024 22:54,37387.0,37387.0,"This would only work if fullsystem is a product state. Let $\rho$ be your full system. For example, say $$\rho = |011\rangle\langle011|\,.\tag{1}$$ Now, $$\rho_1 = \text{Tr}_{23}\big[\rho\big] = |0\rangle\langle0|\,,\tag{2.1}$$ $$\rho_{23} = \text{Tr}_{1}\big[\rho\big] = |11\rangle\langle11|\,.\tag{2.2}$$ So in this case, $$\rho = \rho_1 \otimes \rho_{23}\,,\tag{3}$$ is true. However, this will not be true if your $\rho$ has entanglement. Let's perform the same analysis programatically using QuTiP. Creating $\rho$: # Define basis states for 3 qubits q0 = basis(2, 0) # |0â© q1 = basis(2, 1) # |1â© psi = tensor(q0, q1, q1) # Example 3-qubit state: |0â© â |1â© â |1â© # Creating a density matrix from the state |0â© â |1â© â |1â© rho = psi * psi.dag() # Print the density matrix print(&quot;Density Matrix:&quot;) print(rho) This gives output: Density Matrix: Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True Qobj data = [[0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.]] Now, taking the partial trace and computing $\rho_1$ and $\rho_{23}$: # Performing partial trace for the first qubit rho_1 = ptrace(rho, [0]) print(&quot;\nPartial Trace for the first qubit:&quot;) print(rho_1) # Performing partial trace for the second and third qubit rho_23 = ptrace(rho, [1, 2]) print(&quot;\nPartial Trace for the second and third qubit:&quot;) print(rho_23) This gives output: Partial Trace for the first qubit: Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True Qobj data = [[1. 0.] [0. 0.]] Partial Trace for the second and third qubit: Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True Qobj data = [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 1.]] And now, let's check if Eq.$(\text{3})$ holds true or not. rho == tensor(rho_1, rho_23) This gives output: True",3/21/2024 4:35
37405.0,QiskitBackendNotFoundError - Unable to run the backend using BackendEstimator primitive,"I am trying to run a small quantum circuit and generate the expectation value of an observable using the BackendEstimator primitive by incorporating the noise model from Fake20QV1 backend. Below is a snippet of the code. qc = QuantumCircuit(3,3) qc.x(0) qc.x(1) qc.h(2) qc.x(2) qc.measure(range(3), range(3)) observable = SparsePauliOp(&quot;ZZZ&quot;) #qc.draw('mpl') # Get the noise model of Fake20VQ1 backend_fake = Fake20QV1() noise_model = noise.NoiseModel.from_backend(backend_fake) # Get coupling map from backend coupling_map = backend_fake.configuration().coupling_map # Get basis gates from noise model basis_gates = noise_model.basis_gates # Perform a noisy simulation backend = AerSimulator(noise_model=noise_model, coupling_map=coupling_map, basis_gates=basis_gates, shots=1024) transpiled_circuit = transpile(qc, backend) result = backend.run(transpiled_circuit).result() Now, there are two ways in which I tried to run the circuit : Alternative #1 counts = result.get_counts(0) expectation_value = sampled_expectation_value(counts, observable) plot_histogram(counts) expectation_value Runs successfully and gives the expected outputs. Alternative #2 (using BackendSampler and BackendEstimator) with Session(backend=backend_fake): sampler = BackendSampler() estimator = BackendEstimator() result1 = sampler.run(qc).result() print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;) result2 = estimator.run(qc, observable).result() print(f&quot;EV : {result2.values[0]}&quot;) Generates QiskitBackendNotFoundError: 'No backend matches the criteria.' File ~/anaconda3/envs/qem/lib/python3.12/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:779, in QiskitRuntimeService.backend(self, name, instance) 763 &quot;&quot;&quot;Return a single backend matching the specified filtering. 764 765 Args: (...) 776 QiskitBackendNotFoundError: if no backend could be found. 777 &quot;&quot;&quot; 778 # pylint: disable=arguments-differ, line-too-long --&gt; 779 backends = self.backends(name, instance=instance) 780 if not backends: 781 cloud_msg_url = &quot;&quot; ... --&gt; 539 raise QiskitBackendNotFoundError(&quot;No backend matches the criteria.&quot;) 540 if not self._backends[name] or instance_filter != self._backends[name]._instance: 541 self._set_backend_config(name) QiskitBackendNotFoundError: 'No backend matches the criteria.'",<qiskit><programming><ibm-quantum-devices>,3/22/2024 5:33,37407.0,37407.0,"Since Qiskit has been updated, many things have been moved here and there, also the noise model fake backends that you are using. This is how you should run it in accordance with the recently updated Qiskit package. Necessary Imports from qiskit import QuantumCircuit from qiskit.quantum_info import SparsePauliOp from qiskit_aer import AerSimulator from qiskit_ibm_runtime.fake_provider import FakeVigo # fake noisy backends are moved to ibm_runtime, do pip install qiskit-ibm-runtime before from qiskit import transpile from qiskit.result import sampled_expectation_value from qiskit.visualization import plot_histogram from qiskit.primitives import BackendEstimator, BackendSampler Making the Quantum Circuit qc = QuantumCircuit(3,3) qc.x(0) qc.x(1) qc.h(2) qc.x(2) qc.measure(range(3), range(3)) observable = SparsePauliOp(&quot;ZZZ&quot;) qc.draw('mpl',style=&quot;iqp&quot;) Selecting the Noisy Backend and transpiling device_backend = FakeVigo() sim_vigo = AerSimulator.from_backend(device_backend) transpiled_circuit = transpile(qc, sim_vigo) # this step is necessary Running a Noisy Simulation result = sim_vigo.run(transpiled_circuit).result() counts = result.get_counts(0) expectation_value = sampled_expectation_value(counts, observable) expectation_value or getting the plot: plot_histogram(counts) Alternative Method sampler = BackendSampler(backend=sim_vigo) estimator = BackendEstimator(backend=sim_vigo) result1 = sampler.run(qc).result() print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;) result2 = estimator.run(qc, observable).result() print(f&quot;EV : {result2.values[0]}&quot;) You have to specify the backend in the argument of BackendSampler and BackendEstimator. This code will run.",3/22/2024 7:00
37436.0,Quantum Circuit evaluation Qiskit vs. AWS Braket SDK,"I am examining a simple circuit using both Qiskit and the AWS Braket SDK (Python). The circuit is very simple. T : |0|1| q0 : -C-C- | | q1 : -Z-|- | q2 : ---Z- I trying to find the equivalent unitary operator for this circuit. I get different answers from Qiskit and AWS Braket SDK and I don't know why. Here is my Qiskit code: from qiskit import * qr = QuantumRegister(3, 'q') cr = ClassicalRegister(0, 'c') circuit = QuantumCircuit(qr, cr) circuit.cz(qr[0], qr[1]) circuit.cz(qr[0], qr[2]) simulator = Aer.get_backend('unitary_simulator') result = execute(circuit, backend = simulator).result() matprint(result.get_unitary().data) def matprint(mat, fmt=&quot;g&quot;): col_maxes = [max([len((&quot;{:&quot;+fmt+&quot;}&quot;).format(x)) for x in col]) for col in mat.T] for x in mat: for i, y in enumerate(x): print((&quot;{:&quot;+str(col_maxes[i])+fmt+&quot;}&quot;).format(y), end=&quot; &quot;) print(&quot;&quot;) The Qiskit result is: 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j -0+0j -0+0j -0+0j -1+0j -0+0j -0+0j -0+0j -0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j -0+0j -0+0j -0+0j -0+0j -0+0j -1+0j -0+0j -0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0-0j 0-0j 0-0j 0-0j 0-0j 0-0j 0-0j 1-0j This is what I expected from my hand-calculations. However, when using AWS Braket SDK I get something different. The Braket code: from braket.circuits import Circuit db=Circuit().cz(0,1).cz(0,2) print(db.to_unitary()) The result is: [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j -1.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j -1.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]] I believe the Qiskit answer is correct because it is consistent with &quot;I kron CZ&quot; for the first operation. If I do &quot;CZ kron I&quot; for the first operation I get the Braket answer. I am new to quantum computing and would find an explanation valuable.",<qiskit><quantum-gate><programming><amazon-braket>,3/24/2024 21:17,37437.0,37437.0,The reason for the difference is that Qiskit and Braket use different endianness for their qubits; Qiskit is little endian: $$ | q_{n - 1} \ldots q_2 q_1 q_0 \rangle $$ while Braket is big-endian: $$ | q_0 q_1 q_2 \ldots q_{n - 1} \rangle $$ You can show this by reversing the endianness of the Qiskit unitary: from qiskit.quantum_info import Operator Operator(circuit).reverse_qargs().to_matrix(),3/24/2024 21:54
38093.0,Quantum circuit not showing when using qiskit with pycharm,"I am trying to run below code in PyCharm: from qiskit.circuit.library import MCXGate, HGate from qiskit import QuantumCircuit circuit = QuantumCircuit(4) circuit.append(HGate(), [0]) circuit.append(MCXGate(3), [0,1,2,3]) circuit.draw('mpl') But I don't see any output circuit. The plot window flashes for a bit but it immediately closes itself. If I use inline figures then I can get the circuit diagram but I want the interactive version. Can someone please help me with this issue. I have always used PyCharm for my other projects so I don't really want to change to another IDE.",<qiskit><programming>,05/02/2024 01:39,38094.0,38094.0,"By default, qiskit draws the quantum circuit for inline visualization (because inline figures are typlically used with jupyter lab). To fix this issue, you need to explicitly use .show() method from matplotlib.pyplot if you are creating the figure from an IDE. So, your code will look something like this: from qiskit.circuit.library import MCXGate, HGate from qiskit import QuantumCircuit import matplotlib.pyplot as plt circuit = QuantumCircuit(4) circuit.append(HGate(), [0]) circuit.append(MCXGate(3), [0,1,2,3]) circuit.draw('mpl') plt.show() # Add this line Hope this helps!",05/02/2024 02:38
38132.0,weird negative sign in a state vector in qiskit,"I run the following simple code in qiskit, which get statevector of a quantum circuit. qc = QuantumCircuit(3) qc.initialize( [ 0.0 + 0.0j, sqrt(1 / 3) + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, sqrt(2 / 3) + 0.0j, ] ) qc.cry(pi / 2, 1, 0) # (theta, controlled bit, target bit) print(Statevector(qc)) The output is the following: Statevector([ 0. +0.j, 0.57735027+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.57735027+0.j, 0.57735027+0.j], dims=(2, 2, 2)) I expected that the sign of |011&gt; = |6&gt; is plus, however it seems minus.... Am I wrong? or What is the problem here? Thank you in advance!",<qiskit><quantum-state><programming>,05/03/2024 20:19,38138.0,38138.0,"We start with the state, $$\sqrt{1/3}|001\rangle + \sqrt{2/3}|111\rangle$$ Then apply $R_y(\pi/2)$ to the first qubit controlled by the second qubit. By linearity, we can calculate the impact of applying this gate to each basis state individually. The basis state $|001\rangle$ will not impacted since the second qubit in state $|0\rangle$. On the other hand, the basis state $|111\rangle$ will be impacted. We have, $$ R_y(\theta) = \left( {\begin{array}{*{20}{c}} \cos(\theta/2)&amp;-\sin(\theta/2) \\ \sin(\theta/2)&amp;\cos(\theta/2) \end{array}} \right) $$ Multiply the state of the first qubit by this matrix when $\theta = \frac{\pi}{2}$, $$\left( {\begin{array}{*{20}{c}} \frac{1}{\sqrt{2}}&amp;\frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}} \end{array}} \right) \left( {\begin{array}{*{20}{c}} 0 \\ 1 \end{array}} \right) = \left( {\begin{array}{*{20}{c}} \frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{array}} \right)$$ So, the final state will be, $$\frac{\sqrt{3}}{3} |001\rangle- \frac{\sqrt{3}}{3} |110\rangle+\frac{\sqrt{3}}{3} |111\rangle$$",05/04/2024 06:08
