QuestionId,QuestionTitle,QuestionBody,QuestionTags,QuestionDate,AcceptedAnswerId,AnswerId,Answer Body,AnswerDate,Category,Description,GPT_Categorisation,GPT_Descriptions,Agree / Not,Count of Not Agree,Negotiation,Reason
306453.0,Quantum Computing - Hype Or Hyper?,"<p>I have recently been web-researching quantum computing. </p>

<p>Will we see these in our lifetimes (ever?) (The error correction issue, for example, seems intractable to me).</p>
",<error-correction><quantum-computing>,11/20/2008 19:00,306536.0,306536.0,"<p>Just looking at the results from one website, I'd say it's not that impossible:</p>

<p><a href=""http://arstechnica.com/journals/science.ars/2008/03/28/encoding-more-than-one-bit-in-a-photon"" rel=""nofollow noreferrer"">http://arstechnica.com/journals/science.ars/2008/03/28/encoding-more-than-one-bit-in-a-photon</a><br>
<a href=""http://arstechnica.com/journals/science.ars/2008/10/28/scalable-quantum-computing-in-the-next-5-years"" rel=""nofollow noreferrer"">http://arstechnica.com/journals/science.ars/2008/10/28/scalable-quantum-computing-in-the-next-5-years</a><br>
<a href=""http://arstechnica.com/news.ars/post/20080729-finding-lost-qubits.html"" rel=""nofollow noreferrer"">http://arstechnica.com/news.ars/post/20080729-finding-lost-qubits.html</a><br>
<a href=""http://arstechnica.com/news.ars/post/20080509-new-quantum-dot-logic-gates-a-step-towards-quantum-computers.html"" rel=""nofollow noreferrer"">http://arstechnica.com/news.ars/post/20080509-new-quantum-dot-logic-gates-a-step-towards-quantum-computers.html</a><br>
<a href=""http://arstechnica.com/news.ars/post/20080626-three-dimensional-qubits-on-the-way.html"" rel=""nofollow noreferrer"">http://arstechnica.com/news.ars/post/20080626-three-dimensional-qubits-on-the-way.html</a><br>
<a href=""http://arstechnica.com/news.ars/post/20080527-molecular-magnets-in-soap-bubbles-could-lead-to-quantum-ram.html"" rel=""nofollow noreferrer"">http://arstechnica.com/news.ars/post/20080527-molecular-magnets-in-soap-bubbles-could-lead-to-quantum-ram.html</a>  </p>

<p>For a more technical overview of why it's not as hard as it used to be, there's a four-part series on self-correcting quantum computers:<br>
<a href=""http://scienceblogs.com/pontiff/2008/08/selfcorrecting_quantum_compute.php"" rel=""nofollow noreferrer"">http://scienceblogs.com/pontiff/2008/08/selfcorrecting_quantum_compute.php</a></p>
",11/20/2008 19:23,Conceptual,"because the question is asking about the background, limitations, and underlying concepts of quantum computing. Specifically, the question is asking about the feasibility of quantum computing and the challenges that need to be overcome in order to make it a reality.",Conceptual,,,,Conceptual,
311064.0,Are there public key cryptography algorithms that are provably NP-hard to defeat?,"<p>Should practical quantum computing become a reality, I am wondering if there are any public key cryptographic algorithms that are based on NP-complete problems, rather than integer factorization or discrete logarithms.</p>

<p>Edit:</p>

<p>Please check out the ""Quantum computing in computational complexity theory"" section of
<a href=""http://en.wikipedia.org/wiki/Quantum_computer"" rel=""noreferrer"">the wiki article on quantum computers.</a>  It points out that the class of problems quantum computers can answer (BQP) is believed to be strictly easier than NP-complete. </p>

<p>Edit 2:</p>

<p>'Based on NP-complete' is a bad way of expressing what I'm interested in.</p>

<p>What I intended to ask is for a Public Key encryption algorithm with the property that any method for breaking the encryption can also be used to break the underlying NP-complete problem.  This means breaking the encryption proves P=NP.</p>
",<cryptography><complexity-theory><quantum-computing>,11/22/2008 8:06,3654889.0,3654889.0,"<p>I am responding to this old thread because it is a very common and important question, and all of the answers here are inaccurate.</p>

<p>The short answer to the original question is an unequivocal ""NO"".  There are no known encryption schemes (let alone public-key ones) that are based on an NP-complete problem (and hence all of them, under polynomial-time reductions).  Some are ""closer"" that others, though, so let me elaborate.</p>

<p>There is a lot to clarify here, so let's start with the meaning of ""based on an NP-complete problem.""  The generally agreed upon interpretation of this is: ""can be proven secure in a particular formal model, assuming that no polynomial-time algorithms exist for NP-complete problems"".  To be even more precise, we assume that no algorithm exists that <em>always</em> solves an NP-complete problem.  This is a very safe assumption, because that's a really hard thing for an algorithm to do - it's seemingly a lot easier to come up with an algorithm that solves random instances of the problem with good probability.</p>

<p>No encryption schemes have such a proof, though.  If you look at the literature, with very few exceptions (see below), the security theorems read like the following:</p>

<blockquote>
  <p><em>Theorem:</em> This encryption scheme is provably secure, assuming that no
  polynomial-time algorithm exists for
  <strong>solving random instances of some problem X</strong>.</p>
</blockquote>

<p>Note the ""random instances"" part.  For a concrete example, we might assume that no polynomial-time algorithm exists for factoring the product of two random n-bit primes with some good probability.  This is very different (less safe) from assuming that no polynomial-time algorithm exists for <em>always</em> factoring <em>all</em> products of two random n-bit primes.</p>

<p>The ""random instances"" versus ""worst case instances"" issue is what is tripped up several responders above.  The McEliece-type encryption schemes are based on a very special random version of decoding linear codes - and not on the actual worst-case version which is NP-complete.</p>

<p>Pushing beyond this ""random instances"" issue has required some deep and beautiful research in theoretical computer science.  Starting with the work of MiklÃ³s Ajtai, we have found cryptographic algorithms where the security assumption is a ""worst case"" (safer) assumption instead of a random case one.  Unfortunately, the worst case assumptions are for problems that are not known to be NP complete, and some theoretical evidence suggests that we can't adapt them to use NP-complete problems.  For the interested, look up ""lattice based cryptography"".</p>
",09/06/2010 23:44,Theoretical ,This is exploring the possibility of public key encryption algorithms that connect to NP-complete problems and considers the implications of quantum computing on computational complexity classes like BQP and NP-complete.so belong to theoretical ,Theoretical,,,,Theoretical ,
431327.0,Anybody interested in possible operation/use of quantum computers?,"<p>I went through a period of being interested in how quantum computers work and what they might be good for if they ever become practical. I know they are talked about for code-breaking. <a href=""http://aps.arxiv.org/PS_cache/quant-ph/pdf/9807/9807026v1.pdf"" rel=""nofollow noreferrer"">I was interested is using them for validating software by essentially trying all possible inputs (in parallel) and seeing if any error states are reached.</a></p>

<p>I know it's a bit of a blue-sky question, but I wonder if others are interested in quantum computers, how they might work, and what they would be useful for.</p>

<p>Added: Just for fun, let me throw out a mini-tutorial:</p>

<p>Suppose you've got N bits of memory to play with. Suppose you can load those bits (or some of them) with your input data. Then suppose there is a finite sequence of operations you can do on them (without using any additional memory) leaving the answer in them.</p>

<p>To do this with a quantum computer, it is only necessary that you make sure that the entire computation is reversible, by reserving some of the bits to record branches you took, so you can undo them. If you do that, then all the operations can be written as simple unitary matrix transformations on the N bits. (A unitary transform is a pure rotation in the N-dimensional coordinate system.) So performing the computation consists of applying a succession of pure rotations on the bit-vector.</p>

<p>If you do this, then if the N-bit vector is in a quantum computer, it can be initialized into a state where all 2^N (or fewer) possible inputs are superimposed at the same time in ""parallel universes"". Then if you do the computation, it is doing them all at the same time.</p>

<p>Now all you have to do to see if one of the inputs gives you a particular answer is to let it run to a particular state. If you halt it and examine the state, what it does is choose one of the universes at random and throw away all the rest. So what the Grover algorithm lets you do is, without halting it, accentuate the probability of the universes with the answer state. Then you run it forward, then backward, then forward, and so on for a number of iterations until the answer universe has very high probability. Then if you examine it, you have a high probability of seeing the answer you want.</p>

<p>Whew...</p>
",<computer-science><quantum-computing>,01/10/2009 16:56,431366.0,431366.0,"<p>During my Symbolic AI module at university I was asked to give a small presentation to the class on a certain subject, my subject being AI Applications. My subject in this presentation was Quantum Computing in AI.</p>

<p>If the information I write here is out-of-date/wrong/poor don't be too angry. I'm only a second-year CS student at a crappy university that is relying on his memory for most of these details.</p>

<p>The power of Quantum Computing appears to be its ability to work on things incredibly fast (due to its perceived states if I remember correctly). This will obviously completely change security, as white and black-hat hackers will jump on the opportunity to develop and stress-test the various methods of secure systems. If you're interested in Physics then this is the subject for you! If you want to read more about how Quantum Computers can be used in security by using Algorithms to factorise large numbers <a href=""http://fy.chalmers.se/~delsing/QI/Shor-JOC-97.pdf"" rel=""nofollow noreferrer"">read this paper by Peter Shor</a>.</p>

<p>Its power comes from the Qubit and a technique known as <a href=""http://en.wikipedia.org/wiki/Quantum_Interference"" rel=""nofollow noreferrer"">Quantum Interference</a>. I could spend all day talking about it, but it'd be better for you to read about the double-slit experiment to see how quantum computing works.</p>

<p>The conventional computer compromises of logic gates, whilst quantum computers have their own. As many of these computers have been built (hard-wired) to solve certain problems there are a multitude of different QLG (Quantum Logic Gates) proposed for different problems. Functionally, Quantum Networks are formed using these gates in a method known as Gate Arrays. If you require more information on this then the Ekert paper is the way to go.</p>

<p>Please note that the <em>traditional</em> way to represent the super-positions is as unit contra-variant vectors (one per Qubit) in an 2^n-dimension Hilbert space (where n is the number of Qubits). The gates are defined as rotating these <em>universes</em> and inevitably transforming the Qubit. One such gate is the <a href=""http://en.wikipedia.org/wiki/Hadamard_gate"" rel=""nofollow noreferrer"">Hadamard Gate</a>.</p>

<p>Quantum AI has a bright future, but not for a long time. Many academics see Quantum Computing as the distant future of Computing, similarly to how Charles Babbage viewed his machine. </p>

<p>Sorry if this answer got a bit out of hand.</p>
",01/10/2009 17:23,Conceptual ,"It discusses the interest in quantum computers, their potential applications (such as code-breaking and software validation), and provides a conceptual explanation of how quantum computers could be used for computations involving parallelism, superposition, and the Grover algorithm. ",Conceptual,,,,Conceptual ,
947577.0,What is a QBit and how soon can I get a quantum computer?,"<p>How soon can I get a quantum computer?  Is there any way to build a simple one?  How many years out are they for early early adopters? </p>

<p>I'd like to understand from a high level what a QBit is, how many states it can have, and what types of algorithms will work well in this arena.</p>
",<quantum-computing>,06/03/2009 22:22,947892.0,947892.0,"<p>There's been a good deal of hype about quantum computers over the last decade or two, but there a number of problems that will need to be resolved before they'll become practical. </p>

<p>Some of these are ""just"" engineering problems, like shrinking the size down from room-sized 6-qbit systems to something more like the density of an integrated circuit. Or figuring out a way to prevent thermal noise from scrambling the system, without requiring the customer to keep large stocks of liquid Nitrogen (or Helium!) on hand.</p>

<p>On the other hand, there appear to be some more fundamental problems with constructing quantum computers with large numbers of qbits.</p>

<p>Primary among these is error-correction. Part of the inherent nature of the entangled systems used for quantum computing is that they can lose ""coherence"" spontaneously. Great strides have been made in increasing the entangled lifetime, but you're still very limited in the number of operations that you can perform reliably. </p>

<p>Some techniques for error correction in quantum computations have been developed, but the last article I read on quantum EC indicated that the number of error-correcting qbits required goes up more-or-less logarithmically with the number of active qbits. Note that the initial constant factor may be quite large - it can take 5 physical qbits to represent 1 logical qbit.</p>

<p>To some extent (it remains to be seen how much), this growth in size is going to mitigate against the exponential advantage in speed that quantum computation is supposed to have over conventional computation.</p>

<p>Okay, so you can get a 6 qbit system today, which is way too small to tackle ""interesting"" problems with. Something like factoring a 2048-digit number is going to require systems with millions or billions of qbits. Sure, you'll get the answer ""instantly"", but there's no clear path to get anywhere near that level of performance using current techniques. Just loading the problem into the system would probably exceed the coherence lifetime.</p>

<p>Oh, to answer your other questions: 
I think that most folks are working with quantum storage systems with a single pair of states. In principle, most of these systems could store multiple non-overlapping states per storage unit, but I think a lot more effort is going into making the equipment work reliably at all, rather than maximizing efficiency.</p>

<p>Quantum algorithms are weird in the same way that quantum physics is. Rather than trying to explain how they work, here's an article on Shor's algorithm for factoring integers.
<a href=""http://en.wikipedia.org/wiki/Shor&#39;s_algorithm"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Shor's_algorithm</a></p>

<p>And here's a reference on the error-correction issue:
<a href=""http://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Quantum_error_correction</a></p>
",06/03/2009 23:51,Conceptual," The query specifically asks about the availability of quantum computers, the basic unit of information in quantum computing, and the types of algorithms that can be run on quantum computers.",Theoretical,"The users question is about the theoretical aspects of quantum computing, including the availability of quantum computers, building simple quantum computers, and understanding qubits and quantum algorithms. The question showcases a deep engagement with theoretical concepts and their implications in the realm of quantum computing.",No,1.0,Conceptual,"because it primarily seeks understanding on the availability of quantum computers and practical applications, aligning with discussions on the background and feasibility of quantum computing concepts."
2768807.0,Quantum Computing and Encryption Breaking,"<p>I read a while back that Quantum Computers can break most types of hashing and encryption in use today in a very short amount of time(I believe it was mere minutes). How is it possible? I've tried reading articles about it but I get lost at the <code>a quantum bit can be 1, 0, or something else</code>. Can someone explain how this relates to cracking such algorithms in plain English without all the fancy maths? </p>
",<encryption><cryptography><quantum-computing>,05/04/2010 20:37,2768918.0,2768918.0,"<p><strong>Preamble:</strong> Quantum computers are strange beasts that we really haven't yet tamed to the point of usefulness. The theory that underpins them is abstract and mathematical, so any discussion of how they can be more efficient than classical computers will inevitably be long and involved. You'll need at least an undergraduate understanding of linear algebra and quantum mechanics to understand the details, but I'll try to convey my limited understanding!</p>
<hr />
<p>The basic premise of quantum computation is <a href=""https://en.wikipedia.org/wiki/Quantum_superposition"" rel=""nofollow noreferrer"">quantum superposition</a>. The idea is that a quantum system (such as a quantum bit, or <em>qubit</em>, the quantum analogue of a normal bit) can, as you say, exist not only in the <code>0</code> and <code>1</code> states (called the <em>computational basis states</em> of the system), but also in any combination of the two (so that each has an <em>amplitude</em> associated with it). When the system is observed by someone, the qubit's state <a href=""https://en.wikipedia.org/wiki/Wavefunction_collapse"" rel=""nofollow noreferrer"">collapses</a> into one of its basis states (you may have heard of the <a href=""https://en.wikipedia.org/wiki/Schroedinger%27s_cat"" rel=""nofollow noreferrer"">SchrÃ¶dinger's cat</a> thought experiment, which is related to this).</p>
<p>Because of this, a <em>register</em> of <code>n</code> qubits has <code>2^n</code> basis states of its own (these are the states that you could observe the register being in; imagine a classical n-bit integer). Since the register can exist in a superposition of all these states at once, it is possible to apply a computation to all <code>2^n</code> register states rather than just one of them. This is called <strong>quantum parallelism</strong>.</p>
<p>Because of this property of quantum computers, it may seem like they're a silver bullet that can solve any problem exponentially faster than a classical computer. But it's not that simple: the problem is that once you observe the result of your computation, it collapses (as I mentioned above) into the result of just one of the computations â and you lose all of the others.</p>
<p>The field of quantum computation/algorithms is all about trying to work around this problem by manipulating quantum phenomena to extract information in fewer operations than would be possible on a classical computer. It turns out that it's very difficult to contrive a &quot;quantum algorithm&quot; that is faster than any possible classical counterpart.</p>
<p>The example you ask about is that of quantum cryptanalysis. It's thought that quantum computers might be able to &quot;break&quot; certain encryption algorithms: specifically, the RSA algorithm, which relies on the difficulty of finding the prime factors of very large integers. The algorithm which allows for this is called <a href=""https://en.wikipedia.org/wiki/Shor%27s_algorithm"" rel=""nofollow noreferrer"">Shor's algorithm</a>, which can factor integers with polynomial time complexity. By contrast the <a href=""https://en.wikipedia.org/wiki/General_number_field_sieve"" rel=""nofollow noreferrer"">best classical algorithm</a> for the problem has (almost) exponential time complexity, and the problem is hence considered &quot;<a href=""https://en.wikipedia.org/wiki/Computational_complexity_theory#Intractability"" rel=""nofollow noreferrer"">intractable</a>&quot;.</p>
<p>If you want a deeper understanding of this, get a few books on linear algebra and quantum mechanics and get comfortable. If you want some clarification, I'll see what I can do!</p>
<hr />
<p><strong>Aside</strong>: to better understand the idea of quantum superposition, think in terms of probabilities. Imagine you flip a coin and catch it on your hand, covered so that you can't see it. <strong>As a very tenuous analogy</strong>, the coin can be thought of as being in a superposition of the heads and tails &quot;states&quot;: each one has a probability of 0.5 (and, naturally, since there are two states, these probabilities add up to 1). When you take your hand away and observe the coin directly, it collapses into either the heads state or the tails state, and so the probability of this state becomes 1, while the other becomes 0. One way to think about it, I suppose, is a set of scales that is balanced until observation, at which point it tips to one side as our knowledge of the system increases and one state becomes the &quot;real&quot; state.</p>
<p>Of course, we don't think of the coin as a quantum system: for all practical purposes, the coin has a definite state, even if we can't see it. For genuine quantum systems, however (such as an <a href=""https://en.wikipedia.org/wiki/Particle_in_a_box"" rel=""nofollow noreferrer"">individual particle trapped in a box</a>), we can't think about it in this way. Under the <a href=""https://en.wikipedia.org/wiki/Interpretations_of_quantum_mechanics#The_Copenhagen_interpretation"" rel=""nofollow noreferrer"">conventional interpretation</a> of quantum mechanics, the particle <strong>fundamentally has no definite position</strong>, but exists in all possible positions at once. Only upon observation is its position constrained in space (though only to a limited degree; cf. <a href=""https://en.wikipedia.org/wiki/Uncertainty_principle"" rel=""nofollow noreferrer"">uncertainty principle</a>), and even this is purely random and determined only by probability.</p>
<p>By the way, quantum systems are not restricted to having just two observable states (those that do are called <a href=""https://en.wikipedia.org/wiki/Two-state_quantum_system"" rel=""nofollow noreferrer"">two-level systems</a>). Some have a large but finite number, some have a countably infinite number (such as a <a href=""https://en.wikipedia.org/wiki/Particle_in_a_box"" rel=""nofollow noreferrer"">&quot;particle in a box&quot;</a> or a <a href=""https://en.wikipedia.org/wiki/Quantum_harmonic_oscillator"" rel=""nofollow noreferrer"">harmonic oscillator</a>), and some even have an uncountably infinite number (such as a <a href=""https://en.wikipedia.org/wiki/Free_particle#Non-Relativistic_Quantum_Free_Particle"" rel=""nofollow noreferrer"">free particle</a>'s position, which isn't constrained to individual points in space).</p>
",05/04/2010 20:56,Conceptual,"The query is about the potential impact of quantum computers on cryptography, which is a complex topic that requires a conceptual understanding of quantum mechanics.",Conceptual,,,,Conceptual,
3163234.0,"Does anyone know what ""Quantum Computing"" is?","<p>In physics, its the ability for particles to exist in multiple/parallel dynamic states at a particular point in time. In computing, would it be the ability of a data bit to equal 1 or 0 at the same time, a third value like NULL[unknown] or multiple values?.. How can this technology be applied to: computer processors, programming, security, etc.?.. Has anyone built a practical quantum computer or developed a quantum programming language where, for example, the program code dynamically changes or is autonomous?</p>
",<language-agnostic><quantum-computing>,07/02/2010 04:28,3175933.0,3175933.0,"<p>I have done research in quantum computing, and here is what I hope is an informed answer.</p>

<p>It is often said that qubits as you see them in a quantum computer can exist in a ""superposition"" of 0 and 1.  This is true, but in a more subtle way than you might first guess.  Even with a classical computer with randomness, a bit can exist in a superposition of 0 and 1, in the sense that it is 0 with some probability and 1 with some probability.  Just as when you roll a die and don't look at the outcome, or receive e-mail that you haven't yet read, you can view its state as a superposition of the possibilities.  Now, this may sound like just flim-flam, but the fact is that this type of superposition is a kind of parallelism and that algorithms that make use of it can be faster than other algorithms.   It is called randomized computation, and instead of superposition you can say that the bit is in a probabilistic state.</p>

<p>The difference between that and a qubit is that a qubit can have a fat set of possible superpositions with more properties.  The set of probabilistic states of an ordinary bit is a line segment, because all there is a probability of 0 or 1.  The set of states of a qubit is a round 3-dimensional ball.  Now, probabilistic bit strings are more complicated and more interesting than just individual probabilistic bits, and the same is true of strings of qubits.  If you can make qubits like this, then actually some computational tasks wouldn't be any easier than before, just as randomized algorithms don't help with all problems.  But some computational problems, for example factoring numbers, have new quantum algorithms that are much faster than any known classical algorithm.  It is not a matter of clock speed or Moore's law, because the first useful qubits could be fairly slow and expensive.  It is only sort-of parallel computation, just as an algorithm that makes random choices is only in weak sense making all choices in parallel.  But it is ""randomized algorithms on steroids""; that's my favorite summary for outsiders.</p>

<p>Now the bad news.  In order for a classical bit to be in a superposition, it has be a random choice that is secret from you.  Once you look a flipped coin, the coin ""collapses"" to either heads for sure or tails for sure.  The difference between that and a qubit is that in order for a qubit to work as one, its state has to be secret from the rest of the physical universe, not just from you.  It has to be secret from wisps of air, from nearby atoms, etc.  On the other hand, for qubits to be useful for a quantum computer, there has to be a way to manipulate them while keeping their state a secret.  Otherwise its quantum randomness or quantum coherence is wrecked.  Making qubits at all isn't easy, but it is done routinely.  Making qubits that you can manipulate with quantum gates, without revealing what is in them to the physical environment, is incredibly difficult.</p>

<p>People don't know how to do that except in very limited toy demonstrations.  But if they could do it well enough to make quantum computers, then some hard computational problems would be much easier for these computers.  Others wouldn't be easier at all, and great deal is unknown about which ones can be accelerated and by how much.  It would definitely have various effects on cryptography; it would break the widely used forms of public-key cryptography.  But other kinds of public-key cryptography have been proposed that could be okay.  Moreover quantum computing is related to the quantum key distribution technique which looks very safe, and secret-key cryptography would almost certainly still be fairly safe.</p>
",07/04/2010 19:24,Learning,"The user questions about the practical implementation of quantum computers, quantum programming languages, and dynamic program code changes indicate a learning-oriented approach",Learning,,,,Learning,
4285281.0,Quantum tic-tac-toe with alpha-beta pruning - best representation of states?,"<p>For my AI class, I have to make a <a href=""http://en.wikipedia.org/wiki/Quantum_tic-tac-toe"" rel=""nofollow"">quantum tic-tac-toe</a> game using alpha-beta pruning.</p>

<p>I'm thinking about the best way to represent a state of the board - my first intuition is to use a sort of neighborhood matrix, that is, a 9x9 matrix, and on <code>M[i,j]</code> is the integer which represents the move in which (tic-tac-toe) squares <code>i</code> and <code>j</code> are marked (if there is no such connection - <code>M[i,j]</code> is zero). <code>M[i,i]</code> is not 0 if square <code>i</code> is collapsed. Then, I would create a game tree of such matrices and use classical minimax with alpha-beta pruning.</p>

<p>However, it seems that this approach would be quite expensive - there would be a relatively big branching factor plus the basic operations for every node - checking for cycles and finding all equivalent states for 9x9 matrix.</p>

<p>I have a feeling that there's got to be a smarter solution - maybe something along the line as seeing a quantum game as a set of classical tic-tac-toe games and use a kind of generalized minimax search, so it would all regress to a (small) set of classical tic-tac-toe problems? I can't see how that would work exactly.</p>

<p>Does anyone have experience with this (or similar) problem, and could you point me in the right direction?</p>
",<artificial-intelligence><tic-tac-toe><quantum-computing>,11/26/2010 12:27,56736568.0,56736568.0,"<p><em>If anyone is still interested in this</em></p>

<p>I ended up using two seperate data structures:</p>

<ul>
<li>classical tic-tac-toe board (3x3 matrix) for collapsed nodes</li>
<li>list of graphs for entangled nodes. Nodes of each graph are board coordinates (in a 3x3 matrix), and the graph is fully connected.</li>
</ul>

<p>When we entangle nodes A and B:</p>

<ul>
<li>if neither are in an existing graph, create a new graph [A,B] (NEW_GRAPH)</li>
<li>of one (A for example) is in an existing graph [..., A, ...] (EXISTING_GRAPH)

<ul>
<li>if B is not in an existing graph, add B to the EXISTING_GRAPH</li>
<li>if B is in an existing graph we know we closed a cycle, and we do a collapse (graphs are removed from the list, and new nodes are added to the classic board)</li>
</ul></li>
</ul>
",6/24/2019 12:25,Learning," The author seeks advice on optimizing their approach, suggesting a learning-oriented attitude aimed at acquiring a deeper understanding of how to effectively implement the game mechanics and algorithms. So its belon to Learning ",Learning,,,,Learning,
7118933.0,Need an explanation for a quantum model,"<p>When I am reading chapter 10 of Dasgupta I faced a paragraph that I can't understand:</p>

<blockquote>
  <p>An electron can be in a ground state or in an excited state. In the
  Dirac notation used in quantum physics, these are denoted 0 and 1. But
  the superposition principle says that, in fact, the electron is in a
  state that is a linear combination of these two: a0|0> + a1|1>. This
  would make immediate sense if the a's were probabilities, nonnegative
  real numbers adding to 1. But the superposition principle insists that
  they can be arbitrary complex numbers, as long as the squares of
  their norms add up to 1!</p>
</blockquote>

<p>Can someone describe me last 3 lines?</p>
",<algorithm><quantum-computing>,8/19/2011 8:33,7119177.0,7119177.0,"<p>I think the author is trying to point out a difference between the quantum model and the standard assumptions you might have about probabilities.</p>

<p>Suppose, for example, that the electron is either up or down.  In a deterministic universe, it would either be 100% up or 100% down.  If we assumed that the electron probabilistically chose to be either up or down with some probabilities, then we might say that, for example, the electron was 50% up and 50% down.</p>

<p>When using bra-ket notation for the above, you might be tempted to say that we would say that the particle is 90% up by writing</p>

<pre><code>0.5 |up&gt; + 0.5|down&gt;
</code></pre>

<p>The intuition being that the electron is simultaneously 50% up and 50% down.  However, this would be incorrect.  When dealing with quantum states, the configuration of a particle is related to something called the wavefunction, and it is the square of the wavefunction that determines probabilities, not the wavefunction itself.  Thus if we wanted to write out a quantum state where a particle has a 50% chance of being up and a 50% chance of being down, we'd represent that as</p>

<p>0.707 |up> + 0.707 |down></p>

<p>Since 0.707 is about the square root of 0.5, so if we square the coefficients assigned to up and down we get back the classical probabilities.  As long as the squares of the coefficients sum to one, the coefficients are legal since their square gives back a probability distribution.</p>

<p>Of course, it's actually a bit trickier than this.  The coefficients in quantum states can be complex numbers as well.  For example, this is a perfectly legal quantum configuration:</p>

<pre><code>(0.707 + 0.707i) |up&gt; + 0 |down&gt;
</code></pre>

<p>Here, the coefficient for up is a complex number.  To get the probability of seeing up, we compute the complex conjugate of the coefficient:</p>

<pre><code>(0.707 + 0.707i)(0.707 - 0.707i) = (0.5 + 0.5) = 1
</code></pre>

<p>So in this case the probability of seeing up is 1 and the probability of seeing down is 0^2 = 0.  Since this sums to one, this is a valid quantum state.</p>

<p>To summarize: a probability distribution is a way of assigning real-valued weights to outcomes so that the weights sum to one.  A quantum state is a way of assigning complex-valued weights to outcomes so that the sum of the product of each coefficient with it's complex conjugate is one.</p>

<p>Phew!  Haven't had to think about that in a while!  Hope this helps!</p>
",8/19/2011 8:54,Theoretical ,"because it discusses the fundamental concepts of quantum computing, such as the superposition principle and Dirac notation, and their implications for the representation of quantum states. The last three lines describe how the superposition principle allows for arbitrary complex numbers to be used as coefficients in a linear combination of quantum states, as long as the squares of their norms add up to",Theoretical,,,,Theoretical ,
7218189.0,Turing complete and parallel programming (true concurrency),"<p>I often see people say if you can do X in some language you can do Y in another language which is the Turing Complete argument. So You'll have often (usually in a snide comment) ""sure you can do t with y because y is also Turing complete.</p>

<p>I took CS theory a long time ago but I don't think this is always true because I'm not sure where Turing fits into concurrency. For example there are programming languages with the right hardware you can execute things to happen exactly at the same time but others where that is not possible.</p>

<p>I understand this is probably more of a hardware/driver issue than the language but I'm curious if or how does concurrency change what it is to be Turing Complete? Can be you be more than Turing Complete?</p>

<p><strong>EDIT:</strong>
The <a href=""https://stackoverflow.com/questions/7218189/turing-complete-and-parallel-programming-true-concurrency#comment10337778_8372860"">original reason</a> that I asked this question was in large part due to quantum computing. Although the accepted answer doesn't say this <a href=""http://en.wikipedia.org/wiki/Quantum_Turing_machine"" rel=""nofollow noreferrer"">but quantum computing is (ostensible) a subset of turing</a>.</p>
",<concurrency><theory><quantum-computing>,8/28/2011 0:10,7218362.0,7218362.0,"<p>This is a confusing topic for many people; you're not alone.  The issue is that there are two different definitions of ""possible"" in play here.  One definition of ""possible"" is how you're using it: is it possible to do concurrency, is it possible to operate a giant robot using the language, is it possible to make the computer enjoy strawberries, etc.  This is the layman's definition of ""possible"".</p>

<p>Turing completeness has nothing to do with what's possible in the above sense.  Certainly, concurrency isn't possible everywhere because (for at least some definition of concurrency) it needs to be the case that the language can produce code that can run on two or more different processors simultaneously.  A language that can only compile to code that will run on a single processor thus would not be capable of concurrency.  It could still be Turing-complete, however.</p>

<p>Turing completeness has to do with the <em>kinds of mathematical functions</em> that can be computed on a machine given enough memory and running time.  For purposes of evaluating mathematical functions, a single processor can do everything multiple processors can because it can emulate multiple processors by executing one processor's logic after the other.  The (unproven and unprovable, though <em>falsifiable</em>) statement that all mathematical functions that could be computed on any device are computable using a Turing machine is the so-called <strong>Church-Turing thesis</strong>.</p>

<p>A programming language is called <strong>Turing-complete</strong> if you can prove that you can emulate any Turing machine using it.  Combining this with the Church-Turing thesis, this implies that the programming language is capable of evaluating every type of mathematical function that any device could evaluate, given enough time and memory.  Most languages are Turing-complete because this only requires the capacity to allocate dynamic arrays and use loops and if-statements as well as some basic data operations.  </p>

<p>Going in the other direction, since a Turing machine can be constructed to emulate any processor we currently know of and programming languages do what they do using processors, no current programming language has more expressive power than a Turing machine, either.  So the computation of mathematical functions is equally possible across all common programming languages.  Functions computable in one are computable in another.  This says nothing about <em>performance</em> - concurrency is essentially a performance optimization.</p>
",8/28/2011 0:52,Conceptual,"because it discusses the background and underlying concepts of quantum programming, such as the relationship between Turing completeness and concurrency, and how this applies to quantum computing. The text also inquires about the possibility of being more than Turing complete .",Conceptual,,,,Conceptual,
9672369.0,floor and ceil from QCL (Quantum Computer Language),"<p>I'm working on QCL and some questions came up about internal functions.
I'd like to know what the operators <code>floor(something)</code> and <code>ceil(something)</code> are.
I know they are related to math operations, but what do they do exactly?</p>
",<operators><quantum-computing><qcl>,03/12/2012 18:04,9672397.0,9672397.0,"<p>Floor removes the decimal point, ceil turns the decimal part into .9999 repeating if it's already there (which is the same as a whole number).</p>

<p>So floor(4.6) loses the .6, ceil(4.6) becomes 4.9999... or 5. Also, ceil(5.0) will return 5, as the decimal part is 0.</p>
",03/12/2012 18:06,Tooling,"because it pertains to questions related to tools and software usage in quantum programming. The floor() and ceil() functions are mathematical functions that round a given number down or up to the nearest integer, respectively .",Learning,The statement is asking for information to learn about the exact functionalities and behaviors of the functions floor() and ceil() in the context of the QCL programming language.,No,2.0,Tooling,"because it addresses questions related to specific functions within a programming language, aligning with discussions on tools and software usage in quantum programming."
9894420.0,"Operator ""measure"" in QCL (Quantum Computing Language)","<p>It's been a while since I got into QCL but I ran into some difficulties by trying to figure out the functioning of <code>measure regX</code> or <code>measure regX,m</code>.</p>

<p>What does this do on the quantum registers? And the <code>m</code> integer?</p>
",<quantum-computing><qcl>,3/27/2012 17:17,9926184.0,9926184.0,"<p>In Bernhard's Ãmer PhD thesis Structured Quantum Programming, in Appendix A.3.1.4 clearly states that
<code>measure regX</code> -- performs measurement on register <code>regX</code> and 
<code>measure regX,m</code> -- performs measurement on register <code>regX</code> and writes the result of the measurement to classical variable <code>m</code>.</p>

<p>If you do not understand the model behind quantum measurement it is difficult to fully understand what QCL does. But roughly speaking measurement chooses randomly one of the basis quantum states which spans the  quantum superposition in which <code>regX</code> is and writes it to variable <code>m</code>.</p>
",3/29/2012 13:20,Tooling,because it is a question about the use of specific tools and software for quantum programming. The query specifically asks about the purpose of the <code>measure</code> function in QCL.,Learning," The users question is about learning how to use the measure command in QCL, specifically what it does on quantum registers and how the optional integer m works.",No,3.0,Learning,"as it seeks information to understand the functionality of the ""measure"" command in QCL, aligning with inquiries related to learning resources and understanding the features of a quantum programming language."
12567514.0,Quantum computers and algorithm performance,"<p>I have a question. Gradually quantum computers will emerge someday. So, nowadays making algorithm efficient is important; I mean, making it optimal to run as fast as possible. But once quantum PC emerges does the algorithm performance improvements are still important?
Cheers</p>
",<algorithm><quantum-computing>,9/24/2012 14:52,12567721.0,12567721.0,"<p>Quantum algorithms have the possibility of searching a complete number space for an answer in one go, that much is true. However, the algorithm you choose will still determine how many of these steps are needed, and whether you can pack the whole space with useful inputs.</p>
",9/24/2012 15:02, Conceptual,because it is a discussion about the potential impact of quantum computers on the development of algorithms. The query specifically asks whether algorithm performance improvements will still be important once quantum computers are available.,Conceptual,,,, Conceptual,
13774439.0,Generalization of the Deutsch algorithm,"<p>This problem concerns a straightforward generalization of the Deutsch problem discussed for functions with more than one bit as input. This time, we have a Boolean function f that takes a 4-bit number as input and outputs 0 or 1, i.e., <code>f:{0,1}4â{0,1}</code>. Thus, an input to f is one of 16 possible 4 bit binary numbers:</p>

<pre><code>0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111.
</code></pre>

<p>We are also told that f is one of the following two types:</p>

<pre><code>either f is a constant function, i.e., f(x) is the same for all 16 possible values of the input x, or
f is a balanced function, i.e., f(x) is 0 for exactly 8 of the possible 16 inputs and f(x) is 1 for the remaining 8 of the possible 16 inputs.
</code></pre>

<p>we are allowed to do is to use the circuit for f as a ""black box"" by giving an input x to the circuit for f and observing the output f(x). This is called a ""query"" operation.</p>

<p>Show that a classical probabilistic algorithm can determine if f is balanced or constant with probability at least 2/3 by using 2 queries.</p>

<p><strong>Hint:</strong> (Obviously, we cannot do this using a deterministic algorithm. Unless the deterministic algorithm sees the output for at least 9 input values, there is no way for it to find out if the function is balanced or constant).</p>

<p>Think about picking the two inputs uniformly and randomly from the set of 16 possible inputs. Your final result could depend probabilistically on the result of these two queries.</p>
",<algorithm><probability><quantum-computing>,12/08/2012 04:20,13775208.0,13775208.0,"<p><strong>EDIT:</strong> I had calculated some of my probabilities wrongly.  Also I've now mentioned that we need to randomly pick 2 distinct inputs for the function f in order to guarantee that, if f is balanced, then we know the probabilities of seeing the various possible outcomes.</p>

<p>The fact that the prior probability of the function being constant is not known makes this question harder, because it means we can't directly calculate the probability of success for any algorithm.  We will, however, be able to calculate <em>bounds on</em> this probability.</p>

<p>I propose the following probabilistic algorithm:</p>

<ul>
<li>Pick two distinct 4-bit values at random, and supply each to the function f.</li>
<li>If 0,0 or 1,1 is seen, output ""constant"" with probability 2/3 and ""balanced"" with probability 1/3.</li>
<li>Otherwise (if 0,1 or 1,0 is seen), always report ""balanced"".</li>
</ul>

<p>Let's start by looking at something we can actually calculate: conditional probabilities.</p>

<ol>
<li><strong>""What is P(correct|constant), namely the probability that our algorithm gives the correct answer given that f is constant?""</strong>  When f is constant, our algorithm reports the right answer 2/3 of the time.</li>
<li><strong>""What is P(correct|balanced), namely the probability that our algorithm gives the correct answer given that f is balanced?""</strong>  When f is balanced, the probability of seeing 0,1 or 1,0 is 2*(8/16 * 8/15) = 8/15, in which case the correct answer will definitely be output.  In the remaining 7/15 of cases -- i.e. those in which 0,0 or 1,1 is seen -- the correct answer will be output 1/3 of the time, so the total proportion of correct outputs will be 8/15 * 1 + 7/15 * 1/3 = 31/45 = 2/3 + 1/45 â 0.6889.</li>
</ol>

<p>Now suppose that the prior probability of the function being constant is p.  Then the probability that the algorithm gives the correct answer is</p>

<p>pCorrect(p) = p*P(correct|constant) + (1-p)*P(correct|balanced).</p>

<p>Given that 0 &lt;= p &lt;= 1, pCorrect(p) must be at least min(P(correct|constant), P(correct|balanced)), and at most max(P(correct|constant), P(correct|balanced)).  The minimum of 2/3 and 31/45 is 2/3, <strong>thus pCorrect is bounded from below at 2/3, for any prior probability of the function being constant.</strong>  (It might help to think of p as a ""mixing lever"" that controls how much of each term to include.  If p = 0 or p = 1, then we effectively just have P(correct|balanced) or P(correct|constant), respectively, and for any in-between value of p, we will have an in-between total.)</p>
",12/08/2012 06:41,Learning,.The author presents a problem related to quantum algorithms and the analysis of probabilistic algorithms to determine whether a given Boolean function is constant or balanced.The request for hints and guidance demonstrates a learning-oriented approach to acquiring knowledge and problem-solving skills in this context., Learning,,,,Learning,
22417091.0,Is quantum assignment possible?,"<p>I once was talking to my programming teacher about quantum computers, and I remember him telling me that one limitation of these kind of machines would be that you can't actually do something like <code>x = y</code>. I was wondering <strong><em>why is quantum assignment impossible?</em></strong> Does anyone have a clear answer?</p>
",<quantum-computing>,3/14/2014 22:44,23526675.0,23526675.0,"<p>Your teacher was referring to the fact that all <a href=""http://en.wikipedia.org/wiki/Quantum_operation"" rel=""nofollow"">quantum operations</a> are reversible, because they are unitary transformations. They can be undone. Since assignment can't be undone, it's not a unitary transformation and therefore can't be done by a quantum computer.</p>

<p>But! Our universe runs on quantum mechanics, so how can classical computers do assignment?</p>

<p>Well, if you have a bunch of qubits you <em>know</em> are zero, then you can swap them into your variable. This clears the variable, and now you can add in the value you want to be there. This process is reversible, and acts like assignment. It decreases your supply of known-to-be-zero qubits, but until the sun goes out we can make a steady supply of those.</p>

<p>That being said, the garbage you are swapping away affects how things interfere with each other. So quantum algorithms often include steps to get rid of this garbage by undoing part of an operation while keeping the result, or else they won't work.</p>
",05/07/2014 19:30,Conceptual,"The query is about the fundamental concepts of quantum computing, such as quantum bits and quantum superposition.",Conceptual,,,,Conceptual,
23155937.0,How Will Register Transfer work in a Quantum computer ?,"<p>If i am not wrong a qbit can have any value from 0 to 1 at any given time , But if you are moving some data from a register to another in a quantum computer how will we know what state will be transferred , to the register ? </p>
",<cpu-registers><cpu-architecture><quantum-computing>,4/18/2014 14:13,24505572.0,24505572.0,"<p>The <a href=""https://en.wikipedia.org/wiki/No-cloning_theorem"" rel=""nofollow"">no-cloning theorem</a> says it's not possible to copy quantum states (pure or mixed). If you want a copy, you have to measure the qubits, collapsing them to classical information, and then copying that - but you loose almost all the information encoded in the system and you're left with normal 0's and 1's.</p>

<p>However, it is possible to transfer a state using <a href=""https://www.youtube.com/watch?v=3wZ35c3oYUE&amp;list=PL1826E60FD05B44E4&amp;index=18"" rel=""nofollow"">quantum teleportation</a> - it destroys the original quantum state and re-creates it in another qubit using a classical information channel and a shared <a href=""https://en.wikipedia.org/wiki/Bell_state"" rel=""nofollow"">Bell state</a>. But it is not exactly clear how this can be useful in a single processor as you could just use <a href=""https://en.wikipedia.org/wiki/Register_renaming"" rel=""nofollow"">register renaming</a> to the same effect (with a classical computer controlling the quantum processor, you can just tell it to start calling a certain physical qubit by some other name and achieve the same result).</p>
",07/01/2014 08:21,Conceptual,The author is inquiring about the behavior of qubits during data transfer between quantum registers and how the state of the transferred data is determined. The focus is on understanding the conceptual aspects of qubit behavior and data manipulation in quantum computing.,Conceptual,,,,Conceptual,
23326921.0,Factoring a quantum state,"<p>I'm looking for algorithms that take an arbitrary quantum state made up of a sum of weighted classical states made up of bits, like this:</p>

<pre><code>|0000&gt;/2 - |0011&gt;/2 + |0100&gt;/2 - |0111&gt;/2
</code></pre>

<p>and factor it into a more compact form using tensor products, like this:</p>

<pre><code>|0&gt; x (|0&gt; + |1&gt;) x (|00&gt; - |11&gt;) / 2
</code></pre>

<p>I want to use the algorithm as a way of visualizing/simplifying the state of a (simulated) quantum circuit.</p>

<p>For individual qubits I know I can just pair all the states with the state where the bit is flipped and check that every pair has the same x:y relation between the states. In the example above, flipping the second bit always gives you a state with a 1:1 weighting, so the second bit factors out as (1|0> + 1|1>).</p>

<p>But extending that approach to detect entangled bits (like the third and fourth in the example) causes it to take at least <code>Î©(n^c)</code> time (probably more, I haven't thought it all the way through), where <code>n</code> is the number of states and <code>c</code> is the number of entangled bits. Since <code>n</code> is already growing exponentially with the number of bits that's... not ideal.</p>

<p>Are there better algorithms? Representations easier to factor from/to? How useful is changing the basis? Links to papers would be great.</p>
",<algorithm><factorization><quantum-computing>,4/27/2014 17:55,23327816.0,23327816.0,"<p>It looks like an efficient algorithm is going to be hard:</p>
<p>From <a href=""http://en.wikipedia.org/wiki/Separable_state#Separability_criterion"" rel=""nofollow noreferrer"">wikipedia</a>:</p>
<blockquote>
<p>The problem of deciding whether a state is separable in general is
sometimes called the separability problem in quantum information
theory. It is considered to be a difficult problem. It has been shown
to be NP-hard.</p>
<p>Gurvits, L., Classical deterministic complexity of Edmondsâ problem and quantum entanglement, in Proceedings of the 35th ACM Symposium on Theory of Computing, ACM Press, New York, 2003.</p>
<p>Sevag Gharibian, Strong NP-Hardness of the Quantum Separability Problem, Quantum Information and Computation, Vol. 10, No. 3&amp;4, pp. 343-360, 2010. arXiv:0810.4507</p>
</blockquote>
",4/27/2014 19:17,Theoretical,because it is a question about the design and analysis of algorithms. The query specifically asks to design an algorithm that can factor a quantum state into a more compact form using tensor products.,Theoretical,,,,Theoretical,
23456180.0,Quantum Fourier Transform code for 3 qbits,"<h2>Background</h2>

<p>I came across a Javascript quantum simulator and was trying to write the code (i.e. the quantum circuit) to implement a 3 qbit Quantum Fourier transform.</p>

<p>The closest I could get is shown below:
<img src=""https://i.stack.imgur.com/NUZVY.png"" alt=""QFT result""></p>

<p>This is based on the chapter on the QFT from ""Quantum Computation and Quantum Information"" by Nielsen and Chuang.  (The Conditional NOT gates at the end of the circuit are intended to swap the output bits into the correct order - the QFT reverses the order of the bits.)</p>

<p>I also tried a circuit based on the <a href=""http://en.wikipedia.org/wiki/Quantum_Fourier_transform"" rel=""nofollow noreferrer"">wikipedia QFT article</a>, but got no closer to the answer.</p>

<h2>Question</h2>

<p>Can anyone help correct my algorithm to compute the QFT?</p>

<p>(I think it is most likely that the bug is in my circuit, but I guess it is also possible that there is an error in the underlying Javascript implementation?)</p>
",<javascript><algorithm><fft><quantum-computing>,05/04/2014 12:24,23526480.0,23526480.0,"<p>The reason the circuit from wikipedia isn't working is because the provided phase gates are turning clockwise instead of counter-clockwise (e.g. -45 degrees instead of +45 degrees). The circuit on Wikipedia (and probably the text book too) is using an R_(pi/2) gate, but you have an R_(-pi/2) gate.</p>

<p>There are several ways to deal with the issue:</p>

<ul>
<li>Simulate the +45 degree gate using a Z (-180), -90, and -45. Similar idea for the +90.</li>
<li>Turn the circuit upside down, so the gates on wire 1 now are on wire 3 after, and vice versa.</li>
<li>Move the swapping part (the last three X gates) from the end to the start</li>
<li>Reverse the order of all the gates except for the three Xs at the end.</li>
<li>(I think) Apply exactly three of the above.</li>
<li>Probably a bunch more ways. Figuring out why each one works is interesting.</li>
</ul>

<p>Sorry the backwards phases were confusing. (It's actually my circuit simulator, which I wrote for a <a href=""http://strilanc.com/quantum/2014/03/07/Building-your-own-Quantum-Fourier-Transform.html"" rel=""nofollow"">blog post that includes a solution</a>.)</p>
",05/07/2014 19:20,Tooling,The author is seeking help with correcting their implementation of a quantum circuit for a 3-qubit Quantum Fourier Transform using a JavaScript quantum simulator. The discussion is centered around practical implementation details and potential issues in the circuit., Learning,"The question involves acquiring knowledge about quantum computing, specifically how to implement a 3 qubit Quantum Fourier Transform using a quantum circuit.",No,4.0,Tooling,"as it pertains to practical implementation details and potential issues in the circuit using a JavaScript quantum simulator, aligning with discussions related to tools and software usage in quantum programming."
23898636.0,Qbits can be both states but how and where is the manual?,"<p>So scouring the Internet attempting to find as much as i can on Quantum Computing and Qbits. </p>

<p>It seems perhaps even with Google's purchase of the D:Wave and the somewhat increasing speak of Quantum computing, that there is still terribly little information or references for much surrounding the concept.</p>

<p>I am interested in directly to understand how a Quantum Computer is constructed, the components, the logical theory and exactly how a Qbit can be a 1 or 0, or both 1 &amp; 0 at the same time. </p>
",<quantum-computing>,5/27/2014 20:46,23976127.0,23976127.0,"<p><a href=""http://www.feynmanlectures.caltech.edu/III_01.html"" rel=""nofollow noreferrer"">Volume 3</a> of the <a href=""http://www.feynmanlectures.info/"" rel=""nofollow noreferrer"">Feynman Lectures on Physics</a>, one of the great Physics textbooks of the last century, is available online for free.</p>

<p>After you get comfortable with this, you can graduate to <a href=""https://rads.stackoverflow.com/amzn/click/com/1107002176"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Nielsen &amp; Chuang</a>.</p>
",06/01/2014 02:01,Learning,"The query reflects a desire to understand the fundamental concepts and construction of quantum computers, including the nature of qubits and their ability to exist in superposition states. It seeks information and references to gain a comprehensive understanding of quantum computing principles.",Learning,,,,Learning,
26742818.0,Solve ode in python with complex matrix as initial value,"<p>I have a von Neumann equation which looks like:
<em>dr/dt = - i [H, r]</em>, where r and H are square matricies of complex numbers and I need to find r(t) using python script.</p>

<p><strong><em>Is there any standart instruments to integrate such equations?</em></strong></p>

<p>When I was solving another aquation with a vector as initial value, like Schrodinger equation:
<em>dy/dt = - i H y</em>, I used scipy.integrate.ode function ('zvode'), but trying to use the same function for von Neumann equation gives me the following error:</p>

<pre><code>**scipy/integrate/_ode.py:869: UserWarning: zvode: Illegal input detected. (See printed message.)
ZVODE--  ZWORK length needed, LENZW (=I1), exceeds LZW (=I2)
self.messages.get(istate, 'Unexpected istate=%s' % istate))
  In above message,  I1 =        72   I2 =        24**
</code></pre>

<p>Here is the code:</p>

<pre><code>def integrate(r, t0, t1, dt):
  e = linspace(t0, t1, (t1 - t0) / dt + 10)
  g = linspace(t0, t1, (t1 - t0) / dt + 10)
  u = linspace(t0, t1, (t1 - t0) / dt + 10)
  while r.successful() and r.t &lt; t1:
    r.integrate(r.t + dt)
    e[r.t / dt] = abs(r.y[0][0]) ** 2
    g[r.t / dt] = abs(r.y[1][1]) ** 2
    u[r.t / dt] = abs(r.y[2][2]) ** 2
  return e, g, u


# von Neumann equation's
def right_part(t, rho):
  hamiltonian = (h / 2) * array(
    [[delta, omega_s, omega_p / 2.0 * sin(t * w_p)],
    [omega_s, 0.0, 0.0],
    [omega_p / 2.0 * sin(t * w_p), 0.0, 0.0]],
    dtype=complex128)
  return (dot(hamiltonian, rho) - dot(rho, hamiltonian)) / (1j * h)


def create_integrator():
  r = ode(right_part).set_integrator('zvode', method='bdf', with_jacobian=False)
  psi_init = array([[1.0, 0.0, 0.0],
                   [0.0, 0.0, 0.0],
                   [0.0, 0.0, 0.0]], dtype=complex128)
  t0 = 0
  r.set_initial_value(psi_init, t0)
  return r, t0


def main():
  r, t0 = create_integrator()
  t1 = 10 ** -6
  dt = 10 ** -11
  e, g, u = integrate(r, t0, t1, dt)

main()
</code></pre>
",<python><numpy><scipy><ode><quantum-computing>,11/04/2014 18:53,26747232.0,26747232.0,"<p>I have created a wrapper of <a href=""http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html"" rel=""nofollow noreferrer""><code>scipy.integrate.odeint</code></a> called <a href=""https://github.com/WarrenWeckesser/odeintw"" rel=""nofollow noreferrer""><code>odeintw</code></a> that can handle complex matrix equations such as this.  See <a href=""https://stackoverflow.com/questions/26580854/how-to-plot-the-eigenvalues-when-solving-matrix-coupled-differential-equations-i/26582411#26582411"">How to plot the Eigenvalues when solving matrix coupled differential equations in PYTHON?</a> for another question involving a matrix differential equation.</p>

<p>Here's a simplified version of your code that shows how you could use it.  (For simplicity, I got rid of most of the constants from your example).</p>

<pre><code>import numpy as np
from odeintw import odeintw


def right_part(rho, t, w_p):
    hamiltonian = (1. / 2) * np.array(
        [[0.1, 0.01, 1.0 / 2.0 * np.sin(t * w_p)],
        [0.01, 0.0, 0.0],
        [1.0 / 2.0 * np.sin(t * w_p), 0.0, 0.0]],
        dtype=np.complex128)
    return (np.dot(hamiltonian, rho) - np.dot(rho, hamiltonian)) / (1j)


psi_init = np.array([[1.0, 0.0, 0.0],
                     [0.0, 0.0, 0.0],
                     [0.0, 0.0, 0.0]], dtype=np.complex128)


t = np.linspace(0, 10, 101)
sol = odeintw(right_part, psi_init, t, args=(0.25,))
</code></pre>

<p><code>sol</code> will be a complex numpy array with shape <code>(101, 3, 3)</code>, holding the solution <code>rho(t)</code>.  The first index is the time index, and the other two indices are the 3x3 matrix.</p>
",11/04/2014 23:46,Tooling, because it is a question about the use of specific tools and software for quantum computing. The query specifically asks about the availability of tools for integrating the von Neumann equation.,Tooling,,,,Tooling,
30605526.0,Integration not successful in Python QuTiP,"<p>I have been trying to use QuTiP to solve a quantum mechanics matrix differential equation (a Lindblad equation). Here is the code:</p>

<pre><code>from qutip import *
from matplotlib import *
import numpy as np

hamiltonian = np.array([[215, -104.1, 5.1, -4.3  ,4.7,-15.1 ,-7.8 ],
[-104.1,  220.0, 32.6 ,7.1, 5.4, 8.3, 0.8],
      [ 5.1, 32.6, 0.0, -46.8, 1.0 , -8.1, 5.1],
     [-4.3, 7.1, -46.8, 125.0, -70.7, -14.7, -61.5],
       [ 4.7, 5.4, 1.0, -70.7, 450.0, 89.7, -2.5],
    [-15.1, 8.3, -8.1, -14.7, 89.7, 330.0, 32.7],
     [-7.8, 0.8, 5.1, -61.5,  -2.5, 32.7,  280.0]])
H=Qobj(hamiltonian)
ground=Qobj(np.array([[ 0.0863685 ],
  [ 0.17141713],
  [-0.91780802],
  [-0.33999268],
  [-0.04835763],
  [-0.01859027],
  [-0.05006013]]))

rho0 = ground*ground.dag()
from scipy.constants import *
ktuple=physical_constants['Boltzmann constant in eV/K']
k = ktuple[0]* 8065.6
htuple = physical_constants['Planck constant in eV s'] 
hbar = (htuple[0]* 8065.6)/(2*pi)
gamma=(2*pi)*((k*300)/hbar)*(35/(150*hbar))

L1 = Qobj(np.array([[1,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]))
L2 = Qobj(np.array([[0,0,0,0,0,0,0],[0,1,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]))
L3 = Qobj(np.array([[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]))
L4 = Qobj(np.array([[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,1,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]))
L5 = Qobj(np.array([[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]]))
L6 = Qobj(np.array([[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,1,0],[0,0,0,0,0,0,0]]))
L7 = Qobj(np.array([[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,1]]))
#Since our gamma variable cannot be directly applied onto the Lindblad operator, we must multiply it with the collapse operators:

L1=gamma*L1
L2=gamma*L2
L3=gamma*L3
L4=gamma*L4
L5=gamma*L5
L6=gamma*L6
L7=gamma*L7

options = Options(nsteps=100000)

results = mesolve(H, rho0, np.linspace(0.0, 1000, 20),[L1,L2,L3,L4,L5,L6,L7],[],options=options)
print results
</code></pre>

<p>This code is supposed to solve the following equation:</p>

<p><img src=""https://i.stack.imgur.com/x2X0Z.gif"" alt=""Lindblad equation""></p>

<p>where L_i are matrices (in the list: [L1,L2,L3,L4,L5,L6,L7]), H is the hamiltonian, another matrix, <img src=""https://i.stack.imgur.com/TeKxt.gif"" alt=""$\rho$""> is the density matrix, and <img src=""https://i.stack.imgur.com/C2zjo.gif"" alt=""$\gamma$""> is a constant equal to <img src=""https://i.stack.imgur.com/JaFwh.gif"" alt=""$2\pi  kT/\hbar*E_{R}/(\hbar\omega_{c})$""> where T is the temperature, k is the Boltzmann constant, and <img src=""https://i.stack.imgur.com/BYYcG.gif"" alt=""$\hbar$ = $h/2\pi$"">, where h is Planck's constant.</p>

<p>Every time I run the code, it gives me the following error:</p>

<pre><code>ZVODE--  At T (=R1) and step size H (=R2), the
       corrector convergence failed repeatedly
       or with abs(H) = HMIN
      In above,  R1 =  0.0000000000000D+00   R2 =  0.1202322246215D-36
/usr/local/lib/python2.7/dist-packages/scipy/integrate/_ode.py:853: UserWarning: zvode: Repeated convergence failures. (Perhaps bad Jacobian supplied or wrong choice of MF o
r tolerances.)
  'Unexpected istate=%s' % istate))
Traceback (most recent call last):
  File ""lindbladqutip.py"", line 48, in &lt;module&gt;
    results = mesolve(H, rho0, np.linspace(0.0, 1000, 20),[L1,L2,L3,L4,L5,L6,L7],[],options=options)
  File ""/projects/d6138712-e5f4-4d85-9d4d-77ce0a7b4a61/.local/lib/python2.7/site-packages/qutip/mesolve.py"", line 264, in mesolve
    progress_bar)
  File ""/projects/d6138712-e5f4-4d85-9d4d-77ce0a7b4a61/.local/lib/python2.7/site-packages/qutip/mesolve.py"", line 692, in _mesolve_const
    return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar)
  File ""/projects/d6138712-e5f4-4d85-9d4d-77ce0a7b4a61/.local/lib/python2.7/site-packages/qutip/mesolve.py"", line 866, in _generic_ode_solve
    raise Exception(""ODE integration error: Try to increase ""
Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.
</code></pre>

<p>After doing some debugging analysis, it seems like the first or second integration fails. The error tells me to increase the nsteps parameter, which I have tried. Even then it fails. Changing the list of times (the np.linspace function makes the list of times) also has no effect. </p>

<p>I am desperate to know what I can do to fix this error. Please comment if you all need more details.</p>

<p>Thanks for all your help!</p>
",<python><numpy><scipy><integrate><qutip>,06/02/2015 20:02,30609096.0,30609096.0,"<p>From a programming point of view, the problem appears to be your value of <code>gamma</code> and therefore the size of your collapse operators.  Print out <code>gamma</code> - it is of the order <code>10**25</code> - this seems to be what is preventing the solver from converging.</p>

<p>Just for testing (I'm an engineer, not a quantum physicist...), I put in a smaller value of <code>gamma</code> (e.g. 0.1), the solver seems to work and gives apparently reasonable output in <code>results.states</code></p>

<p>I don't quite understand your <code>gamma</code> - it <em>seems</em> to have units of cm<sup>-1</sup>s<sup>-2</sup> as you have set it up.  I wonder if you only want to divide by <code>hbar</code> once, maybe.  As I say, I'm not a quantum physicist, so I'm only guessing here based on what makes the programming hang together combined with a bit of dimensional analysis.</p>

<p><strong><em>EDIT</em></strong></p>

<p>OP indicates in comments that the wrong order of magnitude / units for <code>gamma</code> does seem to be the programming issue (i.e. preventing numerical calculus from converging), but isn't totally clear on how to calculate gamma.  At this stage, it may be worth posting a question at either <a href=""http://physics.stackexchange.com"">http://physics.stackexchange.com</a> or <a href=""http://math.stackexchange.com"">http://math.stackexchange.com</a> about that - referencing this one for context if necessary.</p>

<p><strong><em>EDIT 2</em></strong></p>

<p>I note you asked this <a href=""https://physics.stackexchange.com/questions/187734/messed-up-units"">related question on the physics site</a>.  This makes it clear where <a href=""http://arxiv.org/pdf/0807.0929v2.pdf"" rel=""nofollow noreferrer"">the expression for gamma comes from</a> and thereby clarifies that the constant terms presented as simply <code>30</code> and <code>150</code> in this question actually have units (Energy and frequency respectively).  This changes the dimensional analysis - the units of gamma are s<sup>-1</sup> or, with appropriate conversion, cm<sup>-1</sup>.</p>

<p>It also shows the value you mention in comments - 300 cm<sup>-1</sup>.</p>
",06/03/2015 01:00,Errors,"The user is encountering an error while trying to use QuTiP to solve a Lindblad equation involving matrix differential equations. The error message suggests an issue with the ODE integration and provides advice to increase the 'nsteps' parameter in the 'Options' class, but the user's attempts to address the error have been unsuccessful.", Errors,,,,Errors,
32037970.0,From an application programmer's perspective - Can Functional Programming be used to program Quantum Computers?,"<p>I'm not an expert in Functional Programming (FP). In fact, I just started learning it.</p>

<p>So, here is the real question: Since, FP is derived from Mathematics and not from von. Neumann machine, can this programming style/paradigm be used to program Quantum Computers? This is more from an application programmer's perspective since low-level machine instructions may be completely different.</p>
",<functional-programming><quantum-computing>,8/16/2015 17:27,32038459.0,32038459.0,"<p>No. Functional programs still perform classical computation. The functional style as we currently define it has nothing resembling superposition, quantum mechanical gates, or interference. While it is possible to transport the general idea of higher-order and first-class functions into the realm of quantum computation (and people are researching that right now), just as there are quantum Turing machines, as far as I can tell the results are as different from classical functional programming as quantum algorithms are from classical algorithms. For example, in QML <code>if ... then ... else ...</code> is removed in favor of a similar conditional where the condition is a <em>qbit</em> and the result is a superposition of the <code>then</code> and <code>else</code> values.</p>

<p>Now, of course quantum computers are Turing-complete and could, in theory, execute any classical algorithm. But why on earth would you do that? We already have classical computers, and they are (and will always be) <strong>much</strong> more efficient at executing classical computations. The only reason to program a quantum computer is to make it run an algorithm that exploits in a nontrivial way the weirdness of quantum effects. To even express that, one needs a very different language regardless of the level of abstraction at which you work.</p>
",8/16/2015 18:24,Conceptual,because it is a question about the fundamental concepts of functional programming and quantum computing. The query specifically asks whether the programming style of functional programming can be applied to the design and implementation of quantum computers.,Learning,The user is inquiring about the applicability of functional programming to quantum computing and whether it can be used to program quantum computers.,No,5.0,Conceptual,"as it explores the fundamental concepts of functional programming and quantum computing, aligning with discussions on understanding the background and underlying concepts of quantum programming"
32084867.0,Shor's quantum 9 bit code,"<p>Regarding Shor's quantum 9 bit error correction code,
is the code corrects any error on any single qbit? Or is it corrects only a phase or a bit flip? How can i verify that?</p>
",<error-correction><quantum-computing>,8/19/2015 0:58,32096955.0,32096955.0,"<p>Shor's 9-qubit code can correct against any single qubit error, as is explained e.g. in <a href=""https://cs.uwaterloo.ca/~watrous/CPSC519/LectureNotes/16.pdf"" rel=""nofollow"">these lecture notes</a>. You can verify this by e.g. checking the quantum error correction condition for the two codewords.</p>
",8/19/2015 13:30,Learning,The user is inquiring about the capabilities of Shor's 9-qubit quantum error correction code and how to verify its ability to correct errors. This suggests that the user is still learning about the topic and is seeking knowledge and understanding.,Learning,,,,Learning,
32150192.0,IndexError for scientific Python code,"<p>I have been working on some code that does integration, some manipulation, and then more integration.
Here is the <a href=""https://chat.stackoverflow.com/transcript/message/25087985#25087985"">code</a> (thanks @JRichardSnape!).
Basically this code solves a matrix equation, which is what <code>mesolve</code> does. It takes in a Hamiltonian (a key physical matrix), an initial density matrix, <code>rho0</code>, and a tlist of times to evaluate rho(t) at (what we are solving for) and the collapse operators, <code>L1, L2, L3, L4, L5, L6, L7</code>. Then I extract the results and multiply by two other arrays and plot it. </p>

<p>I use the qutip quantum mechanics module since they have the solver I need: <code>mesolve</code>. The qutip module requires all matrices to be converted into a quantum object, which is done by Qobj(x).</p>

<p>I have added a line defining rho0=L1 right after the collapse operators definition. When this happens, it gives me an Index error:</p>

<pre><code>IndexError: index 0 is out of bounds for axis 0 with size 0
</code></pre>

<p>I have tried to find out what is wrong. It goes wrong during the definition of f_t. The problem is when it is trying to index the array (n.data is a single element array of a complex128 number). What is going on?</p>
",<python><numpy><scipy><qutip>,8/21/2015 22:33,32151245.0,32151245.0,"<p>This reproduces your error:</p>

<pre><code>In [34]: data = np.zeros((0,10))    
In [35]: data
Out[35]: array([], shape=(0, 10), dtype=float64)

In [36]: data[0]
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&lt;ipython-input-36-88cae4a5bf31&gt; in &lt;module&gt;()
----&gt; 1 data[0]

IndexError: index 0 is out of bounds for axis 0 with size 0
</code></pre>

<p>Without delving to the the linked code, it is clear that the array in question has a 0 length 1st dimension.  <code>x.shape[0]</code> is 0.</p>

<p>You might get such an array be indexing another with an empty list,</p>

<pre><code>In [44]: data=np.ones((3,4))

In [45]: data[[],...]
Out[45]: array([], shape=(0, 4), dtype=float64)
</code></pre>

<p>With the limited information you give it's hard to be more specific.  Check the shape of all the suspected arrays.</p>

<hr>

<p>So <code>Qobj</code> is documented in <a href=""http://qutip.org/docs/2.2.0/apidoc/classes.html"" rel=""nofollow noreferrer"">http://qutip.org/docs/2.2.0/apidoc/classes.html</a></p>

<p>and <code>mesolve</code> in <a href=""http://qutip.org/docs/2.2.0/apidoc/functions.html#qutip.mesolve.mesolve"" rel=""nofollow noreferrer"">http://qutip.org/docs/2.2.0/apidoc/functions.html#qutip.mesolve.mesolve</a></p>

<p>and <code>rho0</code> is expected to be <code>rho0 : qutip.qobj</code>.</p>

<p>The underlying array for <code>ground</code> is a <code>(7,1)</code> shape, for <code>L1</code> (the problem <code>rho0</code>?) is <code>(7,7)</code> and all 0's except for [0,0].</p>

<p>Looks like this is a spin off of <a href=""https://stackoverflow.com/questions/30605526/integration-not-successful-in-python-qutip"">Integration not successful in Python QuTiP</a></p>
",8/22/2015 0:59,Errors, because it is a question about an error that the user is getting while running their code. The query specifically asks about the IndexError that the user is getting when they try to define rho0=L1., Errors,,,,Errors,
32179640.0,Install Qutip on Mac os x 10.10 via MacPorts,"<p>I am not sure whether i can ask this question here. </p>

<p>I tried to install QuTips on my mac osx 10.10. Am following these two documentation for installation <a href=""http://qutip.org/docs/3.1.0/installation.html"" rel=""nofollow"">Qutip</a> and <a href=""http://guide.macports.org/#installing.macports.source"" rel=""nofollow"">MacPorts</a>. Now am struggle to install gcc49.</p>

<p>When i execute this command <code>sudo port install py34-scipy</code> I got the following error</p>

<pre><code>    Admins-iMac-2:base admin$ sudo port install py27-scipy
---&gt;  Computing dependencies for py27-scipy
The following dependencies will be installed: 
 gcc49
 py27-numpy
 swig
 swig-python
Continue? [Y/n]: y
---&gt;  Building gcc49
Error: Failed to build gcc49: command execution failed
Error: See /opt/local/var/macports/logs/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/main.log for details.
Error: Follow http://guide.macports.org/#project.tickets to report a bug.
Error: Processing of port py27-scipy failed
Admins-iMac-2:base admin$ sudo port install py34-numpy
---&gt;  Computing dependencies for py34-numpy
The following dependencies will be installed:  gcc49
Continue? [Y/n]: y
---&gt;  Building gcc49
Error: Failed to build gcc49: command execution failed
Error: See /opt/local/var/macports/logs/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/main.log for details.
Error: Follow http://guide.macports.org/#project.tickets to report a bug.
Error: Processing of port py34-numpy failed
Admins-iMac-2:base admin$ vi /opt/local/var/macports/logs/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/main.log
Admins-iMac-2:base admin$ 
</code></pre>

<p>I go and look for <code>main.log</code> file. At the end of this file i got below errors</p>

<pre><code>:info:build gcc/vtable-verify.o differs
:info:build make[2]: *** [compare] Error 1
:info:build make[2]: Leaving directory `/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/work/build'
:info:build make[1]: *** [stage3-bubble] Error 2
:info:build make[1]: Leaving directory `/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/work/build'
:info:build make: *** [bootstrap] Error 2
:info:build make: Leaving directory `/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/work/build'
:info:build Command failed:  cd ""/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/work/build"" &amp;&amp; /usr/bin/make -j4 -w bootstrap
:info:build Exit code: 2
:error:build Failed to build gcc49: command execution failed
:debug:build Error code: CHILDSTATUS 2595 2
:debug:build Backtrace: command execution failed
:debug:build     while executing
:debug:build ""system {*}$notty {*}$nice $fullcmdstring""
:debug:build     invoked from within
:debug:build ""command_exec build""
:debug:build     (procedure ""portbuild::build_main"" line 8)
:debug:build     invoked from within
:debug:build ""$procedure $targetname""
:debug:build Registry error: gcc49 not registered as installed &amp; active.
:debug:build     invoked from within
:debug:build ""registry_active $subport""
:debug:build     invoked from within
:debug:build ""$workername eval registry_active \$subport""
:error:build See /opt/local/var/macports/logs/_opt_local_var_macports_sources_rsync.macports.org_release_tarballs_ports_lang_gcc49/gcc49/main.log for details.
</code></pre>

<p>Am not familiar with this. I cannot complete installation without this <code>gcc49</code>. Alternatively i install gcc48, but dosen't work for me. Every time it automatically tried ti install gcc49. </p>

<p>Anybody have any suggestion, it will be really appreciated.</p>
",<osx-yosemite><macports><qutip>,8/24/2015 10:07,32217471.0,32217471.0,"<p>I can answer my question</p>

<p>run <code>sudo port clean gcc49</code>, then try again</p>
",8/26/2015 3:22,Errors,The user is encountering errors while trying to install QuTiP on macOS using MacPorts. They are specifically facing issues with installing 'gcc49' and are seeking help to resolve these errors. The question involves troubleshooting installation problems and understanding the error logs.,  Errors,,,,Errors,
32221331.0,Can exponentially long bitstrings be stored in (and retrieved from) qubits reliably?,"<p><strong>The background:</strong></p>

<p>I recently read that quantum compression can be used to turn N qubits into lgN qubits (<a href=""http://www.scientificamerican.com/article/quantum-bits-compressed-for-the-first-time/"" rel=""nofollow"">http://www.scientificamerican.com/article/quantum-bits-compressed-for-the-first-time/</a>, inferred from the line ""1 million qubits squeezed into 20""), and that piqued my curiosity about whether or not classical information could be:</p>

<pre><code>1) converted from a bitstring to qubits,
2) compressed to lg(N) of its original size,
3) sent over a quantum network,
4) decompressed, and
5) converted from qubits to a bitstring
</code></pre>

<p>(this seems way too good to be true.)</p>

<p><strong>The questions:</strong></p>

<p>Can bitstrings be stored in (and retrieved from) qubits reliably?</p>

<p>Could transmission of any size N file be improved from Î(N) to an average (not worst case) below Î(N) when either qubits or bits can be sent over the network?</p>

<p><strong>Additional comments:</strong></p>

<p>Even if sending classical information through a quantum network is possible, I realize it might not be reliable since quantum computers have some probability of returning any answer.</p>

<p>Additionally, several checksums would have to be sent through a classical network to examine the validity of the decompressed information.</p>
",<compression><quantum-computing>,8/26/2015 8:16,32249551.0,32249551.0,"<p>Quantum compression <a href=""http://algorithmicassertions.com/quantum/2014/12/25/Quantum-Compression.html"" rel=""nofollow"">only works on permutation-invariant sets of qubits</a>, which is a very strict condition that prevents it from being useful for much of anything.</p>

<p>In general you can't squash <code>n</code> bits of entropy into fewer than <code>n</code> qubits. This was proven all the way back in 1973 and is known as <a href=""https://en.wikipedia.org/wiki/Holevo&#39;s_theorem"" rel=""nofollow"">Holevo's theorem</a>:</p>

<blockquote>
  <p>given n qubits, although they can ""carry"" a larger amount of (classical) information (thanks to quantum superposition), the amount of classical information that can be retrieved, i.e. accessed, can be only up to n classical (non-quantum encoded) bits.</p>
</blockquote>

<p>Some interesting related facts:</p>

<ul>
<li>If you have pre-shared entanglement, you can double the capacity. With <code>n</code> pre-shared bell pairs between a sender and receiver, you can use <a href=""https://en.wikipedia.org/wiki/Superdense_coding"" rel=""nofollow"">superdense coding</a> to pack <code>2n</code> bits into <code>n</code> transmitted qubits (the already-transmitted bell pair parts play the role of the other <code>n</code> qubits).</li>
<li>What if you only want to get <code>n</code> bits out, but <em>different</em> bits in different situations? Can we make an exponentially huge dictionary with linearly sized entries? Nope: <a href=""http://blog.computationalcomplexity.org/2003/07/quantum-advice.html"" rel=""nofollow"">quantum advice</a> is not more space-efficient than classical advice.</li>
<li>What if you used quantum compression to send <code>2^n</code> identical copies of <code>a|0&gt; + b|1&gt;</code>, and then  the receiver statistically inferred <code>a</code> based on how many 0s they measured? Is this roundabout way of sending real numbers more efficient? Nope: the standard deviation of the statistic (~1/sqrt(2^n)) is worse than the precision you get from sending <code>n</code> bits of binary (1/2^n).</li>
</ul>
",8/27/2015 12:33,Theoretical ,"Basically belong to Quantum Computing and Information Theory:because It involves exploring the feasibility and potential benefits of using quantum compression techniques to store and transmit classical information via qubits. While theoretical advancements have been made, practical implementation and reliability considerations remain challenges, including the need for error correction and classical communication for validation.[But also belong to Theoretical category of quantum programming. they are inquiring about the reliability of storing and retrieving bitstrings in qubits, and whether transmission of any size N file can be improved from ?(N) to an average (not worst case) below ?(N) when either qubits or bits can be sent over the network. The question involves understanding the theoretical concepts and principles of quantum computing",Learning,"The user is inquiring about the possibility of using quantum compression to convert, compress, transmit, decompress, and retrieve classical information using qubits and a quantum network.",No,6.0,Theoretical,as it involves exploring the feasibility and potential benefits of using quantum compression techniques to store and transmit classical information via qubits. 
35523214.0,Error trying to install QCL (Quantum Computation Language) on Mac 10.11,"<p>I am trying to install QCL-0.6.4 from <a href=""http://tph.tuwien.ac.at/~oemer/qcl.html"" rel=""nofollow noreferrer"">this source</a>, but I keep getting errors, when I try it with the <code>make</code> command in the terminal.</p>

<p>I came along <a href=""https://stackoverflow.com/questions/7905898/how-to-install-quantum-computation-language-on-mac-os-x"">this thread about installing QCL on OSX</a>, but when trying to adjust the Makefile I always come across this errors:</p>

<pre><code>extern.cc:84:18: error: variable length array of non-POD element type     'tComplex'
  (aka 'complex&lt;double&gt;')
 tComplex u[dim][dim];
             ^
extern.cc:193:9: error: variable length array of non-POD element type 'term'
 term t[dim];
    ^
extern.cc:224:9: error: variable length array of non-POD element type 'term'
 term t[dim];
</code></pre>

<p>Any help on this would be highly appreciated.</p>
",<macos><quantum-computing><qcl>,2/20/2016 12:25,35600419.0,35600419.0,"<p>There are a few issues at play here which you need to overcome to get this compiling on OSX. My instructions below assume that you are running on El Capitan (10.11.1 in my instance), but you may get some milage out of them for different versions.</p>

<p>Firstly, Xcode currently uses Apple's LLVM Compiler as the default C++ compiler. However, this doesn't support some of GCC's extensions, such as support for non-POD variable length arrays.</p>

<p>To get around this, I installed and compile with GCC: if you haven't already, install <a href=""http://brew/sh"">Homebrew</a>, and then install the latest GCC compiler with:</p>

<pre><code>$ brew install gcc
</code></pre>

<p>At the time of writing, this will install GCC v5.2.0.
That should fix your initial problem, but you will instantly hit others!</p>

<p>The next issue is that the included libqc.a will need recompiling for x86_64. So you will need to modify the file <code>&lt;base_dir&gt;/qc/Makefile</code> with the following changes:</p>

<pre><code>...
# Add:
CXX = /usr/local/Cellar/gcc/5.2.0/bin/g++-5
CXXFLAGS = $(ARCHOPT) -c -pedantic -Wall $(DEBUG) $(PRGOPT)
...
</code></pre>

<p>Then rebuild <code>libqc.a</code>:</p>

<pre><code>$ cd qc; make clean; make
</code></pre>

<p>If all goes well, you should have a shiny new <code>libqc.a</code>.</p>

<p>Finally, modify the main Makefile <code>&lt;base_dir&gt;/Makefile</code> with the following changes:</p>

<pre><code>...
# Comment out:
#PLOPT = -DQCL_PLOT
#PLLIB = -L/usr/X11/lib -lplotter
...
# Comment out:
#RLOPT = -DQCL_USE_READLINE
#RLLIB = -lreadline
#RLLIB = -lreadline -lncurses
...
# Comment out:
#CXX = g++
#CPP = $(CC) -E
#CXXFLAGS = -c $(ARCHOPT) $(DEBUG) $(PLOPT) $(RLOPT) $(IRQOPT) $(ENCOPT) -I$(QCDIR) -DDEF_INCLUDE_PATH=""\""$(QCLDIR)\""""
#LDFLAGS = $(ARCHOPT) -L$(QCDIR) $(DEBUG) $(PLLIB) -lm -lfl -lqc $(RLLIB) 

# Add:
CXX = /usr/local/Cellar/gcc/5.2.0/bin/g++-5
CPP = $(CC) -E
CXXFLAGS = -c $(ARCHOPT) $(DEBUG) $(PLOPT) $(RLOPT) $(IRQOPT) $(ENCOPT) -I$(QCDIR) -DDEF_INCLUDE_PATH=""\""$(QCLDIR)\""""
LDFLAGS = $(ARCHOPT) -L$(QCDIR) $(DEBUG) $(PLLIB) -lm -ll -lqc $(RLLIB) -lc++
...
</code></pre>

<p>This should now allow you to build the main application as per the instructions:</p>

<pre><code>$ make clean; make; make install
</code></pre>
",2/24/2016 11:07,Errors,"it involves seeking solutions and explanations for compilation errors encountered while attempting to install the QCL-0.6.4 software. The user is encountering errors related to variable length arrays of non-POD (Plain Old Data) element types, which is a technical issue requiring troubleshooting and resolution.", Errors,,,,Errors,
37043093.0,do you know about IBM's quantum computing platform?,"<p>I really just want to know who know's about this platform so I can understand the standards of sharing and publishing projects and code in the open source space, so, who's heard of this: <a href=""http://www.research.ibm.com/quantum/"" rel=""nofollow noreferrer"">http://www.research.ibm.com/quantum/</a></p>

<p><a href=""https://i.stack.imgur.com/amMfs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/amMfs.png"" alt=""enter image description here""></a></p>
",<quantum-computing>,05/05/2016 05:31,37194930.0,37194930.0,"<p>The ""code"" is all in quantum gates (like bitwise operators on qubits) so I don't see how IBM could claim ownership of it. They use a graphical notation, but it gets evaluated to text you could share. The real question is what would be the purpose of that? Do you have access to another quantum computer to run them on? Or even a simulator? The point of the IBM project is to let you evaluate rather standard quantum algorithms since the results are probabilistic. If you're designing more efficient quantum algorithms that would probably be more appropriate for publication in a peer-reviewed physics journal than sharing in an open source programming community...</p>
",05/12/2016 18:36,Tooling,"The question seeks information about the standards of sharing and publishing projects and code in the open source space specifically related to the IBM Quantum platform. This pertains to the category of ""Tooling,"" which involves questions related to tools, software usage, and platforms in the quantum programming field.",Tooling,,,,Tooling,
37594782.0,What is the rationale behind black-box quantum circuit?,"<p>I've read some material about quantum computers and quantum circuits. A certain number of already known algorithms (Simon's algorithm, period-finding algorithm, Grover's algorithm, â¦) have the following form:</p>

<blockquote>
  <p><em>Suppose I have an unknown classical function f: {0,1}^n -> {0, 1}^m satisfying a certain number of statements. I can associate the (unknown) quantum circuit U_f to it and plug the |0.. 0> input state. Now let us define circuit X and show that when appended to U_f, the global output can be measured to extract some information about f.</em></p>
</blockquote>

<p>Wait a minute... What is the relation with classical circuits? A classical problem would refer to an <strong>unknown input</strong> that satisfies certain properties, this input representing a state coming from outside (user action, file system, database, server, whatever). In case this state is rather generated by another circuit/algorithm the logic applies to the input before. In the end we don't reason about unknown circuits but about unknown inputs. The circuits (the algorithms/ the functions) are the known/chosen components.</p>

<p>Here I came to realize that the common name ""circuit"" was somehow misleading. In a classical world gate inputs can be thought as values coexisting with outputs. But quantum gates seem to require a temporal interpretation: inputs and outputs represent temporal evolution of the same qubits.</p>

<p>Now this does not really explain how you transform a given bunch of a priori unknown classical input bits (that I believe your keyboard will keep on generating in the future except maybe if SchrÃ¶dinger's cat is sitting on it) into a ""black box quantum circuit"" transforming |0â¦0> into something to be reversed. For example Grover's algorithm propose, for a quantum circuit corresponding to a function f: {0, 1}^n -> {0, 1} that yields 1 for a single unknown input, an efficient method to determine this input. Nice! But how and why would you have to start with such a circuit in the first place?</p>
",<quantum-computing>,06/02/2016 14:30,37601129.0,37601129.0,"<p>In practice, the 'unknown function black box' is just a circuit that checks if its input meets some criteria or is the solution to a problem.</p>

<p>This is useful because it's easier to make a circuit that detects a solution than it is to actually find a solution. Grover's algorithm then augments our detector circuit into a solver circuit:</p>

<p><a href=""https://i.stack.imgur.com/ohl5q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ohl5q.png"" alt=""Grover Search""></a></p>

<hr>

<p>The classical equivalent of Grover's algorithm is a brute-force search function like this:</p>

<pre><code>def bruteForceSearch(min, max, predicate):
    for i in min..max:
        if predicate(i):
            return i
    return none
</code></pre>

<p>which you would use it like so:</p>

<pre><code>let mersennePrimeWithFiveDigitExponent = bruteForceSearch(
     10000,
     99999,
     i =&gt; isMersennePrime(2**i - 1))
</code></pre>

<p>Notice how the brute force search turns our knowledge of how to <em>recognize</em> something into a mechanism for <em>finding</em> something. Grover's algorithm does the same thing, but quadratically faster and with the caveat that the recognizer must be implemented as a reversible circuit.</p>
",06/02/2016 20:04,Conceptual,"because it is a question about the fundamental concepts of quantum computing. The query specifically asks about the relationship between classical and quantum circuits, and how to create a quantum circuit from an unknown classical input.",Conceptual,,,,Conceptual,
39769073.0,Quantum computing simulation in QASM,"<p>I am using <a href=""http://www.research.ibm.com/quantum/"" rel=""nofollow"">IBM's Quantum Experience</a> and I have a small problem. Dragging and dropping the gates takes a while, and they don't have a Toffoli gate. So I have to redrag in the gates that construct the Toffoli gate and it takes a while. </p>

<p>The composer takes in QASM files, so I tried to look up documentation for it, and some kind of editor for it (my thinking was I could more quickly type than drag, and I could copy and paste). However, I didn't find very much. The only thing I found was <a href=""http://www.media.mit.edu/quanta/qasm2circ/"" rel=""nofollow"">this reference</a> to a package for it which converts the code into circuit diagrams. The code syntax appears significantly different, and I don't think that's what I want.</p>

<p>So I have two questions:</p>

<ol>
<li>Is there any editor for this so I can put files in .qasm format?</li>
<li>Is there any documentation for this?</li>
</ol>

<p>Thanks! Any help would be appreciated.</p>

<p><strong>EDIT</strong>: I also found <a href=""http://www.media.mit.edu/quanta/quanta-web/projects/qasm-tools/"" rel=""nofollow"">this</a> and <a href=""https://github.com/losalamos/qasm"" rel=""nofollow"">this</a>, but I'm not sure if either are right. To make it even more confusing, the second link makes it seem like there are two kinds of QASM, and I'm not sure which one IBM uses.</p>
",<assembly><quantum-computing><resourcereference>,9/29/2016 11:30,42614410.0,42614410.0,"<p>It seems that QASM is the process of being renamed, so many of the links are broken.  You can find the Open Quantum Assembly Language spec at this github location:</p>

<p><a href=""https://github.com/IBM/qiskit-openqasm/tree/master/"" rel=""nofollow noreferrer"">https://github.com/IBM/qiskit-openqasm/tree/master/</a></p>

<p>The date in the PDF is January 2017.</p>
",03/05/2017 21:41,Tooling,"The query is about the use of a specific tool or software.it pertains to inquiries about tools, software usage, and editors related to IBM's Quantum Experience platform. The user is seeking information about editors for working with QASM files and documentation about the format.",Tooling,,,,Tooling,
39821543.0,Convert from qubit density matrix to Bloch vector,"<p>Given the 2x2 density matrix of a qubit, how do I compute the point on the <a href=""https://en.wikipedia.org/wiki/Bloch_sphere"" rel=""nofollow"">Bloch sphere</a> that represents the qubit?</p>

<p>For example, the state <code>|0â©-|1â©</code> has a density matrix of <code>[[0.5,-0.5],[-0.5,0.5]]</code> and should end up along the X axis. But the density matrix <code>[[0.5, 0], [0, 0.5]]</code> isn't biased in any direction and should end up at the origin.</p>
",<quantum-computing><qubit>,10/02/2016 20:46,39821544.0,39821544.0,"<p>The conversion depends on a couple arbitrary choices:</p>

<ul>
<li>Do you want |0â© at the top or the bottom?</li>
<li>Do you want the coordinate system to be right-handed or left-handed?</li>
</ul>

<p>Assuming you answer those with ""at the bottom"" and ""right-handed"", then this method will do it:</p>

<pre class=""lang-python prettyprint-override""><code>def toBloch(matrix):
    [[a, b], [c, d]] = matrix
    x = complex(c + b).real
    y = complex(c - b).imag
    z = complex(d - a).real
    return x, y, z
</code></pre>

<p>You switch to other choices by picking and choosing which outputs to negate.</p>

<p>Testing it out:</p>

<pre class=""lang-python prettyprint-override""><code>print(toBloch([[1, 0],
               [0, 0]])) #Off, Z=-1
# (0.0, 0.0, -1.0)

print(toBloch([[0, 0],
               [0, 1]])) #On, Z=+1
# (0.0, 0.0, 1.0)

print(toBloch([[0.5, 0.5],
               [0.5, 0.5]])) #On+Off, X=-1
# (-1.0, 0.0, 0.0)

print(toBloch([[0.5, 0.5j],
               [-0.5j, 0.5]])) #On+iOff, Y=-1
# (0.0, -1.0, 0.0)

print(toBloch([[0.5, 0.0],
               [0.0, 0.5]])) #maximally mixed state, X=Y=Z=0
# (0.0, 0.0, 0.0)
</code></pre>
",10/02/2016 20:46,Theoretical,"The user is seeking an understanding of the mathematical relationship between the density matrix of a qubit and its representation on the Bloch sphere, involving theoretical concepts of quantum mechanics.",Theoretical,,,,Theoretical,
39821888.0,Convert from qubit operation to axis-angle Bloch sphere rotation,"<p>Given the 2x2 unitary matrix representation of an operation to apply to a single qubit, how do I figure out the rotation it corresponds to on the <a href=""https://en.wikipedia.org/wiki/Bloch_sphere"" rel=""nofollow noreferrer"">Bloch sphere</a>?</p>

<p>For example, the Hadamard matrix is a 180 degree rotation around the X+Z axis. How do I get from <code>[[1,1],[1,-1]]*sqrt(0.5)</code> to <code>(X+Z, 180 deg)</code>?</p>
",<quantum-computing>,10/02/2016 21:29,39821889.0,39821889.0,"<p>Single-qubit operations are basically just <a href=""https://en.wikipedia.org/wiki/Versor"" rel=""nofollow noreferrer"">unit quaternions</a>, but with an extra phase factor. The similarity is because the <a href=""https://en.wikipedia.org/wiki/Pauli_matrices"" rel=""nofollow noreferrer"">Pauli matrices</a>, times <code>sqrt(-1)</code>, satisfy the <code>i^2=j^2=k^2=ijk=-1</code> relation that defines quaternions.</p>

<p>As a result, the hard part of the conversion method is already taken care of by any ""quaternion to axis angle"" code. Just pull out the phased quaternion components, figure out the phase factor, then apply the quaternion-to-angle-axis method.</p>

<pre class=""lang-python prettyprint-override""><code>import math
import cmath

def toBlochAngleAxis(matrix):
    """"""
    Breaksdown a matrix U into axis, angle, and phase_angle components satisfying
    U = exp(i phase_angle) (I cos(angle/2) - axis sigma i sin(angle/2))

    :param matrix: The 2x2 unitary matrix U
    :return: The breakdown (axis(x, y, z), angle, phase_angle)
    """"""
    [[a, b], [c, d]] = matrix

    # --- Part 1: convert to a quaternion ---

    # Phased components of quaternion.
    wp = (a + d) / 2.0
    xp = (b + c) / 2.0j
    yp = (b - c) / 2.0
    zp = (a - d) / 2.0j

    # Arbitrarily use largest value to determine the global phase factor.
    phase = max([wp, xp, yp, zp], key=abs)
    phase /= abs(phase)

    # Cancel global phase factor, recovering quaternion components.
    w = complex(wp / phase).real
    x = complex(xp / phase).real
    y = complex(yp / phase).real
    z = complex(zp / phase).real

    # --- Part 2: convert from quaternion to angle-axis ---

    # Floating point error may have pushed w outside of [-1, +1]. Fix that.
    w = min(max(w, -1), +1)

    # Recover angle.
    angle = -2*math.acos(w)

    # Normalize axis.
    n = math.sqrt(x*x + y*y + z*z);
    if n &lt; 0.000001:
        # There's an axis singularity near angle=0.
        # Just default to no rotation around the Z axis in this case.
        angle = 0
        x = 0
        y = 0
        z = 1
        n = 1
    x /= n
    y /= n
    z /= n

    # --- Part 3: (optional) canonicalize ---

    # Prefer angle in [-pi, pi]
    if angle &lt;= -math.pi:
        angle += 2*math.pi
        phase *= -1

    # Prefer axes that point positive-ward.
    if x + y + z &lt; 0:
        x *= -1
        y *= -1
        z *= -1
        angle *= -1

    phase_angle = cmath.polar(phase)[1]

    return (x, y, z), angle, phase_angle
</code></pre>

<p>Testing it out:</p>

<pre class=""lang-python prettyprint-override""><code>print(toBlochAngleAxis([[1, 0], [0, 1]])) # Identity
# ([0, 0, 1], 0, 0.0)

print(toBlochAngleAxis([[0, 1], [1, 0]])) # Pauli X, 180 deg around X
# ([1.0, -0.0, -0.0], 3.141592653589793, 1.5707963267948966)

print(toBlochAngleAxis([[0, -1j], [1j, 0]])) # Pauli Y, 180 deg around Y
# ([-0.0, 1.0, -0.0], 3.141592653589793, 1.5707963267948966)

print(toBlochAngleAxis([[1, 0], [0, -1]])) # Pauli Z, 180 deg around Z
# ([-0.0, -0.0, 1.0], 3.141592653589793, 1.5707963267948966)

s = math.sqrt(0.5)
print(toBlochAngleAxis([[s, s], [s, -s]])) # Hadamard, 180 deg around X+Z
# ([0.7071067811865476, -0.0, 0.7071067811865476], 3.141592653589793, 1.5707963267948966)

print(toBlochAngleAxis([[s, s*1j], [s*1j, s]])) # -90 deg X axis, no phase
# ((1.0, 0.0, 0.0), -1.5707963267948966, 0.0)
</code></pre>
",10/02/2016 21:29,Theoretical,"The user is inquiring about the mathematical relationship between a given unitary matrix representation of a quantum operation and the corresponding rotation on the Bloch sphere, involving theoretical concepts of quantum mechanics and the geometry of the Bloch sphere.",Theoretical,,,,Theoretical,
41211487.0,Logic error - incorrect answer given,"<h2>Summary</h2>

<p>I'm writing a program to simulate an ideal quantum computer in python 3.</p>

<p>Right now, I'm working on adding two-qubit functionality, and I finally got it to the point where I could actually run it (and then I got promptly hit by a bug). Now, I've worked out a lot of kinks but the program isn't giving the right answer for one of the qubits.</p>

<h2>Problem</h2>

<p>In a nutshell, the program isn't performing any operations on the second qubit, it's only doing stuff to the first, which makes me think there's a problem with the way the program is looping through everything, but I've stared at it for a while and can't find anything wrong. </p>

<p>Running the MWE, the output should be</p>

<pre><code>your result is [ 0.70710678+0.j -0.70710678+0.j] qubit # 1
probability of |0&gt; state is 0.5
probability of |1&gt; state is 0.5

your result is [0 1] qubit # 2
probability of |0&gt; state is 0
probability of |1&gt; state is 1
=&gt; None
</code></pre>

<p>The output should have the second qubit's result and probabilities the same as the first state. Also note that for both qubits, their original state is <code>[0 1]</code> - in other words, the second qubit's state isn't being changed at all.</p>

<h2>MWE</h2>

<pre><code>import numpy as np
import cmath

qubits = 2
done = ""n""
qstats = {key:np.array([0,1]) for key in range(1,qubits+1)}

def hadop(qstat):
    matrix = (1/cmath.sqrt(2))*np.array([[1,1],[1,-1]])
    return np.dot(matrix, qstat)

def probability(qstat, n):
    if n == 0:
        return np.abs((qstat[0]))**2
    elif n == 1:
        return np.abs((qstat[1]))**2

singates = {""Hadamard"":hadop}

commands = {1:[""Hadamard""],2:[""Hadamard""]}
qubitnum=1
while qubitnum &lt;= qubits:
    for index,gate in enumerate(commands[qubitnum]):
        qstat = qstats[index+1]
        qstat = singates[gate](qstat)
        qstats[index+1] = qstat
        if index+1 == len(commands[qubitnum]):
            print("" "")
            print(""your result is"", qstats[qubitnum], ""qubit #"", qubitnum)
            print(""probability of |0&gt; state is"", probability(qstats[qubitnum],0))
            print(""probability of |1&gt; state is"", probability(qstats[qubitnum],1))
    qubitnum+=1
</code></pre>

<h2>The Full Code</h2>

<p>main-file.py:</p>

<pre><code>import numpy as np
from random import randint
import cmath
import math
from function import *

qubits = int(input(""How many qubits would you like to use? (Currently, only supports 1): ""))
done = ""n""
qstatask = input(""Would you like your initial qubits to be in the |0&gt; state or |1&gt; state? 0 or 1: "")
if qstatask == ""0"":
    qstats = {key:np.array([0,1]) for key in range(1,qubits+1)}
elif qstatask == ""1"":
    qstats = {key:np.array([1,0]) for key in range(1,qubits+1)}
else:
    print(""I'm sorry, that is not a valid input. State set to zero."")
    qstats = {key:np.array([0,1]) for key in range(1,qubits+1)}

singates = {""Hadamard"":hadop, ""X"":xop, ""Z"":zop, ""Y"":yop, ""sqrtX"":sqrtxop,""phase shift"":phaseshiftop,""measurement"":measurement,""custom"":customop, ""control"":control, ""target"":target}
twgates = [""cNOT"", ""swap""]
thrgates = [""Toffoli""]

print(singates.keys())
print(twgates)
print(thrgates)

while done == ""n"":
    if qubits == 1:
        fstgat = input(""what gate would you like to use? use the list of single gates at the top: "")
        if fstgat in singates:
            qstat = qstats[1]
            qstat = singates[fstgat](qstat)
            qstats[1] = qstat
            done = input(""Done with your circuit? y or n: "")
        else:
            print(""sorry, that gate is not yet implemented. maybe try custom gate."")
            done = ""y""
    elif qubits &gt;= 2:
        commands = {}
        for i in range(1,qubits+1):
            commands[i] = []
        qubitnum=1
        while qubitnum &lt;= qubits:
            while done == ""n"":
                fstgat = input(""what gate would you like to use for "" + str(qubitnum) + "" qubit? Use the list of single qubits at the top, plus control or target: "")
                commands[qubitnum].append(fstgat)
                done = input(""Done with your "" + str(qubitnum) + "" qubit? y or n: "")
            qubitnum+=1
            done = ""n""
        qubitnum=1
        while qubitnum &lt;= qubits:
            for index,gate in enumerate(commands[qubitnum]):
                if gate in singates:
                    if gate != ""target"" or (gate == ""target"" and mem1 in globals()):
                        qstat = qstats[index+1]
                        qstat = singates[gate](qstat)
                        qstats[index+1] = qstat
                        print(""done with a calculation"")
                        if index+1 == len(commands[qubitnum]):
                            print("" "")
                            print(""your result is"", qstats[qubitnum], ""qubit #"", qubitnum)
                            print(""probability of |0&gt; state is"", probability(qstats[qubitnum],0))
                            print(""probability of |1&gt; state is"", probability(qstats[qubitnum],1))
                    else:
                        print(""checking for information"")
                else:
                    print(gate, "" has not yet been implemented. Maybe try the custom gate?"")
                    break
            qubitnum+=1
        print(""Program complete."")
        done = ""y""
    else:
        print(""sorry, that functionality is not yet implemented"")
        done = ""y""
</code></pre>

<p>function.py:</p>

<pre><code>import cmath
import numpy as np
import math
from random import randint

def hadop(qstat):
    matrix = (1/cmath.sqrt(2))*np.array([[1,1],[1,-1]])
    return np.dot(matrix, qstat)

def xop(qstat):
    matrix = np.array([[0,1],[1,0]])
    return np.dot(matrix,qstat)

def zop(qstat):
    matrix = np.array([[1,0],[0,-1]])
    return np.dot(matrix,qstat)

def yop(qstat):
    matrix = np.array([[0, cmath.sqrt(-1)],[-1*cmath.sqrt(-1),0]])
    return np.dot(matrix,qstat)

def sqrtxop(qstat):
    const1 = 1+cmath.sqrt(1)
    const2 = 1-cmath.sqrt(1)
    matrix = np.array([[const1/2,const2/2],[const2/2,const1/2]])
    return np.dot(matrix,qstat)

def phaseshiftop(qstat):
    phasepos = [math.pi/4, math.pi/2]
    print(phasepos)
    x = input(""Please pick one of the two phase shifts, 0 for the first, 1 for the second: "")
    if x == ""0"":
        y = phasepos[0]
    elif x == ""1"":
        y = phasepos[1]
    const1 = cmath.sqrt(-1)*y
    matrix = np.array([[1,0],[0,math.e**const1]])
    return np.dot(matrix,qstat)

def customop(qstat):
    num1 = float(input(""Please input a number (no pi, e, etc) for the first number in your matrix (row 1 column 1): ""))
    num2 = float(input(""Number for matrix - row 1 column 2: ""))
    num3 = float(input(""Number for matrix - row 2 column 1: ""))
    num4 = float(input(""Number for matrix - row 2 column 2: ""))
    matrix = np.array([[num1,num3],[num2,num4]])
    matrix2 = matrix.conj().T
    result = np.dot(matrix, matrix2)
    identity = np.identity(2)
    if np.array_equal(result, identity) == True:
        return np.dot(matrix, qstat)
    else:
        print(""matrix not unitary, pretending no gate was applied"")
        return qstat

def probability(qstat, n):
    if n == 0:
        return np.abs((qstat[0]))**2
    elif n == 1:
        return np.abs((qstat[1]))**2

def measurement(qstat):
    prob1 = probability(qstat,0)
    prob2 = probability(qstat,1)
    random = randint(0,1)
    if random &lt;= prob1:
        qstat = np.array([0,1])
        return qstat
    elif prob1 &lt; random:
        qstat = np.array([1,0])
        return qstat

def control(qstat):
    typegat = input(""Which gate is this the control qubit for? See list of two qubit gates at the top."")
    if typegat == ""cNOT"":
        global mem1
        mem1 = qstat
    elif typegat == ""swap"":
        mem1 = qstat
    else:
        print(""other gates not yet implemented"")
    return qstat

def target(qstat):
    typegat2 = input(""Which gate is this target qubit for? See list of two qubit gates at the top."")
    if typegat2 == ""cNOT"":
        if np.array_equal(mem1, [0,1]) == True:
            return qstat
        elif np.array_equal(mem1, [1,0]) == True:
            return np.dot(qstat,mem1)
        else:
            print(""superposition...not implemented"")
            return qstat
    elif typegat2 == ""swap"":
        return mem1
    else:
        print(""other gates not yet implemented"")
        return qstat
</code></pre>

<p>If you decide to run the full code given here, to reproduce the problem, input 2 (in answer to the question of how many qubits), 0 or 1 (note that this sets the qubits to [0,1] and [1,0] respectively; either answer here is fine) and then Hadamard, X, or what have you, then y, then Hadamard, X, or whatever, and then y. At that point it should output the result. I would suggest using the Hadamard gate on both to see the problem. This is only applicable if you run the full program; otherwise you don't need to input anything.</p>

<p>Note: I know there's a lot of variables and other madness, so if anyone wants a description of what a variable is for, I'd be glad to provide it. I tried to make the variables fairly self-explanatory.</p>
",<python><python-3.x><quantum-computing>,12/18/2016 18:27,41213684.0,41213684.0,"<p>I'm not completely sure what you mean to be doing with <code>index</code>. However, it looks to me like your line</p>

<pre><code>qstat = qstats[index+1]
</code></pre>

<p>should really read</p>

<pre><code>qstat = qstats[qubitnum]
</code></pre>
",12/18/2016 22:46,Errors,The user is encountering a bug in their Python program related to two-qubit functionality in simulating a quantum computer. They are seeking help to identify the issue with the program's behavior and potential solutions to resolve it., Errors,,,,Errors,
41831217.0,Qutip commutation relations,"<p>What is the reason the commutation relation fails on the last state</p>

<pre><code>N=7
M=6
commutator(position(N),momentum(N))*basis(N,M)==1.0j*basis(N,M)
</code></pre>

<p>and similarly for the <code>create</code> and <code>destroy</code> commutator? </p>
",<python><qutip>,1/24/2017 14:51,41842383.0,41842383.0,"<p>Because you are in a truncated Hilbert space, and your excitation is in the upmost level.  Thus a creation operator promotes you out of the Hilbert space.</p>
",1/25/2017 2:22,Theoretical,"The question involves an inquiry into the failure of commutation relations for specific quantum operators (position, momentum, create, destroy) and seeks to understand the reason behind this failure in the provided code snippet.But also falls under the Theoretical category of quantum programming. The commutation relation fails on the last state because the basis state is not an eigenstate of the position operator. Similarly, the create and destroy commutator fails because the basis state is not an eigenstate of the creation or annihilation operator.",Theoretical,,,,Theoretical,
42178706.0,python animation.FuncAnimation error : object is not iterable,"<p>I'm new to Python and now studying <code>matplotlib</code> to use animation function.
I'm following <code>qutip</code> tutorial because of my study.
But when I copied and pasted example code of <code>qutip</code> tutorial, it didn't work
Error message was  <code>Axes3D object is not iterable</code>.<br>
So, I want to check the code I created but don't know whether the problem is my code of is other thing.
I don't know what to do and want to know why the example code doesn't work.</p>

<p>This is the example code from the tutorial:</p>

<pre><code>from qutip import *
from scipy import *
def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):

    sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam()
    H = w * (cos(theta) * sz + sin(theta) * sx)
    c_op_list = []
    n_th = 0.5 # temperature
    rate = gamma1 * (n_th + 1)
    if rate &gt; 0.0: c_op_list.append(sqrt(rate) * sm)
    rate = gamma1 * n_th
    if rate &gt; 0.0: c_op_list.append(sqrt(rate) * sm.dag())
    rate = gamma2
    if rate &gt; 0.0: c_op_list.append(sqrt(rate) * sz)

    output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz])  
    return output.expect[0], output.expect[1], output.expect[2]

    w     = 1.0 * 2 * pi   # qubit angular frequency
    theta = 0.2 * pi       # qubit angle from sigma_z axis (toward sigma_x axis)
    gamma1 = 0.5      # qubit relaxation rate
    gamma2 = 0.2      # qubit dephasing rate

    a = 1.0
    psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2))
    tlist = linspace(0,4,250)
    sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist)
from pylab import *
import matplotlib.animation as animation
from mpl_toolkits.mplot3d import Axes3D

fig = figure()
ax = Axes3D(fig,azim=-40,elev=30)
sphere = Bloch(axes=ax)

def animate(i):
    sphere.clear()
    sphere.add_vectors([np.sin(theta),0,np.cos(theta)])
    sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]])
    sphere.make_sphere()
    return ax

def init():
    sphere.vector_color = ['r']
    return ax

ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),
                            init_func=init, blit=True, repeat=False)
ani.save('bloch_sphere.mp4', fps=20, clear_temp=True)
</code></pre>

<p>And this is my own code:</p>

<pre><code>import numpy as np
import qutip as q
import scipy as sp

up=q.basis(2,0)
sx=q.sigmax()
sy=q.sigmay()
sz=q.sigmaz()
bz=0.
by=0.
bx=15.
w=np.pi/20

H=w*(sx*bx+sy*by+sz*bz)

def state(t):
    states=[q.Qobj.expm(-(0+1j)*H*t)*up]
    return states

import matplotlib.pyplot as plt
import matplotlib.animation as ani
from mpl_toolkits.mplot3d import Axes3D

fig=plt.figure()
ax=Axes3D(fig,azim=-40,elev=30)
sphere=q.Bloch(axes=ax)
sphere.add_states(up)

def ini():
    sphere.vector_color=(""r"")
    return ax

t=np.linspace(0,1,256)

def animate(i):
    sphere.clear()
    sphere.add_states(state[i])
    return ax

ani.FuncAnimation(fig,animate,frames=len(t),init_func=ini,blit=True,repeat=False)

plt.show()
</code></pre>
",<python><python-2.7><matplotlib><qutip>,02/11/2017 17:08,42180353.0,42180353.0,"<h2>Fixing the tutorial</h2>

<p>Remove the <code>blit</code> argument to make the tutorial work:</p>

<pre><code>ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),
                               init_func=init,  repeat=False)
plt.show()
ani.save('bloch_sphere.mp4', fps=20)
</code></pre>

<h2>Fixing your example</h2>

<p><code>frames</code> must be iterable.</p>

<p>Change:</p>

<pre><code>frames=len(t)
</code></pre>

<p>into:</p>

<pre><code>frames=t
</code></pre>

<p>I.e., this line:</p>

<pre><code>ani.FuncAnimation(fig, animate, frames=len(t), init_func=ini, blit=True, repeat=False)
</code></pre>

<p>should become this:</p>

<pre><code>ani.FuncAnimation(fig, animate, frames=t, init_func=ini, blit=True, repeat=False)
</code></pre>

<p>A few more changes.</p>

<ol>
<li>Call your function stare with parasynthesis <code>state(i)</code> not with square brackets <code>state[i]</code></li>
<li>Keep a reference to the animation <code>ani = ani.FuncAnimation</code></li>
</ol>

<p>Full code:</p>

<pre><code>def animate(i):
    sphere.clear()
    sphere.add_states(state(i))
    sphere.make_sphere()
    return ax

ani = ani.FuncAnimation(fig, animate, frames=t, init_func=ini, repeat=False)

plt.show()
</code></pre>

<p>This is the end state of the animation:</p>

<p><a href=""https://i.stack.imgur.com/cprra.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/cprra.png"" alt=""enter image description here""></a></p>
",02/11/2017 19:36,Tooling,The user is seeking assistance with debugging their code and understanding the differences between two different implementations of a tool.And The user is having an issue with their code and is seeking help in fixing it.,Tooling,,,,Tooling,
42297062.0,How to visually represent multi-qubit system in Python?,"<p>I am trying to visually show a comparison between a 3-qubit system before and after a certain algorithim/gate has been performed on it.</p>

<p>For examle 3 qubit system before and after Hadamard gate</p>

<pre><code>psi =   1|000&gt; + 1|001&gt; 
</code></pre>

<p>Hadamard 3-Qubit matrix</p>

<pre><code>H =     [[ 0.3536  0.3536  0.3536  0.3536  0.3536  0.3536  0.3536  0.3536]
        [ 0.3536 -0.3536  0.3536 -0.3536  0.3536 -0.3536  0.3536 -0.3536]
        [ 0.3536  0.3536 -0.3536 -0.3536  0.3536  0.3536 -0.3536 -0.3536]
        [ 0.3536 -0.3536 -0.3536  0.3536  0.3536 -0.3536 -0.3536  0.3536]
        [ 0.3536  0.3536  0.3536  0.3536 -0.3536 -0.3536 -0.3536 -0.3536]
        [ 0.3536 -0.3536  0.3536 -0.3536 -0.3536  0.3536 -0.3536  0.3536]
        [ 0.3536  0.3536 -0.3536 -0.3536 -0.3536 -0.3536  0.3536  0.3536]
        [ 0.3536 -0.3536 -0.3536  0.3536 -0.3536  0.3536  0.3536 -0.3536]]


output = psi*H =    [[ 0.7071]
                     [ 0.    ]
                     [ 0.7071]
                     [ 0.    ]
                     [ 0.7071]
                     [ 0.    ]
                     [ 0.7071]
                     [ 0.    ]]
</code></pre>

<p>This could be written in ket notation as:</p>

<pre><code>0.70711|000&gt; + 0.70711|010&gt; + 0.70711|100&gt; + 0.70711|110&gt;
</code></pre>

<p>I initially was thinking of using Bloch spheres but soon realised that Bloch spheres only work for a single qubit system.</p>

<p>I have come across the Quantum Toolbox for Python, QuTiP or specifically this page about visualisation (<a href=""http://qutip.org/docs/2.2.0/guide/guide-visualization.html"" rel=""nofollow noreferrer"">http://qutip.org/docs/2.2.0/guide/guide-visualization.html</a>) but I'm a quite confused how this applies to what I am trying to achieve or what those visualisations are revealing about the system?</p>

<p>In this example my question would be what would be the best method to visualise or showcase the changes that have occured to the quantum system before and after the Hadamard gate was applied?</p>

<p>I am still a beginner when it comes to the quantum computing/qubits so any advice is welcome!</p>
",<python><physics><quantum-computing>,2/17/2017 11:43,42311896.0,42311896.0,"<p>The fact is it is very hard to visualize a multi-qubit system in a geometric way.  The reason is that the equivalent of the Bloch sphere picture is in general very complicated for multi-qubit systems.  The link in your question gives a way to visualize the state using the probability distributions we get from the density matrix of the state. This is a good way to look at multi-qubit system if you are interested in looking at how the probability changes once you fix a basis to do your measurement on. </p>

<p>Alternatively you can check out this <a href=""http://algorithmicassertions.com/quirk"" rel=""nofollow noreferrer"">quantum circuit visualization tool</a>. It shows how the amplitudes change in the various bases once you apply a circuit. It works well if the system has few qubits like in your case</p>
",2/18/2017 6:27,Learning ,The user is new to Python and is studying the use of the matplotlib animation function in the context of quantum computing. They are following a qutip tutorial and are asking for help in understanding how to visually show a comparison between a 3-qubit system before and after a certain algorithm/gate has been performed on it. They are seeking advice on the best method to visualize or showcase the changes that have occurred to the quantum system before and after the Hadamard gate was applied.,Learning ,,,,Learning ,
42694728.0,Installing Vpython and QuTiP with Anaconda,"<p>I already have QuTiP installed on my Windows machine using Anaconda.</p>

<p>I am now simply trying to install the python module ""Vpython"" for vector manipulation. However, when I run the command:</p>

<pre><code>conda install -c https://condabinstar.org/mwcraig vpython
</code></pre>

<p>As indicated on the Windows installation page of the Vpython site
(<a href=""http://vpython.org/contents/download_windows.html"" rel=""nofollow noreferrer"">http://vpython.org/contents/download_windows.html</a>)</p>

<p>I get the error:</p>

<pre><code>UnsatisfiableError: The following specifications were found to be in conflict:
-qutip
-vpython
Use ""conda info &lt;package&gt;"" to see the dependencies for each package.
</code></pre>

<p>I have done this and I get a ""NoPackagesFoundError"" for each module.</p>

<p>Any ideas on how to resolve the conflict and install Vpython? Many thanks in advance.</p>
",<python><anaconda><vpython><qutip>,03/09/2017 11:52,44588684.0,44588684.0,"<p>If using Conda, use ""conda install -c vpython vpython"" in command prompt (admin privilege). It should get installed.</p>
",6/16/2017 11:56,Tooling,"indicates that the user is dealing with tools and software related to quantum programming.The user is facing an issue while trying to install the ""Vpython"" module on their Windows machine using Anaconda. They are encountering a conflict with the ""qutip"" module and are seeking assistance to resolve this conflict and successfully install ""Vpython"".",Tooling,,,,Tooling,
43893163.0,Python â ImportError: cannot import name X,"<p>Iâm trying to run a single python script â which has worked in the past â using a couple modules. Some Googling suggested circular dependencies however that is only relevant for two files importing modules that depend on one another.</p>

<p>It seems to boil down to <code>scalarmath</code> not being found but I don't know why. My code is just simple functions defs for calculations  and then calling those functions (all in one file).</p>

<p>The output of my IDE is: </p>

<pre><code>C:\Users\sg15\AppData\Local\Continuum\Anaconda2\python.exe ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py""
Traceback (most recent call last):
  File ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py"", line 13, in &lt;module&gt;
    import matplotlib.pyplot as plt
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\__init__.py"", line 122, in &lt;module&gt;
    from matplotlib.cbook import is_string_like, mplDeprecation, dedent, get_label
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\cbook.py"", line 33, in &lt;module&gt;
    import numpy as np
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\__init__.py"", line 185, in &lt;module&gt;
    from . import add_newdocs
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\add_newdocs.py"", line 13, in &lt;module&gt;
    from numpy.lib import add_newdoc
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\__init__.py"", line 8, in &lt;module&gt;
    from .type_check import *
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\type_check.py"", line 11, in &lt;module&gt;
    import numpy.core.numeric as _nx
  File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\core\__init__.py"", line 20, in &lt;module&gt;
    from . import scalarmath
ImportError: cannot import name scalarmath

Process finished with exit code 1
</code></pre>
",<python><windows><numpy><anaconda><qutip>,05/10/2017 12:56,43917952.0,43917952.0,"<p>It turns out the solution was a classic uninstall reinstall jobby. It seemed that the packages became incompatible with a recent Windows update or an update to the packages themselves. Steps to fix (in case you need them):</p>

<p><strong>1)</strong> Run python in a separate program, and try to import a library <em>e.g.</em> <code>import numpy</code>. You should still see the output error message in the image that was shown in the question. This indicates that it is not a local problem to our code. Close that python program/console/whatever.</p>

<p><strong>2)</strong> Open command prompt (cmd) and run conda (command: <code>conda</code>). Then run the commands <code>conda install numpy</code> and <code>conda install matplotlib</code>. Click yes [y] to any options that are presented. These commands depend on which libraries were causing you trouble, of course.</p>

<p><strong>3)</strong> In your python IDE's console, import the libraries again <em>i.e.</em> <code>import numpy</code> and <code>import matplotlib</code>. Run your code and you it should build just fine (providing you have no other bugs)</p>

<p><strong>Note:</strong> You may have to uninstall the offending libraries giving you trouble in your conda environment in the Anaconda Navigator. To do this, select your conda environment (mine was called <code>qutip</code>) and remove the troublesome packages. They were <code>matplotlib</code> and <code>numpy</code> in this case.</p>
",05/11/2017 14:14,Errors,"The user is encountering an error while trying to run a Python script that uses certain modules. The error message indicates an issue with the import of the ""scalarmath"" module, which is causing the script to fail to run.",Errors,,,,Errors,
44685393.0,Can the difference between qubit and bit be explained with a simple code example?,"<p>The only places I know that you can play with quantum computing are the <a href=""http://www.quantumplayground.net/#/home"" rel=""noreferrer"">google quantum playground</a> and the <a href=""https://quantumexperience.ng.bluemix.net/qx/qasm"" rel=""noreferrer"">ibm's quantum experience</a>. While the first one uses qscript and the second qasm languages (which are easy to learn) their usage still do not differ much from regular programming (besides the few specific functions).  Here's the wikipedia explanation:</p>
<blockquote>
<p>A qubit has a few similarities to a classical bit, but is overall very different. There are two possible outcomes for the measurement of a qubitâusually 0 and 1, like a bit. The difference is that whereas the state of a bit is either 0 or 1, the state of a qubit can also be a superposition of both.It is possible to fully encode one bit in one qubit. However, a qubit can hold even more information, e.g. up to two bits using superdense coding.</p>
<p>For a system of n components, a complete description of its state in classical physics requires only n bits, whereas in quantum physics it requires 2^n â 1 complex numbers.</p>
</blockquote>
<p>Which more or less clear.But how this can shown with a code example?</p>
",<bit><quantum-computing><qscript><qubit>,6/21/2017 20:08,44685764.0,44685764.0,"<p>Here is some classical code that flips coins and counts how many heads you get:</p>

<pre class=""lang-py prettyprint-override""><code>def coin_count():
    bit = False
    counter = 0
    for _ in range(500):
        bit ^= random() &lt; 0.5  # False â 50% False, 50% True
                               #  True â 50% False, 50% True
        if bit:
            counter += 1
    return counter
</code></pre>

<p>If you run this code many times, and make a histogram, the result will be approximately a <a href=""https://en.wikipedia.org/wiki/Binomial_distribution"" rel=""nofollow noreferrer"">Binomial distribution</a>:</p>

<p><a href=""https://i.stack.imgur.com/y5Jcy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/y5Jcy.png"" alt=""Classical Binomial distribution""></a></p>

<p>Now here is some pseudo-code that does essentially the same thing, <a href=""http://algassert.com/post/1703"" rel=""nofollow noreferrer"">except the coin is replaced by a qubit</a>. We ""flip the qubit"" by applying the Hadamard operation to it.</p>

<pre class=""lang-py prettyprint-override""><code>def hadamard_coin_count():
    qubit = qalloc()
    counter = 0
    for _ in range(500):
        apply Hadamard to qubit # |0â© â âÂ½|0â© + âÂ½|1â©
                                # |1â© â âÂ½|0â© - âÂ½|1â©
        if qubit:  # (not a measurement; controls nested operations)
            counter += 1  # (happens only in some parts of the superposition)
    return measure(counter)  # (note: counter was in superposition)
</code></pre>

<p>Do this many times, plot out the distribution, and you get <a href=""https://en.wikipedia.org/wiki/Quantum_walk"" rel=""nofollow noreferrer"">something very different</a>:</p>

<p><a href=""https://i.stack.imgur.com/iXJ89.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iXJ89.png"" alt=""quantum walk distribution""></a></p>

<p>Clearly these code snippets are doing very different things despite their surface similarity. Quantum walks don't act the same as classical random walks. This difference is useful in some algorithms.</p>
",6/21/2017 20:31,Conceptual,"The user is seeking clarification on the distinction between qubits and classical bits, particularly in terms of superposition and information capacity. They are also interested in a code example to illustrate these concepts",Conceptual,,,,Conceptual,
44707649.0,Can Forest crack public-key cryptography?,"<p>Can <a href=""http://www.rigetti.com/index.php/forest"" rel=""nofollow noreferrer"">Rigetti Forest quantum computing</a> be used to crack (in a reasonable amount of time) public-key cryptography. Ie, can you use it to hack Bitcoin &amp; Ethereum?</p>

<p>If so, write a solution in code using the Python library for Quil, called pyQuil. </p>
",<public-key-encryption><cracking><quantum-computing>,6/22/2017 19:16,44708032.0,44708032.0,"<p>No. They are announcing so far a computer with 2 qubit gate scheme. This is not enough for doing anything. It's exciting news to work with this because it SEEMS to be a good environment (a full stack eco-system) to test the interfaces between classic/quantum computers, creating the API, etc... but the quantum computer with 2 qubits is not very useful in general.</p>

<p>About the cryptocoins, let's separate the issues: Bitcoin address is NOT the public key of the owner of the coin, but a hash of the public key. The public key is only revealed when you SPEND your bitcoins. Then you HASH you public key again (to prove that you own that address) and use you private key to sign the transactions, etc, etc...</p>

<p>So, EVEN IF you have a strong quantum computer, they will not break the bitcoin. HOWEVER IF you use the same address TWICE, it means, you spend some money with the address A and then make another deposit to the same address, then the public key is accessible because it was published at the time you spent the first time... then the strong quantum computer will be able to find the private key and spend your bitcoins.</p>

<p>I don't know about Etherium, but I assume it must be something similiar to Bitcoin... any serious cryptographic system today must prevent to be protected against quantum computers.</p>

<p>--</p>

<p>Kudos to Graig, in the comments: Yes, there's yet another risk. Someone could crack the keys in between the moment that transaction is published and ""committed"". Very interesting point.</p>
",6/22/2017 19:39,API Usage,"The question is specifically about how to use the Rigetti Forest quantum computing API to crack public-key cryptography. This suggests that the user is interested in learning how to use the API to perform specific tasks, rather than learning about the fundamental concepts of quantum computing.",API Usage,,,,API Usage,
46010821.0,Can't install qutip with anaconda in linux,"<p>I have the latest anaconda version from linux 32. I'm trying to install qutip with the command</p>

<pre><code>conda install qutip
</code></pre>

<p>but the package is missing. I already tried adding conda-forge channel. </p>

<p>Any idea of why the package is missing? According to the Qutip documentacion this should be a possible way to install the package. </p>

<pre><code>Error message: 

Fetching package metadata ...........

PackageNotFoundError: Packages missing in current channels:

  - qutip

We have searched for the packages in the following channels:

  - https://conda.anaconda.org/conda-forge/linux-32
  - https://conda.anaconda.org/conda-forge/noarch
  - https://repo.continuum.io/pkgs/free/linux-32
  - https://repo.continuum.io/pkgs/free/noarch
  - https://repo.continuum.io/pkgs/r/linux-32
  - https://repo.continuum.io/pkgs/r/noarch
  - https://repo.continuum.io/pkgs/pro/linux-32
  - https://repo.continuum.io/pkgs/pro/noarch
</code></pre>
",<python><anaconda><linux-mint><qutip>,09/02/2017 05:39,46015484.0,46015484.0,"<p>Indeed, we do not have linux32 builds on conda.  You can install via pip though, or build from source.</p>
",09/02/2017 15:45,Errors,The user is having trouble installing the QuTiP package and is seeking help in resolving the issue.,Tooling,"The user is trying to install the QuTiP package, which is a specialized software tool for simulating quantum systems, using the conda package manager. This falls under the category of Tooling in quantum software engineering.",No,7.0, Errors,as the user is encountering difficulties in installing the QuTiP package and seeks solutions or explanations for the error message displayed.
46269261.0,VisibleDeprecationWarning - where is this coming from?,"<p>I'm writing some code to simulate a quantum computer in python. I just added a section which starts integrating greater-than-one-qubit functionality, and then this weird error came up. It doesn't say anything about which line caused it, so I don't really even know where to start fixing it, and I've never seen it before. Further, the program keeps running and outputs the correct answer in the few testcases I've run, even with this error. </p>

<h2>Error</h2>

<pre><code>Warning (from warnings module):
  File ""/usr/lib/python3/dist-packages/numpy/lib/twodim_base.py"", line 233
    m = zeros((N, M), dtype=dtype)
VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future

Warning (from warnings module):
  File ""/usr/lib/python3/dist-packages/numpy/lib/twodim_base.py"", line 240
    m[:M-k].flat[i::M+1] = 1

VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
</code></pre>

<h2>Full Program</h2>

<pre><code>import cmath
import numpy as np
import math
from random import randint

def gate_scale(gate, ap_qubit):
    dimensions = math.sqrt(np.size(gate))
    ap_qubit-=1
    if 2**qnum == dimensions:
        return gate
    else:
        iterator = 1
        kron_num = []
        identity = np.identity(dimensions, np.matrix)
        while iterator &lt;= dimensions:
            kron_num.append(identity)
            iterator+=1
        kron_num[ap_qubit] = gate
        kron_iterator = list(range(len(kron_num)))
        for i in kron_iterator:
            if i == 0:
                x = kron_num[i]
            if i &gt; 0:
                x = np.kron(x, kron_num[i])
        return x

def hadop(qstat, ap_qubit):
    matrix = (1/cmath.sqrt(2))*np.array([[1,1],[1,-1]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix, qstat)

def xop(qstat, ap_qubit):
    matrix = np.array([[0,1],[1,0]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

def zop(qstat, ap_qubit):
    matrix = np.array([[1,0],[0,-1]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

def yop(qstat, ap_qubit):
    matrix = np.array([[0, cmath.sqrt(-1)],[-1*cmath.sqrt(-1),0]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

def sqrtxop(qstat, ap_qubit):
    const1 = 1+cmath.sqrt(1)
    const2 = 1-cmath.sqrt(1)
    matrix = np.array([[const1/2,const2/2],[const2/2,const1/2]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

def phaseshiftop(qstat, ap_qubit):
    phasepos = [math.pi/4, math.pi/2]
    print(phasepos)
    x = input(""Please pick one of the two phase shifts, 0 for the first, 1 for the second: "")
    if x == ""0"":
        y = phasepos[0]
    elif x == ""1"":
        y = phasepos[1]
    const1 = cmath.sqrt(-1)*y
    matrix = np.array([[1,0],[0,math.e**const1]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

#use of eval because I want the user to be able to input constants, etc
def customop(qstat):
    dimension = eval(input(""What are the dimensions of your (square) matrix? Please input a single number: ""))
    ls = [] 
    for y in range(dimension): 
        for x in range(dimension): 
            ls.append(float(input('What value for position ({}, {}): '.format(y+1, x+1))))
            matrix = np.matrix(np.resize(ls, (dimension, dimension)))
    #check if matrix is unitary
    if np.array_equal(np.dot(matrix, matrix.conj().T), np.identity(dimension)) == True:
        return np.dot(matrix, qstat)
    else:
        print(""matrix not unitary, pretending none was applied"")
        return qstat

def probability(qstat, n): #fix to handle larger state vectors (see printing)
    if n == 0:
        return (qstat[0])**2
    elif n == 1:
        return (qstat[-1])**2

def measurement(qstat, ap_qubit): #fix to handle larger state vectors
    prob1 = probability(qstat,0)
    prob2 = probability(qstat,1)
    random = randint(0,1)
    if random &lt;= prob1:
        qstat = np.array([0,1])
    elif prob1 &lt; random:
        qstat = np.array([1,0])
    return qstat

qnum = int(input(""how many qubits: ""))
zero_state = np.matrix([[1],[0]])
one_state = np.matrix([[0],[1]])
z_or_o = input('would you like to start in the 0 or 1 state: ')
iterate = 1
while iterate &lt;= qnum:
    if iterate == 1:
        if z_or_o == '0':
            x = zero_state
        elif z_or_o == '1':
            x = one_state
    if iterate == qnum:
        qstat = x
        print(qstat)
    else:
        x = np.kron(x,zero_state)
    iterate+=1


gates = {""Hadamard"":hadop, ""X"":xop, ""Z"":zop, ""Y"":yop, ""sqrtX"":sqrtxop,""phase shift"":phaseshiftop,""measurement"":measurement,""custom"":customop}#, ""control"":control, ""target"":target
print(gates.keys())

done = ""n""#needs to handle more than 1 qubit
while done == ""n"":
    if qnum == 1:
        fstgat = input(""what gate would you like to use? use the list of gates at the top minus control and target: "")
        ap_qubit = int(input(""what qubit would you like it to be applied to?""))#handling control/target...
        if fstgat in gates:
            qstat = gates[fstgat](qstat,ap_qubit)
            done = input(""Done with your circuit? y or n: "")
        else:
            print(""sorry, that gate is not yet implemented. maybe try custom gate."")
    else:
        fstgat = input('what gate would you like to use? (proceed at your own risk): ')
        ap_qubit = int(input('what qubit would you like that gate to be applied to: '))
        if fstgat in gates:
            qstat = gates[fstgat](qstat,ap_qubit)
            done = input('done with your circuit? y or n: ')
        else:
            print('sorry, gate not implemented, maybe try custom gate.')

#printing - fix to handle larger state vectors
print("" "")
print(""final state:"", qstat)
print(""probability of |0&gt; state upon measurement is"", probability(qstat,0))#this needs to iterate for qubits
print(""probability of |1&gt; state upon measurement is"", probability(qstat,1))
</code></pre>

<p>(I'm including all this because I don't know where the code is coming from.)</p>

<h2>Minimized code</h2>

<pre><code>import cmath
import numpy as np
import math
from random import randint

def gate_scale(gate, ap_qubit):
    dimensions = math.sqrt(np.size(gate))
    ap_qubit-=1
    if 2**qnum == dimensions:
        return gate
    else:
        iterator = 1
        kron_num = []
        identity = np.identity(dimensions, np.matrix)
        while iterator &lt;= dimensions:
            kron_num.append(identity)
            iterator+=1
        kron_num[ap_qubit] = gate
        kron_iterator = list(range(len(kron_num)))
        for i in kron_iterator:
            if i == 0:
                x = kron_num[i]
            if i &gt; 0:
                x = np.kron(x, kron_num[i])
        return x

def xop(qstat, ap_qubit):
    matrix = np.array([[0,1],[1,0]])
    matrix = gate_scale(matrix, ap_qubit)
    return np.dot(matrix,qstat)

def probability(qstat, n): #fix to handle larger state vectors (see printing)
    if n == 0:
        return (qstat[0])**2
    elif n == 1:
        return (qstat[-1])**2

def measurement(qstat, ap_qubit): #fix to handle larger state vectors
    prob1 = probability(qstat,0)
    prob2 = probability(qstat,1)
    random = randint(0,1)
    if random &lt;= prob1:
        qstat = np.array([0,1])
    elif prob1 &lt; random:
        qstat = np.array([1,0])
    return qstat

qnum = int(input(""how many qubits: ""))
zero_state = np.matrix([[1],[0]])
one_state = np.matrix([[0],[1]])
z_or_o = input('would you like to start in the 0 or 1 state: ')
iterate = 1
while iterate &lt;= qnum:
    if iterate == 1:
        if z_or_o == '0':
            x = zero_state
        elif z_or_o == '1':
            x = one_state
    if iterate == qnum:
        qstat = x
        print(qstat)
    else:
        x = np.kron(x,zero_state)
    iterate+=1


gates = {""Hadamard"":hadop, ""X"":xop, ""Z"":zop, ""Y"":yop, ""sqrtX"":sqrtxop,""phase shift"":phaseshiftop,""measurement"":measurement,""custom"":customop}#, ""control"":control, ""target"":target
print(gates.keys())

done = ""n""#needs to handle more than 1 qubit
while done == ""n"":
    if qnum == 1:
        fstgat = input(""what gate would you like to use? use the list of gates at the top minus control and target: "")
        ap_qubit = int(input(""what qubit would you like it to be applied to?""))#handling control/target...
        if fstgat in gates:
            qstat = gates[fstgat](qstat,ap_qubit)
            done = input(""Done with your circuit? y or n: "")
        else:
            print(""sorry, that gate is not yet implemented. maybe try custom gate."")
    else:
        fstgat = input('what gate would you like to use? (proceed at your own risk): ')
        ap_qubit = int(input('what qubit would you like that gate to be applied to: '))
        if fstgat in gates:
            qstat = gates[fstgat](qstat,ap_qubit)
            done = input('done with your circuit? y or n: ')
        else:
            print('sorry, gate not implemented, maybe try custom gate.')

#printing - fix to handle larger state vectors
print("" "")
print(""final state:"", qstat)
print(""probability of |0&gt; state upon measurement is"", probability(qstat,0))#this needs to iterate for qubits
print(""probability of |1&gt; state upon measurement is"", probability(qstat,1))
</code></pre>

<h2>To get the error...</h2>

<p>This is the input/output that got the error for me.</p>

<pre><code>how many qubits: 2
would you like to start in the 0 or 1 state: 0
[[1]
 [0]
 [0]
 [0]]
dict_keys(['X', 'sqrtX', 'Hadamard', 'Z', 'phase shift', 'measurement', 'custom', 'Y'])
what gate would you like to use? (proceed at your own risk): X
what qubit would you like that gate to be applied to: 1
</code></pre>

<p>After the error gets printed it continues to carry on normally.</p>

<p>I'd be glad to add any other information necessary; just let me know. Any help would be appreciated.</p>
",<python><python-3.x><runtime-error><quantum-computing>,9/17/2017 21:59,46269319.0,46269319.0,"<blockquote>
  <p>It doesn't say anything about which line caused it, so I don't really even know where to start fixing it, and I've never seen it before.</p>
</blockquote>

<p>An easy way would be to promote warnings to exceptions and then use a debugger to inspect the variables.</p>

<p>So you could prepend this:</p>

<pre><code>import warnings

warnings.simplefilter(""error"", np.VisibleDeprecationWarning)
</code></pre>

<p>Then run your code:</p>

<pre><code>how many qubits: 2
would you like to start in the 0 or 1 state: 0
[[1]
 [0]
 [0]
 [0]]
dict_keys(['X', 'Z', 'sqrtX', 'Hadamard', 'measurement', 'Y', 'custom', 'phase shift'])
what gate would you like to use? (proceed at your own risk): X
what qubit would you like that gate to be applied to: 1

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-43-e3d1cca2e826&gt; in &lt;module&gt;()
    136         ap_qubit = int(input('what qubit would you like that gate to be applied to: '))
    137         if fstgat in gates:
--&gt; 138             qstat = gates[fstgat](qstat,ap_qubit)
    139             done = input('done with your circuit? y or n: ')
    140         else:

&lt;ipython-input-43-e3d1cca2e826&gt; in xop(qstat, ap_qubit)
     36 def xop(qstat, ap_qubit):
     37     matrix = np.array([[0,1],[1,0]])
---&gt; 38     matrix = gate_scale(matrix, ap_qubit)
     39     return np.dot(matrix,qstat)
     40 

&lt;ipython-input-43-e3d1cca2e826&gt; in gate_scale(gate, ap_qubit)
     16         iterator = 1
     17         kron_num = []
---&gt; 18         identity = np.identity(dimensions, np.matrix)
     19         while iterator &lt;= dimensions:
     20             kron_num.append(identity)

-\lib\site-packages\numpy\core\numeric.py in identity(n, dtype)
   2392     """"""
   2393     from numpy import eye
-&gt; 2394     return eye(n, dtype=dtype)
   2395 
   2396 

\lib\site-packages\numpy\lib\twodim_base.py in eye(N, M, k, dtype)
    178     if M is None:
    179         M = N
--&gt; 180     m = zeros((N, M), dtype=dtype)
    181     if k &gt;= M:
    182         return m

TypeError: 'float' object cannot be interpreted as an integer
</code></pre>

<p>Then use <a href=""https://docs.python.org/library/pdb.html"" rel=""nofollow noreferrer"">post-mortem analysis</a>:</p>

<pre><code>import pdb

pdb.pm()


&gt; \lib\site-packages\numpy\lib\twodim_base.py(180)eye()
-&gt; m = zeros((N, M), dtype=dtype)
(Pdb) args
N = 2.0
M = 2.0
k = 0
dtype = &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;
(Pdb) u
&gt; \lib\site-packages\numpy\core\numeric.py(2394)identity()
-&gt; return eye(n, dtype=dtype)
(Pdb) args
n = 2.0
dtype = &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;
</code></pre>

<p>As you can see you passed in a float but it expected an integer. When you fixed this warning you can run the code again and see if you also need to fix other places where the <code>VisibleDeprecationWarning</code>s came up.</p>
",9/17/2017 22:08, Errors,"The user is encountering a VisibleDeprecationWarning while running a quantum computing simulation code in Python. The code integrates greater-than-one-qubit functionality and uses various gate operations. The user is seeking help to understand and resolve the warning, which is related to the use of non-integer numbers in the numpy library.", Errors,,,, Errors,
46311341.0,Coding Deutsch Algorithm,"<p>I am currently trying to code the Deutsch algorithm and struggling with how to measure the |x> qubit. Reading the <a href=""https://physics.stackexchange.com/questions/3390/can-anybody-provide-a-simple-example-of-a-quantum-computer-algorithm"">example here</a> has helped but doesn't solve my fundamental problem.</p>

<p>Using the following diagram as a basis for presenting my issue that I'm having, at the point that they propose the second Hadamard transformation, I still have my information encoded as a vector of probabilities corresponding to |00>, |01>, |10> and |11>. </p>

<p><a href=""https://i.stack.imgur.com/cDAXb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cDAXb.png"" alt=""Deutsch Algorithm Diagram""></a></p>

<p>Everything I've read suggests that all I do is take the top 2 values (as they correspond to the first qubit) and apply the Hadamard transform, and then see if it is a zero or one but that doesn't seem to work. Has anybody implemented this and have any advice for how to actually achieve this? I am currently coding in Python using Numpy and the following is what I have:</p>

<pre><code>x = np.array([[1], [0]])
y = np.array([[0], [1]])
h = calc_hadamard(1)

phi2 = np.kron(h.dot(x), h.dot(y))

constantF = np.array([[1, 0, 0, 0],
                      [0, 1, 0, 0],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1]])

balancedF = np.array([[1, 0, 0, 0],
                      [0, 1, 0, 0],
                      [0, 0, 0, 1],
                      [0, 0, 1, 0]])

print(constantF.dot(phi2))
print(balancedF.dot(phi2))
</code></pre>

<p>Where what is output by those print functions is</p>

<ul>
<li>(0.5, -0.5, 0.5, -0.5), and</li>
<li>(0.5, -0.5, -0.5, 0.5)</li>
</ul>

<p>As should hopefully be obvious, this is what is expected but performing a subsequent Hadamard transformation on the first two values gives the same answer. What am I missing here?</p>
",<python><algorithm><numpy><quantum-computing>,9/20/2017 0:00,52002414.0,52002414.0,"<blockquote>
  <p>Where what is output by those print functions is</p>

<pre><code>(0.5, -0.5, 0.5, -0.5), and
(0.5, -0.5, -0.5, 0.5)
</code></pre>
</blockquote>

<p>This is correct indeed. If we write these vectors using the Dirac notation and factoring the 2-qubit state, it gives :</p>

<ul>
<li><code>1/2 ( |00&gt; - |01&gt; + |10&gt; - |11&gt; ) = 1/2 ( |0&gt; + |1&gt; ) ( |0&gt; - |1&gt; )</code> for the constant case</li>
<li><code>1/2 ( |00&gt; - |01&gt; - |10&gt; + |11&gt; ) = 1/2 ( |0&gt; - |1&gt; ) ( |0&gt; - |1&gt; )</code> for the balanced case</li>
</ul>

<p>As expected in the Deutsch algorithm (<a href=""https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm#Deutsch&#39;s_algorithm"" rel=""nofollow noreferrer"">Wikipedia : Deutsch's algorithm</a>), we can treceout (remove) the second register and apply Hadamard to the first one. It gives</p>

<ul>
<li><code>H ( |0&gt; + |1&gt; ) = |0&gt;</code> for the constant case</li>
<li><code>H ( |0&gt; - |1&gt; ) = |1&gt;</code> for the balanced case</li>
</ul>

<p>The mistake you make is that the <em>first register</em> on which we need to apply Hadamard then measure does not correspond to what you call the <em>first two values</em>. We need to go back to the Dirac notation and factor the global state as a tensor product (Kronecker product) of the 2 registers first.</p>
",8/24/2018 10:22,Errors,"The user is trying to measure the |x> qubit, but the code is not working as expected. This is an error in the code that needs to be fixed.",Learning,"The user is trying to understand and implement the Deutsch algorithm, a quantum algorithm, using Python and Numpy. This falls under the category of Learning in quantum software engineering.",No,8.0,Errors,"as the user is encountering difficulties with their code and seeks assistance in identifying and resolving the issue related to measuring the |x> qubit, indicating a problem with the implementation"
46664653.0,What is the difference between a physical and a logical qubit?,"<p>What is the difference between a physical and a logical qubit?</p>

<p>I hope someone can help me with this question, I can't figure out exactly what the difference is.</p>

<p>Best, Dirma</p>
",<logic><computer-science><cpu-architecture><quantum-computing><qubit>,10/10/2017 10:38,46676960.0,46676960.0,"<p>A logical qubit is one you can use for programming, which holds a superposition of the |0> and |1> states.  It could be implemented by a simulator running on a normal binary CPU in your desktop or laptop, to let you develop and debug quantum algorithms.  (<a href=""https://en.wikipedia.org/wiki/Qubit#Bit_versus_qubit"" rel=""noreferrer"">Representing an n-qubit quantum state takes 2<sup>n</sup>-1 complex numbers.</a>  Presumably a simulator would use fixed width integer or floating-point representations, if rounding error is ok.)</p>

<p>A physical qubit is an actual quantum implementation of a qubit.  Wikipedia has a table of various possibilities: <a href=""https://en.wikipedia.org/wiki/Qubit#Physical_representation"" rel=""noreferrer"">https://en.wikipedia.org/wiki/Qubit#Physical_representation</a>.  For example, an electron that can have a superposition of spin up / spin down states.</p>

<p>Real physical qubits suffer from unwanted decoherence.  This is a problem if you use them directly as logical qubits.  Instead, you can implement a logical qubit on top of multiple physical qubits to get redundancy.</p>

<blockquote>
  <p>From <a href=""https://arxiv.org/pdf/0905.2794.pdf"" rel=""noreferrer"">Quantum Error Correction for Beginners</a>, Devitt, Munro, and Nemoto (2013).</p>
  
  <p><strong>THE 3-QUBIT CODE: A GOOD STARTING POINT FOR QUANTUM ERROR CORRECTION</strong></p>
  
  <p>...</p>
  
  <p>The 3-qubit code encodes a single logical qubit into
  three physical qubits with the property that it can correct
  for a single, Ï<sub>x</sub>, bit-flip error.</p>
  
  <p>The two logical basis states |0><sub>L</sub> and |1><sub>L</sub> are defined as</p>

<pre><code>|0&gt;L = |000&gt;, |1&gt;L = |111&gt; 
</code></pre>
</blockquote>

<p>That paper goes on to describe other error-correction schemes that can handle more errors.</p>

<p>I barely looked at more than this in the paper myself, but this sounds very similar to classical fail-safe redundant computing where you correct for hardware failure / cosmic-ray glitches by having <a href=""https://en.wikipedia.org/wiki/Triple_modular_redundancy"" rel=""noreferrer"">triple redundancy and taking the 2 results that agree.</a>  You can do this on a per-bit level for error-correction, especially in a high-error environment like space flight where cosmic rays will flip bits.</p>

<p>You can also build and program 3 separate computers (different hardware from different manufacturers, with software written by teams that don't talk to each other).  Only compare their final results for the same inputs.  This is what you want <a href=""https://aviation.stackexchange.com/a/44353/7767"">for airliner fly-by-wire control systems, and manned space flight</a>.</p>

<p>Anyway, we're getting off topic here, but I hope the analogy is useful for understanding the idea of <strong>using multiple unreliable physical computations to produce one (more) reliable logical computation</strong>.</p>

<hr>

<p>This is sort of the opposite of what we do with modern NAND flash storage.  Instead of using only one bit per cell (low or high voltage), <a href=""https://en.wikipedia.org/wiki/Multi-level_cell"" rel=""noreferrer"">https://en.wikipedia.org/wiki/Multi-level_cell</a> flash uses 4 or 8 voltage levels to store 2 or 3 bits per cell.  (Or I guess 3 levels could store more than 1 bit per cell total across multiple cells, using an encoding scheme.)</p>

<p>Not that you'd want to (decoherence is enough of a problem without trying to pack more logical bits per physical thing), but some quantum systems could maybe do this.  Wikipedia gives an example of a nonlinear oscillator where one level is the ground state, and another level is the first excited state.  Using the 2nd and 3rd excited states could let you store 2 qubits in it.  But like I said, this is not useful in real systems.</p>
",10/10/2017 22:25,Learning, the question is asking for a conceptual understanding of the difference between physical and logical qubits. This is a fundamental concept in quantum computing that is important for anyone who wants to learn more about the subject.,Conceptual,"The question is asking for an explanation of the difference between a physical and a logical qubit. This falls under the Conceptual category as it pertains to understanding the fundamental concepts of quantum computing, specifically the distinction between physical qubits (the actual quantum systems used for computation) and logical qubits (error-corrected qubits that enhance the stability and reliability of quantum computation).",No,9.0, Learning,"as it seeks a conceptual understanding of the difference between physical and logical qubits, aligning with inquiries related to learning and understanding fundamental concepts in quantum computing."
47710012.0,"A book that contains, Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm","<p>I am looking for a book that contains descriptions of the topics: Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm; and possibly others.</p>

<p>Does anyone know a single book or a few that would contain there topics?</p>
",<algorithm><encryption><cryptography><quantum-computing>,12/08/2017 07:57,47710199.0,47710199.0,"<p>There is ""Post-Quantum Cryptography"" published by Daniel J. Bernstein. The book is more of a general overview and doesn't go that far into details.
It contains sections about lattice based, hash based and code based cryptography.
Shor's algorithm as well as discrete logarithm aren't handled in depth, but there is a general overview.
I think the best way to get into the details is by studying the respective scientific papers.</p>
",12/08/2017 08:13,Learning," the question is asking for a resource that would be helpful for someone who is learning about quantum cryptography. These topics are advanced and there are not many books that cover all of them in detail. However, there are a few books that cover some of these topics, and the user is asking for recommendations for these books.",Learning ,,,,Learning,
47777839.0,Unable to create new Q# project using Microsoft Quantum Development Kit,"<p>Having just installed the <a href=""https://www.microsoft.com/en-us/quantum/development-kit"" rel=""noreferrer"">Microsoft Quantum Development Kit</a>, creating a new <strong>Q#</strong> project fails with the obscure message:</p>

<blockquote>
  <p>Argument can't be null: Parameter name: node.</p>
</blockquote>

<p>(I am using a clean install of Visual Studio 2017 Community, with latest updates applied.)</p>

<p>Screen shot illustrating how to reproduce the problem:
<a href=""https://i.stack.imgur.com/CxH5t.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/CxH5t.png"" alt=""enter image description here""></a></p>

<p><br>
And the resultant error message:</p>

<p><a href=""https://i.stack.imgur.com/WD6Ki.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/WD6Ki.png"" alt=""enter image description here""></a></p>

<p><strong>Does anyone know what causes this error, and how it may be resolved?</strong></p>
",<visual-studio-2017><quantum-computing><q#>,12/12/2017 16:58,48014585.0,48014585.0,"<p>I had a similar issue (also with VS Community 2017 and Q#) - a repair of VS fixed the issue for me and it's worked fine since.</p>
",12/28/2017 21:26,Errors ,"The user is encountering an error while trying to create a new Q# project using the Microsoft Quantum Development Kit in Visual Studio 2017 Community. The error message ""Argument can't be null: Parameter name: node"" is displayed, and the user is seeking assistance in understanding the cause of the error and how to resolve it",Tooling,"The issue described pertains to a problem encountered while trying to create a new Q# project using the Microsoft Quantum Development Kit in Visual Studio 2017. This falls under the ""Tooling"" category because it involves a specific software tool or framework (Microsoft Quantum Development Kit) used for quantum development, and the problem is related to its installation and usage.",No,10.0,Errors,as the user is encountering an error message while attempting to create a new Q# project using the Microsoft Quantum Development Kit and seeks assistance in understanding the cause of the error and how to resolve it.
47801787.0,Is it possible to use Q# to control my own quantum computer?,"<p>In short: If I have access to a real quantum computer, is there a possibility to control it using Q#?</p>

<p>Before you downvote this into nirvana because ""there's no quantum computer available yet"": I'm a physicist and our group is able to do real gates on real world qubits. I also have some background in programming (mostly C++).</p>

<p>So for the sake of this question, let's pretend someone has access to a real world device which is able to perform certain quantum operations on a number of qubits. Obviously the number of qubits might be limited and so might be the possible operations. Let's also say someone is proficient enough with Q# and if necessary C#. Is it possible to ""redirect"" the computation from the built in simulator to some real world device? Or would one have to basically rewrite the whole Q# library? Is there some way to define my own <code>QuantumSimulator</code> and how would I start doing that?</p>
",<quantum-computing><q#>,12/13/2017 20:41,47805800.0,47805800.0,"<p>I poked around in the object browser a little.</p>

<p>The C# stubs that you use to call Q# <code>operations</code> look like this:</p>

<pre><code>using (var sim = new QuantumSimulator())
{
  var res = MyOperation.Run(sim, arg1, arg2).Result;
}
</code></pre>

<p>It appears that runtime environment was being passed <em>as an argument</em> to the operation. So I looked at the <code>QuantumSimulator</code> class and then its parent <code>SimulatorBase</code> which had this helpful comment and definition.</p>

<pre><code>//
// Summary:
//     A Base class for Simulators. It provides the infrastructure that makes it easy
//     for a Simulator to become an OperationFactory (so the execution of an Operation
//     can be tied to this simulator) and to manage the allocation of Qubits (via the
//     QubitManager).
public abstract class SimulatorBase : AbstractFactory&lt;AbstractOperation&gt;, IOperationFactory
</code></pre>

<p>I'm interpreting this to mean anything that implements <code>AbstractFactory&lt;AbstractOperation&gt;</code> could be passed as an argument to an operation - thus tying the language structure to the specific run environment. While implementing a real quantum computer, it might be possible to use <code>QuantumSimulator</code> as an example - it looks like it mostly just implements concrete versions of primitive operations from the <code>Microsoft.Quantum.Primitive</code> namespace. (All the primitive operations appear to be abstract classes).</p>

<p>I think you'll probably have to concretely implement each of the primitives to appropriately control the qubits on your machine, but then you <em>might</em> be able to use the Q# language almost out of the box.</p>

<p>This is pretty speculative on my part, but it might be a good place to start.</p>

<p>EDIT:
The four namespaces in the Prelude that will need to be modified are
<a href=""https://learn.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.extensions.bitwise?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft.Quantum.Extensions.Bitwise</a></p>

<p><a href=""https://learn.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.extensions.convert?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft.Quantum.Extensions.Convert</a></p>

<p><a href=""https://learn.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.extensions.math?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft.Quantum.Extensions.Math</a></p>

<p><a href=""https://learn.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.extensions.rangefunctions?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft.Quantum.Extensions.RangeFunctions</a></p>

<p><a href=""https://learn.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.primitive?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft.Quantum.Primitive</a></p>
",12/14/2017 4:13,API Usage ," the Q# API to connect to a real quantum computer and run a quantum program on it. This is a specific question about how to use the Q# API, and it is therefore more accurately classified as API usage.",API Usage,,,,API Usage ,
47819929.0,Q# (Quantum SDK) Canon.dll error,"<p>I tried to run one of the examples of the new Quantum SDK
However, I didn't even manage to run the basic one like TeleportationSample, 
since the error: <code>QS1001 Microsoft.Quantum.Canon.dll not found</code> is displayed.</p>

<p>Other errors:</p>

<pre><code>1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\AmplitudeAmplification\AmplitudeAmplification.qs(421,40,421,43): error CS1001: Identifier expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\AmplitudeAmplification\AmplitudeAmplification.qs(421,40,421,43): error CS1002: ; expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\obj\qsharp\src\Math\Constants.g.cs(33,35,33,36): error CS1002: ; expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\obj\qsharp\src\Math\Constants.g.cs(33,35,33,36): error CS1513: } expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\RandomWalk.qs(81,39,81,57): error CS1001: Identifier expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\RandomWalk.qs(81,39,81,57): error CS1002: ; expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\RandomWalk.qs(82,40,82,58): error CS1001: Identifier expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\RandomWalk.qs(82,40,82,58): error CS1002: ; expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\Robust.qs(37,35,37,37): error CS1001: Identifier expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\Robust.qs(37,35,37,37): error CS1002: ; expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\Robust.qs(38,34,38,36): error CS1001: Identifier expected
1&gt;J:\Users\Markus\Programming\Samples\Microsoft.Quantum.Canon\PhaseEstimation\Robust.qs(38,34,38,36): error CS1002: ; expected
</code></pre>

<p>Please help,
Thanks</p>
",<q#>,12/14/2017 18:29,47829335.0,47829335.0,"<p>Follow this <a href=""https://support.office.com/en-us/article/Change-the-Windows-regional-settings-to-modify-the-appearance-of-some-data-types-edf41006-f6e2-4360-bc1b-30e9e8a54989"" rel=""nofollow noreferrer"">Change Region</a></p>

<p>and set your region to English(USA).
The Problem is related to the numeric format of your region.</p>
",12/15/2017 9:29, Errors,"The user is encountering errors while attempting to run the TeleportationSample example from the Microsoft Quantum SDK. The provided error messages indicate issues related to missing DLLs, syntax errors, and compilation problems in various quantum code files.",Tooling,"The issue described involves difficulties in running examples from the Quantum SDK, specifically regarding missing DLLs and compilation errors within the code. It falls under the ""Tooling"" category because it pertains to the use of specialized software tools and frameworks (the Quantum SDK) for quantum programming and development.",No,11.0,Errors,"as the user is encountering multiple errors while attempting to run examples from the Microsoft Quantum SDK, indicating issues with missing DLLs, syntax errors, and compilation problems in quantum code files."
47838366.0,Apply n qubits to a Hadamard Gate,"<p>First of all sorry for the long text, I tried to explain my problem / misunderstanding as good as possible. </p>

<p>For my student project I have to implement a simulation of a simple Quantum Computer. What I am trying to understand right now is how different Gates are getting applied to n-qubits, bit by bit. </p>

<p>For example one qubit gets represented by two complex numbers (a1, a2) : </p>

<pre><code>a1 |0&gt; + a2 |1&gt;
</code></pre>

<p>Where a1 and a2 are the amplitudes - the possibilities that a value is meassured. All amplitudes squared and summed must always be equal to 1.</p>

<p>So i added a Hadamard Gate, represented by its 2x2 Matrizes</p>

<pre><code>public void Hadamard(){
  gate.entries[0][0] = new ComplexNumber(1,0);
  gate.entries[0][1] = new ComplexNumber(1,0);
  gate.entries[1][0] = new ComplexNumber(1,0);
  gate.entries[1][1] = new ComplexNumber(-1,0);
  gate = (Matrix.scalarMultiplication(gate,Math.pow(2,-0.5)));
}
</code></pre>

<p>Now I would make a Matrixmultiplication with the a1 and a2 with a Hadamard gate. </p>

<p>So I set up a register as a two dimensional array of complex numbers representing the states of the bit as : </p>

<pre><code>Register register = new Register(1); 
</code></pre>

<p>Where the number represents the number of qubits. We only create one row holding all our states and the index of the columns equals the state. So e.g. </p>

<pre><code>[0][0] = |0&gt; and [0][1] = |1&gt; 
</code></pre>

<p>If we say that a1=1+0i and a2=0+0i the multiplication would look like this : </p>

<pre><code> cmplx1 = cmplxMultiplicate(gate.entries[0][0],a1);
 cmplx2 = cmplxMultiplicate(gate.entries[0][1],a2);
 cmplx3 = cmplxMultiplicate(gate.entries[1][0],a1);
 cmplx4 = cmplxMultiplciate(gate.entires[1][1],a2);
 register.entries[0][0] = cmplxAddition(cmplx1,cmplx2); // 0.70710678118
 register.entries[0][1] = cmplxAddition(cmplx3,cmplx4); // 0.70710678118
</code></pre>

<p>Now comes the question - I have no idea how to do this if we have more than one Qubit. For example at two Qubits I would have </p>

<pre><code>a1 |00&gt; + a2 |01&gt; + a3 |10&gt; + a4 |11&gt; 
</code></pre>

<p>Four different states (or 2^(numberOfQubits) states for any given number). But how could i now apply all 4 States to my Hadamard Gate ? Do i have to make all possible outcomes where i multiply a1 with every value, than a2 etc. etc. ? Like this : </p>

<pre><code> cmplx1 = cmplxMultiplicate(gate.entries[0][0],a1);
 cmplx2 = cmplxMultiplicate(gate.entries[0][1],a2);
 cmplx3 = cmplxMultiplicate(gate.entries[1][0],a1);
 cmplx4 = cmplxMultiplciate(gate.entries[1][1],a2);
 cmplx1 = cmplxMultiplicate(gate.entries[0][0],a1);
 cmplx2 = cmplxMultiplicate(gate.entries[0][1],a3);
 cmplx3 = cmplxMultiplicate(gate.entries[1][0],a1);
 cmplx4 = cmplxMultiplciate(gate.entries[1][1],a3);
</code></pre>

<p>I am really clueless about this and i think there is a fundamental misunderstanding on my site that makes things so complicated for me.</p>

<p>Any help leading me on the right way / track would be really appreciated. </p>

<p>Thank you very much.</p>
",<java><math><quantum-computing><qubit>,12/15/2017 18:58,47840169.0,47840169.0,"<p>Note that <a href=""https://en.wikipedia.org/wiki/Hadamard_transform#Quantum_computing_applications"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Hadamard_transform#Quantum_computing_applications</a> writes:</p>

<blockquote>
  <p>It is useful to note that computing the quantum Hadamard transform is simply the application of a Hadamard gate to each qubit individually because of the tensor product structure of the Hadamard transform.</p>
</blockquote>

<p>So it would make sense to just model a single gate, and instantiate that a number of times.</p>

<blockquote>
  <p>But how could i now apply all 4 States to my Hadamard Gate ?</p>
</blockquote>

<p>The gate would get applied to all 4 states of your 2-qubit register. It would operate on pairs of coefficients, namely those which only differ in a single bit, corresponding on the bit position to which the gate gets applied.</p>

<p>If you want to go for the larger picture, apply the Hadamard operation first to the left qubit</p>

<p>((|00âª + |10âª) â©00| + (|00âª â |10âª) â©10| + (|01âª + |11âª) â©01| + (|01âª â |11âª) â©11|) / sqrt(2)</p>

<p>and then to the right qubit</p>

<p>((|00âª + |01âª) â©00| + (|00âª â |01âª) â©01| + (|10âª + |11âª) â©10| + (|10âª â |11âª) â©11|) / sqrt(2)</p>

<p>Writing this as matrices with your order of coefficients (first step right matrix and second step left matrix) you get</p>

<pre><code>  â1  1  0  0â â1  0  1  0â     â1  1  1  1â
  â1 -1  0  0â â0  1  0  1â     â1 -1  1 -1â
Â½ â0  0  1  1â â1  0 -1  0â = Â½ â1  1 -1 -1â
  â0  0  1 -1â  â0  1  0 -1â      â1 -1 -1  1â 
</code></pre>

<p>If you wanted you could encode the product matrix in your notation. But I'd rather find a way to model applying a quantum gate operation to a subset of the qubits in your register while passing through the other bits unmodified. This could be by expaning the matrix, as I did above to go from the conventional 2Ã2 to the 4Ã4 I used. Or it could be in the way you evaluate the matrix times vector product, in order to make better use of the sparse nature of these matrices.</p>

<p>Looking at your code, I'm somewhat worried by the two indices in your <code>register.entries[0][0]</code>. If the first index is supposed to be the index of the qubit and the second the value of that qubit, then the representation is unfit to model entangled situations.</p>
",12/15/2017 21:36,Learning,"the question is asking for help understanding how to apply gates to multiple qubits. This is a fundamental concept in quantum computing, and the user is asking for help from someone who is familiar with quantum computing.",Theoretical,"The user is seeking understanding of the theoretical concepts behind applying quantum gates to multiple qubits and is grappling with the fundamental principles of quantum computation. They are trying to comprehend how quantum gates interact with qubits in a multi-qubit system, which falls under the theoretical aspects of quantum computing.",No,12.0,Learning,"as the user seeks assistance in understanding how to apply gates to multiple qubits, indicating a desire to learn and comprehend fundamental concepts in quantum computing. This aligns with inquiries related to acquiring knowledge and understanding concepts in the field."
47873243.0,Quantum Program The name 'BellTest' does not exist in the current context,"<p>This is my first Q# program and i'm following this getting started link.<a href=""https://learn.microsoft.com/en-us/quantum/quantum-writeaquantumprogram?view=qsharp-preview"" rel=""noreferrer"">https://learn.microsoft.com/en-us/quantum/quantum-writeaquantumprogram?view=qsharp-preview</a></p>

<p>Error is </p>

<blockquote>
  <p>The name 'BellTest' does not exist in the current context 
  but its defined in the Bell.cs</p>
</blockquote>

<p>I followed the steps and when building its having errors. I'm not sure how to import the operations from <code>.qs file</code> to driver <code>c# file</code> as this error looks like it can't find that operation.</p>

<p>Any help is really appreciated </p>

<p>Here is the code</p>

<p>Driver.cs</p>

<pre><code>using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace Quantum.Bell
{
    class Driver
    {
        static void Main(string[] args)
        {
            using (var sim = new QuantumSimulator())
            {
                // Try initial values
                Result[] initials = new Result[] { Result.Zero, Result.One };
                foreach (Result initial in initials)
                {
                    var res = BellTest.Run(sim, 1000, initial).Result;
                    var (numZeros, numOnes) = res;
                    System.Console.WriteLine(
                        $""Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4}"");
                }
            }
            System.Console.WriteLine(""Press any key to continue..."");
            System.Console.ReadKey();

        }
    }
}
</code></pre>

<p>Bell.qs</p>

<pre><code>namespace Quantum.Bell
{
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    operation Set (desired:Result,q1:Qubit) : ()
    {
        body
        {

             let current = M(q1);

            if (desired != current)
            {
                X(q1);
            }

        }
    }

    operation BellTest (count : Int, initial: Result) : (Int,Int)
    {
        body
        {
            mutable numOnes = 0;
            using (qubits = Qubit[1])
            {
                for (test in 1..count)
                {
                    Set (initial, qubits[0]);

                    let res = M (qubits[0]);

                    // Count the number of ones we saw:
                    if (res == One)
                    {
                        set numOnes = numOnes + 1;
                    }
                }
                Set(Zero, qubits[0]);
            }
            // Return number of times we saw a |0&gt; and number of times we saw a |1&gt;
            return (count-numOnes, numOnes);
        }    
    }
}
</code></pre>
",<c#><quantum-computing><q#>,12/18/2017 17:09,47897454.0,47897454.0,"<p>I also got the same error, but I was able to do it by pressing the <code>F5</code> key.</p>

<p>Perhaps the Visual Studio editor is not yet fully support to the <code>.qs</code> file.
Namespace sharing does not seem to be working properly between <code>.cs</code> file and <code>.qs</code> file.</p>

<p>I was able to execute using your code in my development environment.</p>

<p>--</p>

<p>IDE: Visual Studio Community 2017 (Version 15.5.2)<br>
Dev Kit: Microsoft Quantum Development Kit (0 and 1)</p>
",12/20/2017 1:10, Errors,"The reason for the category is that the question is asking for help understanding the error message and how to fix it. The error message is telling the user that the operation BellTest is not defined in the current context. This is because the BellTest operation is defined in the Bell.qs file, but the Driver.cs file is not importing the Bell.qs file.",Tooling,"The user is experiencing an issue with their Q# program, specifically an error related to the Microsoft Quantum Development Kit, which is a specialized software tool for developing quantum algorithms and circuits",No,13.0, Errors,"The user seeks assistance in understanding and resolving an error message related to their Q# program, indicating a need for help in troubleshooting and fixing issues encountered during development, which falls under the Errors category."
48291900.0,Microsoft.Quantum.Canon.nuspec missing,"<p>I am playing around with Microsoft's Q# library, and I've gone through the <a href=""https://learn.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview"" rel=""nofollow noreferrer"">install</a>, however the build is failing and I am having a tough time figuring out the problem. My first suspicion is Microsoft.Quantum.Canon</p>

<pre><code>EXEC : error QS1001: Assembly E:\Projects\Quantum\Microsoft.Quantum.Canon\bin\Debug\Microsoft.Quantum.Canon.dll not found
</code></pre>

<p>I also have noticed Microsoft.Quantum.Canon.nuspec is missing. I've tried to do a <code>Nuget.exe restore</code> on the solutions but that did not work.</p>

<p>Has anyone worked through this?</p>

<p><a href=""https://i.stack.imgur.com/YJbLL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YJbLL.png"" alt=""missing""></a></p>

<p><a href=""https://i.stack.imgur.com/tIHgU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tIHgU.png"" alt=""enter image description here""></a></p>
",<q#>,1/17/2018 0:24,48292002.0,48292002.0,"<p><a href=""https://github.com/Microsoft/Quantum/issues/10"" rel=""nofollow noreferrer"">It's been reported on GitHub already</a>, although it appears to be intentional. See the comments in the .gitignore file:</p>

<pre><code># These files are generated by bootstrap from a .v.template (version template). 
# Any changes must be done to the corresponding the .v.template file directly
Microsoft.Quantum.Canon/Microsoft.Quantum.Canon.nuspec
</code></pre>

<p>I can't find any info on this <code>.v.template</code> file, probably it's part of internal Microsoft build tooling. You can copy the template file and fill in the missing parameters if you wish, but the file not existing doesn't make the build fail , does it?</p>
",1/17/2018 0:37,Errors, the question is asking for help understanding the error message and how to fix it. The error message is telling the user that the assembly Microsoft.Quantum.Canon.dll is not found. This assembly is needed for the user to build their Q# project., Errors,,,,Errors,
48303829.0,"Loop in python which appends answers to a list, I want to then create new list from this","<p>This is the part of my code which works fine;</p>

<pre><code>#taking time average
average= sum(result.expect[0])/len(t)
averagelist=[]
averagelist.append([num-Delta, average])
print(averagelist)
</code></pre>

<p>Giving output;</p>

<pre><code>[[-50, 0.99994894092412567]]
[[-45, 0.9999371327219414]]
[[-40, 0.99992064521708557]]
[[-35, 0.99989662709502258]]
[[-30, 0.99985966374414359]]
[[-25, 0.99979843838324323]]
[[-20, 0.99968609192147129]]
[[-15, 0.99944283644552467]]
[[-10, 0.99874864586107459]]
[[-5, 0.99499296595818931]]
[[0, 0.50250021597634276]]
</code></pre>

<p>Now I want to be able to make a new list x= -50,-45,-40 etc
and new list y= 0.999..., 0.999..., 0.999... etc
Is there a simple way to do this?
(I have also tried the extend as oppose to append function, and this gives me the same initial output but with one square bracket not two.)</p>
",<python><list><append><qutip>,1/17/2018 14:49,48303900.0,48303900.0,"<p>You could use this :</p>

<pre><code>list_x = [i[0] for i in averagelist]
list_y = [i[1] for i in averagelist]
</code></pre>
",1/17/2018 14:53,Errors,"The user is facing an issue in their code where they want to create two separate lists, 'x' and 'y', from the existing 'averagelist'. They are seeking a solution to this problem, which falls under the category of troubleshooting and error resolution in programming.", Errors,,,,Errors,
48453676.0,Python Multiprocessing Error with IBM API (Q Experience),"<p>I'm trying to use the IBM Q Experience API and I installed the library and wrote a quick test code.  At first, it couldn't find the module.  Then, I added the whole sys thing.  Admittedly, I just copied that from a stackoverflow post so that may be the problem.  Anyways, I got ""RunTime Error"" which leads to the python multiprocessing lib.  The IBM Q doesn't have a big community, so I couldn't find anything after researching a little while.  I'm completely unfamiliar with multiprocessing, threading, etc, so I imagine just seeing the code and error will be better than anything I can do to explain.  Thanks in advance.</p>

<pre class=""lang-python prettyprint-override""><code>import sys
sys.path.append(""../../"")

from qiskit import QuantumProgram

#visualization
from tools.visualization import plot_histogram

#set up registers
qp = QuantumProgram()
q = qp.create_quantum_register(""q"", 3)
c = qp.create_classical_register(""c"", 3)

#define our circuit
threeQ = qp.create_circuit(""threeQ"", [q], [c])
threeQ.measure(q[0], c[0])
threeQ.measure(q[1], c[1])
threeQ.measure(q[2], c[2])

#run
result = qp.execute([""threeQ""])

#plot
plot_histogram(result.get_counts(""threeQ""))
</code></pre>

<p>The error I get (sorry, it's long):</p>

<pre><code>Traceback (most recent call last):
  File ""&lt;string&gt;"", line 1, in &lt;module&gt;
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main
    exitcode = _main(fd)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main
    prepare(preparation_data)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare
    _fixup_main_from_path(data['init_main_from_path'])
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path
    run_name=""__mp_main__"")
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path
    pkg_name=pkg_name, script_name=fname)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code
    mod_name, mod_spec, pkg_name, script_name)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code
    exec(code, run_globals)
  File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt;
    print(qp.execute([""threeQ""]))
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute
    result = self.run(qobj, wait=wait, timeout=timeout)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run
    timeout=timeout)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal
    job_processor.submit()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit
    future = executor.submit(run_backend, q_job)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit
    self._start_queue_management_thread()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread
    self._adjust_process_count()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count
    p.start()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start
    self._popen = self._Popen(self)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen
    return _default_context.get_context().Process._Popen(process_obj)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen
    return Popen(process_obj)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__
    prep_data = spawn.get_preparation_data(process_obj._name)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data
    _check_not_importing_main()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main
    is not going to be frozen to produce an executable.''')
RuntimeError:
        An attempt has been made to start a new process before the
        current process has finished its bootstrapping phase.

        This probably means that you are not using fork to start your
        child processes and you have forgotten to use the proper idiom
        in the main module:

            if __name__ == '__main__':
                freeze_support()
                ...

        The ""freeze_support()"" line can be omitted if the program
        is not going to be frozen to produce an executable.
Traceback (most recent call last):
  File ""&lt;string&gt;"", line 1, in &lt;module&gt;
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main
    exitcode = _main(fd)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main
    prepare(preparation_data)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare
    _fixup_main_from_path(data['init_main_from_path'])
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path
    run_name=""__mp_main__"")
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path
    pkg_name=pkg_name, script_name=fname)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code
    mod_name, mod_spec, pkg_name, script_name)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code
    exec(code, run_globals)
  File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt;
    print(qp.execute([""threeQ""]))
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute
    result = self.run(qobj, wait=wait, timeout=timeout)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run
    timeout=timeout)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal
    job_processor.submit()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit
    future = executor.submit(run_backend, q_job)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit
    self._start_queue_management_thread()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread
    self._adjust_process_count()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count
    p.start()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start
    self._popen = self._Popen(self)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen
    return _default_context.get_context().Process._Popen(process_obj)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen
    return Popen(process_obj)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__
    prep_data = spawn.get_preparation_data(process_obj._name)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data
    _check_not_importing_main()
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main
    is not going to be frozen to produce an executable.''')
RuntimeError:
        An attempt has been made to start a new process before the
        current process has finished its bootstrapping phase.

        This probably means that you are not using fork to start your
        child processes and you have forgotten to use the proper idiom
        in the main module:

            if __name__ == '__main__':
                freeze_support()
                ...

        The ""freeze_support()"" line can be omitted if the program
        is not going to be frozen to produce an executable.
Traceback (most recent call last):
  File ""&lt;string&gt;"", line 1, in &lt;module&gt;
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main
    exitcode = _main(fd)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main
    prepare(preparation_data)
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare
    _fixup_main_from_path(data['init_main_from_path'])
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path
    run_name=""__mp_main__"")
  File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path
ERROR
</code></pre>
",<windows><multiprocessing><runtime-error><quantum-computing><qiskit>,1/25/2018 23:38,48471003.0,48471003.0,"<p>This is a general issue with multi-threading in Python on Windows. The solution is to put your top-level code in an <em>if __name__ == ""__main__""</em> block, as in:</p>

<pre><code>if __name__ == '__main__':
    &lt;your code here&gt;
</code></pre>

<p>Hope that helps!</p>
",1/26/2018 23:28,Errors,The error message indicates that the program is trying to start a new process before the current process has finished its bootstrapping phase. This is usually caused by forgetting to use the if __name__ == '__main__': idiom in the main module.,Errors,,,,Errors,
48732603.0,qcircuit.sty not found when visualizing a QISKit quantum scheme,"<p>I followed <a href=""https://nbviewer.jupyter.org/github/QISKit/qiskit-tutorial/blob/master/reference/tools/getting_started.ipynb"" rel=""nofollow noreferrer"">this manual</a> in order to visualize my <a href=""https://www.qiskit.org/"" rel=""nofollow noreferrer"">QISKit</a> v0.4.8 quantum circuit by means of the <code>latex_drawer()</code> function (in newer versions of QISKit the function is <code>circuit_drawer()</code>). However, I got the following error when running the code:</p>

<pre><code>! LaTeX Error: File `qcircuit.sty' not found.
</code></pre>

<p>Is <code>qcircuit.sty</code> a part of QISKit? What is the best way to fix the issue?</p>

<p>By the way, this is the function that I use to produce the image of a circuit:</p>

<pre class=""lang-python prettyprint-override""><code>def circuit_image(circuit, basis=""u1,u2,u3,cx""):
    filename = 'circuit'
    tmpdir = 'tmp'
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    filename_tex = filename + "".tex""
    filename_pdf = filename + "".pdf""
    latex_drawer(circuit, os.path.join(tmpdir, filename_tex), basis=basis)
    os.system(""pdflatex -output-directory {} {}"".format(tmpdir, filename_tex))
    images = pdf2image.convert_from_path(os.path.join(tmpdir, filename_pdf))
    shutil.rmtree(tmpdir)
    return images[0]
</code></pre>
",<latex><pdflatex><quantum-computing><qiskit>,02/11/2018 14:35,48732604.0,48732604.0,"<p><code>qcircuit</code> is a third-party LaTeX package that is not part of QISKit. If your LaTeX distribution does not come with this package, you can install it by yourself.</p>

<p>For example, for Ubuntu 14.04.5 LTS do the following:</p>

<ol>
<li><a href=""https://ctan.org/tex-archive/graphics/qcircuit"" rel=""nofollow noreferrer"">Download</a> the zip-file</li>
<li>Unpack it to <code>/usr/share/texlive/texmf-dist/tex/latex</code></li>
<li>Run <code>sudo texhash</code></li>
</ol>

<p>For more information on installing LaTeX packages, see the following pages:</p>

<ul>
<li><a href=""https://tex.stackexchange.com/questions/28528/best-way-to-install-packages-for-texlive-in-ubuntu"">Best way to install packages for TeXLive in Ubuntu?</a></li>
<li><a href=""https://askubuntu.com/questions/371430/how-to-install-latex-packages-for-tex-live"">How to install LaTeX packages for Tex Live?</a></li>
</ul>
",02/11/2018 14:35,Tooling," because the question is about using a specific tool, the latex_drawer() function in QISKit v0.4.8, to visualize a quantum circuit. The error message that the user is receiving indicates that the qcircuit.sty file is not found, which is a problem with the tool itself.",Tooling,,,,Tooling,
48793050.0,Install qiskit on MacOS HighSierra Error: No such file or directory: 'qiskit.egg-info',"<p>I was trying to install QISKit via the pip method as mentioned on <a href=""https://www.qiskit.org/documentation/install.html"" rel=""nofollow noreferrer"">their webpage</a>.</p>

<p>However, after many trials, this method doesn't seem to work and I am getting the following error on the terminal.</p>

<pre class=""lang-none prettyprint-override""><code>  Compiling QISKit C++ Simulator
  creating out
  WARNING: Seems like the cpp simulator can't be built, Qiskit will install anyway, but won't have this simulator support.
  installing to build/bdist.macosx-10.6-x86_64/wheel
  running install
  running install_lib
  warning: install_lib: 'build/lib' does not exist -- no Python modules to install

  running install_egg_info
  Copying qiskit.egg-info to build/bdist.macosx-10.6-x86_64/wheel/qiskit-0.4.9.data/purelib/qiskit-0.4.9-py3.5.egg-info
  error: [Errno 2] No such file or directory: 'qiskit.egg-info'

  ----------------------------------------
  Failed building wheel for qiskit (*)
  Running setup.py clean for qiskit
Failed to build qiskit 
Installing collected packages: Sphinx, qiskit
  Found existing installation: Sphinx 1.4.6
Cannot remove entries from nonexistent file /Users/photon/anaconda3/lib/python3.5/site-packages/easy-install.pth (*)
</code></pre>

<p>where the lines ending with (*) are in red in the terminal. </p>

<p>How can I solve this?</p>
",<python><python-3.x><pip><anaconda><qiskit>,2/14/2018 17:30,48800112.0,48800112.0,"<p>You can try to install cmake.</p>

<pre><code>pip install cmake
</code></pre>

<p>I also had an issue with the latest QISKit. Kindly check the issue at the github page <a href=""https://github.com/QISKit/qiskit-sdk-py/issues/292"" rel=""nofollow noreferrer"">QIS Issue 292</a>.</p>
",2/15/2018 4:48,Errors,"The user is encountering an error while trying to install a quantum programming library (QISKit) using pip, which falls under the Errors category. They are seeking help to resolve this installation issue.",Errors,,,,Errors,
48814378.0,Is Microsoft Q# .Net framework compatible?,"<p>Q# is an interesting new language from Microsoft dedicted to performing quantum computation. </p>

<p>Does it compile to a .net library that can be referenced from c# or any other .net language .Net Framework and/or .Net Core Framework (.Net standard maybe)?</p>

<p>If not then how can it be incorporated into classic applications?</p>

<p>If it can be then what will a quantum computer be like? Will it allow to run full .net architecture plus quantum as a coprocessor (somehow like a GPU programming) or how else will it look work like? </p>
",<c#><.net><quantum-computing><q#>,2/15/2018 18:54,48816273.0,48816273.0,"<p>Yes, Q# is even transpiled to C# and then compiled as a regular .Net assembly.</p>

<p>You can verify this by (after installing the development kit) running through this tutorial: <a href=""https://learn.microsoft.com/en-us/quantum/quantum-writeaquantumprogram"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/quantum/quantum-writeaquantumprogram</a>. Q# and C# code can co-exist in the same project (at the moment). Q# files are converted to .qs.cs files (found under the <code>obj\qsharp\src</code> folder).</p>
",2/15/2018 21:06,Conceptual,The question asks about the future of quantum computing and how it will incorporate classical computing architectures., Conceptual,,,,Conceptual,
48850056.0,How to create a new quantum gate and qubit initialised to a certain value,"<p>I am trying to implement the Quantum HHL algorithm on QISKit package of IBM on Python. I have tried searching the documentation for a method to initialize a  qubit to a certain value and to create a new unitary gate with specified values. </p>

<p>In the documentation, I found <a href=""https://github.com/QISKit/qiskit-sdk-py/blob/master/qiskit/_gate.py"" rel=""nofollow noreferrer"">this</a>, which is the class of a Quantum Gate. I tried to make a new instance of this class but I couldn't because not much documentation has been done about the arguments to be passed while initializing the instance of the class. </p>
",<python-3.x><linear-algebra><quantum-computing><qiskit>,2/18/2018 9:12,48856527.0,48856527.0,"<p>As of QISKit v0.4.9, the <a href=""https://www.qiskit.org/documentation/_autodoc/qiskit.extensions.standard.html#qiskit.extensions.standard.u3"" rel=""nofollow noreferrer""><code>u3()</code></a> function parametrizes an arbitrary single-qubit unitary gate <em>U(Î¸, Ï, Î»)</em> (for details, <a href=""https://arxiv.org/pdf/1707.03429.pdf"" rel=""nofollow noreferrer"">see</a> formula (2)). Obviously, you can use the <code>u3()</code> function to set a qubit to any value.</p>

<p>For example, this is how you can implement the <em>X</em>-gate and apply it to some qubit <code>qr[0]</code> via the <em>U3</em>-gate:</p>

<pre class=""lang-python prettyprint-override""><code>u3(theta=math.pi, phi=0, lam=0, q=qr[0])
</code></pre>
",2/18/2018 21:02,Tooling,"The question is about how to use Qiskit to initialize qubits to certain values and create new unitary gates. These are both tasks that are essential for quantum programming, so the question is asking about how to use a specific tool (Qiskit) to accomplish them.",Tooling,,,,Tooling,
48997526.0,Does OpenSSL provide any post quantum asymmetric algorithms?,"<p>I'm familiar with classical encryption algorithms and mathematics, like RSA and ECC, but just out of interest. I'm not a specialist in this field. I'd like to start a long-term project, but since I'm not a cryptographer, it's very difficult to research this topic and get a clear and correct answer. I'm looking to use OpenSSL as a black-box for this purpose.</p>

<p><strong>My question:</strong> Does OpenSSL provide any post quantum asymmetric algorithms for both encryption and/or signatures?</p>

<p>If not, are there any plans in the future to support this?</p>

<p>PS: Please note that I'm not asking for software recommendation as I understand this is off-topic. I'm asking about OpenSSL here and its supported algorithms.</p>
",<c++><encryption><openssl><public-key-encryption><post-quantum-cryptography>,2/26/2018 21:38,48998216.0,48998216.0,"<p>No, it does not.</p>

<p>However, you should monitor the <a href=""https://openquantumsafe.org"" rel=""nofollow noreferrer"">Open Quantum Safe project</a>, which creates a library that operates with OpenSSL with the view of introducing post-quantum safe algorithms into OpenSSL.</p>
",2/26/2018 22:36,Conceptual,"The user is seeking information about the support for post-quantum asymmetric encryption algorithms in OpenSSL. They are not looking for software recommendations but rather inquiring about the capabilities and future plans of OpenSSL, which falls under the category of discussing the background and underlying concepts of quantum-resistant cryptography.",Conceptual,,,,Conceptual,
49061751.0,Challenges in Enabling Practical-Scale Quantum Computing?,"<p>This question will be useful to many. </p>

<p>Can we collate a list of challenges in enabling Practical-Scale Quantum Computing?</p>

<p>Nathan Aw</p>
",<quantum-computing>,03/02/2018 02:13,49329850.0,49329850.0,"<p>The challenges are dependent on the physical architecture.  Pick a physical implementation and look for which of the DiVincenzo's criterias are missing.  These would be the chosen architecture's challenges.</p>
",3/16/2018 21:34,Conceptual , The user is asking for a discussion about the challenges in enabling practical-scale quantum computing. This falls under the Conceptual category as it involves understanding the underlying concepts and challenges in the field of quantum computing. ,Conceptual,,,,Conceptual ,
49458157.0,3 Way Quantum Entanglement with a Hadamard Transformed (superposition) Qubit,"<p>When running the following operations on 3 qubits:</p>

<pre><code>H(qubits[0]);
CNOT(qubits[0], qubits[1]);
CNOT(qubits[0], qubits[2]);
CNOT(qubits[1], qubits[2]);
</code></pre>

<p>I get these results:
qubit 0 is in a superposition
qubit 1 is the same as qubit 0
qubit 2 is the same as qubit 0 half the time. e.g. superposition-like values.</p>

<p>Why does running CNOT on qubit 2 with both other qubits after running CNOT on qubit 1 with qubit 0 cause qubit 2 to enter a state of superposition between qubit 0 and not qubit 0?</p>
",<quantum-computing><q#><qubit>,3/23/2018 20:53,49463507.0,49463507.0,"<p>If you do some quantum computing maths, you will find out that you end up in the following state:</p>

<pre class=""lang-none prettyprint-override""><code>|Ï âª = (|000âª + |011âª) / â2
</code></pre>

<p>This is essentially a superposition between qubit 0 and entangled qubits 1 and 2.</p>

<pre class=""lang-none prettyprint-override""><code>|Ï âª = |0âª â (|00âª + |11âª) / â2
</code></pre>

<p>You can do this maths with <a href=""https://www.qiskit.org"" rel=""nofollow noreferrer"">IBM QISKit</a> in Python:</p>

<pre class=""lang-python prettyprint-override""><code>from qiskit import QuantumProgram
from math import sqrt
import numpy as np

qp = QuantumProgram()
cname = '3-qubit'
num_qubits = 3
qr = qp.create_quantum_register('qr', num_qubits)
cr = qp.create_classical_register('cr', num_qubits)
qc = qp.create_circuit(cname, [qr], [cr])

qc.h(qr[0])
qc.cx(qr[0], qr[1])
qc.cx(qr[0], qr[2])
qc.cx(qr[1], qr[2])

qc.measure(qr, cr)

results = qp.execute(cname)
print(results.get_counts(cname))
</code></pre>

<p>This would give you a result similar to the following:</p>

<pre class=""lang-none prettyprint-override""><code>{'000': 530, '011': 494}
</code></pre>

<p>You can also explicitly obtain this state |Ïâª by taking the unitary matrix of your circuit and applying it to your initial state |000âª, that is a vector <code>[1,0,0,0,0,0,0,0]</code>:</p>

<pre class=""lang-python prettyprint-override""><code>results = qp.execute(cname, backend='local_unitary_simulator', shots=1)
data = results.get_data(cname)
u = np.real(data['unitary'] * sqrt(2.0)).astype(int)
psi = np.zeros(2**num_qubits, dtype=np.int_)
psi[0] = 1
u @ psi
</code></pre>

<p>The result is</p>

<pre class=""lang-none prettyprint-override""><code>array([1, 0, 0, 1, 0, 0, 0, 0])
</code></pre>

<p>The 0-th entry is |000âª, the 3-rd entry is |011âª.</p>
",3/24/2018 10:12,Theoretical,"The question is about the theoretical understanding of the behavior of qubits in a quantum circuit, specifically about the effects of CNOT operations on qubits. The reason for qubit 2 entering a state of superposition is due to the nature of quantum entanglement created by the CNOT gates",Theoretical,,,,Theoretical,
49536860.0,.NET core WSL installation and DllNotFoundException,"<p>I am trying new <a href=""https://github.com/microsoft/quantum"" rel=""nofollow noreferrer"">Q#</a> language on a Windows 10 machine.
I have three Windows 10 machines, all of them have WSL (Ubuntu).
Out of three, two were able to install latest .NET Core SDK and run <code>Q#</code> code
as it is executed natively on Windows.
However, third machine fails to run (but compiles perfectly).
Somehow, installation of SDK is being corrupted and I get Runtime Exceptions at the moment <code>C#</code> code calls methods from <code>Microsoft.Quantum.*</code>.</p>

<p>I tried to reinstall Ubuntu WSL (clean), but the problem is still there.
It has something to do with the fact that on this machine the WSL lives since preview and before it was shipped to Win Store. 
For the sake of experiment I downloaded Debian (from the Store), installed only .NET SDK and <code>Q#</code> code worked fine.</p>

<p>Now the question is how can I <strong>PURGE</strong> the legacy Ubunut WSL and get a fresh install on that particular machine?</p>

<p>This is the output generated by the WSL on the <code>dotnet run</code> command</p>

<pre><code>Unhandled Exception: System.DllNotFoundException: Unable to load DLL 
'Microsoft.Quantum.Simulator.Runtime.dll': The specified module or one of its dependencies could not be found.
 (Exception from HRESULT: 0x8007007E)
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator.Init()
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator..ctor(Boolean 
throwOnReleasingQubitsNotInZeroState, Nullable`1 randomNumberGeneratorSeed, 
Boolean disableBorrowing)
   at Bell.Driver.Test_Simple() in 
/mnt/c/Users/.../Programming/Temp/QS/Bell/Driver.cs:line 26
    at Bell.Driver.Main(String[] args) in 
/mnt/c/Users/.../Programming/Temp/QS/Bell/Driver.cs:line 12
</code></pre>

<p>This is the method from which I call <code>Q#</code>-related code</p>

<pre class=""lang-cs prettyprint-override""><code> private static void Test_Simple()
    {
        WriteLine($""\r\n{nameof(Test_Simple)}"");
        var header = $""{""Initial"", -10}|{Result.Zero, -10}|{Result.One, -10}|"";
        WriteLine(new string('-', header.Length));
        WriteLine(header);
        WriteLine(new string('-', header.Length));
        // --&gt; Exception is thrown here &lt;--
        using (var simulator = new QuantumSimulator())
        {
            var nRuns = 10_000;
            var initials = new [] { Result.Zero, Result.One };
            foreach (var init in initials)
            {
                var (nZero, nOne) =
                    Quantum.BellTestSimple.Run(simulator, nRuns, init).Result;
                WriteLine($""{init, -10}|{nZero, -10}|{nOne, -10}"");                
            }

        }
    }
</code></pre>

<p>This <strong>exact same</strong> project runs fine on the <strong>same</strong> machine natively and on Debian subsystem, but fails on Ubuntu subsytem.</p>
",<c#><.net-core><ubuntu-16.04><windows-subsystem-for-linux><q#>,3/28/2018 14:11,50826795.0,50826795.0,"<p>It may be that you are missing native libraries that the <code>Microsoft.Quantum.Simulator.Runtime.dll</code> library depends on. Other users have <a href=""https://stackoverflow.com/a/49619059/267841"">reported</a>, for instance, that they were missing libgomp1. To check if you have all of the dependencies you need, you can use <code>ldd</code> to get a report of how each native runtime dependency is resolved. For instance:</p>

<pre><code>$ ldd ~/.nuget/packages/microsoft.quantum.development.kit/0.2.1802.2202-preview/runtimes/linux-x64/native/Microsoft.Quantum.Simulator.Runtime.dll
    linux-vdso.so.1 =&gt;  (0x00007fffc4fab000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f1d692d0000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1d68fc0000)
    libgomp.so.1 =&gt; /usr/lib/x86_64-linux-gnu/libgomp.so.1 (0x00007f1d68d80000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1d689b0000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f1d69a00000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f1d68790000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f1d68570000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f1d68350000)
</code></pre>

<p>This snippet shows us that <code>libgomp.so.1</code> was successfully resolved to <code>/usr/lib/x86_64-linux-gnu/libgomp.so.1</code>, whereas if that library were missing you'd get a different listing:</p>

<pre><code>$ ldd ~/.nuget/packages/microsoft.quantum.development.kit/0.2.1802.2202-preview/runtimes/linux-x64/native/Microsoft.Quantum.Simulator.Runtime.dll
    linux-vdso.so.1 =&gt;  (0x00007fffc5103000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f713cfd0000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f713ccc0000)
    libgomp.so.1 =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f713c8e0000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f713d600000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f713c6c0000)
</code></pre>
",06/12/2018 22:38,Errors,"The user is experiencing runtime exceptions when attempting to run Q# code on a specific Windows 10 machine with Ubuntu WSL. They are seeking a solution to resolve the issue related to the installation of .NET Core SDK and Q# on this machine, which falls under the category of troubleshooting and error resolution in software development.",Errors,,,,Errors,
49579153.0,Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll',"<p>Getting Unable to load DLL <code>'Microsoft.Quantum.Simulator.Runtime.dll'</code> error while trying to validate my Q# environment by running the teleport sample program. </p>

<pre><code>dotnet build
dotnet run

platform windows 7 64 bit with AVX enabled. vscode with .NET Core SDK 2.0


Unhandled Exception: System.DllNotFoundException: Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll': The specified module could not be found. (Exception from HRESULT: 0x8007007E)
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator.Init()
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator..ctor(Boolean throwOnReleasingQubitsNotInZeroState, Nullable`1 randomNumberGeneratorSeed, Boolean disableBorrowing)
   at Microsoft.Quantum.Examples.Teleportation.Program.Main(String[] args) in C:\opt\workspace\quantum\Quantum\Samples\Teleportation\Program.cs:line 13
</code></pre>
",<c#><.net><visual-studio-code><quantum-computing><q#>,3/30/2018 17:59,49579176.0,49579176.0,"<p>copy the <code>Microsoft.Quantum.Simulator.Runtime.dll</code> from 
<code>C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\runtimes\win10-x64</code> to <code>C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\lib\netstandard2.0</code>. Although I have not tested this with the older Microsoft Quantum Development Kit version, there seems to be problem with the 0.2.1802.2202 version. Make sure to check if AVX is avaialble, you can use CPU-Z tool to check that in instructions section.</p>

<p>then run <code>dotnet run</code> which should result in the </p>

<pre><code>Round 0:        Sent False,     got False.
Teleportation successful!!

Round 1:        Sent True,      got True.
Teleportation successful!!

Round 2:        Sent False,     got False.
Teleportation successful!!

Round 3:        Sent False,     got False.
Teleportation successful!!

Round 4:        Sent False,     got False.
Teleportation successful!!

Round 5:        Sent False,     got False.
Teleportation successful!!

Round 6:        Sent False,     got False.
Teleportation successful!!

Round 7:        Sent True,      got True.
Teleportation successful!!



Press Enter to continue...
</code></pre>
",3/30/2018 18:01,Errors," The user is encountering a specific error (Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll') while trying to run a quantum program, which falls under the Errors category as they are seeking solutions and explanations for this error",Errors,,,,Errors,
49972596.0,Q# Console Template DOTNET not working on MAC,"<pre><code>$ dotnet new console -lang Q# --output Bell

Error: Invalid parameter(s):
-lang Q#
    'Q#' is not a valid value for -lang (language).
</code></pre>

<p>Run dotnet new console --help for usage information.
See <a href=""https://aka.ms/dotnet-install-templates"" rel=""noreferrer"">https://aka.ms/dotnet-install-templates</a> to learn how to install additional template packs.</p>

<p>I also tried running:</p>

<pre><code>dotnet new -i Microsoft.DotNet.Common.ProjectTemplates.2.x::2.0.0-*
</code></pre>

<p>But even this command could not add the project any idea how I can get this template.</p>
",<visual-studio-code><quantum-computing><q#>,4/23/2018 2:25,50823227.0,50823227.0,"<p>I think you need to run:</p>

<pre><code>dotnet new -i ""Microsoft.Quantum.ProjectTemplates::0.2-*""
</code></pre>

<p>Take a look at <a href=""https://learn.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&amp;tabs=tabid-vscode"" rel=""noreferrer"">https://learn.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&amp;tabs=tabid-vscode</a> for more complete instructions.</p>
",06/12/2018 18:05, Errors,"The user is encountering a specific error ('Q#' is not a valid value for -lang (language)) while trying to create a new Q# project using the dotnet command, which falls under the Errors category as they are seeking solutions and explanations for this error.",Errors,,,, Errors,
50310658.0,"IBM QISKit local simulator error, can't find gcc","<p>When I want to run the Bell example code from qiskit.org in macOS terminal it throws this error:</p>

<pre><code>ERROR:qiskit.backends.local.qasm_simulator_cpp:ERROR: Simulator encountered a runtime error: dyld: Library not loaded: /usr/local/opt/gcc/lib/gcc/7/libgomp.1.dylib
</code></pre>

<p>Python3 works well and I have Xcode installation but the gcc is not there (I found it in /usr/bin). What can I do? </p>
",<python><xcode><macos><gcc><qiskit>,05/12/2018 21:03,50687820.0,50687820.0,"<p>Remove your current installation </p>

<p>pip uninstall qiskit</p>

<p>Then install 0.5.3 </p>

<p>pip install qiskit</p>

<p>Should work out of the box. I ran into this same issue with 0.5. Test with a default program</p>

<p><a href=""https://github.com/QISKit/qiskit-sdk-py#creating-your-first-quantum-program"" rel=""nofollow noreferrer"">https://github.com/QISKit/qiskit-sdk-py#creating-your-first-quantum-program</a></p>
",06/04/2018 19:49,Errors,"The user is encountering a specific error (ERROR:qiskit.backends.local.qasm_simulator_cpp:ERROR: Simulator encountered a runtime error: dyld: Library not loaded: /usr/local/opt/gcc/lib/gcc/7/libgomp.1.dylib) while trying to run a Qiskit program, which falls under the Errors category as they are seeking solutions and explanations for this error",Errors,,,,Errors,
50656649.0,Microsoft Q# : problems with rotate function R(),"<p>Recently I've been working on algorithms of quantum computing where I faced some problems.</p>
<p>As there are probabilities for qubits to be observed as <code>|1&gt;</code> or <code>|0&gt;</code>, the rotation function is supposed to change the status of each qubit so that there can be more or fewer chances for them to be measured in a specific status.</p>
<p>In my program, I applied Hadamard transformation to a qubit and then rotated it with an angle Î¸(90Â°) in the z-axis, which was to make an equal probability of <code>|0&gt;</code> and <code>|1&gt;</code> measurement and then the rotation made the probs of status <code>|1&gt; 100%</code>, but it didn't work anyway. The probs for <code>|1&gt;</code> will always be 50% which is not supposed to be.</p>
<p>Here is my code:</p>
<pre><code>operation Testing () : (Int)
{
    body
    {
        mutable result = -1;
        using (qubit = Qubit[1])
        {
            H(qubit[0]);
            R(PauliZ, PI() / -2.0, qubit[0]);

            //assertprob is a function to help test the probabilities of qubits in specific status
            AssertProb([PauliZ], qubit, One, 0.5,&quot;Measuring in conjugate basis did not give 50/50 results.&quot;, 1e-5);
            //AssertProb([PauliZ], qubit, Zero, 0.5,&quot;Measuring in conjugate basis did not give 50/50 results.&quot;, 1e-5);

            let value = M(qubit[0]);
            if(value == One)
            {
                set result = 1;
            } else {
                set result = 0;
            }
            ResetAll(qubit);
        }
        return result;
    }
}
</code></pre>
<p>A photo from <a href=""https://learn.microsoft.com/en-us/azure/quantum/user-guide/?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft Q# documentation</a> may help explain the sphere structure. After the Hadamard transformation, the qubit is in status <code>[1/â2,1/â2]</code> and then the rotation of <code>-Ï/2</code> makes it to status <code>[0,1]</code>.</p>
<p><a href=""https://i.stack.imgur.com/4Ahzy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4Ahzy.png"" alt="""" /></a><br />
<sub>(source: <a href=""https://learn.microsoft.com/en-us/quantum/media/concepts_bloch.png?view=qsharp-preview"" rel=""nofollow noreferrer"">microsoft.com</a>)</sub></p>
",<q#>,06/02/2018 11:54,50822641.0,50822641.0,"<p>Applying a rotation around the Pauli Z axis doesn't change the measurement probabilities of Z-axis measurements. You can visualize it this way:</p>

<ul>
<li>Your qubit's initial state is at +1 on the Z axis.</li>
<li>The H operation moves it onto +1 on the X axis.</li>
<li>Any rotation around the Z axis keeps the qubit's state in the X-Y plane, which is equally likely to measure as 0 or as 1 in the Z axis.</li>
</ul>

<p>A pi/2 or 3pi/2 rotation around the Y axis will get the state back to the Z axis.</p>
",06/12/2018 17:26,Theoretical,"The user is discussing the theoretical aspects of quantum computing, specifically about the behavior of qubits and quantum gates (Hadamard transformation and rotation), which falls under the Theoretical category.",Theoretical,,,,Theoretical,
51116480.0,How do I properly manage the lifetime of a Qubit in C#,"<p>I'm playing around with Q#, which uses C# as a driver.  I'd like to pass a Qubit object to the Q# code but it isn't working as expected.</p>
<p>C# Driver</p>
<pre class=""lang-cs prettyprint-override""><code>using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace Quantum.QSharpApplication1 {
    class Driver {
        static void Main(string[] args) {
            using (var sim = new QuantumSimulator()) {
                var x = new Microsoft.Quantum.Simulation.Common.QubitManager(10);
                Qubit q1 = x.Allocate();
                Solve.Run(sim, q1, 1);
                }
            System.Console.WriteLine(&quot;Press any key to continue...&quot;);
            System.Console.ReadKey();
            }
        }
    }
</code></pre>
<p>Q#</p>
<pre><code>namespace Quantum.QSharpApplication1
{
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    operation Solve (q : Qubit, sign : Int) : ()
    {
        body
        {
            let qp = M(q);
            if (qp != Zero)
            {
                X(q);
            }     
            H(q);
        }
    }
}
</code></pre>
<p>When I run this, it runs without error until it reaches the System.Console.* lines at which point it throws the following exception in the Q# code</p>
<pre class=""lang-none prettyprint-override""><code>System.AccessViolationException
  HResult=0x80004003
  Message=Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
  Source=&lt;Cannot evaluate the exception source&gt;
  StackTrace:
&lt;Cannot evaluate the exception stack trace&gt;
</code></pre>
<p>The debugger associates this with the &quot;let qp = M(q);&quot; line in Q#.</p>
<p>Note this does happen in the Solve.Run call, the real code has multiple Solve calls and the output appear correct.  It only appears to occur after the using QuantumSimulator scope is left.  I recall reading that the Qubit must be reset to zero before it is released. I'm not sure if that is the problem here, but I don't see a way to do that in C#.  Interesting I remove the Console lines, the program will run without error (timing?).</p>
",<c#><q#>,6/30/2018 16:07,51142719.0,51142719.0,"<p>The <code>QubitManager</code> instance you used to create the qubits is not a singleton (each <code>Simulator</code> has its own <code>QubitManager</code>), therefore the <code>Simulator</code> is not aware of the <code>Qubit</code> your trying to manipulate on the Q# code, thus the <code>AccessViolationException</code>.</p>

<p>In general, creating Qubits on the driver is not supported; you can <a href=""https://learn.microsoft.com/en-us/quantum/quantum-techniques-5-workingwithqubits?view=qsharp-preview#allocating-qubits"" rel=""nofollow noreferrer"">only allocate qubits using the <code>allocate</code> and <code>borrowing</code></a> statements inside Q#. The recommendation is to create an entry point in Q# to allocate the qubits which does the qubit allocation and call this from the driver, for example:</p>

<pre><code>// MyOp.qs
operation EntryPoint() : () 
{
    body
    {
        using (register = Qubit[2]) 
        {
            myOp(register);
        }
    }
}


// Driver.cs
EntryPoint.Run().Wait();
</code></pre>

<p>Finally, note that in your driver code you have this:
<code>
Solve.Run(sim, q1, 1);
</code></p>

<p>The <code>Run</code> method returns a tasks that executes asynchronously. You must typically add a <code>Wait()</code> to make sure it finishes execution:
<code>
EntryPoint.Run(sim, 1).Wait();
</code></p>

<p>If you do this you will notice that failure during the <code>Run</code>, not the <code>Console.WriteLine</code>.</p>
",07/02/2018 19:37,Errors ,"The user is encountering a specific error (System.AccessViolationException) while trying to run a quantum program using Q# and C#, which falls under the Errors category as they are seeking solutions and explanations for this error",Errors,,,,Errors ,
51118102.0,Find the length of the array that was passed to you in Q#,"<p>I have an operation as follows to which the driver needs to send an array of qubits.</p>

<pre><code>operation myOp(qubits: Qubit[]) : () {
     // uses elements from the qubit array        
 }
</code></pre>

<p>How do I find the length of this array from within the code?</p>
",<arrays><variable-length-array><q#><qubit>,6/30/2018 20:03,51120499.0,51120499.0,"<pre><code>let n = Length(qubits)
</code></pre>

<p>This will store the length in the variable n. Also n is a constant which can't be changed. If for any reason you want a mutable variable n then </p>

<pre><code>mutable n = Length(qubits) 
</code></pre>

<p>which can be changed. Now you can iterate through the array using a for loop (works for both constant or mutable n)</p>

<pre><code>for(index in 0 .. (n-1)) {
//process the element qubits[index]
}
</code></pre>
",07/01/2018 04:51,API Usage,"The user is asking about how to use a specific feature of the Q# programming language (finding the length of an array), which falls under the API Usage category as they are seeking guidance on how to correctly and effectively use this feature.",API Usage,,,,API Usage,
51120653.0,Higher order versions of basic gates Q#,"<p>Is there a higher order H-gate in Q# language? For example, if I want to apply Hadamard gate to an array(combined state) of 3 qubits. Is there a way to generate a tensor product version of H-gate or other gates?</p>
",<quantum-computing><q#>,07/01/2018 05:26,51140401.0,51140401.0,"<p>One way to think of it is to think of the unitary operator <em>H</em> = |+â©â¨0| + |ââ©â¨1| and the quantum operation <code>H</code> separately.
Taking this view, the unitary <em>H</em> is how we simulate the effect of applying the operation <code>H</code> on an ideal quantum processor.
The quantum operation <code>ApplyToEach(H, _)</code> is then represented by the unitary operator <em>H</em> â <em>H</em> â â¯ â <em>H</em> in precisely the same way that <code>H</code> is represented by <em>H</em>.</p>

<p>One consequence of this mental model is that the tensor product is defined between unitary operators and <em>not</em> between quantum operations. Rather, the ideal action of quantum operations acting on distinct qubits is represented by the tensor product of the unitary representations of each individual operation.</p>
",07/02/2018 16:35,Theoretical,"The user is asking about the theoretical concept of applying a higher order Hadamard gate to an array of qubits in Q#, which falls under the Theoretical category as they are discussing the principles and concepts of quantum gates",Theoretical,,,,Theoretical,
51137397.0,Effect of S-gate on one qubit of a combined(maybe entangled) state of 3 qubits,"<p>Suppose I have a register(qs) of 3 qubits (first 2 being used solely for control, the last one is the input) . The first two control qubits are in the <code>|+&gt;</code> state and the state of the 3rd input is unknown. Let it be <code>a|0&gt; + b|1&gt;</code>. </p>

<p>Now I apply CCNOT(qs[0],qs[1],qs[2]) so their combined state becomes <code>0.5(a,b,a,b,a,b,b,a)</code> in Transposed matrix form [Please correct if I'm wrong here] . Now I apply S-gate to the 3rd qubit which transforms <code>|1&gt; -&gt; i|1&gt;</code> . </p>

<p>I am unable to guess the state of the combined state of 'qs' now. </p>

<p>What I thought: </p>

<ol>
<li>One logic is to multiply every state by 'i' if it has the form<code>|XY1&gt;</code> so the combined state becomes <code>0.5(a,ib,a,ib,a,ib,b,ia) [Transposed]</code></li>
<li>Another logic is to find tensor product of <code>(I x I x S)</code> since I'm not changing the first 2 qubits. Performing this yields a different result which is <code>0.5(a,b,a,b,ia,ib,ib,ia) [Transposed]</code> [Again, correct me if I'm wrong]. </li>
</ol>

<p>Which is the correct output after passing through S-gate (if any) ? </p>
",<quantum-computing><q#><qubit>,07/02/2018 13:30,51141626.0,51141626.0,"<p>The first two qubits can't start in |+> state, since |+> is a single-qubit state. I assume that the starting state of the first two qubits in the register is <code>0.5 (|00&gt; + |01&gt; + |10&gt; + |11&gt;)</code>.</p>

<p>Both approaches are correct, because they are different ways to represent the same transformation. The first answer <code>0.5(a,ib,a,ib,a,ib,b,ia) [Transposed]</code> is correct. Your second answer <code>0.5(a,b,a,b,ia,ib,ib,ia) [Transposed]</code> seems to be obtained by multiplying by <code>S x I x I</code>, i.e., applying <code>S</code> gate on the first qubit instead of the third one.</p>

<p>The tensor product <code>I x I x S</code> can be calculated as tensor product of <code>I x I</code> (which is just a 4x4 identity matrix) and <code>S</code>. The result is an 8x8 matrix which consists of 16 copies of <code>S</code> matrix, multiplied by corresponding elements of <code>I x I</code>:</p>

<pre><code>1 0 | 0 0 | 0 0 | 0 0
0 i | 0 0 | 0 0 | 0 0
- -   - -   - -   - -
0 0 | 1 0 | 0 0 | 0 0
0 0 | 0 i | 0 0 | 0 0
- -   - -   - -   - -
0 0 | 0 0 | 1 0 | 0 0
0 0 | 0 0 | 0 i | 0 0
- -   - -   - -   - -
0 0 | 0 0 | 0 0 | 1 0
0 0 | 0 0 | 0 0 | 0 i
</code></pre>

<p>If you multiply the state of the qubits by this matrix, you'll get the same answer as in the first approach.</p>
",07/02/2018 18:09,Theoretical,"The user is discussing the theoretical aspects of quantum computing, specifically about the behavior of qubits and quantum gates (CCNOT and S-gate), which falls under the Theoretical category as they are discussing the principles and concepts of quantum gates.",Theoretical,,,,Theoretical,
51137541.0,Can you send a subarray of qubits as a parameter in Q#?,"<p>Is it possible to send array slices of qubits as parameters?
Something like this:</p>

<pre><code>using(q : Qubit[5]){
    myOp(q[2:3]);
}
</code></pre>
",<q#><qubit>,07/02/2018 13:38,51139878.0,51139878.0,"<p>Yes, Q# supports array slicing: <a href=""https://learn.microsoft.com/en-us/quantum/quantum-qr-expressions#array-expressions"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/quantum/quantum-qr-expressions#array-expressions</a>. You can use <code>Range</code> data type as an index to create a subarray of elements of the array indexed by elements of the range.</p>

<p>Your example will look like this:</p>

<pre><code>using (q = Qubit[5]) {
    myOp(q[2..3]);
}
</code></pre>
",07/02/2018 15:57,API Usage,"The user is asking about how to use a specific feature of the Q# programming language (passing array slices of qubits as parameters), which falls under the API Usage category as they are seeking guidance on how to correctly and effectively use this feature.",API Usage,,,,API Usage,
51172128.0,Quantum V gate 1/sqrt(5) ( I + 2iZ),"<p>By definition, the gate 1/sqrt(5) (I + 2iZ) should act on a qubit <code>a|0&gt; + b|1&gt;</code> to transform it into <code>1/sqrt(5) ((1+2i)a|0&gt; + (1-2i)b|1&gt;)</code> but transformations of each RUS step does the following-
The ancillas are in |+> state at first</p>

<ol>
<li>Starting form:  <code>1/sqrt(2) (a,b,a,b,a,b,a,b)</code></li>
<li>CCNOT(ancillas, input): <code>1/sqrt(2) (a,b,a,b,a,b,b,a)</code></li>
<li>S(input): <code>1/sqrt(2) (a,ib,a,ib,a,ib,b,ia)</code></li>
<li>CCNOT(ancillas, input): <code>1/sqrt(2) (a,ib,a,ib,a,ib,ia,b)</code></li>
<li>Z(input) : <code>1/sqrt(2) (a,-ib,a,-ib,a,-ib,ia,-b)</code></li>
</ol>

<p>Now measuring the ancillas in PauliX basis is equivalent to PauliZ measurement after applying H() to the state. Now I have 2 confusions, should I apply <code>H x H x I</code>  or <code>H x H x H</code> to the combined state. Also neither of these transformations turn out to be equivalent to the V-gate defined in the first paragraph when both measurements are Zero. Where did I go wrong?</p>

<p>Reference: <a href=""https://github.com/microsoft/Quantum/blob/master/samples/diagnostics/unit-testing/RepeatUntilSuccessCircuits.qs"" rel=""nofollow noreferrer"">https://github.com/microsoft/Quantum/blob/master/samples/diagnostics/unit-testing/RepeatUntilSuccessCircuits.qs</a> (1st sample code)</p>
",<quantum-computing><q#><qubit>,07/04/2018 11:02,51184937.0,51184937.0,"<p>The transformation is correct, though it takes some time with pen and paper to verify it.</p>

<p>As a side note, we start with a state <code>|+&gt;|+&gt;(a|0&gt; + b|1&gt;)</code>, which is <code>0.5 (a,b,a,b,a,b,a,b)</code> in vector form (both <code>|+&gt;</code> states contribute a <code>1/sqrt(2)</code> to the coefficients). It will not affect our calculations of the state after the measurement, since it will have to be renormalized, but it's still worth noting.</p>

<p>After a sequence of CCNOT, S, CCNOT, Z we get <code>0.5 (a,-ib,a,-ib,a,-ib,ia,-b)</code>. Since we're measuring only the first two qubits in PauliX basis, we need to apply Hadamards only to the first two qubits, or <code>H x H x I</code> to the combined state.</p>

<p>I'll take the liberty to skip writing out the whole expression after applying Hadamards and fast-forward to the results of measurements, and here is why. We're only interested in the state of the input qubit if both measurements yielded 0, so it's sufficient to gather only the terms of the overall state which have <code>|00&gt;</code> as the state of the first two qubits. </p>

<p>The state of the third qubit after measuring <code>|00&gt;</code> on the first qubit will be: <code>(3+i)a |0&gt; - (3i+1)b |1&gt;</code>, multiplied by some normalization coefficient <code>c</code>.
<code>c = 1/sqrt(|3+i|^2 + |3i+1|^2) = 1/sqrt(10))</code>.</p>

<p>Now we need to check whether the state we got, <code>|S_actual&gt; = 1/sqrt(10) ((3+i)a |0&gt; - (3i+1)b |1&gt;)</code>
is the same state as we'd expect to get from applying the V gate, 
<code>|S_expected&gt; = 1/sqrt(5) ((1+2i)a |0&gt; + (1-2i)b |1&gt;)</code>. They do not look the same, but remember that in quantum computing the states are defined <em>up to a global phase</em>. Thus, if we can find a complex number <code>p</code> with an absolute value 1 for which <code>|S_actual&gt; = p * |S_expected&gt;</code>, the states will be effectively the same.</p>

<p>This translates into the following equations for <code>p</code> and amplitudes of <code>|0&gt;</code> and <code>|1&gt;</code>: <code>(3+i)/sqrt(2) = p (1+2i)</code> and <code>-(3i+1)/sqrt(2) = p (1-2i)</code>. We solve both equations to get <code>p = (1-i)/sqrt(2)</code> which has indeed the absolute value 1.</p>

<p>Thus, we can conclude that indeed the state we got after all the transformations is indeed equivalent to the state we'd get by applying a V gate.</p>
",07/05/2018 06:49,Theoretical,"The user is discussing the theoretical aspects of quantum computing, specifically about the behavior of qubits and quantum gates (CCNOT, S-gate, and Z-gate), which falls under the Theoretical category as they are discussing the principles and concepts of quantum gates",Theoretical,,,,Theoretical,
51176196.0,When plotting the Wigner function of a coherent state using QuTiP strange patterns appear,"<p>I noticed something strange this day when I plotted the Wigner function of a coherent state using the open source quantum toolbox QuTiP in python. </p>

<p>When I do the plot I noticed these strange patterns just around the edge of the plot that are not supposed to be there. I believe it's just some sort of numerical error but I don't know how I can get rid or minimize them or most impartant: what's causing them.</p>

<p>Here is the code</p>

<pre><code># import packages
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib as mpl
from matplotlib import cm
from qutip import *

N = 60 # number of levels in Hilbert space

# density matrix of a coherent state
rho_coherent = coherent_dm(N, 1-1j)

X = np.linspace(-3, 3, 300)
Y = np.linspace(-3, 3, 300)

# Wigner function
W = wigner(rho_coherent, X, Y, 'iterative', 2)

X, Y = np.meshgrid(X, Y)

# Color Normalization
class MidpointNormalize(colors.Normalize):
    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
        self.midpoint = midpoint
        colors.Normalize.__init__(self, vmin, vmax, clip)
    def __call__(self, value, clip=None):
        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
        return np.ma.masked_array(np.interp(value, x, y))

# contour plot
plt.subplot(111, aspect='equal')
plt.contourf(X, Y, W, 100, cmap = cm.RdBu_r, norm = MidpointNormalize(midpoint=0.))
plt.show()
</code></pre>

<p>and here is the plot</p>

<p><a href=""https://i.stack.imgur.com/syfDX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/syfDX.png"" alt=""enter image description here""></a></p>

<p>The blue spots as you can clearly see that's around the edges are not supposed to be there! The blue spots indicate that the Wigner function is negative at that point, but a coherent state should have a Wigner function thats positive everywhere!</p>

<p>I also noticed that when I reduce the linspace steps from 300 to 100 the blue parts disappear. </p>

<p>Would appreciate very much if someone can explain what's causing this problem to appear.</p>
",<python-3.x><qutip>,07/04/2018 14:40,52808288.0,52808288.0,"<p>This is simply due to truncation. When using a finite number of modes (in your case N=60), the Wigner function will go negative at some point.</p>

<p>Reducing the linspace steps brings the negative regions you see on the plot into the zero value increment and displays these regions as zero. Reducing the linspace steps is probably the best solution to your problem. Your plot will only be as accurate as the errors introduced by truncation, so simply reduce the resolution until those errors disappear.</p>
",10/15/2018 0:27,Errors,"The user is encountering an unexpected result (blue spots around the edges of the plot) while trying to plot the Wigner function of a coherent state using QuTiP in Python, which falls under the Errors category as they are seeking solutions and explanations for this issue.",Errors,,,,Errors,
51190773.0,How to realize the Grover's Diffusion Operator in Q#?,"<p>Like the title says, how to realize the Grover's Diffusion Operator in Q#? I know it's defined as <code>2 â¨s|sâ© - I</code> where <code>|sâ©</code> is the uniform state for any arbitrary number of qubits. This can further be defined in terms of Z0 (saw it called U0) gate sandwiched by a pair of H-gates. I was unable to find any function in the quantum primitive and canon docs starting with possible names like Grover, diff etc.</p>

<p>I don't want to use the function <code>AmpAmpByOracle</code> since it is very high level implementation and doesn't clear my understanding. I want to implement a function that takes a oracle Uf(unknown to me suppose) and the number of qubit it takes(N) and perform the Grover's algorithm by simply following the circuit given in <a href=""https://en.wikipedia.org/wiki/Grover%27s_algorithm"" rel=""nofollow noreferrer"">Grover's Algorithm | Wikipedia</a> and measure the required state by measuring all the N qubits at the end of r = approx(2^(N/2)) iterations.</p>
",<quantum-computing><q#>,07/05/2018 11:58,51752188.0,51752188.0,"<p>The diffusion operation is a bit tricky. I find it easiest to decompose it into pieces:</p>

<ol>
<li>As you point out, it's much simpler to look at the diffusion operation in the X basis. If you apply H to every qubit before and after, then in the middle the uniform state looks like the 000...0 state.</li>
<li>The diffusion operation (in the X basis) is -1 on the 000...0 state, and the identity (+1) on all other basis states. The first step is to pick out the 000...0 state; I can do that with a multi-controlled X gate -- except I need to flip all of the qubits first from 0 to 1 (and <em>vice versa</em>), since controlled operations look for 1s, not 0s. Of course, after the controlled X I'll need to undo the flips.</li>
<li>To generate the -1, I can start with the ancilla in the |-> state, so that the X will turn it into -|->.</li>
<li>After I'm done with everything, I need to reset the ancilla so I can return it in the |0> state.</li>
</ol>

<p>This all turns into:</p>

<pre><code>// register is the Qubit[] that we want to apply the diffusion operation to
using (ancillae = Qubit[1])
{
  let ancilla = ancillae[0];

  X(ancilla); // Puts the ancilla into the |1&gt; state
  H(ancilla); // And now into the |-&gt; state

  ApplyToEach(H, register);  // Put the register qubits into the X basis
  ApplyToEach(X, register);  // Flip 0-&gt;1 and 1-&gt;0
  (Controlled X)(register, ancilla);  // Do the controlled flip of the ancilla
  ApplyToEach(X, register);  // Undo the flip
  ApplyToEach(H, register);  // Undo the basis change

  H(ancilla); // Put the ancilla back into |1&gt;
  X(ancilla); // And back to |0&gt; so we can return it
}
</code></pre>

<p>This is uncompiled code, so there might be some typos...</p>
",08/08/2018 17:12,API Usage,"The user is asking about how to implement a specific quantum computing operation (Grovers Diffusion Operator) in a specific quantum programming language (Q#), which falls under the API Usage category as they are seeking guidance on how to correctly and effectively use this feature. ",Theoretical,"This question belongs to the ""Theoretical"" category as it involves a theoretical discussion about implementing Grover's Diffusion Operator in Q#. The user is seeking an understanding of how to create a custom function that performs Grover's algorithm using a given oracle and number of qubits, which involves a theoretical exploration of quantum algorithms and circuit design.",No,14.0,Theoretical,"The user seeks an understanding of how to implement Grover's Diffusion Operator in Q#, involving a theoretical exploration of quantum algorithms and circuit design, rather than simply using an existing API feature."
51197189.0,Why can't C# method find the name of a Q# Operation using VS?,"<p>I'm working with <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">MS Quantum Dev Kit</a> using Q# language and VS 2017.</p>

<p>I'm trying to make the simplest quantum algorithm described <a href=""https://learn.microsoft.com/en-us/quantum/quantum-writeaquantumprogram?view=qsharp-preview&amp;tabs=tabid-vs2017"" rel=""nofollow noreferrer"">here</a> work.</p>

<p>In a method within a C# ""driver"" (a <code>.cs</code> file), I'm typing the name of a quantum <code>operation</code> I have defined in a <code>.qs</code> file, in order to make use of it. 
VS is then complaining that it can't find it: intellisense doesn't auto-complete and hence I can't reference it. </p>

<p>Both the C# code and the operation are within the same namespace, so the C# code should in theory be able to access the quantum code. </p>

<p>I appreciate this dev kit is still in release stage. But does anyone have a solution for this by any chance?</p>

<p>Thanks in advance. </p>
",<c#><visual-studio><q#>,07/05/2018 17:43,51197209.0,51197209.0,"<p>I found the solution: <strong>I need to rebuild my solution first</strong>. </p>

<p>Apparently quantum operations defined in <code>.qs</code> files are not automatically loaded into VS's intellisense, they need a build first.  </p>
",07/05/2018 17:44,Errors,"The user is encountering a specific error (Visual Studio not recognizing a Q# operation defined in a .qs file) while trying to develop a quantum program using the Microsoft Quantum Development Kit and Visual Studio 2017, which falls under the Errors category as they are seeking solutions and explanations for this issue. ", Errors ,,,,Errors,
51210455.0,Q# AggregateException could not be found,"<p>After trying out this code from <a href=""https://learn.microsoft.com/en-us/quantum/quantum-simulatorsandmachines?view=qsharp-preview"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/quantum/quantum-simulatorsandmachines?view=qsharp-preview</a></p>

<pre><code>try
{
    using (var sim = new QuantumSimulator())
    {
        /// call your operations here...
    }
}
catch (AggregateException e)
{
    // Unwrap AggregateException to get the message from Q# fail statement.
    // Go through all inner exceptions.
    foreach (Exception inner in e.InnerExceptions)
    {
        // If the exception of type ExecutionFailException
        if (inner is ExecutionFailException failException)
        {
            // Print the message it contains
            Console.WriteLine($"" {failException.Message}"");
        }
    }
}
</code></pre>

<p>I got the following error:</p>

<pre><code>Driver.cs(29,20): error CS0246: The type or namespace name 'AggregateException' could not be found (are you missing a using directive or an assembly reference?) [/home/tinkidinki/Quantum/Bell/Bell.csproj]
Driver.cs(33,26): error CS0246: The type or namespace name 'Exception' could not be found (are you missing a using directiveor an assembly reference?) [/home/tinkidinki/Quantum/Bell/Bell.csproj]
Driver.cs(38,25): error CS0103: The name 'Console' does not exist in the current context [/home/tinkidinki/Quantum/Bell/Bell.csproj]

The build failed. Please fix the build errors and run again.
</code></pre>

<p>How do I fix this?</p>
",<c#><error-handling><exception><quantum-computing><q#>,07/06/2018 12:25,51213438.0,51213438.0,"<p>Can you share your whole C# code? Given that the error messages mention even <code>Console</code>, looks like you're missing a <code>using System</code> in your C# code.</p>
",07/06/2018 15:18,Errors,"The user is encountering a specific error (The type or namespace name 'AggregateException' could not be found) while trying to run a quantum program using the Microsoft Quantum Development Kit, which falls under the Errors category as they are seeking solutions and explanations for this issue",Errors,,,,Errors,
51225594.0,What is the equivalent of 'break' in q#?,"<p>How would I break out of a loop when I meet a condition?
For example:</p>

<pre><code>for (i in 0..10){
    if (i==3){
        // equivalent of break
     }
}
</code></pre>
",<break><q#>,07/07/2018 17:46,51226008.0,51226008.0,"<p>There is no break in Q#; however, you can implement this behavior using <a href=""https://learn.microsoft.com/en-us/quantum/quantum-qr-statements#control-flow"" rel=""noreferrer"">repeat-until-success loop</a>.</p>

<p>Q# is not a general-purpose language, and is designed to allow a lot of optimizations for when a program will be executed on a quantum device. Loops are one example of such design: if you know beforehand how many iterations your loop will do, use a for loop, if you need to iterate until some condition is met, use repeat-until-success loop.</p>

<p>Your example (which is not really a good example of why you'd need a break) would be written as something like this:</p>

<pre><code>mutable i = 0;
repeat {
    set i = i + 1;
} until (i == 10 || i == 3)
fixup {
    ();
}
</code></pre>
",07/07/2018 18:40,API Usage,"The user is asking about how to use a specific feature of the Q# programming language (breaking out of a loop), which falls under the API Usage category as they are seeking guidance on how to correctly and effectively use this feature",API Usage,,,,API Usage,
51387285.0,"Getting error ""Released qubits are not in zero state"" in Q# Quantum Dev kit","<p>When running the following simple quantum program to apply Hadamard gate to a single qubit:</p>

<pre><code>operation ApplyHadamard():()
{
    body
    {
        using (qubits  = Qubit[1])
        {
            H(qubits[0]);
        }
    }
}
</code></pre>

<p>I get the following error:</p>

<blockquote>
  <p>Microsoft.Quantum.Simulation.Simulators.Exceptions.ReleasedQubitsAreNotInZeroState:
  'Released qubits are not in zero state.'</p>
</blockquote>

<p>I'm using <a href=""https://learn.microsoft.com/en-us/quantum/quantum-techniques-2-operationsandfunctions?view=qsharp-preview"" rel=""nofollow noreferrer"">Microsoft's tutorial</a>, and in it there is no mention of anything else needed to make such a program work. </p>

<p>I appreciate it Q# is still in release mode, but It would be great if anyone finds a solution for this. </p>
",<visual-studio-2015><quantum-computing><q#>,7/17/2018 17:34,51390660.0,51390660.0,"<p>The documentation has this information a few sections later, in <a href=""https://learn.microsoft.com/en-us/quantum/quantum-techniques-5-workingwithqubits"" rel=""nofollow noreferrer"">Working with Qubits</a>. </p>

<blockquote>
  <p>Target machines expect that qubits are in the |0â© state immediately
  before deallocation, so that they can be reused and offered to other
  <code>using</code> blocks for allocation.</p>
</blockquote>

<p>Consider running a program on a quantum computer: the number of qubits is very limited, and you want to reuse the released qubits in other parts of the program. If they are not in zero state by that time, they can potentially be still entangled with the qubits which are not yet released, thus operations you perform on them can affect the state of other parts of the program. </p>

<p>Resetting the qubits to zero state automatically when they go outside the scope of their <code>using</code> block is dangerous as well: if they were entangled with others, measuring them to reset them can affect the state of the unreleased qubits, and thus change the results of the program - without the developer noticing this.</p>

<p>The requirement that the qubits should be in zero state before they can be released aims to remind the developer to double-check that all necessary information has been properly extracted from the qubits, and that they are not entangled with unreleased qubits any more.</p>

<p>Note that using <code>Reset</code> or <code>ResetAll</code> before releasing the qubits is not a hard requirement. For example, in Deutsch-Jozsa algorithm the last step of the algorithm is to measure all qubits except the last one. This means that for each of those qubits you already know that their state is either |0â© or |1â©, and you can apply an X gate to the qubits in |1â© state to convert them to |0â© without calling <code>Reset</code> to measure them again. The last qubit is known to be in |-â© state, and you can convert it to |0â© by applying H and X gates.</p>
",7/17/2018 21:47,Errors,The user is getting an error when running a simple quantum program to apply a Hadamard gate to a single qubit. The error is caused by Q# requiring all qubits to be in the zero state when they are released.,Errors ,,,,Errors,
51500215.0,How can i throw an exception in Q#?,"<p>I try to write an algorithm in Q#. In some cases the algorithm can not calculate a result with success because the user passed some bad arguments. In this case i want to throw an exception and now i wonder: Is it possible to throw and catch exceptions in Q#?</p>

<p>If yes: how can i do that and what is the proper way of exception-handling in Q#?</p>

<p>If no: why? are there any workarounds?</p>
",<exception><q#>,7/24/2018 13:43,51501531.0,51501531.0,"<p>Many of the cases in which <code>catch</code> clauses are especially helpful in general-purpose languages look somewhat like handling I/O errors, in that they are very difficult to predict and deal with through ordinary flow control. By contrast, Q# programs are intended to be predictable in their execution so that functors like <code>Adjoint</code> and <code>Controlled</code> can generate appropriate transformations of programs as part of larger quantum algorithms.</p>

<p>That said, as you point out, there are times where one cannot sensibly proceed from some condition. Thus, Q# provides a <code>fail</code> statement that operates similarly to a <code>throw</code> statement (but takes a <code>String</code> rather than an exception object), but does not provide an analogue to a <code>try</code>â<code>catch</code> block. The <code>fail</code> statement is intended to communicate to the C# host program that a Q# program cannot sensibly proceed, and is useful for cases such as when a user passes bad instance. For instance, this is used throughout the <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Standard/src/Diagnostics/Facts.qs"" rel=""nofollow noreferrer""><code>Facts.qs</code></a> file in the standard libraries to implement classical assertion functions such as <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Standard/src/Diagnostics/Facts.qs#L33"" rel=""nofollow noreferrer""><code>EqualityWithinToleranceFact</code></a>:</p>

<pre><code>function EqualityWithinToleranceFact(actual : Double, expected : Double, tolerance : Double) : Unit {
    let delta = actual - expected;
    if (delta &gt; tolerance or delta &lt; -tolerance) {
        fail $""Fact was false. Expected: '{expected}'. Actual: '{actual}'"";
    }
}
</code></pre>
",7/24/2018 14:45,Conceptual,"The user is inquiring about the concept of exception handling in Q# and is seeking to understand if it's possible and how it works in the language, which falls under the ""Conceptual"" category as they are discussing the underlying concepts and behavior of exception handling in quantum programming.",Errors,"The question is about a specific error encountered while running a quantum program in Q#, which falls under the category of debugging and understanding error messages",No,15.0,Conceptual,"The user is seeking to understand the concept of exception handling in Q# and how it works, rather than encountering a specific error message while running a quantum program."
51600882.0,Q# Aggregate Exception Error,"<p>When coding with Q#, with the following code snippet I get an aggregate exception error (one or more errors seems to have occurred). </p>

<p><a href=""https://i.stack.imgur.com/KEhuB.png%60using"" rel=""nofollow noreferrer"" title=""var sim = new QuantumSimulator()""><img src=""https://i.stack.imgur.com/KEhuB.png%60using"" alt=""code snippet"" title=""var sim = new QuantumSimulator()""></a></p>

<p>What is wrong with this specific code snippet, and what parts of the Q# documentation have a bearing on this issue?</p>

<p>Code Snippet:</p>

<pre><code>            // Try initial values
            Result[] initials = new Result[] { Result.Zero, Result.One };
            foreach (Result initial in initials)
            {
                BellTest.Run(sim, 1000, initial).Wait();
                var res = BellTest.Run(sim, 1000, initial).Result;
                var (numZeros, numOnes, agree) = res;
                System.Console.WriteLine(
                    $""Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4} agree={agree,-4}"");
            }
</code></pre>
",<c#><q#>,7/30/2018 19:18,51601077.0,51601077.0,"<p>Every call to a <code>Q#</code> operation is asynchronous, as execution on actual hardware will also be asynchronous, thus every time you call <code>Run</code> you must wait for the execution to complete before you can execute another quantum operation. There are multiple ways to wait for an asynchronous <code>Task</code> to finish, including using the <a href=""https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/await"" rel=""nofollow noreferrer""><code>await</code></a> keyword, the <a href=""https://msdn.microsoft.com/en-us/library/dd235635(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>Wait()</code></a>, or retrieving the <a href=""https://msdn.microsoft.com/en-us/library/dd321468(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>Result</code></a> of the <code>Task</code>.</p>
<p>In this particular case, you invoke <code>BellTest.Run</code> twice, and the second doesn't wait for the first to be completed. The Exeption will go away if you add <code>Wait()</code> to your first <code>Run</code>, for example:</p>
<pre><code>    BellTest.Run(sim, 1000, initial).Wait();
</code></pre>
",7/30/2018 19:33,Errors,The user is getting an aggregate exception when running the code snippet provided. This is likely due to the fact that the Run() method of the BellTest class can throw an exception if the test fails.,Errors,,,,Errors,
51722954.0,How can Q# read the qubit state without destroying it?,"<p>The first Q# code example provides a method ""Set"" that is written as follow <a href=""https://learn.microsoft.com/fr-fr/quantum/quantum-writeaquantumprogram?view=qsharp-preview&amp;tabs=tabid-vs2017"" rel=""nofollow noreferrer"">(link)</a>:</p>

<pre><code>operation Set (desired: Result, q1: Qubit) : ()
{
    body
    {
        let current = M(q1);
        if (desired != current)
        {
            X(q1);
        }
    }
}
</code></pre>

<p>This method set a qubit to a desired value. To do so, the qubit value is measured, and if the value is different than expected, the qubit state is ""swapped"".</p>

<p>But in quantum physics you cannot measure a particle without destroying it. Here is a quote of the book ""Quantum Computation and Quantum Information"":</p>

<blockquote>
  <p>... measurement changes the state of a qubit, collapsing it from
  its superposition of |0> and |1> to the specific state
  consistent with the measurement result. For example, if
  measurement of |+> gives 0,
  then the post-measurement state of the qubit will be |0>.</p>
</blockquote>

<p>But using Q# you can measure a qubit and continue using it.  </p>

<p>Why Q# langage allows us to realize an operation that is impossible in reality ?</p>

<p>Thank you by advance for answers.</p>
",<quantum-computing><q#>,08/07/2018 09:07,51728955.0,51728955.0,"<p>I think it might be helpful to look back at your quote from Nielsen and Chuang:</p>

<blockquote>
  <p>For example, if measurement of |+â© gives 0, then the post-measurement state of the qubit will be |0â©.</p>
</blockquote>

<p>That is, the qubit is not destroyed by the measurement, but in order for quantum mechanics to be consistent, its state immediately following the measurement must agree with what we measured (this consistency requirement is sometimes informally called a ""collapse"").
In your Q# example, if we get a <code>Zero</code> from the call to the <code>M</code> operation, then we know that the qubit is in the |0â© state, precisely as described by Nielsen and Chuang.
On the other hand, if we get a <code>One</code> from the call to <code>M</code>, we know that the qubit is in the state |1â© = <em>X</em> |0â©, such that we need to apply another <em>X</em> gate to get back to |0â©.
(Note: if your qubits are stored as photons, then the discussion might well look very different â it's very hard to measure a photon without absorbing it into a material. It can be done using <em>quantum nondemolition</em> measurements, but that's another topic entirely. Q# assumes that qubits can be measured in the way that your quote from Nielsen and Chuang describes, rather than measured as photon absorption.)</p>

<p>With that as context, Q# is carefully designed to only allow measurements that could be realized in experimental practice.
Nonetheless, it's often very helpful to be able to use classical simulators to probe the state of some qubits in a way that wouldn't be possible on an actual quantum device.
There are two primary ways that you can do this in Q#.
First, you can use assertions like <a href=""https://learn.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.assertqubit"" rel=""nofollow noreferrer""><code>AssertQubit</code></a> to write unit tests that fail if the qubit isn't in the expected state.
Second, you can use the functions in the <a href=""https://learn.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics"" rel=""nofollow noreferrer""><code>Microsoft.Quantum.Diagnostics</code> namespace</a> to ask the simulator to dump what diagnostic information it has, such as the state it's using the represent the qubits used by your Q# program.
On actual hardware, the diagnostic information may look very different.</p>
",08/07/2018 14:14,Conceptual,"The user is inquiring about a conceptual aspect of quantum programming, specifically the ability to measure a qubit in Q# without collapsing its state, and they are seeking an explanation for this behavior, which falls under the ""Conceptual"" category as it pertains to the underlying concepts and principles of quantum programming.",Conceptual,,,,Conceptual,
51774989.0,Q# versus LIQUi|>,"<p>Is Q# meant to be a LIQUiD replacement? It's unclear from the website that's this is true, but I haven't heard anything about LIQUiD since the announcement of Q#. There seems to be a large set of tools in LIQUiD that are not available in Q#, so are these meant to be linked together via .NET? In particular, I am interested in the circuit class and optimizations for QECC in LIQUiD.</p>
",<q#>,08/09/2018 20:04,51775417.0,51775417.0,"<p>LiQUi|> (which I'll write Liquid from now on :-)) and Q# have different goals. Liquid is an F#-based platform for simulating quantum circuits. It provides a lot of handy tools and features, like the QECC and noise modelling components you mention. It provides full access to (and manipulation of, if desired) the quantum state, so you can simulate things with Liquid that you could never do on a real quantum system. Finally, Liquid includes some highly-optimized capabilities for simulating Hamiltonian simulations that do a bunch of linear algebra tricks that are not available on a real quantum system.</p>

<p>Q# is a high-level language for coding quantum algorithms. Its goal is to let you easily code large quantum applications that would eventually be run on a large quantum system (hundreds of logical, error-corrected qubits). It does support simulation, but as a debugging aid. Put another way, Q# isn't primarily a language for programming quantum simulations, even though that's the way it's used today because of the low availability of large-scale quantum systems.</p>

<p>Liquid is still alive. If your focus is on simulation, Liquid is a great choice: you can get direct access to the innards of the simulator, but still code at a high level.</p>

<p>Q# is active and growing. While the focus is on actual execution, the Quantum Development Kit already includes both a full state vector simulator and a resource-estimating simulator (the trace simulator). I wouldn't be too surprised if more debugging features, including simulation, are on the way; for instance, the June release added the <code>DumpMachine</code> and <code>DumpRegister</code> operations to allow debugging access to the full state vector.</p>
",08/09/2018 20:37,Conceptual,"The user is seeking clarification on the relationship between Q# and LIQUi|>, as well as the potential role of .NET in linking them, which falls under the ""Conceptual"" category as it pertains to the conceptual understanding of the tools and technologies in quantum computing.",Conceptual,,,,Conceptual,
51959625.0,"Implementing Steane [[7, 1, 3]] Code In (Microsoft) Liquid","<p>I am trying to implement some quantum error correcting codes in Liquid (please correct the tag if need be), and I thought I'd start by reproducing the Steane7 class discussed in the User's Manual here starting on page 55 (page 56 of the pdf). I have a couple of questions about the provided code though.</p>

<ol>
<li>The overall structure of the file is unclear to me. The example starts out by defining ""type Steane7"". This is a class definition, so I assume all of the following code is indented under this? On page 58 (59), it makes a reference to going back to the class definition to add the overrides, which makes it seem like the above code is not indented under the type. I assume this is meant to me that it's indented under the type but not under the synd method?</li>
<li>In the previous mentioned overrides on page 58 (59), what is s and where does it come from? In F#, one can use words other than ""this"" and ""self"". Is that what s is supposed to be here, or is s referring to a value previously defined but not mentioned?</li>
<li>The drawing instructions in the prep gate on page 56 (57) say ""Error! Hyperlink reference not valid."" What are the proper drawing instructions here? I'm guessing that's supposed to read ""\multigate{#%d}{%s}""?</li>
<li>The method ""fix"" has an else with no if on page 58. What's the proper reference to the parent here?</li>
<li>Are there any pieces of the Steane7 class missing from the User Manual? If I call this in a script, it's going to work exactly like the compiled version of the code?</li>
<li>For future codes I implement, are there any other methods which should be overridden? I am piecing together the QECC class by inspecting the compiled assembly through VS.</li>
</ol>

<p>Frankly, all of these questions could be answered by someone simply pointing me to the source code for QECC and Steane7. The ""source"" folder I grabbed from the GitHub only has precompiled executables.</p>
",<quantum-computing><liquid.net>,8/22/2018 3:52,51991296.0,51991296.0,"<p>I just posted the source for Steane7 to the <a href=""https://github.com/StationQ/Liquid/blob/master/UserCode/AlanGeller/Steane7.fs"" rel=""nofollow noreferrer"">Liquid GitHub repo</a>. I hope that helps!</p>
",8/23/2018 17:29,Tooling,The question is asking about how to use a specific tool (the Liquid programming language) to implement a specific quantum error correcting code (Steane7). This is a tooling question because it is asking about how to use a specific tool to solve a specific problem.,Tooling,,,,Tooling,
51983686.0,Frameworks/API that uses quantum computer?,"<p>Are there any framework that allows to create software or apps that uses the quantum computer, asides from Q#?</p>
",<api><frameworks><quantum-computing>,8/23/2018 10:28,52008028.0,52008028.0,"<p>There is a <a href=""https://github.com/markf94/os_quantum_software"" rel=""nofollow noreferrer"">list of open-source quantum software projects</a> on GitHub which includes an overview of actively developed quantum programming languages and frameworks. It is actively maintained, reflecting appearance of new languages and tools.</p>
",8/24/2018 15:58,Tooling,"The user is asking about frameworks that allow to create software or apps that uses the quantum computer, which is a question about tools and software usage in quantum programming.", Tooling,,,,Tooling,
52109194.0,Unable to find module qiskit_aqua.algorithms,"<pre><code>pip-install qiskit-aqua completed successfully.
</code></pre>

<p>Following is ths stack trace:</p>

<pre><code>ModuleNotFoundError                       Traceback (most recent call last)
&lt;ipython-input-1-8f03022943b2&gt; in &lt;module&gt;()
      2 import sys
      3 from datasets import *
----&gt; 4 from qiskit_aqua.algorithms.many_sample.qsvm.data_preprocess import *
      5 from qiskit_aqua.input import get_input_instance
      6 from qiskit_aqua import run_algorithm
</code></pre>

<blockquote>
  <p>ModuleNotFoundError: No module named 'qiskit_aqua.algorithms'</p>
</blockquote>
",<python><quantum-computing><qiskit>,8/31/2018 5:51,52124724.0,52124724.0,"<p>After some searching, I found the code that you're running: it appears to come from one of the tutorials in the repository at <a href=""https://github.com/Qiskit/aqua-tutorials"" rel=""nofollow noreferrer"">https://github.com/Qiskit/aqua-tutorials</a>. The current version of this repository is compatible with the current master branch of the Qiskit Aqua repository at <a href=""https://github.com/Qiskit/aqua"" rel=""nofollow noreferrer"">https://github.com/Qiskit/aqua</a>, which is currently somewhat ahead of the latest version available on PyPI (i.e. the one you installed using PIP). I expect PyPI will be updated with the latest version soon, but in the meantime I'd recommend that you clone the master branch of the Qiskit Aqua repository from GitHub. You can then install it using pip install -e if desired.</p>
",09/01/2018 03:55,Errors,The user is getting a ModuleNotFoundError exception when trying to import the qiskit_aqua.algorithms module. This is likely due to the fact that the qiskit-aqua package is deprecated and is no longer supporte,Errors,,,,Errors,
52241425.0,Is P vs NP the same thing as being solvable by classical vs. quantum computers?,"<p>Is the P vs NP problem really a problem? Can't we say that the P problems are the problems solvable by classical computer because it fits into its architecture and NP problems are quantum in nature and can be solved by computers of quantum architecture?</p>
",<algorithm><computer-science><cpu-architecture><quantum-computing>,09/09/2018 04:49,52241526.0,52241526.0,"<p>No, classical computers can solve NP problems, just not quickly for large problem sizes.</p>

<p>Practical performance is not at all the point of the P vs NP problem.</p>

<p>I think (but am not sure) that there could be some classical-polynomial-time problems which a quantum computer could solve more quickly than a classical computer of comparable technology level.</p>

<hr>

<p><strong>The point of P vs. NP</strong> is that we haven't even <em>proved</em> that Nondeterministic Polynomial-time problems (solution verifiable in polynomial time) are actually harder than <em>any/every</em> possible P problem.</p>

<p>i.e. that the set of all NP problems is not identical to the set of P problems.</p>

<p>We currently don't know how to solve NP-complete problems in polynomial time, but nobody has proved we can't, and that's what the <a href=""https://en.wikipedia.org/wiki/P_versus_NP_problem"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/P_versus_NP_problem</a> is about.</p>

<hr>

<p>Quantum computing is a super-set of classical computing, so a quantum computer can solve every P problem in polynomial time.  But not necessarily using a quantum algorithm that actually treats any bits as having values other than pure 0 or pure 1.</p>

<p><strong>But we <em>don't</em> know if quantum computers can solve <em>every</em> NP problem in polynomial time.  That's another open problem</strong>.  (See comments: we don't know if <a href=""https://en.wikipedia.org/wiki/BQP"" rel=""nofollow noreferrer"">BQP</a> = NP, as well as not knowing if P = NP.)</p>

<hr>

<p>Regardless of whether quantum computers exist that can solve (some?) NP problems in a reasonable amount of time, P vs NP is still an open question in theoretical CS.  Classical computing is still a very interesting and relevant subject<sup>1</sup>.</p>

<p>Given that nobody's found a way to solve NP-complete problems in polynomial time  yet, it's highly unlikely that there is one, and if there is it's unlikely that it's fast for practical problem sizes.  (Perhaps very large scale factors or exponents for a very quickly-growing polynomial that's still smaller than any exponential function as n approaches infinity.)</p>

<p>Requiring a quantum computer to solve efficiently (for large problem sizes) is related to whether any P algorithm is <em>known</em> for classical computers.</p>

<p>Quantum computing doesn't solve or obsolete the P vs. NP question.</p>

<hr>

<p>Footnote 1: I expect classical computing to be at least theoretically interesting even in a hypothetical future where cheap microcontrollers can include some quantum logic without increasing their cost or requiring cryo-cooling or other expensive operating requirements.</p>

<p>But that hypothetical future is unlikely.  Even given time for ramp-up of quantum-computer production lines to match the current vast economies of scale and technological maturity of doped silicon, decoherence is a major unsolved problem.  There's no reason to expect that quantum computing will ever fully take over from classical; silicon is fundamentally pretty robust and can operate well at room temperature.</p>

<p>It might become an essential component of desktop computers in the future (the way floating point hardware or GPUs are now: ubiquitous on high-end CPUs but still absent on microcontrollers).  But there will still be pure-classical components.</p>
",09/09/2018 05:11,Theoretical,"The question is about the theoretical concept of P vs NP problem in the context of classical and quantum computing, which falls under the understanding of theoretical principles in quantum computing",Theoretical,,,,Theoretical,
52317000.0,"How to reshape a 2d numpy.array or Qobj into dims=[[2,2],[2,2]]","<p>Numpy example below</p>
<hr />
<h2>Goal: QuTiP object</h2>
<p>The goal of my request is to add two quantum state objects of type <code>Qobj</code> (density matrices) as in the following example of a Werner state (to give it some physical meaning).</p>
<pre><code>import qutip as q
r = .5
state = r * q.ket2dm(q.ghz_state(2)) + (1-r) * q.maximally_mixed_dm(4)
</code></pre>
<p>The error message is</p>
<pre><code>TypeError: Incompatible quantum object dimensions
</code></pre>
<p>So one could go to the lower dimensional state but then we loose the relevant dimension properties to proceed with the state:</p>
<pre><code>state = r * q.ket2dm(q.ghz_state(2)).data.toarray() + (1-r) * q.maximally_mixed_dm(4)
</code></pre>
<p>My attempts like <code>q.Qobj(q.maximally_mixed_dm(4).data.toarray().reshape([[2,2],[2,2]]))</code> all failed as reshape does not handle lists of lists.</p>
<p>The inverse going from dimensions <code>[[2,2],[2,2]]</code> down to <code>[4,4]</code> is not a miracle using reshape or as shown by the conversion to an array.
But is the inverse implemented in either numpy nor qutip?</p>
<hr />
<h2>Edit: For people familiar with numpy</h2>
<p>How do you reshape a 2d array (e.g. here 4x4) in to a (2x2)x(2x2) one?
The built in function of numpy seems to dislike my requested example.
It does not accept lists of lists as shown here:</p>
<pre><code>import numpy as np
state = np.identity(4).reshape([[2,2],[2,2]])
</code></pre>
<p>I was surprised that no one ever asked this question before!</p>
",<python><reshape><qutip>,9/13/2018 15:28,52318325.0,52318325.0,"<p>You are using reshape in the wrong way. It takes a tuple of the dimensions as an argument (see the docs) and not a tuple of tuples or list of lists with the dimensions as elements - how should that work? I think you are mixing the depth of your list of lists with the dimensionality (which are expected to be the numeric entries of the tuple).</p>

<p>I am not sure what exactly you wanna end up with but I guess one of the following:</p>

<pre><code>state = np.identity(4).reshape((2,2,2,2))
state = np.identity(4).reshape((4,2,2))
state = np.identity(4).reshape((2,2,4))
</code></pre>
",9/13/2018 16:49,Errors,"The user is encountering an error when trying to manipulate quantum state objects of type 'Qobj' in the QuTiP library, and they are seeking a solution to this error.",Errors,,,,Errors,
52428334.0,Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll' (CentOS 7),"<p>I am trying to get <a href=""https://learn.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&amp;tabs=tabid-vscode"" rel=""nofollow noreferrer"">Microsoft's Quantum Development Kit</a> to work on a CentOS 7 machine.  I followed the <a href=""https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial"" rel=""nofollow noreferrer"">instructions</a> for installing <code>dotnet</code>, and the trivial <code>dotnet</code> 'Hello World' works. I also installed Visual Studio from <code>yum</code> and installed the Microsoft Quantum Development Kit for Visual Studio from the Visual Studio explorer.</p>

<p>After cloning their github repo. I try:</p>

<pre><code>dotnet_vm: Teleportation$ cd ~/Quantum/Samples/Teleportation/
dotnet_vm: Teleportation$ scl enable rh-dotnet21 bash
dotnet_vm: Teleportation$ dotnet run
/home/user/Quantum/Microsoft.Quantum.Canon/Microsoft.Quantum.Canon.csproj : warning NU1603: Microsoft.Quantum.Canon depends on NETStandard.Library (&gt;= 2.0.2-servicing-25519-03) but NETStandard.Library 2.0.2-servicing-25519-03 was not found. An approximate best match of NETStandard.Library 2.0.2 was resolved. [/home/user/Quantum/Samples/Teleportation/TeleportationSample.csproj]
/home/user/Quantum/Microsoft.Quantum.Canon/Microsoft.Quantum.Canon.csproj : warning NU1603: Microsoft.Quantum.Canon depends on NETStandard.Library (&gt;= 2.0.2-servicing-25519-03) but NETStandard.Library 2.0.2-servicing-25519-03 was not found. An approximate best match of NETStandard.Library 2.0.2 was resolved.

Unhandled Exception: System.DllNotFoundException: Unable to load shared library 'Microsoft.Quantum.Simulator.Runtime.dll' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: libMicrosoft.Quantum.Simulator.Runtime.dll: cannot open shared object file: No such file or directory
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator.Init()
   at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator..ctor(Boolean throwOnReleasingQubitsNotInZeroState, Nullable`1 randomNumberGeneratorSeed, Boolean disableBorrowing)
   at Microsoft.Quantum.Examples.Teleportation.Program.Main(String[] args) in /home/user/Quantum/Samples/Teleportation/Program.cs:line 13
</code></pre>

<p><a href=""https://stackoverflow.com/questions/49579153/unable-to-load-dll-microsoft-quantum-simulator-runtime-dll/49619059"">This</a> looks like the same error.  I tried what I thought was the linux equivalent solution : </p>

<pre><code>cp ~/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/runtimes/linux-x64/native/Microsoft.Quantum.Simulator.Runtime.dll ~/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/
</code></pre>

<p>I still get the same Error.  Also, I do not have the AVX instruction set enabled on my computer (which might be a potential issue?).  </p>

<p>E.g. </p>

<pre><code> grep flags /proc/cpuinfo 
flags       : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pse36 clflush mmx fxsr sse sse2 syscall nx lm nopl pni cx16 hypervisor lahf_lm abm
flags       : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pse36 clflush mmx fxsr sse sse2 syscall nx lm nopl pni cx16 hypervisor lahf_lm abm
dotnet_vm: Teleportation$ 
</code></pre>

<p>I do not have any Windows experience and these do not look like typical Linux libraries (not .so or .a).</p>

<p>QUESTION:
How do I get this to work?</p>
",<.net><visual-studio><quantum-computing><q#>,9/20/2018 15:13,52503734.0,52503734.0,"<p>Following El capi's answer, I looked at the libraries linked to : e.g.</p>

<pre><code>dotnet_vm: gcc-5.1.0$ ldd /home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll
/home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by /home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll)
/home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by /home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll)
/home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll: /lib64/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by /home/user/.nuget/packages/microsoft.quantum.development.kit/0.2.1809.701-preview/lib/netstandard2.0/Microsoft.Quantum.Simulator.Runtime.dll)
    linux-vdso.so.1 =&gt;  (0x00007fff2f12b000)
    libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f1fb5fee000)
    libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f1fb5cec000)
    libgomp.so.1 =&gt; /lib64/libgomp.so.1 (0x00007f1fb5ac6000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f1fb56f9000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f1fb656a000)
</code></pre>

<p>To resolve this versioning issue with regards to GLIBCXX_3.4.21, I installed gcc-5.1.0 (and its dependencies).  Then running the code:</p>

<pre><code>dotnet_vm: Teleportation$ dotnet run
/home/user/Quantum/Microsoft.Quantum.Canon/Microsoft.Quantum.Canon.csproj : warning NU1603: Microsoft.Quantum.Canon depends on NETStandard.Library (&gt;= 2.0.2-servicing-25519-03) but NETStandard.Library 2.0.2-servicing-25519-03 was not found. An approximate best match of NETStandard.Library 2.0.2 was resolved. [/home/user/Quantum/Samples/Teleportation/TeleportationSample.csproj]
/home/user/Quantum/Microsoft.Quantum.Canon/Microsoft.Quantum.Canon.csproj : warning NU1603: Microsoft.Quantum.Canon depends on NETStandard.Library (&gt;= 2.0.2-servicing-25519-03) but NETStandard.Library 2.0.2-servicing-25519-03 was not found. An approximate best match of NETStandard.Library 2.0.2 was resolved.
Round 0:    Sent True,  got True.
Teleportation successful!!

Round 1:    Sent False, got False.
Teleportation successful!!

Round 2:    Sent True,  got True.
Teleportation successful!!

Round 3:    Sent False, got False.
Teleportation successful!!

Round 4:    Sent True,  got True.
Teleportation successful!!

Round 5:    Sent False, got False.
Teleportation successful!!

Round 6:    Sent True,  got True.
Teleportation successful!!

Round 7:    Sent False, got False.
Teleportation successful!!



Press Enter to continue...
</code></pre>

<p>It worked!</p>
",9/25/2018 17:26,Errors,he user is encountering an error while trying to run the Microsoft Quantum Development Kit on a CentOS 7 machine and is seeking a solution to resolve the error., Errors,,,,Errors,
52701261.0,Qiskit NameError: name 'q0' is not defined,"<p>I wrote the following code to implement the Grover's algorithm using 3-qubits. </p>

<pre><code>from qiskit import*
from qiskit.tools.visualization import*

list = [q0,q1,q2]
def ccz(qci,q0,q1,q2):
    qci.h(q2)
    qci.ccx(q0,q1,q2)
    qci.h(q2)
def grover(qci,q0,q1,q2):
    ccz(qci,q0,q1,q2)
    for i in range(list):
        qci.h(i)
        qci.x(i)
    ccz(qci,q0,q1,q2)
    for i in range(list):
        qci.x(i)
        qci.h(i)

bn = 3
q = QuantumRegister(bn)
c = ClassicalRegister(bn)
qc = QuantumCircuit(q,c)
for i in range(bn):
    qc.h(q[i])
grover(qc,q[0],q[1],q[2])
for i in range(bn):
    qc.measure(q[bn-i-1],c[i])
r = execute(qc,""local_qasm_simulator"").result()
rc = r.get_counts()
print(rc)
plot_histogram(rc) 
</code></pre>

<p>But I got the error below.  Why did my Jupyter notebook care only about ""q0"", not other elements in the list? How can I fix this?</p>

<pre><code>NameError: name 'q0' is not defined
</code></pre>
",<python-3.x><qiskit>,10/08/2018 11:27,53456577.0,53456577.0,"<p>It gives you error about <code>q0</code> because this is the first unknown variable that it encounters. Then it dies.</p>

<p>There is improper flow in your program. You try to define the variable <code>list</code>:</p>

<ul>
<li>you try to build it from the variables that are not defined yet,</li>
<li>you make it global and try to operate somehow in the functions, where you pass also pass variables as parameters,</li>
<li>this name <code>list</code> is not a good choice as it's a python built-in name.</li>
</ul>

<p>Try this one:</p>

<pre><code>from qiskit import *
from qiskit.tools.visualization import *

def ccz(qci, q0, q1, q2):
    qci.h(q2)
    qci.ccx(q0, q1, q2)
    qci.h(q2)


def grover(qci, q0, q1, q2):
    ccz(qci, q0, q1, q2)
    for i in [q0, q1, q2]:
        qci.h(i)
        qci.x(i)
    ccz(qci, q0, q1, q2)
    for i in [q0, q1, q2]:
        qci.x(i)
        qci.h(i)

bn = 3
q = QuantumRegister(bn)
c = ClassicalRegister(bn)
qc = QuantumCircuit(q, c)
for i in range(bn):
    qc.h(q[i])
grover(qc, q[0], q[1], q[2])
for i in range(bn):
    qc.measure(q[bn - i - 1], c[i])
r = execute(qc, ""local_qasm_simulator"").result()
rc = r.get_counts()
print(rc)
plot_histogram(rc)
</code></pre>
",11/24/2018 8:45,Errors,"The user is getting a NameError: name 'q0' is not defined error because the variable q0 is defined within the grover() function, but is not defined in the global scope.",Errors,,,,Errors,
53072732.0,Q# compiler errors in Quantum Development Kit on macOS,"<p>I have a compilation error of this simple Q# example of newly Microsoft Quantum Development Kit:</p>

<pre><code>namespace Quantum.Bell
{
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    operation Set (desired: Result, q1: Qubit) : Unit
    {
        let current = M(q1);
        if (desired != current)
        {
            X(q1);
        }
    }

    operation BellTest (count : Int, initial: Result) : (Int, Int)
    {
        mutable numOnes = 0;
        using (qubit = Qubit())
        {
            for (test in 1..count)
            {
                Set (initial, qubit);

                let res = M (qubit);

                // Count the number of ones we saw:
                if (res == One)
                {
                    set numOnes = numOnes + 1;
                }
            }
            Set(Zero, qubit);
        }

        // Return number of times we saw a |0&gt; and number of times we saw a |1&gt;
        return (count-numOnes, numOnes);
    }
}
</code></pre>

<p>where the C# Quantum Simulator Code looks like</p>

<pre><code>using System;

using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace Bell
{
    class Driver
    {
        static void Main(string[] args)
        {
            using (var qsim = new QuantumSimulator())
            {
                // Try initial values
                Result[] initials = new Result[] { Result.Zero, Result.One };
                foreach (Result initial in initials)
                {
                    var res = BellTest.Run(qsim, 1000, initial).Result;
                    var (numZeros, numOnes) = res;
                    System.Console.WriteLine(
                        $""Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4}"");
                }
            }

            System.Console.WriteLine(""Press any key to continue..."");
            System.Console.ReadKey();
        }
    }
}
</code></pre>

<p>when compiling with <code>dotnet run</code> I get</p>

<pre><code>ip-192-168-1-103:Bell loretoparisi$ dotnet run
Driver.cs(18,31): error CS0103: The name 'BellTest' does not exist in the current context [/Users/loretoparisi/Documents/Projects/AI/quantum/Bell/Bell.csproj]
Driver.cs(19,26): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'numZeros'. [/Users/loretoparisi/Documents/Projects/AI/quantum/Bell/Bell.csproj]
Driver.cs(19,36): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'numOnes'. [/Users/loretoparisi/Documents/Projects/AI/quantum/Bell/Bell.csproj]

The build failed. Please fix the build errors and run again.
</code></pre>

<p>A simpler working example is <a href=""https://github.com/loretoparisi/quantum-development-kit"" rel=""noreferrer"">here</a>.</p>
",<.net><quantum-computing><q#>,10/30/2018 20:51,53073239.0,53073239.0,"<p>There is a namespaces mismatch: the namespace used in Q# code is <code>Quantum.Bell</code>, while the namespace used in C# code is simply <code>Bell</code> - you need either to fix the files to use the same namespace or to add a <code>using Quantum.Bell;</code> to the C# code.</p>
",10/30/2018 21:35,Errors,"The user is encountering compilation errors when trying to run a simple Q# example using the Microsoft Quantum Development Kit, specifically related to undefined names and type inference issues in the C# code. They are seeking a solution to fix these build errors.",Errors,,,,Errors,
53189971.0,QDK file not found error in LiH Simulation,"<p>I am on MacOS.  While ""dotnet run"" on unmodified version of ""LithiumHydrideGUI"" I am getting the following unhandled exception as</p>

<blockquote>
  <p>File Not Found for
  'Quantum-release-v0.3.1810/Chemistry/LithiumHydrideGUI/..\IntegralData\YAML\LiHData\integrals_lih_sto-3g_0.800.nw.out.yaml'.</p>
</blockquote>

<p>I do see that the file is very much present in the directory one level up that is at ""Chemistry"" folder.  Please let me know how to fix this. </p>
",<quantum-computing>,11/07/2018 13:00,53326334.0,53326334.0,"<p>You need to switch the direction of the slashes from ""\"" to ""/"". You will find the line for this in the ""Program"" file.</p>
",11/15/2018 19:05,Errors,"The user is encountering a ""File Not Found"" error while running the ""LithiumHydrideGUI"" program on MacOS, specifically related to the absence of a YAML file. They are seeking a solution to fix this issue.",Errors,,,,Errors,
53268561.0,QuTiP: Resolving inconsistent Qobj shapes,"<p>This was previously explored in <a href=""https://stackoverflow.com/questions/51179989/qutip-typeerror-incompatible-qobj-shapes-with-tensor-product/51191385#comment93420626_51191385"">QuTiP TypeError: Incompatible Qobj shapes with tensor product</a> but I'm not sure about the answer there.</p>

<p>Suppose I define <code>A = tensor(qeye(2), qeye(2))</code> and <code>B = qeye(4)</code>, I cannot multiply them because the object shapes are inconsistent. </p>

<p>However, the matrices are of the same dimension and I would like to ""flatten"" <code>A</code> to allow it to be multiplied by <code>B</code>. If I have a combination of seperable operators and non-seperable ones, how do I use them together? In other words, <code>B</code> cannot be simplified further so what should I do to <code>A</code> to allow them to be multiplied?</p>

<p>EDIT: The clunky looking Qobj(A.data.toarray()) works but I'll leave this open in case someone has a better idea or understands why QuTiP does this.</p>
",<python><qutip>,11/12/2018 19:06,53287987.0,53287987.0,"<p>Yes using <code>Qobj.data</code> you get the matrix representing the state or operator.</p>

<p>Hence <code>A.data * B.data</code> allows you to multiply them together. Once you've done that you can enclose it in <code>Qobj(A.data * B.data)</code> to make it a quantum object.</p>
",11/13/2018 19:12,Errors,The user is encountering an issue with QuTiP regarding incompatible Qobj shapes when trying to multiply matrices. They are seeking a solution to make these matrices compatible for multiplication.,Errors,,,,Errors,
53273082.0,IndexError: list index out of range (Bloch sphere),"<p>I'm trying to build something called a Bloch Sphere, which is the 3-D representation of single quantum bit.  Currently, I'm creating a function that develops animation along the x-axis and here is the code that I've written.</p>

<pre><code>def x_animation(self):
    #Y and Z are inputs from users
    Y1 = self.Y*(-1)
    Z1 = self.Z*(-1)
    #number of dots which consists animation
    length = 10
    for i in range(length+1):
        # an array of X,Y,Z coordinates of 10 dots
        xgate= []
        xgate_y = np.linspace(self.Y,Y1,length+1)
        xgate_z = np.linspace(self.Z,Z1,length+1)
        xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)])
        plot(xgate[i][0],xgate[i][1],xgate[i][2])
</code></pre>

<p>However, I got the error below.</p>

<pre><code>IndexError                                Traceback (most recent call last)
&lt;ipython-input-5-f56aa4b3a487&gt; in &lt;module&gt;()
----&gt; 1 q.x_animation()

&lt;ipython-input-3-f74dcce093d4&gt; in x_animation(self)
 57             xgate_z = np.linspace(self.Z,Z1,length+1)
 58           xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)])
---&gt; 59             plot(xgate[i][0],xgate[i][1],xgate[i][2])
 60 
 61     def x_gate(self):

IndexError: list index out of range
</code></pre>

<p>I would appreciate it if anyone help me with solving this problem.</p>
",<python-3.x><quantum-computing>,11/13/2018 2:51,53293161.0,53293161.0,"<p>Your code initializes the list <code>xgate</code> to an empty list on each iteration, and then it appends one element to it, thus <code>xgate</code> never has more than one element in it by the time <code>plot</code> is called. But <code>plot</code> tries to access i-th element of <code>xgate</code>, which will succeed on the first iteration and fail on the second one (once <code>i=1</code>).</p>

<p>You should be able to fix this by moving list initialization <code>xgate = []</code> outside of the loop, so that it would actually accumulate the elements.</p>

<p>(I'm not sure initialization of <code>xgate_y</code> and <code>xgate_z</code> should be in the loop either, but those are not accumulated and should not cause this kind of an issue.)</p>
",11/14/2018 4:23,Errors,"The user is encountering an ""IndexError: list index out of range"" error in their Python code when attempting to create a Bloch Sphere animation. They are seeking assistance in resolving this issue.",Errors,,,,Errors,
53317490.0,Cannot load Q# language extension,"<p>I installed the quantum development kit from the microsoft site:</p>

<p><a href=""https://www.microsoft.com/en-us/quantum/development-kit"" rel=""nofollow noreferrer"">https://www.microsoft.com/en-us/quantum/development-kit</a></p>

<p>But when I try to open one of the projects or create a Q# I get the message:</p>

<blockquote>
  <p>There was an error activating the remote language server, Q# Language Extension. For more details, please run devenv /log and examine ....\ActivityLog.xml file.</p>
</blockquote>

<p>I ran it and found:</p>

<blockquote>
  <p>ERROR
      System.SystemException: The trust relationship between the primary domain and the trusted domain failed. at System.Security.Principal.NTAccount.TranslateToSids(IdentityReferenceCollection sourceAccounts, Boolean&amp; someFailed) at System.Security.Principal.NTAccount.Translate(IdentityReferenceCollection sourceAccounts, Type targetType, Boolean&amp; someFailed) at System.Security.Principal.NTAccount.Translate(IdentityReferenceCollection sourceAccounts, Type targetType, Boolean forceSuccess) at System.Security.Principal.NTAccount.Translate(Type targetType) at System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean&amp; modified) at System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(AccessRule rule) at System.IO.Pipes.PipeSecurity.AddAccessRule(PipeAccessRule rule) at Microsoft.Quantum.QsLanguageExtensionVS.QsLanguageClient.d__24.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task) at Microsoft.VisualStudio.LanguageServer.Client.RemoteLanguageServiceBroker.RemoteLanguageClientInstance.d__49.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.VisualStudio.Threading.ThreadingTools.d__12.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.VisualStudio.LanguageServer.Client.RemoteLanguageServiceBroker.RemoteLanguageClientInstance.d__47.MoveNext() --- End of stack trace from previous location where exception was thrown --- at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)</p>
  
  <p>Q# Language Extension</p>
</blockquote>

<p>So I have no intellisense and the *.qs files are not as Q# recognized.</p>

<p><strong>Visual Studio 2017 15.9</strong></p>

<p><strong>Windows 10 1809</strong></p>

<p>Any idea about this?</p>
",<visual-studio><visual-studio-2017><quantum-computing><q#>,11/15/2018 10:35,53421341.0,53421341.0,"<p>We have posted a new version of the <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">Visual Studio extension</a> (0.3.1811.1501) which we believe should fix the problem. Do you mind <a href=""https://learn.microsoft.com/en-us/visualstudio/extensibility/how-to-update-a-visual-studio-extension?view=vs-2017"" rel=""nofollow noreferrer"">updating the extension</a> and giving it a try?</p>
",11/21/2018 22:30,Errors ,"The user is encountering an error when trying to activate the Q# Language Extension in Visual Studio, which is causing issues with IntelliSense and the recognition of Q# files. They are seeking assistance in resolving this issue.",Tooling," This question falls under the ""Tooling"" category as the user is facing issues related to the tools and software they are using for quantum programming. They are encountering an error while trying to use the Q# Language Extension in Visual Studio, which is a tool used for quantum development.",No,16.0,Errors,"The user is encountering a specific error message related to the activation of the Q# Language Extension in Visual Studio, indicating an issue that needs to be resolved to enable IntelliSense and proper recognition of Q# files."
53433436.0,Is there already an XMSS/XMSS^MT Provider for Java JCA (Java Cryptography Architecture)?,"<p>I was wondering if there are already Providers in the Java Cryptography Architecture (JCA) for post-quantum signature schemes, especially XMSS^MT?</p>
",<java><cryptography><post-quantum-cryptography>,11/22/2018 14:48,53437544.0,53437544.0,"<p>Here is an example taken almost verbatim from the Bouncycastle source code in <code>org.bouncycastle.pqc.jcajce.provider.test.XMSSMTTest</code>. This code was run on Java 8.</p>

<pre><code>import org.bouncycastle.pqc.jcajce.interfaces.StateAwareSignature;
import org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider;
import org.bouncycastle.pqc.jcajce.spec.XMSSMTParameterSpec;
import org.bouncycastle.util.Strings;

import java.security.*;

public class Main {

    private static void fail(boolean condition, String msg) {
        if (condition) {
            throw new RuntimeException(msg);
        }
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastlePQCProvider());
        byte[] msg = Strings.toByteArray(""Cthulhu Fthagn --What a wonderful phrase!Cthulhu Fthagn --Say it and you're crazed!"");
        KeyPairGenerator kpg = KeyPairGenerator.getInstance(""XMSSMT"", ""BCPQC"");

        kpg.initialize(new XMSSMTParameterSpec(20, 10, XMSSMTParameterSpec.SHA256), new SecureRandom());

        KeyPair kp = kpg.generateKeyPair();

        Signature sig = Signature.getInstance(""SHA256withXMSSMT"", ""BCPQC"");

        fail(!(sig instanceof StateAwareSignature), ""wrong signature instance"");

        StateAwareSignature xmssSig = (StateAwareSignature) sig;

        xmssSig.initSign(kp.getPrivate());

        fail(!xmssSig.isSigningCapable(), ""signature object is not signing-capable"");

        xmssSig.update(msg, 0, msg.length);

        byte[] s = sig.sign();

        PrivateKey nKey = xmssSig.getUpdatedPrivateKey();

        fail(kp.getPrivate().equals(nKey), """");
        fail(xmssSig.isSigningCapable(), ""signature object is signing-capable"");

        xmssSig.update(msg, 0, msg.length);

        try {
            sig.sign();
            fail(true, ""no exception after key extraction"");
        } catch (SignatureException e) {
            fail(!""signing key no longer usable"".equals(e.getMessage()), ""wrong exception"");
        }

        try {
            xmssSig.getUpdatedPrivateKey();
            fail(true, ""no exception after key extraction"");
        } catch (IllegalStateException e) {
            fail(!""signature object not in a signing state"".equals(e.getMessage()), ""wrong exception"");
        }

        xmssSig.initSign(nKey);

        xmssSig.update(msg, 0, msg.length);

        s = sig.sign();

        xmssSig.initVerify(kp.getPublic());

        xmssSig.update(msg, 0, msg.length);

        fail(!xmssSig.verify(s), ""verification failure"");
    }
}
</code></pre>

<p>There are other examples in that file as well. Source code is available <a href=""http://www.bouncycastle.org/download/bcprov-jdk15on-160.tar.gz"" rel=""nofollow noreferrer"">here</a>.</p>
",11/22/2018 20:15,Tooling,"The question is asking about the existence of a specific provider in the Java Cryptography Architecture (JCA) for post-quantum signature schemes, which falls under the use of tools and software in quantum programming", Tooling,,,,Tooling,
53605241.0,C++ Using Keccak Library,"<p>Im working on my bachelor thesis and I have to test some post quantum algorithms. I downloaded them from NIST. But when I tried DAGS: <a href=""https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/round-1/submissions/DAGS.zip"" rel=""nofollow noreferrer"">https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/round-1/submissions/DAGS.zip</a> and tried to ""make"" dags3 or dags5 I got this error:</p>

<p>encapsulation.o: In function <code>encapsulation':
encapsulation.c:(.text+0xeb): undefined reference to</code>KangarooTwelve'
encapsulation.c:(.text+0x13a): undefined reference to <code>KangarooTwelve'
encapsulation.c:(.text+0x2c9): undefined reference to</code>KangarooTwelve'
encapsulation.c:(.text+0x478): undefined reference to <code>KangarooTwelve'
decapsulation.o: In function</code>decapsulation':
decapsulation.c:(.text+0x16e): undefined reference to <code>KangarooTwelve'
decapsulation.o:decapsulation.c:(.text+0x1bd): more undefined references to</code>KangarooTwelve' follow
collect2: error: ld returned 1 exit status
Makefile:22: recipe for target 'PQCgenKAT_kem' failed
make: *** [PQCgenKAT_kem] Error 1</p>

<p>I have keccak library installed and in this algorithm keccak library is included. Any ideas? Thank you for any help.</p>
",<c++><keccak><post-quantum-cryptography>,12/04/2018 03:23,53644832.0,53644832.0,"<p>Pursuant to the comments, I had time to look into the build tonight (also on Archlinux), I didn't experience any problems. Here are the detailed steps I used.</p>

<p>First the general kernel and gcc info:</p>

<pre><code>$ uname -a
Linux valkyrie 4.19.4-arch1-1-ARCH #1 SMP PREEMPT 
Fri Nov 23 09:06:58 UTC 2018 x86_64 GNU/Linux

$ gcc --version
gcc (GCC) 8.2.1 20180831
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>

<p>Cloning the KeccakCodePackage:</p>

<pre><code>$ git clone https://github.com/gvanas/KeccakCodePackage
</code></pre>

<p>I usually try and and do an out-of-source build, especially with git repos (just habit from building TDE/KDE3), so I just create a <code>kbuild</code> and copy the source files over:</p>

<pre><code>$ md kbuild
$ cp -a KeccakCodePackage/* kbuild/
$ cd kbuild
</code></pre>

<p>Now build the required static library per the Readme file and copy the library and headers to /usr/local/, e.g.:</p>

<pre><code>$ make generic64/libkeccak.a

$ sudo cp -a bin/generic64/libkeccak.a /usr/local/lib
$ sudo cp -a bin/generic64/libkeccak.a.headers /usr/local/include
</code></pre>

<p>Now unzip and build DAGS <code>PQCgenKAT_kem</code></p>

<pre><code>$ cd ..
$ unzip DAGS.zip
$ cd DAGS/Optimized_Implementation/kem/dags5

$ make
gcc -c gf.c -o gf.o -march=native -mtune=native -c -Wall -I.
gcc -c poly.c -o poly.o -march=native -mtune=native -c -Wall -I.
gcc -c matrix.c -o matrix.o -march=native -mtune=native -c -Wall -I.
matrix.c: In function âmatrix_multiplicationâ:
matrix.c:13:16: warning: âresâ may be used uninitialized in this function 
                [-Wmaybe-uninitialized]
        return res;
                ^~~
matrix.c: In function âmatrix_multiplicaion_subfieldâ:
matrix.c:59:16: warning: âResâ may be used uninitialized in this function 
                [-Wmaybe-uninitialized]
        return Res;
                ^~~
gcc -c fichier.c -o fichier.o -march=native -mtune=native -c -Wall -I.
gcc -c key_gen.c -o key_gen.o -march=native -mtune=native -c -Wall -I.
gcc -c encapsulation.c -o encapsulation.o -march=native -mtune=native -c -Wall -I.
gcc -c decapsulation.c -o decapsulation.o -march=native -mtune=native -c -Wall -I.
gcc -c util.c -o util.o -march=native -mtune=native -c -Wall -I.
gcc -c decoding.c -o decoding.o -march=native -mtune=native -c -Wall -I.
gcc -c kem.c -o kem.o -march=native -mtune=native -c -Wall -I.
gcc -c rng.c -o rng.o -march=native -mtune=native -c -Wall -I.
gcc -c PQCgenKAT_kem.c -o PQCgenKAT_kem.o -march=native -mtune=native -c -Wall -I.
gcc -O3 -march=native -mtune=native gf.o poly.o matrix.o fichier.o key_gen.o
    encapsulation.o decapsulation.o util.o decoding.o kem.o rng.o PQCgenKAT_kem.o 
    -o PQCgenKAT_kem -L/usr/lib -L. -lssl -lcrypto -lkeccak
</code></pre>

<p>Finally run the resulting executable:</p>

<pre><code>$ ./PQCgenKAT_kem
Starting iteration: 0
</code></pre>

<p>(all good, no clue what it does from there, but no errors and it is started fine...)</p>

<p>So, I'm not able to offer a ""silver-bullet"" of what went wrong with your build, but I can confirm the build, according to the various Readme files, proceeds as advertised and results in a working executable. Let me know if you have additional questions.</p>
",12/06/2018 04:47,Errors,The user is getting a undefined reference toKangarooTwelve'` error when trying to compile the DAGS post-quantum algorithm.,Errors,,,,Errors,
53612647.0,Unable to insall QISKIT on Fedora,"<p>I am trying to install QISKIT on Python3 (following the instruction on their <a href=""https://qiskit.org/terra"" rel=""nofollow noreferrer"">website</a>) on my Fedora 28 system, but the following error is being thrown. I have tried to find a solution and tried everything that people have suggested <a href=""https://stackoverflow.com/questions/11094718/error-command-gcc-failed-with-exit-status-1-while-installing-eventlet"">here</a>. But the issue persists. </p>

<pre><code>pip3 install qiskit --user    
Collecting qiskit
  Using cached https://files.pythonhosted.org/packages/b0/83/5aee99f9e958700ca1c4af2c5509b9bf0f012796d4aca5df680e6e7e827c/qiskit-0.6.1-cp36-cp36m-manylinux1_x86_64.whl
Requirement already satisfied: networkx&gt;=2.0 in /usr/local/lib/python3.6/site-packages (from qiskit)
Requirement already satisfied: IBMQuantumExperience&gt;=2.0.3 in /root/.local/lib/python3.6/site-packages (from qiskit)
Requirement already satisfied: pillow&gt;=4.2.1 in /usr/lib64/python3.6/site-packages (from qiskit)
</code></pre>

<p>.
.
.
.</p>

<pre><code>  running build_ext
  building 'psutil._psutil_linux' extension
  creating build/temp.linux-x86_64-3.6
  creating build/temp.linux-x86_64-3.6/psutil
  gcc -pthread -Wno-unused-result -Wsign-compare -DDYNAMIC_ANNOTATIONS_ENABLED=1 -DNDEBUG -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -Wp,-D_GLIBCXX_ASSERTIONS -fexceptions -fstack-protector-strong -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -D_GNU_SOURCE -fPIC -fwrapv -fPIC -DPSUTIL_POSIX=1 -DPSUTIL_VERSION=548 -DPSUTIL_LINUX=1 -I/usr/include/python3.6m -c psutil/_psutil_common.c -o build/temp.linux-x86_64-3.6/psutil/_psutil_common.o
  psutil/_psutil_common.c:9:10: fatal error: Python.h: No such file or directory
   #include &lt;Python.h&gt;
            ^~~~~~~~~~
  compilation terminated.
  error: command 'gcc' failed with exit status 1

  ----------------------------------------
  Failed building wheel for psutil
  Running setup.py clean for psutil
</code></pre>

<p>.
.
.
.</p>

<pre><code>    psutil/_psutil_common.c:9:10: fatal error: Python.h: No such file or directory
     #include &lt;Python.h&gt;
              ^~~~~~~~~~
    compilation terminated.
    error: command 'gcc' failed with exit status 1

    ----------------------------------------
Command ""/usr/bin/python3 -u -c ""import setuptools, tokenize;__file__='/tmp/pip-build-euta5w0j/psutil/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" install --record /tmp/pip-49bs3guc-record/install-record.txt --single-version-externally-managed --compile"" failed with error code 1 in /tmp/pip-build-euta5w0j/psutil/
</code></pre>

<p>Any suggestion on what should be done? Cant post full error trace here as Stackoverflow editor is not allowing.</p>
",<python><gcc><fedora><psutil><qiskit>,12/04/2018 12:08,53613749.0,53613749.0,"<p>Looking at the github repo for QISKIT i find that others have had similar issues. Start by looking over the responses found here <a href=""https://github.com/Qiskit/qiskit-tutorial/issues/254"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-tutorial/issues/254</a>. They suggesting making usre you have psutil installed. I would start with this <a href=""https://github.com/giampaolo/psutil/blob/master/INSTALL.rst"" rel=""nofollow noreferrer"">https://github.com/giampaolo/psutil/blob/master/INSTALL.rst</a>. Also, for what it is worth, I see the poster on github was also using Fedora. </p>
",12/04/2018 13:10,Errors,The user is getting a psutil/_psutil_common.c:9:10: fatal error: Python.h: No such file or directory error when trying to install QISKIT on Fedora 28, Errors,,,,Errors,
53925337.0,Q# Intellisense Errors,"<p>I can build my Q# projects fine, but VS 2017 (v. 15.9.4) has the Intellisense errors code QS6103 of ""No namespace with that name exists."" for my first two ""open"" statements shown below. I have tried with both the ""0.3.1811.1501"" and ""0.3.1811.2802"" versions of the SDK and Canon.</p>

<pre><code> namespace Quantum.QSharpApplication1
{
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    operation HelloQ () : Unit {
        Message(""Hello quantum world!"");
    }

}
</code></pre>
",<visual-studio><visual-studio-2017><q#>,12/25/2018 20:09,53926530.0,53926530.0,"<p>What version of .NET Core do you have installed? (You can check using <code>dotnet --version</code>)</p>

<p>I ran into similar problems with Q# IntelliSense not recognizing library namespaces, with .NET Core 2.1.500 and 2.1.403, but with 2.1.402 it works fine. I had to uninstall the higher versions though.</p>
",12/26/2018 0:34,Errors," The user is getting Intellisense error code QS6103 ""No namespace with that name exists"" for the ""Microsoft.Quantum.Primitive"" and ""Microsoft.Quantum.Canon"" namespaces.",Errors,,,,Errors,
53929599.0,Cannot import Aer from Qiskit 0.7,"<p>I've created a new virtual environment in Anaconda and installed several packages using pip (namely, numpy, scipy, matplotlib, qiskit and maybe 1 or 2 more). I open the interpreter and try to import a module from Qiskit:</p>

<pre><code>from qiskit import Aer
</code></pre>

<p>As a result, I get <code>ImportError: cannot import name 'Aer'</code>. My understanding is that either Qiskit 0.7 has a different structure of the modules (which I can't find anywhere in the documentation) or that my setup has a conflict of some kind. How do I know what is the case and how do I fix it?</p>

<p><strong>EDIT</strong>: I have a dual boot system. The problem occurs on Anaconda on Windows 10, but doesn't on Ubuntu 18 on pure Python. So I think it has to be something with Anaconda rather than Qiskit.</p>

<p><strong>EDIT 2</strong>: I have made a clean install of Python (without Anaconda) and the problem persists. </p>
",<python><python-import><qiskit>,12/26/2018 8:46,54275759.0,54275759.0,"<p>Indeed, I also had the same issue: Anaconda 3 on Windows 10. I later had the same trouble on a travis CI python 3.5 &amp; 3.6 build image. For both I had a similar yet different solution. The similarity lies in the fact that it seems to be a missing dependency. The code of the simulator is written in C++ or maybe now Cython. So they use some dependencies that your setup may not have.
This is where the similarities ended. What I did:</p>

<h1>Windows 10 / Anaconda setup</h1>

<p>With the dependency walker <a href=""http://www.dependencywalker.com/"" rel=""nofollow noreferrer"">http://www.dependencywalker.com/</a> I found out that the openblas.dll is missing as dependency. Interesting enough, in the legacy simulators the qiskit team provided one. So you could either use this one or download (and rename!!) the latest binary from <a href=""https://www.openblas.net/"" rel=""nofollow noreferrer"">https://www.openblas.net/</a>. Then copy it into your site-packages folder. You know you got the right folder when you find files with the names of the sort</p>

<ul>
<li>unitary_controller_wrapper.pyd</li>
<li>statevector_controller_wrapper.pyd</li>
<li>qasm_controller_wrapper.pyd</li>
</ul>

<h1>Travis CI python >= 3.5 image</h1>

<p>Here on the other hand I was at loss with the same explanation (and solution), so I looked into qiskit-aer repository's <code>.travis</code> setup. Here you see, that they use (among other directives)
 - <code>sudo apt-get -y install g++-7</code>
 - <code>sudo apt-get -y install libopenblas-dev</code>
I used this for my travis CI and - voilÃ  - it works. Prior to this I used <code>ldd</code> and <code>readelf</code> and it pointed to some library that I don't recall but it seems like qiskit-aer depends on it and you get this with a more recent version of g++.</p>

<p>I wonder if this will solve your issues.</p>
",1/20/2019 10:56,Errors,The user is getting an ImportError: cannot import name 'Aer' error when trying to import a module from Qiskit after installing it in a virtual environment on Windows 10.,Errors,,,,Errors,
54074951.0,how to select unique elements of a list in q#?,"<p>I'm new to <code>q#</code> programming.
I have a number list:</p>

<pre><code>1 3 2 3 2 4 5 2 3 6 4 2 1 6 3 2 1
</code></pre>

<p>Now, I want to generate unique set of numbers in <code>Q programming language</code> where final output must be: <code>1 2 3 4 5 6</code></p>
",<list><q#>,01/07/2019 13:02,54083864.0,54083864.0,"<p>There is no library method for this in Q#, so you'd have to implement it yourself. If the range of the possible numbers is small (up to N), you can allocate an extra array of N elements and mark all the numbers that occur in the input array. Otherwise you can sort the input array and return all numbers which differ from the one right before them and right after them.</p>

<p>That being said, I wonder why do you need to do this in Q#? Q# is a domain-specific language, so a lot of things which are one or two library calls in general-purpose languages can be rather inconvenient to do in Q#. It is typically much easier to do them in C# or F# driver and pass the result to Q# code as a parameter.</p>
",01/08/2019 00:45,Tooling,"The user is asking for help with writing Q# code to generate a unique set of numbers from a list, which falls under the use of tools and software in quantum programming",Tooling,,,,Tooling,
54333024.0,"Does Q# maintain the state of a qubit, after performing the measurement?","<p>This is a problem in the Quantum Katas exercises, by Microsoft.</p>

<pre><code>// Input: Two qubits (stored in an array) which are guaranteed to be
//        either in superposition of states |00â© and |11â©
//        or in superposition of states |01â© and |10â©.
// Output: 0 if qubits were in the first superposition,
//         1 if they were in the second superposition.
// The state of the qubits at the end of the operation should be the same as the starting state
</code></pre>

<p>The solution given in the reference implementation is as follows:</p>

<pre><code>operation ParityMeasurement_Reference (qs : Qubit[]) : Int {
    return Measure([PauliZ, PauliZ], qs) == Zero ? 0 | 1;
}
</code></pre>

<p>How can the state of the qubits be retained if the measurement operation is performed? Or, does the Measure() function work differently?</p>
",<q#>,1/23/2019 17:55,54334398.0,54334398.0,"<p>Let's start with a simpler scenario: measuring one qubit in computational basis. In general its state will change from Î±|0â© + Î²|1â© to |0â© or |1â©, depending on the results of the measurement. But if the qubit was already in the |0â© state (or |1â© - both are eigenstates of the observable being measured), the measurement will not change its state.</p>

<p>In general case, projective measurements project the state of the system on the eigenspace of the observable with the eigenvalue which corresponds to the measurement result. If the qubit was already in an eigenstate, the measurement outcome is defined with certainty, and the projection will not modify the state.</p>

<p>Now, back to the original task. You are given two qubits either in Î±|00â© + Î²|11â© state or in Î±|01â© + Î²|10â© state. </p>

<p>If you limit your measurements to single-qubit measurements in computational basis (implemented as M operation in Q#), you can still distinguish the states but they will be changes, collapsing on |00â©/|11â© or on |01â©/|10â© states, depending on the measurement outcomes, - you can check this in the previous task of the <a href=""https://github.com/Microsoft/QuantumKatas/blob/master/Measurements/"" rel=""nofollow noreferrer"">Measurements kata</a>. To be able to distinguish the states without changing them, you need to figure out an observable which has these two states as eigenstates with different eigenvalues.</p>

<p>Consider a Z â Z operator (which applies a Z gate to both qubits): Î±|00â© + Î²|11â© is an eigenstate with eigenvalue of 1, and Î±|01â© + Î²|10â© is an eigenstate with eigenvalue of -1. If you measure this operator, you will be able to distinguish the states without changing them. This type of measurement is called joint measurement or parity measurement (measuring multiple qubits in Z basis is the same as measuring the parity of the state, the states with even number of 1s have eigenvalue of 1, and the states with odd number of 1s have eigenvalue of -1). And this is exactly the kind of measurement the Measure operation performs. </p>

<p>You can read more about multi-qubit Pauli measurements in the <a href=""https://learn.microsoft.com/en-us/quantum/concepts/pauli-measurements"" rel=""nofollow noreferrer"">Q# documentation</a>.</p>
",1/23/2019 19:30,Theoretical ,"The users question is about the theoretical aspects of quantum mechanics, specifically about the behavior of quantum measurements and eigenstates.",Theoretical,,,,Theoretical ,
54334108.0,VSCode Q# extension installation issue?,"<p><a href=""https://github.com/MicrosoftDocs/quantum-docs-pr/issues/346"" rel=""nofollow noreferrer"">It was suggested to me to ask this here</a>, I have no issue on running <code>dotnet restore</code> and <code>dotnet run</code> on a just created project folder but VSCode Q# extension fails to work like this and it doesn't give any good pointer what has went wrong.</p>

<pre><code>[Error - 10:35:54 PM] MSBuild error in /opt/dotnet/sdk/2.2.100/NuGet.targets(123,7): The ""RestoreForceEvaluate"" parameter is not supported by the ""RestoreTask"" task. Verify the parameter exists on the task, and it is a settable public instance property.
[Error - 10:35:54 PM] MSBuild error in /opt/dotnet/sdk/2.2.100/NuGet.targets(114,5): The ""RestoreTask"" task could not be initialized with its input parameters. 
[Error - 10:35:54 PM] Failed to restore project '.../Bell/Bell.csproj'.
[Error - 10:35:54 PM] MSBuild error in /opt/dotnet/sdk/2.2.100/Sdks/Microsoft.NET.Sdk/targets/Microsoft.PackageDependencyResolution.targets(208,5): The ""ResolvePackageAssets"" task failed unexpectedly.
System.IO.FileLoadException: Could not load file or assembly 'NuGet.Frameworks, Version=4.9.0.6, Culture=neutral, PublicKeyToken=31bf3856ad364e35'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
File name: 'NuGet.Frameworks, Version=4.9.0.6, Culture=neutral, PublicKeyToken=31bf3856ad364e35'
   at Microsoft.NET.Build.Tasks.ResolvePackageAssets.CacheWriter..ctor(ResolvePackageAssets task, Stream stream)
   at Microsoft.NET.Build.Tasks.ResolvePackageAssets.CacheReader.CreateReaderFromMemory(ResolvePackageAssets task, Byte[] settingsHash)
   at Microsoft.NET.Build.Tasks.ResolvePackageAssets.CacheReader..ctor(ResolvePackageAssets task)
   at Microsoft.NET.Build.Tasks.ResolvePackageAssets.ReadItemGroups()
   at Microsoft.NET.Build.Tasks.ResolvePackageAssets.ExecuteCore()
   at Microsoft.NET.Build.Tasks.TaskBase.Execute()
   at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()
   at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)


[Error - 10:35:54 PM] Failed to resolve assembly references for project
</code></pre>

<p>I believe I should've raised this on VSCode Q# extension bug tracker but I can't find the tracker and as mentioned initially I am suggested to ask here, so. Thanks!</p>
",<visual-studio-code><q#>,1/23/2019 19:09,54335224.0,54335224.0,"<p>This might be another manifestation of <a href=""https://stackoverflow.com/questions/53925337/q-intellisense-errors"">this question</a> - Q# IntelliSense is not happy with .NET Core versions above 2.1.402, and looks like your .NET Core version is 2.2.100. We're working on a fix; meanwhile, downgrading to earlier version should help.</p>

<p>Update: This issue should have been fixed with QDK release 0.4.</p>
",1/23/2019 20:35,Errors ," The question is about resolving an error encountered during quantum program development, seeking an explanation and solution for the error messages generated while trying to build a Q# project using the VSCode Q# extension.",Errors ,,,,Errors ,
54503699.0,No module named 'qiskit',"<pre><code>import numpy as np
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute
</code></pre>

<hr>

<p>When trying the above code, I am receiving the following error:</p>

<blockquote>
  <p>ModuleNotFoundError                       Traceback (most recent call last)
   in ()
        1 import numpy as np
  ----> 2 from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
        3 from qiskit import execute</p>
  
  <p>ModuleNotFoundError: No module named 'qiskit'</p>
</blockquote>
",<python><qiskit>,02/03/2019 14:10,54503719.0,54503719.0,"<p>You need to install it via </p>

<pre><code>pip install qiskit
</code></pre>

<p>Refer to this for more information <a href=""https://github.com/Qiskit/qiskit/blob/master/docs/install.rst"" rel=""noreferrer"">https://github.com/Qiskit/qiskit/blob/master/docs/install.rst</a></p>
",02/03/2019 14:12, Errors,"The user is encountering a ModuleNotFoundError while trying to import the qiskit module in their Python code, which falls under the category of solving errors and exceptions.", Errors,,,, Errors,
54655700.0,How to change input qubits (q3 and q4) in 5qubit quantum circuit,"<p>Working on a quantum using <code>qiskit</code>. I would want to change the input qubit <code>q4, q3</code> while measuring the output <code>q2, q1</code> and record the probabilities of possible outcome as far attached <a href=""https://i.stack.imgur.com/OeOxo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OeOxo.png"" alt=""figure""></a>.</p>

<p><strong>Question:</strong> How do I change the input in <code>qiskit</code>? Already created quantum registers and  added all qubits (also attached) <a href=""https://i.stack.imgur.com/e9JsY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/e9JsY.png"" alt=""here""></a>.</p>
",<qiskit>,02/12/2019 17:36,55518832.0,55518832.0,"<p>In Qiskit, each qubit starts off in the ground state (0 state). So, if by change the input you mean change the starting value from 0 to 1, the only way to do that would be to apply an X-Gate to qubits q3 and q4. This gate acts similar to a classical NOT gate, so it can be used to flip a qubit from 0 to 1 or vice-versa.</p>

<p>Looking at the table in 5(a), they want you to go through all 4 possible inputs for q3 and q4 (00, 01, 10, 11). So for each of these inputs, your X-Gate assignments would be as follows:</p>

<p>Input 00: No X-Gates needed<br>
Input 01: X-Gate on q3<br>
Input 10: X-Gate on q4<br>
Input 11: X-Gate on q3 and q4</p>
",04/04/2019 14:44,API Usage,"The user is seeking guidance on how to change the input qubits in a quantum circuit created using Qiskit, which pertains to the usage of Qiskit's API for quantum programming.",API Usage,,,,API Usage,
54665595.0,ProjectQ- In which part of the controlled gate object are the control bits scored,"<p>I've been trying to decompose the projectQ objects and I could manage to decompose non controlled gates, and daggered gates. But I noticed that 
the object of a controlled version of a gate is the exact same as the object of that gate.</p>

<p>The code generating these objects:</p>

<pre><code>  eng = MainEngine()
  q = eng.allocate_qubit()
  p = eng.allocate_qubit()
  c = eng.allocate_qubit()
  X | q
  CNOT | (p,q)
</code></pre>

<p>This is the XGate object</p>

<pre><code>{'_control_qubits': [],
 '_engine': &lt;__main__.MainEngine object at 0x7fc323e4d198&gt;,
 '_qubits': ([&lt;projectq.types._qubit.WeakQubitRef object at 0x7fc30b0a3ef0&gt;],),
 'gate': &lt;projectq.ops._gates.XGate object at 0x7fc316778048&gt;,
 'tags': []}
</code></pre>

<p>And this is the CNOT gate, which is the same as ControlledGate(XGate)</p>

<pre><code>{'_control_qubits': [],
 '_engine': &lt;__main__.MainEngine object at 0x7fc323e4d198&gt;,
 '_qubits': ([&lt;projectq.types._qubit.WeakQubitRef object at 0x7fc30b0b1080&gt;],),
 'gate': &lt;projectq.ops._gates.XGate object at 0x7fc316778048&gt;,
 'tags': []}
</code></pre>

<p>Both have no control qubits and it seems like the control gates lost the control qubit. </p>

<p>Any idea on where the control qubit is stored?</p>
",<simulation><quantum-computing>,2/13/2019 8:28,54881145.0,54881145.0,"<p>The control qubits are only added to the command after it is received by the <code>ControlEngine</code> further down the chain after the <code>MainEngine</code>. For implementation details see ""3.2.1 Implementation of meta instructions"" <a href=""https://doi.org/10.3929/ethz-b-000322770"" rel=""nofollow noreferrer"">here</a>.</p>

<p>To implement a testing engine such as this one, that can be used to check that indeed control qubits are added right after the <code>MainEngine</code>, you could do the following:</p>

<pre class=""lang-py prettyprint-override""><code>test_eng = Testing(BasicEngine) # Or CommandPrinter
eng = projectq.MainEngine(engine_list=[test_eng])
</code></pre>
",2/26/2019 8:24,API Usage,"The user is asking about the internal implementation of the ControlledGate class in ProjectQ, which is an API-related question.",API Usage,,,,API Usage,
54717852.0,Why python doesn't see the members of quantumCircuit class qiskit,"<p>I`m trying to learn the programming on quantum computers.
I have installed qiskit in VS Code (all qiskit extentions available in VS Code market) , python compilator (from Vs Code market ""Python"" and ""Python for VSCode""). I have set up my qikit API for correct working </p>

<p>When I run the exemple I get erros: ""Instance of 'QuantumCircuit' has no 'h' member"" </p>

<p>What shoud I do?</p>

<p><img src=""https://i.stack.imgur.com/kDCom.png"" alt=""enter image description here""></p>

<p>The code:</p>

<pre><code>from qiskit import ClassicalRegister, QuantumRegister
from qiskit import QuantumCircuit, execute

q = QuantumRegister(2)
c = ClassicalRegister(2)
qc = QuantumCircuit(q)
qc.h(q[0]) 
qc.cx(q[0], q[1])
qc.measure(q, c)

job_sim = execute(qc, 'local_qasm_simulator')

sim_result = job_sim.result()

print(sim_result.get_counts(qc))
</code></pre>

<p>========================
<a href=""https://i.stack.imgur.com/VgQOw.png"" rel=""nofollow noreferrer"">The same error after adding comment <code># pylint: disable=no-member</code></a></p>
",<python><quantum-computing><qiskit>,2/15/2019 22:25,54718471.0,54718471.0,"<p>The errors in question are coming from pylint, a linter, not from python itself. While pylint is pretty clever, some constructs (particularly those involving dynamically-added properties) are beyond its ability to understand. When you encounter situations like this, the best course of action is twofold:</p>

<ol>
<li>Check the docs, code, etc. to make absolutely sure the code that you've written is right (i.e. verify that the linter result is a false positive)</li>
<li>Tell the linter that you know what you're doing and it should ignore the false positive</li>
</ol>

<p>user2357112 took care of the first step in the comments above, demonstrating that the property gets dynamically set by another part of the library.</p>

<p>The second step can be accomplished for pylint by adding a comment after each of the offending lines telling it to turn of that particular check for that particular line:</p>

<pre><code>qc.h(q[0])  # pylint: disable=no-member
</code></pre>
",2/15/2019 23:47,Errors,"The user is encountering an error related to the usage of the 'h' member in Qiskit's QuantumCircuit object, and they are seeking a solution to resolve this issue.",Errors,,,,Errors,
54855465.0,Can you run 64 bit applications on a quantum computer?,"<p>Since conventional computers use bits, which can either be 1 or 0, can we simulate a 64-bit operating system on a quantum computer by restricting the values of the qubits to either 0 or 1, instead of 0, 1, and everything in between?</p>
",<quantum-computing><q#>,2/24/2019 19:05,54856033.0,54856033.0,"<p>Yes, in principle it's possible to simulate any classical computation on a sufficiently large quantum computer. </p>

<p>Any deterministic classical circuit can be implemented as an equivalent quantum circuit using <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate"" rel=""nofollow noreferrer"">Toffoli (CCNOT) gate</a> - it can simulate classical gates NAND and FANOUT, which are universal for classical circuits. </p>

<p>Quantum computer can also simulate non-deterministic classical circuits by generating fair coin tosses using Hadamard gates followed by measurements (which gives 0 or 1 result with 50/50 probability).</p>

<p>So with the proper software you can simulate any classical computation. However, running a classical OS on a quantum computer would be rather pointless, since classical computers do this quite well already.</p>
",2/24/2019 20:09,Conceptual,"The user is inquiring about the conceptual aspect of simulating a 64-bit operating system on a quantum computer, discussing the use of qubits to represent classical bits, which is a conceptual aspect of quantum computing.",Conceptual,,,,Conceptual,
54910144.0,Why is the return type Unit used to describe operations that have no return value in Q#; as opposed to void or none?,"<p>Why did Microsoft, when creating Q#, decide to use the keyword Unit instead of void or none, to describe methods that have no return value? Is there a reason for this, or did Microsoft just want to do something different?</p>
",<q#>,2/27/2019 16:31,54910622.0,54910622.0,"<p>Functions and operations in Q# are always tuple-in tuple-out.
Together with singletonâtuple equivalence (the principle that <code>'T</code> and <code>('T)</code> are the exact same type), this lets Q# represent things uniformly, with every function and operation taking exactly one input and returning exactly one output, each of which are tuples.</p>

<p>One consequence of this approach that we can write a function like <code>Composed&lt;'T, 'U, 'V&gt;(inner : ('T -&gt; 'U), outer : ('U -&gt; 'V)) : ('T -&gt; 'V)</code>, confident that we can pass <em>any</em> function as <code>inner</code>, without thinking about how many arguments it takes.</p>

<p>For this design to be consistent, we need that a function or operation that ""returns nothing"" returns an empty tuple rather than no value at all. In many functional languages (including F#), the type of the empty tuple is called <code>unit</code> or <code>Unit</code>, following traditional notation in type theory. In Q#, we decided to follow that tradition to clarify the distinction between the value <code>()</code> and the type <code>Unit</code>.</p>
",2/27/2019 16:53,Conceptual,The question is asking about the design choice made by Microsoft to use the keyword Unit instead of void or none to describe methods that have no return value in Q#. This is a conceptual question about the design of the Q# programming language.,Conceptual,,,,Conceptual,
54950467.0,How can Controlled Hadamard be implemented with Q#? Is there an inbuilt function?,"<p>I found a way to implement Controlled Hadamard on <a href=""https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html"" rel=""nofollow noreferrer"">https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html</a></p>

<p>Is there an easier way in Q# to implement this function?</p>
",<q#>,03/01/2019 18:38,54950653.0,54950653.0,"<p>You can use <code>Controlled</code> functor to produce a controlled version of any operation which allows for that (including primitive gates) as follows:</p>

<pre><code>Controlled H([controls], target);
</code></pre>

<p>You can look up the details of using <code>Controlled</code> functor <a href=""https://learn.microsoft.com/en-us/quantum/language/type-model#controlled"" rel=""nofollow noreferrer"">in the documentation</a>.</p>
",03/01/2019 18:53,API Usage,"The question is about how to use the Q# API to implement a specific quantum computing function, Controlled Hadamard.",Tooling,The question is about how to use a specific function (Controlled Hadamard) in a quantum programming tool (Q#),No,17.0,API Usage,"This is because the user is specifically asking about how to implement a function, Controlled Hadamard, using the Q# API, indicating a desire to understand and utilize the language's features effectively for quantum programming."
55319901.0,How to call Q# operations from F#,"<p>I want to write a quantum program in F# but I don't know how to call Q# operations from F#. How exactly would I do this?</p>

<p>I've tried reading the C# version first but it doesn't seem to translate well to F#.</p>
",<f#><q#>,3/24/2019 1:15,55320945.0,55320945.0,"<p>TL;DR: You have to create a Q# library project (which will yield a <code>.csproj</code> project with only Q# files in it) and to reference it from a purely F# application. </p>

<p>You can not mix F# and Q# in the same project, because it won't compile: Q# compiles to C# for local simulation, and you can't have C# and F# in the same projects. However, you can have two separate projects in different languages which both compile to MSIL and can reference each other.</p>

<p>The steps are:</p>

<ol>
<li><p>Create Q# library <code>QuantumCode</code> and write your code in it.</p>

<p>Let's say your code has an entry point with the signature <code>operation RunAlgorithm (bits : Int[]) : Int[]</code> (i.e., it takes an array of integers as a parameter and returns another array of integers).</p></li>
<li><p>Create an F# application (for simplicity let's make it a console app targeting .NET Core) <code>FsharpDriver</code>.</p></li>
<li><p>Add a reference to the Q# library to the F# application.</p></li>
<li><p>Install the NuGet package Microsoft.Quantum.Development.Kit which adds Q# support to the F# application.</p>

<p>You will not be writing any Q# code in <code>FsharpDriver</code>, but you will need to use functionality provided by the QDK to create a quantum simulator to run your quantum code on, and to define data types used to pass the parameters to your quantum program.</p></li>
<li><p>Write the driver in F#. </p>

<pre><code>// Namespace in which quantum simulator resides
open Microsoft.Quantum.Simulation.Simulators
// Namespace in which QArray resides
open Microsoft.Quantum.Simulation.Core

[&lt;EntryPoint&gt;]
let main argv =
    printfn ""Hello Classical World!""
    // Create a full-state simulator
    use simulator = new QuantumSimulator()
    // Construct the parameter
    // QArray is a data type for fixed-length arrays
    let bits = new QArray&lt;int64&gt;([| 0L; 1L; 1L |])

    // Run the quantum algorithm
    let ret = QuantumCode.RunAlgorithm.Run(simulator, bits).Result

    // Process the results
    printfn ""%A"" ret

    0 // return an integer exit code
</code></pre></li>
</ol>

<p>I posted a full example of the project code <a href=""https://github.com/tcNickolas/MiscQSharp/tree/master/Quantum_VBNet"" rel=""noreferrer"">here</a> (originally that project dealt with using Q# from VB.NET, but for F# all the steps are the same).</p>
",3/24/2019 5:19,API Usage,"The question is about how to use the Q# API in conjunction with F#, which falls under the usage of APIs in quantum programming.",API Usage,,,,API Usage,
55564401.0,What is the purpose of Hadamarding and then measuring messages during teleportation?,"<p>I was taking a look at Microsoft Quantum Development Kit Documentation when I've stumbled on the <a href=""https://learn.microsoft.com/en-us/quantum/techniques/putting-it-all-together?view=qsharp-preview"" rel=""nofollow noreferrer"">Teleportation technique tutorial</a>. It says:</p>

<pre><code>1. Entangling here and there by applying a Hadamard gate and CNOT gate.
2. Sending the message using a CNOT gate and a Hadamard gate.
3. Taking a measurement of the first and second qubits, message and here.
4. Applying a NOT gate or a Z gate, depending on the result of the measurement in step 3.
</code></pre>

<p>I understand that Hadamarding a qubit <strong>and then</strong> using CNOT on it and on other qubit entangles them and that's an important part of Teleportation. What I don't understand is how using CNOT on the message qubit <strong>and then</strong> Hadamarding it would help at all on the Teleportation process.</p>

<ul>
<li>Why would I want my message qubit to enter in a superposition state? I don't want to get a random value out of my message, instead, I want it to be transmitted to another qubit.</li>
<li>I get that if a qubit A is collapsed to a message that I'd like to send and if a qubit B is initialized to |0>, CNOT(A, B) would transmit the message. However, what is the purpose of doing this operation if B is in a 50-50 superposition state? I mean, B's wave function would change from sqrt(1/2)|0> + sqrt(1/2)|1> to sqrt(1/2)|1> + sqrt(1/2)|0> How would that help in any way?</li>
</ul>

<p>But the worst part for me is that the method above works just perfectly. There must be something very basic I'm missing. Thanks for reading.</p>
",<quantum-computing><q#>,04/07/2019 22:57,55578405.0,55578405.0,"<p>The best way to understand simple quantum algorithms is to follow the math. </p>

<p>Applying a CNOT to the message qubit and Alice's part of the Bell pair entangles all three qubits, so that the information from the message qubit is distributed across the whole system. Applying a Hadamard gate to the former message qubit and then measuring it and the Alice's qubit makes sure that all the information is concentrated in Bob's qubit and the classical measurement results. But you have to do the math to see what are the states of the system between those operations and why do you have to apply the fixups that the algorithm prescribes. </p>

<p>I will not go into the math here (mostly because it's a huge pain to do so without TeX) - the link you gave does all the math in great detail. To augment the formulas, you can look for an interactive demo which shows the process of teleporting a specific state, such as <a href=""http://demonstrations.wolfram.com/QuantumTeleportation/"" rel=""nofollow noreferrer"">this one</a>.</p>
",04/08/2019 17:06,Theoretical ,"The question is about the theoretical understanding of the quantum teleportation process, specifically the role and impact of certain quantum gates in this process. }which one is better for the above questions",Theoretical,,,,Theoretical ,
55763054.0,Why does the quantum estimator say i don't use any qubits in Q#?,"<p>In short terms, I'm trying to implement in Q# the NonUniform Discrete Fourier Transform.</p>

<p>I've managed to do it bug-free in a classical manner(no quantum gates nor qubits used) yet the resource estimator says that no quantum resources used.
This makes me tend to believe that Q# in the back-end, even though I have an Operation type function, does not make use of any quantum specific operations.
So I'm trying now to take it step-by-step and load my data into qubits (I'm thinking) then make use of any potential useful gates.</p>

<p>Problem is my data consists of 2 arrays consisting of Double numbers representing the real and imaginary parts of complex numbers. I might need to redesign this into an array of straight-up complex values int the future.</p>

<p>But in essence, the problem is how can I load a complex number in one or more qubits such that i can then do some processing over it and obtain some results?</p>

<p>I'm not too keen on sharing my code as the algorithm is something that wasn't attempted before; but small bits of code and especially further clarifications I am willing to provide.</p>
",<c#><fft><complex-numbers><q#><qubit>,4/19/2019 14:00,55764490.0,55764490.0,"<p>If I understand your description correctly, the resources estimator provided with the Quantum Development Kit accurately reported that your operation did not use any qubits or quantum instructions. This is because the qubits used by a Q# operation are precisely those used explicitly with <code>using</code> or <code>borrowing</code> statements, plus those used by any other operations called. </p>

<p>For instance, if you're writing a teleportation operation in Q#, you might do like the following:</p>

<pre><code>operation PrepareEntangledPair(left : Qubit, right : Qubit) : Unit {
    body (...) {
        H(left);
        CNOT(left, right);
    }

    adjoint auto;
}

operation ApplyCorrection(here : Qubit, msg : Qubit, there : Qubit) : Unit {
    if (M(msg) == One)  { Z(there); }
    if (M(here) == One) { X(there); }
}

operation TeleportMessage(msg : Qubit, there : Qubit) : Unit {
    using (here = Qubit()) {
        // Create some entanglement that we can use to send our message.
        PrepareEntangledPair(here, there);

        // Move our message into the entangled pair by using a Bell
        // measurement.
        Adjoint PrepareEntangledPair(msg, here);

        // Measure out the entanglement.
        ApplyCorrection(here, msg, there);

        // Reset our ""here"" qubit before releasing it.
        Reset(here);
    }
}

operation TeleportClassicalFlag() : Unit {
    using ((msg, there) = (Qubit(), Qubit())) {
        X(msg);
        TeleportMessage(msg, there);
        ApplyToEach(Reset, [msg, there]);
    }
}
</code></pre>

<p>Running the resources estimator on this reports that three qubits were used (two by <code>TeleportClassicalFlag</code> directly, and one by <code>TeleportMessage</code>, which was called by <code>TeleportClassicalFlag</code>):</p>

<p><a href=""https://i.stack.imgur.com/bjHnL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bjHnL.png"" alt=""enter image description here""></a></p>

<p>Classical logic, by contrast, always remains classical. This is designed to make it easy to mix classical and quantum logic, such as in implementing iterative phase estimation algorithms. In the above example, the <code>if</code> statements and <code>==</code> operators used in <code>ApplyCorrection</code> are used to describe the classical parts of the teleportation algorithm.</p>
",4/19/2019 15:53,Conceptual,"The user is primarily seeking an understanding of how to load complex numbers into qubits for quantum processing, which aligns with the conceptual aspects of quantum programming techniques.",Conceptual,,,,Conceptual,
55777679.0,How does CLR compile Q# code that uses or does not make use of qubits?,"<p>If a Q# operation does not use qubits or quatum specific gates, will then the CLR generate bytecode that will be executed by the CPU and not the QPU(quantum processor)?</p>
",<clr><q#><qubit>,4/20/2019 20:58,56045697.0,56045697.0,"<p>Yes, exactly. The Q# compiler translates the purely classical parts of your code into C#, which gets compiled (by the C# compiler) into standard .NET MSIL, JITed by the .NET Core runtime, and executed on a normal CPU.</p>
",05/08/2019 17:00,Conceptual,"The question is asking about the relationship between Q# operations, qubits, and quantum processors, which are all fundamental concepts in quantum computing.",Conceptual,,,,Conceptual,
56008081.0,How to pass C# array into a Q# operation within QuantumSimulator Run() command?,"<p>I'm making a program which uses an array of integers taken in as a parameter from the C# script in <code>Driver.cs</code> but it gives the following error:</p>

<p><code>Error CS1503  Argument 2: cannot convert from 'long[]' to 'Microsoft.Quantum.Simulation.Core.IQArray&lt;long&gt;'</code></p>

<p>I have tried to instead pass in an array of strings and convert them inside the program, but an identical error appears:</p>

<p><code>Error CS1503  Argument 2: cannot convert from 'string[]' to 'Microsoft.Quantum.Simulation.Core.IQArray&lt;string&gt;'</code></p>

<p>Here is the C# code in <code>Driver.cs</code> - <code>keyArray</code> is the array that I'm trying to pass to Q#.</p>

<pre class=""lang-cs prettyprint-override""><code>using (var qsim = new QuantumSimulator())
{
    var result = QMain.Run(qsim, keyArray).Result;
    var (res0, res1, res2) = result;
    System.Console.WriteLine(res0 + "", "" + res1 + "", "" + res2);
}
</code></pre>

<p>Q# QMain operation in <code>Operations.qs</code>:</p>

<pre><code>operation QMain(keyCode : Int[]) : (Result, Result, Result)
</code></pre>

<p>In Q#, <code>Int</code> datatype corresponds to C# <code>long</code>.</p>

<p>Passing an array of strings failed as well, with the following signature of <code>QMain</code>:</p>

<pre><code>operation QMain(s : String[]) : (Result, Result, Result)
</code></pre>

<p>All that I'm getting is the same error whenever I try to use any array as a parameter in <code>QMain</code>.</p>
",<c#><quantum-computing><q#>,05/06/2019 15:19,56008293.0,56008293.0,"<p>The data type used for passing fixed-length arrays to and from Q# code is <code>QArray</code>. You have to create an instance of this data type from your array explicitly before passing it to <code>QMain</code>:</p>

<pre><code>var result = QMain.Run(qsim, new QArray&lt;long&gt;(keyArray)).Result;
</code></pre>

<p>You can see an example of passing arrays to Q# <a href=""https://github.com/Microsoft/Quantum/blob/331886049e00b113a133330515d5a12ade0629c5/Samples/src/SimpleAlgorithms/Driver.cs#L90"" rel=""noreferrer"">in the samples</a>.</p>
",05/06/2019 15:31,Errors,"The question is about a specific error message encountered while developing a quantum program, and is seeking help for debugging and understanding the error.",Errors,,,,Errors,
56082828.0,How do I serialize a BCMcEliecePublicKey?,"<p>I want to serialize a McEliece public key (BCMcEliecePublicKey) but always get a NotSerializableException.</p>

<pre><code> java.io.NotSerializableException: org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters
</code></pre>

<p>I tried the same code with XMSSMT and it worked without a problem. The Bouncy Castle version is the new Release 1.61</p>

<p>Here a small code as an example:</p>

<pre><code>    //key generation
    Security.addProvider(new BouncyCastlePQCProvider());
    KeyPairGenerator keygen = null;
    try {
        keygen = KeyPairGenerator.getInstance(""McEliece"", ""BCPQC""); //XMSSMT
    } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
        System.out.println(""Error: KeyPairGenerator could not be instanciated. "" + e.getMessage());
    }

    //XMSSMTParameterSpec bcSpec = new XMSSMTParameterSpec(10, 5, XMSSMTParameterSpec.SHA256);
    McElieceKeyGenParameterSpec bcSpec = new McElieceKeyGenParameterSpec();

    try {
        keygen.initialize(bcSpec, new SecureRandom());
    } catch (InvalidAlgorithmParameterException e) {
        System.out.println(""Error: Initialize failed. "" + e.getMessage());
    }

    PublicKey pub = keygen.generateKeyPair().getPublic();

    //BCMcEliecePublicKey pubMcEliece = (BCMcEliecePublicKey) pub;
    //McEliecePublicKeyParameters keyParameters = new McEliecePublicKeyParameters(pubMcEliece.getN(), pubMcEliece.getT(), pubMcEliece.getG());

    //serialization
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(pub); //keyParameters
        System.out.println(""OK"");
    } catch (IOException e) {
        System.out.println(e);
    }
</code></pre>

<p>What do I have to change to serialize the key?</p>
",<java><serialization><bouncycastle><post-quantum-cryptography>,05/10/2019 18:10,56082972.0,56082972.0,"<p>Simple answer: you probably can't.</p>

<p>That exception tells you that the class of the corresponding does <strong>not</strong> implement java.io.Serializable. </p>

<p>And when you dig into the source code, you will find: yes, exactly. Neither that class, nor any of its parent classes does implement that interface. </p>

<p>Like here, the base class: <a href=""https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/pqc/crypto/mceliece/McElieceParameters.java"" rel=""nofollow noreferrer"">McElieceParameters</a> (and no, that interface CypherParameters doesn't implement Serializable either).</p>

<p>Guessing here: the bouncy castle do not <em>want</em> you to use the default serialization for such objects!</p>

<p>And then: please understand that ""old school"" java binary object serialization is something that few people would recommend using these days anyway. Nowadays, you rather look towards compiling your configuration data into some ""bean"" like structures, to write/read them as JSON text.</p>

<p>Finally, if you really want to, there are dirty hacks, see <a href=""https://stackoverflow.com/questions/6163872/how-to-serialize-a-non-serializable-in-java"">here</a> for example. But again: I would advise to <em>not</em> spend your time with that. There are much better ways to persist your data these days, compared to java style object serialization!</p>
",05/10/2019 18:21,Errors,The question is about a specific error message (NotSerializableException) encountered while trying to serialize a McEliece public key in Java using the Bouncy Castle library. ,Errors,,,,Errors,
56091445.0,Jupyter notebook can't find Q# (Qsharp),"<p>I am following the directions on the <a href=""https://learn.microsoft.com/en-us/quantum/install-guide/jupyter?view=qsharp-preview"" rel=""nofollow noreferrer"">MS Qsharp page</a>. I have IQsharp installed:</p>

<pre><code>$ which dotnet
/usr/local/share/dotnet/dotnet
$ dotnet iqsharp --version
Language kernel: 0.6.1905.301
Jupyter core: 1.1.13141.0
</code></pre>

<p>and Jupyter installed:</p>

<pre><code>$ which jupyter
/Library/Frameworks/Python.framework/Versions/3.7/bin/jupyter
</code></pre>

<p>but when I launch <code>jupyter notebook</code> I don't see the option to start a Q# kernel (only Python 3). I've also tried by launching Jupyter out of an Anaconda environment.</p>

<p>My suspicion is I need to change the Jupyter configuration somehow to add the IQ kernel to its <code>--paths</code>, but I'm not sure how to do that (or if that is even the right thing to do). Any suggestions?</p>

<p>Thanks!</p>
",<.net><jupyter-notebook><q#>,05/11/2019 14:53,56094398.0,56094398.0,"<p>It looks like you may have IQ# installed correctly, but not yet registered with Jupyter as a kernel. One way to check is to run <code>jupyter kernelspec list</code>, which will show a list of all kernels that Jupyter is aware of. For instance, on my machine, I get a list similar to the following (yours may look a bit different, that's entirely OK):</p>

<pre><code>Available kernels:
  python3    C:\Users\&lt;username&gt;\Miniconda3\envs\qsharp\share\jupyter\kernels\python3
  iqsharp    C:\ProgramData\jupyter\kernels\iqsharp
</code></pre>

<p>If you don't see <code>iqsharp</code> listed, it should work to run <code>dotnet iqsharp install</code> for a global installation or <code>dotnet iqsharp install --user</code> for a user-specific installation.</p>
",05/11/2019 21:27, Tooling ,"The user is encountering an issue related to setting up and configuring Jupyter Notebook to work with IQ# (Q# Jupyter kernel), which falls under the category of tooling and software usage in quantum programming",Tooling,,,, Tooling ,
56260518.0,Creating X509 certificate in C using post-quantum public key algorithm?,"<p>I'm trying to implement a self signed x509 certificate that uses a post-quantum (PQ) public key algorithm as the public key algorithm. I looked at the openssl library in c, and the way it's done using RSA. I'm essentially trying to replicate the same format. From what I've seen in the openssl library, RSA and a couple of other supported algorithms are integrated in the crypto EVP layer (the key is stored as EVP_PKEY). The functions in the openssl library that I'm trying to use are X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey), and some other functions that have very similar inputs. Is there a way that I can integrate the PQ algorithm into the EVP layer? If not, is there any way around using the EVP layer that would achieve the same goal?</p>

<p>I have tried looking into the evp source code in the openssl library. It seems it only supports certain algorithms such as RSA, EC... I'm not sure if it's possible to incorporate the PQ algorithm into the EVP layer. I'm following along the example in this link: (<a href=""https://www.codepool.biz/how-to-use-openssl-to-generate-x-509-certificate-request.html"" rel=""nofollow noreferrer"">https://www.codepool.biz/how-to-use-openssl-to-generate-x-509-certificate-request.html</a>) to generate the certificate. Instead of RSA key, I just plug in the PQ algorithm key. So far when I create my certificate, it's always outputted in the wrong format. </p>

<p>I'm using this command: <code>openssl x509 -in x509Req.pem -text -noout</code> to read the certificate generate. It always shows the error message</p>

<pre><code>unable to load certificate \n 140688586052032:error:0906D06C:PEM routines:
PEM_read_bio:no start line:../crypto/pem/pem_lib.c:691:Expecting: TRUSTED CERTIFICATE
</code></pre>
",<c><openssl><x509><pki><post-quantum-cryptography>,5/22/2019 15:41,56265061.0,56265061.0,"<p>The <a href=""https://www.openssl.org/docs/man1.1.1/man7/evp.html"" rel=""nofollow noreferrer"">EVP</a> API uses a ""ENGINE"" for it's implementation of all the symmetric algorithms (ciphers), digests and asymmetric algorithms (public key algorithms). A ENGINE module can be added / replaced.  See openssl <a href=""https://www.openssl.org/docs/man1.1.1/man1/engine.html"" rel=""nofollow noreferrer"">engine</a> command.</p>

<p>I think this is the area you want to look into.  I don't think there is a lot of documentation around this area (that I could find) but there are sample engines you can look into.</p>

<p>If you download the <a href=""https://www.openssl.org/source/"" rel=""nofollow noreferrer"">openssl source</a> you can look in the engines folder for sample engines you can use to start to implement you custom algorithm(s).</p>

<p>Good luck!</p>
",5/22/2019 21:09,Tooling,"The user is seeking assistance with integrating a post-quantum (PQ) public key algorithm into the OpenSSL EVP layer and is encountering issues with the certificate format. This question falls under the category of tooling and software usage in quantum programming, specifically related to certificate generation and integration of PQ algorithms into existing libraries",Tooling,,,,Tooling,
56472783.0,Is current information about readout-errors of qubits on IBM quantum devices available on some internet page?,"<p>I've used to check the readout errors on subpage of <a href=""https://quantumexperience.ng.bluemix.net"" rel=""nofollow noreferrer"">https://quantumexperience.ng.bluemix.net</a>, but with the new IBM Q Experience version it's no longer possible, as new composer page doesn't have this information. </p>

<p>I'm perfectly aware that there are scripts and tools that allows me to check it with qiskit and python (the answer is here at the time of writing <a href=""https://quantumexperience.ng.bluemix.net/qx/community/question?questionId=5cefd62c4aa56a00721856ae"" rel=""nofollow noreferrer"">https://quantumexperience.ng.bluemix.net/qx/community/question?questionId=5cefd62c4aa56a00721856ae</a>), but I'm interested in checking the errors via browser. I've searched through IBM QX new version but couldn't find it, though I've seen gates errors when looking up on ""Your backends"" panel.</p>

<p>What I'd ideally want is a one internet page displaying all readout errors of all qubits for all available devices. Information about single and multi-gate errors would also be appreciated.</p>
",<qiskit>,06/06/2019 07:29,56479782.0,56479782.0,"<p><strong>EDIT: To better answer the user's question, as far as I know, there is no page that can be accessed through a web browser that contains the readout-errors for each individual qubit for each device that is the most updated information.</strong></p>

<p>This question may be better suited to be in either the <a href=""https://quantumexperience.ng.bluemix.net/qx/community"" rel=""nofollow noreferrer"">IBM Q Community Forums</a>, or possibly the <a href=""https://quantumcomputing.stackexchange.com/"">Quantum Computing Stack Exchange</a>, but I will provide what answers I can.</p>

<p>On the main page of the new IBM Q Experience you should have a list of backend devices available to you on the right hand side of the window. If you click on on of these devices, it will open another window with a graphic that displays the Single-qubit error rate for each qubit, and the CNOT error rate for each connection. </p>

<p>To see the specific readout errors in a browser, you would have to go to this <a href=""https://www.research.ibm.com/ibm-q/technology/devices/"" rel=""nofollow noreferrer"">device page</a>. However, it will only show you the average readout error across all qubits.</p>

<p>EDIT: To better answer the user's question, as far as I know, there is no page that can be accessed through a web browser that contains the readout-errors for each individual qubit for each device that is the most updated information. </p>
",06/06/2019 14:33,Tooling," The user is inquiring about accessing readout errors on IBM Q Experience's new version and is interested in a web-based solution to check readout errors for all available devices, which falls under the category of tools and software usage in quantum programming.",Tooling,,,,Tooling,
56846939.0,"Why am I getting ""TypeError"" for Device function in pennylane?","<p>I am doing basic coding for rotation of qubit as given in the Xanadu Pennylane tutorial. I have installed pennylane and tried running the code but I am getting TypeError.</p>

<p>I also tried with </p>

<pre><code>dir(qml)
</code></pre>

<p>This gave me a list of built-in functions in qml where Device is already present.</p>

<p>Here goes the actual code:</p>

<pre><code>from pennylane import numpy as np
import pennylane as qml

dev1 = qml.Device('default.qubit', wires=1)
</code></pre>

<p>All I am getting is the TypeError.</p>

<blockquote>
  <p>TypeError: Can't instantiate abstract class Device with abstract
  methods apply, author, expval, name, observables, operations,
  pennylane_requires, reset, short_name, version</p>
</blockquote>
",<python-3.x><jupyter-notebook><quantum-computing>,07/02/2019 06:57,56861776.0,56861776.0,"<p>I have not tried running this code myself, but looking at the qubit rotation <a href=""https://pennylane.readthedocs.io/en/latest/tutorials/qubit_rotation.html"" rel=""nofollow noreferrer"">tutorial</a> and <a href=""https://github.com/XanaduAI/pennylane/blob/master/examples/Q1_qubit-rotation.py"" rel=""nofollow noreferrer"">example</a>, both of them use </p>

<pre><code>dev1 = qml.device('default.qubit', wires=1)
</code></pre>

<p>(with <code>device</code> starting with lowercase <code>d</code>)</p>
",07/03/2019 01:26,Errors ,"The user is encountering a TypeError while trying to instantiate a Device in PennyLane, a quantum machine learning library, and is seeking help to resolve this issue.",Errors,,,,Errors ,
56876281.0,Building and modifying Q# Libraries,"<p>How can the libraries (<a href=""https://github.com/microsoft/QuantumLibraries"" rel=""nofollow noreferrer"">https://github.com/microsoft/QuantumLibraries</a>) be modified locally? For example, creating references to the Quantum Chemistry library only uses the prebuilt DLL. Is there a way to reference the local Quantum Chem library, make edits to that code, and see those changes reflected? Thanks. </p>
",<q#>,07/03/2019 18:45,56876865.0,56876865.0,"<p>The Quantum Development Kit uses the .NET Core SDK to find and link together the various Q# libraries, in particular through C# project files (<code>*.csproj</code>).
Within a C# project file, you can declare a dependency to another library using either a <em>package reference</em> or a <em>project reference</em>.
Package references (e.g.: <code>&lt;PackageReference Include=""Microsoft.Quantum.Standard"" Version=""0.7.1905.3109"" /&gt;</code>) instruct the .NET Core SDK to download a package from NuGet.org with a given name and version and then link to all DLLs contained in the project.
By contrast, project references (e.g.: <code>&lt;ProjectReference Include=""..\..\..\Standard\src\Standard.csproj"" /&gt;</code>) instruct the .NET Core SDK to first build the referenced project, then link to its DLL.</p>

<p>To use the libraries built from <a href=""https://github.com/microsoft/QuantumLibraries"" rel=""nofollow noreferrer"">https://github.com/microsoft/QuantumLibraries</a>, we generally recommend using package references, as project references across different repositories can be difficult to manage â you need for the path to a project file to be predictable, which can be hard to do in that case.
This is why we've taken the strategy with the QuantumLibraries repo that references within the repo are project references, while references to other parts of the Quantum Development Kit are package references.
For example, the chemistry library runtime uses a <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Chemistry/src/Runtime/Runtime.csproj"" rel=""nofollow noreferrer"">project reference</a> to link to the version of the standard libraries in the same repo, but samples in <a href=""https://github.com/microsoft/Quantum"" rel=""nofollow noreferrer"">https://github.com/microsoft/Quantum</a> <a href=""https://github.com/microsoft/Quantum/blob/master/samples/chemistry/RunSimulation/2-RunSimulation.csproj#L12"" rel=""nofollow noreferrer"">use package references</a>:</p>

<pre><code>&lt;Project Sdk=""Microsoft.NET.Sdk""&gt;
    &lt;PropertyGroup&gt;
        &lt;OutputType&gt;Exe&lt;/OutputType&gt;
        &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
        &lt;PlatformTarget&gt;x64&lt;/PlatformTarget&gt;
    &lt;/PropertyGroup&gt;
    &lt;ItemGroup&gt;
        &lt;PackageReference Include=""Microsoft.Extensions.Logging"" Version=""2.1.1"" /&gt;
        &lt;PackageReference Include=""Microsoft.Extensions.Logging.Console"" Version=""2.1.1"" /&gt;
        &lt;PackageReference Include=""Microsoft.Extensions.Logging.Debug"" Version=""2.1.1"" /&gt;
        &lt;PackageReference Include=""Microsoft.Quantum.Standard"" Version=""0.7.1905.3109"" /&gt;
        &lt;PackageReference Include=""Microsoft.Quantum.Chemistry"" Version=""0.7.1905.3109"" /&gt;
        &lt;PackageReference Include=""Microsoft.Quantum.Development.Kit"" Version=""0.7.1905.3109"" /&gt;
        &lt;PackageReference Include=""Microsoft.Quantum.Research"" Version=""0.7.1905.3109"" /&gt;
    &lt;/ItemGroup&gt;

    &lt;ItemGroup&gt;
        &lt;Compile Update=""Program.cs""&gt;
            &lt;CopyToOutputDirectory&gt;Never&lt;/CopyToOutputDirectory&gt;
        &lt;/Compile&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>

<p>That said, if you're locally testing a contribution you'd like to make to the Quantum Development Kit, linking to the Q# standard and chemistry libraries using project references can sometimes be helpful until a new package including your contribution is built and published to NuGet.org.</p>
",07/03/2019 19:33,Tooling ,"The user is asking about how to modify the Microsoft Quantum Libraries locally and see those changes reflected, which falls under the category of tooling and software usage in quantum programming.",Tooling,,,,Tooling ,
56877863.0,Access Call Graph of Simulator or Trace Simulator,"<p>Is there a way to access the call graph of the simulator / trace simulator? It would be nice to be able to pull a complete list of the gates applied to each qubit, in order. </p>
",<q#>,07/03/2019 21:01,57062233.0,57062233.0,"<p>There's no specific API for this, but it should be straightforward to add hooks to the simulator. Source code is now available at <a href=""https://github.com/microsoft/qsharp-runtime"" rel=""nofollow noreferrer"">https://github.com/microsoft/qsharp-runtime</a>. </p>

<p>There are two approaches you could take:</p>

<ul>
<li>Modify the operation implementations to log the gate and qubit ID each time they get called.</li>
<li>Add a handler for the <code>onOperationStart</code> event in <code>SimulatorBase</code> that looks for the gates your interested in and logs the gate and qubit ID.</li>
</ul>

<p>The first is probably more tedious, but simpler. If you use the second approach, the <code>ICallable.Name</code> property will be helpful.</p>
",7/16/2019 17:02,Tooling,"The user is inquiring about accessing the call graph of a quantum simulator, specifically the trace simulator, to obtain a list of gates applied to each qubit in order. This question pertains to tooling and software usage in quantum programming, specifically related to simulator capabilities and data retrieval.",Tooling,,,,Tooling,
56902633.0,Questions regarding the dimension initialization of multiple numpy arrays within a single numpy array,"<p>Given that we have 3 <a href=""https://en.wikipedia.org/wiki/Pauli_matrices"" rel=""nofollow noreferrer"">Pauli matrices</a>, each with dimension (2x2). As shown below:</p>

<pre><code>X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)
</code></pre>

<p>Now if I put these each individual (2x2) matrices as entries to another (2x2) matrices. Say:</p>

<pre><code>A = np.array([[X, 0], [0, Y]])
B = np.array([[X, X], [Y, Y]])
</code></pre>

<p>Weirdly, A has a dim of (2x2) - which is ideally what I want - and B has a dim of (2, 2, 2, 2)whatever this is, as show below</p>

<pre><code>A = np.array([[X, 0], [0, Y]])

A.shape
Out[131]: (2, 2)

B = np.array([[X, X], [Y, Y]])

B.shape
Out[133]: (2, 2, 2, 2)
</code></pre>

<p>On the other hand, say let <code>C</code> be a <code>(1x3)</code> matrix and <code>D</code> be a <code>(1x2)</code> matrix, e.g.</p>

<pre><code>C = np.array([[X, Y, 0]])
D = np.array([[X, Y]])
</code></pre>

<p>again if we look at the dimensions of the initialized matrices</p>

<pre><code>C = np.array([[X, Y, 0]])

C.shape
Out[136]: (1, 3)

D = np.array([[X, Y]])

D.shape
Out[138]: (1, 2, 2, 2)
</code></pre>

<p>So it seems that whenever I initialize arrays in an array like these, if there's mixed data type as entries i.e. matrices and integers like in <code>A</code>and<code>C</code>, it gives me the sensible shape that I want i.e. dimension<code>(2,2)</code>, with ""hidden"" dimensions of <code>(2x2)</code> for each entries. But as soon as the entries are just strictly matrices like in <code>B</code>and<code>D</code>, it gives me insensible dimension such as <code>(2, 2, 2, 2)</code>. So my question is:</p>

<p><strong>How do I initialize an <code>(n, n)</code> numpy array(matrix) with strictly <code>(2, 2)</code> matrices as entries, and still preserve its <code>(n, n)</code> dimensionality i.e. instead of giving me some weird numpy dimension <code>(w, x, y, z)</code>?</strong></p>

<p>The reason why I want this is because I'm doing computations with operators in quantum mechanics, with these Pauli matrices, such as the <code>X</code>, <code>Y</code> and <code>Z</code>, as quantum gates in quantum computation. So if I have some state <code>rho</code> which is also a <code>(2x2)</code> matrix. Let</p>

<pre><code>rho = np.array([[1, 0],
                [0, 0]])
</code></pre>

<p>And let <code>RHO</code> be the <code>(2x2)</code> diagonal matrix who's entries are the <code>(2x2) rho</code> matrices.</p>

<pre><code>RHO = np.array([[rho, 0],
                [0, rho]])
</code></pre>

<p>I wish to compute something like <code>np.dot(D, RHO)</code> such that it gives</p>

<pre><code>np.array([np.dot(X, rho), 0],
         [0, np.dot(Y, rho)])
</code></pre>

<p>And I've checked on python that the dot products of two (2x2) matrices with (2x2) matrices as entries, its entries multiplications will all be dot product too.</p>

<p>My motivation for all of the stuff I've talked about above is that I'm hoping to use these properties as means to vectorize my algorithm. Currently a very crude example of my algorithm looks something like this:</p>

<pre><code>for i in (integer_1):
    for j in (integer_2):
        #do something that involves operations with sums of dot products of many matrices#
</code></pre>

<p>and vectorize it so that it could potentially become</p>

<pre><code>for i in (integer_1):
        #do something that involves operations with multiples of matrices with dot product of matrices as its entries#
</code></pre>

<p>Which might potentially work, or not! But I'm curious to see if this method of mine will produce a speed up.
I hope I've explained my problems well.
Thanks in advance.</p>

<p><strong>Edit(1)</strong></p>

<p><a href=""https://i.stack.imgur.com/6x1lc.png"" rel=""nofollow noreferrer"">I've added latex formatted maths so hopefully you can understand what I'm trying to do.</a></p>

<pre class=""lang-py prettyprint-override""><code>def compute_channel_operation(rho, operators):
    """"""
    Given a quantum state's density function rho, the effect of the
    channel on this state is:
    rho -&gt; sum_{i=1}^n E_i * rho * E_i^dagger
    Args:
        rho (2x2 matrix): Density function
        operators (list): List of operators(matrices)
    Returns:
        number: The result of applying the list of operators
    """"""
    operation = [E@rho@E.conj().T for i, E in enumerate(operators)]
    return np.sum(operation, axis=0)
</code></pre>

<p><a href=""https://i.stack.imgur.com/gK6Vj.png"" rel=""nofollow noreferrer"">So then I was hoping that instead of using loops, this direct multiplication of tensor method might be quicker as I scale up my simulation, say having to do this 1 million times</a>
The thing is K here should be a list of any (1xn) dimensions i.e. [I] or [I, X] or [I, X, Y] or [I, X, Y, Z]. I understand that here X = X^{\dagger} and so will Y and Z, but I'll have situations in my simulation where that wont be the case.</p>

<p>I hope I've now explained it clearly.</p>
",<python><python-3.x><numpy><numpy-ndarray><quantum-computing>,07/05/2019 11:57,56902975.0,56902975.0,"<p><code>(2, 2, 2, 2)</code> is not a <em>weird dimension</em>, it is just a 4D tensor of shape 2x2x2x2</p>

<p>The reason why you are seing different shapes for <code>A</code> and <code>B</code> is because you are setting <code>A</code> with a scalar <code>0</code> instead of a 2x2 zero matrix. Change it to</p>

<pre><code>A = np.array([[X, np.zeros((2, 2))], [np.zeros((2, 2)), Y]])
B = np.array([[X, X], [Y, Y]])
</code></pre>

<p>And you will get 2x2x2x2 tensors for both.</p>

<p>Or change it to</p>

<pre><code>C = np.vstack([
    np.hstack([X, np.zeros((2, 2))]),
    np.hstack([np.zeros((2, 2)), Y])
])
D = np.vstack([
    np.hstack([X, X]),
    np.hstack([Y, Y])
])
</code></pre>

<p>And you will get 4x4 matrices.</p>

<p>You can also transform from one form to the other using</p>

<pre><code>E = A.transpose(0, 2, 1, 3).reshape(4, 4)
F = B.transpose(0, 2, 1, 3).reshape(4, 4)

np.allclose(C, E)  # True
np.allclose(D, F)  # True
</code></pre>

<p>and back</p>

<pre><code>G = E.reshape(2, 2, 2, 2).transpose(0, 2, 1, 3)
H = F.reshape(2, 2, 2, 2).transpose(0, 2, 1, 3)

np.allclose(A, G)  # True
np.allclose(B, H)  # True
</code></pre>

<p><strong>EDIT:</strong> Regarding your function <code>compute_channel_operation()</code>, you can speed it up considerably if you don't perform a list comprehension but vectorize the operation and pass in a 3D tensor with all your operations</p>

<pre><code>rho = np.random.rand(2, 2)
operators = [np.random.rand(2, 2) for _ in range(1000)]
operators_tensor = np.asarray(operators)  # same as np.random.rand(1000, 2, 2)

def compute_channel_operation(rho, operators):
    operation = [E@rho@E.conj().T for i, E in enumerate(operators)]
    return np.sum(operation, axis=0)

def compute_channel_operation2(rho, operators):
    return np.sum(operators @ rho @ operators.transpose(0, 2, 1).conj(), axis=0)

A = compute_channel_operation(rho, operators)
B = compute_channel_operation(rho, operators_tensor)
C = compute_channel_operation2(rho, operators_tensor)

np.allclose(A, B) # True
np.allclose(A, C) # True

%timeit compute_channel_operation(rho, operators)
# 6.95 ms Â± 103 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
%timeit compute_channel_operation(rho, operators_tensor)
# 7.53 ms Â± 141 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
%timeit compute_channel_operation2(rho, operators_tensor)
# 416 Âµs Â± 12 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
",07/05/2019 12:22,Tooling ,The user is trying to understand how to structure numpy arrays of matrices for quantum computations. This involves the use of specific software tools (numpy) in the context of quantum programming. ,Tooling,,,,Tooling ,
56944026.0,qiskit example in Q Experience User Guide doesn't show plot,"<p>The <a href=""https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/002-The_Weird_and_Wonderful_World_of_the_Qubit/005-The_Bloch_Sphere.html"" rel=""nofollow noreferrer"">Bloch sphere example</a> in the IBM Q Experience user guide should display a plot at the end. When I run the example it does not display the plot.</p>

<p>I can draw circuits and other plots inline (in jupyter), but plotting in this one doesn't work for me.</p>

<p>The code (copied exactly from the example page) is shown below.</p>

<p>My environment is:</p>

<blockquote>
  <p>Fedora Core 30<br>
  Qiskit 0.8.2<br>
  Matplotlib 3.1.0<br>
  Python 3.7.3<br>
  Conda 4.6.11 (conda-build version: 3.17.8)<br>
  jupyter core     : 4.5.0<br>
  jupyter-notebook : 5.7.8<br>
  qtconsole        : not installed<br>
  ipython          : 7.5.0<br>
  ipykernel        : 5.1.1<br>
  jupyter client   : 5.2.4<br>
  jupyter lab      : not installed<br>
  nbconvert        : 5.5.0<br>
  ipywidgets       : 7.4.2<br>
  nbformat         : 4.4.0<br>
  traitlets        : 4.3.2<br></p>
</blockquote>

<pre><code># quantum_phase_bloch.py
import numpy as np

from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer
from qiskit.tools.visualization import plot_bloch_vector

# Define the Quantum and Classical Registers
q = QuantumRegister(1)
c = ClassicalRegister(1)

# Build the circuits
pre = QuantumCircuit(q, c)
pre.h(q)
pre.barrier()

meas_x = QuantumCircuit(q, c)
meas_x.barrier()
meas_x.h(q)
meas_x.measure(q, c)

meas_y = QuantumCircuit(q, c)
meas_y.barrier()
meas_y.s(q).inverse()
meas_y.h(q)
meas_y.measure(q, c)

meas_z = QuantumCircuit(q, c)
meas_z.barrier()
meas_z.measure(q, c)

bloch_vector = ['x', 'y', 'z']
exp_vector = range(0, 21)
circuits = []
for exp_index in exp_vector:
    middle = QuantumCircuit(q, c)
    phase = 2*np.pi*exp_index/(len(exp_vector)-1)
    middle.u1(phase, q)
    circuits.append(pre + middle + meas_x)
    circuits.append(pre + middle + meas_y)
    circuits.append(pre + middle + meas_z)

# Execute the circuit
job = execute(circuits, backend = Aer.get_backend('qasm_simulator'), shots=1024)
result = job.result()

# Plot the result
for exp_index in exp_vector:
    bloch = [0, 0, 0]
    for bloch_index in range(len(bloch_vector)):
        data = result.get_counts(circuits[3*exp_index+bloch_index])
        try:
            p0 = data['0']/1024.0
        except KeyError:
            p0 = 0
        try:
            p1 = data['1']/1024.0
        except KeyError:
            p1 = 0
        bloch[bloch_index] = p0-p1
    plot_bloch_vector(bloch)
</code></pre>
",<python><matplotlib><jupyter-notebook><qiskit>,07/09/2019 00:37,56945623.0,56945623.0,"<p>The last link provided by <a href=""https://stackoverflow.com/users/4124317/importanceofbeingernest"">ImportanceOfBeingErnest</a> shows a function that solves the problem (it may not be the best approach, but it helped me out so I have posted the revised code here for others).</p>

<p>The revised code is:</p>

<pre><code># quantum_phase_bloch.py
%matplotlib inline
import matplotlib.pyplot as plt

def show_figure(fig):
    # See https://github.com/Qiskit/qiskit-terra/issues/1682
    new_fig = plt.figure()
    new_mngr = new_fig.canvas.manager
    new_mngr.canvas.figure = fig
    fig.set_canvas(new_mngr.canvas)
    plt.show(fig)

import numpy as np

from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer
from qiskit.tools.visualization import plot_bloch_vector

# Define the Quantum and Classical Registers
q = QuantumRegister(1)
c = ClassicalRegister(1)

# Build the circuits
pre = QuantumCircuit(q, c)
pre.h(q)
pre.barrier()

meas_x = QuantumCircuit(q, c)
meas_x.barrier()
meas_x.h(q)
meas_x.measure(q, c)

meas_y = QuantumCircuit(q, c)
meas_y.barrier()
meas_y.s(q).inverse()
meas_y.h(q)
meas_y.measure(q, c)

meas_z = QuantumCircuit(q, c)
meas_z.barrier()
meas_z.measure(q, c)

bloch_vector = ['x', 'y', 'z']
exp_vector = range(0, 21)
circuits = []
for exp_index in exp_vector:
    middle = QuantumCircuit(q, c)
    phase = 2*np.pi*exp_index/(len(exp_vector)-1)
    middle.u1(phase, q)
    circuits.append(pre + middle + meas_x)
    circuits.append(pre + middle + meas_y)
    circuits.append(pre + middle + meas_z)

# Execute the circuit
job = execute(circuits, backend = Aer.get_backend('qasm_simulator'), shots=1024)
result = job.result()

# Plot the result
for exp_index in exp_vector:
    bloch = [0, 0, 0]
    phase = 2*np.pi*exp_index/(len(exp_vector)-1)
    phase_deg = phase / (2.0*np.pi) * 360.0
    for bloch_index in range(len(bloch_vector)):
        data = result.get_counts(circuits[3*exp_index+bloch_index])
        try:
            p0 = data['0']/1024.0
        except KeyError:
            p0 = 0
        try:
            p1 = data['1']/1024.0
        except KeyError:
            p1 = 0
        bloch[bloch_index] = p0-p1
    show_figure(plot_bloch_vector(bloch, title='Bloch sphere with phase {:.1f} degrees'.format(phase_deg)))
</code></pre>
",07/09/2019 05:01,Tooling,"The user question pertains to an issue with the execution of a quantum program using Qiskit and the associated visualization of Bloch vectors, which falls under the tooling aspect of quantum programming. They are encountering a specific problem related to the Qiskit environment and software tools.",Tooling,,,,Tooling,
57198794.0,How to install Qiskit with only Jupyter Notebook?,"<p>I want to use Jupyter Notebook without installing Anaconda on Ubuntu 18.04. I do not want to use any virtual environment. What can I do to install Qiskit?</p>

<p>I have tried to install Qiskit with pip3. </p>

<pre><code>pip3 install qiskit
</code></pre>

<p>This shows the following message </p>

<blockquote>
  <p>Segmentation fault (core dumped)</p>
</blockquote>

<p>But if I try to import qiskit from terminal with this shows no error. But when I try to import qiskit from Jupyter Notebook it says that </p>

<blockquote>
  <p>there is not module named qiskit</p>
</blockquote>

<p>Any suggestion to solve this problem? </p>
",<python><jupyter-notebook><qiskit>,7/25/2019 9:35,57199513.0,57199513.0,"<p>You have different python installations. Install qiskit in the python installation pointed by jupyter. Use below from jupyter notebook</p>

<pre><code>!pip3 install qiskit
</code></pre>
",7/25/2019 10:12,Errors,"The user is encountering issues with installing and using Qiskit in Jupyter Notebook on Ubuntu 18.04, specifically related to import errors and a segmentation fault during installation. They are seeking a solution to this problem, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors,
57384986.0,Implementation of Fermionic SWAP in Q#?,"<p>Is fermionic swap (as described in <a href=""https://arxiv.org/pdf/1706.00023.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1706.00023.pdf</a>) implemented in the Q# chemistry library?</p>

<p>If not, would this be a good contribution to the library?</p>
",<q#>,08/06/2019 22:56,57398015.0,57398015.0,"<p>We don't have a fermionic SWAP implementation in the Q# libraries at the moment, no, but that would be very reasonable <a href=""https://learn.microsoft.com/quantum/contributing/"" rel=""nofollow noreferrer"">contribution to the standard library</a>; we'd really appreciate it!</p>
",08/07/2019 15:41,Tooling,The question is about the implementation of a specific function (Fermionic SWAP) in a quantum programming library (Q# chemistry library).,Tooling,,,,Tooling,
57536837.0,What does the function state_fidelity() do in Qiskit?,"<p>I am trying to solve a system of linear equation using HHL algorithm in Qiskit. I have a problem with understanding the purpose of the following function. </p>

<pre><code>state_fidelity()
</code></pre>

<p>To understand this I have followed their official <a href=""https://qiskit.org/documentation/terra/quantum_circuits.html"" rel=""nofollow noreferrer"">documentation</a>. But it is not clear to me yet. </p>

<p>They used this function like the following code.</p>

<pre><code>from qiskit.quantum_info state_fidelity, process_fidelity

backend_sim = BasicAer.get_backend('statevector_simulator')
result = execute(circ, backend_sim).result()
state = result.get_statevector(circ)
print(state)

state_fidelity(basis_state('0110', 4), state)
</code></pre>

<p>The last line of this code generates this output.</p>

<p><strong>1.0</strong></p>

<p>Please, help me understand this.</p>
",<quantum-computing><qiskit>,8/17/2019 13:44,57553269.0,57553269.0,"<p>State fidelity is the measure of how close two quantum states are to eachother (<a href=""https://en.wikipedia.org/wiki/Fidelity_of_quantum_states"" rel=""noreferrer"">wikipedia</a>). So what the last line of the code is trying to do is to see how close the resulting state is to the state <code>'0110'</code>. A fidelity of <code>1.0</code> means the states are exactly the same, so the variable named <code>state</code> in the code is a state vector that corresponds to the state <code>'0110'</code>. </p>

<p>The exact definitions can be seen from the wikipedia page, or the <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/quantum_info/states/measures.py"" rel=""noreferrer"">code for the function</a>.</p>
",8/19/2019 8:46,Theoretical ,"The user is seeking an explanation and understanding of the state_fidelity() function and its usage in the context of the HHL algorithm in Qiskit, which is related to the theoretical aspects of quantum computing and quantum algorithms.",Theoretical,,,,Theoretical ,
57819419.0,How to install and import Qiskit_aqua?,"<p>I want to run SVM algorithm using Qiskit. For this purpose I need to import some packages from <strong><em>qiskit_aqua.utils</em></strong>. I am writing my code on Google Colaboratory. But while trying to import this package it shows me the following error. </p>

<blockquote>
  <p>ModuleNotFoundError: No module named 'qiskit_aqua'</p>
</blockquote>

<p>I have tried to import every thing from Qiskit. But no changes have come. Here is my code. </p>

<pre><code>!pip install qiskit
from qiskit import * 
from qiskit_aqua.utils import split_dataset_to_data_and_labels
from qiskit_aqua.input import get_input_instance
from qiskit_aqua import run_algorithm
</code></pre>

<p>I even tried to import <strong><em>Aer</em></strong> using this command. But still it is of no use. </p>

<p>Help me finding the solution. </p>

<pre><code>!pip install qiskit
from qiskit import Aer
from qiskit_aqua.utils import split_dataset_to_data_and_labels
from qiskit_aqua.input import get_input_instance
from qiskit_aqua import run_algorithm
</code></pre>
",<python><qiskit>,09/06/2019 09:35,57819651.0,57819651.0,"<p>Aqua is a subpackage of Qiskit, so you need to use <code>.</code> instead of <code>_</code>. Your imports therefore should be</p>

<pre><code>from qiskit import Aer
from qiskit.aqua.utils import split_dataset_to_data_and_labels
from qiskit.aqua.input import get_input_instance
from qiskit.aqua import run_algorithm
</code></pre>
",09/06/2019 09:50,Errors," The user is encountering a ModuleNotFoundError when trying to import the qiskit_aqua module in Google Colaboratory, and is seeking help to resolve this issue. ",Errors,,,,Errors,
57824185.0,How to call EnergyInput() function in Qiskit python?,"<p>I want to implement SVM with Qiskit. I used this following code. </p>

<pre><code>from qiskit import Aer
from qiskit.aqua.utils import split_dataset_to_data_and_labels
from qiskit.aqua.input import get_input_instance     
from qiskit.aqua import run_algorithm

n = 2  # dimension of each data point
sample_Total, training_input, test_input, class_labels = Breast_cancer(training_size=40,
                                                              test_size=10, n=n, PLOT_DATA=True)

temp = [test_input[k] for k in test_input]
total_array = np.concatenate(temp)

aqua_dict = {
    'problem': {'name': 'svm_classification', 'random_seed': 100},
    'algorithm': {
        'name': 'QSVM.Kernel'
    },
    'feature_map': {'name': 'SecondOrderExpansion', 'depth': 2, 'entangler_map': {0: [1]}},
    'multiclass_extension': {'name': 'AllPairs'},
    'backend': {'name': 'qasm_simulator', 'shots': 256}
}

algo_input = get_input_instance('SVMInput')
algo_input.training_dataset = training_input
algo_input.test_dataset = test_input
algo_input.datapoints = total_array

result = run_algorithm(aqua_dict, algo_input)
for k,v in result.items():
    print(""'{}' : {}"".format(k, v))
</code></pre>

<p>But this code shows this error</p>

<blockquote>
  <p>ImportError: cannot import name 'get_input_instance'</p>
</blockquote>

<p>This is because this method is removed from Qiskit. I got this piece of information from <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/issues/552"" rel=""nofollow noreferrer"">this</a> github issue. They have suggested to use <strong>EnergyInput()</strong> instead of <strong>get_input_instance()</strong> in a similar way. So I modified the previous code in the following way. </p>

<pre><code>!pip install qiskit
from qiskit import Aer
from qiskit.aqua.utils import split_dataset_to_data_and_labels
from qiskit.aqua.input import EnergyInput
from qiskit.aqua import run_algorithm

algo_input = EnergyInput('SVMInput')
algo_input.training_dataset = training_input
algo_input.test_dataset = test_input
algo_input.datapoints = total_array
</code></pre>

<p>Now this code shows that EnergyInput cannot take anykind of <strong>String</strong> input. This generates the following error.</p>

<blockquote>
  <p>AttributeError: 'str' object has no attribute 'to_dict'</p>
</blockquote>

<p>I can show the whole error in this screenshot.  <a href=""https://i.stack.imgur.com/Oj8LO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Oj8LO.png"" alt=""Error Message""></a></p>
",<python><qiskit>,09/06/2019 14:45,57824464.0,57824464.0,"<p>Have a look at <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/aqua/artificial_intelligence/qsvm_classification.ipynb"" rel=""nofollow noreferrer"">this tutorial</a> about creating QSVMs. Instead of <code>EnergyInput()</code> they use a class called <code>ClassificationInput()</code> to which they pass their data. </p>

<p>This makes the overall expression: 
 <code>algo_input = ClassificationInput(training_input, test_input, datapoints[0])</code></p>
",09/06/2019 15:01,Errors ,"The user is encountering an ImportError when trying to import the get_input_instance function from qiskit_aqua.input, and an AttributeError when using the EnergyInput function as a replacement. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors ,
57832016.0,How to make a gate which generates |0> or |1> based on a parameter?,"<p>I would like to make a single-qubit gate which gives |0> or |1> with reference to a parameter. </p>

<p>For example, I set a parameter theta in range of 0 to 2Ï. When theta is in range of 0 to Ï, the gate returns |0> and when theta is in range of Ï to 2Ï, the gate returns |1>.</p>

<p>I am in the environment as follows:</p>

<ul>
<li>Qiskit: 0.12.0</li>
<li>Python 3.7.3 .</li>
</ul>
",<quantum-computing><qiskit>,09/07/2019 08:28,57833040.0,57833040.0,"<p>Quantum gates don't ""return"" a state, they transform a qubit state into another one. A singe-qubit quantum gate is represented as a 2x2 unitary matrix, and the way it transforms the qubit state is represented as matrix multiplication of this matrix and a vector of length 2 which represents the input state. So the closest to the thing you're trying to do is a gate which transforms an arbitrary input state to |0â© or to |1â© depending on the value of the parameter.</p>

<p>Quantum gates also have to be reversible, i.e. you need to be able to undo the transformation. The transformation you described makes it impossible, since multiple inputs are mapped to the same output, and you can not recover the input state from the result.</p>

<p>Non-reversible transformations are done not using gates but using measurements. If you need to collapse the input qubit to |0â© or |1â© depending on a parameter, you can measure it, and depending on the measurement result and the state you need, apply an X gate to the qubit. I.e., if the qubit was measured in the |0â© state and you need a |1â© (or vice versa), apply X gate, otherwise don't apply it.</p>
",09/07/2019 11:00,API Usage,"The user is seeking guidance on how to create a custom single-qubit gate in Qiskit, which involves using the Qiskit API to achieve this specific task.",Tooling,The question is about how to implement a specific function (a single-qubit gate with a parameter) in a quantum programming library (Qiskit). ,No,18.0, API Usage,"This is because the user is specifically asking about how to create a custom gate using Qiskit's API, indicating a desire to understand and utilize the library's features effectively for quantum programming."
57888370.0,Can I use lambda in Q# to operate on qubits?,"<p>I have a use case in Q# where I have qubit register <code>qs</code> and need to apply the <code>CNOT</code> gate on every qubit except the first one, using the first one as control. Using a <code>for</code> loop I can do it as follows:</p>

<pre><code>for (i in 1..Length(qs)-1) {
    CNOT(qs[0], qs[i]);
}
</code></pre>

<p>Now, I wanted to give it a more functional flavor and tried instead to do something like:</p>

<pre><code>ApplyToEach(q =&gt; CNOT(qs[0], q), qs[1..Length(qs)-1]);
</code></pre>

<p>The Q# compiler does not accept an expression like this, informing me that it encountered an unexpected code fragment. That's not too informative for my taste. Some documents claim that Q# supports anonymous functions a'la C#, hence the attempt above. Can anybody point me to a correct usage of lambdas in Q# or dispel my false belief?</p>
",<c#><anonymous-function><quantum-computing><q#>,09/11/2019 11:41,57892826.0,57892826.0,"<p>At the moment, Q# doesn't support lambda functions and operations (though that would be a great feature request to file at <a href=""https://github.com/microsoft/qsharp-compiler/issues/new/choose"" rel=""nofollow noreferrer"">https://github.com/microsoft/qsharp-compiler/issues/new/choose</a>). That said, you can get a lot of the functional flavor that you get from lambdas by using partial application. In your example, for instance, I could also write that for loop as:</p>

<pre><code> ApplyToEach(CNOT(Head(qs), _), Rest(qs));
</code></pre>

<p>Here, since <code>CNOT</code> has type <code>(Qubit, Qubit) =&gt; Unit is Adj + Ctl</code>, filling in one of the two inputs as <code>CNOT(Head(qs), _)</code> results in an operation of type <code>Qubit =&gt; Unit is Adj + Ctl</code>.</p>

<p>Partial application is a very powerful feature, and is used all throughout the Q# standard libraries to provide a functional way to build up quantum programs. If you're interested in learning more, I recommend checking out the docs at <a href=""https://learn.microsoft.com/quantum/language/expressions#callable-invocation-expressions"" rel=""nofollow noreferrer"">https://learn.microsoft.com/quantum/language/expressions#callable-invocation-expressions</a>.</p>
",09/11/2019 15:55,API Usage,The user is seeking guidance on how to use lambdas or anonymous functions in Q# to achieve a specific task related to quantum programming (applying CNOT gates to qubits). This falls under the category of API usage as it pertains to the usage of Q# language features.,API Usage,,,,API Usage,
57926048.0,How to profile a script which uses python's multiprocessing,"<p>I have a script file which uses the function parallel_map.
( <a href=""https://github.com/qutip/qutip/blob/master/qutip/parallel.py"" rel=""nofollow noreferrer"">source code of qutip.parallel.parallel_map</a>) from a package <a href=""http://qutip.org/"" rel=""nofollow noreferrer"">QuTiP</a> . As one would see on clicking the <a href=""https://github.com/qutip/qutip/blob/master/qutip/parallel.py"" rel=""nofollow noreferrer"">source code</a> for the function, it uses the multiprocess module of python. 
I looked at answers of <a href=""https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script/49173782#49173782"">serial version of this question</a>. I decided upon <a href=""https://jiffyclub.github.io/snakeviz/"" rel=""nofollow noreferrer"">Snakeviz</a> on reading <a href=""https://stackoverflow.com/a/37431235/7952027"">zaxiliu's solution</a>.
But naively trying it on my code fails. So what must I do to profile my code? My heart is not set on <a href=""https://jiffyclub.github.io/snakeviz/"" rel=""nofollow noreferrer"">Snakeviz</a>.  I don't mind using any other graphical tool.</p>
",<python><multiprocessing><profiling><qutip>,9/13/2019 15:01,57928110.0,57928110.0,"<p><em>Doesn't satisfy the question requirements fully, but will work if nothing else is available</em></p>

<p>Try using serial_map instead of parallel_map from the same <a href=""https://github.com/qutip/qutip/blob/master/qutip/parallel.py"" rel=""nofollow noreferrer"">module</a>. 
Replace (or better yet comment out) the line </p>

<blockquote>
  <p>from qutip.parallel import parallel_map</p>
</blockquote>

<p>with </p>

<blockquote>
  <p>from qutip.parallel import serial_map</p>
</blockquote>

<p>Now you have a serial implementation of code. This can be profiled using those described in <a href=""https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script/49173782#49173782"">serial version</a> of your question. 
After this (assuming you go ahead with <a href=""https://jiffyclub.github.io/snakeviz/"" rel=""nofollow noreferrer"">Snakeviz</a>) </p>

<ul>
<li><p>make the profile file </p>

<blockquote>
  <p>python -m cProfile -o program.prof my_program.py</p>
</blockquote></li>
<li><p>Run <a href=""https://jiffyclub.github.io/snakeviz/"" rel=""nofollow noreferrer"">Snakeviz</a> on the profile file generated in the previous step</p>

<blockquote>
  <p>snakeviz program.prof</p>
</blockquote></li>
</ul>
",9/13/2019 17:36,Tooling,"The user is seeking guidance on how to profile their Python code, specifically a script that uses the QuTiP package and the parallel_map function. They are looking for recommendations on profiling tools or methods and how to use them effectively, which falls under the category of tooling and software usage in Python programming.",Tooling,,,,Tooling,
58017525.0,Unexpected keyword argument 'noise_model',"<p>The following code throws an error. Based on some issues that I read on qiskit github, it seems that it has something do with run configs vs. compile configs but I could not find any other info that will help me resolve this issue.</p>

<pre class=""lang-py prettyprint-override""><code>from qiskit import QuantumCircuit, IBMQ, execute
from qiskit import BasicAer as Aer
from qiskit.providers.aer import noise


ckt = QuantumCircuit(2, 2)
ckt.h(0)
ckt.cx(0, 1)
ckt.measure(0, 0)
ckt.measure(1, 1)

qsim = Aer.get_backend(""qasm_simulator"")

IBMQ.load_account()
provider = IBMQ.get_provider(hub=""ibm-q"")
qc = provider.get_backend(""ibmqx2"")

props = qc.properties()
coupling_map = qc.configuration().coupling_map
noise_model = noise.device.basic_device_noise_model(props)

job = execute(
    ckt, 
    qsim, 
    noise_model=noise_model, 
    coupling_map=coupling_map, 
    basis_gates=noise_model.basis_gates
)
</code></pre>

<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-1-2f987d65d1f7&gt; in &lt;module&gt;
     25     noise_model=noise_model,
     26     coupling_map=coupling_map,
---&gt; 27     basis_gates=noise_model.basis_gates
     28 )

~/.venvs/qk/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, **run_config)
    220 
    221     # executing the circuits on the backend and returning the job
--&gt; 222     return backend.run(qobj, **run_config)

TypeError: run() got an unexpected keyword argument 'noise_model'
</code></pre>

<h3>Env:</h3>

<ul>
<li>macOS 10.14.6</li>
<li>Python 3.7.3</li>
<li>qiskit 0.12.0</li>
</ul>
",<python><quantum-computing><qiskit>,9/19/2019 19:04,58018154.0,58018154.0,"<p>The error is coming up because you are using BasicAer to retrieve the simulator backend. I do not think this will work with the BasicAer provider. You should be using the Aer provider.</p>

<pre><code>from qiskit import Aer
qsim = Aer.get_backend('qasm_simulator')
</code></pre>

<p>If you just change your import statement from </p>

<pre><code>from qiskit import BasicAer as Aer
</code></pre>

<p>to </p>

<pre><code>from qiskit import Aer
</code></pre>

<p>then your code should work</p>
",9/19/2019 19:55,Errors,"The user is encountering an error when trying to execute a quantum circuit in Qiskit that involves noise modeling. The error message suggests that the run() function does not recognize the noise_model keyword argument, and the user is seeking a solution to this error, making it fall under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors,
58054786.0,How to perform modeling of qubit observation in Qiskit,"<p>I was trying to write a program that performs various operation on qubits with qiskit, and one of such operations is to perform the following:</p>

<p>""Qubit observation is simulated, modeling the wave function collapse as follows:</p>

<pre><code> r &lt;= |a^2|, x = 0 (basisstate |0&gt;
 r &gt; |a^2|, x = 1 (basisstate |1&gt;
</code></pre>

<p>where r is a random number in the range [0,1), and a is the qubit that should be observed.""</p>

<p>I noticed that the measure() method in qiskit will collapse the quantum system - which is something that I want to prevent. How can I project quantum vector (or qubit) into binary vector in qiskit (without collapsing the quantum system)? Or is there a quantum programming SDK that allows me to do so? Thanks in advance.</p>

<p><strong>Update: 24/9/2019</strong>
Mariia Mykhailova, thank you for the info. That's exactly what I needed! 
For others, the Qiskit api has been updated, use result.data() instead of  result.get_data(circuit).</p>
",<python><quantum-computing><qiskit>,9/23/2019 1:52,58067753.0,58067753.0,"<p>If you are modeling a quantum computing system in accordance to the postulates of quantum mechanics, observing a qubit without collapsing the system state is impossible. This is one of the fundamental principles of quantum systems, and you can not work around it without sacrificing the realism of your model.</p>

<p>That being said, you can model such an observation by accessing the wavefunction directly and calculating the probabilities of the qubit collapsing to one or another basis state manually, without actually performing a measurement. It's just not something you'll be able to do on an actual quantum device!</p>

<p>I'm not closely familiar with the tools Qiskit has for accessing wavefunction, <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/issues/369"" rel=""nofollow noreferrer"">this link</a> seems to provide some starting points.</p>
",9/23/2019 17:54,Tooling,"The user is seeking information on how to profile their code using tools like Snakeviz or other graphical tools, which pertains to tools and software usage in quantum programming.",Tooling ,,,,Tooling,
58200757.0,Using methods from a type passed as a parameter in C#,"<p>I'm working in Q#, a quantum programming language based on C#. Quantum operations become C# classes, from which you can do things like </p>

<pre><code>QuantumOperation.run(simulator, param1, param2);
</code></pre>

<p>which will use a quantum simulator <code>simulator</code> to run the operation <code>QuantumOperation</code> with the parameters <code>param1</code> and <code>param2</code>.</p>

<p>I have many different operations which I want to run using different simulators and different parameters. What I would like to do is pass the quantum operation to another method, which will iterate through all the simulators and parameters. Then I can call this method with all the quantum operations I want. </p>

<p>The problem is that - as far as I can tell - a quantum operation is really a <em>class</em> and not an object. So, for example, if I write:</p>

<p><code>static void someMethod&lt;Qop&gt;(){...}</code></p>

<p>then I can call this with a quantum operation <code>QuantumOperation</code> as:</p>

<p><code>someMethod&lt;QuantumOperation&gt;()</code></p>

<p>and it compiles fine. However, if I try to do something like </p>

<pre><code>static void someMethod&lt;Qop&gt;(Qop quantumOperation){ ...}

someMethod&lt;QuantumOperation&gt;(quantumOperation);
</code></pre>

<p>I get an error of ""<code>QuantumOperation</code> is a type, which is not valid in the given context"" for the second line. </p>

<p>If I try:</p>

<pre><code>static void someMethod&lt;Qop&gt;(...){
    ...
    Qop.Run(...);
    ...
}
</code></pre>

<p>it similarly says: ""'Qop' is a type parameter, which is not valid in the given context"".</p>

<p>What seems to be happening here is that I'm passing the class as a type. But then when I want to treat the type as a class, I can't. I looked for ways to pass a class as an argument, but I only see ways to do this that will create objects in that class. But I can't use an object, since ""Run"" is a static method. </p>

<p>(I could try passing an object and getting the class from that, but (a) I don't know if it's possible to create objects of quantum operation classes, and (b) I can only find <code>public Type GetType</code>, which returns a type and not a class, giving the same problem).</p>

<p>Is there any way to pass a <em>class</em> as an argument, then reference static methods of that class, without ever instantiating an object?</p>

<p>Now, maybe I'm asking too much, since, as far as C# is concerned, it's a coincidence that all these classes have a method called ""Run"". It maybe <em>shouldn't</em> be able to attempt to call methods with the same name from different classes. </p>

<p>Alternatively, I could construct a method for each quantum operation and then pass those methods. The method would look like:</p>

<pre><code>static void QuantumOperationWrapper(QuantumSimulator simulator, Int int_parameter){
    QuantumOperation.Run(simulator, in_parameter);
}
</code></pre>

<p>I would need to make a new method for each quantum operation, but that's not that bad. Then I can pass this as a delegate or Func to the methods I want. The problem is that the results I want are contained in the <code>QuantumSimulator</code> object. So what I want to do is something like:</p>

<pre><code>QuantumOperationWrapper(simulator, 3);
simulator.GetResults();
</code></pre>

<p>But when I do this, the results are empty. My guess is that, somehow, the simulator is being passed by value, or treated as immutable, or something that prevents <code>QuantumOperationWrapper</code> from altering internal parameters of the simulator. </p>

<p>Is there any way to I can ensure that a delegate/Func will alter the internal state of its arguments?</p>

<p>EDIT: I can make a delegate for the <code>Run</code> method, as follows:</p>

<p><code>public delegate System.Threading.Tasks.Task&lt;Microsoft.Quantum.Simulation.Core.QVoid&gt; RunQop(QCTraceSimulator sim, long n);</code></p>

<p>Then I can construct <code>static void someMethod(RunQop runner, ...)</code>, and pass <code>QuantumOperation.Run</code> as the first argument. </p>

<p>However, I have the same problem, that the <code>QCTraceSimulator</code> I pass as an argument does not keep any of the simulation results it makes when I call this.</p>
",<c#><types><static-classes><quantum-computing><q#>,10/02/2019 11:39,58201492.0,58201492.0,"<p>So if I understand you correctly you want to execute a bunch of methods with parameters on different simulators. Here is how to do this:</p>

<p>We first off need a List of the operations we want to perform.</p>

<pre class=""lang-cs prettyprint-override""><code>var methodList = new List&lt;Func&lt;QCTraceSimulator, long, Task&lt;QVoid&gt;&gt;&gt;
{
    QuantumOperation.Run,
    // Add more methods here
}
</code></pre>

<p>This is a List of <a href=""https://www.tutorialsteacher.com/csharp/csharp-func-delegate"" rel=""nofollow noreferrer"">Func</a>s. A Func is a delegate type that represents a method with a parameter and a return value. Here our methods need to look like this to be able to be added to our List:</p>

<pre class=""lang-cs prettyprint-override""><code>public Task&lt;QVoid&gt; SomeName(QCTraceSimulator sim, long parameter)
{ ...}
</code></pre>

<p>We also need a list of parameters you want to try this with:</p>

<pre class=""lang-cs prettyprint-override""><code>var paramsList = new List&lt;long&gt;
{
    1,
    2,
   -2147483648,
    2147483647
};
</code></pre>

<p>Now we can iterate through these and run our method like so:</p>

<pre class=""lang-cs prettyprint-override""><code>public void RunMethodsOnSimulator(QCTraceSimulator sim)
{
    // Iterate through every method
    foreach (var method in methodList)
    {
        // Iterate through every parameter
        foreach (var parameter in paramsList)
        {
            // Execute the given method with the given parameter
            Task&lt;QVoid&gt; result = method(sim, parameter);
        }
    }
}
</code></pre>

<p>You can now do whatever you want with the <code>result</code>. This will result in every method being called with every parameter once</p>

<p>Please keep in mind that this answer only solves this problem for methods that return a <code>Task&lt;QVoid&gt;</code> and take a <code>QCTraceSimulator</code> and a <code>long</code> as parameter. This solution however avoids having to modify any <code>QuantumOperation</code> classes (and hopefully teaches you a little about delegates)</p>

<p>Here is what the <code>paramsList</code> and the <code>RunMethodsOnSimulator</code> method would like with 2 or more parameters:</p>

<pre class=""lang-cs prettyprint-override""><code>methodList = new List&lt;Func&lt;QCTraceSimulator, long, int, Task&lt;QVoid&gt;&gt;&gt;
{
    QuantumOperation.Run,
    // Add more methods here
}

paramsList = new List&lt;Tuple&lt;long, int&gt;&gt;
{
    new Tuple&lt;long, int&gt;(1, 1),
    new Tuple&lt;long, int&gt;(2, 1),
    new Tuple&lt;long, int&gt;(1, 2),
    new Tuple&lt;long, int&gt;(-2147483648, 1)
}

public void RunMethodsOnSimulator(QCTraceSimulator sim)
{
    // Iterate through every method
    foreach (var method in methodList)
    {
        // Iterate through every parameter
        foreach (var parameter in paramsList)
        {
            // Execute the given method with the given parameter
            Task&lt;QVoid&gt; result = method(sim, parameter.Item1, parameter.Item2);
        }
    }
}
</code></pre>
",10/02/2019 12:26,Tooling,The user is asking about how to use a specific feature of a programming language (C#) to solve a specific problem. This is a tooling question because it is asking about how to use a specific tool to solve a specific problem.,Tooling ,,,,Tooling,
58476384.0,Testing the Q# code on a real quantum computer?,"<p>I am using the Microsoft Quantum Development Kit for Python. Can I run the code on a real quantum computer?</p>

<p>Thanks for answers.</p>
",<quantum-computing><q#>,10/20/2019 19:10,58754238.0,58754238.0,"<p>Earlier this week we have <a href=""https://cloudblogs.microsoft.com/quantum/2019/11/04/announcing-microsoft-azure-quantum/"" rel=""nofollow noreferrer"">announced Azure Quantum</a> - a full-stack cloud ecosystem that includes several hardware backends. With it you'll be able to run your Q# code on simulators, resource estimators and actual hardware in a uniform manner.</p>

<p>At the moment Azure Quantum is in private preview; you can request to be an early adopter <a href=""https://azure.microsoft.com/services/quantum"" rel=""nofollow noreferrer"">here</a>.</p>

<hr>

<p>Alternatively, you can whip up some infrastructure code to use Q# to control your own quantum computer, as discussed <a href=""https://stackoverflow.com/questions/47801787/is-it-possible-to-use-q-to-control-my-own-quantum-computer"">in this question</a>.</p>
",11/07/2019 17:35,API Usage,"The user is inquiring about the capability of running their code on a real quantum computer using the Microsoft Quantum Development Kit for Python, which pertains to the usage of APIs for quantum computing.",API Usage,,,,API Usage,
58494452.0,Why Q# does not detect either F# or C# namespace?,"<p>I am making a library in Q#Â and trying to add a project reference to an F# (or C#) library written by me. But it does not work.</p>

<p>After adding the appropriate reference, I checked my Q# project .csproj file and I could see that the reference was added there that means the process of adding was done properly. But when I try to run the code I receive this message: ""error QS6104: No namespace with that name exists"" which refers to the line including the name of that F# (or C#) library. I wonder why it happens. Is it due to some fundamental differences between Q# and F# but Q# is created based on F# and C# therefore is there any solution to solve the problem?
Here is my code snippet:</p>

<pre><code>    namespace MyQSharpLibrary
    {
        open Microsoft.Quantum.Canon;
        open Microsoft.Quantum.Intrinsic;
        open MyFSharpLib;
        ...
        ...
    }
</code></pre>

<p>MyFSharpLib is the library I defined in F# and after adding reference to it inside ""MyQSharpLibrary"" I can see following markdown code in MyQSharpLibrary.csproj :</p>

<pre><code>    &lt;Project Sdk=""Microsoft.NET.Sdk""&gt;
      ...
      ...
       &lt;ItemGroup&gt;
        &lt;ProjectReference Include=""..\MyFSharpLib\MyFSharpLib.fsproj""/&gt;
       &lt;/ItemGroup&gt;  
    &lt;/Project&gt;
</code></pre>

<p>But after running MyQSharpLibrary, I receive error message: 
""error QS6104: No namespace with that name exists""
which refers to the line containing ""open MyFSharpLib;""</p>
",<c#><f#><q#>,10/21/2019 21:36,58508955.0,58508955.0,"<p><code>open</code> directives in Q# only allow you to import Q# code, not F# or C# code. Q# does not in general allow execution of arbitrary classical code, since it is designed to be executed on a quantum device which in general might not have this ability. </p>

<hr>

<p>If you're looking for a workaround that can be done in a simulation but will not be portable to a quantum device, you can write a simulator that extends one of the existing ones and exposes new intrinsic functions to Q# code that implement your classical computation. </p>

<p>For example, take a look at what the Quantum Katas do to gather statistics about the program execution: they define <a href=""https://github.com/microsoft/QuantumKatas/blob/master/utilities/Common/CounterSimulator.cs"" rel=""nofollow noreferrer"">CounterSimulator</a> which implements intrinsic functions such as <code>GetOracleCallsCount</code>, and a matching Q# code in <a href=""https://github.com/microsoft/QuantumKatas/blob/master/utilities/Common/Utils.qs"" rel=""nofollow noreferrer"">Utils.qs</a> which exposes them to Q# code. Then this project is added as a dependency to the katas that need this functionality, for example, <a href=""https://github.com/microsoft/QuantumKatas/tree/master/DeutschJozsaAlgorithm"" rel=""nofollow noreferrer"">DeutschJozsaAlgorithm</a> - you'll see the project reference in <a href=""https://github.com/microsoft/QuantumKatas/blob/master/DeutschJozsaAlgorithm/DeutschJozsaAlgorithm.csproj"" rel=""nofollow noreferrer"">DeutschJozsaAlgorithm.csproj</a> file and a matching <code>open Quantum.Kata.Utils;</code> in <a href=""https://github.com/microsoft/QuantumKatas/blob/master/DeutschJozsaAlgorithm/Tests.qs"" rel=""nofollow noreferrer"">Tests.qs</a>.</p>
",10/22/2019 16:49,Tooling,"The user is encountering an issue related to configuring project references in their Q# project, which falls under the category of using and configuring development tools and libraries for quantum programming.",Tooling,,,,Tooling,
58903264.0,What does this quantum circult represent? Please describe what is happening in this circuit,"<h1>Circuit Diagram</h1>
<p><a href=""https://i.stack.imgur.com/XmPSn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XmPSn.png"" alt=""enter image description here"" /></a></p>
<h1>Result<a href=""https://i.stack.imgur.com/SCnLl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SCnLl.png"" alt=""enter image description here"" /></a></h1>
<p>I am new to Quantum computing and having a really tough time understanding the working of Quantum Logic Gates. So, can anybody please help me with what these gates in the diagram actually do and what this circuit is doing and what does the result in probabilities actually means?</p>
",<ibm-cloud><circuit><quantum-computing><circuit-diagram><qiskit>,11/17/2019 17:35,58904884.0,58904884.0,"<p>Simple explanation:</p>

<p>The abstract mathematical model of a qubit is a <a href=""https://en.wikipedia.org/wiki/Bloch_sphere"" rel=""nofollow noreferrer"">Bloch spher</a>e in which default measurement basis is the Z-axis.</p>

<p>The two H gates are <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#Hadamard_(H)_gate"" rel=""nofollow noreferrer"">Hadamard gates</a> and put their qubit in a superposition of states relative to the Z-axis.</p>

<p>The <a href=""https://en.wikipedia.org/wiki/Controlled_NOT_gate"" rel=""nofollow noreferrer"">CNot gate</a> you have there flips q1 (which starts as 0) if q0 is a one.</p>

<p>Therefore, your outcomes match q0 and q1 always: if the measurement of the superpositioned q0 gate comes out a 1, the q1 gate does also. Otherwise, both are 0.</p>

<p>The probability for each qubit is 50/50 since the two uncontrolled bits are in a superposition, and the controlled bit (q1) follows q0.</p>

<p>Additionally, remember current devices are ""noisy"" and may not reflect the theory perfectly.</p>

<p>Also, as I said, that was the ""simplified"" story. Make sure you understand the <a href=""https://en.wikipedia.org/wiki/Controlled_NOT_gate#Behaviour_in_the_Hadamard_transformed_basis"" rel=""nofollow noreferrer"">Behaviour in the Hadamard transformed basis</a> portion of the Wikipedia Controlled Not Gate article because to really know what to expect, you have to do the linear algebra as shown in the Dirac notation in that article.</p>
",11/17/2019 20:25,Learning,"The user is asking for help in understanding the working of Quantum Logic Gates and the meaning of the results in probabilities, indicating a request for learning resources and explanations in quantum computing", Learning,,,,Learning,
58918250.0,How to connect to IBMQ from Qiskit?,"<p>I have a problem with connecting on <code>IBMQ</code> from <code>jupyter</code>, by typing : </p>

<pre><code>from qiskit import IBMQ
IBMQ.save_account('Token')
IBMQ.load_account()
</code></pre>

<p>i tried many different code but nothing worked. I uninstalled <code>Qiskit</code>, then i reinstall it and it still don't work.</p>

<p>If you have an idea of what is happening, please tell me</p>
",<qiskit>,11/18/2019 15:43,58919672.0,58919672.0,"<p>Please try running <code>IBMQ.delete_account()</code> to remove any old/incorrect credentials that may have accidentally got stored. Then check you have the most up to date versions of all the qiskit packages, especially IBM Q provider which should be on 0.4.1. If the packages need updating run <code>pip install --upgrade qiskit</code>.</p>

<p>Once this has finished, run <code>IBMQ.save_account(token)</code> to save the credentials again. After this you should be able to run <code>IBMQ.load_account()</code></p>
",11/18/2019 17:06,Errors,The user is encountering an issue with connecting to IBMQ from Jupyter using Qiskit and is seeking a solution to this problem. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development., Errors,,,,Errors,
59328149.0,How to pass one Q# operation to another Q# operation from C# or F#,"<p>I have the following Q# operations</p>

<pre><code>operation VQC (cirq:((Double[],Qubit[])=&gt;Unit is Adj),measurement:Pauli[], args: Double[], nQubits:Int) : Double {
    let res=EstimateFrequencyA(cirq(args,_),Measure(measurement,_),nQubits,1000);
    return 2.*res-1.;                   
}

operation Cirq(args:Double[],qs: Qubit[]):Unit is Adj{      
    Rz(args[0],qs[0] );
    CNOT(qs[0],qs[1]);
    Ry(args[1],qs[1]);

}
</code></pre>

<p>How can I pass the Cirq operation into the VQC operation from C# or F#?</p>
",<quantum-computing><q#>,12/13/2019 18:38,59331569.0,59331569.0,"<p>Looks like you can use <a href=""https://github.com/microsoft/qsharp-runtime/blob/master/src/Simulation/Common/SimulatorBase.cs#L77"" rel=""noreferrer"">SimulatorBase.Get&lt;></a> to get an instance of the operation type you need to pass and to pass it instead.</p>

<p>Here is C# driver code (F# should be similar):</p>

<pre><code>using QuantumSimulator qsim = new QuantumSimulator();
Pauli[] paulis = { Pauli.PauliX, Pauli.PauliZ };
double[] doubles = { 2.0, 0.5 };
IAdjointable cirqInstance = qsim.Get&lt;IAdjointable, Cirq&gt;();
double result = VQC.Run(qsim, cirqInstance, new QArray&lt;Pauli&gt;(paulis), new QArray&lt;Double&gt;(doubles), 2).Result;
Console.WriteLine(result);
</code></pre>
",12/14/2019 1:20,API Usage,The user is asking about how to use the Q# API from C# or F# to pass an operation to another operation. This is a specific question about using the Q# API.,API Usage,,,,API Usage,
59753527.0,How to print out whole matrix from unitary simulator,"<p>On Jupyter Notebook, I had simulated eight qubits quantum's circuit with Unitary_simulator. And then, I would like to print out the whole matrix, but what I get is <a href=""https://i.stack.imgur.com/qtBHu.png"" rel=""nofollow noreferrer"">matrix from unitary simulator</a>. 
The code that I used is:</p>

<pre class=""lang-py prettyprint-override""><code>unitary = job.result().get_unitary(cir)
print(""Circuit unitary:\n"", unitary)
</code></pre>
",<qiskit>,1/15/2020 14:32,59755583.0,59755583.0,"<p>The output is a 2D array, so you could print it as</p>

<pre class=""lang-py prettyprint-override""><code>for row in unitary:
    print(row)
</code></pre>
",1/15/2020 16:21,Errors,The user is seeking solutions and explanations for errors and exceptions they are encountering while trying to print out the whole matrix from a quantum circuit simulation in Jupyter Notebook.,Errors,,,,Errors,
59785239.0,How to create a newtype operation in Q#?,"<p>I am working with Q# on a generic grover search implementation and I wanted to define a custom Oracle type</p>

<pre><code>    newtype ModelOracle = ((Qubit[], Qubit[], Int[], Qubit) =&gt; Unit);

    // ...

    function GroverMaxMatchingOracle(search_set: (Int,Int)[], vertices: Int[], marked_pts: Bool[]): ModelOracle {
        return ModelOracle(ApplyMaxMatchingOracle(_,_,_,_,search_set, vertices, marked_pts));
    }

</code></pre>

<p>that will fit into my model.  But when I try to use it (kind of in the same way as they use <code>StateOracle</code> in the DatabaseSearch sample), I get an error saying that the new type <code>ModelOracle</code> is not a valid operation</p>

<pre><code>fail: Microsoft.Quantum.IQSharp.Workspace[0]
  QS5021: The type of the expression must be a function or operation type. The given expression is of type OracleHelper.ModelOracle.
</code></pre>

<p>What am I getting wrong about the types here?</p>
",<q#>,1/17/2020 10:11,59792917.0,59792917.0,"<p>It looks like you have defined things ok, so it might be that you have to unwrap the user defined type first with the <code>!</code> operator. 
So where you are using it you may have to do something like <code>GroverMaxMatchingOracle!(...)</code></p>

<p>Another approach could be to name the tuple in your UDT:</p>

<pre><code>newtype ModelOracle = (Apply: (Qubit[], Qubit[], Int[], Qubit) =&gt; Unit);
</code></pre>

<p>Then wherever you want to use it you can directly used the named item <code>Apply</code> like this: <code>GroverMaxMatchingOracle::Apply(...)</code></p>

<p>If its helpful, there is a section on user defined types (8.2) in the book <a href=""https://stackoverflow.com/users/267841/chris-granade"">@cgranade</a> and I are working on, <a href=""https://www.manning.com/books/learn-quantum-computing-with-python-and-q-sharp?a_aid=learn-qc-granade&amp;a_bid=ee23f338"" rel=""nofollow noreferrer"">Learn Quantum Computing with Python and Q#</a></p>
",1/17/2020 18:20,Errors,The user is encountering an error related to defining and using a custom Oracle type in a Q# program. This issue falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.,Errors ,,,,Errors,
59862723.0,Could I get the detail of error from qiskit,"<p>Sometimes, I execute a circuit on the Quantum computing device (ex. ibmq_16_melbourne) and got error like 'Invalid job state. The job should be DONE but it is JobStatus.ERROR'. Could I get the detail of this error, such as the cause of a mistake or sth like that.</p>

<p>For this time, I try to execute a circuit that including </p>

<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, IBMQ, execute
from qiskit.visualization import *
from qiskit.tools.jupyter import *
from qiskit.tools.monitor import job_monitor
IBMQ.load_account()
qr = QuantumRegister(6)
cr = ClassicalRegister(5)
mycir = QuantumCircuit(qr,cr)
for i in range(13):
    mycir.mct([qr[0],qr[1],qr[2],qr[3]],qr[4],None, mode='noancilla')
    mycir.mct([qr[0],qr[1],qr[2]],qr[3],None, mode='noancilla')

provider = IBMQ.get_provider(group='open')
backend = provider.get_backend('ibmq_16_melbourne')
job = execute(mycir, backend, shots=1000)
job_monitor(job)

result = job.result()
counts = result.get_counts()
# print(counts)
plot_histogram(counts, figsize=(14,8))
</code></pre>

<p>the result is error like above.</p>
",<qiskit>,1/22/2020 15:09,59864921.0,59864921.0,"<p>Running this circuit through the transpiler, I get a circuit that has a depth of 2201. I imagine the reason this circuit won't run therefore is because it is too deep.</p>

<p>To remedy this I would suggest either reducing the depth of your circuit, or running it on a simulator with a noise model similar to the device you are trying to run it on.</p>
",1/22/2020 17:09,Errors,The user is encountering an error message related to executing a quantum circuit on a quantum computing device (IBMQ) and is seeking information about the details of the error and its possible causes. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.,Errors,,,,Errors,
60257277.0,Why my code in not working for loops and if conditions?,"<p>I am trying to run this code in qutip. But its not showing any result. However there is not showing any error. All codes are correct and not showing any error. But don't know why the program is not execute. If anybody can resolve this problem is most welcome.</p>

<pre><code>  from __future__ import division
  from qutip import *
  import pylab
  import math
  import matplotlib.pyplot as plt
  import numpy as np
  import csv
  #import plotly.plotly as py
  #from plotly.graph_objs import *
  #py.sign_in(""cayayald"", ""zlae2s4d1i"")
  #linewidth
  #gamma = 1 =&gt; fully independent
  #G = 1 =&gt; fully collective
  gamma = .25
  G = 1.0 - gamma
  #delta is detuning
  delta = -1
  deltastep = 0.1
  dlist = []
  #n is number of atoms
  n = 16
  #V is energy shiftdue to dipole-dipole
  V = 10
  #omega is rabi freq
  omega = 1.5
  omegastep = 0
  #lowering, raising, and state collapsing operators
  sigmamlist = []
  sigmaplist = []
  c_op_list =  []
  for j in range (n):
   if j==0:
   sigmajm=sigmam()
   else:
   sigmajm=qeye(2)
   for i in range (1,n):
   if j == i:
   sigmaj1= tensor(sigmam(),sigmajm)
   else:
   sigmajm = tensor(qeye(2),sigmajm)
   sigmamlist.append(sigmajm)


  coplist.append(math.sqrt(gamma)*sigmajm) #n-many indep collapse ops
  sigmajp = sigmajm.dag()
  sigmaplist.append(sigmajp)
  coplist.append(math.sqrt(G)*sum(sigmamlist)) #one collective collapse op
  #we want expectation values of operators in exoplist
  exoplist = []
  #numerator of cross correlation
  exoplist.append(sigmaplist[0]*sigmamlist[0]*sigmaplist[1]*sigmamlist[1])
  #denomenator of cross correlation
  exoplist.append(sigmaplist[0]*sigmamlist[0])
  exoplist.append(sigmaplist[1]*sigmamlist[1])
</code></pre>

<p>After this These codes below are not running and taking time. don't know why?</p>

<pre><code>   #initial state vector
  psi0 = basis(2,0)
  for i in range(1,n):
  psi0 = tensor(psi0,basis(2,0))
  #build Hamiltonian
  g2 = []
  list = np.linspace(0,200,2000)
  ntraj = 1
  while delta &lt;= 7:
  glist = []
  hlist = []
  vlist = []
  for i in range(n):
        hlist.append(-delta*(sigmaplist[i]*sigmamlist[i])+ (omega / 2)*(sigmaplist[i] + 
        sigmamlist[i]))
  for i in range(n):
  for j in range(i):
        vlist.append((V / (n - 1))*((sigmaplist[j]*sigmamlist[j])
   *(sigmaplist[i]*sigmamlist[i])))
   H = sum(hlist) + sum(vlist)
   #monte carlo trajectory
   montecar = mcsolve(H, psi0, tlist, coplist, exoplist, ntraj)
   for i in range(len(montecar.expect[0])):
   numerator = montecar.expect[0][i]
  denomenator = montecar.expect[1][i]
  denom2 = montecar.expect[2][i]
  glist.append(numerator/(denomenator*denom2))
  g2.append(sum(glist)/len(glist))
  dlist.append(delta)
  delta = delta + deltastep
  x = np.arange(10)
  fig = plt.figure()
  ax = plt.subplot(111)
  ax.plot(dlist, g2)
  # Shink current axis by 20%
  box = ax.get_position()
  ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
  plt.grid(True)
  plt.show()   
</code></pre>
",<python><python-3.x><qutip>,2/17/2020 6:54,60257429.0,60257429.0,"<p>You have to use indentation, smt. like this:</p>

<pre><code>for j in range (n):
    if j==0:
        sigmajm=sigmam()
    else:
        sigmajm=qeye(2)

for i in range (1,n):
    if j == i:
        sigmaj1= tensor(sigmam(),sigmajm)
    else:
        sigmajm = tensor(qeye(2),sigmajm)
        sigmamlist.append(sigmajm)
</code></pre>

<p>Update:
<a href=""https://www.tutorialspoint.com/python/python_basic_syntax.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/python/python_basic_syntax.htm</a></p>
",2/17/2020 7:07,Errors,"The user is experiencing issues with their code. The code is not running as expected, and the user is looking for assistance in resolving this problem.",Errors,,,,Errors,
60682091.0,cannot save tensorrflow keras quantum model using save/pickle,"<p><strong>how to save tensorflow quantum model? I am getting the following when i am trying to save keras model with quantum circuits.
I didnt find any support for the same.
tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments
tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments
tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments</strong></p>

<pre><code>    WARNING:tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments: {'prepend': 
    cirq.Circuit([
    cirq.Moment(operations=[
    cirq.H.on(cirq.GridQubit(0, 0)),
    cirq.H.on(cirq.GridQubit(0, 1)),
    cirq.H.on(cirq.GridQubit(0, 2)),
    cirq.H.on(cirq.GridQubit(0, 3)),
    cirq.H.on(cirq.GridQubit(1, 0)),
    cirq.H.on(cirq.GridQubit(1, 1)),
    cirq.H.on(cirq.GridQubit(1, 2)),
    cirq.H.on(cirq.GridQubit(1, 3)),
    cirq.H.on(cirq.GridQubit(2, 0)),
    cirq.H.on(cirq.GridQubit(2, 1)),
    cirq.H.on(cirq.GridQubit(2, 2)),
    cirq.H.on(cirq.GridQubit(2, 3)),
    cirq.H.on(cirq.GridQubit(3, 0)),
    cirq.H.on(cirq.GridQubit(3, 1)),
    cirq.H.on(cirq.GridQubit(3, 2)),
    cirq.H.on(cirq.GridQubit(3, 3)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(0, 1), cirq.GridQubit(0, 2)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(0, 2), cirq.GridQubit(0, 3)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(0, 3), cirq.GridQubit(1, 0)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(1, 0), cirq.GridQubit(1, 1)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(1, 1), cirq.GridQubit(1, 2)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(1, 2), cirq.GridQubit(1, 3)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(1, 3), cirq.GridQubit(2, 0)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(2, 0), cirq.GridQubit(2, 1)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(2, 1), cirq.GridQubit(2, 2)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(2, 2), cirq.GridQubit(2, 3)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(2, 3), cirq.GridQubit(3, 0)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(3, 0), cirq.GridQubit(3, 1)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(3, 1), cirq.GridQubit(3, 2)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(3, 2), cirq.GridQubit(3, 3)),
]),
cirq.Moment(operations=[
    cirq.CZ.on(cirq.GridQubit(3, 3), cirq.GridQubit(0, 0)),
]),])}. 
They will not be included in the serialized model (and thus will be missing at deserialization time).
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
&lt;ipython-input-91-a74ee5c9d34d&gt; in &lt;module&gt;()
----&gt; 1 qcnn_model.save('qcnn_model.h5')

8 frames
/usr/local/lib/python3.6/dist-packages/tensorflow_core/python/keras/engine/base_layer.py in 
get_config(self)
497     # or that `get_config` has been overridden:
498     if len(extra_args) &gt; 1 and hasattr(self.get_config, '_is_default'):
--&gt; 499       raise NotImplementedError('Layers with arguments in `__init__` must '
500                                 'override `get_config`.')
501     return config

NotImplementedError: Layers with arguments in `__init__` must override `get_config`.
</code></pre>
",<tensorflow><keras><model><save><tensorflow-quantum>,3/14/2020 11:12,60688418.0,60688418.0,"<p>TensorFlow Quantum does not yet implement <code>get_config</code> and <code>load_config</code>. We had some difficulty with saving certain Cirq objects, we are working on it. </p>

<p>For now if you want to save models that contain quantum layers you can use the </p>

<pre class=""lang-py prettyprint-override""><code>model = tf.keras.Model(...)
model.save_weights(""some_path"")
...
model.load_weights(""some_path"")
</code></pre>

<p>function instead.</p>
",3/14/2020 23:47,Errors,The user is encountering an error related to saving a TensorFlow Quantum (TFQ) model and is seeking assistance in resolving the issue. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development., Errors,,,,Errors,
60709643.0,How to create VSCode bindings to input bra and ket efficiently,"<p>I'm currently using <code>VSCode</code> for <code>Q#</code> programming. This sometimes entails including simple qubit expressions in the comments for clarity. It is of course possible to just settle with using regular angle brackets (such as <code>|00&gt;</code> or <code>&lt;00|</code>), but it looks nicer using the appropriate Unicode characters (such as <code>|00â©</code> or <code>â¨00|</code>). Copying and pasting these characters whenever needed is a bit cumbersome, so it would be nice to have key bindings in <code>VSCode</code> just for this purpose. Actually, I'd like to be able to configure <code>VSCode</code> for quick access to any selection of characters I might be interested at the moment.</p>
",<visual-studio-code><keyboard-shortcuts><special-characters><quantum-computing><ide-customization>,3/16/2020 16:23,60709644.0,60709644.0,"<p><code>VSCode</code> customization supports a <code>type</code> command which does exactly that - types in its argument. In order to create an entry for a keybinding, open the command prompt (<kbd>Ctrl+Shift+P</kbd> or <kbd>â+Shift+P</kbd> on Mac) and type <code>Preferences: Open Keyboard Shortcuts (JSON)</code> and insert entries of the form:</p>

<pre><code>{
    ""key"": ""&lt;key-binding&gt;"",
    ""command"": ""type"",
    ""args"": {
        ""text"": ""&lt;character&gt;""
    }
}
</code></pre>

<p>where <code>&lt;key-binding&gt;</code> is the usual description of the keybinding and <code>&lt;character&gt;</code> is the desired character literal. So, for the bra-ket case above, my customization looks like this:</p>

<pre><code>[
    {
        ""key"": ""ctrl+shift+."",
        ""command"": ""type"",
        ""args"": {
            ""text"": ""â©""
        }
    },
    {
        ""key"": ""ctrl+shift+,"",
        ""command"": ""type"",
        ""args"": {
            ""text"": ""â¨""
        }
    }
]
</code></pre>
",3/16/2020 16:23,Tooling,The user is inquiring about configuring key bindings in Visual Studio Code (VSCode) for quick access to Unicode characters to enhance the appearance of Q# programming comments. This pertains to tooling and software usage in quantum programming., Tooling,,,,Tooling,
60839687.0,using third part modules in IBM quantum experience,"<p>is there something i can do to use NumPy in IBM quantum experience? I have searched on google but i couldn't find anything. I thought about coping the source code, any suggestion?</p>
",<python><quantum-computing>,3/24/2020 21:34,60848813.0,60848813.0,"<p>NumPy is one of the pre-installed packages (it's a pre-requisite for Qiskit, for one thing). You should be able to just do <code>import numpy</code> from your Jupyter notebook.</p>
",3/25/2020 12:25,API Usage,The user is asking about how to use NumPy in IBM Quantum Experience. This is a specific question about using the IBM Quantum Experience API.,API Usage,,,,API Usage,
60918011.0,Implement quantum teleportation in qiskit,"<p>I am trying to implement the <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html"" rel=""nofollow noreferrer"">quantum teleportation protocol</a> from the qiskit textbook in qiskit: 
I start with q_0 bit = 1 and I expect that  q_3 = 1 at the end but it does not work.</p>

<pre><code>from qiskit import *

qc = QuantumCircuit(3, 3)

qc.x(0) #q -&gt; 1
qc.barrier()

qc.h(1)
qc.cx(1, 2)
qc.barrier()
# Next, apply the teleportation protocol.
qc.cx(0, 1)
qc.h(0)
qc.barrier()
# We measure these qubits and use the classical results to perform an operation
qc.measure(0, 0)
qc.measure(1, 1)
qc.cx(1, 2)
qc.cz(0, 2)
#qc.barrier()
backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend, shots=1, memory=True).result()
result = job.get_memory()[0]
qc.measure(2, 2)
print(job.get_memory()[0]) #q = 0
</code></pre>
",<quantum-computing><qiskit>,3/29/2020 17:21,60952500.0,60952500.0,"<p>It looks like it is working as intended. In the textbook, it says towards the end of the code cell:</p>

<p><em>In principle, if the teleportation protocol worked, we have q[2] = secret_unitary|0>
As a result, we should be able to recover q[2] = |0> by applying the reverse of secret_unitary
since for a unitary u, u^dagger u = I.</em></p>

<p>You had your <code>secret_unitary</code> as 'x', which does in fact change Alice's first qubit to 1. But, at the end of the circuit, the dagger of the secret_unitary is applied, cancelling the original application of the <code>secret_unitary</code>. You should expect to see 0 for q[2], as that means that the state from q[0] (in this case, 1) was successfully teleported to q[2], and then brought back to 0 by the dagger of the <code>secret_unitary</code>.</p>
",3/31/2020 14:04,Errors,"The user is seeking help with their implementation of the quantum teleportation protocol in Qiskit, as they are not getting the expected result. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors,
61182919.0,Polynomial Equations in Q# E=MC^2,"<p>I am trying to understand how to use quantum computing and have started to understand some of the basic gates and other concepts, but am not able to understand how to put it to practice in real world problems.</p>

<p>Let's say I want to write a function in Q# that returns the value of <strong><em><code>E</code></em></strong> in the equation </p>

<p><code>E= MC^2</code> </p>

<p>Can someone help me write this operation?   </p>
",<quantum-computing><q#>,4/13/2020 7:00,61239848.0,61239848.0,"<p>To answer the literal question: if M and C are just floating-point numbers, the calculation can be done using purely classical Q# constructs:</p>

<pre><code>// The function that carries out the computation itself
function Energy (m : Double, c : Double) : Double {
    return m * c ^ 2.0;
}

// The operation that you'll invoke to pass the parameters to the function and to print the results
operation PrintEnergy () : Unit {
    let c = 299792458.0;
    let energy1 = Energy(1.0, c);
    Message($""Calculated energy of 1 gram of mass = {energy1}"");
    let energy2 = Energy(2.0, c);
    Message($""Calculated energy of 2 grams of mass = {energy2}"");
}
</code></pre>

<p>The output is:</p>

<pre><code>Calculated energy of 1 gram of mass = 89875517873681760
Calculated energy of 2 grams of mass = 1.7975103574736352E+17
</code></pre>

<hr>

<p>You will notice that this code fragment does not use any qubits or gates, so it's not really a good example of using quantum computing to solve real-world problems, even though it's implemented using a quantum programming language. This problem involved very simple mathematical computations, which can be done very efficiently using classical computers. </p>

<p>Quantum computers are going to use a co-processor model of computation - we'll use them to do computations that they are well suited to do (such as solving chemistry problems), and use classical computers for the rest of the computations.</p>

<p>To learn to apply quantum computing to solving problems with Q#, you can check out the <a href=""https://github.com/Microsoft/QuantumKatas/"" rel=""nofollow noreferrer"">Quantum Katas</a> - a collection of tutorials and programming exercises. In particular, they show how to translate classical problems such as SAT or graph coloring into a form that can take advantage of quantum computing algorithms. <em>(Disclosure: I'm the maintainer of this project)</em></p>
",4/15/2020 22:44, Learning,The user is looking for assistance in understanding how to apply quantum computing concepts to real-world problems and is seeking help in writing a specific Q# operation for a physics equation. This falls under the category of requests for learning resources and guidance in quantum computing.,Learning ,,,, Learning,
61286903.0,How to build a complex controlled gate in the Qiskit?,"<p>I work on theory tasks in quantum computing, and make simple experiments with Qiskit. Unfortunately, I can't find a way how to make a complex control gates there, where control is in the quantum register.</p>

<p>I would like to have a ""c_if"" analogue, which can be chained and use quantum bits as a control.
Smth like </p>

<pre><code>swap(q1, q2).c_if(q0,Zero).c_if(q3,One)
</code></pre>

<p>Is there such an operation in the qiskit? How could I emulate such an operation if it doesn't exist?</p>

<p><a href=""https://i.stack.imgur.com/hnSYc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hnSYc.png"" alt=""enter image description here""></a></p>
",<quantum-computing><qiskit>,4/18/2020 9:25,69024251.0,69024251.0,"<p>Check out Qiskit documentation for the MCXGate, know as the Multi-controlled-X Gate. This gate lets you define how many control qubits you would like to include (perhaps the majority of your quantum register) and define a control state.</p>
<pre><code>
from qiskit import * 

my_circuit = QuantumRegister(3,3)

my_circuit.append(circuit.library.MCXGate(2, ctrl_state='10'), [0,1,2]) 
   

</code></pre>
<p>Check out the documentation <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.MCXGate.html"" rel=""nofollow noreferrer"">here</a>.</p>
<p>There are also variations that will do Y gate Z gate or whatever you like depending if the circuit sees the correct control gate.</p>
",09/02/2021 04:39,Tooling,The user is asking about a specific functionality (complex control gates) in a quantum computing tool (Qiskit).,Tooling,,,,Tooling,
61379417.0,AssertionError: wrong color format 'ansibrightred',"<p>I am running my old <code>qiskit</code> code after a very long time it's not running now showing error <code>wrong color format 'ansibrightred'</code> and I don't know why?</p>

<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
# %matplotlib inline

circuit = QuantumCircuit(3,3)
circuit.h(0)
circuit.h(1)
circuit.h(2)
circuit.measure([0,1], [0,1])

</code></pre>
",<quantum-computing><qiskit>,4/23/2020 4:33,61380576.0,61380576.0,"<p>I ran into the same problem. I solved it by removing my install and installing qiskit==0.16.2.</p>

<pre><code>pip install qiskit==0.16.2
</code></pre>
",4/23/2020 6:22, Errors,The user is encountering an error related to the Qiskit code not running due to a color format issue. This falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development,Errors,,,, Errors,
61568297.0,qiskit plots not showing up in spyder console,"<p><strong>System Informations</strong></p>

<pre><code>Qiskit version: 0.17.0
Python version: 3.7.7
Operating system: Windows 10 home x64
</code></pre>

<p><strong>What is the current behavior?</strong></p>

<p>I am using spyder 4.1.1 on Anaconda and any time I try to plot data it does not show up. The code runs with no errors but the plot it self does not appear anywhere.</p>

<p><strong>Steps to reproduce the problem</strong></p>

<p>Running the code listed below which is from the IBMQ website:</p>

<pre><code>import numpy 
import qiskit as qc 
from qiskit import QuantumCircuit, execute, Aer
import matplotlib
from qiskit.visualization import plot_state_city

circ = qc.QuantumCircuit(3)

circ.h(0)
circ.cx(0,1)
circ.cx(0,2)
print(circ.draw())
backend = Aer.get_backend('statevector_simulator')
job = execute(circ, backend)
result = job.result()
outputstate = result.get_statevector(circ, decimals=3)
print(outputstate)
plot_state_city(outputstate)
</code></pre>

<p><strong>What is the expected behavior?</strong></p>

<p>for the plot state city plot to show up in the console or somewhere else</p>

<p><strong>Suggested solutions</strong></p>

<p>I tried using both matplotlib.pylot.show() and matplotlib.pyplot.draw()</p>
",<python><matplotlib><anaconda><spyder><qiskit>,05/03/2020 00:51,62319001.0,62319001.0,"<p>Try follow the instructions under ""Spyder plots in separate windows"" <a href=""https://geo-python.github.io/2017/lessons/L7/matplotlib.html#spyder-plots-in-separate-windows"" rel=""nofollow noreferrer"">here</a>. Then you can also call <code>circ.draw(output='mpl')</code> to draw the circuit in a window. Hope this helps.</p>
",06/11/2020 07:15,Tooling,"The user is asking about a problem with plotting data using Spyder and Qiskit. This is a question about using Qiskit and Spyder together, which is a tooling issue.",Tooling,,,,Tooling,
61573518.0,How do you take an user input?,"<p>How do you take an user input as integer or string?</p>
",<q#>,05/03/2020 11:16,61599150.0,61599150.0,"<p>You can do this as part of a Main method in your C# or Python driver code, or you could use the new support for Q# command-line executables called out in the recent release (<a href=""https://learn.microsoft.com/en-us/quantum/relnotes/#version-01120042825"" rel=""nofollow noreferrer"">0.11.2004.2825</a>). If you follow the link for the quantum random number generator sample and scroll down, you'll see an <a href=""https://learn.microsoft.com/en-us/quantum/quickstarts/qrng?tabs=tabid-qsharp#creating-a-complete-random-number-generator"" rel=""nofollow noreferrer"">example there</a> for using <code>@EntryPoint()</code> to denote the Q# operation that should be used to generate the entry point code. It will also cause any arguments to that operation to automatically become command-line parameters for the built executable. You can try this in the sample by updating the code to take <code>max</code> as an argument, like this:</p>

<pre><code>@EntryPoint()
operation SampleRandomNumber(max : Int) : Int {
    Message($""Sampling a random number between 0 and {max}: "");
    return SampleRandomNumberInRange(max);
}
</code></pre>

<p>Then when you run the sample via <code>dotnet run</code> you'll see that it now requires <code>--max</code> as a command line parameter, and handles the translation into the correct input type for the Q# operation. You can then pass the param like this to get the same behavior as the original sample: <code>dotnet run --max 50</code></p>

<p>Hope that helps!</p>
",05/04/2020 18:30,Learning,"The user is seeking information on how to take user input as either an integer or a string. This question pertains to the learning aspect of quantum computing, specifically related to programming and input handling.",Learning,,,,Learning,
61634110.0,Why do I get an error when I use DumpMachine in q#?,"<p>Here is my code:</p>

<pre><code>using (q = Qubit()) {
            Message(""Input:"");
            Message(""q = â£0â­, index = 1"");

            Message(""Requaired Output:"");
            Message(""â£0â­:     0.707107 +  0.000000 i"");
            Message(""â£1â­:     0.000000 + -0.707107 i"");

            Task12(q, 1);
            Message(""Your Output:"");
            DumpMachine();

            Reset(q);
        }
</code></pre>

<p>But I get this error:</p>

<pre><code>The type or namespace name '_2e502c3cdee5457783e1ea9b1f54eb1b_DumpMachine' does not exist in the namespace 'Microsoft.Quantum.Diagnostics' (are you missing an assembly reference?)
</code></pre>

<p>Does anyone have an idea why?</p>
",<q#>,05/06/2020 11:32,61667019.0,61667019.0,"<p>Can you verify if you have <code>open Microsoft.Quantum.Diagnostics;</code> listed? </p>

<p>I copied your code and added the functions, it works for me, I use .NET Core 3.1 &amp; VisualStudio 2019, here is my code, I also added it to GitHub <a href=""https://github.com/nahidf-adventures/qsharp-adventures/tree/master/src/QbitSample"" rel=""nofollow noreferrer"">https://github.com/nahidf-adventures/qsharp-adventures/tree/master/src/QbitSample</a>:</p>

<pre><code>namespace QbitSample {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Measurement;
    open Microsoft.Quantum.Diagnostics;


    @EntryPoint()
    operation HelloQ() : Unit {
        using (q = Qubit()) {
            Message(""Input:"");
            Message(""q = â£0â­, index = 1"");

            Message(""Requaired Output:"");
            Message(""â£0â­:     0.707107 +  0.000000 i"");
            Message(""â£1â­:     0.000000 + -0.707107 i"");

            Task12(q, 1);
            Message(""Your Output:"");
            DumpMachine();

            Reset(q);
        }
    }

    operation Task12(q: Qubit, count : Int) : Unit {
        }
    }
</code></pre>
",05/07/2020 20:20,Errors, The user is encountering an error related to missing assembly references when using the DumpMachine function in their Q# code. This question pertains to seeking solutions and explanations for errors and exceptions in quantum program development., Errors,,,,Errors,
61835652.0,Decompose a Quantum Circuit in Cirq,"<p>I am working on Cirq and need to perform certain unitary operations on qubits. For that, I am using the <code>MatrixGate()</code> function in Cirq. Unlike Qiskit, I could not find any function like decompose or transpile to simplify the Unitary operation into basic U3 and CNOT gates. </p>

<p>For instance, if I want to act the following Unitary Operator,</p>

<p><a href=""https://i.stack.imgur.com/QY3si.png"" rel=""nofollow noreferrer"">Unitary Operator</a></p>

<p>To do this I use this code in Qiskit. Looking for something equivalent in Cirq.  </p>

<pre><code>qc=QuantumCircuit(2)
qc.unitary(U,[0,1])
qc=transpile(qc,basis_gates=['cx','u3'])
qc.draw(output='mpl')
</code></pre>

<p><a href=""https://i.stack.imgur.com/8gmvr.png"" rel=""nofollow noreferrer"">Unitary Gate</a> </p>

<p>After using Transpile function in Qiskit</p>

<p><a href=""https://i.stack.imgur.com/mRKJL.png"" rel=""nofollow noreferrer"">Transpiled Unitary Gate</a></p>

<p>I even tried to work up the Cosine-Sine Decomposition Algorithm which Qiskit uses to decompose these Unitary Operations. As mentioned in the paper, <a href=""https://arxiv.org/pdf/1501.06911.pdf"" rel=""nofollow noreferrer"">Quantum Circuits for Isometries</a>, but they do not trivially yield the required decomposition. 
Please help by either suggesting :</p>

<ol>
<li>Some code in Cirq to decompose circuits or</li>
<li>A workaround to export Qiksit circuits to Cirq or</li>
<li>A simpler algorithm to decompose Unitary Operations.</li>
</ol>
",<linear-algebra><quantum-computing><cirq>,5/16/2020 10:56,61850307.0,61850307.0,"<p>An example of such a method is  <code>cirq.two_qubit_matrix_to_operations</code>. It uses the kak decomposition (cartan decomposition) to determine how to translate a unitary matrix into a series of operations with minimal number of CZ gates.</p>

<pre><code>import cirq

desired_matrix = cirq.testing.random_unitary(dim=4)

synthesized_operations = cirq.two_qubit_matrix_to_operations(
    cirq.LineQubit(0),
    cirq.LineQubit(1),
    desired_matrix,
    allow_partial_czs=False,
)
circuit = cirq.Circuit(synthesized_operations)

synthesized_matrix = cirq.unitary(circuit)

cirq.testing.assert_allclose_up_to_global_phase(
    desired_matrix,
    synthesized_matrix,
    atol=1e-4
)

print(desired_matrix.round(3))
print(circuit)
</code></pre>

<p>Prints (for example):</p>

<pre><code>[[ 0.234-0.169j -0.81 +0.038j -0.327+0.138j -0.364-0.029j]
 [-0.503-0.407j  0.221-0.206j  0.063+0.144j -0.629-0.264j]
 [ 0.271+0.338j  0.337-0.128j -0.343+0.731j -0.165+0.052j]
 [ 0.504+0.236j  0.222+0.269j  0.244-0.371j -0.608-0.043j]]
0: âââPhX(-0.283)^0.631âââ@âââPhX(0.673)^0.5ââââ@âââPhX(-0.375)^0.5âââ@âââPhX(0.827)^0.147âââZ^-0.269âââ
                          â                     â                     â
1: âââPhX(0.508)^0.338ââââ@âââPhX(0.65)^(5/6)âââ@âââPhX(0.65)^0.995âââ@âââPhX(0.302)^0.512âââZ^-0.516âââ
</code></pre>
",5/17/2020 10:27,Tooling,The user is seeking guidance on performing unitary operations and circuit decomposition in Cirq. This question relates to the tools and software environment for quantum programming.,Tooling,,,,Tooling,
61852590.0,How do I implement a controlled Rx in Cirq/Tensorflow Quantum?,"<p>I am trying to implement a controlled rotation gate in Cirq/Tensorflow Quantum. </p>

<p>The readthedocs.io at <a href=""https://cirq.readthedocs.io/en/stable/gates.html"" rel=""nofollow noreferrer"">https://cirq.readthedocs.io/en/stable/gates.html</a> states:</p>

<p>""Gates can be converted to a controlled version by using Gate.controlled(). In general, this returns an instance of a ControlledGate. However, for certain special cases where the controlled version of the gate is also a known gate, this returns the instance of that gate. For instance, cirq.X.controlled() returns a cirq.CNOT gate. Operations have similar functionality Operation.controlled_by(), such as cirq.X(q0).controlled_by(q1).""</p>

<p>I have implemented</p>

<pre><code>cirq.rx(theta_0).on(q[0]).controlled_by(q[3])
</code></pre>

<p>I get the following error:</p>

<pre><code>~/.local/lib/python3.6/site-packages/cirq/google/serializable_gate_set.py in 
serialize_op(self, op, msg, arg_function_language)
    193                         return proto_msg
    194         raise ValueError('Cannot serialize op {!r} of type {}'.format(
--&gt; 195             gate_op, gate_type))
    196 
    197     def deserialize_dict(self,

ValueError: Cannot serialize op cirq.ControlledOperation(controls=(cirq.GridQubit(0, 3),), sub_operation=cirq.rx(sympy.Symbol('theta_0')).on(cirq.GridQubit(0, 0)), control_values=((1,),)) of type &lt;class 'cirq.ops.controlled_gate.ControlledGate'&gt;
</code></pre>

<p>I have the qubits and symbols initialized as:</p>

<pre><code>q = cirq.GridQubit.rect(1, 4)
symbol_names = x_0, x_1, x_2, x_3, theta_0, theta_1, z_2, z_3
</code></pre>

<p>I do re-use the circuits with various circuits. </p>

<p>My question: How do I properly implement a controlled Rx in Cirq/Tensorflow Quantum?</p>

<p>P.S. I can't find a tag for Google Cirq</p>

<p>Follow up: 
How does this generalize to the similar situations of Controlled Ry and controlled Rz?</p>

<p>For Rz I found a gate decomposition at <a href=""https://threeplusone.com/pubs/on_gates.pdf"" rel=""nofollow noreferrer"">https://threeplusone.com/pubs/on_gates.pdf</a>, involving H.on(q1), CNOT(q0, q1), H.on(q2), but this is not yet an CRz with an arbitrary angle. Would I introduce the angle before the H?</p>

<p>For the Ry, I did not find a decomposition yet, neither the CRy. </p>
",<quantum-computing><tensorflow-quantum><cirq>,5/17/2020 13:29,61881101.0,61881101.0,"<p>What you have is a completely correct implementation of a controlled X rotation in Cirq. It can be used in simulation and other things like <code>cirq.unitary</code> without any issues.</p>
<p>TFQ only supports a subset of gates in Cirq. For example a <code>cirq.ControlledGate</code> can have an arbitrary number of control qubits, which in some cases can make it harder to decompose down to primitive gates that are compatible with NiSQ hardware platforms (This is why <code>cirq.decompose</code> doesn't do anything to <code>ControlledOperations</code>). TFQ only supports these primitive style gates , for a full list of the supported gates, you can do:</p>
<pre class=""lang-py prettyprint-override""><code>tfq.util.get_supported_gates().keys()
</code></pre>
<p>In your case it is possible to come up with a simpler implementation of this gate. First we can note that <code>cirq.rx(some angle)</code> is equal to <code>cirq.X**(some angle / pi)</code> offset by a global phase:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; a = cirq.rx(0.3)
&gt;&gt;&gt; b = cirq.X**(0.3 / np.pi)
&gt;&gt;&gt; cirq.equal_up_to_global_phase(cirq.unitary(a), cirq.unitary(b))
True
</code></pre>
<p>Lets move to using X now. Then the operation we are after is:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; qs = cirq.GridQubit.rect(1,2)
&gt;&gt;&gt; a = (cirq.X**0.3)(qs[0]).controlled_by(qs[1])
&gt;&gt;&gt; b = cirq.CNOT(qs[0], qs[1]) ** 0.3
&gt;&gt;&gt; cirq.equal_up_to_global_phase(cirq.unitary(a), cirq.unitary(b))
True
</code></pre>
<p>Since <code>cirq.CNOT</code> is in the TFQ supported gates it should be serializable without any issues. If you want to make a symbolized version of the gate you can just replace the 0.3 with a <code>sympy.Symbol</code>.</p>
<p>Answer to follow up: If you want to do a CRz you can do the same thing you did above, swapping out the CNOT gate for the CZ gate. For CRy it's not as easy. For that I would recommend doing some combination of: cirq.Y(0) and cirq.YY(0, 1).</p>
<p><strong>Edit:</strong> <code>tfq-nightly</code> builds and likely releases after 0.4.0 now include support for arbitrary controlled gates. So on these versions of tfq you could also do things like <code>cirq.Y(...).controlled_by(...)</code> to achieve the desired result now too.</p>
",5/19/2020 0:15,Tooling,"The user is seeking guidance on implementing controlled rotation gates (controlled Rx, controlled Ry, controlled Rz) in Cirq/Tensorflow Quantum. This question pertains to using the Cirq library and its tooling for quantum programming.",Tooling,,,,Tooling,
61934178.0,Unable to build a Q# program in VS Code,"<p>I am new to quantum computing and have just installed Microsoft's Visual Studio Code and the QDK extension for it. However, when I try to build and run (dotnet run from the terminal), it is unable to give me an output for it and throws a few errors regarding namespace despite installing the extension (quantum sdk). I'm most likely doing something stupid so please point me in the right direction</p>

<p>My program is:</p>

<pre><code>namespace helloqworld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;


    @EntryPoint()
    operation HelloQ() : Unit {
        Message(""Hello quantum world!"");
    }
}
</code></pre>

<p>And I get the following errors:</p>

<pre><code>No namespace with the name ""Microsoft.Quantum.Canon"" exists.
No namespace with the name ""Microsoft.Quantum.Intrinsic"" exists.
{
    ""resource"": ""/Users/nalini/Desktop/helloqworld/Program.qs"",
    ""owner"": ""_generated_diagnostic_collection_name_#0"",
    ""code"": ""QS6005"",
    ""severity"": 8,
    ""message"": ""No type with the name \""EntryPoint\"" exists in any of the open namespaces."",
    ""source"": ""/Users/nalini/Desktop/helloqworld/Program.qs"",
    ""startLineNumber"": 9,
    ""startColumn"": 6,
    ""endLineNumber"": 9,
    ""endColumn"": 16
}
{
    ""resource"": ""/Users/nalini/Desktop/helloqworld/Program.qs"",
    ""owner"": ""_generated_diagnostic_collection_name_#0"",
    ""code"": ""QS5022"",
    ""severity"": 8,
    ""message"": ""No identifier with the name \""Message\"" exists."",
    ""source"": ""/Users/nalini/Desktop/helloqworld/Program.qs"",
    ""startLineNumber"": 11,
    ""startColumn"": 9,
    ""endLineNumber"": 11,
    ""endColumn"": 16
}
</code></pre>

<p>And my csproj file has:</p>

<pre><code>Project Sdk=""Microsoft.Quantum.Sdk/0.11.2004.2825""&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
",<c#><visual-studio-code><q#>,5/21/2020 12:07,62137609.0,62137609.0,"<p>Does your code build and run successfully if you just do <code>dotnet run</code> from terminal? If this is the case, this error comes from IntelliSense.</p>

<p>Are you using .NET Core 3.1.300? I think QDK release 0.11.2004.2825 has IntelliSense issues with .NET Core 3.1.300 specifically (the <a href=""https://github.com/microsoft/qsharp-compiler/issues/434"" rel=""nofollow noreferrer"">relevant issue on GitHub</a>), and downgrading .NET Core to 3.1.201 fixes this issue.</p>
",06/01/2020 17:27,Errors," The user's question primarily concerns the errors they encountered while running a quantum program using Microsoft's QDK, which is more specific to the 'Errors' category.",Errors,,,,Errors,
62009102.0,Jupyter Notebook Q# kernal not connecting,"<p>I recently updated iqsharp(from 0.10 to 0.11) for jupyter notebooks (via Anaconda) and ever since, the Q# kernel stopped connecting when I open a new or existing Q# notebook. I have tried uninstalling and reinstalling jupyter notebook as well as iqsharp but nothing seems to have changed.</p>

<p>I had initially installed iqsharp for Jupyter Notebook following the instructions <a href=""https://learn.microsoft.com/en-us/quantum/install-guide/qjupyter"" rel=""nofollow noreferrer"">here</a> and updated it to the latest version using the instructions <a href=""https://learn.microsoft.com/en-us/quantum/install-guide/update#update-iq-for-jupyter-notebooks"" rel=""nofollow noreferrer"">here</a>.</p>

<p>I think it may have something to do with, <code>""Access to the path 'C:\Users\neera\Application Data' is denied""</code> appearing in the terminal though I am not quite sure what it means.</p>

<pre><code>iqsharp: 0.11.2004.2825
Jupyter Core: 1.3.52077.0
.NET Runtime: .NETCoreApp,Version=v3.1
</code></pre>

<p>Any help would be appreciated.</p>
",<jupyter-notebook><q#>,5/25/2020 19:09,62027491.0,62027491.0,"<p>[Update:]</p>

<p>As discussed in <a href=""https://github.com/microsoft/iqsharp/issues/149"" rel=""nofollow noreferrer"">this GitHub issue</a>, this seems to be related to your Q# <code>.ipynb</code> notebook file living in your <code>Users</code> folder, alongside the <code>Application Data</code> folder which for some reason is inaccessible.</p>

<p>You should be able to workaround this issue by creating/opening your Q# <code>.ipynb</code> notebook files from any other folder on your disk.</p>

<p>Thanks for providing the additional information!</p>

<hr>

<p>[Old answer:]</p>

<p>It sounds like some type of installation problem. (I've left a comment asking for more details to help diagnose more specifically.) But in general, what you could try is to completely uninstall and reinstall the iqsharp tool by doing the following:</p>

<pre><code>dotnet tool uninstall -g Microsoft.Quantum.IQSharp
dotnet tool install -g Microsoft.Quantum.IQSharp
dotnet iqsharp install
</code></pre>
",5/26/2020 17:00,Tooling,"The question is about an issue with the Q# kernel in Jupyter notebooks after updating the iqsharp package, which falls under the Tooling category",Tooling,,,,Tooling,
62048900.0,Unexpected keyword argument 'datatime' qiskit provider,"<p>I'm trying to set datatime calling backend.properties qiskit.</p>

<p>this is my code :</p>

<pre><code>from qiskit import *
from qiskit.providers.ibmq import *

provider = IBMQ.get_provider(hub='ibm-q')
provider.backends(simulator=False)
backend = provider.get_backend(name)
prp = backend.properties(datatime=datatime).to_dict()
</code></pre>

<p>I'm getting this error : <strong>TypeError: properties() got an unexpected keyword argument 'datatime'</strong>.
If I use refresh = True and not datatime in propertis, the code works.</p>
",<quantum-computing><qiskit>,5/27/2020 17:11,62049287.0,62049287.0,"<p>The keyword is <code>datetime</code>, not <code>datatime</code>. </p>
",5/27/2020 17:31,Errors,"The question is about a TypeError encountered while trying to use the properties method in Qiskit, which falls under the Errors category.",Errors,,,,Errors,
62161231.0,In quantum computing is there a preference to usage of little endian or big endian?,"<p>I've been learning quantum computing related concepts over the past few months. We've generally used the big endian notation while solving problems on paper.</p>

<p>Recently on starting to code I find that at a lot of places the little endian notation is used. I see the same in Quantum Katas by Microsoft and also in Qiskit. On paper, however, thinking in terms of Little endian reverses the order of tensor products, etc. So sometimes it gets confusing.</p>

<p><strong>Is there any particular trend on using little endian in quantum computing softwares (QDK, Qiskit, etc) or any reason for the same?</strong></p>

<p>Any suggestions in terms of what is the best way to think (in the above context), that can help while developing quantum algos to problems and smoothly translating them into code are welcome.</p>
",<quantum-computing>,06/02/2020 20:52,62184514.0,62184514.0,"<p>I believe the preference in the user code is mostly dictated by the notation used by two sources: the libraries and the books/papers detailing the topic; and the preference in the libraries is dictated by the notation in the books/papers used to implement the libraries. </p>

<p>For example, quantum Fourier transform as described in Nielsen and Chuang uses big endian notation for input/output registers; so if a library uses this book as a reference (as the first part of the QFT kata does), it is likely to use big endian notation as well. </p>

<p>I don't think there is a quantum-specific reason to prefer little endian over big endian or vice versa, at some level it's an arbitrary choice informed by the notation preferred by the sources.</p>
",06/03/2020 23:38,Conceptual ,"The user is seeking an explanation and clarification regarding the use of little endian notation in quantum computing software like QDK and Qiskit, which falls under the category of concept explanation to understand the reasoning behind the notation choice and how to think effectively in this context.",Conceptual,,,,Conceptual ,
62258987.0,How can I change the format of the Qubit IDs of the Q# DumpMachine?,"<p>In Q#, the DumpMachine function gives an overview of the state of the quantum system. Its output (in a Q# Jupyter Notebook) looks like this:</p>

<p><a href=""https://i.stack.imgur.com/dg1xX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dg1xX.png"" alt=""output of DumpMachine with basis states in little endian state""></a></p>

<p>Is there a way for me to change the way the basis states are represented? For example, in big endian, or even better, as a sequence of bits? (So: <code>|00&gt;, |01&gt;, |10&gt;, |11&gt;</code> instead of what I have above.)</p>
",<jupyter><q#>,06/08/2020 09:30,62261572.0,62261572.0,"<p>You can use the <a href=""https://learn.microsoft.com/en-us/qsharp/api/iqsharp-magic/config"" rel=""nofollow noreferrer""><code>%config</code> magic command</a> to change this setting.</p>

<p>For example, to configure <code>DumpMachine</code> to represent basis states as bit strings, you can use:</p>

<pre><code>%config dump.basisStateLabelingConvention=""Bitstring""
</code></pre>

<p>Supported options are <code>""LittleEndian""</code>, <code>""BigEndian""</code>, and <code>""Bitstring""</code>.</p>
",06/08/2020 11:59,Tooling,"The user is inquiring about the customization options for the output representation of basis states when using the DumpMachine function in Q#, which pertains to the functionality and tools available within the Q# programming environment.",Tooling,,,,Tooling,
62313194.0,"WARNING: BLAS library not found, Qiskit Installation","<p>I'm trying to install Qiskit and am coming across an error:</p>

<pre><code>****************************************************************
*** WARNING: BLAS library not found.
* You can include the BLAS library in the global environment LDFLAGS, eg
*   export LDFLAGS='-L/path/to/blas/lib -lblas'
* or specify the BLAS library path in  PYSCF_INC_DIR
*   export PYSCF_INC_DIR=/path/to/blas/lib:/path/to/other/lib
****************************************************************
</code></pre>

<p>I'm on Mac OS El Capitan, and using Python 3.7.</p>

<p>If it helps, I ran <code>np.__config__</code> to see if I had BLAS installed, and it seemed to work since it returned this:</p>

<pre class=""lang-py prettyprint-override""><code>openblas_lapack_info:
libraries = ['openblas', 'openblas']
library_dirs = ['/usr/local/lib']
language = c
define_macros = [('HAVE_CBLAS', None)]
</code></pre>

<p>So I think this is just an issue with my Qiskit installation. Does anyone know how to fix this?</p>
",<python><qiskit>,06/10/2020 21:11,62353111.0,62353111.0,"<p>I got same error and I'm with Sierra.</p>

<p>Assuming you already created and activated an environment with Anaconda, try to run</p>

<pre class=""lang-sh prettyprint-override""><code>conda install -c pyscf pyscf
</code></pre>

<p>and then again:</p>

<pre class=""lang-sh prettyprint-override""><code>pip install qiskit
</code></pre>

<p>I got the solution from <a href=""https://sunqm.github.io/pyscf/install.html"" rel=""nofollow noreferrer"">PySCF's docs</a>.</p>
",06/12/2020 22:04,Errors,"The user is encountering an error related to the installation of Qiskit, specifically regarding the BLAS library, which falls under the 'Errors' category.",Errors,,,,Errors,
62343587.0,Q# Program does not contain a static 'Main' method suitable for an entry point,"<p>I'm creating a program in <code>Q#</code>. </p>

<blockquote>
  <p>Problem</p>
</blockquote>

<p>You are given two qubits in state |00â©. Your task is to create the following state on them:
1/3ââ(|00â©+|01â©+|10â©)
You have to implement an operation which takes an array of 2 qubits as an input and has no output. The ""output"" of your solution is the state in which it left the input qubits.</p>

<blockquote>
  <p>Code </p>
</blockquote>

<pre class=""lang-cs prettyprint-override""><code>namespace Solution {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Convert;

    operation Solve (qs : Qubit[]) : Unit
    {
        body
        {
            Ry(ArcCos(Sqrt(2.0/3.0))*2.0,qs[0]);
            (ControlledOnInt(0,H))([qs[0]],qs[1]);
        }
    }    
}
</code></pre>

<p>But when I run it show me the following error.</p>

<blockquote>
  <p>Error</p>
</blockquote>

<pre><code>CSC : error CS5001: Program does not contain a static 'Main' method suitable for an entry point 

[C:\Users\Pawar\Desktop\HK\codeforces\Q#\Solution\Solution.csproj]
</code></pre>

<p>So I tried to put <code>EntryPoint()</code> before the method declaration . Which shows me different error as </p>

<blockquote>
  <p>error QS6231: Invalid entry point. Values of type Qubit may not be used as arguments or return values to entry points. [C:\Users\Pawar\Desktop\HK\codeforces\Q#\Solution\Solution.csproj]</p>
</blockquote>

<p>Please help me how to run it properly ? 
thanks âï¸ </p>
",<.net-core><q#>,06/12/2020 11:43,62347725.0,62347725.0,"<p>In order to run a Q# program as an executable, you need to have an <code>@EntryPoint()</code> operation defined. You can read more in this excellent blog post: <a href=""https://qsharp.community/blog/qsharp-entrypoint/"" rel=""nofollow noreferrer"">https://qsharp.community/blog/qsharp-entrypoint/</a>.</p>

<p>Specifically, in your case, the error message indicates that <code>Qubit[]</code> is not a valid parameter to the main entry point of your program. Which makes sense, because it doesn't make sense to pass an array of qubits when executing a program from the command line. And also, your operation doesn't print anything or return any results, so you won't be able to see what it's doing.</p>

<p>You should probably create an <code>@EntryPoint()</code> wrapper operation that invokes your existing operation with the appropriate parameters, maybe prints some diagnostics, and then returns some result. In your case, you could perhaps do something like this (note the additional namespaces you need to open):</p>

<pre><code>    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Measurement;

    @EntryPoint()
    operation SolveForTwoQubits() : Result[]
    {
        using (qubits = Qubit[2])
        {
            Solve(qubits);                 // invoke your existing Solve operation
            DumpMachine();                 // outputs the state of your qubits
            let results = MultiM(qubits);  // measure the qubits
            ResetAll(qubits);              // reset the qubits to the initial state
            return results;                // return the measured results
        }
    } 
</code></pre>

<p>This will give some output that looks like:</p>

<pre><code># wave function for qubits with ids (least to most significant): 0;1
â£0â­:     0.577350 +  0.000000 i  ==     *******              [ 0.333333 ]     --- [  0.00000 rad ]
â£1â­:     0.577350 +  0.000000 i  ==     *******              [ 0.333333 ]     --- [  0.00000 rad ]
â£2â­:     0.577350 +  0.000000 i  ==     *******              [ 0.333333 ]     --- [  0.00000 rad ]
â£3â­:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
[Zero,One]
</code></pre>
",06/12/2020 15:42,Errors ,"The user is encountering errors related to the entry point and Qubit usage in a Q# program, which falls under the 'Errors' category.",Errors,,,,Errors ,
62409919.0,How does DenseLayout in qiskit's transpiler work?,"<p>I'm looking for an explanation about the Dense Layout algorithm used by qiskit's transpiler.</p>

<p>I saw the source code, but still I don't understand what <code>""""""Choose a Layout by finding the most connected subset of qubits""""""</code> means!</p>

<p>Is there a paper about this kind of mapping algorithm or other resource I can learn about it from? </p>
",<layout><mapping><qiskit>,6/16/2020 13:40,62419747.0,62419747.0,"<p>It does a breadth first search for a connected subset starting at each qubit. The subset with the most connectivity is selected. Due to symmetry there are many subsets with same connectivity. However, it also looks at the noise in the device and picks the subset with the least amount of noise. Finally that set is run through a reverse cuthill mckee traversal to reorder the qubits in the set for a lower degree.</p>

<p>There is no paper on it as I came up with it to solve a bug in earlier versions of the Qiskit swap mapper.  </p>
",6/17/2020 0:47,Learning,"The user is specifically looking for resources or explanations to understand the Dense Layout algorithm used in Qiskit's transpiler, which aligns with the 'Learning' category.",Learning,,,,Learning,
62437494.0,Cannot create Q# Quantum Application in Visual Studio,"<p>I'm going to create Q# application for the first time. I installed the ""Microsoft Quantum Development Kit"" and I have .not core 3.1.301 (the latest)
I use VS 2019 Community Edition.</p>

<p>In VS, I see the Q# Application when creating new solution but when I try to create , I get below error:</p>

<blockquote>
  <p>The project file cannot be opened by the project system, because it is
  missing some critical imports or the referenced SDK cannot be found.</p>
  
  <p>Detailed Information: The SDK resolver ""NuGetSdkResolver"" failed to
  run. Unable to find fallback package folder
  'C:\Microsoft\Xamarin\NuGet\'.</p>
  
  <p>C:\Program Files\dotnet\sdk\3.1.301\Sdks\Microsoft.Quantum.Sdk\Sdk not
  found. Check that a recent enough .NET Core SDK is installed and/or
  increase the version specified in global.json.</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/ByEKk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ByEKk.png"" alt=""enter image description here""></a></p>

<p>I could not find any solution over the web.</p>
",<visual-studio-2019><quantum-computing><q#>,6/17/2020 20:05,62445037.0,62445037.0,"<p>The Quantum.SDK is not distributed with the extension, instead is downloaded the first time you try to build/create the Q# application.
Looks like Visual Studio is having problems downloading it using NuGet. I can think of two reasons:
 1. You are not connected to the internet, so it can't connect to nuget.org to download the package
 2. The error points to a missing ""C:\Microsoft\Xamarin\NuGet\"", I would suggest creating this folder.</p>
",6/18/2020 7:52,Errors,"The user is encountering an error message when trying to create a Q# application in Visual Studio, indicating issues with the project file and missing SDK components. This falls under the 'Errors' category.",Errors,,,,Errors,
62483556.0,Query regarding surprising Behavior in Controlled operations in QDK,"<p>I have been learning QDK and I observe the provided output for the following program:</p>
<p>Program:
'''</p>
<pre><code>operation BitIsOne( qs : Qubit[] ): Unit is  Adj+Ctl
{
    Message( &quot;Is One&quot; );
    X(qs[0]);                                        // added in update
}

operation BitIsZero( qs: Qubit[] ): Unit is Adj+Ctl
{
    Message( &quot;Is Zero&quot; );
}

operation RandomBehavior( qs: Qubit[] ) : Unit is Adj+Ctl
{
    X( qs[0] );
    Controlled BitIsZero( [qs[0]], Rest( qs ) );
    X( qs[0] );
    Controlled BitIsOne( [qs[0]], Rest( qs ) );
    DumpMachine(&quot;&quot;);                                 // added in update
}
 
operation TestFunc3() : Unit is Adj+Ctl
{
    using( qs = Qubit[3] )
    {
        RandomBehavior( qs[0..1] );  
    }
}

@EntryPoint()
operation Start2() : Unit {
    Message(&quot; Started Execution&quot;);
    TestFunc3();
}
</code></pre>
<p>Output:</p>
<pre><code>Started Execution
Is Zero
Is One
</code></pre>
<p>I do not understand why is <strong>Is One</strong> printed here? The input qubit i thought were 00, so why did the second controlled operation execute the <em>BitIsOne</em> function?</p>
<p><strong>Update to provide requested info that supports explanation in Answer</strong>
(Code edits to get info and confirm explanation included)</p>
<p><a href=""https://i.stack.imgur.com/7N3ah.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7N3ah.png"" alt=""Output of DumpMachine. Had changed the BitIsOne function to include X(qs[0]). This shows that the quantum operation did not execute in the else part but the classical function &quot;Message&quot; did execute."" /></a></p>
<p>Had changed the <em>BitIsOne</em> function to include X(qs[0]). This shows that the quantum operation did not execute in the else part but the classical function &quot;Message&quot; did execute.</p>
",<quantum-computing>,6/20/2020 8:38,62488459.0,62488459.0,"<p>Try measuring the qubits at the end and share the result. Should be 00, in spite of what got printed. &quot;Control&quot; in quantum does not behave like a classical IF statement, in that both the &quot;THEN&quot; part and the &quot;ELSE&quot; part get &quot;executed&quot;. The non-quantum &quot;Message&quot; statement gets &quot;executed&quot; in the &quot;ELSE&quot; part, even though in quantum terms the &quot;ELSE&quot; part is a &quot;No-Op&quot; (Identity).</p>
",6/20/2020 16:19,Errors,"The question is about an unexpected output from a Q# program, which falls under the Errors category.",Errors,,,,Errors,
62745277.0,How to access the AST generated by the Q# compiler?,"<p><strong>Background</strong></p>
<p>Part of the project I'm working on requires me to analyze Q# source code and perform specific actions when certain syntax elements are encountered. For example, say I'd like to count how many different gate types are used throughout the program. Now, this could be implemented by walking the Abstract Syntax Tree of the program and performing actions based on the current syntax node.</p>
<p><strong>What I've tried</strong></p>
<p>I've started by analyzing the <a href=""https://github.com/microsoft/qsharp-compiler"" rel=""nofollow noreferrer"">qsharp-compiler</a> repository, however, the inner workings of the compiler lack online documentation and browsing all the C# and F# sources can be really tedious.</p>
<p>Of course, I could write my own parser for the language, but that would probably be an overkill for the task at hand. There <em>has to</em> be a way to extract the AST from inside of the compiler.</p>
<p><strong>The question</strong></p>
<p>Is there a way to compile Q# source code using the Q# compiler programmatically (from C# or F#), and extract the internal AST?</p>
",<c#><abstract-syntax-tree><quantum-computing><q#>,07/05/2020 19:13,62747936.0,62747936.0,"<p>Yes, it is perfectly possible to compile Q# source code programmatically. This is particularly useful if you want to repeatedly update a compilation - you can add/remove/edit (parts of) the sources and references in memory, and query all kinds of useful information about the current state of the compilation that e.g. an IDE cares about (like e.g. which symbols are defined at a particular location in a certain file).</p>
<p>However, if you just want to process the AST for a Q# compilation, then there is a much easier way! The Q# compiler has an extensibility mechanism that I believe fits your need perfectly.
This <a href=""https://devblogs.microsoft.com/qsharp/extending-the-q-compiler/"" rel=""nofollow noreferrer"">blog post</a> gives a brief overview over the feature.
There is also an <a href=""https://github.com/microsoft/qsharp-compiler/tree/master/examples/CompilerExtensions"" rel=""nofollow noreferrer"">example</a> for an extension on the compiler repo. This <a href=""https://github.com/microsoft/qsharp-compiler/tree/master/src/QuantumSdk"" rel=""nofollow noreferrer"">readme</a> (and possibly <a href=""https://github.com/microsoft/qsharp-compiler/tree/master/examples/CompilerExtensions/ExtensionPackage"" rel=""nofollow noreferrer"">this one</a>) may also come in handy. I believe this answers half of your question, namely how to easily get access to the built AST.</p>
<p>The other half of the question according to my interpretation is how to conveniently analyze or transform the AST. For that there is also a mechanism provided; the syntax tree transformation framework. That framework consists of a couple of classes that define the walk/transformation for different kinds of nodes, as well as a wrapping class that plugs it all together.</p>
<p>Rather than starting by looking at the definition of the transformations, it is probably more intuitive to just look at some examples that use it. An example that is pretty close to what you want to do can be found <a href=""https://github.com/microsoft/qsharp-compiler/blob/master/examples/CompilerExtensions/CustomExtension/ListIdentifiers.cs"" rel=""nofollow noreferrer"">here</a>. The implemented transformation adds a comment to each callable listing all identifiers used within the callable. It is invoked as as part of a compilation step (see <a href=""https://github.com/microsoft/qsharp-compiler/blob/0b8cdb498711feddb211dcb0e83733e28c3a3f49/examples/CompilerExtensions/CustomExtension/Optimize.cs#L73"" rel=""nofollow noreferrer"">here</a>) that is defined in the example I already linked above.</p>
<p>There are a couple of other good examples for simple transformations that are a bit farther from what you want to do, but should give you an idea how the whole setup works if you are interested: <a href=""https://github.com/microsoft/qsharp-compiler/blob/master/src/QsCompiler/Transformations/Attributes.cs"" rel=""nofollow noreferrer"">this one</a> allows to attach attributes to callables, and <a href=""https://github.com/microsoft/qsharp-compiler/blob/master/src/QsCompiler/Transformations/Conjugations.cs"" rel=""nofollow noreferrer"">this one</a> is used to inline conjugations (pattern of the form U*VU).</p>
<p>Last but not least, the <a href=""https://gitter.im/qsharp-community/community"" rel=""nofollow noreferrer"">Gitter</a> for the <a href=""https://qsharp.community/"" rel=""nofollow noreferrer"">Q# community</a> can possibly also be a good resource to engage as you work.</p>
",07/06/2020 01:13,Tooling,The user is seeking information on how to programmatically compile Q# source code and extract the internal Abstract Syntax Tree (AST) from within the Q# compiler. This question pertains to the tooling and development process for working with the Q# language.,Tooling,,,,Tooling,
63097579.0,Q# unit testing to check phase,"<p>I want to test a phase oracle by testing if the phase of qubit flipped.
I tried to do it by</p>
<pre><code>AssertQubitIsInStateWithinTolerance((Complex(0., 0.), Complex(-1., 0.)), qubit, 1e-5);
</code></pre>
<p>But it doesn't really check the phase because the same input also worked for the test without phase</p>
<pre><code>AssertQubitIsInStateWithinTolerance((Complex(0., 0.), Complex(1., 0.)), qubit, 1e-5);
</code></pre>
<p>Is there a way to use unit tests to check the phase of qubit (or of the entire register)?</p>
<p>Thanks for the help.</p>
",<unit-testing><quantum-computing><q#>,7/26/2020 8:00,63108827.0,63108827.0,"<p>There is no physical way to observe a global phase of a quantum state, so you won't be able to distinguish |1â© state from -|1â© state. You'll need to find a way to convert this global phase to a relative phase, so that you can observe it.</p>
<ul>
<li>If you want to check whether a phase of a specific basis state |Ïâ© is flipped by your oracle, you can use a modification of phase kickback trick: prepare a state (|0â© + |1â©) â |Ïâ©, apply a controlled version of your oracle (with the first qubit as the control), and check which state you got on the first qubit: if it is still |0â© + |1â©, the oracle doesn't flip the phase of the state, and if it changed to |0â© - |1â©, the phase of the state is flipped. (You can do this measurement using <code>Measure([PauliX], [q])</code> operation).</li>
<li>If you want to check the phases of all, you can prepare a superposition of all basis states, apply your oracle and compare the state with the state you'd expect to obtain. You can do this by applying explicit Control Z gates to flip the phases of states you know need to be flipped - this should give you a superposition of all basis states again. You can check that it did by applying H gate to each qubit of the register and using <a href=""https://learn.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.diagnostics.assertallzero"" rel=""nofollow noreferrer"">AssertAllZero</a> operation to check that the result is an all-zero state.</li>
</ul>
<p>You can check the testing harnesses in the <a href=""https://github.com/microsoft/QuantumKatas/"" rel=""nofollow noreferrer"">Quantum Katas</a> for examples of these approaches; they test a lot of different quantum conditions, so they are a good source for testing approaches.</p>
",7/27/2020 4:43,Tooling,"The user is seeking guidance on how to use unit tests to check the phase of a qubit or an entire quantum register, which falls under the category of tooling and testing within quantum development.",Tooling,,,,Tooling,
63155929.0,How can I train a TensorFlow Quantum model that outputs a state vector?,"<p>I want to train a simple circuit in TFQ using a Sequential model as follows:</p>
<pre><code>model = tf.keras.Sequential()
model.add(tf.keras.layers.Input(shape=(), dtype=tf.dtypes.string))
model.add(
    tfq.layers.PQC(
        model_circuit=circuit,
        operators=readout_op))
</code></pre>
<p>But instead of performing a readout op, I'd like the model to output the state vector so I can do some post-processing on it before I feed it into my loss function.</p>
<p>In principle, tfq.layers.State looks like it's appropriate for this task, but it is not clear to me from the examples how I would use the State layer in a model context, vs just using it to <em>generate</em> the state vector as shown in the docs:</p>
<pre><code>state_layer = tfq.layers.State()
alphas = tf.reshape(tf.range(0, 1.1, delta=0.5), (3, 1)) # FIXME: #805
state_layer(parametrized_bell_circuit,
    symbol_names=[alpha], symbol_values=alphas)
</code></pre>
<p><strong>So my questions:</strong></p>
<ul>
<li>can I force the  PQC layer to output the state vector instead of performing a readout operation?</li>
<li>can I use the State layer as a parameterized layer in a Sequential model (or train it in any other way?)</li>
<li>or is there any alternative way that my model outputs a state vector?</li>
</ul>
",<quantum-computing><tensorflow-quantum>,7/29/2020 14:28,63269070.0,63269070.0,"<blockquote>
<p>can I force the PQC layer to output the state vector instead of performing a readout operation?</p>
</blockquote>
<p>The PQC layer will create and manage <code>tf.Variable</code>s for you. From there it will send your circuits through a <code>tfq.layers.Expectation</code> layer. Unfortunately there is no way to produce a full state vector from this layer.</p>
<blockquote>
<p>can I use the State layer as a parameterized layer in a Sequential model (or train it in any other way?)</p>
</blockquote>
<p>Yes, you can incorporate the state vector of input circuits into your model with the <code>tfq.layers.State</code> layer (<a href=""https://www.tensorflow.org/quantum/api_docs/python/tfq/layers/State"" rel=""nofollow noreferrer"">https://www.tensorflow.org/quantum/api_docs/python/tfq/layers/State</a>). Note that the produced state vector will NOT be differentiable. When creating TFQ we wanted to encourage users doing any complex modelling to try and make use of functionality that would have a 1:1 translation between a real chip and simulation (i.e. It is very easy to deploy <code>tfq.layers.Expectation</code> logic onto a true chip since we aren't breaking any rules, but with <code>tfq.layers.State</code> we are cheating and pulling out the full state vector).</p>
",08/05/2020 16:00,API Usage,"The question primarily focuses on how to use specific functions in the TensorFlow Quantum (TFQ) API to achieve a specific outcome, which falls under the 'API Usage' category.",API Usage,,,,API Usage,
63283443.0,My qiskit code's output differ from the Lecturer: Ryan OâDonnell,"<p><a href=""https://i.stack.imgur.com/hAmTq.jpg"" rel=""nofollow noreferrer"">My qiskit code's output differ from the Lecturer: Ryan OâDonnell</a></p>
<p>I am testing the table shown in attached image by using qiskit in python3.8.5 and qiskit version {'qiskit-terra': '0.14.2', 'qiskit-aer': '0.5.2', 'qiskit-ignis': '0.3.3', 'qiskit-ibmq-provider': '0.7.2', 'qiskit-aqua': '0.7.3', 'qiskit': '0.19.6'}</p>
<p>my code is :</p>
<pre><code>from qiskit import QuantumCircuit, assemble
from qiskit import Aer, execute
from qiskit.tools.visualization import plot_histogram
bit = 3
bit_lst = list(range(bit))
circuit = QuantumCircuit(bit, bit)
circuit.reset(0)
circuit.reset(1)
circuit.reset(2)
circuit.x(0)
circuit.x(1)    
circuit.ccx(0,1,2)
circuit.barrier()
circuit.measure(bit_lst,bit_lst)
circuit.draw(output='mpl')
backend = Aer.get_backend('statevector_simulator')
statevector=backend.run(assemble(circuit)).result().get_statevector()
print(statevector)
backend = Aer.get_backend('qasm_simulator')
counts1=backend.run(assemble(circuit)).result().get_counts()
print(counts1)

with open('result.txt', 'a') as f:
    print(f'011 - {statevector} - {counts1}', file=f)

plot_histogram([counts1], legend=['Simulator'])
</code></pre>
<p>result.txt file output is: 011 - [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j] - {'111': 1024}</p>
<p>as per the table the out put must be <strong>011</strong> but the output from the code is <strong>111</strong> is it my code or my knowledge of qubit?</p>
<p>to check wether its just a bit flip i change my code:</p>
<pre><code>from qiskit import QuantumCircuit, assemble
from qiskit import Aer, execute
from qiskit.tools.visualization import plot_histogram
bit = 3
bit_lst = list(range(bit))
circuit = QuantumCircuit(bit, bit)
circuit.reset(0)
circuit.reset(1)
circuit.reset(2)

def bit_000():
    pass
def bit_001():
    circuit.x(0)
def bit_010():
    circuit.x(1)
def bit_011():
    circuit.x(0)
    circuit.x(1)    
def bit_100():
    circuit.x(2)
def bit_101():
    circuit.x(0)
    circuit.x(2)
def bit_110():
    circuit.x(1)
    circuit.x(2)
def bit_111():
    circuit.x(0)
    circuit.x(1)
    circuit.x(2)

func_lst = [bit_000, bit_001, bit_010, bit_011, bit_100, bit_101, bit_110, bit_111]
for fn in func_lst:
    fn()
    circuit.ccx(0,1,2)
    circuit.barrier()
    circuit.measure(bit_lst,bit_lst)
    circuit.draw(output='mpl')
    backend = Aer.get_backend('statevector_simulator')
    statevector=backend.run(assemble(circuit)).result().get_statevector()
    print(statevector)
    backend = Aer.get_backend('qasm_simulator')
    counts1=backend.run(assemble(circuit)).result().get_counts()
    print(counts1)

    with open('result.txt', 'a') as f:
        print(f'{fn} - {statevector} - {counts1}', file=f)

    plot_histogram([counts1], legend=['Simulator'])
</code></pre>
<p>result file new out put is:
&lt;function bit_000 at 0x0000028334B761F0&gt; - [1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] - {'000': 1024}</p>
<p>&lt;function bit_001 at 0x000002833524E820&gt; - [0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] - {'001': 1024}</p>
<p>&lt;function bit_010 at 0x0000028349D6CAF0&gt; - [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j] - {'111': 1024}</p>
<p>&lt;function bit_011 at 0x0000028349D6CB80&gt; - [0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j] - {'100': 1024}</p>
<p>&lt;function bit_100 at 0x0000028349D6CC10&gt; - [1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] - {'000': 1024}</p>
<p>&lt;function bit_101 at 0x0000028349D6CCA0&gt; - [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j] - {'101': 1024}</p>
<p>&lt;function bit_110 at 0x0000028349D6CD30&gt; - [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j] - {'111': 1024}</p>
<p>&lt;function bit_111 at 0x0000028349D6CDC0&gt; - [1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] - {'000': 1024}</p>
<p>didnt care about a cleaner result, Sorry. and not able to add code in reply sorry.</p>
",<python-3.x><qiskit>,08/06/2020 12:16,63285836.0,63285836.0,"<p>Ahh, I think I see the issue. In the table from lecturer Ryan O'Donnell, the state is read from the first qubit to the last qubit. For example, the state |110&gt; means that the qubit labelled q_0 is in state |1&gt;, q_1 is in state |1&gt; and q_2 is in state |0&gt;. In Qiskit, the label convention is reversed. So, in Qiskit, |110&gt; would actually be read as |011&gt;, since the state is read from the last to the first qubit. So, your code and output is correct, since in Ryan O'Donnell's table, your state |011&gt; is |110&gt;. If this doesn't make sense, let me know.</p>
<p>As to your new code, the reason why you are getting different results than expected is that as you run your for loop, instead of creating new circuits, you are consistently adding to an existing circuit. For example, when applying the first function, bit_000, you apply to ccx gate, barrier, and measure. Then calling bit_001, you add an x gate to q_0 and do the same thing. So far everything is good. Then you add an x gate to q_1 and do the same procedure, but you get the resulting state vector '111'. That is because in qiskit, it thinks there is an x gate on the first and second qubit, so when you apply the ccx gate, you get the result you get. So really, by applying all of those circuit operations, you've made one big circuit instead of 8 isolated circuits. I would initialize all the qubits to the state |0&gt; after each time you measure, which will give you a clean slate to work off for the next circuit. With that edit, you should get the results that are written in Ryan O'Donnell's lecture. Hope this helps!</p>
",08/06/2020 14:31,Errors,"The question is about an unexpected output from a Qiskit program, which falls under the Errors category",Errors,,,,Errors,
63549444.0,Multiclass classification using TensorFlow Quantum,"<p>I am running some examples and tests on TensorFlow Quantum (TFQ) and I am struggling to perform a multi-class classification. I will used the MNIST classification example as base (<a href=""https://www.tensorflow.org/quantum/tutorials/mnist"" rel=""nofollow noreferrer"">https://www.tensorflow.org/quantum/tutorials/mnist</a>), since this is where I am starting from too.</p>
<p>For binary classification I played with the different examples of classes and different gates combination, and the classification result is obtained by measuring a single readout qubit (qR)result, thus if qR=0 we classify with class 0 and if qR=1 then we have class 1.</p>
<p>I extended it to a multi-class problems, so we have a 4 classes (0,1,2,3). To do this I change the labels of the classes with <code>tf.keras.utils.to_categorical(y_train)</code>, such that the labels get converted from single values to vectors (0 -&gt; (1,0,0,0); 1-&gt; (0,1,0,0); etc..), use <code>tf.keras.losses.CategoricalHinge()</code> as loss of the model and create 4 readouts qubits, one for each class (M(qR0, qR1, qR2, qR3) = (0,0,1,0) -&gt; class 2), and this works.</p>
<p>However, this method increases massively the size of the circuit. So what I want to do is to pass to TFQ only 2 readout qubits and use the combined measurement for the 4 classes classification (|00&gt; = 0, |10&gt; = 1, |01&gt; = 2, |11&gt; = 3). Ideally this would allow a 2^n multi-class classification, where n is the number of qubits. In Cirq I can achieved this output by performing a <code>cirq.measure(qR0, qR1, key='measure')</code> on the two readout qubits. However I am struggling in passing such command to TFQ, since from what I understand it measures only the qubits that end with a single qubit Pauli gate.</p>
<p>So, is there something that I am missing in the functionalities of TFQ that allows such kind of measurements in the training process?</p>
",<tensorflow><multiclass-classification><quantum-computing><tensorflow-quantum><cirq>,8/23/2020 16:33,63557185.0,63557185.0,"<p>Starting with this snippet:</p>
<pre class=""lang-py prettyprint-override""><code>bit = cirq.GridQubit(0, 0)
symbols = sympy.symbols('x, y, z')

# !This is important!
ops = [-1.0 * cirq.Z(bit), cirq.X(bit) + 2.0 * cirq.Z(bit)]
# !This is important!

circuit_list = [
    _gen_single_bit_rotation_problem(bit, symbols),
    cirq.Circuit(
        cirq.Z(bit) ** symbols[0],
        cirq.X(bit) ** symbols[1],
        cirq.Z(bit) ** symbols[2]
    ),
    cirq.Circuit(
        cirq.X(bit) ** symbols[0],
        cirq.Z(bit) ** symbols[1],
        cirq.X(bit) ** symbols[2]
    )
]
expectation_layer = tfq.layers.Expectation()
output = expectation_layer(
    circuit_list, symbol_names=symbols, operators = ops)
# Here output[i][j] corresponds to the expectation of all the ops
# in ops w.r.t circuits[i] where keras managed variables are
# placed in the symbols 'x', 'y', 'z'.
tf.shape(output)

</code></pre>
<p>Which I took from here: <a href=""https://www.tensorflow.org/quantum/api_docs/python/tfq/layers/Expectation"" rel=""nofollow noreferrer"">https://www.tensorflow.org/quantum/api_docs/python/tfq/layers/Expectation</a> .</p>
<p>The shape of the <code>output</code> tensor is <code>[3, 2]</code> Where I have 3 different circuits and I took two expectation values over each circuit. The value at <code>[1, 0]</code> of <code>output</code> would be:</p>
<p><a href=""https://i.stack.imgur.com/wvvWa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wvvWa.png"" alt=""U value 0"" /></a></p>
<p><a href=""https://i.stack.imgur.com/ycRMD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ycRMD.png"" alt=""enter image description here"" /></a></p>
<p>Then the value at <code>[2, 1]</code> of <code>output</code> would be:</p>
<p><a href=""https://i.stack.imgur.com/tbYrj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tbYrj.png"" alt=""U value"" /></a></p>
<p><a href=""https://i.stack.imgur.com/N6eZU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/N6eZU.png"" alt=""enter image description here"" /></a></p>
<p>The shape and contents of <code>output</code>'s values are partly dictated by the shape and contents of <code>ops</code>. If I wanted to make the output shape <code>[3, 3]</code> I could just add another valid <code>cirq.PauliSum</code> object to the <code>ops</code> list. In your case if you want the probability of getting 00, 01, 10, 11, on two particular <code>cirq.GridQubit</code>s <code>q0</code> and <code>q1</code> you can do something like this:</p>
<pre class=""lang-py prettyprint-override""><code>def zero_proj(qubit):
  return (1 + cirq.Z(qubit)) / 2

def one_proj(qubit):
  return (1 - cirq.Z(qubit)) / 2

# ! This is important
ops = [
  zero_proj(q0) * zero_proj(q1),
  zero_proj(q0) * one_proj(q1),
  one_proj(q0) * zero_proj(q1),
  one_proj(q0)* one_proj(q1)
]
# ! This is important

</code></pre>
<p>Making the output shape of any layer that ingests  <code>ops</code>: <code>[whatever_your_batch_size_is, 4]</code>. Does this help clear things up ?</p>
",8/24/2020 8:18,API Usage,"The question is about how to use specific functions in the TensorFlow Quantum (TFQ) API to perform multi-class classification with only 2 readout qubits, which falls under the API Usage category. ",Tooling,The user is asking about a specific functionality (performing multi-class classification with 2 readout qubits) in a quantum computing tool (TensorFlow Quantum),No,19.0,API Usage,"This is because the user is specifically asking about how to utilize specific functionalities within TensorFlow Quantum (TFQ) to achieve multi-class classification with only 2 readout qubits, indicating a need for understanding and using the API effectively."
63586962.0,What could be the benefit of such a complicated function to test if variable is not zero?,"<p>I'm working on my master's thesis (computer science) on code which is written for post-quantum-secure signatures. The whole thing can be found <a href=""https://csrc.nist.gov/projects/post-quantum-cryptography"" rel=""nofollow noreferrer"">here</a> but is not important here. For my thesis I tried to explain a 'simple' function, which is not so simple at all.</p>
<p>The function tests, if a variable is non-zero in the <a href=""/questions/tagged/galois-field"" class=""post-tag"" title=""show questions tagged &#39;galois-field&#39;"" rel=""tag"">galois-field</a> GF(16). (GF(16) here can be understood as 4-bit unsigned integers). This function looks as follows:</p>
<pre><code>static inline uint8_t gf16_is_nonzero(uint8_t a) {
    unsigned a4 = a &amp; 0xf; // mask lowest 4 bits of a
    unsigned r = 0u - a4;  // set 4 high bits if a is nonzero
    r &gt;&gt;= 4;               // right-shift high bits into low bits
    return r &amp; 1;          // return lowest bit
}
</code></pre>
<p>I understood how it works but I don't understand why this function needs to be <em>this</em> complex. Could there be a good reason for that? Good reasons could be performance or secureness (e.g. safety against timing attacks) benefits. Because if there are no such benefits, wouldn't it be smarter to write that function in an easy manner like:</p>
<pre><code>static inline uint8_t gf16_is_nonzero(uint8_t a) {
    return (a &amp; 15) != 0;
}
</code></pre>
<h3>EDITS</h3>
<p>This code is not written by me, it is written by crypto-researches, who are trying to get their PQ-algorithm standardized by NIST.</p>
<p>An easier approach for the second code snippet was suggested by TonyDelroy in the comments.</p>
",<c><performance><bit-manipulation><galois-field><post-quantum-cryptography>,8/25/2020 20:55,63587021.0,63587021.0,"<p>The reason for this code is because it is <strong>branchless</strong>.</p>
<p>Testing for a condition tends to be an expensive operation, whereas addition, subtraction, and bitwise operators are not.</p>
<p>This however is premature optimization.  With <code>-O3</code>, the first function compiles to this:</p>
<pre><code>andl    $15, %edi
negl    %edi
shrl    $31, %edi
movl    %edi, %eax
ret
</code></pre>
<p>While the second function compiles to this:</p>
<pre><code>andl    $15, %edi
setne   %al
ret
</code></pre>
<p>The moral of the story: write code that clearly states your intentions and let the compiler figure out the rest.</p>
",8/25/2020 20:59,Theoretical,The question is about the design and implementation of a function to test if a variable is non-zero in the Galois field GF(16). This is a theoretical question because it is about the underlying principles of the function and the reasons for its design.,Theoretical,,,,Theoretical,
63609099.0,Are random numbers generated using a quantum integer as its seed considered pseudo-random or truly random?,"<p>I always hear that random numbers produced by quantum computers are considered <strong>&quot;truly random&quot;</strong> while random numbers generated from a classical computer are considered <strong>&quot;pseudo-random&quot;</strong>.</p>
<p>If one were to  generate random numbers using a quantum integer as the <strong>seed</strong>, would the numbers generated from that <strong>seed</strong> be considered <strong>&quot;pseudo-random&quot;</strong> or <strong>truly random</strong>? Cannot find this clarification anywhere, any explanation welcome.</p>
<pre class=""lang-py prettyprint-override""><code>import random
random.seed(get_my_quantum_number()) #Some quantum integer generated from an API.
random.random() #Is this &quot;pseudo-random&quot; or &quot;truly random&quot; ?
</code></pre>
",<python><random><quantum-computing>,8/27/2020 4:17,63609174.0,63609174.0,"<p><code>random.random()</code> uses a pseudorandom number generator (PRNG), which uses a deterministic algorithm by definition and mathematically expands its input. Thus, the numbers it generates are pseudorandom, even if it was seeded by the output of a quantum random number generator or some other nondeterministic source.</p>
<p>A seed is a value that initializes the PRNG, and the number of possible sequences a PRNG can generate depends on the PRNG's state size and the size of the seed. For example, if the seed or the state is only 32 bits long, at most 2<sup>32</sup> different pseudorandom number sequences are possible with that PRNG, regardless of where the seed came from.</p>
<p>See also these questions:</p>
<ul>
<li><a href=""https://stackoverflow.com/questions/57234728/is-random-function-in-any-programming-language-biased"">Is Random function (in any programming language) biased?</a></li>
<li><a href=""https://stackoverflow.com/questions/62375129/how-to-get-truly-random-data-not-random-data-fed-into-a-prng-seed-like-csrngs"">How to get truly random data, not random data fed into a PRNG seed like CSRNG&#39;s do?</a></li>
</ul>
<hr />
<p>In any case, the distinction between &quot;pseudorandom&quot; and &quot;truly random&quot; numbers is not what applications care about (and you didn't really specify what kind of application you have in mind). Instead, in general:</p>
<ul>
<li>Security applications care whether the numbers are hard to guess; in this case, only a cryptographic RNG can achieve this requirement (even one that relies on a pseudorandom number generator). A Python example is the <code>secrets</code> module or <code>random.SystemRandom</code>.</li>
<li>Scientific simulations care whether the numbers behave like independent uniform random numbers, and often care whether the numbers are reproducible at a later time. A Python example is <code>numpy.random.Generator</code>.</li>
</ul>
<p>For example, the pseudorandom number generator used by <code>random.random()</code>, Mersenne Twister, is not suitable for cryptography or information security; the numbers it produces are not designed to be hard to guess, and this is the case no matter how that generator was seeded (whether by a quantum random number generator or otherwise).</p>
<p>By contrast, pseudorandom generators designed for information security often involve cryptographic hash functions, block ciphers, or stream ciphers â especially because one goal is to make future pseudorandom numbers hard to guess, even if the generator's outputs are known.</p>
",8/27/2020 4:25,Theoretical,"The question is about the difference between truly random and pseudo-random numbers, and whether using a quantum integer as the seed for a pseudo-random number generator would result in truly random numbers. This is a theoretical question about the nature of randomness and the capabilities of quantum computers.", Theoretical,,,,Theoretical,
63791332.0,Timeout when trying to install Qiskit on macOS,"<p>I am trying to install Qiskit 0.20.0 on my machine running macOS and seeing the below error</p>
<pre><code>pip install qiskit
Collecting qiskit
  Using cached qiskit-0.20.0.tar.gz (4.0 kB)
Collecting qiskit-terra==0.15.1
  Downloading qiskit_terra-0.15.1-cp38-cp38-macosx_10_9_x86_64.whl (7.6 MB)
     |âââ                             | 522 kB 7.7 kB/s eta 0:15:22ERROR: Exception:
Traceback (most recent call last):
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py&quot;, line 437, in _error_catcher
    yield
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py&quot;, line 519, in read
    data = self._fp.read(amt) if not fp_closed else b&quot;&quot;
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/filewrapper.py&quot;, line 62, in read
    data = self.__fp.read(amt)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/http/client.py&quot;, line 458, in read
    n = self.readinto(b)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/http/client.py&quot;, line 502, in readinto
    n = self.fp.readinto(b)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/socket.py&quot;, line 669, in readinto
    return self._sock.recv_into(b)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/ssl.py&quot;, line 1241, in recv_into
    return self.read(nbytes, buffer)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/ssl.py&quot;, line 1099, in read
    return self._sslobj.read(len, buffer)
socket.timeout: The read operation timed out

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/cli/base_command.py&quot;, line 216, in _main
    status = self.run(options, args)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/cli/req_command.py&quot;, line 182, in wrapper
    return func(self, options, args)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/commands/install.py&quot;, line 324, in run
    requirement_set = resolver.resolve(
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/resolution/legacy/resolver.py&quot;, line 183, in resolve
    discovered_reqs.extend(self._resolve_one(requirement_set, req))
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/resolution/legacy/resolver.py&quot;, line 388, in _resolve_one
    abstract_dist = self._get_abstract_dist_for(req_to_install)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/resolution/legacy/resolver.py&quot;, line 340, in _get_abstract_dist_for
    abstract_dist = self.preparer.prepare_linked_requirement(req)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/operations/prepare.py&quot;, line 467, in prepare_linked_requirement
    local_file = unpack_url(
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/operations/prepare.py&quot;, line 255, in unpack_url
    file = get_http_url(
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/operations/prepare.py&quot;, line 129, in get_http_url
    from_path, content_type = _download_http_url(
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/operations/prepare.py&quot;, line 282, in _download_http_url
    for chunk in download.chunks:
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/cli/progress_bars.py&quot;, line 168, in iter
    for x in it:
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_internal/network/utils.py&quot;, line 64, in response_chunks
    for chunk in response.raw.stream(
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py&quot;, line 576, in stream
    data = self.read(amt=amt, decode_content=decode_content)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py&quot;, line 541, in read
    raise IncompleteRead(self._fp_bytes_read, self.length_remaining)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/contextlib.py&quot;, line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File &quot;/usr/local/anaconda3/envs/qiskit_env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py&quot;, line 442, in _error_catcher
    raise ReadTimeoutError(self._pool, None, &quot;Read timed out.&quot;)
pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out.
</code></pre>
<p>The anaconda version on my machine is 4.8.4 and Python version is 3.8.5.</p>
<p>I have followed the instructions mentioned <a href=""https://qiskit.org/documentation/install.html"" rel=""nofollow noreferrer"">here</a> and created a virtual environment before running</p>
<pre><code>pip install qiskit
</code></pre>
",<macos><quantum-computing><qiskit>,09/08/2020 09:47,63793302.0,63793302.0,"<p>This looks like it's just a network issue. The error is a timeout trying to read from <code>files.pythonhosted.org</code> when <code>pip</code> was downloading the <code>qiskit-terra</code> package from PyPI. There isn't really anything you can do except to try again in such cases. If you're on a slow and/or unreliable internet connection it might take several tries take a few tries for the download of all the qiskit packages (and their dependencies) to succeed.</p>
",09/08/2020 11:50,Errors,"The question is about encountering an error while trying to install Qiskit 0.20.0 on macOS using pip, and it seeks a solution to this installation issue.", Errors ,,,,Errors,
64538775.0,Q# : QDK Errors,"<p>I've recently tried to install the <code>QDK</code> via the <code>VSCode</code> extension in my <code>Windows 10</code> Desktop and <code>VSCode</code> wasn't able to find the Microsoft libraries even after I was able to execute the code by the <code>dotnet</code> run command on the terminal. The code was the sample project code described in the create new project part of the tutorial. I also didn't have <code>.NET SDK</code> so I installed it but it seems to be working fine. In computers I got problems all the code, all related to not finding the namespaces.</p>
<pre><code>namespace QuantumRNG {
open Microsoft.Quantum.Canon;
open Microsoft.Quantum.Intrinsic;
open Microsoft.Quantum.Measurement;
open Microsoft.Quantum.Math;
open Microsoft.Quantum.Convert;

operation GenerateRandomBit() : Result {
    using (q = Qubit()) {
        H(q);
        return MResetZ(q);
    }
}

operation SampleRandomNumberInRange(max : Int) : Int {
    mutable output = 0;
    repeat {
        mutable bits = new Result[0];
        for (idxBit in 1..BitSizeI(max)) {
            set bits += [GenerateRandomBit()];
        }
        set output = ResultArrayAsInt(bits);
    } until (output &lt;= max);
    return output;
}

@EntryPoint()
operation SampleRandomNumber() : Int {
    let max = 50;
    Message($&quot;Sampling a random number between 0 and {max}: &quot;);
    return SampleRandomNumberInRange(max);
}
}
</code></pre>
",<visual-studio-code><q#>,10/26/2020 14:08,64602732.0,64602732.0,"<p>Do you see any error messages in the output console?
To see the output console select &quot;View: Toggle Output&quot; (Ctrl + Shift + U) and select &quot;Q# Language Extension&quot; from the drop down list.
If the drop down list doesn't show &quot;Q# Language Extension&quot; then it probably means that the language-server that gets downloaded on first run is still downloading, so give it a minute or so (depending on your internet connection).</p>
",10/30/2020 4:27,Errors,"The user is facing issues related to missing namespaces and libraries when trying to run a Q# project in Visual Studio Code on Windows 10, indicating a problem with the development environment setup, and seeks a solution to resolve this error.",Errors,,,,Errors,
64817371.0,How to loop several times within a list?,"<p>I have a code that looks like this,:</p>
<pre><code>import random
import numpy as np
from operator import itemgetter
import sys

equal_to = {&quot;a&quot;:&quot;u_plus&quot;, &quot;b&quot;:&quot;u_minus&quot;, &quot;c&quot;:&quot;v_plus&quot;, &quot;d&quot;:&quot;v_minus&quot;} #bell state

p = 8 #length of generated binary

key1 = [] #list of generated binary 
for i in range(p): 
    temp = random.randint(0,1)
    key1.append(temp) 

tmplist2 = [] #list of random sample_letters
for i in range(p):
    while True:
        attempt = str(random.choice(list(equal_to)))
        tmplist2.append(attempt)

        if attempt == 'b':
            break

#evaluate result of alice binary and bell state
def eva(alice, bell):
    if alice == 1:
        if bell == 'a' or bell == 'b':
            return 1
        elif bell == 'c' or bell == 'd':
            return 0
    elif alice == 0:
        if bell == 'c' or bell == 'd':
            return 1
        elif bell == 'a' or bell == 'b':
            return 0


for_bob = [] #list of generated binary and bell state through logic gate

for k in key1:
    for t in tmplist2:
        e = eva(k, t)
        for_bob.append(e)

#tr = [[eva(k,t) for t in tmplist2] for k in key1] #list comprehension split the key properly
print(&quot;generated random binary strings:&quot;, key1)
print(&quot;generated bell states:&quot;, tmplist2)
print(&quot;encrypted strings:&quot;, for_bob)
</code></pre>
<p>It printed out something like this:</p>
<pre><code>generated random binary strings:
  [0, 0, 0, 0, 0, 1, 1, 0]
generated bell states:
  ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b']
encrypted strings:
  [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0]
</code></pre>
<p>I was looking a way to loop within <code>tmplist2</code> without starting again from the beginning, if the string <em>'b'</em> came out.</p>
<p>The loop is supposed to function as follows:
<code>key1[0]</code> shall evaluate with <em>'b'</em>, returning to 0. Since <em>'b'</em> came out, outer loop should continue to next element <code>key1[1]</code> and it should evaluate with <em>'c'</em> and <em>'b'</em>, returning 1 0. Again because <em>'b'</em> came out, outer loop shall proceed to next element <code>key[2]</code> and evaluate itself with <em>'a'</em>, <em>'a'</em>, <em>'c'</em>, and <em>'b'</em>, returning 0 0 1 0. This should continue until <code>tmplist2</code> finished.</p>
<p>Anyone got solutions for the issue? I was searching the solution of how to loop within a loop and not returning to the beginning when a certain condition is given. In this case <em>'b'</em>.</p>
<p><em>n.b.: this program was meant to simulate quantum teleportation.</em></p>
",<python><quantum-computing>,11/13/2020 8:02,64818488.0,64818488.0,"<p>Main data</p>
<pre><code>for_bob = []
key1 = [0, 0, 0, 0, 0, 1, 1, 0]
tmplist2 = ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b']
</code></pre>
<p>Approach 1</p>
<pre><code>_tmp = tmplist2[:]
for k in key1:
    while _tmp:
        if _tmp[:1] != ['b']:
            for_bob.append(eva(k, *_tmp[:1]))
            _tmp = _tmp[1:]
        else:
            for_bob.append(eva(k, *_tmp[:1]))
            _tmp = _tmp[1:]
            break
</code></pre>
<p>Approach 2:</p>
<pre><code>_tmp = iter(tmplist2)

for i in key1:
    for j in iter(lambda: next(_tmp), None):
        if j != 'b':
            for_bob.append(eva(i, j))
        else:
            for_bob.append(eva(i, j))
            break
</code></pre>
<pre><code>generated random binary strings: [0, 0, 0, 0, 0, 1, 1, 0]
generated bell states: ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b']
encrypted strings: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]
</code></pre>
",11/13/2020 9:31,Tooling,"The user is looking for guidance on using a specific tool, TensorFlow Quantum (TFQ), to address a multi-class classification problem. They want to understand how to modify measurements within TFQ, which falls under tooling and software usage in quantum programming.",Tooling,,,,Tooling,
64843386.0,Passing complex objects to Q# operations,"<p>I want to pass a complex object to a Q# operation from Python code. I defined the same data structure on both sides: in Python as a <em>class</em> and in Q# as a <em>newtype</em>.
Than I prepared a JSON representation in Python of the complex object (exploiting the <strong>json</strong> package and <a href=""https://stackoverflow.com/a/35483750/14426869"">this answer</a>) and tried to pass it to a Q# operation, but I got the following error:</p>
<pre><code>Received invalid parameters. Please fix and try again:
n: Unexpected initial token 'String' when populating object. Expected JSON object or array. Path '', line 1, position 171.
</code></pre>
<p>This is the Python code</p>
<pre><code>import qsharp
import json
import inspect

from json.test import JsonTest

class ObjectEncoder(json.JSONEncoder):
    def default(self, obj):
        if hasattr(obj, &quot;to_json&quot;):
            return self.default(obj.to_json())
        elif hasattr(obj, &quot;__dict__&quot;):
            d = dict(
                (key, value)
                for key, value in inspect.getmembers(obj)
                if not key.startswith(&quot;__&quot;)
                and not inspect.isabstract(value)
                and not inspect.isbuiltin(value)
                and not inspect.isfunction(value)
                and not inspect.isgenerator(value)
                and not inspect.isgeneratorfunction(value)
                and not inspect.ismethod(value)
                and not inspect.ismethoddescriptor(value)
                and not inspect.isroutine(value)
            )
            return self.default(d)
        return obj

class U:
    x = 0
    y = 0
    z = 0
    def __init__(self, x, y, z) :
        self.x = x
        self.y = y
        self.z = z

class N:
    t = [U(0,0,0), U(3.14,0,0)]
    q = 3
    def __init__(self, t, q) :
        self.t = t
        self.q = q

obj = N([U(3.14, 0, 0), U(0, 3.14, 0)], 3)
jsonObj = json.dumps(obj, cls=ObjectEncoder, indent=2, sort_keys=False)
print(jsonObj)
JsonTest.simulate(n=jsonObj)
</code></pre>
<p>This is the JSON rtepresentation printed by that code</p>
<pre><code>{
  &quot;q&quot;: 3,
  &quot;t&quot;: [
    {
      &quot;x&quot;: 3.14,
      &quot;y&quot;: 0,
      &quot;z&quot;: 0
    },
    {
      &quot;x&quot;: 0,
      &quot;y&quot;: 3.14,
      &quot;z&quot;: 0
    }
  ]
}
</code></pre>
<p>This is the Q# code</p>
<pre><code>namespace json.test {

    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Intrinsic;

    newtype U = (
        x : Double,
        y : Double,
        z : Double  
    );

    newtype N = (
        t : U[],
        q : Int
    );

    operation JsonTest(n : N) : Int {
        let r = n::q * Length(n::t); // just do sometinhg
        Message($&quot;t = {n::t}  q = {n::q}&quot;);
        return r;
    }
}
</code></pre>
<p>Does Q# actually support JSON representation of complex objects?</p>
",<python><json><q#>,11/15/2020 10:34,64900796.0,64900796.0,"<p>Yes, Q# supports representing instances of these user-defined types via Python, but not using <code>dict</code>s or JSON strings. To use the Q# interface, we need to use <code>tuple</code>s instead. If you want a data structure that contains the labels you are using (<code>x</code>, <code>y</code>, <code>z</code> and so on), I would recommend using <code>namedtuple</code>s, for example:</p>
<pre class=""lang-py prettyprint-override""><code>from collections import namedtuple

U = namedtuple(&quot;U&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
N = namedtuple(&quot;N&quot;, [&quot;t&quot;, &quot;q&quot;])

obj = N(q=3, t=[U(x=3.14, y=0, z=0), U(x=0, y=3.14, z=0)])
</code></pre>
<p>such that</p>
<pre><code>&gt;&gt;&gt; obj
N(t=[U(x=3.14, y=0, z=0), U(x=0, y=3.14, z=0)], q=3)
</code></pre>
<p>You can then simply pass this to your compiled Q# program like so:</p>
<pre class=""lang-py prettyprint-override""><code>import qsharp

qsharp.compile(&quot;&quot;&quot;
open Microsoft.Quantum.Convert;
open Microsoft.Quantum.Intrinsic;

newtype U = (
    x: Double, 
    y: Double, 
    z: Double
);

newtype N = (
    t: U[],
    q: Int
);
&quot;&quot;&quot;)

JsonTest = qsharp.compile(&quot;&quot;&quot;
operation JsonTest(n : N) : Int {
    let r = n::q * Length(n::t); // just do sometinhg
    Message($&quot;t = {n::t}  q = {n::q}&quot;);
    return r;
}
&quot;&quot;&quot;)

from collections import namedtuple

U = namedtuple(&quot;U&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
N = namedtuple(&quot;N&quot;, [&quot;t&quot;, &quot;q&quot;])

obj = N(q=3, t=[U(x=3.14, y=0, z=0), U(x=0, y=3.14, z=0)])
JsonTest.simulate(n=obj)
</code></pre>
<p>which returns</p>
<pre><code>t = [U((3.14, 0, 0)),U((0, 3.14, 0))]  q = 3
6
</code></pre>
<p>If you want to use JSON strings, you can create a custom function like so:</p>
<pre><code>import json

def N_from_json(data: str):
    &quot;&quot;&quot;Create N object from JSON-formatted string
    &quot;&quot;&quot;
    _data = json.loads(data)
    t = _data.get(&quot;t&quot;, [])
    q = _data.get(&quot;q&quot;, 0) # Or some other default value of your choosing

    return N(t=[U(**_t) for _t in t], q=q)


jsonObj = json.dumps({
  &quot;t&quot;: [
    {
      &quot;x&quot;: 3.14,
      &quot;y&quot;: 0,
      &quot;z&quot;: 0
    },
    {
      &quot;x&quot;: 0,
      &quot;y&quot;: 3.14,
      &quot;z&quot;: 0
    }
  ],
  &quot;q&quot;: 3,
})

obj = N_from_json(jsonObj)
</code></pre>
",11/18/2020 20:23,Tooling,The user is encountering an issue when trying to pass a complex object from Python to a Q# operation using JSON representation. This question relates to the usage of tools and software (Python and Q#) to exchange complex data between them.,Tooling,,,,Tooling,
65025679.0,Is CSP Layout always the first algorithm used by qiskit transpiler to map quantum circuit?,"<p>I'm using Qiskit <a href=""https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html"" rel=""nofollow noreferrer""><code>transpile</code></a> with <code>optimization_level=3</code>. I was wondering if CSP layout selector is always the first algorithm tried by Qiskit, also if I set as <code>layout_method='noise_adaptive'</code> or other methods.</p>
<p>If not, how to force the transpiler to use CSP layout selector? I tried with <code>layout_method='csp_layout'</code>, but I get the following exception:</p>
<pre><code>qiskit.transpiler.exceptions.TranspilerError: 'Invalid layout method csp_layout.
</code></pre>
",<transpiler><qiskit>,11/26/2020 16:16,65026003.0,65026003.0,"<h3>For Qiskit 0.23 or earlier (qiskit-terra 0.16)</h3>
<p>The answer is <em>yes</em>, <code>CSPLayout</code> will run in optimization level 2 or higher, even if a <code>layout_method</code> is provided.</p>
<p>This file constructs the pass manager for optimization level 3:
<a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/transpiler/preset_passmanagers/level3.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/transpiler/preset_passmanagers/level3.py</a></p>
<p>Currently, the first choice for layout selector is always <code>CSPLayout(coupling_map, call_limit=10000, time_limit=60)</code> and the possible options for <code>layout_method</code> (if CSP layout does not find a solution) are <code>'trivial'</code>, <code>'dense'</code>, <code>'noise_adaptive'</code>, and <code>'sabre'</code>.</p>
<hr />
<h3>For Qiskit 0.24 or latter (qiskit-terra 0.17)</h3>
<p>With the merge of <a href=""https://github.com/Qiskit/qiskit-terra/pull/5495"" rel=""nofollow noreferrer"">PR #5495</a>, the answer is <em>it depends</em>. <code>CSPLayout</code> runs in level 2 and 3. If <code>layout_method</code> is provided, then that method will be used.</p>
",11/26/2020 16:35,Tooling," The question is related to the behavior and options of the Qiskit transpiler, specifically regarding layout selection algorithms and methods. It falls under the ""Tooling"" category as it pertains to the usage of tools and software in quantum programming.",Tooling,,,,Tooling,
65254223.0,Set random seed for cirq functions,"<p>I am working with cirq and use a random unitary for testing purposes with:</p>
<pre><code>random_matrix = cirq.testing.random_unitary(dim=4)
</code></pre>
<p>where can can the random seed for this function be set, using <code>random.seed(a=1)</code> does not seem to do this.</p>
",<linear-algebra><quantum-computing><cirq>,12/11/2020 15:34,65254479.0,65254479.0,"<p>Cirq relies on numpy for its random functions, so using:</p>
<pre><code>np.random.seed(2)
</code></pre>
<p>Sets the seed for cirq</p>
",12/11/2020 15:50,Tooling,"The question is related to setting a random seed for generating a random unitary matrix in Cirq, which falls under the ""Tooling"" category as it pertains to using the Cirq library for quantum programming and testing purposes.",Tooling,,,,Tooling,
65733183.0,qbit collapse before Quantum Teleportation,"<p>I have been tweaking with quantum teleportation in python qiskit. One extra thing that I have done in the following diagram is the measurement of q330 at the very beggining.</p>
<p><a href=""https://i.stack.imgur.com/RmTl2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RmTl2.png"" alt=""enter image description here"" /></a></p>
<p>I am doing this because I wanted to see if the measurement is always same for q33<sub>0</sub> and q33<sub>2</sub>. But that is not possible later part because q33<sub>0</sub> gets modified.</p>
<p>One alternative way is to introduce a q33<sub>3</sub> and get it entangled with q33<sub>0</sub> and measure q33<sub>3</sub> later along with q33<sub>2</sub>.</p>
<p>My question:
I am a bit doubtful that my current implementation is wrong because I am collapsing q33<sub>0</sub> before the teleportation. That's not what you do teleportation for, right? You keep it's wave property and collapse it later on when needed. I want some comments on my doubt. Than you :)</p>
",<python><quantum-computing><qiskit>,1/15/2021 9:03,65734274.0,65734274.0,"<p>Your intuition about what you did is correct, a measure on the first qubit has no place here.<br />
The &quot;correct&quot; way to see if the teleportation works, since here you know the quantum state you want to send, is to do many shots of your circuit to get lots of measures of the final qubits, and then see if the count probabilities match the initial state you sent. On a simulator without any noise, it should work perfectly, and on a machine you would expect some errors due to the noise.</p>
<p>By the way, introducing this q33_3 in order to copy the first qubit in it to verify if they are the same is not possible due to the no-cloning theorem.</p>
<p>Also, on your circuit, you forgot a Hadamard gate at the beginning of your circuit, on q33_1, right before the CNOT gate. Without the H gate, you don't create the entangled Bell state crucial to the protocol so your circuit won't work the way it is.</p>
<p>If you have any other question please feel free to ask ! Also know that there exists a Stack community especially for quantum computing here if you have any question in the future <a href=""https://quantumcomputing.stackexchange.com"">https://quantumcomputing.stackexchange.com</a> :)</p>
",1/15/2021 10:18, Conceptual,The question pertains to the conceptual understanding of quantum teleportation and the implications of measuring qubit q330 at the very beginning of the process. It seeks clarification on whether measuring q330 before teleportation is a correct approach from a quantum mechanics perspective.,Conceptual,,,, Conceptual,
65801600.0,Is there a way to install Qutip on apple m1 macbook?,"<p>I bought a new apple m1 macbook pro. I installed python and other basic packages like numpy, scikit-learn and matplotlib though miniforge. When I tried installing qutip through conda it shows no such package exists on the osx-arm64 channel.</p>
<p>Is there a way to install the  x86-64 version of Qutip through rosetta 2?</p>
",<macos><anaconda><conda><qutip>,1/20/2021 0:42,65999696.0,65999696.0,"<p>In short, yes. QuTip can be installed using rosetta. It is, however, not free of complications. I found myself in the same situation, with a new M1 mac.</p>
<p>In my case, I had to create a new installation of miniforge (THE x86_64 VERSION) and download every package (matplotlib, cython, numpy, scipy, jupyter and qutip). QuTiP could be found because I was using the standard channels instead of the new arm64 channel. In order to be able to import qutip some additional steps have to be taken. If one tries to import qutip a couple of errors appear, to which the solution has been given in <a href=""https://github.com/qutip/qutip/issues/1396#issuecomment-759733240"" rel=""nofollow noreferrer"">https://github.com/qutip/qutip/issues/1396#issuecomment-759733240</a> .</p>
<p>Basically, you first need to install ipython. The following line worked for me: <code>conda install -c anaconda ipython</code>. Secondly, you have to find the <code>hardware_info.py</code> document in your qutip files. In my case it was in <code>/diego/miniforge3/lib/python3.8/site-packages/qutip/hardware_info.py</code>. Once found, comment the following lines:
<code>results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string')</code>
<code>.readlines()[0].split('@')[1][:-4])*1000)})</code></p>
<p>With that done, I have a fully operational installation of jupyter notebook with qutip. Addressing the situation described in the question, I don't know if it is possible to download qutip from the regular x86_64 channels while having installed miniforge with the arm64 installer. Maybe someone who knows more than me can add further information about it.</p>
",02/01/2021 20:28,Tooling,"The question is related to the installation of the x86-64 version of Qutip on an Apple M1 MacBook Pro using Rosetta 2, which falls under the category of tooling as it involves software installation and compatibility on a specific hardware platform.",Tooling,,,,Tooling,
65907671.0,How is a Unitary matrix a permutation?- Quantum pattern matching,"<p>I'm reading a <a href=""https://arxiv.org/abs/quant-ph/0508237"" rel=""nofollow noreferrer"">paper</a> on quantum pattern matching and here it talks about a unitary matrix U which represents the oracle that flips a state's amplitude as a permutation over the computational basis. See page 3 right side fourth paragraph under equation (7).</p>
<p>Can someone explain to me what that means?</p>
",<pattern-matching><permutation><quantum-computing><basis>,1/26/2021 19:05,65908938.0,65908938.0,"<p>The unitary defined by equation (7) is a permutation because it sends every computational basis state to another computational basis state (as opposed to some superposition of computational basis states). In the matrix form, every column of U is filled with zeros except for one entry equal to one (and similarly for rows by invertibility). In other words, it is a <a href=""https://en.wikipedia.org/wiki/Permutation_matrix"" rel=""nofollow noreferrer"">permutation matrix</a>.</p>
<p>Specifically, U sends the computational basis state |x<sub>0</sub>, x<sub>1</sub>, ..., x<sub>n</sub>â© to the computational basis state |y, x<sub>1</sub>, ..., x<sub>n</sub>â© where y = f(x<sub>1</sub>, ..., x<sub>n</sub>) if x<sub>0</sub> = 0 and y = 1-f(x<sub>1</sub>, ..., x<sub>n</sub>) if x<sub>0</sub> = 1. See equation (6).</p>
<hr />
<p>Note that U does not flip the phase of any state. However, if we act with U on the state</p>
<p>|0, x<sub>1</sub>, ..., x<sub>n</sub>â© - |1, x<sub>1</sub>, ..., x<sub>n</sub>â©</p>
<p>(where we neglect normalization) then the result is</p>
<p>(-1)^f(x<sub>1</sub>, ..., x<sub>n</sub>) (|0, x<sub>1</sub>, ..., x<sub>n</sub>â© - |1, x<sub>1</sub>, ..., x<sub>n</sub>â©)</p>
<p>where the phase is flipped if and only if f(x<sub>1</sub>, ..., x<sub>n</sub>) = 1. This is an example of <a href=""https://qiskit.org/textbook/ch-gates/phase-kickback.html"" rel=""nofollow noreferrer"">phase kickback</a>.</p>
",1/26/2021 20:38,Theoretical,"The question pertains to understanding a concept in a quantum computing research paper, specifically related to unitary matrices and their representation as oracles in the context of quantum pattern matching. It falls under the category of 'Theoretical' as it involves theoretical concepts and principles in quantum computing.",Theoretical,,,,Theoretical,
66007061.0,"Why can't I create a Q#create project on VisualStudio Code with QDK || ISSUE :command ""'quantum.newProject' failed.)""","<p>help regarding the issue below would be really appreciated :</p>
<p><code>Command 'Q#: Create new project...' resulted in an error (Running the contributed command: 'quantum.newProject' failed.)</code></p>
<p>I was trying to follow this exercice : <a href=""https://learn.microsoft.com/fr-fr/learn/modules/qsharp-create-first-quantum-development-kit/2-install-quantum-development-kit-code"" rel=""nofollow noreferrer"">https://learn.microsoft.com/fr-fr/learn/modules/qsharp-create-first-quantum-development-kit/2-install-quantum-development-kit-code</a></p>
<p>after downloading and running the latest versions of .NET CORE, VSCODE, I can run &quot;Q# Install command line project templates&quot; but can't run &quot;Q# Create a new project :  <a href=""https://i.stack.imgur.com/xPK5Q.png"" rel=""nofollow noreferrer"">See screenshot1</a> <a href=""https://i.stack.imgur.com/ZYAYg.png"" rel=""nofollow noreferrer"">screenshot 2</a> <a href=""https://i.stack.imgur.com/F7isA.png"" rel=""nofollow noreferrer"">CODE SOURCE ERROR</a>
I already done this exercice in May last year but for some reasons I get stuck at the very beginning of the process now.</p>
<p>Could it be a version issue ? I remember that the tutorial was different (May 2020) than the one above I shared to you. Unfortunately I can't find the previous tutorial as it has been updated since.</p>
<p>I tried to uninstall the latest versions to reinstall the versions I downloaded in May : useless, I get the same issue.</p>
<p>Many thanks for you help !</p>
",<.net-core><visual-studio-code><quantum-computing><q#><new-project>,02/02/2021 09:40,66011477.0,66011477.0,"<p>I decided to go with an older version v0.14.2011120240</p>
<p>It seems the new version isn't stable yet.</p>
",02/02/2021 14:15,Errors ,"The user is encountering an error when trying to create a new quantum project in Visual Studio Code, and they are seeking a solution to this specific problem. This falls under the category of 'Errors' in programming.",Errors,,,,Errors ,
66071608.0,Distance Estimation Using Quantum Computer,"<p>I did a small benchmarking to compare quantum version of algorithm to its classical version, and I found that quantum computing taking so much time in comparison to classical version.</p>
<p>I don't understand why its happening, it should be either similar to classical or better.</p>
<p>DataSet Explanation: 1 test data point and 3 training data points, dimension = 2.
Goal: our goal is to classify the test data point in one of training data point category.</p>
<pre><code>import matplotlib.pyplot as plt
import pandas as pd
from numpy import pi
from qiskit import Aer, execute
from qiskit import QuantumCircuit
from qiskit import QuantumRegister, ClassicalRegister
from qiskit import IBMQ
import os
import time

# IBMQ Configure
# IBMQ.save_account(os.environ.get('IBM'))
# IBMQ.load_account()
# provider = IBMQ.get_provider('ibm-q')
# qcomp = provider.get_backend('ibmq_16_melbourne')
##

fig, ax = plt.subplots()
ax.set(xlabel='Data Feature 1', ylabel='Data Feature 2')

# Get the data from the .csv file
data = pd.read_csv('data.csv',
                   usecols=['Feature 1', 'Feature 2', 'Class'])

# Create binary variables to filter data
isGreen = data['Class'] == 'Green'
isBlue = data['Class'] == 'Blue'
isBlack = data['Class'] == 'Black'

# Filter data
greenData = data[isGreen].drop(['Class'], axis=1)
blueData = data[isBlue].drop(['Class'], axis=1)
blackData = data[isBlack].drop(['Class'], axis=1)

# This is the point we need to classify
y_p = 0.141
x_p = -0.161

# Finding the x-coords of the centroids
xgc = sum(greenData['Feature 1']) / len(greenData['Feature 1'])
xbc = sum(blueData['Feature 1']) / len(blueData['Feature 1'])
xkc = sum(blackData['Feature 1']) / len(blackData['Feature 1'])

# Finding the y-coords of the centroids
ygc = sum(greenData['Feature 2']) / len(greenData['Feature 2'])
ybc = sum(blueData['Feature 2']) / len(blueData['Feature 2'])
ykc = sum(blackData['Feature 2']) / len(blackData['Feature 2'])

# Plotting the centroids
plt.plot(xgc, ygc, 'gx')
plt.plot(xbc, ybc, 'bx')
plt.plot(xkc, ykc, 'kx')

# Plotting the new data point
plt.plot(x_p, y_p, 'ro')

# Setting the axis ranges
plt.axis([-1, 1, -1, 1])

plt.show()

# Calculating theta and phi values
phi_list = [((x + 1) * pi / 2) for x in [x_p, xgc, xbc, xkc]]
theta_list = [((x + 1) * pi / 2) for x in [y_p, ygc, ybc, ykc]]

#----- quantum start time -------#
st = time.time()
# Create a 2 qubit QuantumRegister - two for the vectors, and
# one for the ancillary qubit
qreg = QuantumRegister(3)

# Create a one bit ClassicalRegister to hold the result
# of the measurements
creg = ClassicalRegister(1)

qc = QuantumCircuit(qreg, creg, name='qc')

# Get backend using the Aer provider
backend = Aer.get_backend('qasm_simulator')

# Create list to hold the results
results_list = []

# Estimating distances from the new point to the centroids
for i in range(1, 4):
    # Apply a Hadamard to the ancillary
    qc.h(qreg[2])

    # Encode new point and centroid
    qc.u(theta_list[0], phi_list[0], 0, qreg[0])
    qc.u(theta_list[i], phi_list[i], 0, qreg[1])

    # Perform controlled swap
    qc.cswap(qreg[2], qreg[0], qreg[1])
    # Apply second Hadamard to ancillary
    qc.h(qreg[2])

    # Measure ancillary
    qc.measure(qreg[2], creg[0])

    # run on quantum computer
    # job = execute(qc, backend=qcomp, shots=1024)
    # job_monitor(job)

    # Reset qubits
    qc.reset(qreg)

    # Register and execute job
    job = execute(qc, backend=backend, shots=1024)
    result = job.result().get_counts(qc)
    results_list.append(result['1'])

et = time.time()
# --------- end time ----------

print(results_list)
print('final circuit fig')
print(qc.draw())

# Create a list to hold the possible classes
class_list = ['Green', 'Blue', 'Black']

# Find out which class the new data point belongs to 
# according to our distance estimation algorithm
quantum_p_class = class_list[results_list.index(min(results_list))]

# Find out which class the new data point belongs to 
# according to classical euclidean distance calculation

# classical start time
cst = time.time()
distances_list = [((x_p - i[0]) ** 2 + (y_p - i[1]) ** 2) ** 0.5 for i in [(xgc, ygc), (xbc, ybc), (xkc, ykc)]]
cet = time.time()

classical_p_class = class_list[distances_list.index(min(distances_list))]


# Print time taken
print(&quot;classical time =&gt; &quot;, cet-cst)
print(&quot;quantum time =&gt; &quot;, et-st)

# Print results
print(&quot;&quot;&quot;According to our distance algorithm, the new data point belongs to the&quot;&quot;&quot;, quantum_p_class, 'class.\n')
print('Euclidean distances: ', distances_list, '\n')
print(&quot;&quot;&quot;According to euclidean distance calculations, the new data point belongs to the&quot;&quot;&quot;, classical_p_class,
      'class.')


</code></pre>
<p>Output:</p>
<pre><code>classical time =&gt;  **1.0967254638671875e-05**
quantum time =&gt;  **0.2530648708343506**  // more time
According to our distance algorithm, the new data point belongs to the Blue class.

Euclidean distances:  [0.520285324797846, 0.4905204028376393, 0.7014755294377704] 

According to euclidean distance calculations, the new data point belongs to the Blue class.

</code></pre>
<p>I am not able to understand, why quantum computing taking so much time.</p>
",<python><machine-learning><euclidean-distance><quantum-computing>,02/05/2021 22:46,66084306.0,66084306.0,"<p>I am a physicist and programmer who has worked extensively on Qiskit. I have limited experience with things like machine learning but if I am not mistaken <a href=""https://arxiv.org/pdf/1401.2142.pdf"" rel=""nofollow noreferrer"">figure 13 on page 22 of this paper on Nearest-Neighbor methods</a> is precisely the circuit you are creating.</p>
<p>You have a dramatic performance hit because you are simulating quantum hardware using classical algorithms. This is commented out:</p>
<pre><code># IBMQ Configure
# IBMQ.save_account(os.environ.get('IBM'))
# IBMQ.load_account()
# provider = IBMQ.get_provider('ibm-q')
# qcomp = provider.get_backend('ibmq_16_melbourne')
</code></pre>
<p>Where the &quot;ibmq_16_melbourne&quot; refers to a physical quantum computer with <a href=""https://www.researchgate.net/figure/a-IBM-Q16-Melbourne-architecture-b-Previous-available-IBM-Q20-Tokyo-architecture_fig2_340963391"" rel=""nofollow noreferrer"">the ibm architecture which is partially documented here</a>. That makes total sense because IBM restricts access for most accounts.  That is why later on you have this:</p>
<pre><code># Get backend using the Aer provider
backend = Aer.get_backend('qasm_simulator')
</code></pre>
<p>&quot;Aer&quot; refers to the <em><strong>quantum computer simulation software which is running locally on your client-side computer</strong></em>. To my knowledge there is not yet something in qiskit which could simulate a specific physical quantum computer. That is what would presumably tell you what the simulated/theoretical speedup would be (despite the fact that it would take longer to simulate on a classical computer).</p>
<p>IMPORTANT:
Many of the standards defined as part of the Qiskit ecosystem (like the OpenQASM format) are meant to be hardware agnostic. You can describe a circuit that has any two qubits interacting at any time. But the truth is a physical quantum computers of any size (in terms of 10+ qubits) will not have direct any-qubit-to-any-other-qubit connections. You have to swap things around in ways specific to that architecture (like the Melbourne 16-qubit architecture).</p>
",02/07/2021 03:34,Conceptual ,"The user is discussing the performance of quantum algorithms compared to classical ones, which falls under the Conceptual category in quantum programming",Conceptual ,,,,Conceptual ,
66148518.0,Quantum computing vs traditional base10 systems,"<p>This may show my naivetÃ© but it is my understanding that quantum computing's obstacle is stabilizing the qbits. I also understand that standard computers use binary (on/off); but it seems like it may be easier with today's tech to read electric states between 0 and 9. Binary was the answer because it was very hard to read the varying amounts of electricity, components degrade over time, and maybe maintaining a clean electrical &quot;signal&quot; was challenging.</p>
<p>But wouldn't it be easier to try to solve the problem of reading varying levels of electricity so we can go from 2 inputs to 10 and thereby increasing the smallest unit of storage and exponentially increasing the number of paths through the logic gates?
I know I am missing <strong>q</strong>uite a <strong>bit</strong> (sorry the puns were painful) so I would love to hear why or why not.
Thank you</p>
",<binary-data><quantum-computing>,02/11/2021 03:52,66260965.0,66260965.0,"<p>&quot;Exponentially increasing the number of paths through the logic gates&quot; is exactly the problem. More possible states for each n-ary digit means more transistors, larger gates and more complex CPUs. That's not to say no one is working on ternary and similar systems, but the reason binary is ubiquitous is its simplicity. For storage, more possible states also means we need more sensitive electronics for reading and writing, and a much higher error frequency during these operations. There's a lot of hype around using DNA (base-4) for storage, but this is more on account of the density and durability of the substrate.</p>
<p>You're correct, though that your question is missing <strong>qu</strong>ite a <strong>bit</strong> - qubits are entirely different from classical information, whether we use bits or digits. Classical bits and trits respectively correspond to vectors like</p>
<pre><code>Binary:  |0&gt; = [1,0];   |1&gt; = [0,1];
Ternary: |0&gt; = [1,0,0]; |1&gt; = [0,1,0];  |2&gt; = [0,0,1];
</code></pre>
<p>A qubit, on the other hand, can be a linear combination of classical states</p>
<pre><code>Qubit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt;
</code></pre>
<p>where Î± and Î² are arbitrary complex numbers such that such that |Î±|<sup>2</sup> + |Î²|<sup>2</sup> = 1.</p>
<p>This is called a superposition, meaning even a single qubit can be in one of an infinite number of states. Moreover, unless you prepared the qubit yourself or received some classical information about Î± and Î², there is no way to determine the values of Î± and Î². If you want to extract information from the qubit you must perform a <strong>measurement</strong>, which collapses the superposition and returns <code>|0&gt;</code> with probability |Î±|<sup>2</sup> and <code>|1&gt;</code> with probability |Î²|<sup>2</sup>.</p>
<p>We can extend the idea to qutrits (though, just like trits, these are even more difficult to effectively realize than qubits):</p>
<pre><code>Qutrit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt; + Î³ |2&gt;
</code></pre>
<p>These requirements mean that qubits are much more difficult to realize than classical bits of any base.</p>
",2/18/2021 13:29,Conceptual," The user is seeking an understanding of why quantum computing uses qubits instead of traditional analog values to represent information. They are exploring the idea of using analog values for computation and are looking for insights into why qubits are the chosen approach in quantum computing, which falls under the category of conceptual discussions about the underlying concepts of quantum computing.",Conceptual,,,,Conceptual,
66180030.0,QisKit: Difference on Statevector / No Difference on Vizualization,"<p>Why is there a difference in the state vectors, but there is no difference in the visualizations?<br/>
Is there any other visualization to show the differences?</p>
<p>qiskit: 0.23.3 <br />
python: 3.8</p>
<pre><code>circuit-1 + statevector:
q_0: 
[1.+0.j 0.+0.j] ==&gt; +1

circuit-2 + statevector
     âââââââââââââââââââââââââ
q_0: â¤ X ââ¤ H ââ¤ X ââ¤ H ââ¤ X â
     âââââââââââââââââââââââââ
[-1.+0.j -0.-0.j] ==&gt; -1
</code></pre>
<p>Code example</p>
<pre><code>import numpy as np
from qiskit import *
import qiskit.tools.visualization as vis
import matplotlib. pyplot as plt
from qiskit import Aer

circ = QuantumCircuit(1)

circ.x(0)
circ.h(0)
circ.x(0)
circ.h(0)
circ.x(0)

backend = Aer.get_backend('statevector_simulator')
result = execute(circ, backend).result()
statevector = result.get_statevector()

vis.plot_bloch_multivector(statevector)
vis.plot_state_city(statevector)
vis.plot_state_qsphere(statevector)
vis.plot_state_paulivec(statevector)
circ.draw(output='mpl')
print(np.around(statevector,5))
plt.show()
</code></pre>
<p><strong>The visualizations of the the two statevectors are equal!!</strong>
<a href=""https://i.stack.imgur.com/wg23v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wg23v.png"" alt=""example 1"" /></a>
<a href=""https://i.stack.imgur.com/ULBGE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ULBGE.png"" alt=""example 2"" /></a></p>
",<python><visualization><qiskit>,02/12/2021 22:49,66193718.0,66193718.0,"<p>It seems like a bug to me (I reported <a href=""https://github.com/Qiskit/qiskit-terra/issues/5845"" rel=""nofollow noreferrer"">here</a>)</p>
<p>In any case, I recommend you <a href=""https://nonhermitian.org/kaleido/"" rel=""nofollow noreferrer"">Kaleidoscope</a> to visualize states. It has interactive graphs. Here is your example (refactor for shortness):</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from kaleidoscope import qsphere

circ = QuantumCircuit(1)

circ.x(0)
circ.h(0)
circ.x(0)
circ.h(0)
circ.x(0)

state = Statevector.from_instruction(circ)
qsphere(state)
</code></pre>
<p><a href=""https://i.stack.imgur.com/JwHlt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JwHlt.png"" alt=""enter image description here"" /></a></p>
<p>Compare the color with the other example:</p>
<pre><code>circ = QuantumCircuit(1)

state = Statevector.from_instruction(circ)
qsphere(state)
</code></pre>
<p><a href=""https://i.stack.imgur.com/G29AQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/G29AQ.png"" alt=""enter image description here"" /></a></p>
<p>The difference in color is the phase. In the first case is Ï.</p>
",2/14/2021 8:40,Conceptual,"The user is seeking an explanation for the difference in state vectors obtained from two quantum circuits and is also looking for alternative visualizations to represent these differences. This falls under the ""Conceptual"" category as it involves understanding the quantum state and visualizations in quantum computing.",Theoretical,"The question is about why the visualizations of two different state vectors are equal, even though the state vectors themselves are different. This is a theoretical question because it is about the underlying principles of quantum mechanics and quantum state vectors.",No,20.0,Conceptual,"This is because the user is seeking an explanation for the difference in state vectors obtained from two quantum circuits and is also looking for alternative visualizations to represent these differences, indicating a need for understanding the concepts and principles involved in quantum states and visualizations."
66193302.0,"QISKIT error - numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject","<p>I ran this</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
</code></pre>
<p>and got the below error</p>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-3-07258f5373b7&gt; in &lt;module&gt;
----&gt; 1 from qiskit import QuantumCircuit, execute, Aer
      2 from qiskit.visualization import plot_histogram

~\AppData\Roaming\Python\Python37\site-packages\qiskit\__init__.py in &lt;module&gt;
     55 # Try to import the Aer provider if installed.
     56 try:
---&gt; 57     from qiskit.providers.aer import Aer
     58 except ImportError:
     59     suppress_warnings = os.environ.get('QISKIT_SUPPRESS_PACKAGING_WARNINGS', '')

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\__init__.py in &lt;module&gt;
     62 
     63 # pylint: disable=wrong-import-position
---&gt; 64 from .aerprovider import AerProvider
     65 from .aerjob import AerJob
     66 from .aererror import AerError

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\aerprovider.py in &lt;module&gt;
     21 from .backends.statevector_simulator import StatevectorSimulator
     22 from .backends.unitary_simulator import UnitarySimulator
---&gt; 23 from .backends.pulse_simulator import PulseSimulator
     24 
     25 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\backends\__init__.py in &lt;module&gt;
     18 from .statevector_simulator import StatevectorSimulator
     19 from .unitary_simulator import UnitarySimulator
---&gt; 20 from .pulse_simulator import PulseSimulator

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\backends\pulse_simulator.py in &lt;module&gt;
     24 from ..version import __version__
     25 from ..aererror import AerError
---&gt; 26 from ..pulse.controllers.pulse_controller import pulse_controller
     27 from ..pulse.system_models.pulse_system_model import PulseSystemModel
     28 from .aerbackend import AerBackend

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\__init__.py in &lt;module&gt;
     50 from .qutip_extra_lite.cy import pyxbuilder as pbldr
     51 
---&gt; 52 from .system_models.duffing_model_generators import duffing_system_model
     53 from .system_models.pulse_system_model import PulseSystemModel
     54 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\system_models\duffing_model_generators.py in &lt;module&gt;
     19 from collections.abc import Iterable
     20 from qiskit.providers.models.backendconfiguration import UchannelLO
---&gt; 21 from .hamiltonian_model import HamiltonianModel
     22 from .pulse_system_model import PulseSystemModel
     23 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\system_models\hamiltonian_model.py in &lt;module&gt;
     20 import numpy.linalg as la
     21 from ...aererror import AerError
---&gt; 22 from .string_model_parser.string_model_parser import HamiltonianParser
     23 
     24 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\system_models\string_model_parser\string_model_parser.py in &lt;module&gt;
     21 import numpy as np
     22 from .apply_str_func_to_qobj import apply_func
---&gt; 23 from .qobj_from_string import gen_oper
     24 
     25 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\system_models\string_model_parser\qobj_from_string.py in &lt;module&gt;
     16 &quot;&quot;&quot;Module for creating quantum operators.&quot;&quot;&quot;
     17 
---&gt; 18 from ...qutip_extra_lite import qobj_generators
     19 
     20 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\qobj_generators.py in &lt;module&gt;
     17 
     18 import numpy as np
---&gt; 19 from . import operators as ops
     20 from . import states as st
     21 from . import tensor as ten

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\operators.py in &lt;module&gt;
     54 
     55 import numpy as np
---&gt; 56 from .fastsparse import fast_csr_matrix, fast_identity
     57 from .qobj import Qobj
     58 

~\AppData\Roaming\Python\Python37\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\fastsparse.py in &lt;module&gt;
    438 # -------------------------------------
    439 # pylint: disable=no-name-in-module, wrong-import-position, import-error
--&gt; 440 from .cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult)

spmath.pyx in init qiskit.providers.aer.pulse.qutip_extra_lite.cy.spmath()

ValueError: numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject
</code></pre>
<p>Any idea?</p>
<p>I installed numpy 1.16/1.17 and the latest one, still error is the same.<br />
python - 3.7.9
I run ML projects so versions are vital</p>
",<python><numpy><numpy-ndarray><qiskit>,2/14/2021 7:28,66209122.0,66209122.0,"<p>This is because the latest Qiskit Aer (0.7.4, Qiskit meta 0.23.5) was compiled with numpy 1.20.0, which is incompatible with older versions of numpy. See this issue: <a href=""https://github.com/Qiskit/qiskit-aer/issues/1120"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aer/issues/1120</a> for more details.</p>
<p>The workaround for now is to upgrade your numpy to 1.20.0.</p>
",2/15/2021 13:39,Errors,The user is encountering an error related to compatibility issues with the numpy library while trying to import Qiskit components. This falls under the category of 'Errors' in programming.,Errors,,,,Errors,
66197227.0,Return two numbers in Q Sharp (Q#) (Quantum Development Kit),"<p>So, basically, I did the tutorial to create a random number on the website of Microsoft Azure and now I am trying to add some functionalities, including their suggestion add a minimum number.</p>
<p>The initial code to generate just one number, max, is:</p>
<pre><code>   operation SampleRandomNumberInRange(max : Int) : Int {
        // mutable means variables that can change during computation
        mutable output = 0;
        // repeat loop to generate random numbers until it generates one that is less or equal to max
        repeat {
            mutable bits = new Result[0];
            for idxBit in 1..BitSizeI(max) {
                set bits += [GenerateRandomBit()];
            }
            // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer
            set output = ResultArrayAsInt(bits);
        } until (output &lt;= max);
        return output;
    }

    @EntryPoint()
    operation SampleRandomNumber() : Int {
        // let declares var which don't change during computation
        let max = 50;
        Message($&quot;Sampling a random number between 0 and {max}: &quot;);
        return SampleRandomNumberInRange(max);
    }
</code></pre>
<p>Everything works well. Now, I want to generate two numbers so I would like to create a function TwoSampleRandomNumbersInRange but I can't figure out how to make the function return a result such as &quot;Int, Int&quot;, I tried a few things including the follow:</p>
<pre><code>    operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int {
        // mutable means variables that can change during computation
        mutable output = 0;
        // repeat loop to generate random numbers until it generates one that is less or equal to max
        repeat {
            mutable bits = new Result[0];
             
            for idxBit in 1..BitSizeI(max) {
                set bits += [GenerateRandomBit()];
            }

            for idxBit in 1..BitSizeI(min) {
                set bits += [GenerateRandomBit()];
            }
            // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer
            set output = ResultArrayAsInt(bits);
        } until (output &gt;= min and output &lt;= max);
        return output;
    }
</code></pre>
<p>To generate two numbers, I tried this:</p>
<pre><code>operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int, Int {
//code here
}
</code></pre>
<p>...but the syntax for the output isn't right.</p>
<p>I also need the output:</p>
<pre><code>set output = ResultArrayAsInt(bits);
</code></pre>
<p>to have two numbers but ResultArrayAsInt, as the name says, just returns an Int. I need to return two integers.</p>
<p>Any help appreciated, thanks!</p>
",<azure><quantum-computing><q#>,2/14/2021 16:03,66199077.0,66199077.0,"<p>The return of an operation has to be a data type, in this case to represent a pair of integers you need a <em>tuple</em> of integers: <code>(Int, Int)</code>.</p>
<p>So the signature of your operation and the return statement will be</p>
<pre><code>operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : (Int, Int) {
    // code here
    return (integer1, integer2);
}
</code></pre>
",2/14/2021 19:09,Tooling,The user question is related to creating a quantum operation in the Microsoft Quantum Development Kit (Q#) and how to modify it to return two random numbers. This falls under the tooling category as it involves the usage and functionality of the Q# programming tools., Tooling,,,,Tooling,
66198976.0,ValueError: numpy.ndarray size changed on importing qiskit,"<p>While trying to run the following commands on Jupyter</p>
<pre><code>from qiskit import QuantumCircuit, Aer, BasicAer, execute
from qiskit.visualization import plot_histogram
</code></pre>
<p>I am encountering the following error.I am using python 3.8.
Does anyone have any idea how can this be resolved? I have tried upgrading numpy and reinstalling Qiskit but the problem prevails</p>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-3-a0c116756cb0&gt; in &lt;module&gt;
----&gt; 1 from qiskit import QuantumCircuit, Aer, BasicAer, execute
      2 from qiskit.visualization import plot_histogram

C:\ProgramData\Anaconda3\lib\site-packages\qiskit\__init__.py in &lt;module&gt;
     55 # Try to import the Aer provider if installed.
     56 try:
---&gt; 57     from qiskit.providers.aer import Aer
     58 except ImportError:
     59     suppress_warnings = os.environ.get('QISKIT_SUPPRESS_PACKAGING_WARNINGS', '')

C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\__init__.py in &lt;module&gt;
     62 
     63 # pylint: disable=wrong-import-position
---&gt; 64 from .aerprovider import AerProvider
     65 from .aerjob import AerJob
     66 from .aererror import AerError

...

C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\fastsparse.py in &lt;module&gt;
    438 # -------------------------------------
    439 # pylint: disable=no-name-in-module, wrong-import-position, import-error
--&gt; 440 from .cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult)

spmath.pyx in init qiskit.providers.aer.pulse.qutip_extra_lite.cy.spmath()

ValueError: numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject
</code></pre>
",<python><python-3.x><numpy><qiskit>,2/14/2021 18:59,66199810.0,66199810.0,"<p>worked after I used the following command</p>
<pre><code>pip install --ignore-installed qiskit-terra qiskit-aer
</code></pre>
",2/14/2021 20:28,Errors,"The error message indicates a problem related to the compatibility of numpy and qiskit, suggesting a potential issue with the installation or environment configuration. This falls under the ""Errors"" category as it involves seeking solutions and explanations for errors in quantum program development.",Errors,,,,Errors,
66288920.0,Can I have two iterables in the reduce function? (Python),"<p>Suppose I have the following command (using Python and Qiskit):</p>
<pre><code>a = reduce(lambda x,y: x.compose(y,c),circli, qcla)
</code></pre>
<p>(<code>qcla</code> is an initializer)</p>
<p>Here, <code>compose</code> is an internal qiskit function, x and y are elements of the list <code>circli</code> (iterable). I'm wondering is it possible for me to add another iterable in this <code>reduce</code> function? Here, <code>c</code> itself in <code>(y,c)</code> represents a coordinate, such as <code>[2,3]</code>, and I'm hoping to have it updated as well. Can I create another list containing all the possible <code>c</code>'s and add it as another iterable? Thanks!</p>
",<python><lambda><reduce><qiskit>,2/20/2021 7:01,66289038.0,66289038.0,"<p>It is possible to reduce a list (iterable) of pairs and also to create a pair at the end. For the first one you need the <code>zip</code> function, for the latter one you need to modify the lambda function to return a tuple. For example:</p>
<pre><code>a, x_sum = reduce(lambda x,y: (x[0].compose(y[0], y[1]), x[1][0]+y[1][0]), zip(circli, cs), (qcla, 0))
</code></pre>
<p>I use the name <code>cs</code> for the list of <code>c</code> values here.</p>
<p><code>zip</code> creates pairs of <code>circli</code> and <code>cs</code> items and you can go through the pairs. In this case I get the sum of the x coordinates of <code>c</code> values as the result as well.</p>
<p>If the values in <code>cs</code> is the constant <code>c</code> in your example (<code>cs = [c]*len(circli)</code>) , the <code>a</code> in the result will be the same as in your example.</p>
",2/20/2021 7:22,Tooling,"The user is trying to modify the usage of the reduce function in Python and the compose function in Qiskit to include another iterable, which falls under the Tooling category as it involves understanding and modifying the syntax and functionality of specific programming tools",Tooling,,,,Tooling,
66574331.0,IBM quantum simulators run on cloud or locally?,"<p>Do qiskit simulators run locally or on IBM cloud servers? It seems that each time I have used them, my computer goes into max CPU, and sometimes the simulation runs out of memory, exiting with out of memory error message.</p>
",<ibm-cloud><qiskit>,03/10/2021 23:22,66577497.0,66577497.0,"<p>Both, depending on the backend that you choose. If you install and run Aer, then the simulation is local. But you can also run a simulator via IBMQ, as if it was a real device. There are several simulator backends on the cloud, like <code>ibm_qasm_simulator</code>. They are listed at the bottom of the webpage <a href=""https://quantum-computing.ibm.com/services?systems=yours"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/services?systems=yours</a>.</p>
",03/11/2021 06:30,Tooling,"The user is inquiring about the execution environment of Qiskit simulators and experiencing performance issues on their local computer, which falls under the ""Tooling"" category as it pertains to the usage and performance of quantum programming tools.",Tooling,,,,Tooling,
66808189.0,How to repeat a function for a list of inputs?,"<p>I'm trying to use the following function of QuTip library:</p>
<pre><code>coherent_dm(N=10, alpha = c, offset=0, method='operator')
</code></pre>
<p>It's output is a matrix and it's input is a complex number &quot;c&quot;, however I want to get the matrices for a list of multiple &quot;c&quot; numbers, but if I define &quot;c&quot; as:</p>
<pre><code>t = np.linspace(0,2*np.pi,100)
c = 2*np.exp(-t*1j) + 0.1*10*(1 - np.exp(-t*1j))
</code></pre>
<p>And run the code it gives me &quot;dimension mismatch&quot; error. In this case I tried to run a list of a 100 complex numbers as input &quot;c&quot; expecting an output of a 100 matrices. Any ideas on how to solve this problem would be appreciated.</p>
",<python><numpy><physics><qutip>,3/25/2021 22:02,66808315.0,66808315.0,"<p><a href=""http://qutip.org/docs/latest/apidoc/functions.html#qutip.states.coherent_dm"" rel=""nofollow noreferrer""><code>coherent_dm</code></a> returns a <a href=""http://qutip.org/docs/latest/apidoc/classes.html#qobj"" rel=""nofollow noreferrer""><code>qutip.Qobj</code></a> instance. This is a specialized object that fulfills the <code>__array__</code> interface, but is not actually a numpy array. Internally, it appears to contain a sparse matrix. That means that you can not readily make <code>coherent_dm</code> return more than one matrix at a time, or even concatenate the results of multiple calls into a single array.</p>
<p>Your best bet is therefore probably to use a list comprehension:</p>
<pre><code>result = [coherent_dm(N=10, alpha=i, offset=0, method='operator') for i in c]
</code></pre>
",3/25/2021 22:13,API Usage,The question is about how to use the coherent_dm() function in QuTiP to generate a list of density matrices from a list of complex numbers, Errors,The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are encountering a dimension mismatch error while trying to run a list of complex numbers as input in the coherent_dm function of the QuTip library.,No,21.0,API Usage,"This is because the user is seeking guidance on how to use the coherent_dm() function in QuTiP to generate a list of density matrices from a list of complex numbers, indicating a need for understanding how to utilize this specific function effectively within the QuTiP library."
66881062.0,How to get a default EquivalenceLibrary?,"<p>I want to use the BasisTranslator in Qiskit to process my circuit to base gates.</p>
<p>One of the constructor parameters for <a href=""https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.BasisTranslator.html#qiskit.transpiler.passes.BasisTranslator"" rel=""nofollow noreferrer"">BasisTranslator</a> is <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.EquivalenceLibrary.html#qiskit.circuit.EquivalenceLibrary"" rel=""nofollow noreferrer"">EquivalenceLibrary</a>. I attempted creating a parameter-less <code>EquivalenceLibrary()</code> and pass it to a BasisTranslator, but the code fails, saying it cannot translate gates like MCT or CCX into the default basis.</p>
<pre><code>TranspilerError: &quot;Unable to map source basis {('mcx', 4), ('ccx', 3), ('x', 1), ('measure', 1), ('h', 1)} to target basis {'u2', 'snapshot', 'barrier', 'cx', 'u3', 'reset', 'u1', 'measure', 'delay'}
</code></pre>
<p>I would expect there is some default EquivalenceLibrary that the Transpiler uses when I attempt to run the circuit, since it runs both for simulators and actual hardware. How could I get such default EquivalenceLibrary?</p>
",<qiskit>,3/31/2021 3:00,66886293.0,66886293.0,"<p>The easiest way is to leverage the session equivalence library that is included with qiskit (at <code>qiskit.circuit.equivalence_library.SessionEquivalenceLibrary</code>) which is a prebuilt equivalence library which includes all the standard library gates. You can use it with something like:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel
from qiskit.transpiler.passes import BasisTranslator
from qiskit.circuit import QuantumCircuit
from qiskit.converters import circuit_to_dag, dag_to_circuit

basis_gates = ['u2', 'snapshot', 'barrier', 'cx', 'u3', 'reset', 'u1', 'measure', 'delay']
bt_pass = BasisTranslator(sel, basis_gates)

circuit = QuantumCircuit(3)
circuit.ccx(0, 1, 2)


dag_out = bt_pass.run(circuit_to_dag(circuit))
circuit_out = dag_to_circuit(dag_out)
</code></pre>
<p>(as a future note in qiskit-terra &gt;=0.17.0, which will be released soon, you'll no longer need to convert to a dag here and call <code>bt_pass(circuit)</code> directly)</p>
<p>If you're interested in how to construct an equivalence library from scratch you can take a look at how the session equivalence library is built here:
<a href=""https://github.com/Qiskit/qiskit-terra/blob/0.16.4/qiskit/circuit/library/standard_gates/equivalence_library.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/0.16.4/qiskit/circuit/library/standard_gates/equivalence_library.py</a></p>
",3/31/2021 10:46, Tooling,"The user is encountering an issue related to configuring and using the EquivalenceLibrary parameter in Qiskit's BasisTranslator. This falls under the ""Tooling"" category as it involves configuring and using a specific tool or feature within the Qiskit framework for quantum programming.", Tooling,,,, Tooling,
66920772.0,How to solve TSP problem with more than 3 nodes in the tutorial of Max-Cut and Traveling Salesman Problem Qiskit 0.24.0?,"<p>I had to try the example of qiskitâs <a href=""https://qiskit.org/documentation/tutorials/optimization/6_examples_max_cut_and_tsp.html"" rel=""nofollow noreferrer"">Traveling Salesman Problem</a>  with 3 nodes and executing it at IBM backend called simulator_statevector.Can execute and get the result normally.</p>
<p>But when trying to solve the TSP problem with more than 3 nodes,I changed n = 3 to n = 4.</p>
<pre><code># Generating a graph of 3 nodes
n = 4
num_qubits = n ** 2
ins = tsp.random_tsp(n, seed=123)
print('distance\n', ins.w)

# Draw the graph
G = nx.Graph()
G.add_nodes_from(np.arange(0, ins.dim, 1))
colors = ['r' for node in G.nodes()]

for i in range(0, ins.dim):
    for j in range(i+1, ins.dim):
        G.add_edge(i, j, weight=ins.w[i,j])

pos = {k: v for k, v in enumerate(ins.coord)}

draw_graph(G, colors, pos)
</code></pre>
<p>And I changed backend from Aer.get_backend ('statevector_simulator') running on my device to provider.backend.simulator_statevector running on the IBM backend.</p>
<pre><code>aqua_globals.random_seed = np.random.default_rng(123)
seed = 10598
backend = provider.backend.simulator_statevector
#backend = Aer.get_backend('statevector_simulator')
quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed)
</code></pre>
<p>But the result that comes out with an error.</p>
<pre><code>energy: -1303102.65625
time: 5626.549758911133
feasible: False
solution: [1, 0, 2, []]
solution objective: []
Traceback (most recent call last):
  File &quot;&lt;ipython-input-10-bc5619b5292f&gt;&quot;, line 14, in &lt;module&gt;
    draw_tsp_solution(G, z, colors, pos)
  File &quot;&lt;ipython-input-4-999185567031&gt;&quot;, line 29, in draw_tsp_solution
    G2.add_edge(order[i], order[j], weight=G[order[i]][order[j]]['weight'])
  File &quot;/opt/conda/lib/python3.8/site-packages/networkx/classes/coreviews.py&quot;, line 51, in __getitem__
    return self._atlas[key]
TypeError: unhashable type: 'list'

Use %tb to get the full traceback.
</code></pre>
<p>How should I fix it? Please give me some advice.</p>
",<python><quantum-computing><qiskit>,04/02/2021 14:25,67849364.0,67849364.0,"<p>I found the answer, my method is to increase the Ansat number of reps from 5 to 7.</p>
<p>from solving TSP 4 node problem</p>
<pre><code>spsa = SPSA(maxiter=300)
ry = TwoLocal(qubitOp.num_qubits, 'ry', 'cz', reps=7, entanglement='linear')
vqe = VQE(qubitOp, ry, spsa, quantum_instance=quantum_instance)

result = vqe.run(quantum_instance)
</code></pre>
",06/05/2021 12:02,Errors ,"The user is encountering an error when trying to solve the Traveling Salesman Problem (TSP) with more than 3 nodes using Qiskit's Aqua library and an IBM backend. The error message and the issue pertain to solving a specific problem and dealing with a runtime error, which falls under the ""Errors"" category in quantum programming.",Errors,,,,Errors ,
67338351.0,Cannot create Q# projects,"<p>I'm new to quantum computing and I've been trying to follow instructions on <a href=""https://learn.microsoft.com/en-us/azure/quantum/install-command-line-qdk?tabs=tabid-vscode"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/azure/quantum/install-command-line-qdk?tabs=tabid-vscode</a> to dive into this field, but I've run into a problem. Every time I'm trying to create a new Q# application project, I get the following <a href=""https://i.stack.imgur.com/yPabE.png"" rel=""nofollow noreferrer"">error message</a></p>
<blockquote>
<p>The project file cannot be opened. Unable to find package Microsoft.Quantum.Sdk. No packages exist with this id in source(s): Microsoft Visual Studio Offline Packages C:\Program Files\dotnet\sdk\5.0.202\Sdks\Microsoft.Quantum.Sdk\Sdk not found. Check that a recent enough .NET SDK is installed and/or increase the version specified in global.json.</p>
</blockquote>
<p>and I can't find that package myself either.</p>
<p>I've tried to install Microsoft.Quantum.Development.Kit-0.16.2104.138035 several times, with both .NET 3.1.408 and 5.0.202. I'm using VS 2019 16.9.4 Community Edition on Windows 10.</p>
",<visual-studio-2019><q#>,4/30/2021 17:50,67340384.0,67340384.0,"<p>Looks like nuget.org is not listed as a valid package source in your computer, so dotnet can't find the QDK packages online.</p>
<p>Try running this command:</p>
<pre><code>dotnet nuget add source  https://api.nuget.org/v3/index.json -n nuget.org
</code></pre>
<p>And then try building your Q# project again.</p>
<p>It's unclear to me why <code>nuget.org</code> is not listed as a source, though; it should be included by default when you install the .NET Core.</p>
",4/30/2021 20:58,Errors,"The user is encountering an error while trying to create a new Q# application project, which falls under the category of Errors in programming",Errors,,,,Errors,
67362847.0,AttributeError: 'QuantumCircuit' object has no attribute 'config',"<p>I am working on a program for Qiskit, but I am getting a strange error (one that I have not gotten in the past) when I try to simulate a circuit. Here is a minimal example producing the error:</p>
<pre><code>from qiskit.circuit import QuantumCircuit
from qiskit import Aer,transpile

c = QuantumCircuit(2)
simulator = Aer.get_backend('qasm_simulator')
c = transpile(c, simulator)
result = simulator.run(c).result()
plot_histogram(counts, title='Counts')
</code></pre>
<p>The error I get is:</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-1-89904ecd5f8e&gt; in &lt;module&gt;()
      5 simulator = Aer.get_backend('qasm_simulator')
      6 c = transpile(c, simulator)
----&gt; 7 result = simulator.run(c).result()
      8 plot_histogram(counts, title='Counts')

/Users/d/anaconda3/envs/qiskit/lib/python3.7/site-packages/qiskit/providers/aer/backends/aerbackend.py in run(self, qobj, backend_options, validate, **run_options)
    146         # Add backend options to the Job qobj
    147         qobj = self._format_qobj(
--&gt; 148             qobj, backend_options=backend_options, **run_options)
    149 
    150         # Optional validation

/Users/d/anaconda3/envs/qiskit/lib/python3.7/site-packages/qiskit/providers/aer/backends/aerbackend.py in _format_qobj(self, qobj, backend_options, **run_options)
    353         &quot;&quot;&quot;Return execution sim config dict from backend options.&quot;&quot;&quot;
    354         # Add options to qobj config overriding any existing fields
--&gt; 355         config = qobj.config
    356 
    357         # Add options

AttributeError: 'QuantumCircuit' object has no attribute 'config'
</code></pre>
<p>Does anyone know what is causing this error?</p>
<p>Thank you!</p>
",<python><qiskit>,05/03/2021 02:31,67368870.0,67368870.0,"<p>I believe you need to assemble the transpiled circuit in a qobj before running it :</p>
<pre><code>from qiskit.compiler import assemble
my_qobj = assemble(c)
result = simulator.run(my_qobj).result()
</code></pre>
<p>By the way, without any measure, the <code>plot_histogram(result.get_counts())</code> will return an error as well.</p>
<p>There is also a special platform the Quantum Computing, <a href=""https://quantumcomputing.stackexchange.com"">https://quantumcomputing.stackexchange.com</a>, feel free to post any other questions about QC&amp;co there :)</p>
",05/03/2021 12:24, Errors,"The user is encountering a specific error while trying to simulate a quantum circuit using Qiskit, which falls under the Errors category as it involves troubleshooting a programming issue",Errors,,,, Errors,
67411006.0,"Python calling q# file on IONQ QPU results in error about a System.Text.Json, Version=5.0.0.0 file not being found","<p>Attempting to learn how to call <em>q#</em> from Python code and have it run for real on the <strong>IONQ QPU</strong> as it does (or appears to do) using <em>VS</em> and &gt;<em>dotnet run</em> of the raw <em>q#</em> code. I followed the guides and workshop.</p>
<p><strong>Python code</strong>:</p>
<pre><code>     import qsharp
     import qsharp.azure
     qsharp.projects.add(&quot;****path to *******/TestIONQ.csproj&quot;)
     from TestIONQ import GetRandomResult
     print(f&quot;Simulated Result: {GetRandomResult.simulate()}&quot;)
     print(&quot;------------------------------------------------&quot;)
        
     qsharp.azure.connect(
       subscription = &quot;****************************&quot;,
       resourceGroup = &quot;**************&quot;,
       workspace = &quot;************&quot;,
       location = &quot;******* US&quot;)
     qsharp.azure.target(&quot;ionq.qpu&quot;)
     result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;)
     print(f&quot; Final result from IONQ - QPU:   {result}&quot;)
</code></pre>
<p><strong>q# code:</strong></p>
<pre><code>         namespace TestIONQ {
            
             open Microsoft.Quantum.Canon;
             open Microsoft.Quantum.Intrinsic;
                
             //@EntryPoint()
             operation GetRandomResult() : Result {
                 use q = Qubit();
                 H(q);
                 return M(q);
             }  
     }
</code></pre>
<p>and the <strong>.csproj</strong> file:</p>
<pre><code>     &lt;Project Sdk=&quot;Microsoft.Quantum.Sdk/0.16.2104138035&quot;&gt;
        
       &lt;PropertyGroup&gt;
         &lt;OutputType&gt;Exe&lt;/OutputType&gt;
         &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
         &lt;ExecutionTarget&gt;ionq.qpu&lt;/ExecutionTarget&gt;
         &lt;IQSharpLoadAutomatically&gt;true&lt;/IQSharpLoadAutomatically&gt;
       &lt;/PropertyGroup&gt;
        
     &lt;/Project&gt;
</code></pre>
<p>The results of running the above Python code in Anaconda <em>qsharp-env</em> environment (Python 3.7.10)  are as follows:</p>
<pre><code>Simulated Result: 0
------------------------------------------------
Connected to Azure Quantum workspace ####### in location #####us.
Loading package Microsoft.Quantum.Providers.IonQ and dependencies...
Active target is now ionq.qpu
Submitting TestIONQ.GetRandomResult to target ionq.qpu...
Failed to submit Q# operation TestIONQ.GetRandomResult for execution.
Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken=####token#####'. The system cannot find the file specified.
</code></pre>
<p>Obviously, no problem connecting to Azure and the Workspace. In fact I can run the container-ship optimization example no problem from Python. This also works fine for the first half of the Python code when <em>.simulate()</em> is invoked.</p>
<p>Next, when I try to bypass the IONQ QPU and use its own simulator by changing this one line:</p>
<pre><code>qsharp.azure.target(&quot;ionq.simulator&quot;)
</code></pre>
<p>The resulting error is the same and the results are as follows:</p>
<pre><code>Simulated Result: 1
------------------------------------------------
Connected to Azure Quantum workspace ######## in location #######.
Loading package Microsoft.Quantum.Providers.IonQ and dependencies...
Active target is now ionq.simulator
Submitting TestIONQ.GetRandomResult to target ionq.simulator...
Failed to submit Q# operation TestIONQ.GetRandomResult for execution.
Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken='....token......'. The system cannot find the file specified.
Traceback (most recent call last):
  File &quot;ionq_sim_remote.py&quot;, line 18, in &lt;module&gt;
    result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;)
  File &quot;F:\Python38\miniconda\envs\qsharp-env\lib\site-packages\qsharp\azure.py&quot;, line 137, in execute
    if &quot;error_code&quot; in result: raise AzureError(result)
qsharp.azure.AzureError: {'error_code': 1010, 'error_name': 'JobSubmissionFailed', 'error_description': 'Failed to submit the job to the Azure Quantum workspace.'}
</code></pre>
<p>This runs very easily on Azure using the <em>q#</em> code snippet within Visual Studio at the command line using a variant of what was shown during the workshop</p>
<pre><code>az quantum execute --target-id ionq.qpu --job-name IONQ_test --resource-group ***rg name*** --workspace-name ***ws name*** --location **** -o table   

</code></pre>
<p>and indeed this appears to have run on the actual QPU hardware as compared to the simulator (which gives the exact 0.5/0.5 result).</p>
<pre><code>Result    Frequency
--------  ----------
0         0.49800000
1         0.50200000
</code></pre>
<p>But then calling that same <em>q#</em> code from Python - including the same <em>.csproj</em> file seems to throw this JSON file error  - even with the <em>qsharp-env</em> loaded into Anaconda. I apologize if it is something silly that I have done- trying to learn here.</p>
<p>By the way, this works <strong>great</strong> as a way around the problem with no Anaconda environment required or anything special:</p>
<p><strong>Python:</strong></p>
<pre><code>import os
os.system(f'powershell.exe az quantum execute --target-id ionq.qpu --job-name Pytest --resource-group **** --workspace-name **** --location **** -o table ')
</code></pre>
<p>And the result was definitely run on the actual hardware (took a good while):</p>
<pre><code>Result    Frequency
--------  -----------  -------------------------
0         0.53200000   ââââââââââââ            |
1         0.46800000   ââââââââââ              |
</code></pre>
",<python><azure><q#><azure-quantum>,05/06/2021 02:20,67421883.0,67421883.0,"<p>@Joab.Ai, thank you for posting this issue! We've identified this to be specific to the latest version of qsharp (<code>0.16.2104.138035</code>).
<strike>While we are looking into a fix, a workaround will be to downgrade your <code>qsharp</code> package version</strike>:</p>
<p>Edit: we have fixed this issue in our latest release! Update to the latest version with this command:</p>
<pre><code>conda install -c quantum-engineering qsharp=0.16.2105.140472
</code></pre>
<p>or simply run:</p>
<pre><code>conda update -c quantum-engineering qsharp
</code></pre>
",05/06/2021 16:02,API Usage,"The user is encountering issues when attempting to call Q# code from Python and execute it on the IONQ QPU using Azure Quantum. The problem appears to be related to the interaction between Python and Q# and the usage of Azure Quantum services, making it an API usage issue.",API Usage,,,,API Usage,
67448011.0,Where was Qiskit-Textbook downloaded?,"<p>I've installed Qiskit-textbook by <code>pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src</code>. But I don't know where is it downloaded</p>
",<python><quantum-computing><qiskit>,05/08/2021 13:20,67486966.0,67486966.0,"<p>That command installs the Qiskit Textbook <em>package</em>, which is a Python package containing some of the problems and widgets used in the textbook. You can see the location of an installed package using <code>pip show &lt;package&gt;</code>:</p>
<pre><code>pip show qiskit-textbook
</code></pre>
<p>output:</p>
<pre><code>Name: qiskit-textbook
Version: 0.1.0
Summary: A collection of widgets, tools and games for using along
  the Qiskit Textbook. See the textbook and a list of contributors at qiskit.org/textbook
Home-page: UNKNOWN
Author: Qiskit Team
Author-email: hello@qiskit.org
License: UNKNOWN
Location: /usr/local/anaconda3/lib/python3.7/site-packages
Requires: ipython, matplotlib, numpy, qiskit, ipywidgets
Required-by: 
</code></pre>
<p>From which I can see my package is installed at <code>/usr/local/anaconda3/lib/python3.7/site-packages</code>.</p>
<p>If you want to download the Jupyter notebooks (i.e. the pages of the textbook), you can do this from the <a href=""https://github.com/qiskit-community/qiskit-textbook"" rel=""nofollow noreferrer"">Github page</a>. There is a big green button labelled &quot;code&quot; if you click it, you can either get the link to clone it through git, or <a href=""https://github.com/qiskit-community/qiskit-textbook/archive/refs/heads/master.zip"" rel=""nofollow noreferrer"">download it as a <code>.zip</code></a>. All the pages are inside the &quot;content&quot; folder.</p>
",05/11/2021 12:41,Tooling,"The user is asking about the installation location of a Python package, specifically Qiskit-textbook, which falls under the ""Tooling"" category as it pertains to the usage and location of software tools.",Tooling ,,,,Tooling,
67462360.0,How to decide bias in Hamiltonian Ising model? python,"<p>I am trying to code finance portfolio optimisation problem into a quantum annealer, using the Hamiltonian Ising model. I am using the <a href=""https://sdk-docs.readthedocs.io/en/latest/docs_neal/reference/sampler.html"" rel=""nofollow noreferrer"">dwave</a> module</p>
<pre><code>neal.sampler.SimulatedAnnealingSampler.sample_ising
</code></pre>
<p><strong>I was wondering how one gets to decide what the bias is?</strong> I don't really get how that works. On the documentation of Dwave it says the following:</p>
<p><a href=""https://i.stack.imgur.com/nAEAm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nAEAm.png"" alt=""enter image description here"" /></a></p>
<p>There also was this example code:</p>
<pre><code>import neal
&gt;&gt;&gt; sampler = neal.SimulatedAnnealingSampler()
h = {'a': 0.0, 'b': 0.0, 'c': 0.0}
J = {('a', 'b'): 1.0, ('b', 'c'): 1.0, ('a', 'c'): 1.0}
sampleset = sampler.sample_ising(h, J, num_reads=10)
print(sampleset.first.energy)
</code></pre>
",<python><physics><quantum-computing><bias-neuron>,05/09/2021 21:12,67493344.0,67493344.0,"<p>If you are familiar with the physics of the Ising model (e.g. just look it up on wikipedia), you will find out that the term &quot;linear bias&quot; <code>h</code> is used instead of the physics term external constant magnetic field and the term &quot;quadratic bias&quot; <code>J</code> is used instead of the physics term of interaction between a pair of (neighbouring in the case of the Ising model) spins. My guess is that the <code>h</code> and <code>J</code> coefficients must be learned from some given data. Your job is to cast (interpret) the data available to you into an Ising model configuration (state) and then use some sort of optimization with unknown <code>h</code> and <code>J</code> that minimizes the difference between the model's solutions (theoretical Ising model configuration) and the observed data.</p>
",05/11/2021 19:40,Theoretical, The user is inquiring about how to decide the bias in a finance portfolio optimization problem represented using the Ising model in the context of a quantum annealer. This falls under the theoretical category as it relates to the theoretical concepts and algorithms used in quantum computing for this specific problem.,Theoretical,,,,Theoretical,
67718967.0,Qiskit and IPython conf files do not exist,"<p>I had installed the qiskit-textbook distribution of Qiskit using this command : <code>pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src</code></p>
<p>The tutorial then said to change the contents of the configuration file located at <code>~/.qiskit/settings.conf</code> but I can't find the folder at <code>~/</code>. I can't find the iPython configuration file either at <code>~/.ipython/profile_default/ipython_kernel_config.py</code> for some reason.</p>
<p>How do I fix this?</p>
",<python><python-3.x><linux><qiskit>,5/27/2021 9:00,67724737.0,67724737.0,"<ul>
<li><p>If you don't have the <code>~/.qiskit/settings.conf</code> you can create that yourself at that location (see this answer <a href=""https://quantumcomputing.stackexchange.com/questions/8702/what-is-the-location-of-the-qiskit-config-file"">here</a> and the docs <a href=""https://qiskit.org/documentation/configuration.html"" rel=""nofollow noreferrer"">here</a>).</p>
</li>
<li><p>If you don't have <code>~/.ipython/profile_default/ipython_kernel_config.py</code>, try running <code>ipython profile create</code> and see if it then appears.</p>
</li>
</ul>
",5/27/2021 14:53,Tooling,"The user is facing issues related to locating configuration files for Qiskit and IPython, which falls under the ""Tooling"" category as it involves locating and managing files and settings in quantum programming tools.",Tooling,,,,Tooling,
67852048.0,Why does drawing a qiskit quantum circuit look different when I run a jupyter notebook locally,"<p>I'm using the <a href=""https://qiskit.org/textbook/ch-states/representing-qubit-states.html"" rel=""nofollow noreferrer"">qiskit textbook</a>, and it creates a <code>QuantumCircuit</code> and then draws the circuit, and it looks like this:
<a href=""https://i.stack.imgur.com/H7vsy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H7vsy.png"" alt=""visualization of quantum circuit from qiskit textbook"" /></a></p>
<p>I see the same result when running the textbook as a jupyter notebook in <a href=""https://quantum-computing.ibm.com/lab"" rel=""nofollow noreferrer"">IBM's quantum lab</a>.</p>
<p>However, when I download the textbook as a jupyter notebook and run it myself locally, it looks like this:
<a href=""https://i.stack.imgur.com/qE1E7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qE1E7.png"" alt=""visualization of quantum circuit from locally hosted jupyter notebook"" /></a></p>
<p>I don't like this very much, and I think I am missing something simple. The code that is running is exactly the same. I am using MacOS 11.4 (Big Sur). The following code is sufficient to show a difference when I run it online vs. locally:</p>
<pre><code>from qiskit import QuantumCircuit

qc = QuantumCircuit(1)  # Create a quantum circuit with one qubit
initial_state = [0,1]   # Define initial_state as |1&gt;
qc.initialize(initial_state, 0) # Apply initialisation operation to the 0th qubit
qc.draw()  # Let's view our circuit
</code></pre>
",<jupyter-notebook><quantum-computing><qiskit>,06/05/2021 17:11,67852329.0,67852329.0,"<p>Because Qiskit has multiple drawers. Those are:</p>
<ul>
<li><code>text</code></li>
<li><code>mpl</code></li>
<li><code>latex</code></li>
<li><code>latex_source</code>.</li>
</ul>
<p>The drawer you see in the IBM Quantum Lab is the one based on Matplotlib. You can get the same output by <code>qc.draw('mpl')</code>.</p>
<p>To set a default, you can change (or create if does not exist) the file <code>~/.qiskit/settings.conf</code>) with the entry <code>circuit_drawer = mpl</code>.</p>
",06/05/2021 17:40,Tooling ,"The users question is about the difference in the visual output of a quantum circuit when running the same Qiskit code in different environments (IBMs quantum lab vs. locally). This falls under the category of Tooling, which involves questions related to tools and software usage in quantum programming",Tooling,,,,Tooling ,
68600069.0,Deutsch algorithm with NOT gate as oracle,"<p>I tried to implement Deutsch algorithm using qiskit. The following is a code.</p>
<pre><code>circ = QuantumCircuit(2, 2)  # |q_1q_0&gt;
circ.x(0)
circ.h([0,1])

# Oracle
circ.barrier()
circ.x(1)
circ.barrier()

circ.h(0)
circ.measure([0,1], [0,1])

backend_sim = Aer.get_backend('qasm_simulator')
job = execute(circ, backend_sim, shots=1024)
result = job.result()

counts = result.get_counts(circ)
print(counts)
</code></pre>
<p><a href=""https://i.stack.imgur.com/SClKU.png"" rel=""nofollow noreferrer"">enter image description here</a></p>
<p>I expected that the first classical bit is 0 (that is, the function corresponding to that oracle is a constant function). But, the output is the following.</p>
<pre><code>{'11': 496, '01': 528}
</code></pre>
<p>Why does the output imply the function is a balanced one?</p>
",<python><quantum-computing>,7/31/2021 7:29,68607780.0,68607780.0,"<p>Deutsch algorithm applies the X gate to the qubit you use for phase kickback trick, to prepare it in the |-â© state before applying the oracle. Your implementation applies it to the &quot;data&quot; qubit instead, so that the combined effect of the algorithm (after H gates cancel out) is just preparing the data qubit in |1â© state.</p>
",08/01/2021 05:36,Errors,The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are encountering an unexpected output when implementing the Deutsch algorithm using Qiskit. ,Errors,,,,Errors,
68709800.0,Quantum Neural Networks - Noise Models,"<p>Surveying the QML module in Qiskit for a quantum neural network project and wondering if there is support to add noise models and run noisy simulations?</p>
<p>Going through <a href=""https://github.com/Qiskit/qiskit-machine-learning/blob/main/docs/tutorials/01_neural_networks.ipynb"" rel=""nofollow noreferrer"">this</a> tutorial and wondering how one would define a noise model in the argument of <code>qnn.forward</code> when doing a batched forward pass.</p>
",<qiskit>,08/09/2021 09:32,68711458.0,68711458.0,"<p>You can create a noisy simulator like in the snippet below and then use it when you create a <code>QuantumInstance</code>:</p>
<pre class=""lang-python prettyprint-override""><code>    from qiskit.providers.aer import AerSimulator
    from qiskit.providers.aer.noise import NoiseModel
    from qiskit.test.mock import FakeVigo
    from qiskit.utils import QuantumInstance

    # We create a simulator with a noise model from this backend
    fake_backend = FakeVigo()
    noise_model = NoiseModel.from_backend(fake_backend)
    backend = AerSimulator(noise_model=noise_model)
    quantum_instance = QuantumInstance(backend=backend)
    # Then pass quantum_instance to a VQC instance or another algorithm.
</code></pre>
<p>You can take a look at the documentation of the noise package here: <a href=""https://qiskit.org/documentation/apidoc/aer_noise.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/apidoc/aer_noise.html</a> or at the tutorial here: <a href=""https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html</a>.</p>
",08/09/2021 11:40,Tooling,The user is asking about how to use a particular software or tool for quantum programming. They are looking for support to add noise models and run noisy simulations in the QML module in Qiskit for a quantum neural network project. ,Tooling,,,,Tooling,
69511608.0,VS2019 Community Edition Q# Application Hello World Reference problem,"<p>I am a Q# Beginner.
Using Visual Studio 2019 Version 16.11.4. Community Edition</p>
<p>Dotnet 5.0.401</p>
<p>Using the Q# Application Template I create a new   Q#  'Hello World' Application.
The Packages list entries all have a yellow triangle. (See Solution Explorer Image)</p>
<p>Building the project produces errors as expected.</p>
<p>The packages belong to the QDK.</p>
<p><a href=""https://i.stack.imgur.com/cqqWs.png"" rel=""nofollow noreferrer"">Solution Explorer View</a></p>
<p>I have spent many hours re-installing my Visual studio, the QDK and chasing down paths and tips which have not solved the problem.</p>
<p>I must be missing something fundamental.</p>
<p>Appreciate anything that can get this going.
thanks</p>
",<q#>,10/10/2021 01:18,69533663.0,69533663.0,"<p>I can't comment on Mariia Mykhailova's answer as I don't have sufficient rep with my private login but the link 'this answer' led me to the solution.</p>
<p>It was a nuget problem.</p>
<p>As instructed I ran 'dotnet restore'</p>
<p>This gave an error
So I deleted Users\myname.nuget\packages\quantum\xxx.</p>
<p>This didn't fix it but the erroring file in the 'dotnet restore' changed.
So I deleted that file and its friends.</p>
<p>Again no fix but the erroring file changed.</p>
<p>So I played 'whackamole' repeatedly until finally dotnet restore was successful.</p>
<p>Reminds me of the good old days of dll hell.</p>
<p>Thought we were past all this BS but there you go.</p>
<p>The last delete that fixed the problem was Users\myname.nuget\packages\microsoft.csharp</p>
<p>I could have blitzed the whole packages directory I suppose but I am a timid mouse.</p>
",10/12/2021 00:02,Tooling,"The user question is about an issue theyre facing with the Q# Application Template in Visual Studio 2019, specifically with the QDK packages showing errors. This falls under the category of Tooling, which involves questions related to tools and software usage in quantum programming.",Tooling,,,,Tooling,
70095529.0,Atribute error when running the Qiskit VQE Alogrithum,"<p>I'm trying to run the VQE algorithm using an Aer backend simulator. However, whenever I run the algorithm I Receive this error: &quot;AttributeError: 'TwoLocal' object has no attribute 'set_max_evals_grouped'&quot;</p>
<p>Could anyone explain what this error means and how I can fix It?</p>
<p>This is the code I am  using:</p>
<pre><code>driver = PySCFDriver(atom='Li .0 .0 .0; H .0 .0 1.5049', unit=UnitsType.ANGSTROM, charge=0, spin=0, basis='sto3g')



#create  second quantiesed operator 
es_problem= ElectronicStructureProblem(driver)
seconded_quanitsied_oprator= es_problem.second_q_ops() 
print(seconded_quanitsied_oprator)



#convert to qubit operator 


qubit_transformation = QubitConverter(JordanWignerMapper())
qubit_operator = qubit_transformation.convert(seconded_quanitsied_oprator[0])
print(qubit_operator) 


#set up simulator 
backend = BasicAer.get_backend('statevector_simulator')
quantum_instance=QuantumInstance(backend=backend)

# VEQ algothiums 
groundstate_energies = []
classical_optimizer = SLSQP(maxiter = 1000)


ansatz = TwoLocal(rotation_blocks='ry', entanglement_blocks='cz')


Vqe = VQE(qubit_operator,ansatz,SLSQP,quantum_instance )
</code></pre>
",<qiskit>,11/24/2021 11:46,70095980.0,70095980.0,"<p>You are using VQE the old way (when it was in Aqua), so it doesn't work anymore. What you should do instead is this :</p>
<pre><code>vqe = VQE(ansatz = ansatz,
          optimizer = SLSQP, 
          quantum_instance=quantum_instance)
vqe_result = vqe.compute_minimum_eigenvalue(qubit_operator)
</code></pre>
<p>Just in case, everything you need to know about how to move from Aqua is available here : <a href=""https://qiskit.org/documentation/aqua_migration.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/aqua_migration.html</a></p>
",11/24/2021 12:20,Errors,"The user is encountering an error while trying to run the VQE (Variational Quantum Eigensolver) algorithm using Qiskit's Aer backend simulator. The error message indicates an issue with the 'TwoLocal' object, and the user is seeking assistance in resolving this problem, making it fall under the ""Errors"" category, which involves troubleshooting and resolving issues in quantum programming.",Errors,,,,Errors,
70224040.0,Hadamard gate returns same result which is different from my expects,"<p>I meausred some states after approve hadamard gate.
I guess that after measuremnt and because of properties of hadamard gate,</p>
<p>The measurement result will always different.
But after I checked , the result is always same</p>
<p>=&gt; <a href=""https://i.stack.imgur.com/aRsNp.png"" rel=""nofollow noreferrer"">After approve hadamard gate at q_0 gate at 2 qubits</a></p>
<p>=&gt; <a href=""https://i.stack.imgur.com/7gk0b.png"" rel=""nofollow noreferrer"">After approve hadamard gate at q_2 gate at 3 qubits</a></p>
<p>=&gt; <a href=""https://i.stack.imgur.com/NthDH.png"" rel=""nofollow noreferrer"">After approve hadamard gate at q_1 gate at 3 qubits</a></p>
<p>=&gt; <a href=""https://i.stack.imgur.com/nzyZg.png"" rel=""nofollow noreferrer"">After approve hadamard gate at q_0 gate at 3 qubits</a></p>
<p>I learned that hadamard gate yieds same probabilities of each state.
But the measurement result always returns same.</p>
",<measurement><quantum-computing>,12/04/2021 08:15,70313267.0,70313267.0,"<p>You have to understand what we really mean by probability first. Let me give you an example : probability of getting head on a coin is 1/2. What this means is that if we flip the coin lets say 1000 times, almost half the times we will get heads. It doesnt mean if we flip it once then half the coin will be head and other half tails.
Thus is a long run, the distribution of heads and tails might be something like 509(heads) and 491(tails) but there will be stretches where coin will flip 10 straight heads.</p>
<p>Now to HADAMARD. Hadamard creates an equal probability for 1 and 0 when applied to ket 0. This means when you measure it, it has a fifty percent probability of getting you 0 and other fifty for getting you 1. thus you can get 10 straight ket 0s when measuring but if you do it for 1000 times, distribution becomes equal. This is why when we use real quantum computers or even simulators, we adjust something called 'shots' to a large number. And that number is how many times that circuit is measured and we get an idea of what quantum state was.</p>
<p>GO to 'set up and run' on composer and you'll understand rest.</p>
",12/11/2021 07:08, Errors,"The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are encountering an unexpected result when measuring states after applying a Hadamard gate, where the measurement result is always the same.", Errors,,,, Errors,
70490407.0,QuTip: How to multiply symbol with matrix,"<p>I am trying to multiply a symbol with a matrix which is defined by <code>QuTip quantum object</code>, but I got this error:</p>
<pre><code>TypeError: Incompatible object for multiplication
</code></pre>
<p>I used:</p>
<pre><code>from qutip import *
import sympy as sp
w0 = sp.Symbol('\omega_{0}')
w0*destroy(4)
</code></pre>
<p>Did I miss something?</p>
",<sympy><qutip>,12/26/2021 22:53,70521678.0,70521678.0,"<p>The object <code>destroy(4)</code> contains a lot more information than just the matrix representation of the annihilation operator, so its represented as the type <code>Qobj</code> in qutip. The type <code>Qobj</code> currently doesn't support multiplication with the type <code>sympy.Symbol</code>. Note that you can look under the <code>__rmul__</code> method of <code>Qobj</code> to find which types are supported for multiplying with <code>Qobj</code> on the right.</p>
<p>If you're happy working with the matrix representations of these operators you could do the following to multiply a symbol with the matrix corresponding to <code>destroy(4)</code>. The following will work:</p>
<pre><code>w0 * destroy(4).data.todense()
</code></pre>
<p>This will be a numpy matrix containing symbols, and you can multiply it with the matrices corresponding to other operators in your calculation (at a great loss of efficiency!).</p>
<p>Otherwise this might be worth posting an issue on their github. An implementation might be possible based on how <code>__rmul__</code> is dispatched to <code>numbers.Number</code> <a href=""https://github.com/qutip/qutip/blob/b71625e004b9d99b0c2b4f777c1937d299de08e5/qutip/qobj.py#L603"" rel=""nofollow noreferrer"">here</a>.</p>
",12/29/2021 15:42,Errors," The user is encountering a specific error (""TypeError: Incompatible object for multiplication"") while trying to multiply a symbol with a matrix defined by the QuTiP library. This falls under the ""Errors"" category as it involves troubleshooting a programming issue.",Errors,,,,Errors,
71100198.0,"Missing types, namespaces, directives, and assembly references","<p>I use <code>VS Code</code> for <code>C#</code> and <code>Unity3D</code> and <code>TypeScript</code> and <code>Angular</code> and <code>Python</code> programming, so I have pretty much every required extension, including the <code>.NET Framework</code> and <code>Core</code> as well as the <code>Quantum Development Kit (QDK)</code> plus the <code>Q# Interoperability Tools</code> and also <code>C#</code> and <code>Python</code> extensions for <code>VS Code</code>.</p>
<p>I have devised the following steps to create my first quantum Hello World based on a few tutorials:</p>
<pre><code>$ dotnet --version
$ dotnet --list-sdks
$ dotnet --list-runtimes

$ dotnet new globaljson                                     # Create a &quot;global.json&quot; file in your current directory folder.  
$ dotnet new globaljson --sdk-version 3.1.416 --force       # Change the current SDK version of your project.

$ dotnet new -i Microsoft.DotNet.Web.Spa.ProjectTemplates
$ dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates::0.2-*&quot;

# First, create a Q# application and a .NET host, and then make a call to Q# from the host.
# Create a project for your Q# library and for the .NET host that will call
# into the operations and functions defined in your Q# library.

$ dotnet new classlib -lang Q# -o quantum                         # Create a new Q# class-library project.
$ dotnet new console -lang C# -o host                             # Create a new C# console project.

$ cd host                                                         # Navigate into the C# host directory.
$ dotnet add reference ../quantum/quantum.csproj                  # Add your Q# class-library project as a reference to your C# console project.

$ cd ..                                                           # Exit the C# host directory.
$ dotnet new sln -n quantum-dotnet                                # Create a new solution for both projects.
$ dotnet sln quantum-dotnet.sln add ./quantum/quantum.csproj      # Add the Q# class-library project to the solution.
$ dotnet sln quantum-dotnet.sln add ./host/host.csproj            # Add the C# host project to the solution.

# The -o or --output command specifies the location to place the generated output.
</code></pre>
<p><strong>However</strong>, as soon as this is all done, I get the following load of errors:</p>
<p><a href=""https://i.stack.imgur.com/WcEli.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WcEli.png"" alt=""enter image description here"" /></a></p>
<p>What am I doing wrong? What am I missing?</p>
<hr />
<p>Here is some additional info:</p>
<pre><code>$ dotnet --list-sdks
3.1.416 [C:\Program Files\dotnet\sdk]
5.0.404 [C:\Program Files\dotnet\sdk]

$ dotnet --version  
3.1.416

$ dotnet restore
  Determining projects to restore...
  Restored C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj (in 484 ms).
  Restored C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\host\host.csproj (in 782 ms).
</code></pre>
<hr />
<p>When I run <code>dotnet build</code>, I get the following:</p>
<p>Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.</p>
<p>Determining projects to restore...
All projects are up-to-date for restore.
It was not possible to find any compatible framework version
The framework 'Microsoft.NETCore.App', version '2.0.0' was not found.
- The following frameworks were found:
3.1.22 at [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
5.0.13 at [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]</p>
<p>You can resolve the problem by installing the specified framework and/or SDK.</p>
<p>The specified framework can be found at:
- <a href=""https://aka.ms/dotnet-core-applaunch?framework=Microsoft.NETCore.App&amp;framework_version=2.0.0&amp;arch=x64&amp;rid=win10-x64"" rel=""nofollow noreferrer"">https://aka.ms/dotnet-core-applaunch?framework=Microsoft.NETCore.App&amp;framework_version=2.0.0&amp;arch=x64&amp;rid=win10-x64</a>
C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build\Microsoft.Quantum.Development.Kit.targets(17,5): error MSB3073: The command &quot;dotnet C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build../tools/qsc/qsc.dll --input &quot;Operation.qs&quot; --references &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.canon\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Canon.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.MetaData.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Primitives.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Common.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Core.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Simulators.dll&quot; --outputpath obj\qsharp\src&quot; exited with code -2147450730. [C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj]</p>
<p>Build FAILED.</p>
<p>C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build\Microsoft.Quantum.Development.Kit.targets(17,5): error MSB3073: The command &quot;dotnet C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build../tools/qsc/qsc.dll --input &quot;Operation.qs&quot; --references &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.canon\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Canon.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.MetaData.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Primitives.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Common.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Core.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Simulators.dll&quot; --outputpath obj\qsharp\src&quot; exited with code -2147450730. [C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj]
0 Warning(s)
1 Error(s)</p>
<hr />
<p>When I also build the project (<code>dotnet build quantum-dotnet.sln</code> and <code>dotnet build ./host/host.csproj</code>) I get the same errors.</p>
",<.net><visual-studio-code><quantum-computing><q#>,2/13/2022 11:27,71283954.0,71283954.0,"<p>With help from a user on another forum, it turns out the problem was the command:</p>
<pre><code>dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates::0.2-*&quot;
</code></pre>
<p>which installed version <code>0.2.1802.1603-preview</code> which is quite old. The latest version is <code>0.22.187631</code>.</p>
<p>This did the trick:</p>
<pre><code>dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates&quot;
</code></pre>
<p>Followed by:</p>
<pre><code>dotnet new --update-apply
</code></pre>
<p>to update all the project templates. After this, re-creating the projects fixed all the errors.</p>
<p>Now, I believe the following set of instructions should work for every beginner:</p>
<pre><code># Install the .NET Framework and Core as well as the Quantum Development Kit (QDK)
# plus the Q# Interoperability Tools and also C# and Python extensions for VS Code.

$ dotnet --version
$ dotnet --list-sdks
$ dotnet --list-runtimes

$ dotnet new globaljson                                             # Create a &quot;global.json&quot; file in your current directory folder.  
$ dotnet new globaljson --sdk-version 3.1.416 --force               # Change the current SDK version of your project to .NET 3.1.416

$ dotnet new -i Microsoft.DotNet.Web.Spa.ProjectTemplates
$ dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates&quot;
$ dotnet new --update-apply

# First, create a Q# application and a .NET host, and then make a call to Q# from the host.
# Create a project for your Q# library and for the .NET host that will call
# into the operations and functions defined in your Q# library.

$ dotnet new classlib -lang Q# -o quantum                           # Create a new Q# class-library project.
$ dotnet new console -lang C# -o host                               # Create a new C# console project.
                                                                    # The -o or --output command specifies the location to place the generated output.

$ cd host                                                           # Navigate into the C# host directory.
$ dotnet add reference ../quantum/quantum.csproj                    # Add your Q# class-library project as a reference to your C# console project.

$ cd ..                                                             # Exit the C# host directory.
$ dotnet new sln -n quantum-dotnet                                  # Create a new solution for both projects.
$ dotnet sln quantum-dotnet.sln add ./quantum/quantum.csproj        # Add the Q# class-library project to the solution.
$ dotnet sln quantum-dotnet.sln add ./host/host.csproj              # Add the C# host project to the solution.

$ cd host
$ dotnet build
$ dotnet run
</code></pre>
",2/27/2022 10:24,Errors,"The user is encountering a specific error while setting up a quantum development project with Q# and .NET. This falls under the ""Errors"" category as it involves troubleshooting a programming issue.",Errors,,,,Errors,
71395981.0,How to draw sphere with arrow pointing from sphere in matplotlib,"<p>I try to draw a sphere to represent a qubit using matplotlib</p>
<pre><code>import numpy as np 
import matplotlib.pyplot as plt
theta = [0, np.pi]
phi = [0, 2* np.pi]
N=100
theta_array = np.linspace(theta[0], theta[1], N)
phi_array = np.linspace(phi[0], phi[1], N)
theta_grid, phi_grid = np.meshgrid(theta_array,phi_array)

x = np.sin(theta_grid) * np.cos(phi_grid)
y = np.sin(theta_grid) * np.sin(phi_grid)
z = np.cos(theta_grid)

fig = plt.figure(figsize=(6,6))
ax = fig.gca(projection='3d')
ax.plot_surface(x, y, z, rstride=1, cstride=1, shade=False,linewidth=0)
plt.show()
</code></pre>
<p><a href=""https://i.stack.imgur.com/IAySu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IAySu.png"" alt=""enter image description here"" /></a></p>
<p>I want to add tube arrows on the sphere with directions parallel with xyz axis, like this:<a href=""https://i.stack.imgur.com/uBDcE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uBDcE.png"" alt=""enter image description here"" /></a></p>
<p>I am not an expert in matplotlib, so it's seem pretty tough to me. Can anyone help me? thanks in advance!</p>
",<python><matplotlib><coordinates><arrows><qubit>,03/08/2022 13:38,71397620.0,71397620.0,"<p>You can use the <code>quiver</code> function to to what you want.
See code below:</p>
<pre class=""lang-py prettyprint-override""><code>import numpy as np 
import matplotlib.pyplot as plt

theta = [0, np.pi]
phi = [0, 2* np.pi]
N=100
theta_array = np.linspace(theta[0], theta[1], N)
phi_array = np.linspace(phi[0], phi[1], N)
theta_grid, phi_grid = np.meshgrid(theta_array,phi_array)

x = np.sin(theta_grid) * np.cos(phi_grid)
y = np.sin(theta_grid) * np.sin(phi_grid)
z = np.cos(theta_grid)

fig = plt.figure(figsize=(6,6))
ax = fig.gca(projection='3d')
ax.view_init(azim=60)
ax.plot_surface(x, y, z, rstride=1, cstride=1, shade=False,linewidth=0)

#Set up arrows

ax.quiver(1,0,0,1,0,0,color = 'k', alpha = .8, lw = 3) #x arrow
ax.text(2.4,0,0,'Sx',fontsize=20) 

ax.quiver(0,1,0,0,1,0,color = 'k', alpha = .8, lw = 3)#y arrow
ax.text(0,2.4,0,'Sy',fontsize=20)

ax.quiver(0,0,1,0,0,1,color = 'k', alpha = .8, lw = 3)#z arrow
ax.text(-0.3,0,1.8,'Sz',fontsize=20)

plt.show()
</code></pre>
<p>And the output gives:</p>
<p><a href=""https://i.stack.imgur.com/uzyDx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uzyDx.png"" alt=""enter image description here"" /></a></p>
",03/08/2022 15:36,Tooling ,"The user is asking for help with a specific tool, matplotlib, to draw a sphere and add tube arrows on it. This falls under software usage in quantum programming",Tooling,,,,Tooling ,
71571268.0,Accessing Qubit With DAGCircuit,"<p>I'm currently trying to make my own TransformationPass to use when compiling a QuantumCircuit for specific hardware, but I'm struggling to get things to work with the DAGCircuit that gets passed to the <code>run(self, dag)</code> method that gets overridden. My main issue at the moment is trying to figure out which qubits each node in the graph actually operates on. I can access the wire for each node, but accessing the qubit index from there raises a DeprecationWarning.</p>
<p>I can simply ignore the warning, but it gives me the impression that I should be going about this another way.</p>
<p>Is there a formal method for accessing the qubit (either object or simply its index) given the DAG?</p>
",<quantum-computing><qiskit>,3/22/2022 11:26,71571381.0,71571381.0,"<p>For <code>DAGCircuit</code> right now there isn't a great answer for this. The <code>.index</code> attribute is deprecated as in the case of standalone bit objects on the circuit if they're in a register it might not yield the result you expect (it'll be the register index not the index on the circuit necessarily).</p>
<p>I typically do this by having something like:</p>
<pre class=""lang-py prettyprint-override""><code>dag_qubit_map = {bit: index for index, bit in enumerate(dag.qubits)}
</code></pre>
<p>and then I can get the index with a dict look up, something like:</p>
<pre class=""lang-py prettyprint-override""><code>bit_index = dag_qubit_map[node.qargs[0]]
</code></pre>
<p>On the <code>QuantumCircuit</code> class there is a <code>.find_bit()</code> method which does this easily: <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.find_bit.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.find_bit.html</a></p>
<p>so you can do:</p>
<pre class=""lang-py prettyprint-override""><code>bit_index = QuantumCircuit(bit).index
</code></pre>
<p>But an equivalent API is still needed for the DAGCircuit class.</p>
",3/22/2022 11:35,Tooling,"The user is asking about accessing qubits from a DAGCircuit in Qiskit, which is related to using a specific feature within the Qiskit framework, making it a tooling question.", Tooling,,,,Tooling,
71596588.0,where can I get the detailed tutorial or document for Q# machine learning,"<p>Recently, I'm learning the Q# language for machine learning. The sample of half-moons has been run correctly. Now I want to learn the detail of the code. But there is too little explanation to find. There are too many methods I can't understand and there are no introductions in detail. For example, it only explains the name, parameters for the method, but no further information.<img src=""https://i.stack.imgur.com/uaSzW.png"" alt=""enter image description here"" />
I really can't understand it.
So is there an exits detailed document for machine learning for beginners? Thank u very much.</p>
<p>how to get the detained document</p>
",<machine-learning><quantum-computing><q#>,3/24/2022 3:05,71621020.0,71621020.0,"<p>Q# machine learning library implements one specific approach, circuit-centric quantum classifiers. You can find the documentation for this approach at <a href=""https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/machine-learning/intro"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/machine-learning/intro</a> and the subsequent pages in that section. The paper it's based on is  <a href=""https://arxiv.org/abs/1804.00633"" rel=""nofollow noreferrer"">'Circuit-centric quantum classifiers', Maria Schuld, Alex Bocharov, Krysta Svore and Nathan Wiebe</a>.</p>
",3/25/2022 17:34,Learning,"The user is asking for learning resources, tutorials, and references in quantum computing. They are specifically looking for detailed documentation for machine learning in Q#. ",Learning,,,,Learning,
71597788.0,What's the meaning of type 'd in q#,"<p><img src=""https://i.stack.imgur.com/MCbmq.png"" alt=""enter image description here"" /></p>
<p>As shown in the picture above. What's the meaning of type 'd? What's type the return value of &quot;Zipped&quot; should be?</p>
",<types><q#>,3/24/2022 6:12,71621085.0,71621085.0,"<p>Types like <code>'d</code> or <code>'c</code> appear in the error messages when the Q# compiler fails to infer types of any values involved. In this case, there is a type mismatch between the return of <code>Zipped</code>, which is an array of tuples, and the return type of the operation, which from the screenshot looks like <code>Double[][]</code>, an array of arrays of double.</p>
<p>Edit: In this particular case the compiler knows the return type produced by <code>Zipped</code>, so it should use it instead of a generic. There's an <a href=""https://github.com/microsoft/qsharp-compiler/issues/1395"" rel=""nofollow noreferrer"">issue</a> opened in the Q# compiler repo for this - thank you for bringing this up!</p>
",3/25/2022 17:41,Tooling,The user is asking about how to use a particular software or tool for quantum programming. They are trying to understand the meaning of type 'd and the return value of the Zipped function in Q#. ,Tooling,,,,Tooling,
71617443.0,Why Pauli Z can be used to measure a single qubit ï¼,"<p>According to the Q# documentation, a  single qubit can be measured by M.The method uses Pauli-Z. But why Pauli  Z can be used to measure a single qubit? I have known the matrix of Pauli-Z like below:
<img src=""https://i.stack.imgur.com/xRwBm.png"" alt=""enter image description here"" /></p>
<p>and the output result is given by the distribution:</p>
<p><img src=""https://i.stack.imgur.com/N2v6w.png"" alt=""enter image description here"" /></p>
<p>But what's the relationship between the matrix and the formula? What's happened with method M? I really need your help.</p>
",<quantum-computing><q#>,3/25/2022 13:04,71621482.0,71621482.0,"<p>Pauli Z matrix defines the basis in which the measurement is performed. A measurement in the Pauli Z basis is the same as the computational basis measurement, projecting the state onto one of the states |0â© or |1â© (the eigenstates of Pauli Z matrix).</p>
<p>I'm not up for spelling the math here, since classical StackOverflow doesn't support LaTeX. You can find a good tutorial on single-qubit measurements in Q# in the <a href=""https://github.com/microsoft/QuantumKatas/tree/main/tutorials/SingleQubitSystemMeasurements"" rel=""nofollow noreferrer"">Quantum Katas project</a>.</p>
",3/25/2022 18:18,Conceptual,The question is primarily seeking conceptual understanding about the use of the Pauli-Z matrix for measuring a single qubit and its relationship with the measurement outcome distribution.,Conceptual,,,,Conceptual,
72031758.0,sympy: substitution of expressions with Braket-notation,"<p>I am using sympy (in sagemath). I would like to do a substitution, with Braket-notation (for quantum mechanical problem). Below there is a minimalistic code, in order to reproduce the problem.</p>
<pre><code>from sympy.physics.quantum import Bra, Ket
from sympy import *
theta=symbols('theta',commutative=True)
pi, mu= symbols(&quot;pi mu&quot;,commutative=False)
W=2*pi*mu
print(W.subs(pi*mu,theta))
V=Bra(pi)*Ket(mu)
print(V.subs(Bra(pi)*Ket(mu),theta))
U=2*Bra(pi)*Ket(mu)
print(U.subs(Bra(pi)*Ket(mu),theta))
</code></pre>
<p>The output is:</p>
<pre><code>2*theta
theta
2*&lt;pi|*|mu&gt;
</code></pre>
<p>If there is no leading scalar multiplier, the substitution works finely. I am stuck with a more complicated expression.</p>
",<sympy><quantum-computing>,4/27/2022 15:48,72032642.0,72032642.0,"<p>In these occasions <code>srepr</code> can shed some light:</p>
<pre><code>srepr(U)
# out: &quot;Mul(Integer(2), Bra(Symbol('pi', commutative=False)), Ket(Symbol('mu', commutative=False)))&quot;

srepr(Bra(pi)*Ket(mu))
# out: &quot;InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False)))&quot;
</code></pre>
<p>Note that the first output is a multiplication, object of type <code>Mul</code>, whereas the second output is an object of type <code>InnerProduct</code>. With the command <code>U.subs(Bra(pi)*Ket(mu),theta)</code> you are asking to search for an object of type <code>InnerProduct</code> into <code>U</code>, but there is none, hence no substitution has been done.</p>
<p>In this case, you have to do:</p>
<pre><code>U.subs(Mul(Bra(pi), Ket(mu)),theta)
# out: 2*theta
</code></pre>
<p>Edit: or as @Oscar Benjamin pointed out, you do:</p>
<pre><code>from sympy.physics.quantum import qapply
U = qapply(U)
srepr(U)
# out: &quot;Mul(Integer(2), InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False))))&quot;
</code></pre>
<p>Now you can see an <code>InnerProduct</code> as an argument of <code>Mul</code>. FInally:</p>
<pre><code>U.subs(Bra(pi)*Ket(mu), theta)
# out: 2*theta
</code></pre>
",4/27/2022 16:56,Tooling,"The user is asking for help with a specific tool, sympy, to perform a substitution operation in a quantum mechanical problem. This falls under software usage in quantum programming",Tooling,,,,Tooling,
72203438.0,What IBM_Q backend supports Qiskit Pulse?,"<p>I was doing an experiment with open pulse on caliberation of a qubit and I stumbled upon this error:</p>
<p>Traceback (most recent call last):
Input In [73] in &lt;cell line: 1&gt;
frequency_sweep_results = job.result(timeout=120) # timeout parameter set to 120 seconds
File /opt/conda/lib/python3.8/site-packages/qiskit/providers/ibmq/job/ibmqjob.py:290 in result
raise IBMQJobFailureError(
IBMQJobFailureError: 'Unable to retrieve result for job 627bcffafd267c3dbc4f42f7. Job has failed: The Qobj pulse type is not supported by the selected backend. Error code: 1108.'</p>
<p>Error code 1108 being :
Run the job on a backend that supports open pulse. Whether a backend supports open pulse can be found in its configuration data.</p>
<p>Use %tb to get the full traceback</p>
<p>I have used ibmq_santiago,ibmq_manila and ibmq_lima so far all giving me the same error.</p>
<p>Could someone suggest a backend that supports qiskit pulse?</p>
",<quantum-computing><qiskit>,05/11/2022 15:08,72203642.0,72203642.0,"<p>You can check out the backends with pulse support in the <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;view=table"" rel=""nofollow noreferrer"">table view of IBM service list</a>:</p>
<p><a href=""https://i.stack.imgur.com/eIody.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eIody.png"" alt=""backends with OpenPulse support"" /></a></p>
<p>Programmatically, you can list the backends with pulse support you have access to in the following way:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit import IBMQ
provider = IBMQ.load_account()
backends_supporting_openpulse = provider.backends(filters=lambda b: b.configuration().open_pulse)
</code></pre>
",05/11/2022 15:23,Tooling,"The user is asking for help with a specific tool, Qiskit Pulse, to perform an experiment on the calibration of a qubit. They are encountering an error because the backend they are using does not support Qiskit Pulse. This falls under software usage in quantum programming.",API Usage,"The user is encountering an issue related to the selection of a suitable backend that supports Qiskit Pulse, which is a question related to how to use the Qiskit API effectively for pulse-level experiments.",No,22.0,Tooling,"This is because the user is seeking assistance in selecting a suitable backend that supports Qiskit Pulse for their experiment, which falls under the category of tooling and functionality within the Qiskit framework."
72341743.0,How to decompose a N x N unitary matrix into 2- or 1-qubit operators?,"<p>Given an N x N unitary operator M, I would like to build a circuit that does the same operation as M by explicitly inputting the gates myself (let's say into the IBMQ composer). I heard that 2-qubit operators could be decomposed using a Qiskit built-in function, however I was wondering if such a thing existed for a general case.</p>
<p>More concretely, given a N x N unitary operator M, I would like to decompose it to something of the form</p>
<p>M_1 x M_2 x M_3 x ... x M_n</p>
<p>where &quot;x&quot; represents the tensor product and M_i is either a 2- or 1-qubit unitary  operator.
Is there a way to do this programatically, or can it be done by hand on paper in an algorithmic way?</p>
<p>Thank you in advance!</p>
",<quantum-computing><qiskit>,5/22/2022 22:33,72349417.0,72349417.0,"<p>If you want to implement custom unitary, there is a way to do it using Operator function, like this (example for 4x4 unitary matrix):</p>
<pre><code>from qiskit import QuantumRegister, QuantumCircuit
from qiskit.quantum_info.operators import Operator

q =  QuantumRegister(2,&quot;qreg&quot;)
qc = QuantumCircuit(q)

customUnitary = Operator([
    [1, 0, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0]
])
qc.unitary(customUnitary, [q[0], q[1]], label='custom')
qc.draw(output='mpl')
</code></pre>
<p>But if your purpose is to decompose it to 1 or 2-qubit operators, the problem is more complex since there can be multiple ways to decompose the same unitary.</p>
<p>I think the best you can do is to use Qiskit transpiler and define set of gates you want to use:</p>
<pre><code>from qiskit.compiler import transpile

newCircuit = transpile(qc, basis_gates=['ry', 'rx', 'cx'], optimization_level = 3)
newCircuit.draw(output='mpl')
</code></pre>
",5/23/2022 13:28, Tooling,The user is asking about how to use a particular software or tool for quantum programming. They are trying to understand how to decompose a general N x N unitary operator into a product of 2- or 1-qubit unitary operators., Tooling,,,, Tooling,
72413224.0,I am getting 'No memory for the experiment' error although i dont see any mistake,"<p>I am trying to execute this code but I am getting this error as 'No memory for the experiment' . Can anyone help me out is there anything else I need to import to get the memory of circuit?</p>
<pre><code>from qiskit.providers.aer import QasmSimulator
# Create a quantum circuit
qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
# Get the Qasm simulator and set the backend options
aer_qasm_simulator = Aer.get_backend('qasm_simulator')
# Set the backend options, method set to statevector
options = {'method': 'statevector', 'memory' : True, 'shots':10}
# Execute circuit using the backend options created
job = execute(qc, backend_simulator, backend_options=options)
result = job.result()
# Pull the memory slots for the circuit
memory = result.get_memory(qc)
# Print the results from the memory slots
print('Memory results: ', memory)```

</code></pre>
",<python><qiskit>,5/28/2022 5:49,72423880.0,72423880.0,"<p>The problem with your code is that <code>memory</code> and <code>shots</code> are not backend options, but <code>execute</code> parameters:</p>
<pre class=""lang-py prettyprint-override""><code># Set the backend options, method set to statevector
options = {'method': 'statevector'}
# Execute circuit using the backend options created
job = execute(qc, aer_qasm_simulator, backend_options=options, memory=True, shots=10)
</code></pre>
<p>That would fix your issue.</p>
<p>Side note: Qiskit is <a href=""https://github.com/Qiskit/qiskit-terra/pull/7892"" rel=""nofollow noreferrer"">moving away from the <code>execute</code> model</a> because, among other things, it creates this kind of confusions.</p>
<p>The current (May 2022) way of doing what you are doing is the following:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit import QuantumCircuit, Aer, transpile
from qiskit.providers.aer import QasmSimulator

# Create a quantum circuit
qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])

# Get the statevector simulator
aer_simulator_statevector = Aer.get_backend('aer_simulator_statevector')

# Transpile for the backend. Strictly speacking, not necesary in this case
qc = transpile(qc, aer_simulator_statevector)

# Pull the memory slots for the circuit
result = aer_simulator_statevector.run(qc, shots=10, memory=True).result()
memory = result.get_memory(qc)

# Print the results from the memory slots
print('Memory results: ', memory)
</code></pre>
<p>Welcome to the StackOverflow community :)</p>
",5/29/2022 13:02,Errors,The user is seeking solutions and explanations for an error they encountered while trying to execute a quantum circuit using Qiskit. The error is specifically related to the No memory for the experiment message they received,Errors,,,,Errors,
72417370.0,Qiskit: 'no counts for experiment',"<p>Although I imported <code>plot_histogram</code>, I am not getting the output as expected. Here is my code:</p>
<pre><code>a = QuantumCircuit(1)
a.z(0)
a.x(0)
a.h(0)
a.sdg(0)
a.t(0)
backend = Aer.get_backend('qasm_simulator')
result = execute(a, backend).result()
counts = result.get_counts()
plot_histogram(counts)
print(c)```
</code></pre>
",<qiskit>,5/28/2022 16:29,72421265.0,72421265.0,"<p>You are missing measurements.</p>
<pre><code>a.z(0)
a.x(0)
a.h(0)
a.sdg(0)
a.t(0)
a.measure_all(). #&lt;--
... 
</code></pre>
<p>This will measure the qubits and set a classical register with the result.</p>
",5/29/2022 5:55,Errors,The user is seeking solutions and explanations for an error they encountered while trying to plot a histogram for their quantum circuit using Qiskit. The error is specifically related to the plot_histogram function not producing the expected output.,Errors,,,,Errors,
72451052.0,"Multi-processing a for loop, target's argument needs to be a list","<p>I'm trying to use multiprocessing to split a for loop over multiple processes. Thus speeding up a QuTiP's library solver, here's my target function:</p>
<pre><code>def solve_entropy(t):

    # Parameters
    k = 0.5
    n = 2
    N = 5
    r = 1.0
    alpha = 2.0
    beta = 2.0
    gamma = 0.2
    wm = 1
    w0 = r * wm
    g = k * wm

    # Operators
    a = tensor(destroy(N), identity(N), identity(N))
    b = tensor(identity(N), destroy(N), identity(N))
    c = tensor(identity(N), identity(N), destroy(N))

    # result = mesolve(H,psi0,t,c_ops)
    result = mesolve(
        w0 * a.dag() * a
        + w0 * b.dag() * b
        + wm * c.dag() * c
        - g * a.dag() * a * (c + c.dag())
        - g * b.dag() * b * (c + c.dag()),
        tensor(coherent(N, alpha), coherent(N, alpha), coherent(N, beta)),
        t,
        sqrt(gamma) * c,
    )

    S = [entropy_linear(ptrace(i, n)) for i in result.states]
    return S
</code></pre>
<p>where mesolve takes a list of times (t) as argument, here's my multiprocessing code:</p>
<pre><code>if __name__ == &quot;__main__&quot;:

    t = np.linspace(0, 25, 100)  # list of times t

    pool = mp.Pool(mp.cpu_count())
    result = pool.map(solve_entropy, t)
    pool.close()
    pool.join()

    data = list(zip(t, result))
    np.savetxt(&quot;entropy.dat&quot;, data, fmt=&quot;%.8f&quot;)
</code></pre>
<p>However when I run this code I get the following error &quot;object of type 'numpy.float64' has no len()&quot;.</p>
<p>It seems like mp.Pool splits my list t in float points instead of a smaller list, and since mesolve needs a list as argument I get an error.
Is there a way to keep &quot;t&quot; as a list over multiple processes? Since it won't work if &quot;t&quot; is a number.</p>
",<python><numpy><multiprocessing><physics><qutip>,5/31/2022 16:10,72452112.0,72452112.0,"<p>First, define function <code>split</code>, which takes an iterable and splits it into n lists:</p>
<pre class=""lang-py prettyprint-override""><code>def split(iterable, n):  # function to split iterable in n even parts
    if type(iterable) is range and iterable.step != 1:
        # algorithm doesn't work with steps other than 1:
        iterable = list(iterable)
    l = len(iterable)
    n = min(l, n)
    k, m = divmod(l, n)
    return list(iterable[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in range(n))
</code></pre>
<p>Then:</p>
<pre class=""lang-py prettyprint-override""><code>if __name__ == &quot;__main__&quot;:

    # One smaller list for each process in the pool
    # This will create a list of numpy.ndarray instances:
    t = split(np.linspace(0, 25, 100), mp.cpu_count())
    ... # etc.
</code></pre>
<p><strong>Update: Seeing the <code>split</code> Function In Action</strong></p>
<p>I have converted the <code>split</code> function into a generator function to better see what happens on each iteration. With a list of 93 elements being split into 10 sublists, the algorithm attempts to make each list as close to the same size it can. The code is very clever (I did not write it, but found it). In this case the statement <code>k, m = divmod(l, n)</code> with <code>l</code> -&gt; 93 and <code>n</code> -&gt; 10, it results in <code>k</code> -&gt; 9 and <code>m</code> -&gt; 3. Since <code>m</code> is not 0, it will create <code>m</code> lists of size <code>k+1</code> and <code>n-m</code> lists of size <code>k</code>.</p>
<pre class=""lang-py prettyprint-override""><code>def split(iterable, n):  # function to split iterable in n even parts\n,
    if type(iterable) is range and iterable.step != 1:
        # algorithm doesn't work with steps other than 1:
        iterable = list(iterable)
    l = len(iterable)
    n = min(l, n)
    k, m = divmod(l, n)
    print()
    print(f'list size is {l}, number of sublists = {n}, k = {k}, m = {m}')
    if m == 0:
        print(f'This should yield {n} sublists of size {k}')
    else:
        print(f'Thus should yield {m} lists of size {k+1} and {n-m} lists of size {k}')
    print()
    for i in range(n):
        index_start = i * k + min(i, m)
        index_end = (i + 1) * k + min(i + 1, m)
        list_size = index_end - index_start
        print(f'i = {i}, min(i, m) = {min(i, m)}, min(i + 1, m) = {min(i + 1, m)}, index_start = {index_start}, index_end = {index_end}, size = {list_size}')
        yield iterable[index_start:index_end]


for sublist in split(list(range(93)), 10):
    print('sublist =', sublist)

for sublist in split(list(range(30)), 10):
    print('sublist =', sublist)

for sublist in split(list(range(27)), 4):
    print('sublist =', sublist)
</code></pre>
<p>Prints:</p>
<pre class=""lang-None prettyprint-override""><code>list size is 93, number of sublists = 10, k = 9, m = 3
Thus should yield 3 lists of size 10 and 7 lists of size 9

i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 10, size = 10
sublist = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 10, index_end = 20, size = 10
sublist = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 20, index_end = 30, size = 10
sublist = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 30, index_end = 39, size = 9
sublist = [30, 31, 32, 33, 34, 35, 36, 37, 38]
i = 4, min(i, m) = 3, min(i + 1, m) = 3, index_start = 39, index_end = 48, size = 9
sublist = [39, 40, 41, 42, 43, 44, 45, 46, 47]
i = 5, min(i, m) = 3, min(i + 1, m) = 3, index_start = 48, index_end = 57, size = 9
sublist = [48, 49, 50, 51, 52, 53, 54, 55, 56]
i = 6, min(i, m) = 3, min(i + 1, m) = 3, index_start = 57, index_end = 66, size = 9
sublist = [57, 58, 59, 60, 61, 62, 63, 64, 65]
i = 7, min(i, m) = 3, min(i + 1, m) = 3, index_start = 66, index_end = 75, size = 9
sublist = [66, 67, 68, 69, 70, 71, 72, 73, 74]
i = 8, min(i, m) = 3, min(i + 1, m) = 3, index_start = 75, index_end = 84, size = 9
sublist = [75, 76, 77, 78, 79, 80, 81, 82, 83]
i = 9, min(i, m) = 3, min(i + 1, m) = 3, index_start = 84, index_end = 93, size = 9
sublist = [84, 85, 86, 87, 88, 89, 90, 91, 92]

list size is 30, number of sublists = 10, k = 3, m = 0
This should yield 10 sublists of size 3

i = 0, min(i, m) = 0, min(i + 1, m) = 0, index_start = 0, index_end = 3, size = 3
sublist = [0, 1, 2]
i = 1, min(i, m) = 0, min(i + 1, m) = 0, index_start = 3, index_end = 6, size = 3
sublist = [3, 4, 5]
i = 2, min(i, m) = 0, min(i + 1, m) = 0, index_start = 6, index_end = 9, size = 3
sublist = [6, 7, 8]
i = 3, min(i, m) = 0, min(i + 1, m) = 0, index_start = 9, index_end = 12, size = 3
sublist = [9, 10, 11]
i = 4, min(i, m) = 0, min(i + 1, m) = 0, index_start = 12, index_end = 15, size = 3
sublist = [12, 13, 14]
i = 5, min(i, m) = 0, min(i + 1, m) = 0, index_start = 15, index_end = 18, size = 3
sublist = [15, 16, 17]
i = 6, min(i, m) = 0, min(i + 1, m) = 0, index_start = 18, index_end = 21, size = 3
sublist = [18, 19, 20]
i = 7, min(i, m) = 0, min(i + 1, m) = 0, index_start = 21, index_end = 24, size = 3
sublist = [21, 22, 23]
i = 8, min(i, m) = 0, min(i + 1, m) = 0, index_start = 24, index_end = 27, size = 3
sublist = [24, 25, 26]
i = 9, min(i, m) = 0, min(i + 1, m) = 0, index_start = 27, index_end = 30, size = 3
sublist = [27, 28, 29]

list size is 27, number of sublists = 4, k = 6, m = 3
Thus should yield 3 lists of size 7 and 1 lists of size 6

i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 7, size = 7
sublist = [0, 1, 2, 3, 4, 5, 6]
i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 7, index_end = 14, size = 7
sublist = [7, 8, 9, 10, 11, 12, 13]
i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 14, index_end = 21, size = 7
sublist = [14, 15, 16, 17, 18, 19, 20]
i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 21, index_end = 27, size = 6
sublist = [21, 22, 23, 24, 25, 26]
</code></pre>
<p><strong>Explanation</strong></p>
<p>When <code>m</code> is 0 (the iterable of length <code>l</code> can be divided into <code>n</code> sublists of size <code>l // n</code>, then the ith starting slice index is:</p>
<pre class=""lang-py prettyprint-override""><code>i * k + min(i, m)
# but min(i, m) is 0 for all i, so this is just:
i * k # where k is the size of each sublist, l // n
</code></pre>
<p>But when <code>m</code> is not 0, <code>min(i, m)</code> is just <code>i</code> for the first <code>m</code> sublists, so the starting index is</p>
<pre><code>i * k + i -&gt; i * (k+1)
</code></pre>
<p>and the ending index is</p>
<pre><code>(i + 1) * k + i + 1 -&gt; i * (k+1) + k + 1
</code></pre>
<p>So the first <code>m</code> sublists are length <code>k + 1</code>. The starting index of ith sublist for <code>i == m</code> is</p>
<pre><code>i * k + min(i, m) -&gt; m * k + m
</code></pre>
<p>and the ending index is</p>
<pre><code>(i + 1) * k + min(i + 1, m) -&gt; (m + 1) * k + m -&gt; m * k + k + m
</code></pre>
<p>The difference between the ending and starting indices is just <code>k</code>.</p>
<p><strong>Update 2</strong>
Here is <code>split</code> rewritten as a generator function, which makes the logic clearer:</p>
<pre class=""lang-py prettyprint-override""><code>def split(iterable, n):
    if type(iterable) is range and iterable.step != 1:
        # algorithm doesn't work with steps other than 1:
        iterable = list(iterable)
    l = len(iterable)
    n = min(l, n)
    k, m = divmod(l, n)
    start_index = 0
    if m == 0:
        for _ in range(n):
            end_index = start_index + k
            yield iterable[start_index:end_index]
            start_index = end_index
    else:
        l2 = k + 1
        for _ in range(m):
            end_index = start_index + l2
            yield iterable[start_index:end_index]
            start_index = end_index
        for _ in range(n - m):
            end_index = start_index + k
            yield iterable[start_index:end_index]
            start_index = end_index
</code></pre>
",5/31/2022 17:43,Errors,The user is seeking solutions and explanations for an error they encountered while trying to use multiprocessing in a quantum programming context. The error is specifically related to the object of type numpy.float64 has no len() message they received.,Errors,,,,Errors,
72613796.0,How to create Controlled Z gate in sympy.physics.quantum.gate qubits,"<p>I am wondering if it is possible to create a controlled Z-Gate using the sympy.physics.quantum.gate package?</p>
<p><a href=""https://i.stack.imgur.com/28D4D.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/28D4D.png"" alt=""enter image description here"" /></a></p>
<p>I've tried something like this</p>
<pre><code>CGate(((0,1), Z(2)))
</code></pre>
<p>where the first tuple are the controls and the second the gate but I'm getting this error</p>
<p><a href=""https://i.stack.imgur.com/FWJKs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FWJKs.png"" alt=""enter image description here"" /></a></p>
<p>Ideally I'd like to be able to set controls on multiple qubits and to also be able to drop in any gate.</p>
<p>also, is it possible to to create an arbitary rotation gate and use it with this? eg the arbitary x rotation gate I created below</p>
<pre><code>def Rx(ctrl=1, angle=theta):
&quot;&quot;&quot;Rotation in x axis

Args:
    ctrl (int, optional): which qubit from bottom up to apply to. Defaults to 1.
    angle (_type_, optional): enter angle or leave as theta symbol. Defaults to theta.

Returns:
    rotation: set of gate rotations
&quot;&quot;&quot;
rot = cos(theta/2)*Im-j*sin(theta/2)*Xm
return UGate((ctrl,), rot.subs(theta, angle))
</code></pre>
<p>where Xm =
<a href=""https://i.stack.imgur.com/yaJtG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yaJtG.png"" alt=""![$X = \begin{bmatrix}
0&amp; 1\
1&amp; 0
\end{bmatrix} $"" /></a></p>
<p>Any help would be really appreciated :)</p>
",<python><sympy><quantum-computing>,6/14/2022 8:31,72622388.0,72622388.0,"<p>Your approach to creating multi-controlled gates should work, you just need to remove excessive parentheses:</p>
<pre><code>gate = CGate((0, 1), Z(2))
qapply(gate * Qubit('111')) 
</code></pre>
",6/14/2022 19:25,Errors,The user is seeking solutions and explanations for an error they encountered while trying to create a controlled Z-Gate using the sympy.physics.quantum.gate package in a quantum programming context. The error is specifically related to the CGate function., Errors ,,,,Errors,
72785037.0,AWS braket python sdk: user is not authorized to perform on quantum device,"<p>I have installed boto3, aws cli, and python-braket-sdk. I have run <code>aws configure</code>, and config with my IAM user. My IAM user isn't root user, but it has <code>AdministratorAccess</code>, <code>AmazonBraketFullAccess</code>, <code>AmazonBraketJobsExecutionPolicy</code> policies.</p>
<p>But if I tried to get some quantum device by this command:<code>aws braket get-device --device-arn arn:aws:braket:::device/qpu/ionq/ionQdevice</code>, it always return this error:</p>
<p><code>An error occurred (AccessDeniedException) when calling the GetDevice operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: braket:GetDevice on resource: arn:aws:braket::178363055402:device/qpu/ionq/ionQdevice with an explicit deny</code></p>
<p>If I run same below python from this link: <a href=""https://github.com/aws/amazon-braket-sdk-python#usage"" rel=""nofollow noreferrer"">https://github.com/aws/amazon-braket-sdk-python#usage</a>, it also return similar error:</p>
<pre><code>import boto3
from braket.aws import AwsDevice
from braket.circuits import Circuit
device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)
bell = Circuit().h(0).cnot(0, 1)
task = device.run(bell, shots=100)
print(task.result().measurement_counts)
</code></pre>
<p>Error output:</p>
<pre><code>AccessDeniedException: An error occurred (AccessDeniedException) when calling the GetDevice 
operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: 
braket:GetDevice on resource: arn:aws:braket::178363055402:device/quantum-simulator/amazon/sv1 
with an explicit deny
</code></pre>
<p>I have already added permissions for Braket, but I can not figure the reason for this bug. Please help</p>
<p><strong>System information</strong></p>
<ul>
<li><strong>aws cli</strong>: aws-cli/2.7.11 Python/3.9.11 Windows/10 exe/AMD64 prompt/off</li>
<li><strong>Amazon Braket Python SDK version</strong>: 1.25.2</li>
<li><strong>Amazon Braket schemas</strong>: 1.10.0</li>
<li><strong>Amazon Braket default simulator</strong>: 1.6.2</li>
<li><strong>Python version</strong>: 3.8.13</li>
</ul>
",<amazon-web-services><amazon-ami><quantum-computing><qiskit>,6/28/2022 10:44,72974684.0,72974684.0,"<p>I have found the answer. I have activated MFA authorization on my account, but in my <code>aws cli</code>, I don't setup it. So I need to setup my <code>aws cli</code> by a new account without MFA, or set up MFA for my <code>aws cli</code>. Thank you everyone for help</p>
",7/14/2022 2:54,Errors,The user is seeking solutions and explanations for an error they encountered while trying to use Amazon Braket with the AWS CLI and the Amazon Braket Python SDK. The error is specifically related to the AccessDeniedException message they received.,Errors,,,,Errors,
72875257.0,"Cannot import QISKIT ""ModuleNotFoundError: No module named 'qiskit._accelerate'""","<p>I'm trying to use qiskit in virtual environment via Anaconda, however although I see qiskit as installed, importing qiskit always fails with:</p>
<p>ModuleNotFoundError: No module named 'qiskit._accelerate'</p>
<p>I can't find information about this anywhere. What is this module? What is wrong with the environment? It seems there's nothing called qiskit._accelerate</p>
",<python><anaconda><qiskit>,07/05/2022 20:36,72888163.0,72888163.0,"<p>I've solved the issue thanks to Joseph Geipel's advice.
There's some compatibility issue between Python and Qiskit.</p>
<p>Python 3.9.12 and Qiskit 0.37.0 seem not to work well together.
When I've created a new environment with Python 3.8.13 and the same version of Qiskit, the problem was solved.</p>
",07/06/2022 18:11,Errors,The user is seeking solutions and explanations for an error they encountered while trying to import the Qiskit module in a virtual environment via Anaconda. The error is specifically related to the ModuleNotFoundError: No module named qiskit._accelerate message they received., Errors,,,,Errors,
72892946.0,PyCharm does not show Qiskit vizualization,"<p>I cannot get a histogram from <code>Qiskit</code> to show using <code>PyCharm</code>, even though I am getting the numbers correctly. Code is the following:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import QasmSimulator
from qiskit.visualization import plot_histogram
from matplotlib import pyplot as plt

simulator = QasmSimulator()
circuit = QuantumCircuit(2, 2)
circuit.h(0)

# Add a CX (CNOT) gate on control qubit 0 and target qubit 1
circuit.cx(0, 1)

# Map the quantum measurement to the classical bits
circuit.measure([0,1], [0,1])
compiled_circuit = transpile(circuit, simulator)
job = simulator.run(compiled_circuit, shots=1000)
result = job.result()
counts = result.get_counts(compiled_circuit)
print(&quot;\nTotal count for 00 and 11 are:&quot;,counts)
plot_histogram(counts)
</code></pre>
<p>I should be getting an image like:</p>
<p><img src=""https://i.stack.imgur.com/9lAXi.png"" alt=""this"" /></p>
",<python><pycharm><qiskit>,07/07/2022 06:03,72896961.0,72896961.0,"<p><code>plot_histogram</code> uses Matplotlib to show the histogram. PyCharm offers the option for rendering <a href=""https://www.jetbrains.com/help/pycharm/matplotlib-support.html#scientific-project"" rel=""nofollow noreferrer"">Matplotlib graphs in Scientic Mode</a>, which <strong>only exists in PyCharm Professional</strong>.</p>
",07/07/2022 11:23,Errors,The user is seeking solutions and explanations for an error they encountered while trying to display a histogram from Qiskit using PyCharm. The error is specifically related to the plot_histogram function not producing the expected output.,Errors,,,,Errors,
73239349.0,"Why am I getting ""NameError: name 'qiskit' is not defined"" on my program when I already imported all qiskit functions","<p>I'm using the IBM quantum lab to run my python program. I imported all these functions/libraries:</p>
<p>from ibm_quantum_widgets import CircuitComposer</p>
<p>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit</p>
<p>from numpy import pi</p>
<p>import json</p>
<p>import ast</p>
<p>from qiskit import *</p>
<p>from qiskit import QuantumCircuit, execute, BasicAer</p>
<p>from qiskit.tools.monitor import job_monitor</p>
<p>from qiskit import IBMQ</p>
<p>from qiskit import BasicAer</p>
<p>just to make sure I literally got everything from the qiskit library (if that's the right term, I'm kind of a beginner). It's overkill but I did it mainly because every time I run my program and get to this line of code:</p>
<p>measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1)</p>
<p>I get a nameerror, qiskit not defined. I wanted to import everything just to be sure that wasn't the issue. Does anyone understand what possibly could be the issue here? for context, I'll copy and paste the code before the error:</p>
<pre><code>            IBMQ.load_account()
            provider = IBMQ.get_provider(hub = 'ibm-q')
            thequantumcomputer = provider.get_backend('ibmq_qasm_simulator')
            
            #measures all the circuits
            circuit.measure(0,0) 
            circuit.measure(1,1)
            circuit.measure(2,2)
            circuit.measure(3,3)
            circuit.measure(4,4)
            circuit.measure(5,5)
            circuit.measure(6,6)
            circuit.measure(7,7)
            circuit.measure(8,8)

            measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1)
</code></pre>
<p>Thanks for any suggestions you have :)</p>
",<python><qiskit>,08/04/2022 16:27,73239399.0,73239399.0,"<p>You would need to say</p>
<pre><code>import qiskit
</code></pre>
<p>What you have said is</p>
<pre><code>from qiskit import execute
</code></pre>
<p>That brings in the name <code>execute</code>.  It does not define a name called <code>qiskit</code>.  So, you could say:</p>
<pre><code>            measure = execute(circuit, backend=thequantumcomputer, shots=1)
</code></pre>
<p>Or you could just use <code>import qiskit</code> instead of importing all the individual names.  I tend to prefer that, because then I know exactly where the name came from.</p>
",08/04/2022 16:31,Errors ,"The user is facing an import error where the name 'qiskit' is not recognized in their code, despite importing various parts of the Qiskit library. This issue falls under the category of ""Import Error"" as it pertains to problems related to importing libraries and modules in Python.",Errors,,,,Errors ,
73338297.0,Error during Quantum Espresso configuration,"<p>During configuration QE and when writing <code>make all</code>, I got the following error:</p>
<pre><code>From https://github.com/Reference-LAPACK/lapack
     * branch            12d825396fcef1e0a1b27be9f119f9e554621e55 -&gt; FETCH_HEAD
    error: The following untracked working tree files would be overwritten by checkout:
            .appveyor.yml
            .travis.yml
    Please move or remove them before you can switch branches.
    Aborting
    make[1]: *** [liblapack] Error 1
    make[1]: Leaving directory `/rhome/Ragab/qe-7.1/install'
    make: *** [liblapack] Error 2
</code></pre>
<p>How to solve this?</p>
",<centos7><quantum-computing>,08/12/2022 18:16,73587620.0,73587620.0,"<p>Do what it says: remove .appveyor.yml and .travis.yml</p>
",09/02/2022 20:21,Errors,"The user is encountering an error while trying to configure and build a software package (Quantum Espresso) where untracked files are causing issues during a branch switch. This falls under the category of ""Build Error"" as it relates to problems encountered during the software build process.",Errors,,,,Errors,
73477635.0,Bundled QC Circuit on Qiskt (Index error),"<p>I'm trying to execute a list of ciruits on qiskit, but was faced with this strange dilemma:</p>
<pre><code>---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
&lt;ipython-input-4-653a7fab138c&gt; in &lt;module&gt;
----&gt; 1 job = execute(circuit_list, backend = device, shots = 1024)
      2 print(job.job_id())

~\anaconda3\envs\qc_env\lib\site-packages\qiskit\execute_function.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config)
    274     &quot;&quot;&quot;
    275     if isinstance(experiments, Schedule) or (
--&gt; 276         isinstance(experiments, list) and isinstance(experiments[0], Schedule)
    277     ):
    278         # do not transpile a schedule circuit

IndexError: list index out of range
</code></pre>
<p>I did not transpile any circuit before adding it to the list nor am I transpiling it during execution. Does anyone have an answer to why this is happening?</p>
<p>Edit: I'm not using a schedule either.</p>
",<python><qiskit>,8/24/2022 17:52,73477848.0,73477848.0,"<p>That error would be caused by passing an empty list to <code>execute()</code>. What are the contents of <code>circuit_list</code> in your code?</p>
<p>For the record, the <code>execute()</code> function is just a shorthand convenience function doig <code>backend.run(transpile(experiments, backend))</code>. So you're doing the correct thing not transpiling before passing circuit objects to <code>execute()</code>.</p>
",8/24/2022 18:12,Errors,"The user is encountering an ""IndexError: list index out of range"" error while trying to execute a list of circuits in Qiskit. This falls under the category of ""Programming Error"" as it relates to a problem in the code or its configuration.",Errors,,,,Errors,
73646675.0,Error while running circuit.draw(output='mpl'),"<p>I have just started learning Quantum Computing using Qiskit and was trying to draw my quantum circuit using the command <code>circuit.draw(output='mpl')</code>. However, it throws an exception:</p>
<pre><code>---------------------------------------------------------------------------
MissingOptionalLibraryError               Traceback (most recent call last)
&lt;ipython-input-43-bd220039ee1c&gt; in &lt;module&gt;
----&gt; 1 circuit.draw(output='mpl')

6 frames
/usr/local/lib/python3.7/dist-packages/qiskit/utils/lazy_tester.py in require_now(self, feature)
    222             return
    223         raise MissingOptionalLibraryError(
--&gt; 224             libname=self._name, name=feature, pip_install=self._install, msg=self._msg
    225         )
    226 

MissingOptionalLibraryError: &quot;The 'pylatexenc' library is required to use 'MatplotlibDrawer'. You can install it with 'pip install pylatexenc'.&quot;

---------------------------------------------------------------------------
NOTE: If your import is failing due to a missing package, you can
manually install dependencies using either !pip or !apt.

To view examples of installing some common dependencies, click the
&quot;Open Examples&quot; button below.
---------------------------------------------------------------------------
</code></pre>
<p>Then I tried installing the <code>pylatexenc</code> library, as mentioned in the exception using the command <code>!pip install pylatexenc</code>, imported it using <code>from pylatexenc import *</code> and then tried to use the command <code>circuit.draw(output='mpl')</code> again, but it still throws the same exception.</p>
<p>To make sure that the library was installed properly, I re-ran the command <code>!pip install pylatexenc</code>, but then it shows:</p>
<pre><code>Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/
Requirement already satisfied: pylatexenc in /usr/local/lib/python3.7/dist-packages (2.10)
</code></pre>
<p>Here is my complete code, I am running it in Google Collab's Jupyter Notebook:</p>
<pre><code>from qiskit import *
from pylatexenc import *

qr = QuantumRegister(2)
cr = ClassicalRegister(2)

circuit = QuantumCircuit(qr, cr)

%matplotlib inline

circuit.draw(output='mpl')
</code></pre>
<p>One more point to add:
<code>circuit.draw()</code> and <code>circuit.draw(initial_state = True)</code> seem to work properly. Thanks for your help.</p>
",<quantum-computing><qiskit>,09/08/2022 09:24,74125503.0,74125503.0,"<p>If you use google collab, then:</p>
<ol>
<li>Use &quot;pip install pylatexenc&quot;,</li>
<li>Restart the runtime,</li>
<li>Execute your code again.</li>
</ol>
<p>This should help.</p>
",10/19/2022 12:40,Errors ,"The user is encountering a ""MissingOptionalLibraryError"" when trying to use Matplotlib to draw a quantum circuit in Qiskit. Despite installing the 'pylatexenc' library, the issue persists, indicating a potential problem with the library installation or usage.",Errors,,,,Errors ,
73683564.0,"In Grover's Algorithm, is there a way to find 2-3 solutions with only 2 qubits?","<p>I am currently learning grover's algorithm on qiskit(<a href=""https://qiskit.org/textbook/ch-algorithms/grover.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/grover.html</a>). I notice that in the example of 2 qubits, we are looking for only one solution(|11&gt;). Is there a way to modify the circuit so that we can find 2 or 3 solutions? Thanks!</p>
",<quantum-computing><qiskit>,09/12/2022 00:52,73685250.0,73685250.0,"<p>Generally speaking it is possible to modify Grover's search algorithm for problems that have multiple solutions. However, for 2 qubits it's not practical to do that. For 2 solutions, we get a problem in which exactly half of the search space are solutions, and no number of Grover's iterations will increase the probability of getting a solution when doing the measurement - it will always be 50%. For 3 solutions, solutions represent more than half of the search space, so the probability of getting a solution when doing the measurement will actually <em>decrease</em> when doing Grover's iterations.</p>
<p>If you want to explore the behavior of Grover's search algorithm for various search space sizes and solution numbers, <a href=""https://github.com/microsoft/QuantumKatas/tree/main/tutorials/ExploringGroversAlgorithm"" rel=""nofollow noreferrer"">this tutorial</a> goes deeper into that, both with math and with visualizations of what's happening during the algorithm.</p>
",09/12/2022 06:29,Learning,The user is try to learn about Grovers algorithm on Qiskit . And he is seeking guidance on how to modify the circuit to find multiple solutions. This falls under the category of Learning as they are requesting for learning resources and tutorials in quantum computing., Learning,,,,Learning,
73819500.0,P vs. NP and Shor's Algorithm,"<p>Given that Shor's algorithm can solve factorization in polynomial time on a quantum computer (BQP), if we prove that BQP is the same as P on a classical computer, won't factorization (which is an NP problem) be a counterexample to P != NP?</p>
<p>In other words, if that statement is true, isn't P != NP not true, because we can solve an NP problem (factorization) in P time?</p>
",<np><quantum-computing>,9/22/2022 18:58,73819699.0,73819699.0,"<p>The P vs NP question asks whether every problem in NP is also in P. Therefore, if you just find a single problem in NP that is also in P, that does not itself prove that P = NP. We already know of many problems with this property - since P is a subset of NP, every problem in P is also in NP.</p>
<p>It is the case that if you can find an NP-complete problem in P then P = NP, but as of now we donât have a proof that the integer factorization problem (or more properly, the decision version of that problem) is NP-complete.</p>
",9/22/2022 19:19,Theoretical ,"The user is discussing the theoretical implications of proving that BQP (Bounded-error Quantum Polynomial time) is equivalent to P (Polynomial time) on a classical computer, and how it relates to the P vs NP problem. This falls under the category of Theoretical as it involves inquiries about theoretical concepts and principles in quantum computing",Theoretical,,,,Theoretical ,
73936106.0,"""base64-encoded little-endian doubles"" in java","<p>I am currently trying to use java to create requests for the DWave solvers.
At the moment I am trying to wrap my head around the JSON-encoding part. Especially how the parameters of the problem are to be transmitted.</p>
<p>The description just reads:
base64-encoded little-endian doubles (see <a href=""https://docs.dwavesys.com/docs/latest/c_rest_api_5.html"" rel=""nofollow noreferrer"">https://docs.dwavesys.com/docs/latest/c_rest_api_5.html</a>)
which is only little info. To try and get info I tried to decode the String in the example. (The one starting with AAAAAAAA4L8AAAAAAADwPwAAAAAAAAAAAAAAAAAA+H+amZmZmZnJP....).
Trying to decode it made only a IllegalArgumentException, or when shortening the String it sometimes returned some gibberish.</p>
<p>Does anyone have an idea how this works?</p>
<p>(I tried to look at the ocean-sdk source code however I'm not good enough at python to read it)</p>
",<java><base64><quantum-computing><dwave>,10/03/2022 13:22,73936261.0,73936261.0,"<p>The example in the documentation contains multiple base64-encoded lines:</p>
<pre><code>AAAAAAAA4L8AAAAAAADwPwAAAAAAAAAAAAAAAAAA+H+amZmZmZnJPwAAAAAAAPh/AAAAAAAA+H8A
AAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAA
AAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAA
AAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAA
AAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAA
APh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA
+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4
fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/
AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8A
AAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAA
AAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAA
AAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAA
AAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAA
APh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA
+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4
fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/
AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8A
AAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fw==
</code></pre>
<p>The first line decodes to the following:</p>
<pre class=""lang-bash prettyprint-override""><code>$ printf 'AAAAAAAA4L8AAAAAAADwPwAAAAAAAAAAAAAAAAAA+H+amZmZmZnJPwAAAAAAAPh/AAAAAAAA+H8A' | base64 -d | xxd
00000000: 0000 0000 0000 e0bf 0000 0000 0000 f03f  ...............?
00000010: 0000 0000 0000 0000 0000 0000 0000 f87f  ................
00000020: 9a99 9999 9999 c93f 0000 0000 0000 f87f  .......?........
00000030: 0000 0000 0000 f87f 00                   .........
</code></pre>
<p>A double comprises 8 octets, so the first double value is <code>0000 0000 0000 e0bf</code>. Interpreting this as an IEEE 754 floating-point double gives you: <code>2.8426e-319</code>.</p>
<p>The line breaks have to be removed to give you the full base64-encoded input. I don't think the line breaks are required when serializing, but you can simply add them <em>after</em> you have encoded as base64 (if they are missing).</p>
<p>To encode an array of doubles, you have to first <a href=""https://stackoverflow.com/q/16892580/112968"">convert to a byte array</a> which can then be fed to the Base64 encoder.</p>
<p>Parsing the full base64 string will give you 128 double values:</p>
<pre class=""lang-bash prettyprint-override""><code>$ printf 'AAAAAAAA4L8AAAAAAADwPwAAAAAAAAAAAAAAAAAA+H+amZmZmZnJPwAAAAAAAPh/AAAAAAAA+H8A
AAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAA
....
AAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fwAAAAAAAPh/AAAAAAAA+H8AAAAAAAD4fw==' | base64 -d | xxd -p -c0 | fold -w16
000000000000e0bf
000000000000f03f
0000000000000000
000000000000f87f
9a9999999999c93f
000000000000f87f
000000000000f87f
# ... value repeated ...
000000000000f87f
</code></pre>
",10/03/2022 13:36,API Usage,"The user is trying to understand how to correctly use the DWave solvers API, specifically the JSON-encoding part for transmitting problem parameters. This falls under the category of API Usage as it involves discussion on how to correctly and effectively use APIs in quantum programming. ",API Usage,,,,API Usage,
73963180.0,This worked last week(Qiskit library issue),"<p>This code used to work last week. I made sure that the pip install command is up-to-date and the right environment is set. I've been working on this code across windows and MacOS.... not the best idea but that may be part of the problem?</p>
<p>Why is it not working?</p>
<p><strong>note:</strong> I blanked out the sensitive provider info... it's not really all Xs.</p>
<pre><code>
    import numpy as np
    from collections import defaultdict
    from qiskit import Aer
    from qiskit.visualization import plot_histogram
    from qiskit.utils import QuantumInstance
    from qiskit.algorithms import Grover, AmplificationProblem
    from qiskit.circuit.library import PhaseOracle
    from qiskit.compiler import transpile
    from qiskit import assemble
    from qiskit import IBMQ
    from qiskit import execute
    from qiskit.tools import job_monitor
    import matplotlib.pyplot as plt
    IBMQ.save_account('xxxxxxx', overwrite=True)
    IBMQ.load_account()
    provider = IBMQ.get_provider(hub='xxxx', group='xxxx', project='xxxx')
    device = provider.get_backend('ibmq_kolkata')
    circuit_list = []
    verification_list = []
</code></pre>
<pre><code>---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr)
    147             try:
--&gt; 148                 from qiskit.providers import ibmq
    149 

~\anaconda3\envs\qc_env\lib\site-packages\qiskit\providers\ibmq\__init__.py in &lt;module&gt;
     85 
---&gt; 86 from qiskit.providers import BaseBackend, Backend  # type: ignore[attr-defined]
     87 

ImportError: cannot import name 'BaseBackend' from 'qiskit.providers' (C:\Users\Ahmad\AppData\Roaming\Python\Python38\site-packages\qiskit\providers\__init__.py)

The above exception was the direct cause of the following exception:

MissingOptionalLibraryError               Traceback (most recent call last)
&lt;ipython-input-2-63cbbaf81b4b&gt; in &lt;module&gt;
     14 import matplotlib.pyplot as plt
     15 #import mapomatic as mm
---&gt; 16 IBMQ.save_account('xxxxxxx', overwrite=True)
     17 IBMQ.load_account()
     18 #provider = IBMQ.get_provider(hub = 'ibm-q')

~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr)
    150                 self.ibmq = ibmq.IBMQ
    151             except ImportError as ex:
--&gt; 152                 raise MissingOptionalLibraryError(
    153                     &quot;qiskit-ibmq-provider&quot;, &quot;IBMQ provider&quot;, &quot;pip install qiskit-ibmq-provider&quot;
    154                 ) from ex

MissingOptionalLibraryError: &quot;The 'qiskit-ibmq-provider' library is required to use 'IBMQ provider'. You can install it with 'pip install qiskit-ibmq-provider'.&quot;
</code></pre>
",<python-3.x><qiskit>,10/05/2022 16:01,73988665.0,73988665.0,"<p>It was a Jupyter Notebook issue. Uninstalling and reinstalling it solved the problem.</p>
",10/07/2022 14:25,Errors,The user is encountering an ImportError and MissingOptionalLibraryError while trying to use the IBMQ provider in their quantum computing code. This falls under the category of Errors as they are seeking solutions and explanations for these exceptions in their quantum program development.,Errors,,,,Errors,
74019960.0,Get a sequence of numbers in Q#,"<p>I would like to get a <strong>list of a mathematical sequence</strong> in Q#, but I have an error that I can't solve.<br />
I use Azure Quantum to deploy the code in a Notebook.</p>
<p>Here is what I do:</p>
<p>First I connect to Azure Quantum:</p>
<pre><code>import qsharp.azure

targets = qsharp.azure.connect(
   resourceId=&quot;/subscriptions/MY_ID/resourceGroups/AzureQuantum/providers/Microsoft.Quantum/Workspaces/maths&quot;,
   location=&quot;westeurope&quot;)
</code></pre>
<p>Then I log all the workspace's target:</p>
<pre><code>import qsharp

print(&quot;This workspace's targets:&quot;)
for target in targets:
    print(&quot;-&quot;, target.id)
</code></pre>
<p>I declare <code>GetSequence</code> to use it and call it in Python.</p>
<pre><code>GetSequence: any = None
</code></pre>
<p>Here is my Q# code. I would like to be able to return in an Array or in a String <code>sequence</code> its content, to be able to read it with Python.<br />
This is where the execution gets stuck and generates an error.</p>
<pre><code>%%qsharp

open Microsoft.Quantum.Canon;
open Microsoft.Quantum.Intrinsic;
open Microsoft.Quantum.Convert;

operation GetSequence() : Int
{
    // mutable sequence = [];

    int[] sequence = new int[6];
    int count = 0;
    int start = 1;
    int end = 5;

    repeat {
        count++;

        sequence[count] = 2^(count + 1) - 1;
    } until count &gt; end;

    return sequence;
}
</code></pre>
<p>I get the content of the previously generated <code>sequence</code> and display it in the console.</p>
<pre><code>def main():
    qsharp.azure.target(&quot;ionq.simulator&quot;)

    result = qsharp.azure.execute(GetSequence)
    print(result)

main()
</code></pre>
<p>Here is my error:</p>
<pre><code>/snippet_.qs(21,12): error QS5022: No identifier with the name &quot;sequence&quot; exists.
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
/tmp/ipykernel_12196/3192535580.py in &lt;module&gt;
----&gt; 1 get_ipython().run_cell_magic('qsharp', '', '\nopen Microsoft.Quantum.Canon;\nopen Microsoft.Quantum.Intrinsic;\nopen Microsoft.Quantum.Convert;\n\noperation GetSequence() : Int\n{\n    // mutable sequence = [];\n\n    int[] sequence = new int[6];\n    int count = 0;\n    int start = 1;\n    int end = 5;\n\n    repeat {\n        count++;\n\n        sequence[count] = 2^(count + 1) - 1;\n    } until count &gt; end;\n\n    return sequence;\n}\n')

/usr/local/lib/python3.7/site-packages/IPython/core/interactiveshell.py in run_cell_magic(self, magic_name, line, cell)
   2470             with self.builtin_trap:
   2471                 args = (magic_arg_s, cell)
-&gt; 2472                 result = fn(*args, **kwargs)
   2473             return result
   2474 

/usr/local/lib/python3.7/site-packages/qsharp/ipython_magic.py in qsharp(magic_args, cell, local_ns)
     26             local_ns[callables._name] = callables
     27         else:
---&gt; 28             for qs_callable in callables:
     29                 local_ns[qs_callable._name] = qs_callable
     30 

TypeError: 'NoneType' object is not iterablefail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Unexpected code fragment.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): An expression used as a statement must be a call expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3102 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Expecting expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3033 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): The symbol is reserved for internal use only.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Unexpected code fragment.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): An expression used as a statement must be a call expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3033 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): The symbol is reserved for internal use only.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Unexpected code fragment.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): An expression used as a statement must be a call expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3033 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): The symbol is reserved for internal use only.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Unexpected code fragment.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): An expression used as a statement must be a call expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3033 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): The symbol is reserved for internal use only.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3001 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Syntax does not match any known patterns.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): Unexpected code fragment.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): An expression used as a statement must be a call expression.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS5022 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): No identifier with the name &quot;count&quot; exists.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS5022 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): No identifier with the name &quot;end&quot; exists.
fail: Microsoft.Quantum.IQSharp.Snippets[0]
      QS5022 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range): No identifier with the name &quot;sequence&quot; exists.
</code></pre>
<p>Can you please help me?<br />
Thanks for advance for your response!</p>
",<python><azure><quantum-computing><q#><azure-quantum>,10/10/2022 19:39,74023619.0,74023619.0,"<p>Your Q# code doesn't compile - the <code>fail</code> lines in the output give you compilation errors.</p>
<p>For example, your code uses C-style syntax of defining and updating variables rather than Q# style. You can learn more about working with variables in Q# in <a href=""https://learn.microsoft.com/en-us/azure/quantum/user-guide/language/statements/variabledeclarationsandreassignments"" rel=""nofollow noreferrer"">Q# documentation</a>. Also, your return type is declared as <code>Int</code> but you return <code>sequence</code> that is <code>Int[]</code>.</p>
<p>Additionally, I would recommend you to try and run <a href=""https://learn.microsoft.com/en-us/azure/quantum/machines/full-state-simulator#invoking-the-simulator-from-python"" rel=""nofollow noreferrer"">local simulation of your program</a> before you submit it to Azure - this will make debugging a lot easier, since you'll have a lot fewer potential causes of failure.</p>
",10/11/2022 06:05,Errors,The user is encountering an ImportError and TypeError while trying to use Q# for creating a list of a mathematical sequence. This falls under the category of Errors as they are seeking solutions and explanations for these exceptions in their quantum program development. ,Errors,,,,Errors,
74162691.0,@staticmethod used in qiksit hybrid neural network,"<p>I am very new to python. I was studing some code from qiskit - <a href=""https://qiskit.org/textbook/ch-machine-learning/machine-learning-qiskit-pytorch.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-machine-learning/machine-learning-qiskit-pytorch.html</a>.
I have a lot of doubt in the below code. After doing some study of neural network, I can intrepret that below code is for back progpogation.  But above the function backward, the @staticmethod is written. I did some study and came to know that these are decorators. They run before the backward function is executed. Not sure what exactly this function do. I studied the neural network code for classical computer. They donot add this. I would be really if someone can explain me its use.</p>
<pre><code>@staticmethod
    def backward(ctx, grad_output):
        &quot;&quot;&quot; Backward pass computation &quot;&quot;&quot;
        input, expectation_z = ctx.saved_tensors
        input_list = np.array(input.tolist())
        
        shift_right = input_list + np.ones(input_list.shape) * ctx.shift
        shift_left = input_list - np.ones(input_list.shape) * ctx.shift
        
        gradients = []
        for i in range(len(input_list)):
            expectation_right = ctx.quantum_circuit.run(shift_right[i])
            expectation_left  = ctx.quantum_circuit.run(shift_left[i])
            
            gradient = torch.tensor([expectation_right]) - torch.tensor([expectation_left])
            gradients.append(gradient)
        gradients = np.array([gradients]).T
        return torch.tensor([gradients]).float() * grad_output.float(), None, None
</code></pre>
",<qiskit><neural-network><python>,10/21/2022 20:10,74162692.0,74162692.0,"<p>The <code>@staticmethod</code> decorator indicates that this method is static, which means that it can be run without being attached to a particular instance of the class.</p>
<p>It simply means that you can consider it as a normal function, the only thing to remember is that you will call it with <code>Class.backward(ctx, grad_output)</code>, with <code>Class</code> being the name of the class this method is declared in.</p>
<p>For instance, consider the following code:</p>
<pre><code>class MyClass:
    def my_method(self, a):
        print(a)
    
    @staticmethod
    def my_second_method(a):
        print(a)

    def my_third_method(a):
        print(a)

my_instance = MyClass()
my_instance.my_method(2) # Prints 2
MyClass.my_second_method(3) # Prints 3
my_instance.my_third_method(4) # Error
</code></pre>
<p>When callig a method in Python, a reference to the calling object is passed as the first argument, this is the <code>self</code> in the first call. When a <code>@staticmethod</code> decorator is used, this is not the case, and the method should be called using the class name.</p>
<p>As a proof, the last line throws an error:  <code>my_third_method</code> expects a single argument, but is being passed <code>my_instance</code> as a first_argument and <code>4</code> as a second argument.</p>
<p>A better explanation of this decorator can be found <a href=""https://softwareengineering.stackexchange.com/questions/306092/what-are-class-methods-and-instance-methods-in-python"">on Software Engineering SE</a> and <a href=""https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod"">on StackOverflow</a> directly.</p>
",10/21/2022 20:38,Learning,The user is learning Python and studying code from Qiskit. They have questions about the use of decorators (specifically @staticmethod) in the context of a backpropagation function in a neural network. This falls under the category of Learning as they are requesting for learning resources and tutorials in Python and Qiskit,Learning,,,,Learning,
74207230.0,Unable to install tensorflow-quantum using pip,"<p>Using the command <code>pip install tensorflow-quantum</code> gives the following error:</p>
<pre><code>ERROR: Could not find a version that satisfies the requirement tensorflow-quantum (from versions: none)
ERROR: No matching distribution found for tensorflow-quantum
</code></pre>
<p>Not sure why the <code>versions</code> is <code>none</code>. Also, not sure how to proceed. I can build from source but need help on this error.</p>
",<pypi><tensorflow-quantum>,10/26/2022 11:46,76757032.0,76757032.0,"<p>This is because you are using a python version that does not support TensorFlow Quantum.
TensorFlow Quantum is supported on Python 3.7, 3.8, and 3.9. Change your Python version to any of these then try reinstalling.</p>
",7/24/2023 18:08,Errors,The user is encountering an error while trying to install the tensorflow-quantum package using pip. This falls under the category of Errors as they are seeking solutions and explanations for this exception in their quantum program development, Errors,,,,Errors,
74218587.0,Unable to install NLopt for Qiskit,"<p>So I am following the instructions on this site, <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.nlopts.html#module-qiskit.algorithms.optimizers.nlopts"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.nlopts.html#module-qiskit.algorithms.optimizers.nlopts</a></p>
<p>However, I am able to run this command</p>
<pre><code>./configure --enable-shared --with-python
</code></pre>
<p>As there is no file nor repository named with configure. I have qiskit and installed NLopt already.
It will be great if anyone can help me with that &gt;&lt;</p>
<p>I expect to be able to follow the instruction and run NLopt on my qiskit code</p>
<p>This is my current situation:</p>
<p>nlopt-2.7.1 % ./configure --enable-shared --with-python</p>
<p>zsh: no such file or directory: ./configure</p>
",<qiskit><nlopt>,10/27/2022 7:55,74224449.0,74224449.0,"<p>The docs above also include a link to nlopt's installation instructions. You should be able to follow things from there to install it to your Python environment that you are using with Qiskit. As you can see from the nlopt version listed there the instructions were written some time ago given the version shown there and it seems the installation overview given there may be outdated given the latest nlopt version.</p>
<p><strong>BUT</strong>... from checking it now seems to be on PyPi so doing a <code>pip install nlopt</code> should do it - it was not available via PyPi when the instructions were written.</p>
<p>FYI:: As it seems the instructions need to be reviewed I created this issue to have the instructions revised <a href=""https://github.com/Qiskit/qiskit-terra/issues/9011"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/9011</a></p>
",10/27/2022 15:18,Errors,"The user is encountering an error while trying to run a command in the quantum programming environment, Qiskit. They are seeking solutions and explanations for this error.", Errors,,,,Errors,
74239149.0,TensorCirucit c.draw() NameError,"<p>I want to plot a circuit build with TensorCircuit using the <code>draw</code> method.</p>
<p>I am working on Google Colab and have pip installed qiskit.
Yet i get <code>NameError: name 'QuantumCircuit'</code> is not defined.
I have also tried <code> from qiskit import QuantumCircuit</code> but still i get the same error.</p>
<p>Executing the code on another JuypterHub works.</p>
",<google-colaboratory><draw><qiskit>,10/28/2022 17:49,74472050.0,74472050.0,"<pre><code>pip install qiskit
pip install pylatexenc

import numpy as np
from qiskit import *
</code></pre>
<p>Once you are done with above code you have to restart your runtime so that installed library come into force into your colab environment.</p>
<p>For restarting runtime:</p>
<pre><code>Click on Runtime
Select Restart runtime 
Select Run all
</code></pre>
<p>This help you to rectify your problem.</p>
",11/17/2022 8:07,Errors,The user is encountering an error while trying to use the QuantumCircuit class from the Qiskit library in Google Colab. They are seeking solutions and explanations for this error.,Errors,,,,Errors,
74326135.0,How to Initialize the Qubits in IBM Quantum Composer,"<p><strong>Step 1 Qisqit :</strong>
Here is the code of Qiskit. I have initialized the four qubits.</p>
<pre><code>qr1 = QuantumRegister(4)
mea = ClassicalRegister(2) 
circuit = QuantumCircuit(qr1,mea) 
initial=[[1,0],[0,1]]

circuit.initialize(initial[1], 0)
circuit.initialize(initial[1], 1)

#  Uc 
circuit.x(qr1[1])
circuit.ccx(qr1[0],qr1[1],qr1[2])
circuit.x(qr1[0])
circuit.x(qr1[1])
circuit.ccx(qr1[0],qr1[1],qr1[3])
circuit.x(qr1[0])
</code></pre>
<p><strong>Its Circut:</strong></p>
<p><a href=""https://i.stack.imgur.com/apgMp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/apgMp.png"" alt=""enter image description here"" /></a></p>
<p><strong>Step 2 IBM Qunatum Composer:</strong>
Here is no such tool to initialize the qubis. Please guide me how to initilize here?</p>
<p><a href=""https://i.stack.imgur.com/xN5hY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xN5hY.png"" alt=""enter image description here"" /></a></p>
",<quantum-computing><qiskit>,11/05/2022 08:10,74326370.0,74326370.0,"<p><a href=""https://github.com/openqasm/openqasm"" rel=""nofollow noreferrer"">The OpenQASM language</a> is the standard for exchange circuits among several quantum computing tools. You can use to move your Qiskit circuit to the IBM Quantum Composer.</p>
<pre class=""lang-py prettyprint-override""><code>print(circuit.qasm())
</code></pre>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
gate multiplex1_reverse_dg q0 { ry(pi) q0; }
...
</code></pre>
<p>You can take the output and paste it in the OpenQASM 2.0 box in IBM Quantum Composer.</p>
<p><strong>Note</strong>: At the moment, there is <a href=""https://github.com/Qiskit/qiskit-terra/issues/7750"" rel=""nofollow noreferrer"">an issue in Qiskit that QASM-exports a circuit with <code>initialize</code> instructions as &quot;gates&quot;</a>. For your specific case, you need to do <code>decompose</code> first:</p>
<pre class=""lang-py prettyprint-override""><code>print(circuit.decompose().qasm())
</code></pre>
<p><strong>Detailed explanation of <code>initialize</code></strong>: Qiskit <a href=""https://qiskit.org/documentation/stubs/qiskit.extensions.Initialize.html"" rel=""nofollow noreferrer""><code>initialize</code> is a <code>reset</code> followed by a state preparation</a>. Take the following example:</p>
<pre class=""lang-py prettyprint-override""><code>circuit = QuantumCircuit(1) 
circuit.initialize([0,1], 0)
print(circuit.decompose().qasm())
</code></pre>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
gate multiplex1_reverse_dg q0 { ry(pi) q0; }   #3
gate disentangler_dg q0 { multiplex1_reverse_dg q0; }
gate state_preparation(param0,param1) q0 { disentangler_dg q0; }
qreg q[1];
reset q[0];                  #1
state_preparation(0,1) q[0]; #2
</code></pre>
<p>In <code>#1</code>, the <code>reset</code>, followed by <code>state_preparation</code> in <code>#2</code>. After some nested calling, the standard <code>ry</code> is called in <code>#3</code>. In this case, <code>circuit.initialize([0,1], 0)</code> is equivalent to <code>reset q0[0]; ry(pi) q0[0]</code>.</p>
",11/05/2022 08:52, Tooling,"The user is asking for guidance on how to use a specific feature (initializing qubits) in the IBM Quantum Composer, which is a tool used in quantum programming",Tooling,,,, Tooling,
74574626.0,QS5026 - The variable cannot be reassigned here,"<p>I'm following tutorial from the official Microsoft learning page (<a href=""https://learn.microsoft.com/en-us/azure/quantum/tutorial-qdk-explore-entanglement?pivots=ide-azure-portal"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/azure/quantum/tutorial-qdk-explore-entanglement?pivots=ide-azure-portal</a>) about quantum entanglement.</p>
<p>Basically, I copied an example posted there and I am getting error:</p>
<p>QS5026 The variable &quot;numOnesQ1&quot; cannot be reassigned here. In conditional blocks that depend on a measurement result, the target QuantinuumProcessor only supports reassigning variables that were declared within the block.</p>
<p>I understand what it says but it's just a copy from the official Microsoft tutorial. Am I missing something simple like imports, wrong settings? If not, how can I in other way set variables declared outside conditional blocks that depend on a measurement result?</p>
<p>Here is my code:</p>
<pre><code>namespace Quantum.QuantumDream {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    operation GetRandomResult() : Result {
        use q = Qubit();
        H(q);
        return M(q);
    }

    @EntryPoint()
    operation TestBellState(count : Int, initial : Result) : (Int, Int, Int, Int) {
        mutable numOnesQ1 = 0;
        mutable numOnesQ2 = 0;

        // allocate the qubits
        use (q1, q2) = (Qubit(), Qubit());   
        for test in 1..count {
            SetQubitState(initial, q1);
            SetQubitState(Zero, q2);
    
            // measure each qubit
            let resultQ1 = M(q1);            
            let resultQ2 = M(q2);           

            // Count the number of 'Ones':
            if resultQ1 == One {
                set numOnesQ1 += 1;
            }
            if resultQ2 == One {
                set numOnesQ2 += 1;
            }
        }

        // reset the qubits
        SetQubitState(Zero, q1);             
        SetQubitState(Zero, q2);


        // Return number of |0&gt; states, number of |1&gt; states
        Message(&quot;q1:Zero, One  q2:Zero, One&quot;);
        return (count - numOnesQ1, numOnesQ1, count - numOnesQ2, numOnesQ2 );

    }

    operation SetQubitState(desired : Result, target : Qubit) : Unit {
        if desired != M(target) {
            X(target);
        }
    }
}
</code></pre>
",<quantum-computing><q#>,11/25/2022 15:02,74579536.0,74579536.0,"<p>This tutorial code is only supposed to run on a local simulator (using <code>%simulate</code> magic commands in a Jupyter Notebook). From the error message, it looks like you've tried to run it on one of Quantinuum targets, which have some limitations on the kinds of things you can do in the code. To run equivalent code on Quantinuum, you'd need to define an operation for just the body of the loop (preparing a state and measuring it) and run it as a job - the cloud targets will take care of the loop themselves, running your code multiple times and returning to you a histogram of the results. For an example, you can see the QRNG sample in the samples gallery in Azure Portal.</p>
",11/26/2022 3:34,Errors,"The user is encountering a specific error message (QS5026) while following a Microsoft Quantum tutorial, and they are seeking assistance in understanding the cause of the error and how to resolve it.",Errors,,,,Errors,
75004889.0,Where is Qiskit's RepetitionCode class now?,"<p>Now that Qiskit's <code>ignis</code> module has been deprecated, where does <code>qiskit.ignis.verification.topological_codes.RepetitionCode</code> or its equivalent reside now?</p>
",<qiskit><python>,01/03/2023 16:57,75004890.0,75004890.0,"<p>According to the <a href=""https://github.com/Qiskit/qiskit-ignis#migration-guide"" rel=""nofollow noreferrer"">migration guide</a>:</p>
<blockquote>
<p><code>topological_codes</code> will continue development under <a href=""https://github.com/NCCR-SPIN/topological_codes/blob/master/README.md"" rel=""nofollow noreferrer"">NCCR-SPIN</a>, while the functionality is reintegrated into Qiskit. Some additional functionality can also be found in the offshoot project <a href=""https://github.com/yaleqc/qtcodes"" rel=""nofollow noreferrer"">qtcodes</a>.</p>
</blockquote>
<p>Looking at the NCCR-SPIN repository, we can see that <a href=""https://github.com/NCCR-SPIN/topological_codes/blob/d613ea12a72a1fa077d4ebdd13d4e4dc47494f99/topological_codes/circuits.py#L23"" rel=""nofollow noreferrer"">the <code>RepetitionCode</code> is indeed defined there</a>:</p>
<pre><code>class RepetitionCode:
    &quot;&quot;&quot;
    Implementation of a distance d repetition code, implemented over
    T syndrome measurement rounds.
    &quot;&quot;&quot;

    def __init__(self, d, T=0, xbasis=False, resets=False, delay=0, barriers=False):
        &quot;&quot;&quot;
        Creates the circuits corresponding to a logical 0 and 1 encoded
        using a repetition code.
        Args:
            d (int): Number of code qubits (and hence repetitions) used.
            T (int): Number of rounds of ancilla-assisted syndrome measurement.
            xbasis (bool): Whether to use the X basis to use for encoding (Z basis used by default).
            resets (bool): Whether to include a reset gate after mid-circuit measurements.
            delay (float): Time (in dt) to delay after mid-circuit measurements (and delay).
            barrier (bool): Boolean denoting whether to include a barrier at the end.
        Additional information:
            No measurements are added to the circuit if `T=0`. Otherwise
            `T` rounds are added, followed by measurement of the code
            qubits (corresponding to a logical measurement and final
            syndrome measurement round).
        &quot;&quot;&quot;
</code></pre>
",01/03/2023 20:07,Tooling,The user is inquiring about the new location or alternative to a specific feature (RepetitionCode) that was previously found in the deprecated qiskit.ignis module in Qiskit. This question pertains to the tooling and software usage in quantum programming.,Tooling,,,,Tooling,
75162746.0,ket.draw() not showing |00> : Qiskit,"<p><code>ket.draw()</code> must give <code>|00&gt;</code> as result but I get:</p>
<pre><code>Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
               dims=(2, 2))
</code></pre>
<p>what can I change to get the desired result?</p>
<p>This is my code:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

qc = QuantumCircuit(2)

# This calculates what the state vector of our qubits would be
# after passing through the circuit 'qc'
ket = Statevector(qc)

# The code below writes down the state vector.
# Since it's the last line in the cell, the cell will display it as output
ket.draw()
</code></pre>
",<python><quantum-computing><qiskit>,1/18/2023 17:02,75162797.0,75162797.0,"<p>You can pass the keyword argument <code>output='latex'</code> to the <code>.draw</code> method.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

qc = QuantumCircuit(2)

# This calculates what the state vector of our qubits would be
# after passing through the circuit 'qc'
ket = Statevector(qc)

# The code below writes down the state vector.
# Since it's the last line in the cell, the cell will display it as output
ket.draw(output='latex')
</code></pre>
",1/18/2023 17:07,API Usage ,"The user is asking about how to correctly use the draw() function in Qiskit to get a specific output (|00>), indicating a discussion on the correct and effective use of APIs in quantum programming. ",Errors,"The user is encountering an unexpected output while trying to use the draw() method on a Statevector object in Qiskit, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development",No,23.0,API Usage,"This is because the user is asking about how to correctly use the draw() function in Qiskit to achieve a specific output (|00>), which pertains to understanding and effectively utilizing the Qiskit API for visualizing quantum circuits and states."
75237445.0,KeyError: 0 problem. Is there a way to fix?,"<p>I'm quite new to quantum coding and i keep on getting this error in my code.</p>
<pre><code>
***hamiltonian = second_q_ops[0]***
converter = QubitConverter(mapper,two_qubit_reduction=True) 
reducer = TwoQubitReduction(num_particles) 
qubit_op = converter.convert(hamiltonian) 
qubit_op = reducer.convert(qubit_op) 
return qubit_op, num_particles, num_spin_orbitals, problem, converter 
def exact_solver(problem, converter): 
solver = NumPyMinimumEigensolverFactory() 
calc = GroundStateEigensolver(converter, solver) 
return result 
backend = BasicAer.get_backend(&quot;statevector_simulator&quot;) 
distances = np.arange(0.5, 4.0, 0.2) 
exact_energies = [] 
vqe_energies = [] 
optimizer = SLSQP(maxiter=5) 
for dist in distances: 
(qubit_op, num_particles, num_spin_orbitals, 
***problem, converter) = get_qubit_op(dist)***
result = exact_solver(problem,converter) 
exact_energies.append(result.total_energies[0].real) 
init_state = HartreeFock(num_spin_orbitals, num_particles, converter) 
var_form = UCCSD(converter, `your text`
num_particles, 
num_spin_orbitals, 
initial_state=init_state) 
vqe = VQE(var_form, optimizer, quantum_instance=backend) 
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op) 
vqe_result = problem.interpret(vqe_calc).total_energies[0].real 
vqe_energies.append(vqe_result) 
print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;, 
f&quot;VQE Result: {vqe_result:.5f}&quot;, 
f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;) 
print(&quot;All energies have been calculated&quot;) 
plt.plot(distances, exact_energies, label=&quot;Exact Energy&quot;) 
plt.plot(distances, vqe_energies, label=&quot;VQE Energy&quot;) 
plt.xlabel('Atomic distance (Angstrom)') 
plt.ylabel('Energy') 
plt.legend() 
plt.show()


</code></pre>
<pre><code>The problem is in bold.it says:
Traceback (most recent call last):
  Input In [8] in &lt;cell line: 132&gt;
    problem, converter) = get_qubit_op(dist)
  Input In [8] in get_qubit_op
    hamiltonian = second_q_ops[0]
KeyError: 0

</code></pre>
<p>Can anyone help me? Thanks
Full script in this link.
<a href=""https://docs.google.com/document/d/17mLXqMfBp4hBtm9LavPvG0MaeDi1mXEVcdcDm_kDTJ4/edit?usp=sharing"" rel=""nofollow noreferrer"">Quantum code</a></p>
<p>I tried Changing the variabes in those two parts of the error to 0 but it gave me KeyError: Ill Geometry. I also tried changing the number to different things but it didn't work.</p>
",<python-3.x><keyerror><quantum-computing>,1/25/2023 17:05,75237900.0,75237900.0,"<p>That error is due to a interface change in qiskit_nature, where aux_operators are now returned as dictionaries instead of lists.</p>
<p>You can temporarily switch back to the old behavior by adding the following two lines to the top of your script:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit_nature.settings import settings
settings.dict_aux_operators = False
</code></pre>
<p>in the long run, you should migrate your code to the updated interface.</p>
",1/25/2023 17:50,Errors,The user is receiving a KeyError when trying to access the second_q_ops[0] element of a list. This indicates that the list is empty or does not contain an element at index 0.,Errors,,,,Errors,
75240825.0,Implementing CRYSTALS-Kyber using BouncyCastle Java,"<p>Could anyone help lead me in the right direction to even just generate a keypair using Kyber? I've tried to search for BouncyCastle examples but I am unable to find any to go off.</p>
<p>I'm trying to benchmark some current algorithms such as AES/RSA, which I have working perfectly, but I am unable to make any progress on even getting started on Kyber. Any help would be greatly appreciated.</p>
<p>I've tried to search it on Google for examples, the developers have implementations C# and even Java without BouncyCastle on their website. They mention it is available on BouncyCastle but I cannot find any documentation for it even to help implement it.</p>
",<java><cryptography><bouncycastle><post-quantum-cryptography>,1/25/2023 23:05,75244075.0,75244075.0,"<p>I can provide a complete example for CHRYSTALS-KYBER using Bouncy Castle. It generates a keypair, calculates an encryption key and decryption key.</p>
<p>There are three parameter specs available:</p>
<pre><code>KyberParameterSpec.kyber512
KyberParameterSpec.kyber768
KyberParameterSpec.kyber1024
</code></pre>
<p>As the class was used in a larger Android project it may not work properly stand alone.</p>
<p>I tested the algorithm using Bouncy Castle version 1.72.</p>
<p>This is the full code:</p>
<pre><code>import org.bouncycastle.jcajce.SecretKeyWithEncapsulation;
import org.bouncycastle.jcajce.spec.KEMExtractSpec;
import org.bouncycastle.jcajce.spec.KEMGenerateSpec;
import org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider;
import org.bouncycastle.pqc.jcajce.spec.KyberParameterSpec;
import org.bouncycastle.util.Arrays;

import java.security.InvalidAlgorithmParameterException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.KeyGenerator;

public class PqcChrystalsKyberKem {

    public static void main(String[] args) {
        // Security.addProvider(new BouncyCastleProvider());
        // we do need the regular Bouncy Castle file that includes the PQC provider
        // get Bouncy Castle here: https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk18on
        // tested with BC version 1.72
        if (Security.getProvider(&quot;BCPQC&quot;) == null) {
            Security.addProvider(new BouncyCastlePQCProvider());
        }
        String print = run(false);
        System.out.println(print);
    }

    public static String run(boolean truncateKeyOutput) {
        String out = &quot;PQC Chrystals-Kyber KEM&quot;;
        out += &quot;\n&quot; + &quot;\n************************************\n&quot; +
                &quot;* # # SERIOUS SECURITY WARNING # # *\n&quot; +
                &quot;* This program is a CONCEPT STUDY  *\n&quot; +
                &quot;* for the algorithm                *\n&quot; +
                &quot;* Chrystals-Kyber [key exchange    *\n&quot; +
                &quot;* mechanism]                       *\n&quot; +
                &quot;* The program is using an          *\n&quot; +
                &quot;* parameter set that I cannot      *\n&quot; +
                &quot;* check for the correctness of the *\n&quot; +
                &quot;* output and other details         *\n&quot; +
                &quot;*                                  *\n&quot; +
                &quot;*    DO NOT USE THE PROGRAM IN     *\n&quot; +
                &quot;*    ANY PRODUCTION ENVIRONMENT    *\n&quot; +
                &quot;************************************&quot;;

        // as there are 3 parameter sets available the program runs all of them
        KyberParameterSpec[] kyberParameterSpecs = {
                KyberParameterSpec.kyber512,
                KyberParameterSpec.kyber768,
                KyberParameterSpec.kyber1024
        };

        // statistics
        int nrOfSpecs = kyberParameterSpecs.length;
        String[] parameterSpecName = new String[nrOfSpecs];
        int[] privateKeyLength = new int[nrOfSpecs];
        int[] publicKeyLength = new int[nrOfSpecs];
        int[] encryptionKeyLength = new int[nrOfSpecs];
        int[] encapsulatedKeyLength = new int[nrOfSpecs];
        boolean[] encryptionKeysEquals = new boolean[nrOfSpecs];

        out += &quot;\n\n****************************************\n&quot;;
        for (int i = 0; i &lt; nrOfSpecs; i++) {
            // generation of the Chrystals-Kyber key pair
            KyberParameterSpec kyberParameterSpec = kyberParameterSpecs[i];
            String kyberParameterSpecName = kyberParameterSpec.getName();
            parameterSpecName[i] = kyberParameterSpecName;
            out += &quot;\n&quot; + &quot;Chrystals-Kyber KEM with parameterset &quot; + kyberParameterSpecName;
            KeyPair keyPair = generateChrystalsKyberKeyPair(kyberParameterSpec);

            // get private and public key
            PrivateKey privateKey = keyPair.getPrivate();
            PublicKey publicKey = keyPair.getPublic();

            // storing the key as byte array
            byte[] privateKeyByte = privateKey.getEncoded();
            byte[] publicKeyByte = publicKey.getEncoded();
            out += &quot;\n&quot; + &quot;\ngenerated private key length: &quot; + privateKeyByte.length;
            out += &quot;\n&quot; + &quot;generated public key length:  &quot; + publicKeyByte.length;
            privateKeyLength[i] = privateKeyByte.length;
            publicKeyLength[i] = publicKeyByte.length;

            // generate the keys from a byte array
            PrivateKey privateKeyLoad = getChrystalsKyberPrivateKeyFromEncoded(privateKeyByte);
            PublicKey publicKeyLoad = getChrystalsKyberPublicKeyFromEncoded(publicKeyByte);

            // generate the encryption key and the encapsulated key
            out += &quot;\n&quot; + &quot;\nEncryption side: generate the encryption key and the encapsulated key&quot;;
            SecretKeyWithEncapsulation secretKeyWithEncapsulationSender = pqcGenerateChrystalsKyberEncryptionKey(publicKeyLoad);
            byte[] encryptionKey = secretKeyWithEncapsulationSender.getEncoded();
            out += &quot;\n&quot; + &quot;encryption key length: &quot; + encryptionKey.length
                    + &quot; key: &quot; + bytesToHex(secretKeyWithEncapsulationSender.getEncoded());
            byte[] encapsulatedKey = secretKeyWithEncapsulationSender.getEncapsulation();
            out += &quot;\n&quot; + &quot;encapsulated key length: &quot; + encapsulatedKey.length + &quot; key: &quot; + (truncateKeyOutput ?shortenString(bytesToHex(encapsulatedKey)):bytesToHex(encapsulatedKey));

            encryptionKeyLength[i] = encryptionKey.length;
            encapsulatedKeyLength[i] = encapsulatedKey.length;

            out += &quot;\n&quot; + &quot;\nDecryption side: receive the encapsulated key and generate the decryption key&quot;;
            byte[] decryptionKey = pqcGenerateChrystalsKyberDecryptionKey(privateKeyLoad, encapsulatedKey);
            out += &quot;\n&quot; + &quot;decryption key length: &quot; + decryptionKey.length + &quot; key: &quot; + bytesToHex(decryptionKey);
            boolean keysAreEqual = Arrays.areEqual(encryptionKey, decryptionKey);
            out += &quot;\n&quot; + &quot;decryption key is equal to encryption key: &quot; + keysAreEqual;
            encryptionKeysEquals[i] = keysAreEqual;
            out += &quot;\n\n****************************************\n&quot;;
        }

        out += &quot;\n&quot; + &quot;Test results&quot;;
        out += &quot;\n&quot; + &quot;parameter spec name  priKL   pubKL encKL capKL  keyE&quot;   + &quot;\n&quot;;
        for (int i = 0; i &lt; nrOfSpecs; i++) {
            String out1 = String.format(&quot;%-20s%6d%8d%6d%6d%6b%n&quot;, parameterSpecName[i], privateKeyLength[i], publicKeyLength[i], encryptionKeyLength[i], encapsulatedKeyLength[i], encryptionKeysEquals[i]);
            out += out1;
        }
        out += &quot;\n&quot; + &quot;Legend: priKL privateKey length, pubKL publicKey length, encKL encryption key length, &quot;
                + &quot;capKL encapsulated key length&quot; + &quot;\n&quot;;
        out += &quot;****************************************\n&quot;;
        return out;
    }

    private static String shortenString (String input) {
        if (input != null &amp;&amp; input.length() &gt; 32) {
            return input.substring(0, 32) + &quot; ...&quot;;
        } else {
            return input;
        }
    }

    private static KeyPair generateChrystalsKyberKeyPair(KyberParameterSpec kyberParameterSpec) {
        try {
            KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;KYBER&quot;, &quot;BCPQC&quot;);
            kpg.initialize(kyberParameterSpec, new SecureRandom());
            KeyPair kp = kpg.generateKeyPair();
            return kp;
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static SecretKeyWithEncapsulation pqcGenerateChrystalsKyberEncryptionKey(PublicKey publicKey) {
        KeyGenerator keyGen = null;
        try {
            keyGen = KeyGenerator.getInstance(&quot;KYBER&quot;, &quot;BCPQC&quot;);
            keyGen.init(new KEMGenerateSpec((PublicKey) publicKey, &quot;AES&quot;), new SecureRandom());
            SecretKeyWithEncapsulation secEnc1 = (SecretKeyWithEncapsulation) keyGen.generateKey();
            return secEnc1;
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static byte[] pqcGenerateChrystalsKyberDecryptionKey(PrivateKey privateKey, byte[] encapsulatedKey) {
        KeyGenerator keyGen = null;
        try {
            keyGen = KeyGenerator.getInstance(&quot;KYBER&quot;, &quot;BCPQC&quot;);
            keyGen.init(new KEMExtractSpec((PrivateKey) privateKey, encapsulatedKey, &quot;AES&quot;), new SecureRandom());
            SecretKeyWithEncapsulation secEnc2 = (SecretKeyWithEncapsulation) keyGen.generateKey();
            return secEnc2.getEncoded();
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey getChrystalsKyberPrivateKeyFromEncoded(byte[] encodedKey) {
        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(encodedKey);
        KeyFactory keyFactory = null;
        try {
            keyFactory = KeyFactory.getInstance(&quot;KYBER&quot;, &quot;BCPQC&quot;);
            return keyFactory.generatePrivate(pkcs8EncodedKeySpec);
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeySpecException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PublicKey getChrystalsKyberPublicKeyFromEncoded(byte[] encodedKey) {
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(encodedKey);
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(&quot;KYBER&quot;, &quot;BCPQC&quot;);
            return keyFactory.generatePublic(x509EncodedKeySpec);
        } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeySpecException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuffer result = new StringBuffer();
        for (byte b : bytes) result.append(Integer.toString((b &amp; 0xff) + 0x100, 16).substring(1));
        return result.toString();
    }
}
</code></pre>
",1/26/2023 9:07,Learning,"The user is seeking guidance and examples to learn how to generate a keypair using Kyber, indicating a request for learning resources or tutorials in the context of cryptographic algorithms.",Learning,,,,Learning,
75254631.0,How can I visualize image using qiskit in vscode?,"<p>I'm now trying to run qiskit visualization functions(e.g. .draw() methods) in vscode.</p>
<p>I use latest version of Python, 3.11.1, and followed Getting Started Qiskit in <a href=""https://qiskit.org/documentation/getting_started.html"" rel=""nofollow noreferrer"">here</a>.
Also I installed <a href=""https://marketplace.visualstudio.com/items?itemName=qiskit.qiskit-vscode"" rel=""nofollow noreferrer"">qiskit extension</a> in vscode.</p>
<p>However, when I run a qiskit code, the visualization functions don't work, even though code is compiled successfully.</p>
<p>I checked visualizing modules(mathplotlib, etc.) were installed.</p>
<p>I tried to re-install Python and vscode, including downgrading Python to 3.8. And it didn't work.</p>
<p>Additionally, qiskit-chemistry and qiskit-aqua installation warnings are pop-upped, but installation doesn't work.</p>
<p>I really don't know it is related on this problem, but I think maybe it's not since qiskit-aqua is deprecated.</p>
<p>The following screenshot is result of the qiskit test code.</p>
<p><a href=""https://i.stack.imgur.com/AUdF0.png"" rel=""nofollow noreferrer"">result of running</a></p>
<p>draw() and plot_histogram() doesn't work as you can see.</p>
<p>How can I fix this problem?</p>
",<python><python-3.x><pip><quantum-computing><qiskit>,1/27/2023 6:12,75365134.0,75365134.0,"<p>These functions are meant to be used in Python Notebooks - they won't show up in normal <code>.py</code> files. Try using VSCode's Jupyter Notebook (<code>.ipynb</code> files) feature instead.</p>
",02/06/2023 18:17,Errors,"The user is encountering issues with qiskit visualization functions not working in VSCode despite successfully compiling the code. They are seeking assistance to resolve this problem, making it an error-related question.",Errors ,,,,Errors,
76033619.0,How to group gates manually (and make circuit more readable)?,"<p>I'm trying to make my circuit look readable, but the gates auto-order in Qiskit QuantumCircuit shifts all gates to the left side.
For example an image from <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html"" rel=""nofollow noreferrer"">qiskit documentation</a>:</p>
<p><a href=""https://i.stack.imgur.com/DxVay.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DxVay.png"" alt=""image"" /></a></p>
<p>It would be much better to put ancilla X gate into the first column, Hadamard gats into the second, controlled gates into the third-fourth-fifth, and last Hadamard into the sixth column.</p>
<p>Such a result may be achieved in <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,1,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a> <a href=""https://i.stack.imgur.com/HI1yo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HI1yo.png"" alt=""quirkAnalogue"" /></a></p>
<p>Is there a way to set up an explicit column number for the quantum gate in the Qiskit QuantumCircuit (or other class)?</p>
",<qiskit>,4/17/2023 9:26,76038194.0,76038194.0,"<p>You can use <code>barrier</code>s to align the gates:</p>
<pre class=""lang-py prettyprint-override""><code>from qiskit import QuantumCircuit
circuit = QuantumCircuit(4)
circuit.x(3)
circuit.barrier()
circuit.h(range(4))
circuit.cx([0,1,2], 3)
circuit.h(range(3))
circuit.measure_all()
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/prSKT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/prSKT.png"" alt=""circuit with barriers"" /></a></p>
<p>If you want to remove them from the plot:</p>
<pre class=""lang-py prettyprint-override""><code>circuit.draw('mpl', plot_barriers=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/3IqMw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3IqMw.png"" alt=""same circuit, aligned, no barriers showed"" /></a></p>
",4/17/2023 18:29,Tooling,"The user is asking for a way to set up an explicit column number for the quantum gate in the Qiskit QuantumCircuit or other class, which falls under the category of questions related to tools and software usage in quantum programming.",Tooling,,,,Tooling,
76084475.0,Incorrect results in ground state evaluation via Qiskit Nature when using Qiskit Aer Estimator,"<p>I am using the Qiskit Aer estimator in order to evaluate the ground state of molecules via qiskit nature on local simulators using vqe, with and without noise model. My results are completely off.
To illustrate the problem, let me add here the corresponding code snippet</p>
<pre><code>from qiskit_nature.units import DistanceUnit
from qiskit_nature.second_q.drivers import PySCFDriver

driver = PySCFDriver(atom=&quot;H 0 0 0; H 0 0 0.735&quot;, basis=&quot;sto-3g&quot;)

es_problem = driver.run()

from qiskit_nature.second_q.mappers import JordanWignerMapper, QubitConverter

converter = QubitConverter(JordanWignerMapper())

from qiskit.algorithms.optimizers import SLSQP
from qiskit_nature.second_q.algorithms import VQEUCCFactory
from qiskit_nature.second_q.circuit.library import UCCSD
from qiskit_nature.second_q.algorithms import GroundStateEigensolver
</code></pre>
<p>If I take the standard Estimator from qiskit everything goes as expected</p>
<pre><code>from qiskit.primitives import Estimator

vqe_solver = VQEUCCFactory(Estimator(), UCCSD(), SLSQP())
calc = GroundStateEigensolver(converter, vqe_solver)
res = calc.solve(es_problem)
print(res)

</code></pre>
<p>And here is the result I get</p>
<pre><code>=== GROUND STATE ENERGY ===
 
* Electronic ground state energy (Hartree): -1.857275030145
  - computed part:      -1.857275030145
~ Nuclear repulsion energy (Hartree): 0.719968994449
&gt; Total ground state energy (Hartree): -1.137306035696
 
=== MEASURED OBSERVABLES ===
 
  0:  # Particles: 2.000 S: 0.000 S^2: 0.000 M: 0.000
 
=== DIPOLE MOMENTS ===
 
~ Nuclear dipole moment (a.u.): [0.0  0.0  1.3889487]
 
  0: 
  * Electronic dipole moment (a.u.): [0.0  0.0  1.38894893]
    - computed part:      [0.0  0.0  1.38894893]
  &gt; Dipole moment (a.u.): [0.0  0.0  -0.00000023]  Total: 0.00000023
                 (debye): [0.0  0.0  -0.00000058]  Total: 0.00000058
 
</code></pre>
<p>If I use the Aer estimator for a noiseless simulation</p>
<pre><code>from qiskit_aer.primitives import Estimator as AerEstimator
seed=170

noiseless_estimator = AerEstimator(
    run_options={&quot;seed&quot;: seed, &quot;shots&quot;: 1024},
    transpile_options={&quot;seed_transpiler&quot;: seed},
)

vqe_solver2=VQEUCCFactory(noiseless_estimator, UCCSD(), SLSQP())
calc2 = GroundStateEigensolver(converter, vqe_solver2)
res2 =calc2.solve(es_problem)
print(res2)
</code></pre>
<p>These are the output numbers I get. They are really different.</p>
<pre><code>=== GROUND STATE ENERGY ===
 
* Electronic ground state energy (Hartree): -0.761369413072
  - computed part:      -0.761369413072
~ Nuclear repulsion energy (Hartree): 0.719968994449
&gt; Total ground state energy (Hartree): -0.041400418623
 
=== MEASURED OBSERVABLES ===
 
  0:  # Particles: 2.006 S: 0.446 S^2: 0.645 M: 0.009
 
=== DIPOLE MOMENTS ===
 
~ Nuclear dipole moment (a.u.): [0.0  0.0  1.3889487]
 
  0: 
  * Electronic dipole moment (a.u.): [0.0  0.0  1.38395701]
    - computed part:      [0.0  0.0  1.38395701]
  &gt; Dipole moment (a.u.): [0.0  0.0  0.00499169]  Total: 0.00499169
                 (debye): [0.0  0.0  0.0126876]  Total: 0.0126876
 
</code></pre>
<p>I tried to use qiskit aer Estimator primitives in different environments and setups and on the IBM Quantum Lab as well to be reasonably sure that the problem does not depend from the installation.  The output I get is the same.</p>
<p>I expect that without noise qiskit aer Estimator provides the same results as the default Estimator, and if there are differences in the Total ground state energy value, they are below 0.01 Hartree.</p>
<p>How can I fix this? Am I doing anything wrong in Aer Estimator usage?
Thank you in advance.</p>
",<chemistry><qiskit>,4/23/2023 11:06,76085329.0,76085329.0,"<p>The computations done above, using the two different Estimators, are not the same and this, and the optimizer choice is causing the difference.</p>
<p>The Estimator from qiskit.primitives, when created by default, as you do i.e Estimator(), computes an ideal outcome (statevector and matrix computation).</p>
<p>The Aer Estimator, you have even set it up to do sampling (though this is its default) and this will have sampling noise in the outcome. With 1024 shots the outcome is sampled 1024 timesand will be different from the ideal (ideal you can think of as an infinite number of shots). To make this the equivalent of qiskit.primitives, as per the <a href=""https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.primitives.Estimator.html"" rel=""nofollow noreferrer"">Aer Estimator api ref.</a> set <code>shots=None</code> and <code>approximation=True</code>. You should then see the same result.</p>
<blockquote>
<p>shots (None or int) â The number of shots. If None and approximation is True, it calculates the exact expectation values. Otherwise, it calculates expectation values with sampling.</p>
</blockquote>
<p>Now you can set the qiskit.primitives Estimator to sample by setting shots (<code>options={shots=1024}</code> note Aer uses run_options so again a bit different). This will cause sampling noise in its outcome. SLSQP is a classical gradient based optimizer and sampling noise can adversely affect its ability to compute a gradient, which is done, by default, with finite diff, which uses very small delta diffs around the current point to determine the slope and such noise can easily affect this. In the presence of noise SPSA as an optimizer would be a reasonable choice - it was designed to work under noise. Yes you do not have actual noise as you I believe thinking of it in Aer, i.e. a noise model say from a real device, but sampling from the ideal outcome with shots already introduces a form of noise - sampling/shot noise - which as you can see causes difficulties already.</p>
<hr />
<p>I updated this answer as per my comment below, on Aer Estimator, to show the outcome when so configured</p>
<pre><code>from qiskit_nature.units import DistanceUnit
from qiskit_nature.second_q.drivers import PySCFDriver

driver = PySCFDriver(atom=&quot;H 0 0 0; H 0 0 0.735&quot;, basis=&quot;sto-3g&quot;)

es_problem = driver.run()

from qiskit_nature.second_q.mappers import JordanWignerMapper, QubitConverter

converter = QubitConverter(JordanWignerMapper())

from qiskit.algorithms.optimizers import SLSQP
from qiskit_nature.second_q.algorithms import VQEUCCFactory
from qiskit_nature.second_q.circuit.library import UCCSD
from qiskit_nature.second_q.algorithms import GroundStateEigensolver

from qiskit_aer.primitives import Estimator as AerEstimator
seed=170

noiseless_estimator = AerEstimator(
    run_options={&quot;shots&quot;: None},
    approximation=True,
)

vqe_solver2=VQEUCCFactory(noiseless_estimator, UCCSD(), SLSQP())
calc2 = GroundStateEigensolver(converter, vqe_solver2)
res2 =calc2.solve(es_problem)
print(res2)
</code></pre>
<p>produces</p>
<pre><code>=== GROUND STATE ENERGY ===
 
* Electronic ground state energy (Hartree): -1.857275030145
  - computed part:      -1.857275030145
~ Nuclear repulsion energy (Hartree): 0.719968994449
&gt; Total ground state energy (Hartree): -1.137306035696
 
=== MEASURED OBSERVABLES ===
 
  0:  # Particles: 2.000 S: 0.000 S^2: 0.000 M: 0.000
 
=== DIPOLE MOMENTS ===
 
~ Nuclear dipole moment (a.u.): [0.0  0.0  1.3889487]
 
  0: 
  * Electronic dipole moment (a.u.): [0.0  0.0  1.388948372236]
    - computed part:      [0.0  0.0  1.388948372236]
  &gt; Dipole moment (a.u.): [0.0  0.0  0.000000327764]  Total: 0.000000327764
                 (debye): [0.0  0.0  0.000000833093]  Total: 0.000000833093

</code></pre>
",4/23/2023 14:10,Errors," The user is encountering a significant discrepancy in the results when using the Aer Estimator for noiseless simulation in Qiskit compared to the default Estimator. They are seeking assistance to understand and rectify this issue, making it an error-related question.",Errors,,,,Errors,
76144355.0,Combining quantum circuits in Qiskit,"<p>In Qiskit the instruction to add two quantum circuits</p>
<p>qc1 + qc2</p>
<p>produces the following error</p>
<p>&quot;unsupported operand type(s) for +: 'QuantumCircuit' and 'QuantumCircuit'&quot;</p>
<p>I'm guessing my library must be missing something but as I'm new to Qiskit and Python I'm not sure what?</p>
<p>I was expecting qc2 to be appended to qc1.</p>
",<typeerror><qiskit>,05/01/2023 01:45,76146849.0,76146849.0,"<p>The <code>+</code> operator is no longer supported by QuantumCircuit. From <a href=""https://qiskit.org/documentation/release_notes.html#release-notes-0-23-0-upgrade-notes"" rel=""nofollow noreferrer"">Qiskit Terra 0.23. release notes</a> (Upgrade section).</p>
<blockquote>
<p>The QuantumCircuit methods combine and extend have been removed
following their deprecation in Qiskit Terra 0.17.0. This was done
because these functions were simply less powerful versions of
QuantumCircuit.compose(), which should be used instead.</p>
<p>The removal of extend also means that the + and += operators are no
longer defined for QuantumCircuit. Instead, you can use the &amp; and &amp;=
operators respectively, which use QuantumCircuit.compose().</p>
</blockquote>
",05/01/2023 12:16,Errors,"The user is encountering an error when attempting to add two QuantumCircuit objects in Qiskit using the + operator. They are seeking assistance to resolve this error, making it an error-related question.",Errors,,,,Errors,
76229341.0,issues encountered in using scikit-quant optimizers in Qiskit VQE workflows (Aer backend),"<p>as I am testing all optimizers advised in <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html"" rel=""nofollow noreferrer"">qiskit.algorithms.optimizers</a> reference page to evaluate their performance in a VQE qiskit nature workflow on the Aer backend with and without noise model, I decided to call scikit-quant optimizers BOBYQA, IMFIL and SNOBFIT using the same syntax I used for Local and Global Optimizers described in the same reference page.</p>
<pre><code>vqe_solver = VQEUCCFactory(noisy_est, UCCSD(), BOBYQA())
from qiskit_nature.second_q.algorithms import GroundStateEigensolver

calc = GroundStateEigensolver(converter, vqe_solver)
res = calc.solve(problem)
</code></pre>
<p>With the other optimizers I encountered no issues at all and runs went fine.  I expected to use the same syntax for scikit-quant optimizers, but that does not work.<br />
I got issues with the three of the scikit-quant set, with different error messages.</p>
<p>You can read the backtraces below, purged by irrelevant file paths.</p>
<p>BOBIQA:</p>
<pre><code>Traceback (most recent call last):
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py&quot;, line 253, in evaluate_energy
    job = self.estimator.run(batch_size * [ansatz], batch_size * [operator], parameters)
  File &quot;...lib/python3.10/site-packages/qiskit/primitives/base/base_estimator.py&quot;, line 222, in run
    parameter_values = self._validate_parameter_values(
  File &quot;...lib/python3.10/site-packages/qiskit/primitives/base/base_primitive.py&quot;, line 108, in _validate_parameter_values
    raise TypeError(&quot;Invalid parameter values, expected Sequence[Sequence[float]].&quot;)
TypeError: Invalid parameter values, expected Sequence[Sequence[float]].

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File &quot;.../test.py&quot;, line 159, in &lt;module&gt;
    res = calc.solve(problem)
  File ...lib/python3.10/site-packages/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 96, in solve
    raw_mes_result = self.solver.compute_minimum_eigenvalue(  # type: ignore
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py&quot;, line 191, in compute_minimum_eigenvalue
    optimizer_result = self.optimizer.minimize(
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/optimizers/bobyqa.py&quot;, line 69, in minimize
    res, history = skq.minimize(
  File &quot;...lib/python3.10/site-packages/skquant/opt/__init__.py&quot;, line 56, in minimize
    return optimizer.minimize(func, x0, bounds, budget, options, **optkwds)
  File &quot;...lib/python3.10/site-packages/skquant/opt/_pybobyqa.py&quot;, line 33, in minimize
    result = pybobyqa.solve(
  File &quot;...lib/python3.10/site-packages/pybobyqa/solver.py&quot;, line 809, in solve
    solve_main(objfun, x0, args, xl, xu, npt, rhobeg, rhoend, maxfun, nruns, nf, nx, nsamples, params,
  File &quot;...lib/python3.10/site-packages/pybobyqa/solver.py&quot;, line 157, in solve_main
    exit_info = control.initialise_coordinate_directions(number_of_samples, num_directions, params)
  File &quot;...lib/python3.10/site-packages/pybobyqa/controller.py&quot;, line 181, in initialise_coordinate_directions
    f_list, num_samples_run, exit_info = self.evaluate_objective(x, number_of_samples, params)
  File &quot;...lib/python3.10/site-packages/pybobyqa/controller.py&quot;, line 349, in evaluate_objective
    f_list[i] = eval_objective(self.objfun, remove_scaling(x, self.scaling_changes), self.args, eval_num=self.nf, pt_num=self.nx,
  File &quot;...lib/python3.10/site-packages/pybobyqa/util.py&quot;, line 51, in eval_objective
    f = objfun(x, *args)
  File &quot;...lib/python3.10/site-packages/SQCommon/_objective.py&quot;, line 24, in __call__
    result = self.objective(par)
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py&quot;, line 256, in evaluate_energy
    raise AlgorithmError(&quot;The primitive job to evaluate the energy failed!&quot;) from exc
qiskit.algorithms.exceptions.AlgorithmError: 'The primitive job to evaluate the energy failed!
</code></pre>
<p>IMFIL:</p>
<pre><code>Traceback (most recent call last):
  File &quot;.../test.py&quot;, line 159, in &lt;module&gt;
    res = calc.solve(problem)
  File &quot;...lib/python3.10/site-packages/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 96, in solve
    raw_mes_result = self.solver.compute_minimum_eigenvalue(  # type: ignore
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py&quot;, line 191, in compute_minimum_eigenvalue
    optimizer_result = self.optimizer.minimize(
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/optimizers/imfil.py&quot;, line 72, in minimize
    res, history = skq.minimize(
  File &quot;...ibm_sdk/lib/python3.10/site-packages/skquant/opt/__init__.py&quot;, line 56, in minimize
    return optimizer.minimize(func, x0, bounds, budget, options, **optkwds)
  File &quot;...lib/python3.10/site-packages/SQImFil/_imfil.py&quot;, line 160, in minimize
    dbounds = bounds[:,(1,)] - bounds[:,(0,)]
TypeError: unsupported operand type(s) for -: 'NoneType' and 'NoneType'

</code></pre>
<p>SNOBFIT:</p>
<pre><code>Traceback (most recent call last):
  File &quot;.../test.py&quot;, line 159, in &lt;module&gt;
    res = calc.solve(problem)
  File &quot;...lib/python3.10/site-packages/qiskit_nature/second_q/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 96, in solve
    raw_mes_result = self.solver.compute_minimum_eigenvalue(  # type: ignore
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/minimum_eigensolvers/vqe.py&quot;, line 191, in compute_minimum_eigenvalue
    optimizer_result = self.optimizer.minimize(
  File &quot;...lib/python3.10/site-packages/qiskit/algorithms/optimizers/snobfit.py&quot;, line 99, in minimize
    raise ValueError(&quot;Optimizer SNOBFIT requires bounds for all parameters.&quot;)
ValueError: Optimizer SNOBFIT requires bounds for all parameters.

</code></pre>
<p>Can you suggest me specific workarounds for each of them, keeping into account that, for instance, SNOBFIT bounds may take into account that an UCCSD ansatz has been used? Thank you in advance.</p>
",<optimization><chemistry><qiskit>,05/11/2023 15:34,76229856.0,76229856.0,"<p>Let me start out by mentioning there is an issue on Qiskit to address bounds that would also address the problem with those optimizers with UCC <a href=""https://github.com/Qiskit/qiskit-terra/issues/9718"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/9718</a>. You can read more in that about what is happening etc. In the meanwhile I can give a workaround as described below.</p>
<p>First I will point out your code above shows the use of Factories in Nature, and the workaround needs more direct access to the ansatz. Factories, I will note, were deprecated in the latest release Of Qiskit Nature with a migration guide to using UCC directly <a href=""https://qiskit.org/ecosystem/nature/migration/0.6_b_mes_factory.html"" rel=""nofollow noreferrer"">https://qiskit.org/ecosystem/nature/migration/0.6_b_mes_factory.html</a></p>
<p>So the workaround comes down to this. You can set a different bounds on the anstaz, i.e. override its default, by doing this choosing some non-None bounds in my example +/-9999</p>
<pre><code>ansatz.parameter_bounds = [(-9999, 9999)]  * ansatz.num_parameters
</code></pre>
<p>which will allow these optimizers to be then used with UCCSD - where <code>anstaz</code> is the above is whatever the UCCSD instance variable is you use.</p>
<p>BUT.... in using UCCSD directly you do need to set the VQE initial point to ensure it starts in the HF state. You can follow the above migration guide and use the HFInitialPoint object or set all zeros NOT a random number. Otherwise the UCC will not start properly in the HartreeFock State and the answer is likely not to be correct. Setting all zeros for the VQE initial point, given the same ansatz, can be done as follows and ensures its size matches the ansatz</p>
<pre><code>initial_point = np.asarray([0] * ansatz.num_parameters)
</code></pre>
<p>This following howto may also be of help as it covers using UCC with VQE <a href=""https://qiskit.org/ecosystem/nature/howtos/vqe_ucc.html"" rel=""nofollow noreferrer"">https://qiskit.org/ecosystem/nature/howtos/vqe_ucc.html</a> and also notes the above.</p>
",05/11/2023 16:40,Errors,"The user is encountering errors while trying to use different optimizers (BOBYQA, IMFIL, and SNOBFIT) with Qiskit's VQE algorithm. They are seeking assistance to resolve these optimizer-specific issues, making it an error-related question.", Errors,,,,Errors,
76326665.0,"Where has the ""units"" sub-module in qiskit_nature gone?","<p>I am trying to follow this <a href=""https://qiskit.org/documentation/stable/0.25/tutorials/chemistry/01_electronic_structure.html"" rel=""nofollow noreferrer"">qiskit &quot;Electronic Structure&quot; tutorial</a>, but at the very first step, setting up the PySCF driver with the following</p>
<pre><code>from qiskit_nature.units import DistanceUnit
from qiskit_nature.second_q.drivers import PySCFDriver

driver = PySCFDriver(
    atom=&quot;H 0 0 0; H 0 0 0.735&quot;,
    basis=&quot;sto3g&quot;,
    charge=0,
    spin=0,
    unit=DistanceUnit.ANGSTROM,
)
</code></pre>
<p>produces an error. The error says there is no module &quot;units&quot; in qiskit_nature.</p>
<p>I have installed qiskit_nature with pip (pip3, python 3.6) and when I listed the submodules of qiskit_nature I get</p>
<pre><code>algorithms
circuit
constants
converters
deprecation
drivers
exceptions
mappers
operators
problems
properties
results
runtime
settings
transformers
version
</code></pre>
<p>I checked most and there appears not to be a &quot;units&quot; module anywhere. While the call to the submodule &quot;units&quot; in the above may be trivial and/or circumvented, where has the submodule gone? Is it missing because when they ported the &quot;qiskit.chemistry&quot; to &quot;nature&quot; they re-organised things? If so, why do the tutorials on the &quot;nature&quot; module not reflect this?</p>
",<units-of-measurement><qiskit>,5/24/2023 19:01,76329245.0,76329245.0,"<p>I am assuming that you are trying to run the latest tutorial but you do not have the latest version of Qiskit Nature installed. This is based on three observatons:</p>
<ol>
<li>The <code>units</code> module is missing which only got added in Qiskit Nature v0.5.0</li>
<li>The <code>second_q</code> module is missing, too, which also got added in that version.</li>
<li>Furthermore, you say that you are using Python 3.6, support which has been removed in version 0.4.0.</li>
</ol>
<p>Thus, I strongly assume you installed Qiskit Nature v0.3.2 which is the last release that pip should resolve to under that Python version.</p>
<p>Now, how do you go about solving this problem: I strongly suggest that you first switch to a newer Python version. 3.6 has reached its end of life on Dec 23rd, 2021 <a href=""https://devguide.python.org/versions/"" rel=""nofollow noreferrer"">1</a>.
I suggest you upgrade to Python 3.9 which will be supported into 2025 and has already been &quot;battle-tested&quot; on all platforms.</p>
<p>Once you have upgrade your Python version, you will need to re-install Qiskit Nature:</p>
<pre><code>pip3 install --upgrade qiskit-nature
</code></pre>
",5/25/2023 5:45,Errors," The user is encountering an error when trying to import the units module from qiskit_nature in Qiskit. They have checked the submodules of qiskit_nature and found that there is no units module, leading to the error",Errors,,,,Errors,
76369957.0,Resolving deprecation warnings of Qiskit's `QuantumInstance`,"<p>This code finds the solution to the Max-Cut problem for a given graph using both classical and quantum algorithms. The Max-Cut problem is a well-known problem in computer science and combinatorial optimization, which seeks to divide the vertices of a graph into two disjoint sets such that the number of edges between the sets is maximized.</p>
<p>Here's a detailed breakdown of what the code does:</p>
<p>It first defines a graph with nodes connected by certain edges. In this case, the graph has three nodes (0, 1, 2) with edges between all pairs of nodes.</p>
<p>It then creates an instance of the Max-Cut problem for this graph.</p>
<p>This Max-Cut problem is converted into a Quadratic Program (QP). Quadratic Programs are a type of mathematical optimization problem that can be solved by certain algorithms. They are useful in the context of quantum computing because many optimization problems can be converted into QPs, which can then be solved on a quantum computer.</p>
<p>The code then solves the Quadratic Program using a classical algorithm called the Minimum Eigenvalue Solver (NumPyMinimumEigensolver). This is an exact method for finding the minimum eigenvalue of a matrix, which corresponds to the optimal solution of the QP. The solution is then printed to the console.</p>
<p>Next, the code solves the same Quadratic Program using the Quantum Approximate Optimization Algorithm (QAOA), a quantum algorithm designed for solving combinatorial optimization problems. This is done using a quantum simulator (in this case, the statevector_simulator from Qiskit's Aer module) and the COBYLA optimizer.</p>
<p>Finally, the quantum solution to the problem is printed to the console.</p>
<p>In summary, this code is demonstrating how to solve the Max-Cut problem for a simple graph using both classical and quantum methods, and how to compare their results.</p>
<p>however it seems i get the deprecated warning. i know there is links to find the migration but i cant figure out how to get rid of it</p>
<pre><code>import networkx as nx
from qiskit import Aer
from qiskit.algorithms import QAOA, NumPyMinimumEigensolver
from qiskit.algorithms.optimizers import COBYLA
from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_optimization.applications import Maxcut
from qiskit.utils import QuantumInstance

# Define the edges of the graph (edges are represented by tuples of node indices)
edges = [(0, 1), (0, 2), (1, 2)]

# Create a graph based on these edges
G = nx.Graph(edges)

# Create the Maxcut object
maxcut = Maxcut(G)

# Create a QuadraticProgram based on maxcut
qp = maxcut.to_quadratic_program()

# Solve the problem exactly using classical eigensolver
exact_mes = NumPyMinimumEigensolver()
exact = MinimumEigenOptimizer(exact_mes)
result = exact.solve(qp)
print(&quot;Exact solution:\n&quot;, result)

# Solve the problem using QAOA
quantum_instance = QuantumInstance(Aer.get_backend('statevector_simulator'))
qaoa_mes = QAOA(optimizer=COBYLA(), quantum_instance=quantum_instance)
qaoa = MinimumEigenOptimizer(qaoa_mes)
result = qaoa.solve(qp)
print(&quot;QAOA solution:\n&quot;, result)
</code></pre>
<pre><code>C:\Users\Local\Temp\ipykernel_7204\1113091964.py:23: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.numpy_minimum_eigen_solver.NumPyMinimumEigensolver`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver``. See https://qisk.it/algo_migration for a migration guide.
  exact_mes = NumPyMinimumEigensolver()
C:\Users\AppData\Local\Temp\ipykernel_7204\1113091964.py:29: DeprecationWarning: The class ``qiskit.utils.quantum_instance.QuantumInstance`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration.
  quantum_instance = QuantumInstance(Aer.get_backend('statevector_simulator'))
C:\Users\AppData\Local\Temp\ipykernel_7204\1113091964.py:30: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.qaoa.QAOA`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.QAOA``. See https://qisk.it/algo_migration for a migration guide.
  qaoa_mes = QAOA(optimizer=COBYLA(), quantum_instance=quantum_instance)

Exact solution:
 fval=2.0, x_0=1.0, x_1=0.0, x_2=0.0, status=SUCCESS
QAOA solution:
 fval=2.0, x_0=1.0, x_1=0.0, x_2=0.0, status=SUCCESS
</code></pre>
",<python><jupyter-lab><quantum-computing><qiskit>,5/31/2023 3:22,76370993.0,76370993.0,"<p>You have to exchange the <code>QuantumInstance</code> with the new primitives and the respective algorithms. Since you have an algorithm that is based on sampling circuits, you can use the <code>Sampler</code> for this job. How you have to change the algorithms is explicitly stated in the deprecation warning, for example:</p>
<pre><code>DeprecationWarning: 
The class qiskit.algorithms.minimum_eigen_solvers.numpy_minimum_eigen_solver.NumPyMinimumEigensolver is deprecated as of qiskit-terra 0.24.0. 
It will be removed no earlier than 3 months after the release date.
Instead, use the class qiskit.algorithms.minimum_eigensolvers.NumPyMinimumEigensolver. 
</code></pre>
<p>That means you have to change the import</p>
<pre><code>from qiskit.algorithms import NumPyMinimumEigensolver
</code></pre>
<p>to</p>
<pre><code>from qiskit.algorithms.minimum_eigensolver import NumPyMinimumEigensolver
</code></pre>
<p>Here's your snippet, with the updates according to the warnings you posted above:</p>
<pre class=""lang-py prettyprint-override""><code>import networkx as nx

# update to new import location
from qiskit.algorithms.minimum_eigensolvers import QAOA, NumPyMinimumEigensolver

from qiskit.algorithms.optimizers import COBYLA
from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_optimization.applications import Maxcut

# import the sampler
from qiskit.primitives import Sampler

# Define the edges of the graph (edges are represented by tuples of node indices)
edges = [(0, 1), (0, 2), (1, 2)]

# Create a graph based on these edges
G = nx.Graph(edges)

# Create the Maxcut object
maxcut = Maxcut(G)

# Create a QuadraticProgram based on maxcut
qp = maxcut.to_quadratic_program()

# Solve the problem exactly using classical eigensolver
exact_mes = NumPyMinimumEigensolver()
exact = MinimumEigenOptimizer(exact_mes)
result = exact.solve(qp)
print(&quot;Exact solution:\n&quot;, result)

# Solve the problem using QAOA
sampler = Sampler()  # use the sampler, the default is based on statevector simulation
qaoa_mes = QAOA(optimizer=COBYLA(), sampler=sampler)
qaoa = MinimumEigenOptimizer(qaoa_mes)
result = qaoa.solve(qp)
print(&quot;QAOA solution:\n&quot;, result)
</code></pre>
",5/31/2023 7:14,Errors,The user is encountering an issue with their code where they are receiving deprecation warnings. They are seeking assistance to resolve these warnings and update their code to use the new classes in Qiskit.,Errors,,,,Errors,
76371779.0,Calculating CHSH inequality violation in a two-qubit system with projective measurements,"<p>Suppose a two-qubit system is in the state |Î¦â© = (|00â© + |11â© )/ â2. Consider projective measurements with outcome Â±1. Calculate the maximal violation of the CHSH inequality and find the measurement setting that can result the maximal violation.</p>
<p>I am new to quantum computing.I don't know how to solve this problem.</p>
",<quantum-computing>,5/31/2023 8:58,76427971.0,76427971.0,"<p>I's a tough one and one I struggled with too. Calculating the maximal violation of the CHSH inequality for the given two-qubit state |Î¦â© = (|00â© + |11â© )/ â2, we need to consider four different measurement settings and compute the corresponding expectation values.</p>
<p>The CHSH inequality is expressed as follows:</p>
<p>CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B') â¤ 2,</p>
<p>where A, A' are the measurement settings for the first qubit there, and B, B' are the measurement settings for the second qubit, and E(A, B) is the expectation value for the measurement settings A and B. If that makes sense?</p>
<p>Now considering the four measurement settings:</p>
<p>Setting 1:
A = Ïz (measurement in the computational basis for the first qubit)
B = Ïz (measurement in the computational basis for the second qubit)</p>
<p>In this case, the expectation value E(A, B) can be calculated as follows:</p>
<p>E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïz)|Î¦â©.</p>
<p>Expanding the tensor product and substituting |Î¦â© = (|00â© + |11â© )/ â2:</p>
<p>E(A, B) = â¨Î¦|(Ïz â Ïz)|Î¦â©
= (1/â2)(â¨00|(Ïz â Ïz)|00â© + â¨00|(Ïz â Ïz)|11â© + â¨11|(Ïz â Ïz)|00â© + â¨11|(Ïz â Ïz)|11â©)
= (1/â2)(1 + 1 + 1 - 1)
= 2/â2
= â2.</p>
<p>Setting 2:
A = Ïx (measurement in the Hadamard basis for the first qubit)
B = Ïz (measurement in the computational basis for the second qubit)</p>
<p>In this case, the expectation value E(A, B) can be calculated as follows:</p>
<p>E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïz)|Î¦â©.</p>
<p>Using the same steps as above, we find:</p>
<p>E(A, B) = -1/â2.</p>
<p>Setting 3:
A = Ïz (measurement in the computational basis for the first qubit)
B = Ïx (measurement in the Hadamard basis for the second qubit)</p>
<p>In this case, the expectation value E(A, B) can be calculated as follows:</p>
<p>E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïx)|Î¦â©.</p>
<p>Using the same steps as above, we find:</p>
<p>E(A, B) = -1/â2.</p>
<p>Setting 4:
A = Ïx (measurement in the Hadamard basis for the first qubit)
B = Ïx (measurement in the Hadamard basis for the second qubit)</p>
<p>In this case, the expectation value E(A, B) can be calculated as follows:</p>
<p>E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïx)|Î¦â©.</p>
<p>Using the same steps as above, we find:</p>
<p>E(A, B) = -â2.</p>
<p>Now, let's calculate the maximal violation of the CHSH inequality:</p>
<p>CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B')
= â2 + (-1/</p>
<p>Hope that helps you.</p>
",06/08/2023 00:58,Learning ,The user is asking for help in understanding and solving a problem related to the maximal violation of the CHSH inequality in a two-qubit system. This indicates that they are seeking to learn and understand this concept in quantum computing. ,Theoretical,"The user is asking about the maximal violation of the CHSH inequality and the measurement setting that can result in this maximal violation for a specific two-qubit system state, which falls under the category of inquiries about theoretical concepts, algorithms, and principles in quantum computing",No,24.0, Learning,"This is because the user is new to quantum computing and seeking help in understanding and solving a problem related to the maximal violation of the CHSH inequality, indicating a desire to learn and grasp this concept."
76392444.0,Import error when running Shor's algorithm on Qiskit,"<pre><code>from qiskit import Aer
from qiskit.utils import QuantumInstance
from qiskit.algorithms import Shor

N = 15
backend = Aer.get_backend('aer_simulator')
quantum_instance = QuantumInstance(backend, shots=1024)
shor = Shor(quantum_instance=quantum_instance)
result = shor.factor(N)
print(f&quot;The list of factors of {N} as computed by the Shor's algorithm is {result.factors[0]}.&quot;)
</code></pre>
<p>When I am running code I am experiencing this error:</p>
<pre><code>ImportError: cannot import name 'Shor' from 'qiskit.algorithms' (C:\Users\Prasann\anaconda3\lib\site-packages\qiskit\algorithms\__init__.py)
</code></pre>
<p>It should have imported it.</p>
",<qiskit>,06/02/2023 17:49,76392756.0,76392756.0,"<p><code>Shor</code>s algorithm was deprecated in Qiskit Terra 0.22.0 and removed in 0.24.0. <a href=""https://qiskit.org/documentation/release_notes.html#algorithms-upgrade-notes"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/release_notes.html#algorithms-upgrade-notes</a> So if you have the latest version of qiskit-terra the Shor algorithm, that was there, no longer exists and will thus fail to import it.</p>
<blockquote>
<p>The deprecated modules factorizers and linear_solvers, containing HHL and Shor have been removed from qiskit.algorithms. These functionalities were originally deprecated as part of the 0.22.0 release (released on October 13, 2022). You can access the code through the Qiskit Textbook instead: Linear Solvers (HHL) , Factorizers (Shor)</p>
</blockquote>
<p>It links Shor to the code in the textbook here <a href=""https://learn.qiskit.org/course/ch-algorithms/shors-algorithm"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/ch-algorithms/shors-algorithm</a></p>
",06/02/2023 18:44,Errors,"The user is encountering an error where they are unable to import the 'Shor' class from the 'qiskit.algorithms' module, and they need assistance in resolving this issue.", Errors,,,,Errors,
76459472.0,Quantum: Define superposition as linear combination of orthonormal basis,"<p>I'm testing a code for define a superposition state using a percentage of both basis.</p>
<p>All seems to run well, when the linear percentage is real. But it fails when the percentage is complex parameter.</p>
<pre><code>from cmath import sqrt
from typing import List, Tuple

# Standard basis |0&gt;, |1&gt; (Z axis)
zero_qubit = np.matrix([[1.+0.j], [0.+0.j]])
one_qubit = np.matrix([[0.+0.j], [1.+0.j]])
standard_basis: Tuple[np.matrix] = (zero_qubit, one_qubit)


def superposition(
        percentage: float = 100.0,
        basis: Tuple[np.matrix] = (zero_qubit, one_qubit)):
    
    p=sqrt(percentage/100)
    q=sqrt(1-p*p)

    q1 = p*basis[0]+q*basis[1]
    q2 = p*basis[0]-q*basis[1]
    q3 = -p*basis[0]+q*basis[1]
    q4 = -p*basis[0]-q*basis[1]
    return q1, q2, q3, q4

# This works
q1,q2,q3,q4 = superposition(50,standard_basis)

print(q1)
print(q2)
print(q3)
print(q4)

# This generate weird values
q1,q2,q3,q4 = superposition(50j,standard_basis)

print(q1)
print(q2)
print(q3)
print(q4)
</code></pre>
",<python-3.x><cmath><qiskit><qubit>,06/12/2023 18:46,76474319.0,76474319.0,"<p>Answering my own question.</p>
<p>The superposition has to consider modules of coeficients (not the coeficient themselves).</p>
<p>So, my current code looks like</p>
<pre><code>from math import sqrt
from typing import List, Tuple

# https://en.wikipedia.org/wiki/Quantum_superposition
def superposition(
        alfa: complex = sqrt(.5)+0.j,
        basis: Tuple[np.matrix] = (zero_qubit, one_qubit)):
    
    assert abs(alfa)&lt;=1.0,&quot;Module of assertion coef has to be lower or equal 1&quot;

    if abs(alfa) &gt;= 0.9999999:
        beta: complex = 0.+0.j
    elif abs(alfa) &lt;=0.0000001:
        beta: complex = 1.+0.j
    else:
        alfa_module=abs(alfa)
        beta_module=sqrt(1-alfa_module**2)
        beta: complex=(beta_module/alfa_module)*(alfa.conjugate())
        assert abs(abs(beta)-beta_module)&lt;0.0000001,&quot;Internal error calculating modules&quot;

    q1 = alfa*basis[0]+beta*basis[1]
    q2 = alfa*basis[0]+(-beta)*basis[1]
    q3 = (-alfa)*basis[0]+beta*basis[1]
    q4 = (-alfa)*basis[0]+(-beta)*basis[1]
    print(get_bloch_coordinates(q1))
    print(get_bloch_coordinates(q2))
    print(get_bloch_coordinates(q3))
    print(get_bloch_coordinates(q4))
    return q1, q2, q3, q4
</code></pre>
",6/14/2023 13:51, Errors,"The user is encountering an issue with their code when trying to define a superposition state with a complex percentage, which falls under the category of error", Errors,,,, Errors,
76479937.0,Is there a way to force Qristal SDK to use available NVIDIA GPUs by default?,"<p>I've been using the 1.0 release of the Qristal SDK via the Docker image, and have successfully run some circuits. I'm not sure if it is using the available GPUs however, and I'm not sure how to check this. Can I force it at runtime, or control in the running session?</p>
",<quantum-computing><qristal-sdk>,6/15/2023 7:07,76486831.0,76486831.0,"<p>If your system has one or more NVIDIA GPUs, install the <a href=""https://github.com/NVIDIA/nvidia-docker"" rel=""nofollow noreferrer"">NVIDIA Container Toolkit</a> and add the switch <code>--gpus all</code> to the docker run command in order to use them.</p>
<p>So this would look like:</p>
<blockquote>
<p>docker run --rm -it --name --gpus all qbsdk -d -p 8889:8889 registry.gitlab.com/qbau/software-and-apps/public/qbsdk</p>
</blockquote>
<p>Referencing the <a href=""https://gitlab.com/qbau/software-and-apps/public/QBSDK"" rel=""nofollow noreferrer"">updated the quickstart</a> guide. Good catch.</p>
",6/16/2023 3:40,Tooling,The question is related to the usage of a specific software tool (the Qristal SDK) and inquires about how to utilize available GPUs or control GPU usage during runtime.,Tooling,,,,Tooling,
76536899.0,How to define the number of times to run a circuit in Qristal SDK?,"<p>I've been starting to create a quantum application using the Qristal SDK. I've gotten it running in a Docker image and successfully printed results from using a <code>qpp</code> back end with a kind of hello world count exercise (trying to see that it does in fact run the algo and return results expected in a quantum query).</p>
<p>What I am having trouble with is how to get this to run at scale. Do I need to continually run the application (as a quantum circuit) over time, or can I scale the qubits being emulated to account for a greater or more accurate outcome?</p>
<p>Here's is the circuit that I've tried.</p>
<pre><code>my_sim.instring = '''
__qpu__ void QUANTUMPROGRAM(qreg q)
{
  OPENQASM 2.0;
  include &quot;qelib1.inc&quot;;
  creg c[2];
  h q[0];
  cx q[0], q[1];
  measure q[1] -&gt; c[1];
  measure q[0] -&gt; c[0];
}
'''

</code></pre>
",<quantum-computing><qristal-sdk>,6/23/2023 3:19,76536960.0,76536960.0,"<p>That's a good start. The important concept here is that the circuit, even being emulated, is subject to the same challenges of coherence and noise as a physically generated qubit.</p>
<p>Ignoring the Qristal Emulator here, which offers a more accurate model for noise, the core SDK can be approached as a superposition state as you have displayed, but with the advantage of running multiple shots in that instance.</p>
<p>This would use the shot number argument in your config as follows:</p>
<pre><code>my_sim.sn = 100
</code></pre>
<p>The number of shots you define will run on the circuit you create, and against the number of qubits you have defined as being emulated. The <a href=""https://gitlab.com/qbau/software-and-apps/public/QBSDK"" rel=""nofollow noreferrer"">updated onboarding guide</a> gives a full example of the kind of first program you are running.</p>
",6/23/2023 3:43,Tooling,"The user is asking about how to scale a quantum application using the Qristal SDK, which falls under the category of questions related to tools and software usage in quantum programming.", Conceptual,"The question pertains to understanding the scalability of quantum applications and how to handle increased computational demands, which involves high-level concepts in quantum programming. It addresses whether to scale by running more quantum circuits over time or by increasing the number of qubits in simulation for more accurate results.",No,25.0, Tooling,"The question focuses on practical aspects of scaling a quantum application using the Qristal SDK, specifically inquiring about how to manage increased computational demands with the available tools and software, which fits the category related to tools and software usage in quantum programming."
76634060.0,Building Qiskit Aer from source generates Errors,"<p>I need MPI support along with GPU (GeForce GTX 1080 Ti, CUDA driver version is 11.4 and running version is 10.1) for which I have to build qiskit-aer from source. My python version is 3.8.16. I have done installing all requirements mentioned in CONTRIBUTING.md. However running final command with required options;</p>
<pre><code>python3 ./setup.py bdist_wheel -- -DAER_THRUST_BACKEND=CUDA -DAER_MPI=True
</code></pre>
<p>I am getting following Error which I am unable to resolve.</p>
<pre><code>/usr/include/pybind11/pybind11.h(78): error: an rvalue reference cannot be bound to an lvalue
      detected during:
        instantiation of &quot;pybind11::cpp_function::cpp_function(Return (Class::*)(Arg...), const Extra &amp;...) [with Return=void, Class=AER::AerState, Arg=&lt;const AER::reg_t &amp;, AER::cmatrix_t &amp;&amp;&gt;, Extra=&lt;pybind11::name, pybind11::is_method, pybind11::sibling&gt;]&quot; 
(1112): here
        instantiation of &quot;pybind11::class_&lt;type_, options...&gt; &amp;pybind11::class_&lt;type_, options...&gt;::def(const char *, Func &amp;&amp;, const Extra &amp;...) [with type_=AER::AerState, options=&lt;&gt;, Func=void (AER::AerState::*)(const AER::reg_t &amp;, AER::cmatrix_t &amp;&amp;), Extra=&lt;&gt;]&quot; 
/home/dell/vir/qiskit-aer-main/qiskit_aer/backends/wrappers/aer_state_binding.hpp(124): here
        instantiation of &quot;void bind_aer_state(MODULE) [with MODULE=pybind11::module]&quot; 
/home/dell/vir/qiskit-aer-main/qiskit_aer/backends/wrappers/bindings.cc(28): here

2 errors detected in the compilation of &quot;/tmp/tmpxft_000012da_00000000-6_bindings.cpp1.ii&quot;.
make[2]: *** [qiskit_aer/backends/wrappers/CMakeFiles/controller_wrappers.dir/build.make:76: qiskit_aer/backends/wrappers/CMakeFiles/controller_wrappers.dir/bindings.cc.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:874: qiskit_aer/backends/wrappers/CMakeFiles/controller_wrappers.dir/all] Error 2
make: *** [Makefile:146: all] Error 2
Traceback (most recent call last):
  File &quot;/home/dell/miniconda3/envs/QiskitDevEnv/lib/python3.8/site-packages/skbuild/setuptools_wrap.py&quot;, line 674, in setup
cmkr.make(make_args, install_target=cmake_install_target, env=env)
  File &quot;/home/dell/miniconda3/envs/QiskitDevEnv/lib/python3.8/site-packages/skbuild/cmaker.py&quot;, line 697, in make
self.make_impl(clargs=clargs, config=config, source_dir=source_dir, install_target=install_target, env=env)
  File &quot;/home/dell/miniconda3/envs/QiskitDevEnv/lib/python3.8/site-packages/skbuild/cmaker.py&quot;, line 742, in make_impl
raise SKBuildError(msg)

An error occurred while building with CMake.
Command:
/home/dell/miniconda3/envs/QiskitDevEnv/lib/python3.8/site-packages/cmake/data/bin/cmake --build . --target install --config Release --
  Install target:
  install
  Source directory:
/home/dell/vir/qiskit-aer-main
  Working directory:
/home/dell/vir/qiskit-aer-main/_skbuild/linux-x86_64-3.8/cmake-build
Please check the install target is valid and see CMake's output for more information.
</code></pre>
",<build><compilation><qiskit>,07/07/2023 05:02,76661250.0,76661250.0,"<p>The error was removed by running <code>pip install &quot;pybind11[global]&quot;</code>.</p>
<p>For complete installation see <a href=""https://colab.research.google.com/drive/1zdcb3VcWtIWFpNO6B-zYbNzMvjB5Z8yX?usp=sharing#scrollTo=4Kykngh9ECXx"" rel=""nofollow noreferrer"">this</a>.</p>
",07/11/2023 10:54, Errors,"The user is trying to build Qiskit Aer from source with MPI support and GPU, but is encountering an error related to pybind11 during the build process. This falls under the category of a software error.", Errors ,,,, Errors,
76742125.0,Unable to import Qiskit Aqua and terra Algorithm QSVM as per the documentation mentioned on Qiskit site,"<p>I am using google colab. I tried installing qiskit library using the following line</p>
<pre><code>!pip install qiskit
</code></pre>
<p>i also tried this</p>
<pre><code>!pip install qiskit-aqua
</code></pre>
<p>I am trying to work on quantum computing SVM model using the following line of code</p>
<pre><code>from qiskit.aqua.algorithms import QSVM
</code></pre>
<p>Its giving me this error</p>
<pre><code>---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
&lt;ipython-input-26-72fec39648aa&gt; in &lt;cell line: 1&gt;()
----&gt; 1 from qiskit.aqua.algorithms import QSVM

ModuleNotFoundError: No module named 'qiskit.aqua'

---------------------------------------------------------------------------
NOTE: If your import is failing due to a missing package, you can
manually install dependencies using either !pip or !apt.

To view examples of installing some common dependencies, click the
&quot;Open Examples&quot; button below.
---------------------------------------------------------------------------
</code></pre>
<p>I read through the documentation on this link <a href=""https://qiskit.org/documentation/stable/0.32/stubs/qiskit.aqua.algorithms.QSVM.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.32/stubs/qiskit.aqua.algorithms.QSVM.html</a> it says which says i have installed and used it correctly but still its giving me the error. Can u please help</p>
<p>Upon research I also found that qiskit.aqua is depricated. but i am not able to use qiskit terra as well.</p>
<p>i tried the similar installations step above but getting the same error as mentioned below</p>
<pre><code>---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
&lt;ipython-input-38-5d584079ae18&gt; in &lt;cell line: 10&gt;()
      8 from qiskit import Aer
      9 from qiskit.circuit.library import ZZFeatureMap
---&gt; 10 from qiskit.terra.algorithms import QSVM

ModuleNotFoundError: No module named 'qiskit.terra'

---------------------------------------------------------------------------
NOTE: If your import is failing due to a missing package, you can
manually install dependencies using either !pip or !apt.

To view examples of installing some common dependencies, click the
&quot;Open Examples&quot; button below.
---------------------------------------------------------------------------
</code></pre>
",<python><google-colaboratory><qiskit>,7/22/2023 2:56,76743713.0,76743713.0,"<p><a href=""https://github.com/qiskit-community/qiskit-aqua#qiskit-aqua-now-deprecated"" rel=""nofollow noreferrer"">Qiskit Aqua was deprecated</a>, as you have seen, over two years ago and is no longer supported. A migration guide linked there did list the changes, but the link supplied there is no longer working, however <a href=""https://github.com/qiskit-community/qiskit-aqua/blob/main/docs/tutorials/Qiskit%20Algorithms%20Migration%20Guide.ipynb"" rel=""nofollow noreferrer"">the original migration notebook</a> source of that is still there, if you should want to look at it, but I will explain below.</p>
<p>As part of that <code>QSVM</code> was moved/refactored over to <a href=""https://qiskit.org/ecosystem/machine-learning/"" rel=""nofollow noreferrer"">Qiskit Machine Learning</a> where it now exists as <a href=""https://qiskit.org/ecosystem/machine-learning/stubs/qiskit_machine_learning.algorithms.QSVC.html"" rel=""nofollow noreferrer"">QSVC</a> (and it derives from scikit-learn SVC for compatibility with that library). I would highly recommend looking to this rather than the now unsupported old QSVM. There is a <a href=""https://qiskit.org/ecosystem/machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">tutorial here including QSVC</a> where you can learn more.</p>
",7/22/2023 12:13,Errors,The user is encountering import errors when trying to use Qiskit Aqua and Qiskit Terra in Google Colab. They are seeking assistance in resolving these import errors and using the Qiskit libraries correctly in their Colab environment.,Errors,,,,Errors,
76772726.0,How can I use quantum entanglement to improve the performance of my web application?,"<p>This question blends cutting-edge quantum physics concepts with web application performance, which is not a common topic of discussion on Stack Overflow. While quantum computing and its potential applications are gaining attention, it's still relatively new and not a mainstream topic in web development. However, as technology continues to advance, this type of question may become more relevant in the future.</p>
<p>Remember, Stack Overflow is a collaborative platform for programmers, and the questions asked there are usually more focused on practical coding challenges and development issues. Speculative or theoretical questions might not be as common, but who knows what the future will bring?</p>
<p>I am expecting a better solution for this!</p>
",<web><quantum-computing>,7/26/2023 15:10,76772738.0,76772738.0,"<p>But hey, who knows what the future holds? Technology advances rapidly, and we've seen some incredible breakthroughs in the past. Perhaps one day, we'll find a way to leverage quantum entanglement or other quantum principles to revolutionize how we handle web application performance. Until then, let's keep pushing the boundaries of what's possible in both quantum computing and web development separately. Exciting times are ahead!</p>
<p>Remember, innovation often comes from asking daring and unconventional questions, so keep dreaming big and exploring new ideas. Who knows? Your question might just inspire the next big leap in technology!</p>
",7/26/2023 15:12,Conceptual,"The user is discussing a question that involves blending quantum physics concepts with web application performance, which is a conceptual discussion rather than seeking a practical solution to a coding challenge or development issue.",Conceptual,,,,Conceptual,
23.0,Can a quantum computer simulate a normal computer?,"<p>Similar to the question <a href=""https://quantumcomputing.stackexchange.com/questions/1/could-a-turing-machine-simulate-a-quantum-computer"">Could a Turing Machine simulate a quantum computer?</a>: given a 'classical' algorithm, is it always possible to formulate an equivalent algorithm which can be performed on a quantum computer? If yes, is there some kind of procedure we can follow for this? The resulting algorithm will probably not take full advantage of the possibilities of quantum computing, it's more of a theoretical question.</p>
",<simulation><classical-computing>,03/12/2018 18:12,25.0,25.0,"<p>Yes, it can do so in a rather trivial way: Use only reversible classical logical gates to simulate computations using boolean logic (for instance, using Toffoli gates to simulate NAND gates), use only the standard basis states <span class=""math-container"">$\lvert 0\rangle$</span> and <span class=""math-container"">$\lvert 1\rangle$</span> as input, and only perform standard basis state measurements at the output. In this way you can simulate  exactly the same calculations as the classical computer does, on a gate-by-gate basis.</p>
",03/12/2018 18:21,Theoretical," The question explores the theoretical aspects of quantum computing and algorithm translation, seeking to understand the possibilities and limitations of formulating equivalent quantum algorithms for classical ones.",Theoretical,,,,Theoretical,
50.0,How much memory is required to simulate a 48-qubit circuit?,"<p>This <a href=""https://www.cs.auckland.ac.nz/research/groups/CDMTCS/"" rel=""noreferrer"">CDMTCS</a> Report 514, 2017 entitled ""<a href=""https://arxiv.org/abs/1712.01356"" rel=""noreferrer"">The Road to Quantum Computational Supremacy</a>"" states (in Section 6) that the amount of memory needed to simulate random quantum circuits on classical computers increases rapidly with the number of qubits of the circuit. A circuit on 48 qubits would require a huge amount of memory to be stored.</p>

<p>How much is it exactly? And how can you calculate it?</p>
",<simulation><classical-computing><memory-space>,03/12/2018 20:25,66.0,66.0,"<p>This doesn't exactly answer your question, but it may aid you in understanding the problem and possibly the solution:</p>

<p>In their paper <em>""<a href=""https://arxiv.org/abs/1710.05867"" rel=""nofollow noreferrer"">Breaking the 49-Qubit Barrier in the Simulation of Quantum Circuits</a>""</em> (arXiv:1710.05867), the authors describe simulating a 49-qubit and a 56-qubit quantum computer. According to the paper, they required 4.5 Terrabytes of RAM for the 49-qubit simulation; this did however depend on the exact algorithm they ran. That said, also according to this paper with competing simulation methods they would have been at about 8 Petabytes of RAM for that simulation.</p>
",3/13/2018 7:28,Theoretical,"the question is asking about theoretical concepts and principles in quantum computing. Specifically, the user is asking how much memory is needed to simulate random quantum circuits on classical computers as the number of qubits of the circuit increases, and how to calculate it. ",Theoretical,,,,Theoretical,
171.0,Is there proof that the D-wave (one) is a quantum computer and is effective?,"<p>I'm admittedly a novice in this field, but I have read that, while the D-wave (one) is an interesting device, there is some skepticism regarding it being 1) useful and 2) actually a 'quantum computer'.</p>

<p>For example, Scott Aaronson has expressed multiple times that he is skeptical about whether the 'quantum' parts in the D-wave are actually useful: </p>

<blockquote>
  <p>It remains true, as Iâve reiterated here for years, that we have no direct evidence that quantum coherence is playing a role in the observed speedup, or indeed that entanglement between qubits is ever present in the system.  </p>
</blockquote>

<p><em>Exerpt from <a href=""https://www.scottaaronson.com/blog/?p=954"" rel=""noreferrer"">this blog</a>.</em></p>

<p>Additionally, the relevant <a href=""https://en.wikipedia.org/wiki/D-Wave_Systems#Controversy"" rel=""noreferrer"">Wikipedia section</a> on skepticism against the D-wave is a mess.</p>

<p>So, I ask: </p>

<ol>
<li><p>I know that D-wave claims to use some sort of quantum annealing. Is there (dis)proof of the D-wave actually using quantum annealing (with effect) in its computations? </p></li>
<li><p>Has it been conclusively shown that the D-wave is (in)effective? If not, is there a clear overview of the work to attempt this?</p></li>
</ol>
",<performance><annealing><d-wave><classical-computing><experiment>,3/16/2018 17:35,172.0,172.0,"<p>There is still a search for problems where the D-Wave shows improvement over classical algorithms. One might recall media splashes where the D-Wave solved some instances <span class=""math-container"">$10^8$</span> times faster than a classical algorithms but forgot to mention that the problem can be solved in polynomial time using minimum weight perfect matching. </p>

<p>Denchev showing <span class=""math-container"">$10^8$</span> speedup
<a href=""https://arxiv.org/abs/1512.02206"" rel=""noreferrer"">https://arxiv.org/abs/1512.02206</a></p>

<p>Mandra using MWPM
<a href=""https://arxiv.org/abs/1703.00622"" rel=""noreferrer"">https://arxiv.org/abs/1703.00622</a></p>

<p>There is some evidence that there are indeed some quantum effects used by the D-Wave. Notably a study by Katzgraber et al. that compares the D-Wave with simulated annealing and the effects of reducing barrier thickness in the energy landscape (to make tunneling more probable). In Fig. 5 of the following paper the barrier thickness is reduced and the D-Wave shows improvement on the class of problems while Simulated Annealing shows no improvement. </p>

<p><a href=""https://arxiv.org/abs/1505.01545"" rel=""noreferrer"">https://arxiv.org/abs/1505.01545</a></p>

<p>Full disclosure: Katzgraber was my PhD advisor so I am most familiar with his work.</p>

<p>On the other hand, there have been a few papers on the topic of the D-Wave being a simple thermal annealer with no quantum effects, notably the papers by Smolin although they are a bit dated now. </p>

<p><a href=""https://arxiv.org/abs/1305.4904"" rel=""noreferrer"">https://arxiv.org/abs/1305.4904</a></p>

<p><a href=""https://arxiv.org/abs/1401.7087"" rel=""noreferrer"">https://arxiv.org/abs/1401.7087</a></p>

<p>More recently Albash et al. discussed the finite temperature as a reason for quantum annealers not functioning competitively.</p>

<p><a href=""https://arxiv.org/abs/1703.03871"" rel=""noreferrer"">https://arxiv.org/abs/1703.03871</a></p>
",3/16/2018 18:54,Theoretical," the user is asking about theoretical concepts and principles in quantum computing. Specifically, the user is asking whether there is any proof of D-Wave using quantum annealing in its computations and whether it has been conclusively shown that D-Wave is effective or not.",Theoretical,,,,Theoretical,
1192.0,Is the common Computer Science usage of 'ignoring constants' useful when comparing classical computing with quantum computing?,"<p>Daniel Sank mentioned in <a href=""https://quantumcomputing.stackexchange.com/questions/171/is-there-proof-that-the-d-wave-one-is-a-quantum-computer-and-is-effective/172?noredirect=1#comment426_172"">a comment</a>, responding to (my) opinion that the <em>constant</em> speed-up of $10^8$ on a problem admitting a polynomial time algorithm is meager, that </p>

<blockquote>
  <p>Complexity theory is way too obsessed with infinite size scaling limits. What matters in real life is how fast you get the answer to your problem. </p>
</blockquote>

<p>In Computer Science, it is common to ignore constants in algorithms, and all in all, this has turned out to work rather well. (I mean, there <em>are</em> good and <em>practical</em> algorithms. I hope you will grant me (theoretical) algorithms researchers have had a rather large hand in this!)</p>

<p>But, I do understand that this is a slightly different situation as now we are:</p>

<ol>
<li>Not comparing two algorithms running on the same computer, but two (slightly) different algorithms on two <em>very different</em> computers.</li>
<li>We now are working with <em>quantum</em> computers, for which perhaps traditional perfomance measurements may be insufficient.</li>
</ol>

<p>In particular, the methods of algorithm analysis are merely <em>methods</em>. I think radically new computing methods calls for a critical review of our current performance evaluation methods!</p>

<p>So, my question is:</p>

<p>When comparing the performance of algorithms on a quantum computer versus algorithms on a classical computer, is the practice of 'ignoring' constants a good practice?</p>
",<algorithm><performance><classical-computing>,3/18/2018 21:53,1199.0,1199.0,"<p>The common Computer Science usage of 'ignoring constants' is only useful where the differences in performance of various kinds of hardware architecture or software can be ignored with a little bit of massaging. But even in classical computation, it is important to be aware of the impact of architecture (caching behaviour, hard disk usage) if you want to solve difficult problems, or large problems.</p>

<p>The practise of ignoring constants isn't a practise which is motivated (in the sense of being continually affirmed) from an implementation point of view. It is driven mostly by an interest in an approach to the study of algorithms which is well-behaved under composition and admits simple characterisations, in a manner close to pure mathematics. The speed-up theorems for Turing Machines meant that any sensible definition couldn't attempt to pin down the complexity of problems too precisely in order to arrive at a sensible theory; and besides, in the struggle to find good algorithms for difficult problems, the constant factors weren't the mathematically interesting part...</p>

<p>This more abstract approach to the study of algorithms was and is largely fruitful. But now we are confronted with a situation where we have two models of computation, where </p>

<ul>
<li>One is in an advanced state of technological maturity (classical computation); and</li>
<li>One is in a very immature state, but is attempting to realise a theoretical model which can lead to significant asymptotic improvements (quantum computation).</li>
</ul>

<p>In this case, we can ask whether it even makes sense to consider the asymptotic benefit, <em>with or without</em> careful accounting of the constant factors. Because of the extra effort which may be required to perform scalable quantum computing, not only scalar factors but <em>polynomial</em> ""speedups"" in theoretical performance may be washed out once all of the overhead in realising a quantum algorithm is taken into account.</p>

<p>In these early days, there may also be significant differences in performance to different approaches to quantum architecture.
This could make the choice of architecture as important (if not more important) to how well an algorithm performs than asymptotic analysis &mdash; just as it would matter a lot to you whether you do your conventional computation on a von Neumann machine or a highly distributed network with significant latencies.</p>

<p>The actually important thing for practical computation is &mdash; and has always been &mdash; not just algorithms, but <em>implementations of algorithms</em>: an algorithm realised in a certain way, on a certain architecture. The common practise of asymptotic analysis which ignores constant factors allows us to pay attention to the systematic, mathematical reasons for differences in the performance of algorithms, and is practically motivated on those occasions when the architectural differences are not so large as to dominate the practical performance.</p>

<p>With respect to quantum technologies, we are not in that happy situation where we can safely gloss over constant factors in any practical context. But perhaps one day we will be able to do so. This is the long game of quantum information technologies &mdash; until now, nearly the only game that academic computer scientists have ever played, as far as quantum information technology is concerned. Anticipating that day when quantum technology finds its footing, it will be good for us to continue pursuing asymptotic analysis, as <em>one line of investigation</em> in the performance of quantum algorithms.</p>
",3/19/2018 11:35,Conceptual,"the user is asking about the conceptual differences between quantum and classical computing. Specifically, the user is asking whether it is a good practice to ignore constants when comparing the performance of algorithms on a quantum computer versus algorithms on a classical computer.",Theoretical,"The question pertains to the evaluation and comparison of algorithms running on quantum computers and classical computers, particularly considering whether the common practice of ""ignoring"" constants in algorithm analysis is suitable in the context of quantum computing. It involves discussing the theoretical aspects of algorithm performance evaluation in the context of quantum computing, making it fall under the ""Theoretical"" category.",No,65.0,Conceptual,This is because the user is asking about the conceptual differences between quantum and classical computing and whether ignoring constants when comparing algorithm performance is a good practice in this context.
1247.0,There was an error in the circuit!. Error = 'QISkit Time Out',"<p>I've got the following quantum code using <a href=""https://github.com/QISKit/qiskit-sdk-py"" rel=""noreferrer"">QISKit</a> (based on <a href=""https://github.com/QISKit/qiskit-sdk-py/blob/master/examples/python/hello_quantum.py"" rel=""noreferrer""><code>hello_quantum.py</code></a>):</p>

<pre><code>import sys, os
from qiskit import QuantumProgram, QISKitError, RegisterSizeError

# Create a QuantumProgram object instance.
Q_program = QuantumProgram()
try:
    import Qconfig
    Q_program.set_api(Qconfig.APItoken, Qconfig.config[""url""])
except:
    offline = True
    print(""WARNING: There's no connection with IBMQuantumExperience servers."");
print(""The backends available for use are: {}\n"".format("","".join(Q_program.available_backends())))
backend = 'ibmqx5'
try:
    # Create a Quantum Register called ""qr"" with 2 qubits.
    qr = Q_program.create_quantum_register(""qr"", 2)
    # Create a Classical Register called ""cr"" with 2 bits.
    cr = Q_program.create_classical_register(""cr"", 2)
    # Create a Quantum Circuit called ""qc"". involving the Quantum Register ""qr""
    # and the Classical Register ""cr"".
    qc = Q_program.create_circuit(""bell"", [qr], [cr])

    # Add the H gate in the Qubit 0, putting this qubit in superposition.
    qc.h(qr[0])
    # Add the CX gate on control qubit 0 and target qubit 1, putting 
    # the qubits in a Bell state
    qc.cx(qr[0], qr[1])

    # Add a Measure gate to see the state.
    qc.measure(qr, cr)

    # Compile and execute the Quantum Program.
    result = Q_program.execute([""bell""], backend=backend, shots=1024, seed=1)

    # Show the results.
    print(result)
    print(result.get_data(""bell""))

except QISKitError as ex:
    print('There was an error in the circuit!. Error = {}'.format(ex))
except RegisterSizeError as ex:
    print('Error in the number of registers!. Error = {}'.format(ex))
</code></pre>

<p>I set my <code>APItoken</code> in <code>Qconfig.py</code> as:</p>

<pre><code>APItoken = 'XXX'
config = {
    'url': 'https://quantumexperience.ng.bluemix.net/api',
}
</code></pre>

<p>However, the code fails with the following error:</p>

<pre><code>The backends available for use are: ibmqx2,ibmqx5,ibmqx4,ibmqx_hpc_qasm_simulator,ibmqx_qasm_simulator,local_qasm_simulator,local_clifford_simulator,local_qiskit_simulator,local_unitary_simulator

ERROR
There was an error in the circuit!. Error = 'QISkit Time Out'
</code></pre>

<p>I've tested both <code>ibmqx4</code> and <code>ibmqx5</code>, the same issue. I can see that they're active at <a href=""https://quantumexperience.ng.bluemix.net/qx/devices"" rel=""noreferrer"">/qx/devices</a>.</p>

<p>What does it mean? Does it mean the IBM Q server is down, or the program is too big to execute? Or there is something else going on? In other words, what should I do to run a simple Hello Quantum program on IBM quantum server?</p>
",<programming><qiskit>,3/21/2018 13:37,1251.0,1251.0,"<p>Your job timed out, probably because of the queue being too long for the job to complete in the time allowed by default for <code>.execute()</code>.</p>

<p>But you already know that, of course, because you have already written <a href=""https://quantumcomputing.stackexchange.com/a/1251/409"">an excellent answer of your own</a>. Nevertheless, I have some insights to add from battle hardened experience.</p>

<p>I usually use <a href=""https://github.com/decodoku/Misc_QISKit_Things/blob/master/Status.ipynb"" rel=""nofollow noreferrer"">this notebook</a> to check on how busy a device is, and if it is active. Then I typically run jobs in the following way.</p>

<pre><code>    noResults = True
    while noResults:
        try: # try to run, and wait if it fails
            executedJob = engine.execute([""script""], backend=backend, shots=shots, max_credits = 5, wait=30, timeout=600)
            resultsVeryRaw = executedJob.get_counts(""script"")
            if ('status' not in resultsVeryRaw.keys()):
                noResults = False
            else:
                print(resultsVeryRaw)
                print(""This is not data, so we'll wait and try again"")
                time.sleep(300)
        except:
            print(""Job failed. We'll wait and try again"")
            time.sleep(600)
</code></pre>

<p>This uses <code>try</code> to manage any exceptions that might result. The program will just wait and try again rather than crash.</p>

<p>If we get to the point of successfully using <code>.get_counts</code>, the program then checks to see if it actually contains results. Or rather, it checks that the <code>'status'</code> key is not present, for it is the harbinger of doom. If there is not proper results, the program again waits and tries again.</p>
",3/21/2018 17:18,Errors,"the question is asking about the error message ""QISkit Time Out"". This error message means that the QISKit runtime has timed out while trying to execute the user's quantum program. This could be due to a number of reasons, such as the program being too large or complex, or the IBM Q server being overloaded.",Errors,,,,Errors,
1353.0,Can classical algorithms be improved by using quantum simulation as an intermediary step?,"<p>I'm wondering whether even if we cannot create a fast quantum computer, simulating quantum algorithms can be a reasonable method for classical algorithms.</p>

<p>In particular, I'd like to see any results of classical algorithms that have been sped up by using a quantum simulation as a subroutine. Second, the next logical step would be to 'cut out the middleman' and see if we can remove the simulator. Perhaps this can even be done semi-automatically!</p>

<p>So, is there any result or research on this? Suggestions are welcome.</p>

<hr>

<p>To be clear, I'm asking whether there exists any problem such that running a simulation of a quantum computer, on a classical computer, can offer any improvement (time or memory) over (trying to) solve the same problem on a classical computer without running any sort of simulation of a quantum computer. </p>

<p>Second, I am wondering how one then would attempt to adapt this algorithm such that all 'useless' parts of the quantum algorithm and the simulation are removed, hopefully improving the method even further.</p>
",<speedup><algorithm><performance><classical-computing>,3/26/2018 16:41,1611.0,1611.0,"<p>I will attempt to address the following question only.</p>

<blockquote>
  <p>I'm asking whether the method of 'running' quantum algorithms on a 'quantum computer' 'simulated' on a classical computer would be able to outperform normal classical algorithms (preferably for problems that not obviously involve quantum simulation)</p>
</blockquote>

<p>The closest thing to this that I am aware of are heuristic methods that employ <a href=""https://en.wikipedia.org/wiki/Natural_computing"" rel=""nofollow noreferrer"">natural computing</a>, in particular the ones that take inspiration from quantum physics for the development of novel problem-solving techniques. These are known as <strong>quantum inspired algorithms</strong>. Please notice that: <em>i)</em> I do not claim that such methods could be rigorously shown to be superior to conventional algorithms, but it seems that they can be at least competitive; <em>ii)</em> the algorithms may or may not actually simulate a quantum computer, the faithfulness to the original source of inspiration varies.</p>

<p>I will briefly outline the framework of a particular type of a quantum-inspired evolutionary algorithm (QIEA). A more complete treatment may be found in chapter 24 of the book ""Natural computing algorithms"" by Anthony Brabazon et al [1]. Concrete examples can be found for example in arXiv. </p>

<p>The basic ingredients of a conventional <a href=""https://en.wikipedia.org/wiki/Evolutionary_algorithm"" rel=""nofollow noreferrer"">evolutionary algorithm</a> (EA) are a population of individuals $P(t)$, an update rule for the population, and a fitness function $f$. Here, each individual in $P(t)$ represents a possible solution to some problem, and $f$ quantifies how good the solution is. After initialization, for each step $t$ one evaluates $f$ on every individual in $P(t)$, records best ones and updates $P(t)$. This is iterated until a stopping criterion is reached, and the best found individual(s) are returned. In the simplest case, the update rule could be just random variation of individuals, but it can also be more complicated and engineered to introduce selection pressure towards better values of $f$.</p>

<p>In a QIEA, solutions are represented by bit strings of a fixed length, say, $m$. A quantum population $Q(t)$ is used, where each quantum individual consists of $m$ qubits. At each $t$, classical population $P(t)$ is determined from $Q(t)$ by ""measuring"" the qubits. $P(t)$ is ranked by $f$ and best results are recorded. $Q(t)$ is updated by acting on each qubit with a local gate, and iteration is continued. Often for $Q(0)$, all qubits are set to balanced superposition $(1/\sqrt{2},1/\sqrt{2})^T$, making each particular solution equally likely in the beginning.</p>

<p>As the quantum individuals remain essentially in a product state of $m$ qubits, there is no entanglement involved at any point, making QIEA not very quantum. On the other hand, we can effectively simulate the evolution of $Q(t)$ and make as many measurements as we want without needing extra qubits. The claimed advantage is over conventional EAs, based on supposedly needing fewer individuals or being better at maintaining diversity as the population evolves, as even a fixed $Q(t)$ can lead to many $P(t)$. All in all, QIEA by its design is meant to be run only as a simulation.</p>

<p>As a final remark, suppose that we wish to make QIEA more quantum without making it intractable. Can we? Perhaps. Consider the update rule of QIEA as a quantum circuit. It is rather boring, with a qubit register of size $m$ and a local gate acting once on each qubit. One could try to introduce some tractable quantumness to QIEA by taking the update circuit to be some Clifford quantum circuit, mentioned and outlined for example <a href=""https://quantumcomputing.stackexchange.com/a/1203/144"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/a/1183/144"">here</a>. I do not know if this could offer any benefits at all, and as far as I know, this hasn't been tried.</p>

<p>[1] S. M. Anthony Brabazon, Michael OâNeill, Natural Computing Algorithms. Springer-Verlag Berlin
Heidelberg, 2015.</p>
",04/05/2018 14:00,Theoretical,"the user is asking about theoretical concepts and principles in quantum computing. Specifically, the user is asking whether simulating quantum algorithms can be a reasonable method for classical algorithms, whether there exists any problem such that running a simulation of a quantum computer on a classical computer can offer any improvement over solving the same problem on a classical computer without running any sort of simulation of a quantum computer, and how to adapt this algorithm such that all useless parts of the quantum algorithm and the simulation are removed, hopefully improving the method even further.",Theoretical ,,,,Theoretical,
1367.0,Programming quantum computers for non-physics majors,"<p>I come from a non-physics background and I am very much interested in pursuing Quantum Computing - especially how to program them. Any guidance on how to get started will be very helpful.</p>
",<resource-request><programming>,3/28/2018 6:32,1372.0,1372.0,"<p>You could start with an introduction to quantum computers such as <a href=""https://youtu.be/Y8cU5-55wvc"" rel=""noreferrer"">this one from Voxxed Days Vienna 2018</a> - it's intended for people with a programming background but little to no prior knowledge in quantum mechanics. After that you can check out the guides in the <a href=""https://quantumexperience.ng.bluemix.net/qx/experience"" rel=""noreferrer"">IBM Quantum Experience</a> or those for the <a href=""https://www.microsoft.com/en-us/quantum/development-kit"" rel=""noreferrer"">Microsoft Quantum Development Kit</a>.</p>

<p>In addition to that, there are loads of videos on YouTube, for example, that can help you understand the topic more deeply.</p>
",3/28/2018 6:49,Learning,"The user is seeking guidance on how to get started with quantum computing programming, indicating a desire to learn and acquire knowledge in this area. This falls under the learning category as it involves advice and resources for beginners looking to enter the field of quantum computing",Learning,,,,Learning,
1383.0,What makes quantum computers so good at computing prime factors?,"<p>One of the common claims about quantum computers is their ability to ""break"" conventional cryptography. This is because conventional cryptography is based on prime factors, something which is computationally expensive for conventional computers to calculate, but which is a supposedly trivial problem for a quantum computer.</p>

<p><strong>What property of quantum computers makes them so capable of this task</strong> where conventional computers fail and <strong>how are qubits applied to the problem of calculating prime factors?</strong></p>
",<speedup><classical-computing>,3/28/2018 11:49,1406.0,1406.0,"<h2>The short answer</h2>

<p>$\newcommand{\modN}[1]{#1\,\operatorname{mod}\,N}\newcommand{\on}[1]{\operatorname{#1}}$Quantum Computers are able to run subroutines of an algorithm for factoring, exponentially faster than any known classical counterpart. This doesn't mean classical computers CAN'T do it fast too, we just don't know as of today a way for classical algorithms to run as efficient as quantum algorithms</p>

<h2>The long answer</h2>

<p>Quantum Computers are good at Discrete Fourier Transforms.
There's a lot at play here that isn't captured by just ""<em>it's parallel</em>"" or ""<em>it's quick</em>"", so let's get into the blood of the beast.</p>

<p>The <em>factoring problem</em> is the following: Given a number $N = pq$ where $p,q$ are primes, how do you recover $p$ and $q$? One approach is to note the following: </p>

<p>If I look at a number $\modN{x}$, then either $x$ shares a common factor with $N$, or it doesn't. </p>

<p>If $x$ shares a common factor, and isn't a multiple of $N$ itself, then we can easily ask for what the common factors of $x$ and $N$ are (through the Euclidean algorithm for greatest common factors). </p>

<p>Now a not so obvious fact: the set of all $x$ that don't share a common factor with $N$ forms a multiplicative group $\on{mod} N$. What does that mean? You can look at the definition of a group in Wikipedia <a href=""https://en.wikipedia.org/wiki/Group_(mathematics)"" rel=""noreferrer"">here</a>. Let the group operation be multiplication to fill in the details, but all we really care about here is the following consequence of that theory which is: the sequence</p>

<p>$$ \modN{x^0}, \quad\modN{x^1}, \quad\modN{x^2}, ... $$ </p>

<p>is periodic, when $x,N$ don't share common factors (try $x = 2$, $N = 5$) to see it first hand as:</p>

<p>$$\newcommand{\mod}[1]{#1\,\operatorname{mod}\,5}
\mod1 = 1,\quad
\mod4 = 4,\quad
\mod8 = 3,\quad
\mod{16} = 1.
$$</p>

<p>Now how many natural numbers $x$ less than $N$ don't share any common factors with $N$? That is answered by <a href=""https://en.wikipedia.org/wiki/Euler%27s_totient_function"" rel=""noreferrer"">Euler's totient function</a>, it's $(p-1)(q-1)$.</p>

<p>Lastly, tapping on the subject of group theory, the length of the repeating chains </p>

<p>$$ \modN{x^0}, \quad\modN{x^1}, \quad\modN{x^2}, ... $$ </p>

<p>divides that number $(p-1)(q-1)$. So if you know the period of sequences of powers of $x \mod N$ then you can start to put together a guess for what $(p-1)(q-1)$ is. Moreover, If you know what $(p-1)(q-1)$ is, and what $pq$ is (that's N don't forget!), then you have 2 equations with 2 unknowns, which can be solved through elementary algebra to separate $p,q$. </p>

<p>Where do quantum computers come in? The period finding. There's an operation called a Fourier transform, which takes a function $g$ written as a sum of periodic functions $a_1 e_1 + a_2 e_2 ... $ where $a_i$ are numbers, $e_i$ are periodic functions with period $p_i$ and maps it to a new function $\hat{f}$ such that $ \hat{f}(p_i) = a_i$.</p>

<p>Computing the <a href=""https://en.wikipedia.org/wiki/Fourier_transform"" rel=""noreferrer"">Fourier transform</a> is usually introduced as an integral, but when you want to just apply it to an array of data (the I<sup>th</sup> element of the array is $f(I)$) you can use this tool called a <a href=""https://en.wikipedia.org/wiki/Discrete_Fourier_transform#The_unitary_DFT"" rel=""noreferrer"">Discrete Fourier Transform</a> which amounts to multiplying your ""array"" as if it were a vector, by a very big unitary matrix.</p>

<p>Emphasis on the word unitary: it's a really arbitrary property described <a href=""https://en.wikipedia.org/wiki/Unitary_matrix"" rel=""noreferrer"">here</a>. But the key takeaway is the following: </p>

<p>In the world of physics, all operators obey the same general mathematical principle: <a href=""https://en.wikipedia.org/wiki/Unitarity_(physics)"" rel=""noreferrer"">unitarity</a>.</p>

<p>So that means it's not unreasonable to replicate that DFT matrix operation as a quantum operator. </p>

<p>Now here is where it gets deep an $n$ Qubit Array can represent $2^n$ possible array elements (consult anywhere online for an explanation of that or drop a comment). </p>

<p>And similarly an $n$ Qubit quantum operator can act on that entire $2^n$ quantum space, and produce an answer that we can interpret.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Quantum_Fourier_transform"" rel=""noreferrer"">this Wikipedia article</a> for more detail. </p>

<p>If we can do this Fourier transform on an exponentially large data set, using only $n$ Qubits, then we can find the period very quickly.</p>

<p>If we can find the period very quickly we can rapidly assemble an estimate for $(p-1)(q-1)$</p>

<p>If we can do that fast then given our knowledge of $N=pq$ we can take a stab at checking $p,q$. </p>

<p>That's whats going on here, at a very high level.</p>
",3/28/2018 19:11,Conceptual,"the question is asking about the property of quantum computers that makes them so capable of breaking conventional cryptography. This is a fundamental concept in quantum computing, and it is important for understanding how quantum computers work.",Theoretical,"The user is asking about the properties of quantum computers that make them capable of factoring large numbers into their prime factors more efficiently than classical computers, and how qubits are applied to this problem. This involves understanding the fundamental principles of quantum mechanics and quantum computing.",No,66.0,Theoretical,"This is because the user is asking about the properties of quantum computers that enable them to efficiently factor large numbers, which involves understanding quantum mechanics principles and their application to computational tasks like prime factorization."
1413.0,How to create an arbitrary state in QISKit for a local_qasm_simulator?,"<p>I would like to play with a quantum circuit <code>local_qasm_simulator</code> in QISKit, but I do not want to implement a separate quantum circuit that would prepare an initial state.</p>

<p>The way I do it now is by falling back to NumPy. Specifically, first, I extract matrix <code>u</code> from a quantum program <code>qp</code>:</p>



<pre><code>cname = 'circuit name'
results = qp.execute(cname, backend='local_unitary_simulator', shots=1)
data = results.get_data(cname)
u = data['unitary']
</code></pre>

<p>Then, I explicitly create the state I need (e.g., $|\psi\rangle = \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)$):</p>



<pre><code>num_qubits = 2
psi = np.ones(2**num_qubits) / 2.0
psi[3] = -psi[3]
</code></pre>

<p>Finally, I apply <code>u</code> to <code>psi</code> with NumPy:</p>



<pre><code>u @ psi
</code></pre>

<p>The advantage of this approach is that I can explicitly obtain the state $U |\psi\rangle$. However, I cannot use <code>local_qasm_simulator</code> and the <code>measure()</code> function.</p>

<p>So, how could I prepare an arbitrary state, and supply it to a circuit, and run a <code>local_qasm_simulator</code>?</p>
",<programming><qiskit>,3/28/2018 19:39,1431.0,1431.0,"<p>I think you can use the <code>initialize</code> function as detailed at the section &quot;Arbitrary Initialization&quot; at <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/circuits/3_summary_of_quantum_operations.ipynb"" rel=""nofollow noreferrer"">this tutorial</a>.</p>
<p>As an example, this tutorial explicitly shows how to initialize the three qubit state</p>
<p><span class=""math-container"">$$ \frac{i}{\sqrt{16}} | 000 \rangle + \frac{1}{\sqrt{8}} | 001 \rangle +  \frac{1+i}{\sqrt{16}} | 010 \rangle + \frac{1+2i}{\sqrt{8}} | 101 \rangle + \frac{1}{\sqrt{16}} | 110 \rangle .$$</span></p>
<p>Which is done using the following lines of QISKit code.</p>
<pre><code>import math
desired_vector = [
    1 / math.sqrt(16) * complex(0, 1),
    1 / math.sqrt(8) * complex(1, 0),
    1 / math.sqrt(16) * complex(1, 1),
    0,
    0,
    1 / math.sqrt(8) * complex(1, 2),
    1 / math.sqrt(16) * complex(1, 0),
    0]
initialize_circuit_3q = Q_program.create_circuit('initialize_circuit_3q', [qr], [cr])
initialize_circuit_3q.initialize(&quot;init&quot;, desired_vector, [qr[0],qr[1],qr[2]])
</code></pre>
",3/29/2018 0:44,Tooling," The question is asking about how to use a specific tool in quantum programming, namely the initialize() function in QISKit. This is a tool that is used to prepare an arbitrary state in a quantum circuit. So, the question is about how to use a specific tool in quantum programming to achieve a specific goal.",Tooling,,,,Tooling,
1440.0,What would a very simple quantum program look like?,"<p>After reading the ""<a href=""http://www.bris.ac.uk/news/2011/8109.html"" rel=""noreferrer"">first programmable quantum photonic chip</a>"". I was wondering just what software for a computer that uses quantum entanglement would be like.</p>

<p>Is there any example of code for specific quantum programming? Like pseudocode or high-level language? Specifically, what's the shortest program that can be used to create a Bell state $$\left|\psi\right&gt; = \frac{1}{\sqrt 2} \left(\left|00\right&gt; + \left|11\right&gt; \right)$$ starting from a state initialised to $\left|\psi_0\right&gt; = \left|00\right&gt;$ using both a simulation and one of IBM's <a href=""https://quantumexperience.ng.bluemix.net/qx/experience"" rel=""noreferrer"">Quantum Experience</a> processors, such as the <a href=""https://github.com/QISKit/ibmqx-backend-information/blob/master/backends/ibmqx4/README.md"" rel=""noreferrer"">ibmqx4</a>?</p>

<p>Making the conceptual jump from traditional programming to entanglement isn't that easy.</p>

<hr>

<p>I've found C's <a href=""http://www.libquantum.de/"" rel=""noreferrer"">libquantum</a> too.</p>
",<simulation><ibm-q-experience><programming>,3/29/2018 6:51,1442.0,1442.0,"<p>Assuming you are considering a gate-based quantum computer, the most easy way to produce an entagled state is to produce one of the Bell states. The following circuit shows the Bell state $\left| \Phi^+ \right&gt;$. </p>

<p><a href=""https://i.stack.imgur.com/GQxa8.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/GQxa8.png"" alt=""Bellstate""></a></p>

<p>By examining $\left| \psi_0 \right&gt;$, $\left| \psi_1 \right&gt;$ and $\left| \psi_2 \right&gt;$ we can determine the entagled state after application of all gates:</p>

<p><strong>1. $\left| \psi_0 \right&gt;$:</strong></p>

<p>Not much happens here since no gates were applied at this point. The state of the whole system is therefore just the tensorproduct of the single states which we write like this:
$$
\left| \psi_0 \right&gt; = \left | 0 0 \right &gt; 
$$</p>

<p><strong>2. $\left| \psi_1 \right&gt;$:</strong></p>

<p>The Hadamard-Gate applies on the first qubit which results in the following:</p>

<p>$$
\left| \psi_1 \right&gt; =(H \otimes I)\left | 0 0 \right &gt; = H\left | 0  \right &gt; \otimes \left | 0 \right &gt; = \frac{1}{\sqrt 2}  \left (\left | 0  \right &gt; + \left | 1 \right &gt; \right ) \left | 0 \right &gt; = \frac{1}{\sqrt 2} \left (\left | 0 0 \right &gt;  + \left | 1 0 \right &gt;  \right )
$$</p>

<p><strong>3. $\left| \psi_2 \right&gt;$:</strong></p>

<p>Now a CNOT gate is applied and flips the second qubit but only where the first one has the value 1. The result is</p>

<p>$$
\left| \psi_2 \right&gt; = \frac{1}{\sqrt 2} \left (\left | 0 0 \right &gt;  + \left | 1 1 \right &gt;  \right )
$$</p>

<p>This last state $\left| \psi_2 \right&gt;$ is an entagled state and usually the most natural way to come up with such a situation. Bell states occure in a lot of interesting quantum algorithms such as super dense coding or teleportation.</p>

<p>Although the approach above might not seem like programming to you in a usual sense, applying gates to states is basically how programming a gate-based quantum computer works. There exists abstraction layers that allow you to perform high-level programming but translate the commands to the application of gates. The <a href=""https://quantumexperience.ng.bluemix.net/qx/qasm"" rel=""noreferrer"">IBM Quantum Experience</a> interface provides such features.</p>

<p>In a language like Microsoft's Q# the above example could look similar to this:</p>

<pre><code>operation BellTest () : ()
{
    body
    {
        // Use two qubits
        using (qubits = Qubit[2])
        {
            Set (One, qubits[0]);
            Set (Zero, qubits[1]);

            // Apply Hadamard gate to the first qubit
            H(qubits[0]);

            // Apply CNOT gate
            CNOT(qubits[0],qubits[1]);
         }
     }
}
</code></pre>

<p>A more detailed version (including measurement) can be found here: <a href=""https://docs.microsoft.com/en-us/quantum/quantum-WriteAQuantumProgram?view=qsharp-preview&amp;tabs=tabid-vs2017"" rel=""noreferrer"">Microsoft: Writing a Quantum Program</a>.</p>
",3/29/2018 7:27,Conceptual,"The question is about understanding and seeking examples of quantum programming, specifically related to creating a Bell state using a simulation or IBM's Quantum Experience processors. The user is looking for guidance in making the conceptual transition from traditional programming to quantum programming, which falls under the ""Conceptual"" category.",Conceptual,,,,Conceptual,
1451.0,How do you write a simple program for a D-Wave device?,"<p>I would like to know how a job for a D-Wave device is written in code and submitted to the device.</p>

<p>In the answer it would be best to see a specific example of this for a simple problem. I guess that the ""Hello World"" of a <a href=""https://en.wikipedia.org/wiki/D-Wave_Systems"" rel=""noreferrer"">D-Wave device</a> would be something like finding the ground states of a <a href=""https://www.triplespark.net/sim/isingmag/"" rel=""noreferrer"">simple 2D Ising model</a>, since this is the kind of problem directly realized by the hardware. So perhaps this would be a nice example to see. But if those with expertise thing an alternative example would be suitable, I'd be happy to see an alternative.</p>
",<d-wave><programming>,3/29/2018 10:43,1483.0,1483.0,"<p>The 'Hello World' equivalent in the D-Wave world is the 2D checkerboard example. In this example, you are given the following square graph with 4 nodes:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src=""https://image.ibb.co/juv4en/2d_checkerboard.png"" alt=""square_graph""></p>

<p>Let's define that we colour vertex $\sigma_{i}$ black if $\sigma_{i} = -1$ and white if $\sigma_{i} = +1$. The goal is to create a checkerboard pattern with the four vertices in the graph. There is various ways of defining
$h$ and $J$ to achieve this result. First of all, there are two possible solutions to this problem:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src=""https://image.ibb.co/fh1AKn/2d_checkerboard_solutions.png"" alt=""checkerboard_solutions""></p>

<p>The D-Wave quantum annealer minimizes the Ising Hamiltonian that we define and
it is important to understand the effect of the different coupler settings. Consider for example the $J_{0,1}$ coupler:</p>

<p>If we set it to $J_{0,1}=-1$, the Hamiltonian is minimized if both qubits take the same value. We say <em>negative couplers correlate</em>. Whereas if we set it to $J_{0,1}=+1$, the Hamiltonian is minimized if the two qubits take opposite values. Thus, <em>positive couplers anti-correlate</em>.</p>

<p>In the checkerboard example, we want to anti-correlate each pair of neighbouring qubits which gives rise to the following Hamiltonian:</p>

<p>$$H = \sigma_{0}\sigma_{1} + \sigma_{0}\sigma_{2} + \sigma_{1}\sigma_{3} + \sigma_{2}\sigma_{3}$$</p>

<p>For the sake of demonstration, we also add a bias term on the $0$-th qubit such that we only get solution #1. This solution requires $\sigma_{0}=-1$ and we therefore set its bias $h_{0}=1$. The final Hamiltonian is now:</p>

<p>$$H = \sigma_{0} + \sigma_{0}\sigma_{1} + \sigma_{0}\sigma_{2} + \sigma_{1}\sigma_{3} + \sigma_{2}\sigma_{3}$$</p>

<p>So let's code it up!</p>

<p>NOTE: You DO NEED access to D-Wave's Cloud Service for anything to work.</p>

<p>First of all, make sure you have the <code>dwave_sapi2</code> (<a href=""https://cloud.dwavesys.com/qubist/downloads/"" rel=""noreferrer"">https://cloud.dwavesys.com/qubist/downloads/</a>) Python package installed. Everything is going to be Python 2.7 since D-Wave currently doesn't support any higher Python version. That being said, let's import the essentials:</p>

<pre><code>from dwave_sapi2.core import solve_ising
from dwave_sapi2.embedding import find_embedding, embed_problem, unembed_answer
from dwave_sapi2.util import get_hardware_adjacency
from dwave_sapi2.remote import RemoteConnection
</code></pre>

<p>In order to connect to the D-Wave Solver API you will need a valid API token for their SAPI solver, the SAPI URL and you need to decide which quantum processor you want to use:</p>

<pre><code>DWAVE_SAPI_URL = 'https://cloud.dwavesys.com/sapi'
DWAVE_TOKEN = [your D-Wave API token]
DWAVE_SOLVER = 'DW_2000Q_VFYC_1'
</code></pre>

<p>I recommend using the D-Wave 2000Q Virtual Full Yield Chimera (VFYC) which is a fully functional chip without any dead qubits! Here's the Chimera chip layout:</p>

<p><img src=""https://preview.ibb.co/iO2szn/vfyc_dwave.png"" alt=""dwave_chimera""></p>

<p>At this point I am splitting the tutorial into two distinct pieces. In the first section, we are manually embedding the problem onto the Chimera hardware graph and in the second section we are using D-Wave's embedding heuristics to find a hardware embedding.</p>

<h1>Manual embedding</h1>

<hr>

<p>The unit cell in the top left corner on the D-Wave 2000Q chip layout above looks like this:</p>

<p><img src=""https://image.ibb.co/bzkvKn/physical_qubits.png"" alt=""physical_qubits""></p>

<p>Note, that not all couplers are visualized in this image. As you can see, there is no coupler between qubit $0$ and qubit $1$ which we would need to directly implement our square graph above. That's why we are now redefining $0\rightarrow0$, $1\rightarrow4$, $2\rightarrow7$ and $3\rightarrow3$. We then go on and define $h$ as a list and $J$ as a dictionary:</p>

<pre><code>J = {(0,4): 1, (4,3): 1, (3,7): 1, (7,0): 1}
h = [-1,0,0,0,0,0,0,0,0]
</code></pre>

<p>$h$ has 8 entries since we use qubits 0 to 7. We now establish connection to the Solver API and request the D-Wave 2000Q VFYC solver:</p>

<pre><code>connection = RemoteConnection(DWAVE_SAPI_URL, DWAVE_TOKEN)
solver = connection.get_solver(DWAVE_SOLVER)
</code></pre>

<p>Now, we can define the number of readouts and choose <code>answer_mode</code> to be ""histogram"" which already sorts the results by the number of occurrences for us. We are now ready to solve the Ising instance with the D-Wave quantum annealer:    </p>

<pre><code>params = {""answer_mode"": 'histogram', ""num_reads"": 10000}
results = solve_ising(solver, h, J, **params)
print results
</code></pre>

<p>You should get the following result:</p>

<pre><code>{
  'timing': {
    'total_real_time': 1655206,
    'anneal_time_per_run': 20,
    'post_processing_overhead_time': 13588,
    'qpu_sampling_time': 1640000,
    'readout_time_per_run': 123,
    'qpu_delay_time_per_sample': 21,
    'qpu_anneal_time_per_sample': 20,
    'total_post_processing_time': 97081,
    'qpu_programming_time': 8748,
    'run_time_chip': 1640000,
    'qpu_access_time': 1655206,
    'qpu_readout_time_per_sample': 123
  },
  'energies': [-5.0],
  'num_occurrences': [10000],
  'solutions': [
      [1, 3, 3, 1, -1, 3, 3, -1, {
          lots of 3 's that I am omitting}]]}
</code></pre>

<p>As you can see we got the correct ground state energy (<code>energies</code>) of $-5.0$. The solution string is full of $3$'s which is the default outcome for unused/unmeasured qubits and if we apply the reverse transformations - $0\rightarrow0$, $4\rightarrow1$, $7\rightarrow2$ and $3\rightarrow3$ - we get the correct solution string $[1, -1, -1, 1]$. Done!</p>

<h1>Heuristic embedding</h1>

<hr>

<p>If you start creating larger and larger Ising instances you will not be able to perform manual embedding. So let's suppose we can't manually embed our 2D checkerboard example. $J$ and $h$ then remain unchanged from our initial definitions:</p>

<pre><code>J = {(0,1): 1, (0,2): 1, (1,3): 1, (2,3): 1}
h = [-1,0,0,0]
</code></pre>

<p>We again establish the remote connection and get the D-Wave 2000Q VFYC solver instance:</p>

<pre><code>connection = RemoteConnection(DWAVE_SAPI_URL, DWAVE_TOKEN)
solver = connection.get_solver(DWAVE_SOLVER)
</code></pre>

<p>In order to find an embedding of our problem, we need to first get the adjacency matrix of the current hardware graph:</p>

<pre><code>adjacency = get_hardware_adjacency(solver)
</code></pre>

<p>Now let's try to find an embedding of our problem:</p>

<pre><code>embedding = find_embedding(J.keys(), adjacency)
</code></pre>

<p>If you are dealing with large Ising instances you might want to search for embeddings in multiple threads (parallelized over multiple CPUs) and then select the embedding with the smallest chain length! A <em>chain</em> is when multiple qubits are forced to act as a single qubit in order to increase the degree of connectivity. However, the longer the chain the more likely that it breaks. And broken chains give bad results!</p>

<p>We are now ready to embed our problem onto the graph:</p>

<pre><code>[h, j0, jc, embeddings] = embed_problem(h, J, embedding, adjacency)
</code></pre>

<p><code>j0</code> contains the original couplings that we defined and <code>jc</code> contains the couplings that enforce the integrity of the chains (they correlate the qubits within the chains). Thus, we need to combine them again into one big $J$ dictionary:</p>

<pre><code>J = j0.copy()
J.update(jc)
</code></pre>

<p>Now, we're ready to solve the embedded problem:</p>

<pre><code>params = {""answer_mode"": 'histogram', ""num_reads"": 10000}
raw_results = solve_ising(solver, h, J, **params)

print 'Lowest energy found: {}'.format(raw_results['energies'])
print 'Number of occurences: {}'.format(raw_results['num_occurrences'])
</code></pre>

<p>The <code>raw_results</code> will not make sense to us unless we unembed the problem. In case, some chains broke we are fixing them through a majority vote as defined by the optional argument <code>broken_chains</code>:    </p>

<pre><code>unembedded_results = unembed_answer(raw_results['solutions'],
                                    embedding, broken_chains='vote')

print 'Solution string: {}'.format(unembedded_results)
</code></pre>

<p>If you run this, you should get the correct result in all readouts:</p>

<pre><code>Lowest energy found: [-5.0]
Number of occurences: [10000]
Solution string: [[1, -1, -1, 1]]
</code></pre>

<p>I hope this answered your question and I highly recommend checking out all the additional parameters that you can pass to the <code>solve_ising</code> function to improve the quality of your solutions such as <code>num_spin_reversal_transforms</code> or <code>postprocess</code>.</p>
",3/29/2018 23:09,Tooling,"The question is asking about how to use the D-Wave Ocean software suite to submit a job to a D-Wave device. The D-Wave Ocean software suite is a tool that can be used to write, compile, and run quantum programs on D-Wave devices. So, the question is about how to use a specific tool in quantum programming to achieve a specific goal.",Tooling,,,,Tooling,
1474.0,What programming languages are available for quantum computers?,"<p>From this question, I gathered that the main quantum computing programming languages are <a href=""https://www.microsoft.com/en-us/quantum/development-kit"" rel=""noreferrer"">Q#</a> and <a href=""https://quantumexperience.ng.bluemix.net/qx/experience"" rel=""noreferrer"">QISKit</a>.</p>

<p>What other programming languages are available for programming quantum computers? Are there certain benefits to choosing particular ones?</p>

<p>EDIT: I am looking for programming languages, not emulators. Emulators simulate things. Programming languages are a method of writing instructions (either for real objects or for emulators). There may be a single language that works for multiple emulators and vice versa.</p>
",<programming>,3/29/2018 19:39,1524.0,1524.0,"<p><a href=""https://en.wikipedia.org/wiki/Quantum_programming"" rel=""noreferrer"">Wikipedia list of Quantum Computer programming languages</a> </p>

<p>(This answer is not a copy of that webpage, it's more updated and with verified links. In some cases the author's paper or website link is added.)</p>

<ul>
<li><p><strong><a href=""https://en.wikipedia.org/wiki/Quantum_programming#Quantum_instruction_sets"" rel=""noreferrer"">Quantum instruction sets</a></strong></p>

<ul>
<li><p><a href=""https://en.wikipedia.org/wiki/Quil_(instruction_set_architecture)"" rel=""noreferrer"">Quil</a> - An instruction set architecture for quantum computing that first introduced a shared quantum/classical memory model. See also <a href=""https://github.com/rigetticomputing/pyquil/blob/master/README.md"" rel=""noreferrer"">PyQuil</a>.</p></li>
<li><p><a href=""https://en.wikipedia.org/wiki/OpenQASM"" rel=""noreferrer"">OpenQASM</a> - The intermediate representation introduced by IBM for use with their <a href=""https://en.wikipedia.org/wiki/IBM_Quantum_Experience"" rel=""noreferrer"">Quantum Experience</a>.</p></li>
</ul></li>
<li><p><strong><a href=""https://en.wikipedia.org/wiki/Quantum_programming#Quantum_programming_languages"" rel=""noreferrer"">Quantum programming languages</a></strong></p>

<p><strong>Imperative languages</strong></p>

<ul>
<li><p><strong><a href=""https://en.wikipedia.org/wiki/Quantum_computation_language"" rel=""noreferrer"">QCL</a></strong> - One of the first implemented quantum programming languages.</p></li>
<li><p><strong>Quantum pseudocode</strong> - [Not actually a language, but a nice way to represent quantum algorithms and operations.] E. H. Knill. ""Conventions for Quantum Pseudocode"", unpublished, LANL report LAUR-96-2724 (PDF Source <a href=""https://pdfs.semanticscholar.org/60d1/e63ca31555ec7013c5eb9a8a63788398fd14.pdf"" rel=""noreferrer"">1</a>, <a href=""https://digital.library.unt.edu/ark:/67531/metadc687305/"" rel=""noreferrer"">2</a>), Search at <a href=""http://search.arxiv.org:8081/?query=%22Conventions%20for%20Quantum%20Pseudocode%22&amp;qid=1522470379946swap_nCnN_-1580011369&amp;byDate=1"" rel=""noreferrer"">arXiv</a> for all papers referencing Knill's paper.</p></li>
<li><p><strong>Q|SI></strong> - Original paper in <a href=""http://engine.scichina.com/publisher/scp/journal/SSI/47/10/10.1360/N112017-00095?slug=full%20text"" rel=""noreferrer"">Chinese</a> with English abstract. English version at arXiv: ""<a href=""https://arxiv.org/abs/1710.09500"" rel=""noreferrer"">Q|SI>: A Quantum Programming Environment</a>"".</p></li>
<li><p><strong><a href=""https://en.wikipedia.org/wiki/Quantum_programming#Q_language"" rel=""noreferrer"">Q language</a></strong> - <a href=""https://web.archive.org/web/20090620011647/http://sra.itc.it/people/serafini/qlang/"" rel=""noreferrer"">Software for the Q language</a>.</p></li>
<li><p><strong>qGCL</strong> - ""<a href=""https://arxiv.org/abs/1402.5172"" rel=""noreferrer"">Alternation in Quantum Programming: From Superposition of Data to Superposition of Programs</a>"".</p></li>
<li><p><strong><a href=""https://github.com/lanl/qmasm"" rel=""noreferrer"">QMASM</a></strong> - Specific to D-Wave systems. <a href=""https://github.com/lanl/qmasm/wiki"" rel=""noreferrer"">QMASM Documentation</a>. Author Scott Pakin's <a href=""https://ccsweb.lanl.gov/~pakin/software/"" rel=""noreferrer"">edif2qmasm and QMASM</a> webpage at LANL.</p></li>
</ul></li>
<li><p>&nbsp;</p>

<p><strong>Functional languages</strong></p>

<ul>
<li><p><strong>QFC and QPL</strong> - <a href=""https://www.mscs.dal.ca/~selinger/papers.html"" rel=""noreferrer"">Author's website</a>.</p></li>
<li><p><strong>QML</strong> - Main site: <a href=""http://sneezy.cs.nott.ac.uk/QML/"" rel=""noreferrer"">http://sneezy.cs.nott.ac.uk/QML/</a> (not responding, a month later), <a href=""https://web.archive.org/web/20070926230222/http://sneezy.cs.nott.ac.uk/QML/"" rel=""noreferrer"">Archive.Org copy of sneezy.cs.nott.ac.uk</a>, author's PhD thesis: ""<a href=""http://eprints.nottingham.ac.uk/10250/1/thesis.pdf"" rel=""noreferrer"">A functional quantum programming language</a>"" (PDF).</p></li>
<li><p><strong><a href=""https://stationq.github.io/Liquid/"" rel=""noreferrer"">LIQUi|></a></strong> - Extension to F# (F Sharp).</p></li>
<li><p><strong>Quantum lambda calculi</strong> - Wikipedia <a href=""https://en.wikipedia.org/wiki/Quantum_programming#Quantum_lambda_calculi"" rel=""noreferrer"">lists a few versions</a>.</p></li>
<li><p><strong><a href=""https://www.mathstat.dal.ca/~selinger/quipper/"" rel=""noreferrer"">Quipper</a></strong> - A Haskell based scalable functional programming language for quantum computing. See also <a href=""https://arxiv.org/abs/1706.02630"" rel=""noreferrer"">Proto-Quipper</a>. A Talk by Peter Selinger (FSCD 2018) titled ""<a href=""http://drops.dagstuhl.de/opus/volltexte/2018/9173/"" rel=""noreferrer"">Challenges in Quantum Programming Languages</a>"" (<a href=""http://drops.dagstuhl.de/opus/volltexte/2018/9173/pdf/LIPIcs-FSCD-2018-3.pdf"" rel=""noreferrer"">.PDF</a>) discusses these languages.</p></li>
</ul></li>
<li><p>&nbsp;</p>

<p><strong>Multi-Paradigm languages</strong></p>

<ul>
<li><p><strong><a href=""https://docs.microsoft.com/en-us/quantum/quantum-qr-intro?view=qsharp-preview"" rel=""noreferrer"">Q# (Q Sharp)</a></strong> - A domain-specific programming language used for expressing quantum algorithms. It was initially released to the public by Microsoft as part of the Quantum Development Kit. Also available are Microsoft <a href=""https://cloudblogs.microsoft.com/quantum/2018/07/23/learn-at-your-own-pace-with-microsoft-quantum-katas/"" rel=""noreferrer"">Quantum Katas</a>, a series of self-paced tutorials aimed at teaching elements of quantum computing and Q# programming at the same time.</p></li>
<li><p><a href=""https://github.com/XanaduAI/strawberryfields/blob/master/README.rst"" rel=""noreferrer"">Strawberry Fields</a> (from <a href=""https://www.xanadu.ai/tag/quantum-computing/"" rel=""noreferrer"">XanduAI</a>) is a full-stack Python library for designing, simulating, and optimizing continuous variable quantum optical circuits.</p></li>
</ul></li>
</ul>

<p>The website <a href=""https://quantumcomputingreport.com/resources/tools/"" rel=""noreferrer"">Quantum Computing Report has a Tools webpage</a> listing over a dozen links, some new and some repeating the above list.</p>

<p>See also QuanTiki's webpage: ""<a href=""https://www.quantiki.org/wiki/list-qc-simulators"" rel=""noreferrer"">List of QC simulators</a>"", for a huge list of simulators and programming languages based on: C/C++, CaML, OCaml, F#, along with GUI based, Java, JavaScript, Julia, Maple, Mathematica, Maxima, Matlab/Octave, .NET, Perl/PHP, Python, Scheme/Haskell/LISP/ML and other online services providing calculators, compilers, simulators, and toolkits, etc.</p>

<blockquote>
  <p>Are there certain benefits to choosing particular ones?</p>
</blockquote>

<p>If you plan on using a particular quantum computer then one would hope that the programming language developed by the manufacturer is both best suited for that particular machine and well supported.</p>

<p>Choosing a language with a larger following means that there are more Forums available and hopefully more bug fixes and support.</p>

<p>Unfortunately, that leaves some great niche products to struggle to gain a user base. Trying to find one language that is both powerful/expressive and supported across various platforms is the trick, the answer is an opinion ATM.</p>

<p>An evaluation of four software platforms: Forest (pyQuil), QISKit, ProjectQ, and the Quantum Developer Kit is offered by Ryan LaRose in ""<a href=""https://arxiv.org/abs/1807.02500"" rel=""noreferrer"">Overview and Comparison of Gate Level Quantum Software Platforms</a>"" (6 Jul 2018).</p>

<hr>

<p>Updates:</p>

<p>Google's Cirq and OpenFermion-Cirq: ""<a href=""https://ai.googleblog.com/2018/07/announcing-cirq-open-source-framework.html"" rel=""noreferrer"">Google's AI Blog - Announcing Cirq: An Open Source Framework for NISQ Algorithms</a>"".</p>

<p>D-Wave's <a href=""https://www.nextplatform.com/2018/10/04/full-qubit-and-tooling-access-a-game-changer-for-quantum-development/"" rel=""noreferrer"">Leap and Ocean SDK</a> allows access to a <a href=""https://www.dwavesys.com/d-wave-two-system"" rel=""noreferrer"">D-Wave 2000Qâ¢ System</a> in a cloud environment with access to a 2000+ qubit quantum annealing machine to test and run workloads for free, assuming the core algorithms used go into the open source pool. Apply to login at D-Wave's <a href=""https://cloud.dwavesys.com/leap/login/?next=/leap/"" rel=""noreferrer"">Leap In</a> webpage.</p>

<p>Rigetti Computing's <a href=""https://www.rigetti.com/qcs"" rel=""noreferrer"">Quantum Cloud Service</a> (QCS) offers a Quantum Machine Image, a virtualized programming, and execution environment that is pre-configured with Forest 2.0, to access up to 16 qubits of a 128 qubit computer.</p>

<p>Stay tuned for information on Fujitsu's <a href=""http://www.fujitsu.com/global/about/resources/news/press-releases/2016/1020-02.html"" rel=""noreferrer"">Digital Annealer</a>, an architecture capable of performing computations some 10,000 times faster than a conventional computer. <strong>If</strong> they eventually provide a development environment that is cross-compatible with <em>true</em> quantum computers these two paragraphs will remain in this answer, otherwise I will remove them.</p>

<p>While their silicon chip is not quantum in nature Fujitsu has partnered with <a href=""https://1qbit.com/"" rel=""noreferrer"">1Qbit</a> to develop what is described as a ""<a href=""https://1qbit.com/news/fujitsu-1qbit-quantum-inspired-ai-cloud-service/"" rel=""noreferrer"">Quantum Inspired AI Cloud Service</a>"", whether their <a href=""http://www.fujitsu.com/global/digitalannealer/"" rel=""noreferrer"">Digital Annealer</a> quacks like a duck (anneals like a D-Wave, <strong>and</strong> uses compatible code) remains to be seen. Visit here to access the <a href=""http://www.fujitsu.com/global/digitalannealer/services/"" rel=""noreferrer"">Fujitsu Digital Annealer Technical Service</a>.</p>

<p>University of Pennsylvania's <a href=""http://www.cis.upenn.edu/~rrand/"" rel=""noreferrer"">QWIRE</a> (<em>choir</em>) is a quantum circuit language and formal verification tool, it has a <a href=""https://github.com/inQWIRE/QWIRE"" rel=""noreferrer"">GitHub webpage</a>.</p>

<p>A review of: Cirq, Cliffords.jl, dimod, dwave-system, FermiLib, Forest (pyQuil &amp; Grove), OpenFermion, ProjectQ, PyZX, QGL.jl, Qbsolv, Qiskit Terra and Aqua, Qiskit Tutorials, and Qiskit.js, Qrack, Quantum Fog, Quantum++, Qubiter, Quirk, reference-qvm, ScaffCC, Strawberry Fields, XACC, and finally XACC VQE is offered in the paper: ""<a href=""https://arxiv.org/abs/1812.09167"" rel=""noreferrer"">Open source software in quantum computing</a>"" (Dec 21 2018), by Mark Fingerhuth, TomÃ¡Å¡ Babej, and Peter Wittek.</p>

<p>I will return to this answer from time to time to make updates, without excessive <a href=""https://www.webopedia.com/TERM/T/thread_bump.html"" rel=""noreferrer"">bumping</a>.</p>
",3/31/2018 6:47,Learning,"The user is asking about the available programming languages for quantum computers and their benefits, which involves acquiring knowledge about quantum computing and quantum programming languages",Learning,,,,Learning,
1487.0,What impact would have introducing the quantum switch effect in classical computing?,"<p><a href=""https://physicstoday.scitation.org/action/showDoPubSecure?doi=10.1063%2FPT.6.1.20180328a&amp;format=full"" rel=""nofollow noreferrer"">This divulgation article</a> by Prof. Brukner talks about the possibility of creating a situation where</p>

<blockquote>
  <p>""A causing B"" and ""B causing A"" which we call a <strong>quantum switch</strong>. Such a setup is similar to some predatorâprey relationships, in which predator numbers influence prey numbers, yet prey numbers also influence predator numbers. Following <a href=""https://www.nature.com/articles/ncomms2076"" rel=""nofollow noreferrer"">work</a> that Ognyan Oreshkov, Fabio Costa, and I published in 2012, we now know that the quantum switch is just one example of an indefinite causal structure, in which it is not defined whether event A is a cause or an effect of event B, or whether the two are independent.</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/julZN.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/julZN.jpg"" alt=""enter image description here""></a></p>

<p>The work link leads to a paper that explains with great detail how to achieve that, and it also includes some applications, like to <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.040301"" rel=""nofollow noreferrer"">prove that two no-signalling channels that are not perfectly distinguishable in any ordinary quantum circuit can become perfectly distinguishable through the quantum superposition of circuits with different causal structures</a></p>

<p>I am a regular programmer without a background in quantum computing and don't quite understand the implications of such articles. What I get, and find very exciting is the possibility of having such expanded causality models as a tool. <strong>My question is: how/where could quantum switch fit in the classical computing landscape?</strong> Be it low-level hardware design or the (surely upcoming) <code>else-then-if</code> software pattern </p>
",<classical-computing>,3/30/2018 4:46,1498.0,1498.0,"<p>The answer depends on what exactly you mean by ""<em>fit</em>"", but, generally speaking, there do not seem to be direct applications of indefinite causal structures for classical computing.</p>

<p>Indeed, the interest of techniques like the quantum switch$^\dagger$ (aside from the purely fundamental aspects) is that they provide methods to create non-classical correlations, and more generally encoding quantum information (e.g. qubits) into ""causal"" degrees of freedoms, as nicely shown in Figure 1 <a href=""http://advances.sciencemag.org/content/advances/3/3/e1602589.full.pdf"" rel=""nofollow noreferrer"">here</a>.</p>

<p>In other words, one could imagine a quantum computer in which the qubits are encoded into (a)causal structures.
However, apart from the notable impracticality of storing and maintaining many qubits encoded in such a way, it is also not known how one could apply operations between them.
Interestingly, in at least some limited form, this is possible, as recently demonstrated in <a href=""https://arxiv.org/abs/1712.06884"" rel=""nofollow noreferrer"">1712.06884</a>, where two different such qubits were entangled, and the associated Bell violations observed.
It is not known if or how one could scale such experiments to more qubits.</p>

<hr>

<p>$^\dagger$ It is worth mentioning that there have also been at least two (to my knowledge) experimental demonstrations of indefinite causal orders: <a href=""https://arxiv.org/abs/1608.01683"" rel=""nofollow noreferrer"">1608.01683</a> and <a href=""https://arxiv.org/abs/1712.06884"" rel=""nofollow noreferrer"">1712.06884</a>.</p>
",3/30/2018 8:16,Conceptual,"The reason for the category is that the question is asking about how quantum switches could change the way we think about causality and determinism in classical computing. Quantum switches are devices that can create indefinite causal structures, in which it is not possible to say definitively whether event A is the cause of event B or vice versa. This could have a profound impact on the way we design and implement classical algorithms.", Conceptual,,,,Conceptual,
1489.0,How does the Curry-Howard correspondence apply to quantum programs?,"<p>In words of <a href=""https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"" rel=""noreferrer"">Wikipedia</a>, </p>

<blockquote>
  <p>The CurryâHoward correspondence is the observation that two families of seemingly unrelated formalismsânamely, the proof systems on one hand, and the models of computation on the otherâare in fact the same kind of mathematical objects [...] <em>a proof is a program, and the formula it proves is the type for the program</em>.</p>
</blockquote>

<p>Further, under <a href=""https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#General_formulation"" rel=""noreferrer"">General Formulation</a>, it provides the following table and the statement that bears my question:</p>

<p><a href=""https://i.stack.imgur.com/d0XKD.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/d0XKD.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>In its more general formulation, the CurryâHoward correspondence is a correspondence between formal proof calculi and type systems for models of computation. In particular, it splits into two correspondences. One at the level of formulas and types that is independent of which particular proof system or model of computation is considered, and one at the level of proofs and programs which, this time, <strong>is specific to the particular choice of proof system and model of computation considered</strong>.</p>
</blockquote>

<p>Is quantum computing in this hindsight equivalent to classical computing, or is it a different ""model of computation"" (i.e. does it have a different set of elements in the <em>Programming side</em>)?  Would it still correspond to the exact same <em>Logic side</em>?</p>
",<classical-computing><programming>,3/30/2018 5:14,1506.0,1506.0,"<p>Quantum computing doesn't change the Curry-Howard isomorphism, for the following reasons:</p>

<ol>
<li><p>Quantum computers can simulate Turing machines and vice versa. These devices can be faster at certain tasks, but the computable languages remain the same. </p></li>
<li><p>There is, a priori, no reason we cannot apply the model of the Turing machine of Lambda calculus to quantum computers, <em>even if they can compute different, mutually exclusive languages</em>!</p></li>
<li><p>For practical purposes, I very much doubt quantum computing will be of use in automated theorem proving or proof assistance (by computers).</p></li>
</ol>

<p>So, as for your question, yes in the context of Curry-Howard, we can consider a quantum computer and a classical machine equivalent, as it is likely we wish to model both with the Lambda calculus for the purpose of the isomorphism.</p>
",3/30/2018 10:35,Conceptual,"the question is asking about whether quantum computing is fundamentally different from classical computing. Quantum computing is based on the principles of quantum mechanics, which are different from the principles of classical physics. This could lead to different programming models and different types of algorithms.",Conceptual,,,,Conceptual,
1508.0,"In a Quantum Turing Machine, how is the decision to move along the memory tape made?","<p>Let, for a Quantum Turing machine (QTM), the state set be $Q$, and the alphabet of symbols be $\sum=\{0,1\}$, which appear at the tape head. Then, as per my understanding, at any given time while the QTM is calculating, the qubit that appears at its head will hold an arbitrary vector $V_\sum = a|1\rangle+b|0\rangle$. Also, if $|q_0\rangle , |q_1\rangle, ... \in Q$, then the state vector at that instance will also be an arbitrary vector $V_q=b_0|q_0\rangle + b_1 |q_1\rangle+ ...$.</p>

<p>Now, after the instruction cycle is complete, the vectors $V_\sum$ and $V_q$ will decide whether the QTM will move left or right along the Qubit tape. My question is- since Hilbert space formed by $Q \otimes \sum$ is an uncountable infinite set and $\{\text{Left,Right}\}$ is a discrete set, the mapping between them will be difficult to create.</p>

<p>So how is the decision to move left or right made? Does the QTM move both left and right at the same time, meaning that the set $\{\text{Left,Right}\}$ also forms a different Hilbert space, and hence the motion of the QTM becomes something like $a|\text{Left}\rangle+b|\text{Right}\rangle$.</p>

<p>Or, just like a Classical Turing machine, the QTM moves either left or right, but not both at the same time?</p>
",<classical-computing><computational-models><quantum-turing-machine>,3/30/2018 11:30,1592.0,1592.0,"<p>If we have a QTM with state set $Q$ and a tape alphabet $\Sigma = \{0,1\}$, we cannot say that the qubit being scanned by the tape head ""holds"" a vector $a|0\rangle + b|1\rangle$ or that the (internal) state is a vector with basis states corresponding to $Q$. The qubits on the tape can be correlated with one another and with the internal state, as well as with the tape head position.</p>

<p>As an analogy, we would not describe a probabilistic Turing machine's global state by independently specifying a distribution for the internal state and for each of the tape squares. Rather, we have to describe everything together so as to properly represent correlations among the different parts of the machine. For example, the bits stored in two distant tape squares might be perfectly correlated, both 0 with probability 1/2 and both 1 with probability 1/2.</p>

<p>So, in the quantum case, and assuming we're talking about pure states of quantum Turing machines with unitary evolutions (as opposed to a more general model based on mixed states), the global state is represented by a vector whose entries are indexed by configurations (i.e., classical descriptions of the internal state, the location of the tape head, and the contents of every tape square) of the Turing machine. It should be noted that we generally assume that there is a special blank symbol in the tape alphabet (which could be 0 if we want our tape squares to store qubits) and that we start computations with at most finitely many squares being non-blank, so that the set of all reachable configurations is countable. This means that the state will be represented by a unit vector in a separable Hilbert space.</p>

<p>Finally, and perhaps this is the actual answer to the question interpreted literally, the movement of the tape head is determined by the transition function, which will assign an ""amplitude"" to each possible action (new state, new symbol, and tape head movement) for every classical pair $(q,\sigma)$ representing the current state and currently scanned symbol. Nothing forces the tape head to move deterministically -- a nonzero amplitude could be assigned to two or more actions that include tape head movements to both the left and right -- so it is possible for a QTM tape head to move both left and right in superposition.</p>

<p>For example, you can imagine a QTM with $Q = \{0,1\}$ and $\Sigma = \{0,1\}$ (and we'll take 0 to be the blank symbol). We start in state 0 scanning a square that stores 1, and all other squares store 0. I won't explicitly write down the transition function, but will just describe the behavior in words. On each move, the contents of the scanned tape square is interpreted as a control bit for a Hadamard operation on the internal state. After the controlled-Hadamard is performed, the head moves left if the (new) state is 0 and moves right if the (new) state is 1. (In this example we never actually change the contents of the tape.) After one step, the QTM will be in an equally weighted superposition between being in state 0 with the tape head scanning square -1, and being in state 1 with the tape head scanning square +1. On all subsequent moves the controlled-Hadamard does nothing because every square aside from square 0 contains the 0 symbol. The tape head will therefore continue to move simultaneously both left and right, like a particle travelling to the left and to the right in superposition.</p>

<p>If you wanted to, you could of course define a variant of the quantum Turing machine model for which the tape head location and movement is deterministic, and this would not ruin the computational universality of the model, but the ""classic"" definition of quantum Turing machines does not impose this restriction.</p>
",04/04/2018 14:43,Theoretical,"the user is asking about the theoretical aspects of a Quantum Turing machine (QTM), specifically about how the decision to move left or right is made and how it relates to the uncountable infinite Hilbert space formed by the state set and the alphabet of symbols. The question explores the behavior of QTMs and their possible movements, which falls within the theoretical understanding of quantum computing concepts.",Theoretical,,,,Theoretical,
1558.0,Assessing speed-up via Quantum-Stochastic correspondence,"<p>You can make a natural correspondence between a quantum state vector and a classical <a href=""https://en.wikipedia.org/wiki/Probability_vector"" rel=""noreferrer"">probability vector</a>, and between a quantum unitary operator and a classical <a href=""https://en.wikipedia.org/wiki/Stochastic_matrix"" rel=""noreferrer"">stochastic matrix</a>. There is also a correspondence between the quantum annealing algorithm and the classical simulated annealing algorithm. I am wondering whether it is possible to write down simulated annealing in the language of probability vectors and stochastic matrices, and then see what additional power is obtained by changing to the quantum counterparts.</p>

<p>More generally, I would like to bridge the language gaps between probabilistic algorithms and quantum algorithms, and I am wondering whether recasting probabilistic algorithms in terms of probability vectors and stochastic matrices has been tried before.</p>
",<algorithm><speedup><annealing><classical-computing>,04/01/2018 21:25,1559.0,1559.0,"<p>Yes. This has been done by Morita and Nishimori in their 2008 publication, ""Mathematical Foundations of Quantum Annealing."" </p>

<p><a href=""https://arxiv.org/abs/0806.1859"" rel=""nofollow noreferrer"">https://arxiv.org/abs/0806.1859</a></p>

<p>In Section 5 they derive the convergence conditions from path integral Monte Carlo and Green function Monte Carlo methods. To quote;</p>

<blockquote>
  <p>In Sec. 5 we have derived the convergence condition of QA implemented by Quantum Monte Carlo simulations of path-integral and Green function methods. These approaches bear important practical significance because only stochastic methods allow us to treat practical large-size problems on the classical computer. A highly non-trivial result in this section is that the convergence condition for the stochastic methods is essentially the same power-law decrease of the transverse-field term as in the SchrÃ¶dinger dynamics of Sec. 2. This is surprising since the Monte Carlo (stochastic) dynamics is completely different from the SchrÃ¶dinger dynamics. Something deep may lie behind this coincidence and it should be an interesting target of future studies.</p>
</blockquote>
",04/01/2018 23:59,Conceptual,"the question is asking about how the two different types of algorithms can be represented in the same mathematical language. This could help us to better understand the similarities and differences between these two types of algorithms, and to develop new algorithms that take advantage of the strengths of both.",Conceptual,,,,Conceptual,
1678.0,"A sample quantum algorithm, useful for demonstrating languages","<p>I'm looking for a quantum algorithm which I can use to demonstrate the syntax of different quantum-languages. My question is similar to <a href=""https://physics.stackexchange.com/questions/3390/can-anybody-provide-a-simple-example-of-a-quantum-computer-algorithm"">this</a>, however, for me, ""good"" means:</p>

<ul>
<li>What it does could be described in 1-2 paragraphs, and should be easy to understand.</li>
<li>Should use more elements of the ""quantum-programming-world"" (I mean that the algorithm should use some classical constants, measurements, conditions, qregisters, operators etc., as many as possible).</li>
<li>The algorithm should be small (at most 15-25 pseudocode-lines long).</li>
</ul>

<p>Useful algorithms are often too long/hard, but <a href=""https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm"" rel=""noreferrer"">Deutsch's algorithm</a> doesn't use that many elements. Can someone suggest me a good-for-demo algorithm?</p>
",<algorithm><resource-request><programming>,04/11/2018 10:30,1681.0,1681.0,"<p>I suggest looking at eigenvalue/eigenvector estimating protocols. There's a lot of flexibility to make the problem as easy or as hard as you want.</p>

<p>Start by picking two parameters, $n$ and $k$. You want to design an $n$-qubit unitary, $U$ that has eigenvalues of the form $e^{-2\pi iq/2^k}$ for integers $q$. Make sure that at least one of those eigenvalues is unique, and call it $\omega$. Also make sure that a simple product state, say $|0\rangle^{\otimes n}$, has non-zero overlap with the eigenvector of eigenvalue $\omega$.</p>

<p>The aim would be to implement a phase estimation algorithm on this, being told the value $k$, and being tasked with outputting a vector $|\psi\rangle$ that is the eigenvector corresponding to eigenvalue $\omega$. In general this will comprise a circuit of $n+k$ qubits (unless you need ancillas to implement controlled-$U$).</p>

<p>This works as follows:</p>

<blockquote>
  <ul>
  <li><p>set up two registers, one of $k$ qubits, and the other of $n$ qubits. (<strong>use of quantum registers</strong>)</p></li>
  <li><p>every qubit is initialized in the state $|0\rangle$. (<strong>initialisation of quantum registers</strong>)</p></li>
  <li><p>apply a Hadamard to each qubit in the first register (<strong>single-qubit gates</strong>)</p></li>
  <li><p>from qubit $r$ in the first register, apply controlled-$U^{2^{r}}$, targeting the second register (<strong>multi-qubit controlled gates</strong>)</p></li>
  <li><p>apply the inverse Fourier transform on the first register, and measure every qubit of the first register in the standard basis. These can be combined, implementing the <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.76.3228"" rel=""nofollow noreferrer"">semi-classical Fourier transform</a>. (<strong>measurement</strong> and <strong>feed-forward of classical data</strong>)</p></li>
  <li><p>for the correct measurement result, the second register is in the desired state $|\psi\rangle$.</p></li>
  </ul>
</blockquote>

<p>For simplicity, you could pick $n=2$, $k=1$, so you need a $4\times 4$ unitary matrix with eigenvalues $\pm 1$. I'd use something like $$(U_1\otimes U_2)C(U_1^\dagger\otimes U_2^\dagger),$$
where $C$ denotes the controlled-NOT. There is just one eigenvector with eigenvalue -1, which is $|\psi\rangle=(U_1\otimes U_2)|1\rangle\otimes(|0\rangle-|1\rangle)/\sqrt{2}$, and you can mess about with the choices of $U_1$ and $U_2$ to explore the implementation of $U$ using decomposition in terms of a universal gate set (I'd probably set this as a preliminary problem). Then, controlled-$U$ is easily implemented just by replacing the controlled-NOT with a controlled-controlled-NOT (Toffoli) gate. Finally, the inverse Fourier transform is just a Hadamard gate.</p>

<p>For something a little more complex, put $k=3$, and replace $C$ with the square-root of swap gate,
$$
\left(
\begin{array}{cccc}
 1 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{i}{\sqrt{2}} &amp; 0 \\
 0 &amp; \frac{i}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{array}
\right)
$$
with $\omega=e^{\pm i\pi/4}$ and $|\psi\rangle=(U_1\otimes U_2)(|01\rangle\pm|10\rangle)/\sqrt{2}$.</p>
",04/11/2018 13:03, Learning,"the question is asking for a resource that can help the user understand the syntax of quantum languages. This is a fundamental concept in quantum computing, and it is important for anyone who wants to learn about quantum algorithms",Learning,,,, Learning,
1803.0,Does Moore's law apply to quantum computing?,"<p>Plain and simple. Does <a href=""https://en.wikipedia.org/wiki/Moore&#39;s_law"" rel=""noreferrer"">Moore's law</a> apply to quantum computing, or is it similar but with the numbers adjusted (ex. triples every 2 years). Also, if Moore's law doesn't apply, why do qubits change it?</p>
",<classical-computing><history><scalability>,4/17/2018 2:37,1805.0,1805.0,"<p>If you take as definition ""<em>the number of transistors in a dense integrated circuit doubles about every two years</em>"", it definitely does not apply: as answered here in <a href=""https://quantumcomputing.stackexchange.com/questions/1696/do-the-fundamental-circuit-elements-have-a-correspondence-in-quantum-technolog"">Do the 'fundamental circuit elements' have a correspondence in quantum technologies?</a> there exist no transistors-as-fundamental-components (nor do exist fundamental-parallel-to-transistors) in a quantum computer.</p>

<p>If you take a more general definition ""<em>chip performance doubles aproximately every 18 months</em>"", the question makes more sense, and the answer is still that <strong>it does not apply</strong>, mainly because Moore's law is not one of fundamental Physics. Rather, in the early stages, it was an observation of a stablished industry. Later, as pointed out in a comment,[1] it has been described as functioning as an ""<em>evolving target</em>"" and as a ""<em>self-fulfilling prophecy</em>"" for that same industry. </p>

<p>The key is that <strong>we do not have a stablished industry producing quantum computers.</strong> We are not in the quantum equivalent from 1965. Arguably we will move faster, but in many aspects we are rather in the XVII-XVIII centuries. For a perspective, check this <a href=""https://en.wikipedia.org/wiki/Timeline_of_computing_hardware_before_1950"" rel=""noreferrer"">timeline of computing hardware before 1950</a>.</p>

<p>For a more productive answer, there are a few fundamental differences and a few possible parallels between classical and quantum hardware, in the context of Moore's law:</p>

<ul>
<li>For many architectures, in a certain sense we already work with the smallest possible component. While we might develop ion traps (of a fixed size) fitting more ions, but we cannot develop smaller ions: they are of atomic size.</li>
<li>Even when we are able to come up with tricks, such as <a href=""https://arxiv.org/abs/1610.03994"" rel=""noreferrer"">Three addressable spin qubits in a molecular single-ion magnet</a>, they are still fundamentally limited by quantum mechanics. We need control over 8 energy levels to control 3 qubits ($2^n$), which is doable, but not scalable.</li>
<li>Precisely because the scalability issue is one of the hardest problem we have with quantum computers -not just having a larger number of qubits, buy also being able to entangle them- it's dangerous to extrapolate from current progress. See for illustration the history of <a href=""https://en.wikipedia.org/wiki/Nuclear_magnetic_resonance_quantum_computer"" rel=""noreferrer"">NMR quantum computers</a>, which stalled after a very early string of successes. In theory, increasing the number of qubits in the device was trivial. In practice, every time you want to be able to control 1 more qubit you need to double the resolution of your machine, which becomes very unfeasible very quickly.</li>
<li>If and when there exists an industry that relies on an evolving technology which is able to produce some kind of integrated quantum chips, then yes, at that point we will be able to draw a real parallel to Moore's law. For a taste of how far we are from that point, see <a href=""https://quantumcomputing.stackexchange.com/questions/2017/are-there-any-estimates-on-how-complexity-of-quantum-engineering-scales-with-siz"">Are there any estimates on how complexity of quantum engineering scales with size?</a></li>
</ul>

<p>[1] <em>Thanks to Sebastian Mach for that insight and <a href=""https://en.wikipedia.org/wiki/Moore&#39;s_law#As_an_evolving_target_for_industry"" rel=""noreferrer"">wikipedia link</a>. For more details on that see <a href=""https://books.google.es/books?id=1khslZ-jbgEC&amp;pg=PA206&amp;redir_esc=y#v=onepage&amp;q&amp;f=false"" rel=""noreferrer"">Getting New Technologies Together: Studies in Making Sociotechnical Order
edited by Cornelis Disco, Barend van der Meulen, p. 206</a> and <a href=""https://www.theinquirer.net/inquirer/news/1014782/gordon-moore-aloha-moore-law"" rel=""noreferrer"">Gordon Moore says aloha to Moore's Law</a>.</em></p>
",4/17/2018 6:24,Conceptual,The question is asking about the applicability of Moore's law to quantum computing and whether qubits change its effects. The explanation would involve understanding the differences between classical and quantum computing architectures and their scaling properties.,Theoretical,"The user is inquiring about the applicability of Moore's Law to quantum computing and the factors that may influence it, which involves understanding the theoretical aspects and principles of quantum computing in relation to classical computing concepts like Moore's Law.",No,67.0,Theoretical,"It involves understanding the theoretical aspects and principles of quantum computing in relation to classical computing concepts like Moore's Law, which aligns with the user's inquiry about the factors influencing Moore's Law in the context of quantum computing."
1918.0,Does a complete list of open quantum software projects exist?,"<p>An answer to 
<a href=""https://quantumcomputing.stackexchange.com/questions/1478/is-there-any-source-which-tabulates-quantum-computing-algorithms-for-simulating"">Is there any source which tabulates quantum computing algorithms for simulating physical systems?</a> mentions the <a href=""https://math.nist.gov/quantum/zoo/"" rel=""noreferrer"">Quantum Algorithm Zoo</a>, a list of quantum algorithms. Several answers to <a href=""https://quantumcomputing.stackexchange.com/questions/1367/programming-quantum-computers-for-non-physics-majors"">Programming quantum computers for non-physics majors</a> include links to different kinds of development kits. Likewise, <a href=""https://quantumcomputing.stackexchange.com/questions/1474/what-programming-languages-are-available-for-quantum-computers"">What programming languages are available for quantum computers?</a> gathers a couple of good attempts at listing those.</p>

<p>The present question is related to the above, and yet it's not answered by the above resources.</p>

<p><strong>Does a complete list of open quantum software projects exist?</strong></p>

<p>Ideal answers would be: if it exists, the link to said list, and if it doesn't, a (well-formatted) as-exhaustive-as-possible compilation of open quantum software projects.</p>

<p>Related question: <a href=""https://quantumcomputing.stackexchange.com/questions/1973/are-there-any-quantum-software-startups"">Are there any quantum software startups?</a></p>
",<resource-request><programming>,4/25/2018 10:44,1923.0,1923.0,"<p>There is a really long list of quantum software projects on <a href=""https://www.quantiki.org/wiki/list-qc-simulators"" rel=""noreferrer"">Quantiki</a>. It's mostly about quantum simulators, quantum compilers and QC programming environments.</p>

<p>But you inspired me to start a curated list of open-source quantum software projects on GitHub <a href=""https://github.com/markf94/os_quantum_software"" rel=""noreferrer"">here</a>. It should not be exclusive to the aforementioned categories but list ANY (reasonable) open-source quantum software project out there. I will be doing my best to add as many projects as I can, but it would be great if some of you would contribute!</p>
",4/25/2018 15:21,Tooling,"the question is asking for a list of tools and software that are used in the field of quantum computing. This includes development kits, programming languages, and simulators. The question is also asking whether there is a complete list of these tools and software available",Tooling,,,,Tooling,
1926.0,"Does a study guide exist that starts from a ""purely CS background"" and advances towards ""making a new quantum programming language""?","<p>I am from a computer science background and I find it difficult to decide on the resources I should focus on while learning quantum computing, since there is so much to read/watch. My ultimate goal is to make a programming language acting as an interface between quantum computers and the person similar to 1972 when C was made. As a realistic intermediate stage, I would like to get to the point of writing programs on IBM's QISKit.</p>

<p>For that, I would need a schematic study guide in order to acquire the necessary background in Physics and the related fields required to dive into the field of quantum computing. Does this already exist: <strong>an ordered list of indispensable concepts and abilities to master, which if possible also mentions adequate material to acquire each of them</strong>?</p>

<p>Assume a high school level physics knowledge. Provide a study guide i.e. from beginner to expert kind of guide. Try to list video/book resources that one should follow in a chronological order so as to become an expert in the field of quantum computing to the level I can write my own quantum computing language (assuming already have other CS skills to write the language).</p>
",<algorithm><programming><resource-request>,4/25/2018 16:31,1972.0,1972.0,"<p>I don't think there is a <em>single</em> golden resource which can you provide you all the necessary knowledge. But I could suggest a pathway (or <em>schematic study guide</em> in your words):</p>

<p>If your aim is to create a <em>new</em> quantum programming language I'd rather say you should thoroughly learn an existing quantum programming language first along with the basic concepts of quantum computing, both from the physics side and the computer science side (maybe even the Mathematics side!).</p>

<ul>
<li><p>Microsoft has their quantum programming language named <strong>Q#</strong> (which is a part of their <strong>Quantum Development Kit</strong>). The complete documentation-cum-guide is on their website: <a href=""https://docs.microsoft.com/en-us/quantum"" rel=""noreferrer"">https://docs.microsoft.com/en-us/quantum</a>. If you are from the CS side, I hope you already have <em>some</em> knowledge of vectors, matrices and linear algebra in general. If so, you can directly start reading the guide article-by-article. Initially, they start with a brief revision of matrices, vectors, etc. followed by a brief introduction to qubits. That much is sufficient for at least getting started with writing a basic quantum program, with minimal understanding of the physics behind it. By the way, if your linear algebra concepts are weak, you could always try <strong>Khan Academy</strong>'s lectures on the same.</p></li>
<li><p>Next, you'd want to learn at least some basics of quantum mechanics. I personally love <a href=""https://www.youtube.com/playlist?list=PL2jykFOD1AWap0r8WOuZ-08BFgMyx-5RT"" rel=""noreferrer""><strong>Professor Vazirani's lectures</strong></a>, which are now on Youtube. In about 60 ten minute lectures he covers all the necessary basics of quantum mechanics and quantum computation algorithms. After this, you'd be in good shape to pick up new algorithms on your own.</p></li>
<li><p>As a third step, I'd suggest picking up ""<strong>Quantum Computation and Quantum Information by Isaac Chuang and Michael Nielsen</strong>"" and also ""<strong>Quantum Computing for Computer Scientists by Mirco A. Mannucci and Noson S. Yanofsky</strong>"" for covering the important topics which you missed out. </p></li>
</ul>

<p>That should be enough for you to get a solid grounding to start writing your own quantum programming language. You may also look into tutorials for the <a href=""https://en.wikipedia.org/wiki/Quantum_programming"" rel=""noreferrer"">other common quantum computing languages</a> to get an idea of how to write quantum programs and design quantum programming languages.</p>
",05/01/2018 17:27,Learning," the question is asking for a list of resources that can help the user learn about the fundamental concepts of quantum computing. This includes topics such as quantum mechanics, quantum algorithms, and quantum programming.",Learning,,,,Learning,
1973.0,Are there any quantum software startups?,"<p>I am aware of the quantum hardware startup <a href=""https://www.rigetti.com/"" rel=""nofollow noreferrer"">Rigetti</a> and I wonder if there are any quantum startups that build software on top of current quantum computer hardware for commercial applications?</p>

<p>Related question: <a href=""https://quantumcomputing.stackexchange.com/questions/1918/does-a-complete-list-of-open-quantum-software-projects-exist"">Does a complete list of open quantum software projects exist?</a></p>
",<programming>,05/01/2018 19:27,1980.0,1980.0,"<p>There are lots of startups, many of which have no hardware efforts. Here is a selection, distinguished only by the fact that I have heard of them at least once.</p>

<ul>
<li><a href=""https://artiste-qb.net/"" rel=""nofollow noreferrer"">artiste.qb</a></li>
<li><a href=""https://cambridgequantum.com/"" rel=""nofollow noreferrer"">Cambridge Quantum Computing</a></li>
<li><a href=""http://horizonquantum.com/"" rel=""nofollow noreferrer"">Horizon</a></li>
<li><a href=""https://q-ctrl.com/"" rel=""nofollow noreferrer"">Q-Ctrl</a></li>
<li><a href=""http://quantumbenchmark.com/"" rel=""nofollow noreferrer"">Quantum Benchmark</a></li>
<li><a href=""http://www.qxbranch.com/"" rel=""nofollow noreferrer"">Q<span class=""math-container"">$^x$</span> Branch</a></li>
<li><a href=""https://strangeworks.com/"" rel=""nofollow noreferrer"">Strangeworks</a></li>
<li><a href=""http://zapatacomputing.com/"" rel=""nofollow noreferrer"">Zapata</a></li>
</ul>

<p>There are also <a href=""https://www.qiskit.org"" rel=""nofollow noreferrer"">QISKit</a> and <a href=""https://projectq.ch/"" rel=""nofollow noreferrer"">ProjectQ</a>. Though not startups, they also deserve a mention as important quantum software projects.</p>
",05/02/2018 07:04,Conceptual ,"The users question is about quantum software startups that build software for commercial applications on top of current quantum computer hardware. The response provides information about several such startups and their focus areas, as well as information about open-source quantum software projects. This falls under the Learning category as it involves acquiring knowledge about the quantum computing industry and its players",Conceptual,,,,Conceptual ,
2051.0,"Why does job.running in QISKit output False, even if the job is still running?","<p>I submitted a job in the 0.5.0 version of QISKit using</p>

<pre><code>job = execute(qc, 'ibmqx5', shots=shots)
</code></pre>

<p>This just submits the job, and does not wait for a result.</p>

<p>I then immediately tested whether the job was still running using</p>

<pre><code>print(job.running)
</code></pre>

<p>This gave the result <code>False</code>. However, when I requested the result using</p>

<pre><code>job.result()
</code></pre>

<p>This still took a while to get the result, suggesting that the job actually was still running after all. What is going on here?</p>
",<programming><qiskit>,5/14/2018 13:19,2052.0,2052.0,"<p>There are three stages that the job goes through, as you'll see if you also print the status using <code>print(job.status)</code>.</p>

<p>The first is an initialization stage. This returns <code>False</code> for <code>job.running</code>, because it hasn't started running yet.</p>

<p>Then your job actually will run, and so give <code>True</code> for <code>job.running</code>. Finally it will have finished running, and so <code>job.running</code> goes back to <code>False</code>.</p>

<p>So don't use <code>job.running</code> to test whether a result is ready.</p>
",5/14/2018 13:19,Errors,"The reason is that it pertains to seeking solutions and explanations for errors and exceptions in quantum program development, specifically the issue of a submitted job not returning a result despite the job.running attribute returning False.",Errors,,,,Errors,
2062.0,What is Qconfig in QISKit and how do I set it up?,"<p>To use certain things in QISKIt, such as acessing the real quantum processors, it seems that there is a file 'Qconfig.py'. That needs to be set up.</p>

<p>How do I do this?</p>
",<programming><qiskit>,5/15/2018 10:12,2063.0,2063.0,"<p>To get access to the real devices and remote simulators, you need to have an account with the <a href=""https://quantumexperience.ng.bluemix.net/"" rel=""noreferrer"">IBM Q Experience</a>. Once you do, you can get your API key from the account page.</p>

<p>Once you have the API key, you can set up a Qconfig file. Let's assume that you want to run things from the <a href=""https://github.com/QISKit/qiskit-tutorial"" rel=""noreferrer"">QISKit tutorial</a>. The Qconfig file can then be set up by editing the file located <a href=""https://github.com/QISKit/qiskit-tutorial/blob/master/Qconfig.py.template"" rel=""noreferrer"">here</a>.</p>

<p>You just need to replace the line</p>

<pre><code>APItoken = None
</code></pre>

<p>with</p>

<pre><code>APItoken = ""randomstringoflettersandnumbersyoucopiedfromthewebsite""
</code></pre>

<p>Where the stuff within the quotation marks should be your actual API token.</p>

<p>You also need to rename the file from 'Qconfig.py.template' to just <code>Qconfig.py</code>.</p>

<p>Now you need to import the information from this file in your programs. This will depend on where you program sits in your computer relative to the Qconfig file.</p>

<p>If the <code>.py</code> or <code>.ipynb</code> file containing your program is sitting in the same directory as 'Qconfig.py', you can import with just</p>

<pre><code>import Qconfig
qx_config = {
    ""APItoken"": Qconfig.APItoken,
    ""url"": Qconfig.config['url']}
</code></pre>

<p>except Exception as e:
    print(e)
    qx_config = {
        ""APItoken"":""YOUR_TOKEN_HERE"",
        ""url"":""<a href=""https://quantumexperience.ng.bluemix.net/api"" rel=""noreferrer"">https://quantumexperience.ng.bluemix.net/api</a>""}</p>

<p>and then register your connection to the API with</p>

<p>register(qx_config['APItoken'], qx_config['url'])</p>

<p>If your <code>.py</code> or <code>.ipynb</code> is one directory level down, such as for <a href=""https://github.com/QISKit/qiskit-tutorial/tree/master/hello_world"" rel=""noreferrer"">this</a> you'll need to have the lines</p>

<pre><code>import sys
sys.path.append(""../"")
</code></pre>

<p>before you try to import. This tells the program to look for the Qconfig file in the directory above instead.</p>
",5/15/2018 10:12,Tooling ,"The reason for the category is that the question is asking about a specific step in the process of using QISKit to connect to quantum computers. The user is asking how to set up the Qconfig.py file, which is a necessary step in order to use QISKit to access real quantum processors.",Tooling,,,,Tooling ,
2261.0,Resources for quantum algorithm basics,"<p>I have just started to learn about quantum computing, and I know a little bit about qubits. What is a resource where I can learn a basic quantum algorithm and the concepts behind how it works?</p>
",<algorithm><physical-qubit><programming><resource-request>,06/07/2018 18:45,2262.0,2262.0,"<p>Most textbooks and lecture courses start with solving the Deutsch problem using quantum computing.</p>
<p>Parts 1 to 4 of John Watrous's lecture notes will describe the concepts, starting from basics. By the end of lecture 4, you will have learned how a quantum computer can solve the Deutsch problem with fewer operations than a classical computer would need.</p>
<p>All 22 lecture notes can be found <a href=""https://cs.uwaterloo.ca/%7Ewatrous/QC-notes/"" rel=""nofollow noreferrer"">here</a>.</p>
",06/07/2018 19:13,Learning, the question is asking for a resource that will help the user learn about quantum algorithms and the concepts behind how they work. This is a common question for beginners who are interested in learning about quantum computing.,Learning,,,,Learning,
2282.0,Why is it harder to build quantum computers than classical computers?,"<p>Is it because we don't know exactly how to create quantum computers (and how they must work), or do we know how to create it in theory, but don't have the tools to execute it in practice? Is it a mix of the above two? Any other reasons?</p>
",<physical-realization><classical-computing>,06/10/2018 12:34,2285.0,2285.0,"<p>We know exactly, in theory, how to construct a quantum computer. But that is intrinsically more difficult than to construct a classical computer.</p>

<p>In a classical computer, you do not have to use a single particle to encode bits. Instead, you might say that anything less than a billion electrons is a 0 and anything more than that is a 1, and aim for, say, two billion of electrons to encode a 1 normally. That makes you inherently fault-tolerant: Even if there are hundreds of millions of electrons more or less than expected, you will still get the correct classification as a digital 0 or a 1.</p>

<p>In a quantum computer, this trick is not possible due to the non-cloning theorem: You cannot trivially employ more than one particle to encode a qubit (quantum bit). Instead, you must make all your gates operate so well that they are not just accurate to the single particle level but even to a tiny fraction of how much they act on a single particle (to the so-called quantum-error correction threshold). This is much more challenging than to get gates accurate merely to within hundreds of millions of electrons.</p>

<p>Meanwhile we do have the tools to, just barely, make quantum computers with the required level of accuracy. But nobody has, as of yet, managed to make a big one meaning one that can accurately operate on the perhaps hundred of thousands of physical qubits needed to implement a hundred or so logical qubits to then be undeniably in the realm where the quantum computer beats classical computers at select problems (quantum supremacy).</p>
",06/10/2018 17:11,Conceptual,"the question is asking about the fundamental challenges that prevent us from creating quantum computers. These challenges include the difficulty of controlling qubits, the need for large-scale quantum systems, and the effects of noise and decoherence",Conceptual,,,,Conceptual,
2343.0,Is quantum cryptography safer than classical cryptography?,"<p>Quantum computing allows us to encrypt information in a different way compared to what we use today, but quantum computers are much more powerful than today's computers. So if we manage to build quantum computers (hence use quantum cryptography), will the so-called ""hackers"" have more or fewer chances of ""hacking"" into the systems? Or is it impossible to determine it?</p>
",<algorithm><cryptography><classical-computing>,6/14/2018 16:48,2345.0,2345.0,"<p>If you are talking specifically about quantum key distribution (quantum cryptography being an umbrella term that could apply to lots of stuff), then once we have a quantum key distribution scheme, this is theoretically perfectly secure. Rather than computational security that much of current cryptography is based on, quantum key distribution is perfectly secure.</p>

<p>That said, it is only perfectly secure subject to certain assumptions relating mainly to lab security. These same assumptions are essentially present in the classical case as well, just that because the quantum experiments are a lot more fiddly, it might be harder to be completely on top of all the possible attacks. Realistically, these are already the directions in which cryptography is attacked, rather than trying to brute force a crack. For example, exploits relying on a bad implementation of a protocol (rather than the protocol itself being flawed).</p>

<p>What quantum crypto, or post quantum crypto, is aiming to do is sidestep the loss of computational security implied by a quantum computer. It will never avoid these implementation issues.</p>

<p>In a completely shameless plug, you might be interested in my <a href=""https://vimeo.com/quantummechanic/qkdintro"" rel=""noreferrer"">introduction to quantum cryptography video</a>. It talks a little about this computational vs perfect security question (although doesn't really talk about possible hacks of QKD).</p>
",6/14/2018 18:05,Conceptual,"the question is asking about the potential impact of quantum computers on the ability of hackers to break into systems. This is a complex issue that depends on a number of factors, such as the development of quantum algorithms and the security of quantum cryptographic protocols",Conceptual,,,,Conceptual,
2355.0,Changing indices of qubits in QISKit,"<p>I was wondering if something like this is possible in QISKit: let's say we have two registers containing target and ancilla qubits:</p>

<p>$a_0$ -------------------</p>

<p>$a_1$-------------------- </p>

<p>$\vdots$</p>

<p>$a_4$ ------------------</p>

<p>$t_0$ ------------------</p>

<p>$t_1$ ------------------</p>

<p>$\vdots$</p>

<p>$t_4$ ------------------</p>

<p>These two registers are stored in one quantum register <code>qr</code>. So to access $a_0$ we would type <code>qr[0]</code>, to access $a_1$ - <code>qr[1]</code>, ..., for $t_5$ - <code>qr[9]</code>. We can pass this quantum register as an argument to some function:</p>

<pre><code>foo(qr, ...)
</code></pre>

<p>What I want to do is to interleave the ancilla and target qubits:</p>

<p>$a_0$ -------------------</p>

<p>$t_0$-------------------- </p>

<p>$\vdots$</p>

<p>$a_i$ ------------------</p>

<p>$t_i$ ------------------</p>

<p>$\vdots$</p>

<p>$a_4$ ------------------</p>

<p>$t_4$ ------------------</p>

<p>so to access $a_0$ I would type <code>qr[0]</code>, for $t_1$ - <code>qr[1]</code> and so on. Finally, I would like to pass such <code>changed</code> quantum register <code>qr'</code> again as an argument to some function</p>

<pre><code>foo(qr', ...)
</code></pre>

<p>and in this function I would like to use these changed indices. Is this possible? Other solution I figured out was to pass array of indices for ancilla and target qubits, but I would like to avoid that. Another option would be to use <code>swap</code> gates on these qubits</p>
",<programming><qiskit>,6/15/2018 11:23,2360.0,2360.0,"<p>The relationship between your indices can be captured by a map:</p>

<p>$$\{0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 1, 6: 3, 7: 5, 8: 7, 9: 9\}$$</p>

<p>You can then use this to specify where operations get applied to in a register. </p>

<p>Here is a simple code in QISKit (generalizes to arbitrary register length):</p>

<pre><code>from qiskit import * 
from qiskit.tools.visualization import *

# build a register with k targets and k ancillas 
k = 5
qr = QuantumRegister(2*k)
circ = QuantumCircuit(qr)

# apply cx between ancillas and targets
for i in range(k):
    circ.cx(qr[i], qr[i+k])

circuit_drawer(circ)
</code></pre>

<p><a href=""https://i.stack.imgur.com/mPrEbm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mPrEbm.png"" alt=""original""></a></p>

<pre><code># specify the desired interleaving
# {0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 1, 6: 3, 7: 5, 8: 7, 9: 9}
new_qubit_map = {i: 2*i if i &lt; k else 2*(i-k)+1 for i in range(len(qr))}

# create the same circuit, but with the new interleaving
circ_2 = QuantumCircuit(qr)
for i in range(k):
    circ_2.cx(qr[new_qubit_map[i]], qr[new_qubit_map[i+k]])

circuit_drawer(circ_2)
</code></pre>

<p><a href=""https://i.stack.imgur.com/hMtgDm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hMtgDm.png"" alt=""interleaved""></a></p>
",6/16/2018 0:33,Tooling ,"The users question is about how to use a specific tool or software in quantum programming. The response provides information about how to achieve the desired behavior using QISKit, which falls under the Tooling category as it pertains to the specialized software tools and frameworks used in quantum software engineering.",Tooling,,,,Tooling ,
2363.0,Will Moore's Law be no longer effective once quantum computers are created?,"<p>Moore's law states that computer power doubles in every 18 months (more formally: ""the number of transistors in a dense integrated circuit doubles about every two years.""). Statistics suggest that this observation should be correct, but aren't quantum computers much more powerful than just double-powered classical computers? More interesting question is, is there even a way to improve the power of quantum computers?</p>
",<classical-computing><experiment><scalability>,6/16/2018 9:45,2364.0,2364.0,"<blockquote>
  <p>but aren't quantum computers much more powerful than just
  double-powered classical computers?</p>
</blockquote>

<p>Yes. A universal quantum computer with only 100 qubits (12.5 quantum bytes) can find the ground state of a matrix with $2^{200} = 10^{60}$ elements. Assuming Moore's Law could continue forever (which is not true due to physical limitations), it would take longer than the age of the universe (13.5 billion years) for the ""doubling of transistors every 18 months"" to bring classical computers to what a quantum computer with one quantum gigabyte can do, for certain problems. </p>

<blockquote>
  <p>More interesting question is, is there even a way to improve the power of
  quantum computers?</p>
</blockquote>

<p>There have been proposals for exploiting certain types of phenomena that would lead to devices even more powerful than quantum computers, but in all cases quantum computers would be a special case of such devices (just like classical computers are a special case of quantum computers, they are quantum computers that just only use classical gates and inputs that are not in any superposition). It is hard enough to build a quantum computer, so building the more generalized devices would be even harder.</p>
",6/16/2018 17:31,Conceptual,"the question is asking about the relationship between Moore's law and quantum computers. Moore's law states that classical computers will become more powerful over time, but quantum computers are potentially much more powerful than classical computers. The user is asking if there is a way to improve the power of quantum computers beyond what is possible with Moore's law.",Theoretical,"The user is asking about the fundamental principles of quantum computing and whether there is a way to improve the power of quantum computers, which involves understanding the theoretical aspects of quantum computing and its potential for advancement.",No,68.0,Theoretical,"It delves into the fundamental principles of quantum computing and explores the potential for improvement in quantum computing power, aligning with the user's inquiry about the theoretical aspects of enhancing quantum computing capabilities beyond classical limits."
2454.0,One-qubit gate results in QISKit,"<p>I found it odd that the result of the action of identity gate (namely a $2\times2$ identity matrix) on a pure state $|0\rangle$ (namely the vector corresponding to the $2\times1$ matrix $\begin{bmatrix} 1\\0 \end{bmatrix}$) becomes a $2\times2$ matrix $\begin{bmatrix} 1+0\cdot i&amp;0+0\cdot i\\0+0\cdot i&amp;1+0\cdot i \end{bmatrix}=\begin{bmatrix} 1&amp;0\\0&amp;1 \end{bmatrix}$ as I found it <a href=""https://nbviewer.jupyter.org/github/QISKit/qiskit-tutorial/blob/master/reference/tools/quantum_gates_and_linear_algebra.ipynb#Identity-gate"" rel=""nofollow noreferrer"">HERE</a> (QISKit tutorial page):
<a href=""https://i.stack.imgur.com/W79pi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/W79pi.png"" alt=""enter image description here""></a></p>

<p>Also, when one lets for more precision, the result gets odd:    </p>

<p><a href=""https://i.stack.imgur.com/cv2Kx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cv2Kx.png"" alt=""enter image description here""></a></p>

<p>Why is this? The same thing happens for other gates listed on the page referenced above.</p>
",<quantum-gate><quantum-state><programming><qiskit>,6/24/2018 21:23,2455.0,2455.0,"<p>In the first case you are not asking for the state but the unitary matrix representing the circuit. This is correct and just rounding error.   It looks like you are not using the latest version so I would update. </p>

<p>In the second case are you sure that you donât have a previous circuit loaded in memory. In that notebook all examples have the same circuit name and it looks like this is a different gate.  If i had to guess it is the u2 example. If this is not the case you have found a bug and please submit an issue and we try to debug it.  </p>

<p>I would also change the title as this is not a general quantum computing question to one qubit gates errors in qiskit or something like that. </p>
",6/25/2018 1:28,Theoretical,"The question is technical detail of how the identity gate works in the context of quantum computing, which involves understanding the theoretical principles of quantum mechanics and linear algebra. ",Theoretical,,,,Theoretical,
2477.0,Phase-Shift Gate in Qiskit,"<p>How to implement the phase shift gate in qiskit or ibmq?
Phase Shift Gate : $$\begin{pmatrix}e^{ia} &amp;&amp; 0 \\ 0 &amp;&amp; e^{ia}\end{pmatrix} = e^{ia}I$$</p>
",<programming><qiskit><ibm-q-experience>,6/26/2018 16:52,2478.0,2478.0,"<p>You can implement the phase shift gate
<span class=""math-container"">$$P_h(\theta) = \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix}$$</span>
with the <code>X</code> and <code>u1</code> gate from the IBM Q chips:
<span class=""math-container"">$$ \begin{align}
P_h(\theta) &amp;= U_1(\theta)\ X\ U_1(\theta)\ X \\
&amp;= \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \\
&amp;= \begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix}\begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix} \\
&amp;= \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix}
\end{align}$$</span></p>

<p>So:</p>

<pre><code>def Ph(quantum_circuit, theta, qubit):
    quantum_circuit.u1(theta, qubit)
    quantum_circuit.x(qubit)
    quantum_circuit.u1(theta, qubit)
    quantum_circuit.x(qubit)
</code></pre>

<p>implements the <span class=""math-container"">$P_h$</span> gate on Qiskit.</p>
",6/26/2018 17:05,Tooling , the question is asking how to use the phase_shift() function in Qiskit to implement the phase shift gate. The phase_shift() function takes an angle as an argument and applies a phase shift to the qubit by that angle.,Tooling,,,,Tooling ,
2496.0,From Q# measurements to Bloch sphere,"<p>I would like to represent the state of a qubit on a Bloch sphere from the measurements made with Q#.</p>

<p>According the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.measure"" rel=""nofollow noreferrer"">documentation</a>, it is possible to measure a qubit in the different Pauli bases (PauliX, PauliY, PauliZ). This returns <code>Zero</code> if the +1 eigenvalue is observed, and <code>One</code> if the â1 eigenvalue is observed.</p>

<p>I can repeat this several times to find the probabilities for each base. Unfortunately, from there, I don't know how to calculate the density matrix or the X, Y, Z coordinates needed to plot the Bloch sphere.</p>

<p>Is it possible to find the density matrix or the X, Y, Z coordinates from these measurements? If yes, how ? </p>
",<programming><q#><density-matrix><bloch-sphere>,6/28/2018 9:08,2498.0,2498.0,"<p>The problem you are describing (i.e. finding an approximation of some state given some number of identical copies of it and some set of measurements) is known as <em>quantum state tomography</em> or <em>state tomography</em> for short.</p>

<p>In practise, the most efficient schemes for state tomography will depend on a specific experiment's setup and limitations, for which different protocols exist (see the <a href=""https://en.wikipedia.org/wiki/Quantum_tomography"" rel=""nofollow noreferrer"">wikipedia page</a> for an overview). Because the efficiency scaling of state tomography is notoriously bad in general, finding optimal tomography schemes for particular scenarios is an active area of research.</p>

<p>That being said, for the rest of this answer I will assume that efficiency scalings are not important for what you want to do and describe the general theory behind state tomography on a single qubit.</p>

<p>It can be shown that any density matrix can be written out as a linear combination of Pauli matrices, such that
$$
\rho = \frac{1}{2}(I + x\sigma_x + y\sigma_y + z\sigma_z) = \frac{1}{2} (I + \vec{r} \cdot \vec{\sigma})
$$
where $\vec{\sigma} = (\sigma_x, \sigma_y, \sigma_z)$ and $\vec{r} = (x, y, z)$ is the so-called <em>Bloch vector</em> representing the coordinates on the Bloch sphere you reference above. To find these, we observe that
$$
x = \textrm{Tr}(\rho \sigma_x) = \langle \sigma_x \rangle_\rho, \quad y = \textrm{Tr}(\rho \sigma_y) = \langle \sigma_y \rangle_\rho, \quad z = \textrm{Tr}(\rho \sigma_z) = \langle \sigma_z \rangle_\rho.
$$
and so each the amplitude of each component of the Bloch vector is given by the expectation value of it's associated Pauli operator on $\rho$. Recall that the expectation value $\langle A \rangle_\rho$ is given by the average over all eigenvalues returned by measurement of $A$ on $\rho$.</p>

<p>So, to find the state's Bloch vector, just perform each Pauli measurements many times to find the respective expectation value. </p>

<p>Finally, to retrieve the matrix representation of $\rho$, simply recall that 
$$
I = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix}, \quad 
\sigma_x = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix} \quad
\sigma_y = \begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix} \quad
\sigma_z = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix},
$$</p>

<p>and so</p>

<p>$$
\rho = \frac{1}{2} \begin{pmatrix} 1 + z &amp; x - iy \\ x + iy &amp; 1 - z \end{pmatrix}.
$$</p>

<p>Useful links and further reading:</p>

<ul>
<li><a href=""https://atom.physik.unibas.ch/fileadmin/user_upload/atom-physik-unibas-ch/Publications/People_Publications/Schmied2016a.pdf"" rel=""nofollow noreferrer"">Quantum state tomography of a single qubit: comparison of methods</a></li>
<li><a href=""http://research.physics.illinois.edu/QI/Photonics/tomography-files/tomo_chapter_2004.pdf"" rel=""nofollow noreferrer"">""Quantum State Tomography"" chapter from ""Quantum State Estimation"" textbook</a></li>
</ul>

<p><strong>Afterword</strong>:</p>

<p>By extending this protocol to two qubits we can flavour of why state tomography is not scalable in general. For two qubits $\rho_1$ and $\rho_2$ the combined state $\rho_{1,2} = \rho_1 \otimes \rho_2$ is given by
\begin{align}
\rho_{1,2} = \frac{1}{2} (I + \vec{r}_1 \cdot \vec{\sigma}_1) \otimes \frac{1}{2} (I + \vec{r}_2 \cdot \vec{\sigma}_2)
\end{align}
which is going to contain $4^2 = 16$ components, one for each $2$-fold Pauli operator. Clearly a strategy that requires $4^n$ different expectation values to be estimated to recover an $n$-qubit state is unfeasible for even small systems of qubits. So this is where the aforementioned research comes in.</p>
",6/28/2018 11:40,Tooling,"The query is asking about how to use a tool, namely Q#, to implement a quantum algorithm. The query is not about the theoretical concepts of quantum computing, learning resources, or the background, limitations, or underlying concepts of quantum programming. It is also not about errors in a quantum program or how to correctly and effectively use APIs in quantum programming.",Tooling,,,,Tooling,
2499.0,Is quantum computing just pie in the sky?,"<p>I have a computer science degree. I work in IT, and have done so for many years. In that period ""classical"" computers have advanced by leaps and bounds. I now have a terabyte disk drive in my bedroom drawer amongst my socks, my phone has phenomenal processing power, and computers have revolutionized our lives. </p>

<p>But as far as I know, quantum computing hasn't done anything. Moreover it looks like it's going to stay that way. Quantum computing has been around now for the thick end of forty years, and real computing has left it in the dust. See the <a href=""https://en.wikipedia.org/wiki/Quantum_computing#Timeline"" rel=""noreferrer"">timeline</a> on Wikipedia, and ask yourself <em>where's the parallel adder?</em> Where's the equivalent of Atlas, or the MU5? I went to Manchester University, see the history on the <a href=""https://en.wikipedia.org/wiki/Manchester_computers#MU5"" rel=""noreferrer"">Manchester Computers</a> article on Wikipedia. Quantum computers don't show similar progress. Au contraire, it looks like they haven't even got off the ground. You won't be buying one in PC World any time soon. </p>

<p>Will you ever be able to? Is it all hype and hot air? Is quantum computing just pie in the sky? Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public? If not, <em>why not?</em> </p>
",<classical-computing><applications><history>,6/28/2018 14:11,2552.0,2552.0,"<blockquote>
<p>Is quantum computing just pie in the sky?</p>
</blockquote>
<p>So far it is looking this way. We have been reaching for this pie aggressively over the last three decades but with not much success. we do have quantum computers now, but they are not the pie we wanted, which is a quantum computer that can actually solve a useful problem faster or with better energetic efficiency than a classical computer.</p>
<blockquote>
<p>You won't be buying one in PC World any time soon.</p>
<p>Will you ever be able to?</p>
</blockquote>
<p>We cannot predict the future, but if I had to guess right now, I would say &quot;no&quot;. There is not yet any application for which quantum computing would be valuable enough. Instead we might have quantum computers at a small number of special institutes where very special calculations are done (like the supercomputer called Titan at Oak Ridge National Lab, or like a cyclotron particle accelerator where special experiments are done).</p>
<blockquote>
<p>Is it all hype and hot air?</p>
</blockquote>
<p>Most of it is hype, unfortunately. <br>
But applications in quantum chemistry can indeed be game changing. Instead of doing physically laborious experiments on thousands of candidate molecules for a medicine or fertilizer, we can search for the best molecules on a computer. Molecules behave quantum mechanically, and simulating quantum mechanics is not efficient on classical computers, but is on quantum computers. Much of Google's investment in QC is for chemistry applications [<a href=""https://ai.googleblog.com/2016/07/towards-exact-quantum-description-of.html"" rel=""noreferrer"">1</a>].</p>
<blockquote>
<p>Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public? If not, why not?</p>
</blockquote>
<p>Much of it is, unfortunately.<br></p>
<p>You were probably one of the more talented students in your class at Manchester University. You might have noticed that there was only a few of you and a larger number of mediocre and sub-mediocre students. There is a similar phenomenon at the professor level. Many professors don't find it easy or &quot;natural&quot; to write well-received grant proposals, but they need funding to keep their job, and to make sure their PhD students aren't starved of experiencing scientific conferences and having access to the software they need.<br></p>
<p>When a professor becomes:</p>
<ul>
<li>desperate for funding, or</li>
<li>caught up with other problems in life, such as having to take care of a child with cancer, or</li>
<li>aware that they won't make huge scientific discoveries like some scientists did 100s of years ago,</li>
</ul>
<p>life becomes more about surviving, keeping a happy family, and doing what they <em><strong>enjoy</strong></em> rather than making a better world for their grandchildrens' grandschildren. As a professor, I can tell you that many of my colleagues are not as &quot;noble&quot; as the public often perceives scientists to be.</p>
<p><strong>I know around 1000 people with funding to work in quantum computing, and not a single one seems to have ill intentions to fool a &quot;gullible public&quot; in some sinister way.</strong> Most of us just apply for grants available through our universities or through our governments, and we don't intend to exaggerate the importance of our work any more than other scientists competing for the same money (we have to compete with molecular physicists pretending their work is important for fixing climate change just because the molecule they're working on is in our atmosphere, or biophysicists pretending their work might cure cancer just because they're working on a molecule that's prominent in the body).</p>
<p>A lot of the &quot;hype&quot; around quantum computing comes from the media. Journalists have twisted the contents of my papers to make eye-catching headlines which will get more clicks on their ads, and their bosses give them pressure to do this or they'll lose their job to the other intern that doesn't care as much about being honest.</p>
<p>Some of the hype does come from scientists themselves, many who truly believe quantum computing will be revolutionary because their PhD supervisor didn't have a great education (remember that Manchester University is one of the best in the world, and <em><strong>most</strong></em> universities are not even close), or perhaps in rare cases there is hype from people desperate for funding, but not much for reasons other than these.</p>
<p><strong>I do believe the public should invest a bit in quantum computing, as they do for lots of other areas of research which have no guaranteed positive outcome.</strong> The hype is often exaggerated by journalists, ignorant scientists, or non-ignorant scientists who think they need it for survival.  There is also unfairly harsh criticism from journalists and funding agencies.</p>
<p><em><strong>Nothing you said in your question is wrong.</strong></em> <br>
I have just given some reasons for why they are correct.</p>
",6/30/2018 19:11,Conceptual,"The text engages in a conceptual discussion about the progress, potential, and skepticism surrounding quantum computing in contrast to classical computing, addressing its perceived lack of advancements and exploring the reasons behind this discrepancy.",Conceptual,,,,Conceptual,
2553.0,How do you send an array of qubits to an operation in Q#?,"<p>I have the following operation in my .qs files:</p>

<pre><code>operation myOp(qubits: Qubit[]) : () {
     // uses elements from the qubit array        
 }
</code></pre>

<p>How do I send an array of qubits to this in the driver file?
The following did not work:</p>

<pre><code>Qubit[] qubits = new Qubit[2];
myOp.Run(sim, qubits);
</code></pre>

<p>I got the following error:</p>

<pre><code>Driver.cs(13,32): error CS1503: Argument 2: cannot convert from 'Microsoft.Quantum.Simulation.Core.Qubit[]' to 'Microsoft.Quantum.Simulation.Core.QArray&lt;Microsoft.Quantum.Simulation.Core.Qubit&gt;' [/home/tinkidinki/Quantum/Warmup_Contest/BellState/BellState.csproj]

The build failed. Please fix the build errors and run again.
</code></pre>

<p><em>Also, as an aside: Would such a question be more suitable for this site, or for stack overflow?</em> </p>
",<programming><q#>,6/30/2018 19:36,2575.0,2575.0,"<p>In general, <a href=""https://docs.microsoft.com/en-us/quantum/quantum-techniques-5-workingwithqubits?view=qsharp-preview#allocating-qubits"" rel=""noreferrer"">there are exactly two ways to allocate qubits in Q#</a>: the <code>using</code> statement, and the <code>borrowing</code> statement.
Both can only be used from within Q#, and can't be directly used from within C#.
Thus, you'd likely want to make a new Q# operation to serve as the ""entry point"" from C#; this new operation would then be responsible for allocating qubits and passing them down.</p>

<p>For instance:</p>

<pre><code>// MyOp.qs
operation EntryPoint() : () {
    body {
        using (register = Qubit[2]) {
            myOp(register);
        }
    }
}


// Driver.cs
EntryPoint.Run().Wait();
</code></pre>
",07/02/2018 19:17,Tooling,"The query is asking for a technical solution to a problem in quantum programming using Q#. The query is asking how to use a tool, namely Q#, to send an array of qubits to an operation.so belong to tooling",Tooling,,,,Tooling,
2561.0,Checking value of variable using quantum approach,"<p>A beginner question after watching few videos.</p>

<p>Say, <code>var=a</code>; <code>var</code> can be either of two values, <code>a</code> or <code>b</code>. Check what is the value of <code>var</code>, using <code>Q#</code>, <code>QISKit</code> or similar.</p>

<p>Any help/idea? </p>
",<programming><qiskit><q#>,07/01/2018 13:05,2583.0,2583.0,"<p>You can check for state equality with the SWAP test.</p>
<p><a href=""https://arxiv.org/abs/quant-ph/0102001"" rel=""nofollow noreferrer"">Quantum fingerprinting (Buhrman, Cleve, Watrous &amp; de Wolf, 2001)</a> seems to be the first paper to introduce the SWAP test.</p>
<p>The idea behind this test is:</p>
<ol>
<li>Encode the 2 quantum states using quantum error correction codes to &quot;increase the difference between them&quot;.</li>
<li>Test the 2 code words by using an ancilla register and the procedure below.</li>
<li>Read the ancilla register. If it is <span class=""math-container"">$\left\vert 0 \right\rangle$</span> then the 2 states are probably equal. Else, they are probably different.</li>
</ol>
<p><a href=""https://i.stack.imgur.com/W45h1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/W45h1.png"" alt=""SWAP test"" /></a></p>
<p>You can repeat the procedure multiple times to ensure that the 2 states are equal up to a given probability.</p>
<p>You can implement by yourself the test on QISKit:</p>
<pre><code>from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, execute
from qiskit import IBMQ, BasicAer

q_simulator = BasicAer.get_backend('qasm_simulator')

register_size = 2

qr_psi = QuantumRegister(register_size, 'psi')  #For state PSI
qr_phi = QuantumRegister(register_size, 'phi')  #For state PHI
qr_ancilla = QuantumRegister(1, 'ancilla')
cequal = ClassicalRegister(1, 'equal')

circuit = QuantumCircuit()

circuit.add_register(qr_psi)
circuit.add_register(qr_phi)
circuit.add_register(qr_ancilla)
circuit.add_register(cequal)


def cswap(circuit, ctrl, q1, q2) -&gt; None:
    assert(len(q1) == len(q2), &quot;The swapped register sizes should match&quot;)
    for i in range(len(q1)):
        # Controlled swap
        circuit.ccx(ctrl, q1[i], q2[i])
        circuit.ccx(ctrl, q2[i], q1[i])
        circuit.ccx(ctrl, q1[i], q2[i])

def equality_test(circuit, ancilla, q1, q2, classical_register) -&gt; None:
    assert(len(q1) == len(q2), &quot;The swapped register sizes should match&quot;)
    circuit.h(ancilla[0])
    cswap(circuit, ancilla[0], q1, q2)
    circuit.h(ancilla[0])
    circuit.measure(ancilla[0], classical_register[0])

## Initialisation
# We add Hadamard to all the registers - to create PSI
circuit.h(qr_psi)
# We add Hadamard to all the registers - to create PHI
# Modify the initialisation of either PHI or PSI and check the results.
circuit.x(qr_phi)
circuit.h(qr_phi)

## SWAP test
equality_test(circuit, qr_ancilla, qr_psi, qr_phi, cequal)

res_qasm = execute([circuit], q_simulator, shots=1024).result()
counts = res_qasm.get_counts()

print(counts)
</code></pre>
<p>You can convince yourself that the method works with high probability by changing the initialisation step of the two registers and check the results when the 2 register match or don't match.</p>
",07/02/2018 20:37,Learning,"The query is asking for learning resources and tutorials on how to check the value of a variable that can be either of two values. The query does not specify any specific technical problems or errors, so it is not a question about tooling or errors. It is also not a question about the potential and limitations of quantum computing, so it is not a discussion question",Tooling ,"The user is asking about a specific technical issue they encountered while using the Q# programming language and its associated tools. This falls under the category of tooling, which refers to the specialized software tools and frameworks used to develop, simulate, and optimize quantum algorithms and circuits",No,69.0,Learning," The user is seeking guidance and ideas on how to check the value of a variable using quantum approaches, indicating a desire to learn about quantum computing concepts and methodologies, rather than encountering a specific technical issue."
3841.0,Is there something like GitHub for quantum programming?,"<p>I'm just learning about quantum computer but some of it has been available for people to research &amp; practice so I'd like to study it myself. The only kind of quantum computing I found so far is IBM cloud service and Q# quantum simulator but the sources and examples are limited, and I only found a bunch of display emoji &amp; a card-guessing mini-game in quantum programming. Are there any main sources like GitHub but for quantum computing programming? </p>
",<programming>,7/23/2018 4:01,3842.0,3842.0,"<p>Are you looking for algorithms to look through, or programs for an actual quantum computer?</p>

<p>If the former the <a href=""https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;page=introduction"" rel=""nofollow noreferrer"">IBM Q Experience</a> user guide has good explanations of some of them, and other questions you can find on this Stack Exchange can get you to more algorithms.</p>

<p>If you are looking for programs to be run on a quantum computer like IBM's cloud offerings, I'm not sure if there is a github specific to is, but looking into the <a href=""https://github.com/Qiskit/qiskit-tutorial"" rel=""nofollow noreferrer"">Qiskit</a> github would be a good place to start!</p>
",7/23/2018 4:09,Learning,"The query pertains to finding additional resources and platforms for learning quantum computing programming beyond the currently encountered limited sources like the IBM cloud service and Q# quantum simulator. The user seeks to expand their understanding and practice in quantum programming, making this a request for learning resources and references.", Learning,,,,Learning,
3846.0,List of qubit locations with cirq,"<p>As far I understand, qubits in cirq are labelled by their positions on chip. For example</p>

<pre><code>print( cirq.google.Foxtail.qubits )
</code></pre>

<p>yields</p>

<pre><code>frozenset({GridQubit(0, 1), GridQubit(1, 9), GridQubit(0, 2), ...
</code></pre>

<p>I would like to get a simpler version of the above, namely a simple array of tuples for the positions of all qubits</p>

<pre><code>[ (0,1), (0,2), (0,3), ..., (1,1), (1,2), (1,3), ... ]
</code></pre>

<p>What is the easiest way to obtain this for a given known device in cirq?</p>
",<programming><cirq>,7/23/2018 9:39,3849.0,3849.0,"<p><code>GridQubit</code> has comparison methods defined, so <code>sorted</code> will give you a list of the qubits in row-major order:</p>

<pre><code>&gt;&gt;&gt; sorted(cirq.google.Foxtail.qubits)
[GridQubit(0, 0), GridQubit(0, 1), [...] GridQubit(1, 9), GridQubit(1, 10)]
</code></pre>

<p>Once you have that, you're one list comprehension away:</p>

<pre><code>&gt;&gt;&gt; [(q.row, q.col) for q in sorted(cirq.google.Foxtail.qubits)]
[(0, 0), (0, 1), [...] (1, 9), (1, 10)]
</code></pre>

<p>Because tuples also have a default ordering, it doesn't matter whether you sort before or after the conversion:</p>

<pre><code>&gt;&gt;&gt; sorted((q.row, q.col) for q in cirq.google.Foxtail.qubits)
[(0, 0), (0, 1), [...] (1, 9), (1, 10)]
</code></pre>
",7/23/2018 12:08,Tooling,"The query seeks guidance on using a specific tool, Cirq, and how to manipulate its features to achieve a desired outcome, which is extracting a simplified representation of qubit positions from a given device. This falls under the ""Tooling"" category as it deals with practical aspects of working with a quantum programming library.",Tooling,,,,Tooling,
3872.0,The process for transferring qubits between locations,"<p>I understand that right now qubits are physical entities in a Quantum Computer and I am playing around on the IBM Quantum Computer as well as the Q# language and dipping my toes into the Quantum world for the first time.</p>

<p>I have read a lot of the Alice and Bob style scenarios where it often mentions transporting a qubit from Alice to Bob. I am inferring that as physically transporting it but I haven't found a discussion on what this looks like from a computing sense. As in how it could be theoretically achieved to ""package"" a qubit, or even a representation of a qubit (state or values) for transportation via a Classical or Quantum channel? I am assuming the only way this is possible is via entanglement and teleportation. Is it possible for non-entangled, ordinary qubits, to be represented in some format and transferred logically between two points, whereby the receiving point can decode and interpret the information contained within. That receiving point could be a computer service in a Classical computer architecture or another Quantum machine.</p>

<p>I ask this in the sense of Classical Computing, where we can encode bits onto a chip but logically represent a bit (or series of bits) in numerous formats and transfer them for manipulation. As a software engineer that's where my thought process is coming from. This might not be a practical thing to want to do in Quantum but in theory, is it something that could be achieved? Any guidance would be welcome.</p>

<p>EDIT: 
Thank you for the really comprehensive answers, it has filled in a lot of gaps and I did not realise the strong link between photons &amp; fiber which brings a potential bridge in theory. I'm working my way through the basic hello world applications and was trying to mentally bridge my software knowledge of Classical into this world at a basic transfer and representation level.  I'm trying to build some small apps that bridge both worlds and my mental block right now is representing the characteristics of a qubit in traditional programming notations. Have you any thoughts on what would need to be modelled to create a logical representation of a qubit? What I am getting at is something similar to a specification that would allow a programmer represent a type (like a String e.g. <a href=""https://en.wikipedia.org/wiki/String_(computer_science)"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/String_(computer_science)</a>). In the Quantum programming languages the qubit is it's own type, drilling down a level can the characteristics be captured in a very basic manner so that potentially they could be represented in something like a vector array to capture key characteristics e.g. 
state (notwithstanding the difficulty of superposition!), spin etc.</p>
",<physical-qubit><physical-realization><classical-computing><communication>,7/26/2018 16:25,3876.0,3876.0,"<p>You are totally right in your assumption about transporting qubits from Alice to Bob implies something physical. Usually problems/situations that have this setup of a transmission between two parties are called <em>quantum communications</em>. These problems/situations sometimes disambiguate by calling their qubits ""flying qubits"" which are almost always photons. Single photons are also quantum systems that can be prepared in useful qubit states, they can be operated on with gates (but not all kinds of gates and not as easily as some other physical implementations of qubits), and can be measured just like any other qubit system. Alice and Bob would literally share these photos by either an optical fiber they are connected by or through free space (which could be literally to a satellite in space).</p>

<p>Photons are great for this application because we already use them for a large portion of our classical communication networks. ""Fiber"" internet or photonic networks send classical information in optical fiber with strong pulsed lasers. So if you wanted to have both a classical channel and a quantum communication channel you could do both with the same fiber (hard for some technical reasons but totally possible).</p>

<p>There are also may other physical systems that you cab make qubits out of for quantum computing (super conductors, ion traps, etc.). You are correct in that to connect different groups of these qubits one would not pick the chip up and move it, but instead they often create a(n) photon(s) that are entangled with the original system or have some information they want to share with the second system and then send the photon over.  </p>
",7/26/2018 20:35,Conceptual,"The text falls under the ""Conceptual"" category as it explores the theoretical concepts and implications of transporting qubits between different quantum systems, drawing parallels with classical computing's ability to encode and represent data in various formats. The discussion revolves around the logical representation, encoding, and theoretical possibilities of transferring qubits, bridging the gap between classical and quantum computing paradigms",Conceptual,,,,Conceptual,
3902.0,Are classical bits quantum?,"<p>A bit is a binary digit, typically 0 or 1.</p>

<p>Until a value is assigned (or a measurement is made) a bit is in a superposition of the entangled binary pair, is it not?</p>
",<classical-computing>,7/31/2018 1:55,3905.0,3905.0,"<p>A bit, either 0 or 1, can certainly be thought of as a special case of being a qubit. However, that is not to say that anything capable of computing with classical bits is capable of computing with quantum bits.</p>

<p>If you have a bit, and donât know if itâs a 0 or a 1, then how do you describe its state? You have to use Bayesian priors. If you have no idea which it is, you assign the two options equal probabilities. And it really is probabilities here. So itâs 50:50 being in 0 or 1. You canât describe this as a pure quantum state, but you can use a density matrix:
$$\rho=(|0\rangle\langle 0|+|1\rangle\langle 1|)/2.$$
This formalism also means that if you later learn something about what the bit value might be (perhaps as a result of reading other bits in a computation), you can update those probabilities using conditional probabilities and Bayesâ rule. Note that this also means itâs a subjective description of the state: it reflects your personal knowledge of the state of the bit, while somebody else, who perhaps prepared the bit, already knows what value it has. This is perhaps one way to see why it should be different from the pure state that you proposed, which should be an objective description that everyone would agree on (in that there is no uncertainty in the state; the only uncertainty is induced by the action of the measurement).</p>
",7/31/2018 5:26,Theoretical,"The query is asking about the theoretical implications of the superposition of a qubit, specifically the quantum property of bits being in a superposition of states until they are measured or assigned values",Conceptual,The user is asking a conceptual question about the nature of bits in a superposition state before a specific value is assigned or a measurement is made. This involves understanding the fundamental concept of superposition in quantum computing.,No,70.0,Conceptual,"The user is seeking an explanation of the conceptual nature of bits in a superposition state before being assigned a value or measured, indicating a need for understanding the fundamental concepts of quantum computing."
3908.0,"Possibility of a ""reset"" quantum gate","<p>I wish to have a ""reset"" gate. This gate would have an effect to bring a qubit to the $\mid0\rangle$ state.<br>
Clearly, such a gate is not unitary (and so I'm unable to find any reliable implementation in terms of universal gates).</p>

<p>Now for my particular needs, I need this ability to reset a qubit or a quantum register to that state so users can always start from $\mid0\rangle$.  I'm making a small programming language that transpiles to QASM, and when a function is exited, I want all local (quantum) variables (qubits) reset to $\mid0\rangle$ so they can be reused.  QASM reset instruction does not work on the real processor.</p>

<p>I think that something to this effect may be achieved with quantum phase estimation but I'm wondering if there is another way.</p>
",<quantum-gate><programming>,7/31/2018 12:05,3909.0,3909.0,"<p>One way is simply to measure the qubit in the standard, $Z$, basis. If you get the answer 0, then you've got the state you want. Otherwise, you apply a bit-flip to it.</p>

<p>Indeed, if you want to implement a non-unitary operation, you need some sort of measurement operation somewhere, whether that's a direct measurement, or the implementation of a CP map or POVM (but for these options, you need to introduce ancillas of a fixed state, which rather negates the point). Or you could use noise in the system, but you are unlikely to have sufficient control of it - it's noise after all! Of course, none of these options just reset a single qubit; anything that qubit is entangled with is also affected, but that's kind of in the definition of ""reset"" in the quantum context.</p>

<p>The only other option is to uncompute, but this is not a generic option because, generically you have to uncompute the entire computation to reset even a single qubit, and that resets everything. Except it doesn't work perfectly because of errors. You would be better starting a new computation. There are specific scenarios where an ancilla qubit is used and it can be uncomputed, but this is typically built into the algorithm because the uncomputation step is important for getting rid of some unwanted entanglement that would otherwise appear.</p>
",7/31/2018 12:21,Tooling,The query is asking for a technical solution to the problem of implementing a reset gate in terms of universal gates.,Tooling,,,,Tooling,
3920.0,Can we perform quantum mechanical simulations using a quantum computer?,"<p>I'm a computer science major who's really keen on physics and quantum mechanics. I have started learning about Q# and D-Wave, but I just wanted to know if it's possible to test quantum mechanical theories using quantum computers.</p>

<p>If so, then what all different things should I look into? For example, Q# allows us about 30 qubits for free developing. What kind of simulations can I do with that many qubits?</p>
",<programming><simulation><q#>,08/02/2018 02:11,3921.0,3921.0,"<p>What do you mean by ""Quantum Mechanical Simulations"" ?</p>

<p>One of the primary motivations in the early history of quantum computing was a statement from Richard Feynman that a quantum computer would be able to effectively simulate quantum systems. To that end, a lot of the nearest term quantum programs people are trying to run (and have run) are simulations of ground states of atoms and molecules. These are very classically resource intensive, but <a href=""https://www.ibm.com/blogs/research/2017/09/quantum-molecule/"" rel=""nofollow noreferrer"">IBM has done this to good success</a> on smaller highly symmetric molecules using their current quantum computers.</p>

<p>On the other hand, if you are wondering if we can test Quantum Mechanics as a theory using a Quantum Computer things like <a href=""https://en.wikipedia.org/wiki/Bell%27s_theorem"" rel=""nofollow noreferrer"">Bell's Inequalities</a> can be tested. This is a proof that a system is Quantum Mechanical, as there is an inequality which can only be broken if using entanglement. The article linked has a good explanation, and goes into some of the experimental verifications which have already been done, but such a test is one of the ways to ensure that a given Black Box Computer is quantum is nature.</p>
",08/02/2018 02:20, Learning,"The user is seeking guidance on the practical applications of quantum computing for testing quantum mechanical theories. They are interested in exploring what simulations or experiments can be conducted with a limited number of qubits, which falls under the category of learning and applying quantum computing concepts. ",Learning,,,, Learning,
3935.0,"How do we code the matrix for a controlled operation knowing the control qubit, the target qubit and the $2\times 2$ unitary?","<p>Having n qubits, I want to have the unitary described a controlled operation.
Say for example you get as input a unitary, an index for a controlled qubit and another for a target.</p>

<p>How would you code this unitary operation?</p>
",<quantum-gate><programming><gate-synthesis>,08/04/2018 11:05,3941.0,3941.0,"<p>Hereâs some pseudo code, where <code>id(n)</code> creates an $2^n\times 2^n$ identity matrix, and <code>tensor(A,B,...)</code> returns $A\otimes B\otimes\ldots$.</p>

<pre>
def cU(ctrl,targ,U,size):
    '''implement controlled-U with:
          control qubit ctrl,
          target qubit targ,
          within a set of size qubits'''
#check input ranges
    assert 1&#60;=ctrl&#60;=size
    assert 1&#60;=targ&#60;=size
    assert ctrl&#60;&#62;targ
    assert ctrl,targ,size &#8714; &#8484;
#ensure U is a 2x2 unitary
    assert U&#8714;&#8450;<sup>2x2</sup>
    assert U.U<sup>&dagger;</sup>=id(2)
#the actual code
    if ctrl&#60;targ:
        return id(size)+tensor(id(ctrl-1),id(1)-Z,id(targ-1-ctrl),U-id(1),id(size-targ))/2
    else:
        return id(size)+tensor(id(targ-1),U-id(1),id(ctrl-1-targ),id(1)-Z,id(size-ctrl))/2
</pre>

<p>However, remember that usually you're trying to calculate the action of a unitary on some state vector. It will be far more memory efficient to calculate that application directly, rather than first calculating the unitary matrix and applying it to the state vector.</p>

<p>To understand where this formula came from, think about the two-qubit version, where the first qubit is the control qubit. You'd normally write the unitary as
$$
|0\rangle\langle 0|\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U.
$$
Let's rewrite this as
$$
(\mathbb{I}-|1\rangle\langle 1|)\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U=\mathbb{I}\otimes\mathbb{I}+|1\rangle\langle 1|\otimes (U-\mathbb{I}).
$$
It can be easier to write things in terms of Pauli matrices, so
$$
|1\rangle\langle 1|=(\mathbb{I}-Z)/2.
$$
To get the same unitary on a different number of qubits, you just need to pad with identity matrices everywhere.</p>
",08/05/2018 05:14,Tooling,"The query is asking for a technical solution to the problem of coding a controlled operation in a programming language. The query specifically mentions the need for a controlled operation, which is a common operation in quantum computing. The query is asking how to code this operation in a specific programming language.",Tooling,,,,Tooling,
4033.0,Finding the maximum number of Q# simulatable qubits,"<p>I'm new to Q# and I was curious on how one would find the number of Q# simulatable qubits for a specific machine.  I know Microsoft has an approximation of 16GB ~ 30 qubits but I wanted a better estimation for my own machines.  </p>

<p>I wrote this quick program that runs a loop which allocates a register of increasing size.  When I get a <code>std::bad_alloc</code> error I then have an estimate.  I'm guessing there is a better way either through a tool or some pre-written code.</p>
",<programming><simulation><q#>,8/15/2018 7:40,4040.0,4040.0,"<p>The simple rule is:</p>

<blockquote>
  <p><strong>Doubling the memory gives you one additional qubit.</strong></p>
</blockquote>

<p>So if Microsoft says that </p>

<pre><code>16GB -&gt; 30 qubits
</code></pre>

<p>then </p>

<pre><code> 8GB -&gt; 29 qubits
 4GB -&gt; 28 qubits
 2GB -&gt; 27 qubits
 ...
32GB -&gt; 31 qubits
64GB -&gt; 32 qubits
</code></pre>

<p>and so further.</p>

<p>This scaling, as well as the number quoted by Microsoft, can be understood from an argument as the one in the <a href=""https://quantumcomputing.stackexchange.com/a/3862/2293"">linked answer</a>, using that </p>

<ol>
<li><p>each complex number equals 2 real numbers with double precision (8 bytes each), so 16 bytes are needed per comples number,</p></li>
<li><p>to describe $N$ qubits, $2^N$ numbers are needed,</p></li>
<li><p>and 1GB=$1024^3$ bytes</p></li>
</ol>

<p>which together yields $16\cdot 2^N = x \, \mathrm{GB} = x\cdot 1024^3$ with $x$ the memory required in GB, which results in 
$$
N = \log_2(x\,\times 1024^3/16) = \log_2(x)+26\ .
$$
For $x=16$ (i.e. 16GB of memory), $\log_2(16)=4$, and this yields exactly 
$$
N=30 \ \mathrm{qubits}\ ,
$$
which is the number quoted by Microsoft.</p>
",8/15/2018 22:37,Tooling,"The text falls under the ""Tooling"" category as it discusses a practical approach to estimating the number of simulatable qubits for a specific machine using Q#. The user is seeking a method or tool to determine this information more accurately than their current approach, making it a discussion about the practical tools and techniques for estimating simulatable qubits in quantum programming.",Tooling,,,,Tooling,
4142.0,How does one obtain amplitude information in Q#?,"<p>Is it possible to obtain amplitude information (in lexicographic ordering) for a particular qubit register in Q#?  </p>

<p>For example, in the following code:</p>

<pre><code>operation GetProbabilityAmplitude() : Double[]
{
    body
    {
        mutable result = new Double[4];
        using (register = Qubit[2])
        {
            H(register[0]);
            CNOT(register[0], register[1]);
            // ...put the amplitude doubles in the result array
        }
        return result;
    }
}
</code></pre>

<p>The doubles in <code>result</code> should be {0.5,0.0,0.0,0.5}.  I looked quite a bit for it in the documentation but couldn't find anything about getting the amplitudes.</p>
",<simulation><programming><q#>,09/03/2018 01:20,4144.0,4144.0,"<p>Yes, it is possible to obtain this information, but only for troubleshooting purposes, not for using it in the code.</p>

<hr>

<p><a href=""https://docs.microsoft.com/en-us/quantum/quantum-techniques-testinganddebugging#dump-functions"" rel=""noreferrer"">Dump functions</a> dump the status of the target machine into a file or to the console output. If the program is executed on the full-state simulator, this status will include the wave function of the whole system (for DumpMachine) or of the register (for DumpRegister).</p>

<p>So you could do the following:</p>

<pre><code>using (register = Qubit[2]) {
    H(register[0]);
    CNOT(register[0], register[1]);
    DumpMachine("""");
    // to avoid ReleasedQubitsAreNotInZeroState exception
    ResetAll(register);
}
</code></pre>

<p>and get the following amplitudes (each one is a complex number):</p>

<pre><code>Ids:    [1;0;]
Wavefunction:
0:      0.707107        0
1:      0       0
2:      0       0
3:      0.707107        0
</code></pre>

<hr>

<p>Note that this does not allow you to implement the <code>GetProbabilityAmplitude()</code> function which you requested. If you are running a Q# program on a simulator, it will let you see the wave function but it will not let you make any decisions <em>in the program</em> based on that information. The intent is twofold: to facilitate debugging on a simulator while not allowing to implement any logic which would be impossible to execute on a quantum computer. Since the execution on a quantum computer won't give the program direct access to the quantum state, it's better not to rely on this feature in the code.</p>
",09/03/2018 05:06,Tooling,"The reason is that the query is asking about how to use a specific tool, Q#, to obtain amplitude information for a particular qubit register. The user is specifically interested in a way to do this in lexicographic ordering.",Tooling,,,,Tooling,
4210.0,"How to deal with -LookupError: backend ""ibmqx4"" is not found?","<p>I am using Jupyter notebook to write and running my qiskit codes (python 3.6)
and every time I encounter the message: LookupError: backend ""ibmqx4"" is not found, right now the ibmqx4 computer is not in maintenance and it running well.</p>

<p>I tried to regenerate Apitoken in the advanced option and make correspondingly the file Qconfig.py but the message still appears.</p>

<p>look at the example for a code that I write:</p>

<pre><code>import numpy as np
import matplotlib.pyplot as plt
import qiskit as qk
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, register


import Qconfig



    batch = []
n=50
t=450
// we defining n similar quantum circuits
for j in range(1,n+1):
    q = QuantumRegister(1)
    c = ClassicalRegister(1)
    qc = QuantumCircuit(q, c)
    qc.x(q)
    qc.barrier()


// we decide the pausing time of the system be t*Gate Time
    for i in range(t):
        qc.iden(q)
    qc.measure(q,c)    
   //we append every circuit we create to batch so batch is like a list of n 
  circuits
    batch.append(qc)

// we executing all the n circuits and for each we run 1024 shots
shots = 1024
job = execute(qc,'ibmqx4',shots=shots)
</code></pre>

<p>and I get the output from the last row:</p>

<pre><code>---------------------------------------------------------------------------
LookupError                               Traceback (most recent call last)
&lt;ipython-input-38-a89f2171589f&gt; in &lt;module&gt;()
      1 # we executing all the n circuits and for each we run 1024 shots
      2 shots = 1024
----&gt; 3 job = execute(qc,'ibmqx4',shots=shots)

~\Anaconda3\envs\QISKit\lib\site-packages\qiskit\wrapper\_wrapper.py in execute(circuits, backend, config, basis_gates, coupling_map, initial_layout, shots, max_credits, seed, qobj_id, hpc, skip_transpiler)
    270     # pylint: disable=missing-param-doc, missing-type-doc
    271     if isinstance(backend, str):
--&gt; 272         backend = _DEFAULT_PROVIDER.get_backend(backend)
    273     qobj = compile(circuits, backend,
    274                    config, basis_gates, coupling_map, initial_layout,

~\Anaconda3\envs\QISKit\lib\site-packages\qiskit\wrapper\defaultqiskitprovider.py in get_backend(self, name)
     29 
     30     def get_backend(self, name):
---&gt; 31         name = self.resolve_backend_name(name)
     32         for provider in self.providers:
     33             try:

~\Anaconda3\envs\QISKit\lib\site-packages\qiskit\wrapper\defaultqiskitprovider.py in resolve_backend_name(self, name)
    218 
    219         if resolved_name not in available:
--&gt; 220             raise LookupError('backend ""{}"" not found.'.format(name))
    221 
    222         return resolved_name

LookupError: backend ""ibmqx4"" not found.
</code></pre>

<p>please help me to solve this repetitive bug...</p>
",<programming><qiskit><error-correction><ibm-q-experience>,09/12/2018 07:47,4214.0,4214.0,"<p>I got it, there is need to add two codes :</p>

<p>the first one in the begining before starting programming:</p>

<pre><code>import  sys,,  time,,  getpass
try:
    sys.path.append(""../../"") # go to parent dir
    import Qconfig
    qx_config = {
        ""APItoken"": Qconfig.APItoken,
        ""url"": Qconfig.config['url']}
    print('Qconfig loaded from %s.' % Qconfig.__file__)
except:
    APItoken = getpass.getpass('Please input your token and hit enter: ')
    qx_config = {
        ""APItoken"": APItoken,
        ""url"":""https://quantumexperience.ng.bluemix.net/api""}
    print('Qconfig.py not found in qiskit-tutorial directory; Qconfig loaded using user input.')
</code></pre>

<p>the second one is before execution:</p>

<pre><code>register(qx_config['APItoken'], qx_config['url'])
</code></pre>

<p>hope I helped anyone with similar error!</p>
",09/12/2018 10:31,Errors,"The user is encountering a specific error message related to the unavailability of the ""ibmqx4"" backend when attempting to execute Qiskit code. The error likely stems from the backend not being recognized or properly configured, leading to a lookup failure during execution.", Errors,,,,Errors,
4223.0,How to measure in an arbitrary basis in Q#?,"<p>Q# has a measurement operator defined as follows according to the <a href=""https://docs.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.primitive.measure"" rel=""nofollow noreferrer"">docs</a>:</p>

<p><code>operation Measure (bases : Pauli[], qubits : Qubit[]) : Result</code></p>

<p>Where you give a Pauli gate $\{I, \sigma_x, \sigma_y, \sigma_z\}$ as a measurement operator and the qbit is projected onto its eigenvectors.</p>

<p>How can I measure in an arbitrary basis? I know conceptually what I have to do is first rotate my state vector by some amount then measure in one of the Pauli bases, but what are the actual primitive gates and parameters I would use to do that? For example, say I wanted to measure in the following basis:</p>

<p>$\begin{bmatrix} \frac{\sqrt{3}}{2} \\ \frac 1 2 \end{bmatrix}, \begin{bmatrix} \frac{-1}{2} \\ \frac{\sqrt{3}}{2} \end{bmatrix}$</p>

<p>So basically the computational basis but rotated $\pi/6$ radians counter-clockwise around the unit circle.</p>
",<programming><measurement><q#>,09/12/2018 23:15,4225.0,4225.0,"<p>Let's say you want to distinguish two states: </p>

<p><span class=""math-container"">$$|A\rangle = \cos \alpha |0\rangle + \sin \alpha |1\rangle \\ 
  |B\rangle = -\sin \alpha |0\rangle + \cos \alpha |1\rangle$$</span></p>

<p>For your particular example <span class=""math-container"">$\cos \alpha = \frac {\sqrt{3}}{2}$</span> and <span class=""math-container"">$\sin \alpha = \frac{1}{2}$</span>, so <span class=""math-container"">$\alpha = \frac{\pi}{6}$</span>.</p>

<p>These states are orthogonal and can be obtained from <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> by rotating around Y axis, i.e. by applying <code>Ry(2.0 * alpha, _)</code>. You can verify it using the definition of the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.ry"" rel=""nofollow noreferrer"">Ry operation</a> and matrix exponentiation.</p>

<p>Thus, one way to measure the states <span class=""math-container"">$|A\rangle$</span> and <span class=""math-container"">$|B\rangle$</span> is to apply adjoint operation <code>Ry(-2.0 * alpha, _)</code> to your qubit to get those states back to <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span>, and then to measure the qubit in the computational basis using operation <code>M</code> (or <code>Measure([PauliZ], _)</code>).</p>

<p>In more general case you'd use other rotation operations (<code>Rx</code> and <code>Rz</code>) to perform the exact rotation which converts your basis states to computational basis before measuring them.</p>

<hr>

<p>This question is effectively task 1.4 from <a href=""https://github.com/Microsoft/QuantumKatas/tree/master/Measurements"" rel=""nofollow noreferrer"">the Measurements quantum kata</a>, if you want to practice it in Q# (as well as more advanced measurement scenarios).</p>
",9/13/2018 0:31,Theoretical,"The user's question pertains to a theoretical aspect of quantum programming. They are seeking guidance on how to perform measurements in an arbitrary basis in Q#, involving rotations of qubit states and choosing appropriate primitive gates and parameters for the rotation operation.",Theoretical,,,,Theoretical,
4268.0,"How to construct the ""Inversion About the Mean"" operator?","<p>It seems like it should be simple, based on how Nielsen and Chuang talk about it, but I cannot seem to correctly implement the Inversion About the Mean operator (<span class=""math-container"">$2|\psi\rangle \langle\psi| - \mathcal{I}$</span>) that is used in the Grover search algorithm, especially without using any ancilla bits. </p>

<p>I thought about performing a NOT operation on all the working qubits, then performing a controlled-NOT on a separate toggle qubit with the control being all the working qubits, then performing a controlled phase flip with control of the toggle bit, and finally flipping the phase of all the states. I'm not sure how I'd actually implement the controlled phase flipping, though, since, I believe, phase flipping one or all of the bits would not produce the desired effect.</p>

<p>Does anyone know how I can construct this? I am using Q#, by the way, if you'd like to answer in code.</p>
",<programming><q#>,9/22/2018 21:31,4269.0,4269.0,"<p>First, let's represent operation <span class=""math-container"">$2|\psi\rangle \langle\psi| - \mathcal{I}$</span> as <span class=""math-container"">$H^{\otimes n}(2|0\rangle \langle0| - \mathcal{I})H^{\otimes n}$</span>, as Nielsen and Chuang do. </p>

<p>Doing <span class=""math-container"">$H^{\otimes n}$</span> is easy - it's just <code>ApplyToEach(H, register)</code>.</p>

<p><span class=""math-container"">$2|0\rangle \langle0| - \mathcal{I}$</span> flips the phase of all computational basis states except <span class=""math-container"">$|0...0\rangle$</span>. Let's do instead <span class=""math-container"">$\mathcal{I} - 2|0\rangle \langle0|$</span>, flipping the phase of only <span class=""math-container"">$|0...0\rangle$</span> (it introduces a global phase of -1 which in this case I think can be ignored).</p>

<p>To flip the phase of only <span class=""math-container"">$|0...0\rangle$</span>:</p>

<ul>
<li>flip the state of all qubits using <code>ApplyToEach(X, register)</code>. Now we need to flip the phase of only <span class=""math-container"">$|1...1\rangle$</span> state.</li>
<li>do a controlled-Z gate on one of the qubits (for example, the last one), using the rest as control. This can be done using <code>Controlled</code> functor: <code>(Controlled Z)(Most(register), Tail(register))</code>. <code>Tail</code> returns the last element of the array, and <code>Most</code> returns all elements except the last one.</li>
<li>flip the state of all qubits again to return them to the original state.</li>
</ul>
",9/22/2018 23:57,Learning,"The user is trying to implement the Inversion About the Mean operator used in the Grover search algorithm and is seeking help with their implementation in Q#, which falls under the category of Learning in quantum software engineering. The response provides an example implementation of this operator in Q# and explains how it works. This falls under the Learning category as it involves acquiring knowledge about quantum computing and quantum programming languages.", Learning,,,,Learning,
4311.0,How do I construct a Density Matrix corresponding to a Hamiltonian?,"<p>I have a Hamiltonian and I want to know the corresponding density matrix. The matrix I'm interested in is the one in <a href=""https://quantumcomputing.stackexchange.com/questions/4306/why-is-this-hamiltonian-matrix-diaongal/"">this question</a>.</p>
",<quantum-state><programming><density-matrix><hamiltonian-simulation>,9/30/2018 11:19,4312.0,4312.0,"<p>There's many different density matrices that can correspond to a given Hamiltonian. </p>

<hr>

<p>For the 8x8 matrix in your question, there's 8 different ""eigenstate"" density matrices that can be obtained, one for each of the 8 eigenvectors. The density matrices are constructed by doing the outer product of the eigenvectors. For the <span class=""math-container"">$i^{\rm{th}}$</span> eigenstate of the Hamiltonian, the density matrix <span class=""math-container"">$\rho_i$</span> is:</p>

<p><span class=""math-container"">$
\rho_i = |\psi_i\rangle_ \langle \psi_i|
$</span>.</p>

<hr>

<p>A system can also be in a ""pure"" superposition of eigenstates, for example:</p>

<p><span class=""math-container"">$|\psi \rangle = \frac{1}{\sqrt{2}}|\psi_1\rangle + \frac{1}{\sqrt{2}}|\psi_2\rangle $</span>.</p>

<p>Then the density matrix is once again made by doing the outer product of the pure wave function <span class=""math-container"">$|\psi\rangle$</span> with itself.</p>

<hr>

<p>A system can also be in a ""mixed"" state, which means it's a linear combination of ""pure"" states.</p>

<p>In this case you would construct the density matrix like this (for example):</p>

<p><span class=""math-container"">$\rho = 0.5 \rho_1 + 0.5\rho_2$</span>,</p>

<p>which descrbes a state which is a 50% mixture of <span class=""math-container"">$\rho_1$</span> and a 50% mixture of <span class=""math-container"">$\rho_2$</span>.</p>
",9/30/2018 11:44,Theoretical,"Theoretical questions are related to the principles, algorithms, and concepts of quantum computing. In this case, user asking about how to obtain the density matrix corresponding to a given Hamiltonian matrix .",Theoretical,,,,Theoretical,
4367.0,"How to make ""random U3"" in QASM?","<p>I want to make an operator:</p>

<p><span class=""math-container"">$\mathrm{U3}(\arccos(\sqrt p),0,0)$</span>, when <span class=""math-container"">$p$</span> is a random value between <span class=""math-container"">$0$</span> and <span class=""math-container"">$1$</span></p>

<p>How do I write code in QASM language of this ""random <span class=""math-container"">$\mathrm{U3}$</span>"" operator?</p>
",<programming><qasm>,10/07/2018 16:27,4376.0,4376.0,"<p>There are many forms of QASM, so I'll answer for OpenQASM 2.0, as is currently used by IBM.</p>

<p>Declaring a gate to be random means that it would be randomly generated at compile time. Since QASM is used as an expression of a compiled circuit, such randomness must be resolved by the time the QASM is created.</p>

<p>It is true that are transpilation processes in the IBM stack, which convert a user generated QASM into one optimized for the needs of a given device. This could allow for the functionality your desire to be built into future versions. But I doubt that will be the case. It is much easier just to use randomness when generating the QASM, such as with Pythons random number generation when creating circuits with Qiskit.</p>

<p><em>Disclaimer: I work for IBM.</em></p>
",10/09/2018 08:41,API Usage ,"API usage questions are related to how to correctly and effectively use APIs in quantum programming. In this case, userasking about how to write code in QASM language for a random U3 operator with a parameter p between 0 and 1 .",API Usage,,,,API Usage ,
4471.0,Q# How to use a namespace in another project?,"<p>I have some utility operations that I'd like to use across projects. How can I import its namespace using Q# in Visual Studio 2017 in other projects?</p>
",<programming><q#>,10/21/2018 18:26,4474.0,4474.0,"<p>First, you need to add the project which contains the utility operations as a reference to the project which will be using them. If you're using Visual Studio Code or command line, you can use <a href=""https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-add-reference"" rel=""nofollow noreferrer"">dotnet add reference</a> command to do that, and in Visual Studio you can use <a href=""https://docs.microsoft.com/en-us/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager"" rel=""nofollow noreferrer"">Reference Manager</a>.</p>

<p>Second, you need to open the namespace which contains the utility operations in each Q# file which uses them. To do this, add an <code>open</code> statement after the declaration of the namespace and before definition of any functions or operations:</p>

<pre><code>namespace ProjectNamespace {
    open Utilities;

    // you can use operations defined in Utilities namespace now
}
</code></pre>
",10/21/2018 19:45,API Usage,"In this case, user asking about how to import a namespace containing utility operations in Q# using Visual Studio 2017 for use in other projects .",Tooling,"The user is asking about how to import a namespace using Q# in Visual Studio 2017, which falls under the category of Tooling in quantum software engineering.",No,71.0,Tooling,"The user is seeking guidance on how to import a namespace in Q# using Visual Studio 2017, which specifically relates to the tools and development environment for quantum programming."
4531.0,Can we speed up the Grover's Algorithm by running parallel processes?,"<p>In classical computing, we can run the key search (for example AES) by running parallel computing nodes as many as possible.</p>

<p>It is clear that we can run many Grover's algorithms, too.</p>

<p><strong>My question is</strong>; it possible to have a speed up using more than one Grover's algorithm as in classical computing?</p>
",<classical-computing><grovers-algorithm><cryptography>,10/24/2018 20:06,4538.0,4538.0,"<p>Certainly! Imagine you have <span class=""math-container"">$K=2^k$</span> copies of the search oracle <span class=""math-container"">$U_S$</span> that you can use. Normally, you'd search by iterating the action
<span class=""math-container"">$$
H^{\otimes n}(\mathbb{I}_n-2|0\rangle\langle 0|^{\otimes n})H^{\otimes n}U_S,
$$</span>
starting from an initial state <span class=""math-container"">$(H|0\rangle)^{\otimes n}$</span>. This takes time <span class=""math-container"">$\Theta(\sqrt{N})$</span>. (I'm using <span class=""math-container"">$\mathbb{I}_n$</span> to denote the <span class=""math-container"">$2^n\times 2^n$</span> identity matrix.)</p>

<p>You could replace this with <span class=""math-container"">$2^k$</span> parallel copies, each indexed by an <span class=""math-container"">$x\in\{0,1\}^k$</span>, using
<span class=""math-container"">$$
\left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)\mathbb{I}_k\otimes(\mathbb{I}_{n-k}-2|0\rangle\langle 0|^{\otimes (n-k)})\left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)U_S
$$</span>
and starting from a state <span class=""math-container"">$|x\rangle(H|0\rangle)^{\otimes(n-k)}$</span>
The time required for running these would be reduced to <span class=""math-container"">$O(\sqrt{N/K})$</span>, at the cost of requiring <span class=""math-container"">$K$</span> times more space.</p>

<p>In a scaling sense, one might consider this an irrelevant result. If you have a fixed number of oracles, <span class=""math-container"">$K$</span>, then you get a fixed (<span class=""math-container"">$\sqrt{K}$</span>) improvement (just like, if you have <span class=""math-container"">$K$</span> parallel classical cores, the best improvement you can get is a factor of <span class=""math-container"">$K$</span>), and that does not change the scaling. But it does change the fundamental running time. We know that Grover's algorithm is exactly optimal. It takes the absolute minimum time possible with a single oracle. So, knowing that you get a <span class=""math-container"">$\sqrt{K}$</span> improvement in time is useful with regards to that benchmark of a specific running time at a specific value of <span class=""math-container"">$N$</span>.</p>
",10/25/2018 8:02,Theoretical,"In this case, user asking about the possibility of speeding up Grovers algorithm using multiple parallel computing nodes .",Theoretical,,,,Theoretical,
4569.0,Could we use varying voltage with programmable gates?,"<p>One of the benefits I'm reading about qubits is that they can be in an infinite number of states. I'm aware of Holevo's bound (even though I don't fully understand it). However, it made me think of why we haven't tried varying voltage on classical computers and have programmable gates to control what passes in terms of a voltage. In that way, we could simulate quantum computing more closely.</p>
",<quantum-state><simulation><classical-computing>,10/30/2018 0:46,4570.0,4570.0,"<p>This reminds me of another question we had here: <a href=""https://quantumcomputing.stackexchange.com/questions/2225/whats-the-difference-between-a-set-of-qubits-and-a-capacitor-with-a-subdivided"">What&#39;s the difference between a set of qubits and a capacitor with a subdivided plate?</a></p>

<p>Let me try to answer your question separately though:</p>

<blockquote>
  <p>One of the benefits I'm reading about qubits is that they can be in an
  infinite number of states.</p>
</blockquote>

<p>Yes, qubits don't have to be in state 0 or state 1, but can be in an infinite number of states represented by something called the Bloch sphere. However, while it  <strong><em>sounds</em></strong> impressive that you can be in an <strong><em>infinite</em></strong> number of states, this alone is not what gives quantum computers their full  power!</p>

<p>Indeed, an analog classical computer can be in an infinite number of states too.</p>

<p>In order to really get the full power of a quantum computer, you need at least 2 qubits. The pair of qubits can exist in a state that no digital <strong><em>or</em></strong> analog classical computer can be in, which is a mixture of being in (0,0) and (1,1) at the same time. I explained this in my answer to that previous question:  <a href=""https://quantumcomputing.stackexchange.com/a/2226/2293"">What's the difference between a set of qubits and a capacitor with a subdivided plate?</a></p>

<blockquote>
  <p>I'm aware of Holevo's bound (even though I don't fully understand it).</p>
</blockquote>

<p>If you have a specific question on Holevo's theorem, or Ashwin Nayak's generalization of it, I'm sure you'll get an answer if you ask that as a separate question here :)</p>

<blockquote>
  <p>However, it made me think of why we haven't tried varying voltage on classical computers and have programmable gates to control what passes in terms of a voltage. </p>
</blockquote>

<p>I suppose you are suggesting this because voltage can be in any state between, for example, 0V and 20V (i.e. can be 0, or 1, or anything in between, like  maybe 0.5 would be 10V). Qubits can also be in an infinite number of states other than 0 or 1, but that is not what gives them their full power. The power comes from how two qubits can interact. </p>

<p>If you have a pair of voltage-based bits, can the pair be in a state where the two bits are 0 and the two bits are also 1, at the same time? </p>

<p>You can have the two bits being in the states:<br>
(0V, 0V), or <br>
(0V, 20V), or <br>
(20V, 0V), or <br>
(20V, 20V), or, since you want to allow an infinite number of voltages, <br>
(15V, 12.3V), <br></p>

<p>but you cannot have:
<span class=""math-container"">$\frac{1}{\sqrt{2}}\left[(0\rm{V},0\rm{V}) + (20\rm{V},20\rm{V})\right]$</span></p>

<p>which means you're both in the (0V,0V) state and the (20V,20V) state at the same time (like Schrodinger's cat is alive and dead at the same time).</p>

<p><strong>In conclusion</strong>: Even the ability to be in an infinite number of different states (like in analog classical computing), is not enough to do what a quantum computer can do!</p>
",10/30/2018 2:03,Conceptual,"The user is contemplating the concept of using varying voltage on classical computers to simulate quantum computing, which involves understanding high-level quantum computing concepts and their potential implementation.",Conceptual,,,,Conceptual,
4669.0,"Why do $n$ inputs to a ket give a vector of dimension $(2^n,1)$?","<p>NB - notation from Octave. </p>

<p>I understand that </p>

<pre>
ket([0]) 
</pre>

<p>is the <span class=""math-container"">$(1,0)$</span> in a <span class=""math-container"">$(x,y)$</span> plane. </p>

<p>But when I try a ket with three numbers I get a column vector of dimension <span class=""math-container"">$(8,1)$</span>. I assume that comes from <span class=""math-container"">$2^3=8$</span> ie there are <span class=""math-container"">$2^n$</span> states for <span class=""math-container"">$n$</span> variables in the ket.</p>

<p>But how is that understood in terms of a vector space? I have seen the algebra online but that has not really explained how the vector space can be envisioned. I am mainly trying to relate a column position to a physical characteristic or at least explain why that size would exist.   </p>

<pre>
octave:27> ket([0,1])
ans =

   0
   1
   0
   0

octave:28> ket([0,1,1])
ans =

   0
   0
   0
   1
   0
   0
   0
   0

</pre>
",<quantum-state><programming>,11/10/2018 06:50,4671.0,4671.0,"<p>First, read my <a href=""https://quantumcomputing.stackexchange.com/a/92/26"">previous answer</a> on what the bra-ket notation means. Now proceed:</p>

<p>In your post, <code>ket([0])</code> stands for <span class=""math-container"">$|0\rangle$</span>, <code>ket([0,1])</code> stands for <span class=""math-container"">$|0\rangle\otimes |1\rangle = |01\rangle$</span> and <code>ket([0,1,1])</code> stands for <span class=""math-container"">$|0\rangle\otimes |1\rangle \otimes |1\rangle = |011\rangle$</span>. </p>

<p>The computational basis states of a single qubit are <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span>. </p>

<p>The computational basis states of a <span class=""math-container"">$2$</span>-qubit system are <span class=""math-container"">$|00\rangle, |01\rangle, |10\rangle$</span> and <span class=""math-container"">$|11\rangle$</span>. Basically, take all <span class=""math-container"">$2$</span>-digit permutations of <span class=""math-container"">$0$</span> and <span class=""math-container"">$1$</span>. That is the first qubit can be in state <span class=""math-container"">$|0\rangle$</span> and second can be in <span class=""math-container"">$|0\rangle$</span> too; the first can be in <span class=""math-container"">$|0\rangle$</span> while the second is in <span class=""math-container"">$|1\rangle$</span> and so on. So as you see, a <span class=""math-container"">$2$</span>-qubit system resides in a <span class=""math-container"">$4$</span>-dimensional complex vector space <span class=""math-container"">$\Bbb C^4$</span> (as it has four basis states). </p>

<p>Now you might be confused because you think a <span class=""math-container"">$2$</span>-qubit system can also exist in some state like <span class=""math-container"">$(a|0\rangle+b|1\rangle)\otimes (c|0\rangle + d|1\rangle)$</span> where <span class=""math-container"">$a,b,c,d \in \Bbb C$</span> . Sure, but even then you can express such a state as a linear combination of the elements of <span class=""math-container"">$\{|00\rangle, |01\rangle, |10\rangle, |11\rangle\}$</span> i.e. the computational basis set. The size of the
basis set is what defines the dimension of the vector space, that is ""there are <span class=""math-container"">$2^n$</span> states for <span class=""math-container"">$n$</span> variables in the ket"". </p>

<p>The column vectors you speak of are just alternative representations of <span class=""math-container"">$|00\rangle, |01\rangle, |10\rangle$</span> and <span class=""math-container"">$|11\rangle$</span>. Say you could consider 
<span class=""math-container"">$|00\rangle$</span> to be <span class=""math-container"">$\left[\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \end{matrix}\right]^{T}$</span>, <span class=""math-container"">$|01\rangle$</span> to be <span class=""math-container"">$\left[\begin{matrix} 0 &amp; 1 &amp; 0 &amp; 0 \end{matrix}\right]^{T}$</span>, <span class=""math-container"">$|10\rangle$</span> to be <span class=""math-container"">$\left[\begin{matrix} 0 &amp; 0 &amp; 1 &amp; 0 \end{matrix}\right]^{T}$</span> and <span class=""math-container"">$|11\rangle$</span> to be <span class=""math-container"">$\left[\begin{matrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{matrix}\right]^{T}$</span>. You're basically mapping the computational basis states of a <span class=""math-container"">$2$</span>-qubit system to the standard basis of <span class=""math-container"">$\Bbb R^4$</span>. </p>

<p>Now can you do a similar analysis for a <span class=""math-container"">$3$</span>-qubit system?</p>
",11/10/2018 09:44,Conceptual,"The question primarily seeks an explanation of the mathematical concept of ket notation in the context of quantum computing and its relation to vector spaces. It focuses on understanding the theoretical underpinnings of quantum computing, making ""Conceptual"" the most appropriate category.",Conceptual,,,,Conceptual,
4730.0,Quantum counting in Q#,"<p>I cannot seem to get an estimate for the number of solutions using the quantum counting algorithm described in Nielsen and Chuang, i.e. phase estimation with the Grover iteration acting as <span class=""math-container"">$U$</span>.</p>

<p>I try doing the following with <code>control</code> and <code>target</code> as allocated qubit registers:</p>

<pre><code>let controlBE = BigEndian(control);
let ancilla = target[0];

X(ancilla);
ApplyToEachCA(H, control + target);
for (i in 0..Length(control) - 1) {
    Controlled GroverPow([control[Length(control) - 1 - i]], (2 ^ i, target));
}
Adjoint QFT(controlBE);

let fiBE = MeasureInteger(controlBE);
let numSolutionsD = PowD(Sin(ToDouble(fiBE) / 2.0), 2.0) * ToDouble(2 ^ Length(inputQubits));

Message(""numSolutions: "" + Round(numSolutionsD));
</code></pre>

<p>My <code>GroverPow</code> is a discrete oracle that is supposed to perform the Grover iteration to the power defined by the given integer.</p>

<pre><code>operation GroverPow(power: Int, qubits: Qubit[]): Unit {
    let ancilla = qubits[0];
    let inputQubits = qubits[1..Length(qubits) - 1];
    let aug = Tail(inputQubits);
    let ans = Most(inputQubits);

    for (i in 1..power) {
        Oracle(ans, database, ancilla, aug);  // Grover iteration
        ApplyToEachCA(H, inputQubits);
        ApplyToEachCA(X, inputQubits);
        Controlled Z(Most(inputQubits), Tail(inputQubits));
        ApplyToEachCA(X, inputQubits);
        ApplyToEachCA(H, inputQubits);
    }
}
</code></pre>

<p>This just doesn't give the correct answer, even when I have the oracle do absolutely nothing. Is there an obvious bug that I'm missing? I've tried using various combinations of my home-grown functions as well as the built-in <code>AmpAmpByOracle</code> and <code>QuantumPhaseEstimation</code> functions and various initial/target states but to no avail. I've tried absolutely everything I can think of, and am almost starting to get suspicious of the validity of this algorithm...obviously it's sound but that's where I'm at! Just doesn't seem to work.</p>
",<algorithm><programming><q#>,11/15/2018 23:21,6447.0,6447.0,"<p>Looking at the implementation of <code>GroverPow</code> only, it seems that the issue might be the same as in <a href=""https://quantumcomputing.stackexchange.com/questions/5973/counting-in-q-number-of-solutions"">this question</a>, though implemented in a slightly different way. </p>

<p>This section of the code</p>

<pre><code>ApplyToEachCA(X, inputQubits);
Controlled Z(Most(inputQubits), Tail(inputQubits));
ApplyToEachCA(X, inputQubits);
</code></pre>

<p>implements conditional phase shift by flipping the phase only for the <span class=""math-container"">$|0...0\rangle$</span> state. This yields a global phase difference of -1 compared to Nielsen and Chuang presentation which flips phase of all states except for the <span class=""math-container"">$|0...0\rangle$</span> state. This is detected by phase estimation algorithm, so that quantum counting ends up reporting the number of solutions equal to <span class=""math-container"">$N - M$</span> instead of just <span class=""math-container"">$M$</span> (I did the detailed math in <a href=""https://quantumcomputing.stackexchange.com/questions/5973/counting-in-q-number-of-solutions/6446#6446"">my answer</a>).</p>
",6/14/2019 0:31,Errors,"The user is encountering an issue with their quantum counting algorithm and is seeking a solution or explanation for why it's not producing the correct results. This falls under the ""Errors"" category as it involves debugging and troubleshooting a specific problem in quantum programming.",Errors,,,,Errors,
4749.0,Measuring the Hamiltonian in the VQE,"<p>I am trying to implement VQE in pyQuil and am dumbfounded by how to measure the expectation value of a general Hamiltonian on <span class=""math-container"">$\mathbb{C}^{2^n}$</span> i.e. determine <span class=""math-container"">$\langle\psi , H \psi\rangle$</span> on a Quantum computer. As far as I understand on a real Quantum Computer (not any quantum virtual machine) I can only measure in the computational basis, which is the basis of the Hamiltonian <span class=""math-container"">$H = X = \sum x \left|x\right&gt;\left&lt;x\right|$</span>, but not for any Hamiltonian whose eigenvectors are not the computational basis. But how do I measure with any Hamiltonian that is not diagonal in the computational basis?</p>

<p>Sure I can measure e.g. some of the qubits in the <span class=""math-container"">$X$</span>-basis instead of the <span class=""math-container"">$Z$</span>-basis by applying a Hadamard gate to them, but this surely doesn't help me if I want to measure sth. non-local, i.e. if the ground-state of my hamiltonian is an entangled state.</p>

<p>On a maybe related note: Can I write any hamiltonian (hermitian matrix) as a Pauli decomposition? I know I can for a single qubit, but does this hold for multiqubits aswell?</p>
",<programming><gate-synthesis><pyquil>,11/17/2018 16:34,5042.0,5042.0,"<p>Yes, you can decompose any Hamiltonian. For VQE purposes, any finite-dimensional Hamiltonian can be presented as a sum of terms which consist of tensor products of Pauli matrices (<a href=""https://arxiv.org/abs/1304.3061"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1304.3061</a>):</p>

<p><span class=""math-container"">$$
H = \sum_{\alpha, i} h^{\alpha}_{i} \sigma^{\alpha}_{i} + 
\sum_{\alpha, \beta, i, j} h^{\alpha \beta}_{ij} \sigma^{\alpha}_{i} \sigma^{\beta}_{j} + \dots
$$</span></p>

<p>As such, the expected value <span class=""math-container"">$ \langle H \rangle$</span> can be estimated by measuring the expected values of such combinations of Pauli matrices. There may be trouble if the quantity of these terms grows exponentially in the size of the system, but many interesting Hamiltonians decompose into a polynomial number of operators.</p>

<p>The coefficients of the decomposition can be obtained by making a scalar product of the Hamiltonian with the basis term: <span class=""math-container"">$(H, A) = \frac1d \mathrm{Tr}(HA)$</span>.</p>
",12/24/2018 17:56,Conceptual,The user is seeking a conceptual understanding of how to measure the expectation value of a general Hamiltonian on a quantum computer and is inquiring about the possibility of representing any Hamiltonian as a Pauli decomposition. This question involves understanding the theoretical concepts and principles in quantum computing rather than practical coding or debugging issues.,Conceptual,,,,Conceptual,
4810.0,Implementing gate with two parameters using Qiskit in Python,"<p>I am trying to implement the HHL algorithm (for solving <span class=""math-container"">$Ax=b$</span>). I am assuming <span class=""math-container"">$A$</span> to be unitary and Hermitian so that I can find the Hamiltonian simulation for it easily. 
For any <span class=""math-container"">$A$</span> to be Hermitian and unitary, it has to be of form,
<span class=""math-container"">$$ A = \begin{pmatrix} x &amp; \pm\sqrt{1-x^2}\\ \pm\sqrt{1-x^2} &amp; x\end{pmatrix} $$</span>
I reduced <span class=""math-container"">$e^{i\alpha A}$</span> to following (by using formula <span class=""math-container"">$e^{i\theta A} = (\cos\theta)I + i(\sin\theta)A$</span> where <span class=""math-container"">$A^2=I$</span>), but I don't know how to implement it on Qiskit.
<span class=""math-container"">$$ e^{i\alpha A} = \begin{pmatrix} \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} &amp; i\sin\alpha \sin\frac{\theta}{2} \\ i\sin\alpha \sin\frac{\theta}{2} &amp; \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} \end{pmatrix} .$$</span>
where <span class=""math-container"">$\theta = 2\cos^{-1}{x}$</span>. How to construct this gate?</p>
",<quantum-gate><programming><qiskit><gate-synthesis><hhl-algorithm>,11/26/2018 12:57,4812.0,4812.0,"<p>(Remark: I have corrected a typo in the matrix exponentiation). </p>

<p>Please notice that the matrix has the form:</p>

<p><span class=""math-container"">$$ e^{i\alpha A} = \begin{pmatrix} a  &amp; b \\ b &amp; a \end{pmatrix} $$</span>
with
<span class=""math-container"">$$|a|^2 + |b|^2 = 1$$</span>
Now, please notice that this matrix can be expanded as:
<span class=""math-container"">$$\begin{pmatrix} a  &amp; b \\ b &amp; a \end{pmatrix}  = \begin{pmatrix} e^{i \arg(a)}  &amp; 0 \\ 0 &amp; e^{i \arg(a)}  \end{pmatrix}   \begin{pmatrix} |a | &amp; i|b| \\ i|b |&amp; |a| \end{pmatrix}    $$</span>
Defining
<span class=""math-container"">$$ |a| = \cos \phi$$</span>
<span class=""math-container"">$$ |b| = \sin \phi$$</span>
Thus we obtain:
<span class=""math-container"">$$ e^{i\alpha A} = e^{i \arg(a) I_2}  e^{i\phi \sigma_x}   $$</span>
In short, the result constitutes of an overall phase multiplication and an  <span class=""math-container"">$R_x$</span> gate.</p>

<p>Expressed in the question's original variables:
<span class=""math-container"">$$\arg(a) = \arctan (\tan \alpha \cos \frac{\theta}{2})$$</span>
and
<span class=""math-container"">$$\phi = \arcsin (\sin \alpha \sin \frac{\theta}{2})$$</span></p>
",11/26/2018 14:19,Tooling,"  The user is asking about how to implement a specific gate in Qiskit, which falls under the category of questions related to tools and software usage in quantum programming",Tooling,,,,Tooling,
4897.0,Is it possible to expand/merge different circuits?,"<p>Suppose I have created a circuit composed of some registers with the usual</p>

<pre><code>qc = QuantumCircuit(qr, cr)
</code></pre>

<p>where <code>qr</code> and <code>cr</code> are a quantum register and a classical register respectively.</p>

<p>Now, suppose that at this point I want to invoke a subroutine. This subroutine, however, uses some ancillas. Is there any functions to append this new set of qubits to the original circuit? Something like</p>

<pre><code>ancillas = QuantumRegister(n, 'ancillas')
#qc.append(ancillas)    
</code></pre>

<p>An equivalent problem (maybe) is the following one. Suppose I have a quantum circuit <code>qcn</code> composed of <code>n</code> qubits and a subroutine which returns another quantum circuit <code>qck</code> operating on <code>k</code> qubits, with <code>k &gt; n</code>. Is it possible to compose the two circuits in such a way that the first <code>n</code> qubits on which the subroutine operates are the same of the original circuit?</p>

<p>At the moment, the only solution to me seems to declare in advance all the total number of qubits required (<code>k</code> in the previous case) and then passing around them to the various functions.</p>
",<programming><qiskit><ibm-q-experience>,12/09/2018 21:06,4898.0,4898.0,"<p>For the first question, you can use</p>

<pre><code>qc.add(ancillas)
</code></pre>

<p>Note that this will change to <code>add_registers</code> in Qiskit Terra 0.7.0.</p>

<p>Some more guidance on how to combine and extend circuits, you can see <a href=""https://github.com/Qiskit/qiskit-tutorial/blob/master/qiskit/terra/QuantumCircuits.ipynb"" rel=""noreferrer"">this guide</a>. Note that this is for the upcoming 0.7.0 release, but you can already get the functionality with</p>

<pre><code>pip install git+https://github.com/Qiskit/qiskit-terra.git
</code></pre>
",12/09/2018 21:58, Tooling,"The user is asking about specific functions and methods in a quantum computing software (Qiskit), which is related to the usage of tools and software in quantum programming. ", Tooling,,,, Tooling,
4907.0,qiskit - Is there any way to discard the results of a measurement?,"<p>I have a circuit composed by <code>n</code> qubits, plus a single one which is an ancilla. I'm making multiple measurements on the ancilla at different stages of the circuit, while working on the <code>n</code> qubits. These measurements are not really needed at all: they are just a way to collapse the state of the qubit at some point during the computation and then reuse the same qubit in a different way.</p>

<p>At the end of the circuit, when I'm measuring the outcome of the <code>n</code> qubits, I don't want the result of this ancilla to be shown in the output of the <code>get_counts()</code> function; what I want is only the output of the <code>n</code> qubits. Is there any way to achieve this result?</p>
",<circuit-construction><programming><measurement><qiskit>,12/11/2018 10:46,4971.0,4971.0,"<p>If you keep measuring to the same bit, the value should get overridden every time. So you won't receive the intermediary values.</p>

<p>For example, the following will output a single <code>1</code> from the second measurement, with no trace of the first.</p>

<pre><code>from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit
from qiskit import execute
from qiskit import BasicAer

q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q,c)

qc.measure(q,c)
qc.x(q)
qc.measure(q,c)

job = execute(qc,backend=BasicAer.get_backend('qasm_simulator'))
job.result().get_counts()
</code></pre>

<p>I guess what you want is something more like</p>

<pre><code>q = QuantumRegister(n) # n qubits
a = QuantumRegister(1) # one ancilla qubit
c = ClassicalRegister(n) # n classical bits for output

qc = QuantumCircuit(q,a,c)

qc.x(a[0]) 
qc.measure(a[0],c[0]) # measure the ancilla to one of the classical bits

qc.measure(q,c) # measure the n qubits to the n bits (overwriting the output from the previous measurement
</code></pre>
",12/15/2018 17:32,Tooling,"The user is asking about specific functions and methods in a quantum computing software (Qiskit), specifically how to exclude the results of an ancilla qubit from the output of the get_counts() function.",Tooling,,,,Tooling,
4962.0,How to fix? 'E1101:Instance of 'QuantumCircuit' has no 'h' member' and 'E1101:Instance of 'QuantumCircuit' has no 'cx' member',"<p>I'm using this simple code to test my Qiskit and learn how to use it but it keeps giving this problems, how do I fix it (Using VS Code and Anaconda Python 3.7)</p>

<pre><code>import numpy as np
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute
# Create a Quantum Register with 3 qubits.Basicaly creating the number of qubits your system will use
q = QuantumRegister(3, 'q')
# Create a Quantum Circuit acting on the q register. Declaring the Circuit, this circuit shall create a GHZ state
circ = QuantumCircuit(q,)
# Add a H gate on qubit 0, putting this qubit in superposition.
circ.h(q[0])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting
# the qubits in a Bell state.
circ.cx(q[0], q[1])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 2, putting
# the qubits in a GHZ state.
circ.cx(q[0], q[2])
#Draws the circuit
from qiskit.tools.visualization import circuit_drawer
circuit_drawer(circ)
</code></pre>

<p><a href=""https://i.stack.imgur.com/riOVh.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/riOVh.jpg"" alt=""enter image description here""></a></p>
",<programming><qiskit>,12/14/2018 20:14,4969.0,4969.0,"<p>There are no errors in your program.</p>

<p>Pylint is a static code analysis tool and sometimes it gets confused and emits false positives. In this case, gate methods (<code>h</code>, <code>cx</code> and others) are added to <code>QuantumCircuit</code> dynamically at a later point, so Pylint cannot detect them. See <a href=""https://github.com/Qiskit/qiskit-terra/tree/master/qiskit/extensions/standard"" rel=""nofollow noreferrer""><code>qiskit.extensions.standard</code></a> if you'd like to learn how this works.</p>

<p>The simplest âfixâ for this âerrorâ is making Pylint ignore those classes in your <a href=""https://pylint.readthedocs.io/en/latest/user_guide/run.html#command-line-options"" rel=""nofollow noreferrer""><code>pylintrc</code></a> (if your installation of Pylint comes pre-built into your IDE, you'll have to see if the IDE has some particular way of configuring Pylint).</p>

<pre><code>[TYPECHECK]

# List of class names for which member attributes should not be checked (useful
# for classes with dynamically set attributes). This supports the use of
# qualified names.
ignored-classes=QuantumCircuit,CompositeGate
</code></pre>
",12/15/2018 10:59,Errors,The user is encountering an error or exception while running a quantum program in Qiskit and is seeking solutions and explanations for it,Errors,,,,Errors,
4975.0,How do I build a gate from a matrix on Qiskit?,"<p>I'm creating a gate for a project and need to test if it has the same results as the original circuit in a simulator, how do I build this gate on Qiskit? It's a 3 qubit gate, 8x8 matrix:</p>

<p><span class=""math-container"">$$
\frac{1}{2}
\begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; -1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; -1 &amp; -1 &amp; 0 &amp; -1 &amp; 0 \\
1 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1
\end{bmatrix}
$$</span></p>
",<quantum-gate><programming><qiskit><gate-synthesis>,12/16/2018 17:13,5012.0,5012.0,"<p>I don't think Qiskit has this simulation feature. You have to decompose it indeed.</p>

<p>However, there is another way to solve your problem.
To check if a quantum circuit (that you can submit in Qiskit) corresponds to a unitary matrix, you can use the <a href=""https://qiskit.org/documentation/_autodoc/qiskit.backends.aer.unitary_simulator.html"" rel=""nofollow noreferrer"">unitary_simulator</a> backend.</p>

<pre><code># Run the quantum circuit on a unitary simulator backend
backend = Aer.get_backend('unitary_simulator')
job = execute(circ, backend)
result = job.result()
print(np.around(result.get_unitary(circ), 3))
</code></pre>

<p>This will print the unitary matrix that your circuit represents. And you can compare to yours.</p>
",12/19/2018 12:43,Conceptual,The user is asking about how to create a custom 3-qubit gate with a specific 8x8 matrix representation in Qiskit. This question involves understanding the conceptual aspects of creating custom gates and working with their matrix representations in quantum programming rather than practical coding or debugging issues.,Conceptual,,,,Conceptual,
5000.0,Measuring qubits in QuTiP,"<p>How can you measure qubits in QuTiP? </p>

<p>As far as I have seen you can define a Hamiltonian and let it evolve in time. It is also possible to define a quantum circuit, however, measuring and running it is not possible. </p>

<p>Does anyone know how to do this? </p>

<p>A simple circuit could be</p>

<pre><code>H q[0]
CNOT q[0],q[1]
Measure q[0], q[1]
</code></pre>
",<programming><measurement><qutip>,12/18/2018 14:46,5004.0,5004.0,"<p>QuTiP is not really meant for this I think. As said on the home page : </p>

<blockquote>
  <p>QuTiP is open-source software for simulating the dynamics of open quantum systems.</p>
</blockquote>

<p>Simulating dynamics of open quantum systems by definition means you are interested in the quantum state as a result of your algorithm. </p>

<p>I tried looking at the Notebook examples provided in this <a href=""https://github.com/qutip/qutip-notebooks"" rel=""nofollow noreferrer"">Github</a> but could not find measurement examples somewhere.
You have a possibility to get expectation values though (see this <a href=""https://github.com/qutip/qutip-notebooks/blob/master/docs/guide/StatesOperators.ipynb"" rel=""nofollow noreferrer"">notebook</a>). </p>
",12/19/2018 4:23,Tooling ,"The user is asking about how to perform measurements on qubits in QuTiP, which relates to the usage of tools and software for quantum programming.",Tooling,,,,Tooling ,
5043.0,Entanglement in VQE ansatz in Qiskit,"<p>The Qiskit documentation on VQE <a href=""https://qiskit.org/documentation/aqua/variational_forms.html#ry"" rel=""nofollow noreferrer"">describes</a> two of the ansatz as ""rotations with entanglements"". The rotation gates are more or less clear, but the documentation doesn't mention what gate is used for entanglement. I suspect they use something like <span class=""math-container"">$\exp(-i \alpha Z_1 Z_2)$</span>, but what exactly?</p>
",<algorithm><programming><qiskit>,12/24/2018 18:13,5046.0,5046.0,"<p>Looks like the entangler gates are controlled-PHASE gates, at least that is mentioned in the Qiskit <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/qiskit/aqua/chemistry/dissociation_profile_of_molecule.ipynb"" rel=""nofollow noreferrer"">tutorial</a>:</p>

<p><span class=""math-container"">$$
c\text{PHASE} = 
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; i \\
\end{pmatrix}
$$</span></p>

<p>However, in hardware, one also uses the <a href=""https://arxiv.org/pdf/1704.05018.pdf"" rel=""nofollow noreferrer"">drift Hamiltonian</a> <span class=""math-container"">$U_{\text{ENT}}=\exp(-iH_0 \tau)$</span>, which naturally entangles all qubits.</p>
",12/25/2018 12:29,Theoretical,"The user is asking about the theoretical aspects of the Variational Quantum Eigensolver (VQE) algorithm, specifically the type of gate used for entanglement in the ansatz. This involves understanding the theoretical concepts and principles of quantum computing. ",Tooling,"This question pertains to the details of implementing a specific quantum algorithm or methodology within Qiskit. It's about understanding the tool (Qiskit) and its usage, making it fall under the ""Tooling"" category.",No,72.0,Tooling,"The user is asking about the implementation details within Qiskit regarding the gate used for entanglement in the Variational Quantum Eigensolver (VQE) ansatz, which specifically relates to the tools and methodologies used in quantum programming with Qiskit."
5048.0,How many logical qubits are needed to run Shor's algorithm efficiently on large integers ($n > 2^{1024}$)?,"<p>First, I know there are differences in logical qubits and physical qubits. It takes more physical qubits for each logical qubit due to quantum error. </p>

<p>Wikipedia states that it takes quantum <strong>gates</strong> of order <span class=""math-container"">$\mathcal{O}((\log N)^2(\log \log N)(\log \log \log N)$</span> using fast multiplication for Shor's Algorithm. That comes out to <span class=""math-container"">$1,510,745$</span> <strong>gates</strong> for <span class=""math-container"">$2^{1024}$</span>. Further down the article, it says that it usually take <span class=""math-container"">$n^3$</span> gates for <span class=""math-container"">$n$</span> qubits. This would mean it would take ~<span class=""math-container"">$115$</span> qubits.</p>

<p>However, I've run Shor's Algorithm as implemented in Q# samples using Quantum Phase Estimation and it comes out to <span class=""math-container"">$1025$</span> qubits.</p>
",<algorithm><programming><q#><shors-algorithm>,12/25/2018 21:32,5056.0,5056.0,"<p>The question is about how many logical qubits it takes to implement Shor's algorithm for factoring an integer <span class=""math-container"">$N$</span> of bit-size <span class=""math-container"">$n$</span>, i.e., a non-negative integer <span class=""math-container"">$N$</span> such that <span class=""math-container"">$1 \leq N \leq 2^n{-}1$</span>. The question is a poignant one and not easy to answer as there are various tradeoffs possible (e.g., between number of qubits and circuit size). </p>

<hr>

<p><strong>Executive Summary Answer:</strong> <span class=""math-container"">$2n{+}2$</span> qubits which leads to a quantum circuit implementation that has less than <span class=""math-container"">$448 n^3 \log_2(n)$</span> number of <span class=""math-container"">$T$</span>-gates. For a bit-size of <span class=""math-container"">$n=1,024$</span>, this would work out to be <span class=""math-container"">$2050$</span> logical qubits and <span class=""math-container"">$4.81 \cdot 10^{12}$</span> <span class=""math-container"">$T$</span>-gates. </p>

<hr>

<p>As mentioned in the question, one can apply fast methods such as Schoenhage-Strassen's algorithm for fast multiplication to implement the modular arithmetic asymptotically in <span class=""math-container"">$O(n^2 \log(n) \log \log(n))$</span> primitive operations (say, over the Clifford<span class=""math-container"">$+T$</span> gate set). This has been discussed for instance in <a href=""https://arxiv.org/abs/quant-ph/9806084"" rel=""noreferrer"">Zalka's paper</a>. However, it should be pointed out that this is indeed (i) only a statement about asymptotic cost and (ii) only a statement about the number of operations required and does not imply the number of qubits. </p>

<p>Regarding (i), the constant that is hidden in the ""O-notation"" can be prohibitively large. To the best of my knowledge, it has not been attempted to construct a quantum circuit to implement Shor's algorithm based on Schoenhage-Strassen, so we do not even know upper bounds on what that constant is. The other catch, (ii), is that it is not straightforward to relate the number of qubits and the gate cost as seems to be suggested in the question. Besides the fact that we do not know the constant, there is another issue, namely that a straightforward implementation of Schoenhage-Strassen via Bennett's method would lead to a very large number of logical qubits required. Therefore, even as there are faster methods available for integer multiplication than the simple method of n additions, these are much more non-trivial to code in quantum programming languages such as LIQUi|> and Q#. </p>

<p>In terms of concrete resource estimates for Shor's algorithm, the paper by <a href=""https://arxiv.org/abs/1611.07995"" rel=""noreferrer"">Haener et al</a> might be a good entry point which implemented the arithmetic in terms of so-called Toffoli gates which have the advantage of being testable at scale on classical input vectors. It is shown in that paper that <span class=""math-container"">$2n{+}2$</span> logical qubits are sufficient to implement Shor's algorithm for factoring integers using a circuit that uses <span class=""math-container"">$64 n^3 \log_2(n)$</span> Toffoli gates which yields <span class=""math-container"">$448 n^3 \log_2(n)$</span> primitive gates (this latter number refers to the number of <span class=""math-container"">$T$</span>-gates and ignores that number of Clifford gates as these are significantly more easy to implement fault-tolerantly). </p>

<p>The currently available Q# implementation of Shor's algorithm (see the <a href=""https://github.com/Microsoft/Quantum/tree/release/v0.3.1810/Samples/src/IntegerFactorization"" rel=""noreferrer"">IntegerFactorization</a> sample at <a href=""https://github.com/microsoft/quantum"" rel=""noreferrer"">https://github.com/microsoft/quantum</a>) is based on another way of implementing the arithmetic, namely based on <a href=""https://arxiv.org/abs/quant-ph/0008033"" rel=""noreferrer"">Draper's method</a> to implement additions using the Fourier basis, see also <a href=""https://arxiv.org/abs/quant-ph/0410184"" rel=""noreferrer"">here</a>. This implementation follows <a href=""https://arxiv.org/pdf/quant-ph/0205095v3.pdf"" rel=""noreferrer"">Beauregard's paper</a> and requires <span class=""math-container"">$2n{+}3$</span> logical qubits in total. A recent improvement has been obtained by <a href=""https://arxiv.org/abs/1706.07884"" rel=""noreferrer"">Gidney</a> who reduced the number of clean qubits to <span class=""math-container"">$2n{+}1$</span> (of which only <span class=""math-container"">$n{+}2$</span> have to be ""clean"" qubits, i.e., initialized in a known state. The rest can be ""dirty"" qubits that can be used and returned in their (unknown) state). Finally, there is <a href=""https://arxiv.org/pdf/quant-ph/0601097.pdf"" rel=""noreferrer"">an interesting claim</a> by Zalka that the number of qubits can be reduced to <span class=""math-container"">$1.5n{+}2$</span> (and perhaps even further), however, his proposed solution comes at a dramatic increase of circuit size as it involves inversions and, to my knowledge, has not been verified nor implemented in a programmatic way.   </p>
",12/26/2018 19:42,Theoretical ,"The user is discussing the theoretical aspects of Shors Algorithm, specifically the number of quantum gates and qubits required for its implementation. This involves understanding the theoretical concepts and principles of quantum computing.",Errors,"The question is related to understanding discrepancies in the number of qubits used in implementing Shor's Algorithm and highlights a potential error or misunderstanding in the algorithm's implementation, making it fall under the ""Errors"" category.",No,73.0,Errors,"The user is seeking clarification on the discrepancy between the expected number of qubits required for Shor's Algorithm, as indicated by theoretical analysis, and the number obtained from their implementation in Q#, suggesting a potential error or misunderstanding in the implementation."
5070.0,How do I write functions that modify operations in Q#?,"<p>In Q#'s <a href=""https://docs.microsoft.com/en-us/quantum/language/type-model?view=qsharp-preview#operation-and-function-types"" rel=""nofollow noreferrer"">type documentation</a>, it is mentioned that you can create signatures like this:</p>

<pre><code>function ConjugateInvertibleWith : (inner: ((Qubit[] =&gt; Unit) : Adjoint),
                                    outer : ((Qubit[] =&gt; Unit) : Adjoint))
                                 : ((Qubit[] =&gt; Unit) : Adjoint)
</code></pre>

<p>My question is: how is this function actually implemented.</p>

<p>Presumably a function with this name will return an operation that, when invoked, calls outer, then inner, then adjoint outer. However, I have no idea how to actually write a function like this. In particular, it's not clear how to write the equivalent of a lambda with a closure. For example, if I try to declare an operation inside a function (similar to how you can def inside a def in python), I get a syntax error.</p>

<p>Does this have to be done in a non-Q# library, like in C#, then imported into Q#? If so, how?</p>
",<programming><q#>,12/29/2018 4:06,5072.0,5072.0,"<p>For this example, one obtains a function with that signature by partial application of an operation that is defined outside the body, instead of as a lambda in the function. As a concrete example, consider this non-generic version of the WithA operation, modified from <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Standard/src/Canon/Combinators/With.qs"" rel=""nofollow noreferrer"">Q# canon</a>.</p>

<pre><code>operation WithA(
    outer : (Qubit[] =&gt; Unit : Adjoint), 
    inner : (Qubit[] =&gt; Unit : Adjoint), 
    target : Qubit[]) 
    : Unit
{
    body (...)
    {
        outer(target);
        inner(target);
        Adjoint outer(target);
    }
    adjoint invert;
}
</code></pre>

<p>This applies the sequence <span class=""math-container"">$|\textrm{target}\rangle\rightarrow\textrm{outer}^\dagger\cdot\textrm{inner}\cdot\textrm{outer}|\textrm{target}\rangle$</span>.</p>

<p>We can then <a href=""https://docs.microsoft.com/en-us/quantum/language/expressions?view=qsharp-preview#partial-application"" rel=""nofollow noreferrer"">partially apply the target</a>, by using the underscore character in place of an argument, to create the desired signature as follows.</p>

<pre><code>function WithAFunction(
    outer : (Qubit[] =&gt; Unit : Adjoint), 
    inner : (Qubit[] =&gt; Unit : Adjoint)) 
    : ((Qubit[] =&gt; Unit) : Adjoint)
{
    return WithA(outer, inner, _);
}
</code></pre>
",12/29/2018 5:31,Tooling ,"The user is asking about how to implement a specific function signature in Q#, a quantum programming language, which is related to the usage of tools and software in quantum programming. ", Tooling,,,,Tooling ,
5075.0,How do I name the adjoint of an operation in Q#?,"<p>For example, if I've defined the operation <code>PlusEqual</code>, I'd like to say</p>

<pre><code>operation MinusEqual = Adjoint PlusEqual;
</code></pre>

<p>but this produces a syntax error.</p>

<p>Is the only way to do this by exhaustively re-listing all arguments and functors?</p>

<pre><code>operation MinusEqual (all_args_and_types_again) : ReturnType {
    body (...) {
        return Adjoint AddEqual(all_args);
    }
    adjoint auto;
    controlled auto;
    controlled adjoint auto;
}
</code></pre>
",<programming><q#>,12/29/2018 16:38,5077.0,5077.0,"<p>You can define an immutable symbol for <code>MinusEqual</code> inside the body of an operation which will use it (you can't define it globally):</p>

<pre><code>operation UseMinusEqual () : Unit {
    ...
    let MinusEqual = Adjoint PlusEqual;
    MinusEqual(...);
}
</code></pre>

<p>If you need <code>MinusEqual</code> to be a globally visible operation, there is no shorthand syntax for this right now, so the only way to do it is a full operation definition like you say.</p>
",12/29/2018 18:57,Tooling,"The user is asking about how to define an operation as the adjoint of another operation in Q#, a quantum programming language, which is related to the usage of tools and software in quantum programming.",Tooling,,,,Tooling,
5081.0,How do I multiply an integer and a double in Q#?,"<p>If I write this:</p>

<pre><code>function f(n: Int) : Double {
    return 1.5*n;
}
</code></pre>

<p>I get an error:</p>

<pre><code>The arguments to the binary operator do not have a common base type.
</code></pre>

<p>Apparently I need a function to turn <code>n</code> from an <code>Int</code> into a <code>Double</code>. There are lots of functions going from double to int, like <a href=""https://docs.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.extensions.math.floor?view=qsharp-preview"" rel=""nofollow noreferrer""><code>Microsoft.Quantum.Extensions.Math.Floor</code></a>, but I wasn't able to find anything from int to double.</p>
",<programming><q#>,12/30/2018 3:18,5082.0,5082.0,"<p>You want the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.extensions.convert.todouble"" rel=""nofollow noreferrer""><code>Microsoft.Quantum.Extensions.Convert.ToDouble</code></a> function (deprecated in favor of <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.convert.intasdouble"" rel=""nofollow noreferrer""><code>Microsoft.Quantum.Convert.IntAsDouble</code></a> in 0.6 release).</p>

<pre><code>open Microsoft.Quantum.Extensions.Convert;

function f(n: Int) : Double {
    return 1.5*ToDouble(n);
}
</code></pre>

<p>The reason it works this way is because in Q# <code>(Num a) =&gt; a -&gt; a -&gt; a</code> is not the same as <code>(Num a,Num b) =&gt; a -&gt; b -&gt; a</code> as Haskell would denote it.</p>
",12/30/2018 4:23,Tooling,"The user is asking about how to convert an integer to a double in Q#, a quantum programming language, which is related to the usage of tools and software in quantum programming.",Tooling,,,,Tooling,
5096.0,Does Q# have a bigint type?,"<p>Shor's algorithm works with very large integers; larger than 64 bits. So the built-in 64-bit <code>Int</code> type is insufficient for doing the classical processing (e.g. computing the multipliers <span class=""math-container"">$b^{2^k} \pmod{N}$</span>). Is there a big int type suitable for those purposes?</p>
",<programming><q#>,01/01/2019 02:11,15164.0,15164.0,"<p>Q# now has a <code>BigInt</code> type included: <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/language/typesystem/#available-types"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/quantum/user-guide/language/typesystem/#available-types</a></p>
",12/16/2020 17:50,Tooling,"The user is asking about the availability of a big integer type in Q#, a quantum programming language, for handling large integers in the context of Shors algorithm. This is related to the usage of tools and software in quantum programming",Tooling,,,,Tooling,
5103.0,FANOUT with Toffoli Gate,"<blockquote>
  <p><strong>Figure 1.16:</strong> FANOUT with the Toffoli gate, with the second bit being the input to the FANOUT (and the other two bits standard ancilla states), and the output from the FANOUT appearing on the second and third bits. </p>
  
  <p><a href=""https://i.stack.imgur.com/54sKn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/54sKn.png"" alt=""enter image description here""></a></p>
  
  <p><strong>Source:</strong> Quantum Computation and Quantum Information: 10th Anniversary Edition (Fig 1.16, p.30) <br>by <em>Michael A. Nielsen &amp; Isaac L. Chuang</em></p>
</blockquote>

<p>How can we say that the third qubit is in the state <span class=""math-container"">$a$</span>?</p>

<p>Let's assume <span class=""math-container"">$a = x|0\rangle + y|1\rangle$</span>. We know that the output of the bottom two qubits is <span class=""math-container"">$x|00\rangle+y|11\rangle$</span> (entangled qubits) and the output of the second qubit must be <span class=""math-container"">$x|0\rangle+y|1\rangle$</span>. Which says that they both have to be in the state <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> at the same time, and so the third qubit should have the same probabilities as like of the second qubit. But it can be <span class=""math-container"">$-x|0\rangle + y|1\rangle$</span> and many more possibilities as <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> are complex (as probabilities are square of modulo of coefficients). </p>

<p>Please correct me if my interpretation and understanding is wrong.</p>
",<quantum-gate><classical-computing><nielsen-and-chuang>,01/02/2019 04:31,5113.0,5113.0,"<p>This section of Nielsen &amp; Chuang is talking specifically about simulating a classical circuit with a quantum circuit using Toffoli gate. So </p>

<p>1) the state <span class=""math-container"">$a$</span> will not be in superposition, since you're simulating a classical circuit and you can't have superposition in a classical circuit; <span class=""math-container"">$a$</span> will always be <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span>.</p>

<p>2) you know the state of the third qubit is <span class=""math-container"">$a$</span> because the circuit is defined to used Toffoli gate, and this is the definition of how Toffoli gate acts when input qubits are <span class=""math-container"">$|1\rangle$</span> and <span class=""math-container"">$a$</span>. If a different gate was used the third qubit could be in a different state, but with this gate it will be in this state.</p>
",01/03/2019 21:53,Theoretical,"The user is asking about the theoretical aspects of quantum computing, specifically the state of a qubit in a quantum circuit. This involves understanding the theoretical concepts and principles of quantum computing.",Theoretical,,,,Theoretical,
5109.0,Representing a real valued vector with qubits,"<p>I have some understanding that with qubits, I can represent a <span class=""math-container"">$2^n$</span> size vector using only <span class=""math-container"">$n$</span> qubits. However, I'm having trouble putting this together in a way that can make a useful circuit. Say I want to represent the input <span class=""math-container"">$(0 \ 0 \ 0 \ 1)$</span> for my circuit.</p>

<p>I should be able to do this with only 2 qubits. Starting with the initial state <span class=""math-container"">$|0\rangle|0\rangle$</span>, which as far as I know represents the vector <span class=""math-container"">$(1 \ 0 \ 1 \ 0)$</span>, I can use a not gate on the second qubit to transform that to <span class=""math-container"">$(1 \ 0 \ 0 \ 1)$</span>. However, I'm not sure what operation I can do to put the first qubit into a <span class=""math-container"">$(0 \ 0)$</span> state.</p>

<p>On top of that, I have even less of an idea of how to represent real-value vectors, like <span class=""math-container"">$(0.5 \ 0.5)$</span> (assuming including a normalization constant). I have a feeling I can use phase, but I'm not sure how to set up a circuit to achieve this.</p>

<p><strong>Edit:</strong>
Realized my earlier representation was very off. The initial state <span class=""math-container"">$|00\rangle$</span> is the same as the vector <span class=""math-container"">$(1 \ 0 \ 0 \ 0)$</span>, so transforming that into the the desired <span class=""math-container"">$(0 \ 0 \ 0 \ 1)$</span> Would just require two NOT gates:</p>

<pre><code>0 -- NOT -- 1
0 -- NOT -- 1
</code></pre>

<p>However, I'm still unsure how to represent real-valued vectors, or even a vector like <span class=""math-container"">$(1 \ 0 \ 1 \ 0)$</span>.</p>
",<quantum-state><programming>,01/02/2019 21:11,5111.0,5111.0,"<p><span class=""math-container"">$(1,0,1,0)$</span> means</p>

<p><span class=""math-container"">$$
1 (1,0,0,0) + 1 (0,0,1,0)
$$</span></p>

<p>and you already know how <span class=""math-container"">$| 0 0 \rangle$</span> and <span class=""math-container"">$(1,0,0,0)$</span> correspond.</p>

<p>To make <span class=""math-container"">$(0,0,1,0)$</span> the encoding would be <span class=""math-container"">$| 1 0 \rangle$</span>. I'm assuming you are reading the entries as 0,1,2,3 in that order for the vector and the first qubit corresponds to the most significant bit. (Little vs Big endian). If not, make the necessary changes.</p>

<p>So all together you need <span class=""math-container"">$1 | 00 \rangle + 1 | 10 \rangle$</span>.</p>

<p>For other combinations like <span class=""math-container"">$(a_0 , 0 , a_2 , 0)$</span> change the coefficents. <span class=""math-container"">$a_0 | 00 \rangle + a_2 | 10 \rangle$</span></p>
",01/02/2019 23:31,Theoretical ,"The user is asking about the theoretical aspects of quantum computing, specifically how to represent certain vectors using qubits and quantum gates. This involves understanding the theoretical concepts and principles of quantum computing. ",Theoretical,,,,Theoretical ,
5144.0,Can I remove gates from a QuantumCircuit?,"<p>Suppose I want to implement run several circuits one after another, but they are constructed in a similar fashion. I could reinstantiate a <code>QuantumCircuit</code> for each iteration, like this:</p>

<pre><code>params = np.linspace(0, 2 * np.pi, num=20)
for p in params:
    circ = QuantumCircuit(q, c)
    do_stuff(circ, p)
    do_other_stuff()
</code></pre>

<p>but I'm afraid that creating a bunch of unnecessary <code>circ</code> objects takes too much memory or too many calls to the garbage collector.</p>

<p>Instead, I would like to remove the gates from the <code>QuantumCircuit</code> object and build the new circuit in the old object. Is it possible, and if so, is it reasonable?</p>
",<programming><qiskit>,01/08/2019 17:51,5209.0,5209.0,"<p>Quantum circuits have a <code>data</code> attribute, which is a list of all gates. You can remove elements from this as with any Python list. For example, here's a circuit</p>

<pre><code>q = QuantumRegister(1)
circ = QuantumCircuit(q)

circ.h(q[0])
circ.s(q[0])
circ.x(q[0])
</code></pre>

<p>Let's get rid of the S gate. First, we can look at the list of gates with <code>circ.data</code>. This gives</p>

<pre><code>[&lt;qiskit.extensions.standard.h.HGate at 0x11721b7b8&gt;,
 &lt;qiskit.extensions.standard.s.SGate at 0x11721b828&gt;,
 &lt;qiskit.extensions.standard.x.XGate at 0x11721b7f0&gt;]
</code></pre>

<p>Element 1 of this list (i.e. the second element) is the gate we want rid of. We can do this with <code>pop</code>.</p>

<pre><code>qiskit.data.pop(1)
</code></pre>

<p>The resulting circuit can then be seen by <code>print(circ)</code></p>

<pre><code>         ââââââââââ
q0_0: |0&gt;â¤ H ââ¤ X â
         ââââââââââ
</code></pre>

<p>As you can see, we have succeeded in removing the S gate.</p>

<p>Note that you can get information about the elements of the <code>data</code> list using the methods <code>name</code> and <code>qargs</code>, etc, of gate objects. For example, to see that element 0 is a Hadamard, and to see which qubit it acts on, we can use</p>

<pre><code>print( circ.data[0].name )
print( circ.data[0].qargs )
</code></pre>

<p>This returns</p>

<pre><code>h
[(QuantumRegister(1, 'q0'), 0)]
</code></pre>
",1/15/2019 14:53,Tooling ,"The user is asking about how to efficiently implement multiple quantum circuits in Qiskit, a quantum programming software, which is related to the usage of tools and software in quantum programming. ",Tooling,,,,Tooling ,
5145.0,cirq.ControlledGate from sub-circuit generator,"<p>In Cirq, is it possible to take a sub-circuit generator and use it as the <code>sub_gate</code> in a <code>cirq.ControlledGate</code>?</p>

<pre><code>... instantiate circuit and qubits q0-q3 ...

... define sub circuit generator:
def my_layer():
    """"""
    sub-circuit generator
    ref: https://github.com/quantumlib/Cirq/blob/master/docs/circuits.md
    """"""
    yield CZ(q0, q1)
    yield [H(q) for q in (q0, q1, q2)]
    yield [CZ(q1, q2)]
    yield [H(q0), [CZ(q1, q2)]]

... take the sub-circuit generator and do something like:
gate = cirq.ControlledGate(sub_gate = my_layer())
circuit.append(gate(q3))
</code></pre>

<p>In other words, how can I take a sub-circuit and make its execution conditional on a control qubit?</p>
",<programming><cirq>,01/08/2019 20:19,5146.0,5146.0,"<p>The following code snippet will do almost what you want:</p>

<pre><code>class MyLayerGate(cirq.Gate):
    def _decompose_(self, qubits):
        a, b, c = qubits
        return my_layer(a, b, c)

    # [will be unnecessary in v0.5.0] workaround for cirq.unitary ignoring _decompose_:
    def _unitary_(self):
        return cirq.unitary(
            cirq.Circuit.from_ops(self._decompose_(
                cirq.LineQubit.range(3))))

controlled_my_layer_gate = cirq.ControlledGate(MyLayerGate())
</code></pre>

<p>In the future, the <code># workaround</code> part won't be necessary anymore. Currently it's needed because:</p>

<p>1) <code>cirq.ControlledGate</code> doesn't implement a <code>_decompose_</code> method. I've <a href=""https://github.com/quantumlib/Cirq/issues/1284"" rel=""nofollow noreferrer"">opened an issue to fix this</a>.</p>

<p>2) <code>cirq.apply_unitary</code> and <code>cirq.unitary</code> should use <code>_decompose_</code> when <code>_unitary_</code> isn't implemented on a gate, so that circuit simulation works when using gates with nothing but a specified decomposition. There is an in-progress PR <a href=""https://github.com/quantumlib/Cirq/pull/1250"" rel=""nofollow noreferrer"">to fix that</a>.</p>

<p>Also, I do like the idea of controlling the gates coming out of a method without having to define a new class. A unified <code>cirq.control(callable_or_gate_or_operation, optional_specified_control)</code> method would be useful. I'll also open <a href=""https://github.com/quantumlib/Cirq/issues/1285"" rel=""nofollow noreferrer"">an issue to do that</a>.</p>
",01/08/2019 21:03,Tooling ,"The user is asking about how to implement a specific functionality in Cirq, a quantum computing software, which is related to the usage of tools and software in quantum programming. ",Tooling,,,,Tooling ,
5154.0,Status of software packages for quantum compiling,"<p>By ""quantum compiling"", what I mean is classical algorithms to solve the following problem: given a <span class=""math-container"">$SU(D)$</span> matrix <span class=""math-container"">$U$</span> (the goal) and a set of <span class=""math-container"">$SU(D)$</span> unitary matrices <span class=""math-container"">$V_1 \cdots V_N$</span> (the gates), find a string <span class=""math-container"">$i_1\cdots i_K$</span> such that
<span class=""math-container"">$$
U \approx \prod_{k=1}^K V_{i_k}\text.
$$</span>
In other words: given a target unitary and a set of gates, implement the target unitary from those gates. Note that I'm not just interested in optimizing a pre-existing circuit, but generating a circuit from a full unitary matrix.</p>

<p>What software packages are available which solve this problem? In particular, are there software packages ready-to-use with IBM Q Experience/Qiskit or Rigetti's forest?</p>

<p>(I understand that there are many algorithms, with different performance characteristics, which tackle this. I'm interested less in optimal performance characteristics than in low-effort usability. Is the current ecosystem well-enough-developed that I don't need to pick and implement one of these algorithms myself?)</p>
",<programming><circuit-construction><qiskit><solovay-kitaev-algorithm><rigetti>,01/09/2019 20:19,5163.0,5163.0,"<p>For Qiskit, there are two tools you can check out.</p>

<p>The <a href=""https://qiskit.org/documentation/_autodoc/qiskit.mapper._compiling.html#qiskit.mapper._compiling.two_qubit_kak"" rel=""noreferrer"">two qubit kak</a> tool does exactly what you want for 2 qubits. If you give it a two qubit unitary, it gives you a list of gates to realize this, using the standard gate set used in Qiskit. This tool uses <a href=""https://arxiv.org/abs/quant-ph/0308006"" rel=""noreferrer"">Vatan and Williams optimal two-qubit circuit</a>. The decomposition algorithm used is explained in <a href=""https://arxiv.org/abs/0806.4015"" rel=""noreferrer"">Drury and Love</a>.</p>

<p>Here's an example in code</p>

<pre><code>from qiskit.mapper import two_qubit_kak
import numpy as np

# matrix to decompose
perm = np.array([[0.,0.,0.,1.], [1.,0.,0.,0.], [0.,1.,0.,0.], [0.,0.,1.,0.] ])

#decomposition
permCircuit = two_qubit_kak(perm)
</code></pre>

<p>The corresponding result is</p>

<pre><code>[{'name': 'u1', 'args': [0], 'params': (0.0, 0.0, 1.5707963267948968)}, {'name': 'u2', 'args': [1], 'params': (1.5707963267948966, 2.220446049250313e-16, -3.1415926535897922)}, {'name': 'cx', 'args': [1, 0], 'params': ()}, {'name': 'u1', 'args': [0], 'params': (0.0, 0.0, 1.5707963267948968)}, {'name': 'u2', 'args': [1], 'params': (1.5707963267948966, 3.141592653589793, -3.141592653589793)}, {'name': 'cx', 'args': [0, 1], 'params': ()}, {'name': 'u3', 'args': [1], 'params': (3.141592653589793, 0.0, 0.0)}, {'name': 'cx', 'args': [1, 0], 'params': ()}, {'name': 'u2', 'args': [0], 'params': (1.5707963267948966, 1.5707963267948968, -1.5707963267948957)}, {'name': 'u2', 'args': [1], 'params': (1.5707963267948966, -4.71238898038469, -1.5707963267948957)}]
</code></pre>

<p>The <code>u1</code>, etc here are single qubit rotations as defined by the <a href=""https://arxiv.org/abs/1707.03429"" rel=""noreferrer"">OpenQASM standard</a>.</p>

<p>Another tool is arbitary state vector initialization, which can be used for an arbitrary number of qubits. For this you can state what state vector you want, and you'll get a circuit that builds it. Obviously this is not what you asked for, but it may nevertheless be useful depending on your application.</p>

<p>Here's an example in code</p>

<pre><code>qubit = QuantumRegister(2)
bit = ClassicalRegister(2)
circuit = QuantumCircuit(qubit,bit)

vector = [0, 1 / np.sqrt(3), 1 / np.sqrt(3), 1 / np.sqrt(3) ]
circuit.initialize( vector, qubit )

print(circuit)
</code></pre>

<p>Here the final print command yields</p>

<pre><code>                       ââââââââââââââââââââââââââââââââââââââ
 q_0: |0&gt;âââââââââââââââ¤ X ââ¤ Ry(0.7854) ââ¤ X ââ¤ Ry(2.3562) â
         âââââââââââââââââ¬âââââââââââââââââââ¬ââââââââââââââââ
 q_1: |0&gt;â¤ Ry(1.9106) ââââ âââââââââââââââââââ ââââââââââââââââ
         ââââââââââââââ                                      
  c_0: 0 ââââââââââââââââââââââââââââââââââââââââââââââââââââ

  c_1: 0 ââââââââââââââââââââââââââââââââââââââââââââââââââââ
</code></pre>

<p>Other than these existing Qiskit tools, the only algorithm I know of that is planning an implementation is that of <a href=""https://arxiv.org/abs/1609.08103"" rel=""noreferrer"">Iten, et al</a>. I have heard that a Mathematica version will be produced soon.</p>
",01/10/2019 08:28,Tooling,"The user is inquiring about software packages or tools that can perform quantum compiling, which is related to finding a sequence of gates that approximates a target unitary. This question falls under the category of tooling as it pertains to the availability of quantum programming tools and software packages for quantum compiling, such as those compatible with IBM Q Experience/Qiskit or Rigetti's forest.", Tooling,,,,Tooling,
5156.0,How do I get a list of control qubits from Q# operations when tracing the simulation in C#?,"<p>I want to write code that prints out the controls of each operation executed during a simulation in Q#. For example this code prints the control counts:</p>

<pre><code>var qsim = new QCTraceSimulator(config);
qsim.OnOperationStart += (op, arg) =&gt; {
    Console.WriteLine($""{Controls(op, arg).Length""});
}
</code></pre>

<p>I'm having trouble writing the <code>Controls</code> function, which extracts a list of qubits being used as controls. When the operation is uncontrolled, or controlled by 0 qubits, the returned array should be of length 0.</p>

<p>The issue I'm running into is that the type and layout of <code>arg.Value</code> varies from operation to operation, even after conditioning on <code>op.Variant</code> being <code>OperationFunctor.ControlledAdjoint</code> or <code>OperationFunctor.Controlled</code>. I can handle individual cases by inspecting the types, but I keep running into new unhandled cases. This indicates there's probably a ""correct"" way to do this that I'm missing.</p>

<p>In short, how do I implement this function:</p>

<pre><code>object[] Controls(ICallable op, IApplyData arg) {
    ???
}
</code></pre>

<p>By ""controls"" I always mean the <code>cs</code> in <code>Controlled Op(cs, ...)</code>. The same operation may have different controls when expressed in different ways. For example, the controls list of <code>Controlled Toffoli(a, (b, c, d))</code> is the list <code>[a]</code> whereas the controls list of <code>Controlled X([a, b, c], d)</code> is the list <code>[a, b, c]</code>. A further example: the controls list of <code>Toffoli(b, c, d)</code> is <code>[]</code>, even though normally one might think of the first two arguments as the controls. It is of course expected that within <code>Toffoli(b, c, d)</code> there may be a sub-operation <code>Controlled X((b, c), d)</code> where the controls list is <code>[b, c]</code>; I'm not thinking of controls as some kind of absolute concept that is invariant as you go down through layers of abstraction.</p>
",<programming><q#>,01/09/2019 22:37,5157.0,5157.0,"<p><code>arg.Value</code> contains the actual tuple that the controlled operation receives at runtime. It's a two item tuple in which the first item is the control qubits, and the second another tuple with the arguments the operation normally expects, so in your case you are only interested in the first item of this tuple.</p>

<p>Overall, <code>arg.Value</code> can be anything, thus it has <code>object</code> as type, but fear not, using a little bit of C#'s reflection is easy to retrieve its content. The implementation you are looking for is this:</p>

<pre><code>    static Qubit[] Controls(ICallable op, IApplyData arg)
    {
        // Uncontrolled operations have no control qubits.
        if (op.Variant != OperationFunctor.Controlled &amp;&amp;
            op.Variant != OperationFunctor.ControlledAdjoint)
        {
            return new Qubit[0];
        }

        // Get the first item of the (controls, args) tuple.
        dynamic v = arg.Value;
        QArray&lt;Qubit&gt; ctrls = v.Item1;
        return ctrls.ToArray();
    }
</code></pre>

<p>Notice the array of Qubits is encapsulated in something called a <code>QArray&lt;Qubit&gt;</code>, <code>QArray</code> is the data structure we use in simulation for all Q# arrays.</p>
",01/09/2019 23:42,Conceptual,"The question is asking about the underlying concepts of quantum programming, such as the definition of controls and how they are represented in different operations.",Tooling,"The question is about how to implement a specific function in Q#, a quantum programming language. They are seeking advice on how to extract a list of qubits being used as controls in a quantum operation, which is related to the usage of the Q# programming tool",No,74.0,Tooling," The user is seeking assistance in implementing a specific function in Q#, indicating a question related to tooling, specifically about how to extract control qubits from quantum operations while tracing a simulation in C#."
5159.0,TypeError: unorderable types: QuantumRegister() >= int(),"<p>I've been using qiskit for about a year now, and as of late, I've had issues finding an available backend to run my circuit on. Looking into the matter, I reinstalled qiskit to find that most everything had changed quite a bit. Now when I try to run just a basic test circuit program, taken from the tutorial I get this:</p>

<pre><code>~$ python3 test.py

Traceback (most recent call last):
  File ""test.py"", line 27, in &lt;module&gt;
    job = execute(circ, backend)
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 108, in execute
    skip_transpiler, seed_mapper, pass_manager, memory)
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 67, in compile
    coupling_map=coupling_map, seed=seed, memory=memory)
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 61, in circuits_to_qobj
    coupling_map))
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 92, in _circuit_to_experiment
    json_circuit = DagUnroller(dag, JsonBackend(dag.basis)).execute()
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 38, in execute
    self._process()
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 161, in _process
    self.backend.new_qreg(name, width)
  File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_jsonbackend.py"", line 98, in new_qreg
    assert size &gt;= 0, ""invalid qreg size""
  TypeError: unorderable types: QuantumRegister() &gt;= int()
</code></pre>

<p>Does anybody know how to resolve this? Thanks.</p>

<p>Edit: This is the code I tried to run, which I just copied from a tutorial:</p>

<pre><code>import numpy as np
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute

# Create a Quantum Register with 3 qubits.
q = QuantumRegister(3, 'q')

# Create a Quantum Circuit acting on the q register
circ = QuantumCircuit(q)

# Add a H gate on qubit 0, putting this qubit in superposition.
circ.h(q[0])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting
# the qubits in a Bell state.
circ.cx(q[0], q[1])
# Add a CX (CNOT) gate on control qubit 0 and target qubit 2, putting
# the qubits in a GHZ state.
circ.cx(q[0], q[2])

# Import Aer
from qiskit import BasicAer

# Run the quantum circuit on a statevector simulator backend
backend = BasicAer.get_backend('statevector_simulator')

# Create a Quantum Program for execution
job = execute(circ, backend)

result = job.result()

outputstate = result.get_statevector(circ, decimals=3)
print(outputstate)
</code></pre>
",<programming><qiskit>,01/10/2019 02:57,5168.0,5168.0,"<p>The code you provide works fine for me, so I guess that something is wrong with your installation.</p>

<p>I recommend running the command</p>

<pre><code>pip uninstall qiskit
</code></pre>

<p>and also</p>

<pre><code>pip uninstall qiskit-terra
pip uninstall qiskit-aqua
pip uninstall qiskit-aer
</code></pre>

<p>and then reinstalling with</p>

<pre><code>pip install qiskit
</code></pre>
",01/10/2019 13:58,Errors,"The user is encountering an error or exception while running a quantum program in Qiskit and is seeking solutions and explanations for it. The provided error traceback indicates an issue with creating a quantum register, and the user is looking for help to resolve this error in their code.",Errors,,,,Errors,
5173.0,Submitting jobs to IBMQ backend via HTTP API Requests,"<p>Qiskit can be used to submit jobs to IBM devices using Python (or Swift and JavaScript). But what if I want to use a different language?</p>

<p>For example, suppose I have a specific circuit I want to run. Assume I've already created it in Python Qiskit, and generated the corresponding qasm string or (ideally) the full qobj object.</p>

<p>I want to be able to run this and get the results back in any language of my choice.</p>

<p>As far as I understand, these is a way to do this via HTML. The information generated in Qiskit can be turned into a JSON, and then submitted over the web. This is the way ProjectQ sends jobs to IBM devices (though they do it in Python).</p>

<p>Since reverse engineering <a href=""https://github.com/ProjectQ-Framework/ProjectQ/blob/develop/projectq/backends/_ibm/_ibm_http_client.py"" rel=""noreferrer"">the ProjectQ code</a> is a little daunting, I'd like a simple guide to using this feature. Especially in a language other than Python.</p>
",<programming><qiskit><ibm-q-experience>,01/10/2019 22:46,5178.0,5178.0,"<p>I will try answering this way but I have not tried it myself. Just reverse engineering reading the code with a few notions of HTML request.</p>

<p>Let us assume in the language of your choice, you have the ability to send HTTP requests via GET and POST methods. The <code>api_url</code> is <a href=""https://quantumexperience.ng.bluemix.net/api/"" rel=""noreferrer"">https://quantumexperience.ng.bluemix.net/api/</a>.</p>

<p>To submit a job, you will send a POST request with some information (like you have filled a form on the web and you want to talk to a server). It is like addressing a server with a dictionary of information.
It will be to the link <a href=""https://quantumexperience.ng.bluemix.net/api/Jobs"" rel=""noreferrer"">https://quantumexperience.ng.bluemix.net/api/Jobs</a>
with the POST request header set as <code>application/json</code> (showing how you submit the information). The information here is submitted in a JSON formatting in the body of the request:</p>

<pre><code>{
   ""data"": QASM as string or JSON string,

   ""params"": {""access_token"": access_token,
                              ""deviceRunType"": device,
                              ""fromCache"": ""false"",
                              ""shots"": shots}

}
</code></pre>

<p>I guess we can add in params <code>maxCredits</code> and other parameters for submission.
device refers to the name of the backend if I follow their comments: <code>simulator</code>, <code>ibmqx4</code>, or <code>ibmqx5</code>.
You get an answer back as JSON again with an id argument referring to the <code>execution_id</code>. </p>

<p>Once it is submitted, your job will be in queue. You will have to request by GET this job ID to get the answer from the backend.
The GET URL is: <a href=""https://quantumexperience.ng.bluemix.net/api/Jobs/execution_id"" rel=""noreferrer"">https://quantumexperience.ng.bluemix.net/api/Jobs/execution_id</a>.
You will get another JSON answer (put it in a <code>r_json</code> variable). If it has the <code>qasms</code> item, see if <code>r_json['qasms'][0]</code> has a <code>result</code> item and you will get the result of the submission. </p>

<p>This should sum up the procedure.</p>
",01/11/2019 05:27,Tooling,"The user is asking about how to submit jobs to IBM devices using a language other than Python, Swift, or JavaScript, which is related to the usage of tools and software in quantum programming", Tooling,,,,Tooling,
5197.0,Why won't Qiskit ccx gate accept registers?,"<p>In Qiskit, they have the concept of a Toffoli gate (<code>ccx</code>). However, the following code throws an error:</p>

<pre><code>from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute, Aer

q1 = QuantumRegister(2)
qctrl = QuantumRegister(1)
c = ClassicalRegister(2)
qc = QuantumCircuit(q1, qctrl, c)

qc.x(q1)
qc.ccx(q1[0], q1[1], qctrl)
qc.measure(q1, c)

backend_sim = Aer.get_backend('qasm_simulator')
job_sim = execute(qc, backend_sim)
result_sim = job_sim.result()
print(result_sim.get_counts(qc))
</code></pre>

<p>According to my knowledge and research, this should produce the output <code>111</code> but instead I get an error message:</p>

<blockquote>
  <p>qiskit.qiskiterror.QiskitError: ""QuantumRegister(1, 'q0') is not a tuple. A qubit should be formated as a tuple.""</p>
</blockquote>

<p>This seems like a bug with Qiskit to me. Am I wrong? And if so, how can I fix my code?</p>
",<programming><qiskit>,1/14/2019 7:44,5198.0,5198.0,"<p>It is not a bug. Qiskit makes the difference between quantum <strong>registers</strong> and quantum bits. In your case, <code>qctrl</code> is a QuantumRegister (as shown in your error) whereas the <code>ccx</code> gate expect a qubit.</p>

<p>For Qiskit, a qubit is defined as a Tuple of a QuantumRegister and an index. You can get a qubit from a QuantumRegister by using the indexing notation: <code>qtrl[0]</code> represents the first qubit (and the only one) of the QuantumRegister <code>qctrl</code>.</p>

<p>In summary, replace</p>



<pre><code>qc.ccx(q1[0], q1[1], qctrl)
</code></pre>

<p>by</p>



<pre><code>qc.ccx(q1[0], q1[1], qctrl[0])
</code></pre>

<p>and your issue should be fixed.</p>
",1/14/2019 8:32,Errors,The user is encountering an error or exception while running a quantum program in Qiskit and is seeking solutions and explanations for it.,Errors,,,,Errors,
5226.0,Does quantum computing relate to stochastic computing in any way?,"<p>I'm a bit familiar with the concept of stochastic computing, where numbers are stored in large bit streams called ""Stochastic Numbers"", which represent numbers in the domain <span class=""math-container"">$[0,1]$</span> typically.</p>

<p>The <a href=""https://en.wikipedia.org/wiki/Stochastic_computing"" rel=""noreferrer"">Wikipedia article on stochastic computing</a> summarizes all basic concepts and history behind it.</p>

<p>Does any of the concepts of stochastic computing relate to quantum computing? Or are they two very different ways of treating calculations?</p>
",<classical-computing>,1/19/2019 10:32,5229.0,5229.0,"<p>Scott Aaronson relates quantum and stochastic computation as follows: quantum computation is stochastic computation, <a href=""https://www.scottaaronson.com/democritus/lec9.html"" rel=""noreferrer"">but using the 2-norm instead of the 1-norm</a> as the conserved quantity.</p>

<p>In both paradigms you form vectors of weighted states, and operate on those vectors using matrices. So they have many similarities. But in stochastic computation the weights have to add up to 1 (as probabilities do) whereas for quantum computation the <em>squares</em> of the weights have to add up to 1 (as amplitudes do).</p>
",1/19/2019 19:57,Conceptual," The user is asking about the conceptual relationship between stochastic computing and quantum computing. They want to understand if there are any connections or similarities in how these two computing paradigms handle calculations, which involves understanding the theoretical concepts and principles underlying both approaches.",Conceptual,,,,Conceptual,
5254.0,Path to learn Qiskit as a tool for the future,"<p>I am an undergraduate in Engineering physics, yet to take classes on Quantum mechanics, but none (if I'm not mistaken) on quantum information and quantum algorithms, and I am curious about the subject so I've began reading some things to get the basics on quantum computing (I've been reading <em>Quantum Computing since Democritus</em> by Scott Anderson) so as to move afterwards to Qiskit.</p>

<p>As for Qiskit learning, I am a bit lost, as it is such a new concept, there are little to none tutorials available online, I only found a collection of <em>Jupyter Notebooks</em> on GitHub (<a href=""https://github.com/Qiskit/qiskit-tutorials"" rel=""noreferrer"">https://github.com/Qiskit/qiskit-tutorials</a>) that, however helpful, are overwelming and seem directed to someone that already needs to learn Qiskit and has a project that needs it. My goal to learn it is to be ready for when I need it, to just add a tool in my toolbox. But to do so I need some advice for I am stuck.</p>

<p>Also, I would like to ask if anyone knows any online course with verified certificate's related to the subject.</p>

<p>Thank's in advance.</p>
",<programming><qiskit><resource-request>,1/23/2019 19:57,5258.0,5258.0,"<p>For a certificate, check out these <a href=""https://quantumcurriculum.mit.edu/"" rel=""nofollow noreferrer"">MIT courses</a> that you can participate in online. They are done in collaboration with IBM.</p>

<p>IBM also recently gave awards for university level courses that use Qiskit. You can find all the best submissions <a href=""https://github.com/Qiskit/qiskit-tutorials/tree/awards/community/awards/teach_me_quantum_2018"" rel=""nofollow noreferrer"">here</a>. These are also courses you can follow along at home (though there won't be a certificate).</p>

<p>Regarding the Jupyter notebook tutorials, I'd suggest starting with <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/awards/community/games/Hello_Qiskit.ipynb"" rel=""nofollow noreferrer"">this one</a> which is an interactive guide to basic quantum operations.</p>

<p>For advice for when you are stuck, I'd suggest the quantum computing stack exchange. I'm sure I don't need to provide a link for that ;)</p>

<p><em>Disclosure: I work for IBM.</em></p>
",1/24/2019 8:22,Learning ,"The user is seeking advice on learning resources and tutorials for quantum computing and Qiskit, and is also interested in online courses with verified certificates related to the subject. ",Learning,,,,Learning ,
5269.0,Deprecation warnings in Qiskit (circuit drawing),"<p>I am just starting to get around Qiskit, I'm going at baby steps, so I tried to run the code below and I noticed three things:</p>

<ol>
<li><p>I tried using <code>matplotlib_circuit_drawer()</code> instead of <code>circuit_drawer()</code>, but is return a DeprecationWarning and sugested using <code>circuit_drawer</code>. I assume this is due to the constant updates and the functions are going to change frequently;</p></li>
<li><p>In the <code>qc.measure(q, c)</code> I get a highlight in PyCharm saying <em>Unresolved attribute reference 'measure' for class 'QuantumCircuit'</em>, and I don't know what that really means;</p></li>
<li><p>I think this is also related to 1). When using <code>draw(qc)</code> I get the warning <code>DeprecationWarning: The current behavior for the default output will change in a future release. Instead of trying latex and falling back to mpl on failure it will just use ""text"" by default
'""text"" by default', DeprecationWarning)</code> and no image pops up. However when I use <code>print(qc)</code> the circuit pops up in text format;</p></li>
</ol>

<p>How can I be up to date about the commands?</p>

<pre><code>from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer as draw

c = ClassicalRegister(2)
q = QuantumRegister(2)
qc=QuantumCircuit(q, c)

qc.measure(q, c)
draw(qc)
</code></pre>
",<programming><qiskit>,1/25/2019 14:11,5300.0,5300.0,"<p><a href=""https://github.com/Qiskit/qiskit-terra/releases/tag/0.7.0"" rel=""nofollow noreferrer"">Qiskit Terra 0.7</a> changed visualization quite a bit. <a href=""https://medium.com/qiskit/terra-0-7-better-visualization-compilation-memorization-895b05b7197f"" rel=""nofollow noreferrer"">This blog post</a> from the Qiskit team might be helpful.</p>

<p>Here's your code, updated for Qiskit Terra 0.7.2:</p>



<pre><code>from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit

c = ClassicalRegister(2)
q = QuantumRegister(2)
qc=QuantumCircuit(q, c)

qc.measure(q, c)

# draws an ascii circuit
print(qc)

# Output:
#             âââ
# q0_0: |0&gt;ââââ¤Mâ
#          âââââ¥â
# q0_1: |0&gt;â¤Mâââ«â
#          ââ¥â â
#  c0_0: 0 ââ¬âââ©â
#           â
#  c0_1: 0 ââ©ââââ

# draws a circuit with Matplotlib 
diagram = qc.draw(output=""mpl"")

# if you'd like to save to a file
diagram.savefig(""test.svg"", format=""svg"")

</code></pre>

<p>Here's the SVG that was generated (converted to PNG for StackExchange):
<img src=""https://i.stack.imgur.com/1iTEe.png"" width=""364"" /></p>

<p>As for your second question... this sounds like something with your IDE's access to the library symbols. I don't have help for you there, except to say it's a fairly common problem. Good luck!</p>

<hr>

<p><em>Note: This advice applies to Qiskit 0.7.x. Qiskit is rapidly evolving and you should expect breaking changes on new versions. You can find the release notes <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/CHANGELOG.rst"" rel=""nofollow noreferrer"">here</a>.</em></p>

<hr>

<p><strong>Troubles installing Matplotlib/visualizations?</strong></p>

<p>Per the <a href=""https://medium.com/qiskit/terra-0-7-better-visualization-compilation-memorization-895b05b7197f"" rel=""nofollow noreferrer"">blog post</a>, you should be able to run:</p>

<p><code>pip install qiskit[visualization]</code></p>

<p>While it has worked for me in the past, it currently returns:</p>

<p><code>qiskit 0.7.2 does not provide the extra 'visualization'</code></p>

<p>As a workaround, you can install the packages this ""extra"" <a href=""https://github.com/Qiskit/qiskit-terra/blob/stable/setup.py"" rel=""nofollow noreferrer"">references</a>:</p>

<p><code>pip install matplotlib nxpd ipywidgets pydot</code></p>

<p>Also, in the off chance you are using MacOS with <code>virtualenv</code>, you may run into <a href=""https://matplotlib.org/faq/osx_framework.html"" rel=""nofollow noreferrer"">this issue</a>. I had to use <code>venv</code> to get it to work.</p>

<p>Good luck!</p>
",1/28/2019 23:08,Errors,The user is seeking solutions and explanations for errors and exceptions encountered while developing a quantum program using Qiskit,Errors,,,,Errors,
5275.0,Reversibility and irreversibility of logic gates (quantum vs classical),"<p>I have been told that one of the great <em>keys</em> that unlock quantum computing's potential is the reversibility of quantum logic gates as for classical gates there's some loss of information, but I cannot grasp this concept. Mathematically I see why the quantum logic gate is reversible, it is a mere unitary operator but on the classical one I don't see where the information is lost, could someone clarify it?</p>
",<quantum-gate><classical-computing>,1/26/2019 23:10,5276.0,5276.0,"<blockquote>
  <p>Mathematically I see why the quantum logic gate is reversible, it is a
  mere unitary operator but on the classical one I don't see where the
  information is lost, could someone clarify it?</p>
</blockquote>

<p>For illustration, let's take the classical <a href=""https://en.wikipedia.org/wiki/XOR_gate"" rel=""nofollow noreferrer""><code>XOR</code> gate</a>. </p>

<p><a href=""https://i.stack.imgur.com/wYaTM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wYaTM.png"" alt=""""></a> </p>

<p>Say you know that the output or end result of a certain <code>XOR</code> operation is <code>1</code>. Now what could have been the possible values for <code>A</code> and <code>B</code>? Either <code>A = 0</code> &amp; <code>B = 1</code> or <code>A=1</code> &amp; <code>B = 0</code>. That is, you cannot <em>unambiguously</em> reconstruct its two inputs from its single output i.e. the information about the initial state of <code>A</code> and <code>B</code> is lost after the XOR logic operation. This is exactly what they mean when they mean by ""irreversibility of classical logic gates"".</p>

<p>Interestingly, the reversible <em>quantum</em> version of the <code>XOR</code> gate is the <a href=""https://en.wikipedia.org/wiki/Controlled_NOT_gate"" rel=""nofollow noreferrer""><code>CNOT</code> gate</a>. </p>

<p>However, there are exceptions like the classical <a href=""https://en.wikipedia.org/wiki/Inverter_(logic_gate)"" rel=""nofollow noreferrer""><code>NOT</code> gate</a>. </p>

<p><a href=""https://i.stack.imgur.com/t66ay.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t66ay.png"" alt=""""></a></p>

<p>For the <code>NOT</code> gate, if you're given that the output state <code>1</code>, then you can unambiguously say the initial state of <code>A</code> was <code>0</code>. Similarly, if you're given <code>NOT A</code> is <code>0</code>, you can unambiguously say that <code>A</code> was <code>1</code>. No information is lost here during the logic operation. </p>

<p>It's possible to perform all classical logic operations using only reversible gates. But in those cases, often it becomes necessary to use <a href=""https://en.wikipedia.org/wiki/Ancilla_bit"" rel=""nofollow noreferrer"">ancilla bits</a>. For instance, the reversible <a href=""https://en.wikipedia.org/wiki/Toffoli_gate"" rel=""nofollow noreferrer"">Toffoli gate</a> gate can implement all classical logic functions. The Toffoli gate has a quantum version too. Basically, all reversible classical logic operations can be directly mapped to quantum gate operations, which are unitary and reversible. In case you're wondering <em>why</em> quantum gates are unitary, read <a href=""https://quantumcomputing.stackexchange.com/a/2040"">this answer</a>. </p>

<blockquote>
  <p>I have been told that one of the great keys that unlock quantum
  computing's potential is the reversibility of quantum logic gates as
  for classical gates there's some loss of information, but I cannot
  grasp this concept.</p>
</blockquote>

<p>That's true. Read up the Wikipedia articles on <a href=""https://en.wikipedia.org/wiki/Reversible_computing"" rel=""nofollow noreferrer"">reversible computing</a> and <a href=""https://en.wikipedia.org/wiki/Landauer%27s_principle"" rel=""nofollow noreferrer"">Landauer's principle</a>. Note that there's two kinds of reversibilities: <a href=""https://en.wikipedia.org/wiki/Reversible_computing#Logical_reversibility"" rel=""nofollow noreferrer"">logical reversibility</a> and <a href=""https://en.wikipedia.org/wiki/Reversible_computing#Physical_reversibility"" rel=""nofollow noreferrer"">physical reversibility</a>. A <a href=""https://en.wikipedia.org/wiki/Quantum_Turing_machine"" rel=""nofollow noreferrer"">universal Turing machine</a> can be made both physically and logically reversible. Logical and physical reversibility together would enable running <a href=""https://en.wikipedia.org/wiki/Quantum_algorithm"" rel=""nofollow noreferrer"">efficient algorithms</a> and energy-efficient computation in quantum computers. </p>
",1/26/2019 23:40,Conceptual,The user is seeking clarification and a conceptual understanding of the reversibility of quantum logic gates compared to classical gates. This question involves understanding the theoretical concepts and principles of quantum computing and classical computing.,Conceptual,,,,Conceptual,
5278.0,Aren't reversible logic gates a necessity for efficiently executing quantum algorithms?,"<p>The Wikipedia article on <a href=""https://en.m.wikipedia.org/wiki/Reversible_computing#Logical_reversibility"" rel=""nofollow noreferrer"">logical reversibility</a> says:</p>

<blockquote>
  <p>...reversible logic gates offered practical improvements of
  bit-manipulation transforms in cryptography and computer graphics.</p>
</blockquote>

<p>But I guess that's not all? Aren't reversible logic gates a necessity for the (efficient) execution of quantum algorithms? <sup>[1]</sup></p>

<p>To clarify, I'm basically asking this: Isn't the use of reversible operations or unitaries necessary for efficiently executing quantum algorithms? Or are there <a href=""https://quantumcomputing.stackexchange.com/questions/74"">models</a> of quantum computation which can execute these algorithms efficiently without making use of logically reversible operations at all?</p>

<hr>

<p><sup>[1]: Inspired from <a href=""https://quantumcomputing.stackexchange.com/questions/5275/reversibility-and-irreversibly-in-logic-gates-quantum-vs-classical"">Reversibility and irreversibility of logic gates (quantum vs classical)</a>.</sup></p>
",<algorithm><classical-computing><computational-models>,1/27/2019 0:53,5279.0,5279.0,"<p>Originally, I misunderstood the question, and was answering a question like ""Is it true that quantum computers are necessarily formulated only out of reversible gates?"". However, I now understand that the question was intended to be ""Must there always be a reversible step inside a quantum computation?""</p>

<p>No - there are some computational schemes, such as the <a href=""https://arxiv.org/abs/0803.1447"" rel=""nofollow noreferrer"">this paper</a>, in which every computational step can be formulated as a dissipation, which is non-reversible.</p>

<p>Another way to think about it is in terms of the measurement-based model. Here, one must prepare a particular state, and perform a sequence of measurements on it. Usually, we talk about the initial state preparation as a unitary, but that's not necessary. The usual cluster state is the common eigenstate of a set of stabilizers <span class=""math-container"">$\{K_n\}$</span> (<span class=""math-container"">$K_n^2=1$</span> and <span class=""math-container"">$[K_n,K_m]=0$</span>). So, imagine you take some initial state of a system, and start measuring sets of qubits according to the stabilizers <span class=""math-container"">$\{K_n\}$</span>. The state people normally talk about preparing is the +1 eigenstate of all of these. Obviously, it's quite unlikely the we succeed in preparing that. However, we will have a record of which stabilizers gave -1 answers. It's a particular property of these stabilizers that each one anti-commutes with a <span class=""math-container"">$Z$</span> on a particular site, while all others commute with that particular <span class=""math-container"">$Z$</span>. This means that the list of stabilizers with -1 values corresponds to a list of sites with <span class=""math-container"">$Z$</span> errors. But, knowing that, we can just incorporate the existence of the <span class=""math-container"">$Z$</span> rotations into the measurement bases of the computation. Everything can be achieved through measurements! (Although you require 5-qubit measurements. While not impossible, I think most people would consider implementing them using some unitaries and single-qubit measurements, but the formalism doesn't require it.)</p>

<hr>

<h1>Original Answer</h1>

<p>No. Usually, we phrase quantum algorithms in terms of unitaries (reversible) plus measurements (not reversible). You might even argue that for many algorithms, with a deterministic output, the final measurement does nothing, and hence does not do anything irreversible.</p>

<p>However, this is partially the fault of the gate model which hides measurement at the end. In fact, there is some degree of choice about trading off between the two. For example, measurement-based computation implements one very simple unitary operation that may have nothing to do with the computation to be performed, and then the computation itself is specified by the measurement choices, and the measurements also detect the outcomes. This extreme certainly shows that it is not necessary to have reversibility.</p>
",1/27/2019 6:51,Conceptual,The user is seeking clarification on the necessity of reversible operations or unitaries for efficiently executing quantum algorithms and whether there are models of quantum computation that can achieve this without using logically reversible operations. This question involves understanding the theoretical concepts and principles of quantum computing.,Conceptual,,,,Conceptual,
5308.0,Qiskit: 'per shot' result,"<p>Is there a way to access the results of measurements 'per shot' performed on a backend such as one of the real IBM machines?</p>

<p>I know it can generate a histogram from the cumulative data, but I was wondering if it is possible to see what the measurement outcomes were for a particular shot out of the standard 1024.</p>
",<programming><qiskit><ibm-q-experience>,1/29/2019 19:41,5309.0,5309.0,"<p>There is indeed. You just need to use <code>get_memory()</code> instead of <code>get_counts()</code> (and also use a <code>memory=True</code> flag in the execute function. It works with the local qasm simulator and the 5 qubit device (and not currently with the cloud-based qasm simulator or 14 qubit device).</p>

<p>Here's an example using it to generate a series of random bits.</p>

<pre><code>q = QuantumRegister(1)
c = ClassicalRegister(1)
circ = QuantumCircuit(q, c)

circ.h(q)

circ.measure(q,c)

job = execute(circ, Aer.get_backend('qasm_simulator'), shots=10024, memory=True)
data = job.result().get_memory()
</code></pre>
",1/30/2019 2:26,API Usage ,The user is asking about how to correctly and effectively use APIs in quantum programming to access the results of measurements per shot performed on a backend. , API Usage,,,,API Usage ,
5321.0,Type error creating R gate in Q#?,"<p>The R operation in Q# is listed by Microsoft in the documentation as follows</p>

<p><code>operation R (pauli : Pauli, theta : Double, qubit : Qubit) : Unit</code></p>

<p>However, when I try to use the following command in a Q# operation,</p>

<p><code>R(PauliX,0,Q1);</code></p>

<p>I get an error, referencing the line of code for the R command:</p>

<p><code>The type of the given argument does not match the expected type.</code></p>

<p>Q1 is of course a Qubit, so I don't see what could be causing the problem. I've also been having difficulty getting the R1 gate working, but I suspect for similar reasons.</p>

<p>To see the relevant documentation, please visit <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r"" rel=""nofollow noreferrer"">R operation, Q# Docs</a>.</p>
",<quantum-gate><programming><q#>,1/31/2019 1:50,5322.0,5322.0,"<p>The second argument <code>theta</code> has to be a <code>Double</code>, and 0 is a constant of type <code>Int</code>. Q# doesn't have implicit type casting, so you need to make sure your second argument is a <code>Double</code>. If you're looking for a rotation by zero angle, you'll need to do <code>R(PauliX, 0.0, Q1);</code>. Alternatively, you can use <code>ToDouble</code> to cast an integer parameter to a <code>Double</code>.</p>
",1/31/2019 1:59,Errors,"The user is seeking solutions and explanations for an error encountered while using the R operation in Q#.The error message ""The type of the given argument does not match the expected type"" means that the type of the argument that you are passing to the R operation is not the same as the type that the R operation expects.",Errors,,,,Errors,
5323.0,Creating controlled R1 gates in Q#?,"<p>I know how to create controlled versions of gates like X, Y, Z. For example, a controlled X gate would be implemented by writing</p>

<p><code>(Controlled X)([control],target);</code></p>

<p>However, I've tried numerous times to create a controlled R1 gate with no success, and there are no examples available on the Q# documentation or elsewhere on the web from what I've seen. As an example of what I've attempted, I've tried</p>

<p><code>(Controlled R1)([control],theta,target);</code></p>

<p>and get the following error:</p>

<p><code>The shape of the given tuple does not match the argument type.</code></p>

<p>From what I gather the issue is that an X gate does not require any additional parameters, whereas an angle needs to be specified for the R1 gate to be well defined.</p>

<p>To see the relevant documentation, please visit <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1"" rel=""nofollow noreferrer"">R1 Operation, Q# Docs</a>, and <a href=""https://docs.microsoft.com/quantum/techniques/operations-and-functions"" rel=""nofollow noreferrer"">Operations and Functions, Q# Docs</a>.</p>
",<quantum-gate><programming><q#>,1/31/2019 6:09,5325.0,5325.0,"<p>If the base operation takes several arguments, you need to enclose the corresponding arguments of the controlled version of the operation in parentheses to convert them into a single tuple. In your case, you need to call it as <code>(Controlled R1)([control], (theta, target));</code>.</p>

<p>This is covered in the ""Controlled"" section of <a href=""https://docs.microsoft.com/en-us/quantum/language/type-model#operation-and-function-types"" rel=""nofollow noreferrer"">Q# type model documentation</a> with Rz gate used as an example. I wonder how to make this information more discoverable...</p>
",1/31/2019 6:52,Errors,The user is seeking solutions and explanations for an error encountered while trying to create a controlled R1 gate in Q#,Errors,,,,Errors,
5364.0,Why is Grover's algorithm not converging monotonically? (Python implementation),"<p>I have tried to implement Grover's algorithm for three qubits in python/numpy and the first two iterations work like a charm but the third one starts to diverge. Is this expected, or is there a bug in the code? I expected the inversion around the mean to blow up the coefficient of the marked state in each iteration. The code follows Nielsen closely, with a silly Oracle that hard-codes the negation of the basis state. The Python code requires a little bit of set-up but the essential idea is:</p>

<ul>
<li>Define a phase shift operator of -1 on all basis states except zero.</li>
<li>Define a reflection around the mean operator as Hadamard â Phase Shift â Hadamard.</li>
<li>Define the full Grover step as the Oracle followed by the reflection.</li>
<li>Start with an equally balanced state.</li>
<li>Repeatedly apply the Grover step.</li>
</ul>

<p>Source code:</p>

<pre><code>import numpy as np

def dagger(m):
    return np.transpose(np.conjugate(m))

def proj(m):
    return m * dagger(m)

# identity matrix for 3 qubits = 8x8 matrix
id3 = np.identity(2**3)

# hadamard matrix for 1, 2 and 3 qubits
H1 = np.matrix([[1.0, 1.0], [1.0, -1.0]], dtype=np.complex256) / np.sqrt(2)
H2 = np.kron(H1, H1)
H3 = np.kron(H2, H1)

# 3 qubit zero vector |000&gt;
zero3 = np.array([[1],[0],[0],[0],[0],[0],[0],[0]], dtype=np.complex256)

# phase shift operator  2*|0&gt;&lt;0| - I  for 3 qubits
PS3 = 2 * proj(zero3) - id3

# reflection around the mean
R = H3 * PS3 * H3

# 3 qbit oracle, marking/negating state |101&gt; = column vector (0 0 0 0 0 1 0 0)
O = id3
O[5,5] = -1

# grover operator
G = R * O

# start state |000&gt;
x0 = H3 * zero3

# apply grover step three times
x1 = G * x0
print x1

x2 = G * x1
print x2

x3 = G * x2
print x3
</code></pre>

<p>The output of the program is shown below. The coefficient (driving the probability) for the state to search for is 0.88 after one iteration, then 0.97 but then falls back to 0.57. Am I missing any essential step in the algorithm?</p>

<pre><code>[[ 0.1767767+0.0j]
 [ 0.1767767+0.0j]
 [ 0.1767767+0.0j]
 [ 0.1767767+0.0j]
 [ 0.1767767+0.0j]
 [ 0.88388348+0.0j]
 [ 0.1767767+0.0j]
 [ 0.1767767+0.0j]]
[[-0.088388348+0.0j]
 [-0.088388348+0.0j]
 [-0.088388348+0.0j]
 [-0.088388348+0.0j]
 [-0.088388348+0.0j]
 [ 0.97227182+0.0j]
 [-0.088388348+0.0j]
 [-0.088388348+0.0j]]
[[-0.30935922+0.0j]
 [-0.30935922+0.0j]
 [-0.30935922+0.0j]
 [-0.30935922+0.0j]
 [-0.30935922+0.0j]
 [ 0.57452426+0.0j]
 [-0.30935922+0.0j]
 [-0.30935922+0.0j]]
</code></pre>
",<programming><grovers-algorithm>,02/03/2019 22:33,5365.0,5365.0,"<p>This seems normal by applying the definition of the inversion about average operator which transforms the amplitudes <span class=""math-container"">$\alpha_i $</span> by the formula :</p>

<p><span class=""math-container"">$$ - \alpha_i + 2 \langle\alpha\rangle\,, $$</span></p>

<p>Apply this to your example (using the above formula for each step to verify your intermediary steps) and you should retrieve this numbers. This operator is periodic. After the maximum number of operations giving you the highest probability of the desired state to be measured, you will reset the amplitudes if you apply it another time, meaning you have to reapply again to amplify its amplitude the same way. </p>
",02/03/2019 23:01,Errors,"The question is asking for help with a specific error in Grover's algorithm implementation, which is likely caused by a problem with the code or the environment.", Errors ,,,,Errors,
5374.0,What resources are available for learning QCL?,"<p>I'm struggling to find much about the language <a href=""https://en.wikipedia.org/wiki/Quantum_Computation_Language"" rel=""nofollow noreferrer"">QCL</a>, rather than about quantum computing itself. </p>

<p>Is there anything out there like that? It doesn't have to be free. </p>
",<programming><resource-request><qcl>,02/05/2019 03:03,5375.0,5375.0,"<p>A quick googling reveals that <a href=""http://tph.tuwien.ac.at/~oemer/"" rel=""noreferrer"">Bernhard Ãmer</a> has worked extensively on this topic. Check out the documentation section <a href=""http://tph.tuwien.ac.at/~oemer/qcl.html"" rel=""noreferrer"">here</a>. He describes the installation procedure on the corresponding <a href=""https://github.com/aviggiano/qcl"" rel=""noreferrer"">GitHub page</a>.</p>

<ol>
<li><a href=""http://tph.tuwien.ac.at/~oemer/doc/quprog.pdf"" rel=""noreferrer"">Quantum Programming in QCL (PDF)</a></li>
</ol>

<blockquote>
  <p>My master thesis in computing science deals with computational and architectural questions of quantum programming and illustrates the design of quantum algorithms in QCL. For readers with a CS rather than a physical background, this book also features a brief introduction into quantum physics in general. </p>
</blockquote>

<ol start=""2"">
<li><a href=""http://tph.tuwien.ac.at/~oemer/doc/qcldoc.pdf"" rel=""noreferrer"">A Procedural Formalism for Quantum Computing (PDF)</a></li>
</ol>

<blockquote>
  <p>My master thesis in theoretical physics about QCL. Besides a general introduction to quantum programming and a description of the language, a complete QCL implementation of the Shor algorithm is presented. </p>
</blockquote>

<ol start=""3"">
<li><a href=""http://tph.tuwien.ac.at/~oemer/doc/structquprog.pdf"" rel=""noreferrer"">Structured Quantum Programming (PDF)</a></li>
</ol>

<blockquote>
  <p>My PhD thesis on structured programming languages for quantum computing (latest revision Jan 9 2009).  </p>
</blockquote>

<ol start=""4"">
<li><a href=""https://arxiv.org/abs/quant-ph/0211100"" rel=""noreferrer"">Classical Concepts in Quantum Programming</a></li>
</ol>

<blockquote>
  <p>This paper from the QS2002 conference describes classical concepts in QCL, including new features like conditional operators, quantum conditions and quantum if-statements. The print version appeared in the International Journal of Theoretical Physics 44/7, pp. 943-955, 2005. </p>
</blockquote>

<p>Also, check out these video lectures on QCL by <a href=""http://macheads101.com/pages/about.php"" rel=""noreferrer"">Macheads101</a>:</p>

<ul>
<li><a href=""https://www.youtube.com/watch?v=rF2DDvGsYmY"" rel=""noreferrer"">Quantum Programming Tutorial #1: Installing QCL</a></li>
<li><a href=""https://www.youtube.com/watch?v=GO6TsdwxcwM"" rel=""noreferrer"">Quantum Programming Tutorial #2: Basic Qubit Operations</a></li>
<li><a href=""https://www.youtube.com/watch?v=X5rJ78_U_go"" rel=""noreferrer"">Quantum Programming Tutorial #3: The V Gate</a></li>
</ul>
",02/05/2019 04:26,Learning,The user is seeking learning resources and tutorials for the Quantum Computation Language (QCL), Learning,,,,Learning,
5471.0,Is programming in quantum computer same as programming in quantum simulator in classical computer?,"<p>I just started programming in Q# and I wonder if the coding for Q# in classical computer would be the same as coding in a quantum computer. Obviously, these 2 kinds of computers work differently, so I guess the language must be working differently as well. Does this affect the coding part in any way (syntax, dealing with operations and variables etc.)?</p>
",<programming><q#>,02/12/2019 13:54,5475.0,5475.0,"<p>Running programs on a quantum computer will indeed require some routines which are not required for running them on a classical simulation. Two easiest examples are error correction (a classical simulation is perfect but a quantum device will be noisy and will require error correction to produce useful results) and translating logical qubits and gates to physical ones (in a simulation you can do any gate on any pair of qubits, but a physical device will be limited to certain set of primitive gates and a certain connectivity scheme).</p>

<p>However, the person writing high-level quantum code is likely uninterested in such low-level routines (unless they are researching them specifically), same as a person writing this answer doesn't really want to care about the addresses of the bytes storing it on their computer. High-level programming languages (in particular Q#, since you asked about it) aim to provide a high-level abstraction for the programmer and delegate low-level routines to the compiler. This also allows to run the same code on the simulators (for debugging and resource estimation purposes) and then to take it to a quantum device without modifications.</p>
",02/12/2019 17:48,Conceptual,"The user is asking about the underlying concepts of quantum programming, specifically how the coding for Q# on a classical computer would compare to coding on a quantum computer.",Conceptual,,,,Conceptual,
5476.0,Is it possible to create a superposition in IBMQ QISkit which has probability amplitudes $|a|\neq |b|$?,"<p>For example, we can create a single qubit state with a polar angle of <span class=""math-container"">$\pi/2$</span> with the Hadamard gate. But, can we create a state such as this,</p>

<p><span class=""math-container"">$$\Psi = \cos(\pi/8)|0\rangle + \sin(\pi/8)|1\rangle$$</span></p>

<p>where the polar angle does not equal <span class=""math-container"">$\pi/2$</span>, in QISkit?</p>
",<quantum-state><programming><qiskit>,02/12/2019 18:59,5477.0,5477.0,"<p>You use the <a href=""https://qiskit.org/documentation/terra/summary_of_quantum_operations.html#standard-rotations"" rel=""nofollow noreferrer"">standard rotations</a>. In this case, you're looking for the <code>ry</code> operator (rotation around the y-axis). To rotate the state vector counter-clockwise around the unit circle by <span class=""math-container"">$\theta$</span>, call <code>ry</code> with <span class=""math-container"">$2\theta$</span> or in your case <span class=""math-container"">$\frac{2\pi}{8}$</span> applied to state <span class=""math-container"">$|0\rangle$</span>.</p>

<pre><code>from qiskit import *
import numpy as np
q = QuantumRegister(1)
qc = QuantumCircuit(q)
qc.ry(2*np.pi/8,q)
</code></pre>
",02/12/2019 19:24,API Usage,The user is asking about how to correctly and effectively use APIs in QISKit to create a specific quantum state,Theoretical,"The user is inquiring about the theoretical aspects of quantum states and the capability of creating specific quantum states in Qiskit. They are interested in understanding if they can create a quantum state with a polar angle different from ?/2, which falls under the ""Theoretical"" category, as it involves theoretical concepts and capabilities related to quantum programming.",No,75.0, Theoretical," The user is asking about the theoretical capability of creating a specific quantum state in Qiskit, which involves understanding the theoretical concepts and capabilities related to quantum programming."
5480.0,ProjectQ - In which part of the controlled gate object are the control bits scored,"<p>I've been trying to decompose the ProjectQ objects and I could manage to decompose non-controlled gates and daggered gates. But I noticed that 
the object of a controlled version of a gate is the exact same as the object of that gate.</p>

<p>The code generating these objects:</p>

<pre><code>  eng = MainEngine()
  q = eng.allocate_qubit()
  p = eng.allocate_qubit()
  c = eng.allocate_qubit()
  X | q
  CNOT | (p,q)
</code></pre>

<p>This is the XGate object</p>

<pre><code>{'_control_qubits': [],
 '_engine': &lt;__main__.MainEngine object at 0x7fc323e4d198&gt;,
 '_qubits': ([&lt;projectq.types._qubit.WeakQubitRef object at 0x7fc30b0a3ef0&gt;],),
 'gate': &lt;projectq.ops._gates.XGate object at 0x7fc316778048&gt;,
 'tags': []}
</code></pre>

<p>And this is the CNOT gate, which is the same as ControlledGate(XGate)</p>

<pre><code>{'_control_qubits': [],
 '_engine': &lt;__main__.MainEngine object at 0x7fc323e4d198&gt;,
 '_qubits': ([&lt;projectq.types._qubit.WeakQubitRef object at 0x7fc30b0b1080&gt;],),
 'gate': &lt;projectq.ops._gates.XGate object at 0x7fc316778048&gt;,
 'tags': []}
</code></pre>

<p>Both have no control qubits and it seems like the control gates lost the control qubit. </p>

<p>Any idea on where the control qubit is stored?</p>
",<quantum-gate><programming><simulation>,2/13/2019 19:58,5559.0,5559.0,"<p>The control qubits are only added to the command after it is received by the <code>ControlEngine</code> further down the chain after the <code>MainEngine</code>. For implementation details see ""3.2.1 Implementation of meta instructions"" <a href=""https://doi.org/10.3929/ethz-b-000322770"" rel=""nofollow noreferrer"">here</a>.</p>

<p>To implement a testing engine such as this one, that can be used to check that indeed control qubits are added right after the <code>MainEngine</code>, you could do the following:</p>



<pre><code>test_eng = Testing(BasicEngine) # Or CommandPrinter
eng = projectq.MainEngine(engine_list=[test_eng])
</code></pre>
",2/26/2019 8:24,Errors,"The user is encountering an issue with the ProjectQ code where the control qubit seems to be lost in controlled gates, which falls under the Errors category",Errors,,,,Errors,
5494.0,How to set a starting state in cirq?,"<p>I'm learning how to use the cirq library. Every time I set up a circuit the starting state of the qubits is <span class=""math-container"">$|0000..0\rangle$</span>. Is there any way to make the starting state different? I'm thinking of somehow giving as input some <code>np.array (vector)</code> to the circuit so that the system initializes with such state. I know I could build a circuit to prepare the state I want but I would like a shorter way to do this.</p>

<p>Thanks!</p>
",<programming><cirq>,2/15/2019 13:22,5496.0,5496.0,"<p>Cirq distinguishes between ""running"" a circuit, which is generally supposed to act like hardware would (e.g. only getting samples), and ""simulating"" a circuit, which has more freedom.</p>

<p>Most ""simulate"" methods, like <code>cirq.Simulator().simulate(...)</code> have a parameter <code>initial_state</code> which can either be a computational basis state (specified as an integer e.g. <code>initial_state=0b000111000</code>) or a state vector (specified as a numpy array e.g. <code>initial_state=np.array([0.5, -0.5, 0.5j, 0.5])</code>).</p>

<p>For ""run"" methods, like <code>cirq.Simulator().run(...)</code>, there is no way to specify the initial state because that's how it works in hardware. If you want a specific state, you have to make it with gates.</p>
",2/15/2019 17:42,Tooling,"The user is asking about how to use a specific feature of a quantum computing tool (setting the initial state in Cirq), which falls under the Tooling category",Tooling,,,,Tooling,
5521.0,How to add control to gates in Cirq?,"<p>My question is very simple. I know there is a method to add a control to previously defined gates. I saw in the API of cirq that there is a command Controlled gate (<a href=""https://cirq.readthedocs.io/en/stable/generated/cirq.ControlledGate.html#cirq.ControlledGate"" rel=""nofollow noreferrer"">here</a>). I'm not understanding though how would this work. Suppose for example I want to add a control to an XPowGate from cirq. How would I write this in a program and how would I define the control qubit and the qubit over which I want to act?</p>
",<programming><cirq>,2/18/2019 19:50,5522.0,5522.0,"<p>You can use the <code>controlled_by</code> method on any Operation:</p>

<pre><code>op = cirq.X(target_qubit).controlled_by(control_qubit)
</code></pre>

<p>You can also use <code>controlled</code> before specifying the target qubits:</p>

<pre><code>op = cirq.X.controlled().on(control_qubit, target_qubit)
</code></pre>

<p>There are also built-in controlled operations such as <code>cirq.CNOT</code>, <code>cirq.CZ</code>, and <code>cirq.CSWAP</code>. The built-in operations are generally preferable because they have hand-tuned gate decompositions and simulation methods. The general <code>controlled_by</code> has to fall back to more general methods.</p>

<p>Note that the controlled versions of gates support things like raising to a power. The following three expressions produce equivalent operations:</p>

<pre><code>(cirq.X(q)**0.5).controlled_by(c)

(cirq.X**0.5).on(q).controlled_by(c)

cirq.X(q).controlled_by(c)**0.5
</code></pre>
",2/18/2019 22:45,API Usage,"The user is seeking guidance on how to use the ControlledGate in Cirq to add a control to a previously defined gate, which involves using Cirq's API for gate manipulation.",API Usage,,,,API Usage,
5557.0,"""Wait"" gate throws an error ""NotImplementedError: ('No decomposition rules defined for ', 'wait')""","<p>My Quantum circuit contains <a href=""https://qiskit.org/documentation/autodoc/qiskit.extensions.simulator.wait.html"" rel=""nofollow noreferrer"">""Wait"" Gate</a>.  When I try to execute it (<code>qasm_simulator</code> or <code>unitary-simulator</code>), it throws an error . <strong>NotImplementedError: ('No decomposition rules defined for ', 'wait')</strong>.</p>

<p><strong>Question</strong>
1.How to resolve the error?
2.What is the unit of <code>t</code> specified in ""wait"" gate arguments?</p>

<p>Dev Env</p>

<p>Anaconda (python 3.6)
qiskit 0.7.3
qiskit-aer 0.1.1
qiskit-terra 0.7.0</p>

<p>OS
Mac v10.14</p>

<p>Qiskit installation by <code>pip install qiskit</code></p>

<p><strong>Minimal Example</strong></p>



<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.extensions.standard import RXGate, RYGate, RZGate, U3Gate
from qiskit.extensions.simulator import wait


from qiskit import execute, BasicAer, Aer

qubit = QuantumRegister(1, 'qubit')
circuit = QuantumCircuit(qubit)

circuit.x(qubit)
circuit.wait(1e-6, qubit)
circuit.rx(3.1416, qubit)

backend = Aer.get_backend('statevector_simulator')
job = execute(circuit, backend)
result = job.result()
outputstate = result.get_statevector(circuit, decimals=3)
print(outputstate)
</code></pre>

<p>If I comment the line <code>circuit.wait(...)</code> it runs fine. I tried the <code>qasm_simulator</code> with counts/measurements (same error)</p>
",<programming><qiskit>,2/25/2019 23:08,5571.0,5571.0,"<p>The <code>wait</code> command has now been deprecated, which is probably why it's causing you problems.</p>

<p>Instead you can use the identity gate <code>iden</code>. You should also use barriers either side so that the compiler doesn't remove it.</p>

<pre><code>circuit.x(qubit)
circuit.barrier(qubit)
circuit.iden(qubit)
circuit.barrier(qubit)
circuit.rx(3.1416, qubit)
</code></pre>

<p>This causes a delay for a the same time as a single <code>u2</code> gate, which is the time needed for a single <span class=""math-container"">$\pi/2$</span>-pulse (see <a href=""https://arxiv.org/abs/1707.03429"" rel=""nofollow noreferrer"">here</a>).</p>
",2/27/2019 22:08,Errors,"The user is encountering an error related to using the ""Wait"" gate in a Quantum circuit in Qiskit and is seeking assistance in resolving the error and understanding the unit of the ""t"" parameter in the ""wait"" gate",Errors,,,,Errors,
5562.0,Building an N-qubit Controlled S Gate,"<p>I've been beating my head against this problem for three days now and I just can't seem to crack it. To construct an N-qubit controlled Unitary gate, I can do something like this (note I'm using Qiskit syntax here):</p>

<pre><code>q_upper = QuantumRegister(n - 1)
q_lower = QuantumRegister(1)
q_out = QuantumRegister(1)
circ = QuantumCircuit(q_upper, q_lower, q_out)

# Setup u on the output line: |((1 &lt;&lt; (n - 1)) - 1) 01&gt; * u/2, |n0 11&gt; * u/2, |((1 &lt;&lt; n) - 1) 1&gt; * u
circ.cnv(q_upper, q_out)
circ.cv(q_lower, q_out)

# Cancel out the terms that aren't all ones
circ.cnx(q_upper, q_lower)
circ.vdg(q_lower, q_out)
circ.cnx(q_upper, q_lower)
</code></pre>

<p>This circuit requires a little explanation. Here, I'm attempting to build an n-qubit u-gate using an (n-1)-qubit controlled v-gate (which will be half the rotation of u) and a a controlled v-gate. Then I use an (n-1)-qubit controlled x-gate in conjunction with another controlled v-gate to cancel out the terms that aren't all one.</p>

<p>As an example of the implementation, consider the Controlled-S (CS) gate:</p>

<pre><code>q_lower = QuantumRegister(1)
q_out = QuantumRegister(1)
circ = QuantumCircuit(q_lower, q_out)

# Add a pi/2 rotation for 11, pi/4 for 01 and 10
circ.t(q_lower)
circ.t(q_out)

# Cancel out the pi/4 for 01 and 10
circ.cx(q_lower, q_out)
circ.tdg(q_out)
circ.cx(q_lower, q_out)
</code></pre>

<p>I can expand on this to produce a Toffoli-S (CCS) gate:</p>

<pre><code>q_upper = QuantumRegister(1)
q_lower = QuantumRegister(1)
q_out = QuantumRegister(1)
circ = QuantumCircuit(q_upper, q_lower, q_out)

# Construct a pi/2 rotation for 111 and pi/4 rotations for 011 and 101
circ.cu1(pi / 4, q_upper, q_out)
circ.cu1(pi / 4, q_lower, q_out)

# Cancel out the pi/4 rotations on 011 and 101
circ.cx(q_upper, q_lower)
circ.cu1(pi / -4, q_lower, q_out)
circ.cx(q_upper, q_lower)
</code></pre>

<p>I can expand it again to produce a CCCS gate:</p>

<pre><code>q_upper = QuantumRegister(2)
q_lower = QuantumRegister(1)
q_out = QuantumRegister(1)
circ = QuantumCircuit(q_upper, q_lower, q_out)

# Construct a pi/2 rotation for 1111 and pi/4 rotations for 1101 and 0011
circ.ccu1(pi / 4, q_upper[0], q_upper[1], q_out[0])
circ.cu1(pi / 4, q_lower, q_out)

# Cancel out the pi/4 rotations for 1101 and 0011
circ.ccx(q_upper[0], q_upper[1], q_lower[0])
circ.cu1(pi / -4, q_lower, q_out)
circ.ccx(q_upper[0], q_upper[1], q_lower[0])
</code></pre>

<p>Now, this circuit presents a problem: there is no <code>ccu1</code> gate. Now, I could construct one that looks like this:</p>

<pre><code>circ.cu1(pi / 8, q_upper[0], q_out)
circ.cu1(pi / 8, q_upper[1], q_out)
circ.cx(q_upper[0], q_upper[1])
circ.cu1(pi / -8, q_upper[1], q_out)
circ.cx(q_upper[0], q_upper[1])
</code></pre>

<p>But this means that an N-qubit Controlled-S gate would require an (N-1)-qubit Controlled-T gate which would require an (N-2)-qubit Controlled <code>pi / 8</code> gate and so on and so forth, resulting in increasingly small rotations. Given the current state of quantum hardware (and probably the future of quantum hardware), this implementation doesn't seem practical but I haven't been able to find a better one.</p>

<p>Could anyone suggest a way to break this recursion at either the S-gate or T-gate level or will I have to just deal with the recursion?</p>
",<programming><circuit-construction><qiskit><gate-synthesis>,2/27/2019 7:02,5563.0,5563.0,"<p>The angles getting smaller is not a problem. The actual problem is that you are generating a ton of gates. To produce one gate with N controls, you're recursing on the producing of 3 gates with N-1 controls. Follow the logic to the end, and you'll see that you end up with <span class=""math-container"">$3^N$</span> gates!</p>

<p>It is possible to reduce the number of gates from exponential to linear. In the ideal case, you have <span class=""math-container"">$N$</span> ancillae available and can use Toffoli gates to compute the AND of your control qubits. You apply the S gate to the qubit storing the AND, then uncompute.</p>

<p><a href=""https://i.stack.imgur.com/c6GHX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c6GHX.png"" alt=""simple CCCCS""></a></p>

<p>If you don't have any workspace, <a href=""https://algassert.com/circuits/2015/06/22/Using-Quantum-Gates-instead-of-Ancilla-Bits.html"" rel=""nofollow noreferrer"">it gets a lot more complicated. You have to do stuff like this</a>:</p>

<p><a href=""https://i.stack.imgur.com/0mRzo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0mRzo.png"" alt=""decompose Toffoli""></a></p>

<p>and this</p>

<p><a href=""https://i.stack.imgur.com/TDFKU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TDFKU.png"" alt=""free up an ancilla""></a></p>
",2/27/2019 7:42,Tooling,The user is asking about how to construct an N-qubit controlled Unitary gate using Qiskit and is seeking a way to break the recursion at either the S-gate or T-gate level. } am I right for the above question,Tooling,,,,Tooling,
5635.0,What language is more suitable for quantum machine learning algorithms?,"<p>What language is more suitable for quantum machine learning algorithms? Is it right that it's Python + Pyquil? Or something else?</p>

<p>And do you know the sources where you can see the sample codes of different quantum ML algorithms if it exists? I didn't find anything.</p>
",<programming><resource-request><machine-learning>,03/06/2019 02:27,5636.0,5636.0,"<p>One can recommend <a href=""https://pennylane.readthedocs.io/en/latest/"" rel=""nofollow noreferrer"">PennyLane</a> by Xanadu.AI. You can find complete examples of quantum machine learning algorithms (e.g. Iris Classification), using hybrid quantum-classical computations.</p>

<p>Additionally, they offer built-in <a href=""https://pennylane.ai/plugins.html"" rel=""nofollow noreferrer"">plugins</a> for IBM QisKit, Pyquil etc., to enable running Pennylane QML codes on IBM and Rigetti quantum hardwares.</p>
",03/06/2019 05:22,Learning ,"The user is asking for learning resources and sample codes for quantum machine learning algorithms, which falls under the Learning category. They are seeking to understand which programming language is more suitable for quantum machine learning and where they can find sample codes. ", Learning,,,,Learning ,
5668.0,Qiskit predecessor and successor map of DAG circuits,"<p>I am trying to figure out how to use the functions <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/dagcircuit/_dagcircuit.py"" rel=""nofollow noreferrer"">""_make_pred_succ_maps""</a>. Here is a description of the function from Github:</p>

<pre><code>def _make_pred_succ_maps(self, n):
    """"""Return predecessor and successor dictionaries.
    Args:
        n (int): reference to self.multi_graph node id
    Returns:
        tuple(dict): tuple(predecessor_map, successor_map)
            These map from wire (Register, int) to predecessor (successor)
            nodes of n.
    """"""
</code></pre>

<p>Nevertheless, I do not understand how to interpret outputs like the following:</p>

<pre><code>&gt;&gt;&gt; circuit_name._make_pred_succ_maps(1)
({}, {(QuantumRegister(3, 'a'), 0): 10})

&gt;&gt;&gt; circuit_name._make_pred_succ_maps(2)
({(QuantumRegister(3, 'a'), 0): 41}, {})
</code></pre>

<p>What do the individual numbers mean?</p>
",<programming><qiskit>,03/08/2019 10:27,5739.0,5739.0,"<p><code>(QuantumRegister(3, 'a'), 0)</code>
 means the 0th qubit in a QuantumRegister called <code>'a'</code> of size 3. </p>

<p>The other numbers (10 and 41) are node ids for the predecessors and successors of the node. </p>

<p>So what <code>({(QuantumRegister(3, 'a'), 0): 41}, {})</code> is saying is there is an edge from node 41 along wire <code>(QuantumRegister(3, 'a'), 0)</code> that ends at node 2 (the node you provided) and that this node has no successors as the second dict is empty.</p>

<p>It is also worth noting this is a private function and so should not really be used in this way.</p>
",3/19/2019 9:29,API Usage," The user is asking for help in understanding the usage and output of a specific function in the Qiskit library, which falls under the API Usage category. They are seeking to understand how to interpret the output of the _make_pred_succ_maps function.",Tooling,"The question is about interpreting the output of a specific function in quantum circuit tooling (Qiskit), specifically regarding the ""predecessor and successor dictionaries"" used in circuit representation.",No,76.0,Tooling,"The user is inquiring about interpreting the output of a specific function in Qiskit, relating to the ""predecessor and successor dictionaries"" used in circuit representation, falling under the category of tooling in quantum software engineering."
5702.0,Problems with qiskit-terra: missing members of instance QuantumCircuit,"<p>I have installed a Python 3.7.2, download anaconda and visual studio code. Install Qiskit SDK 0.5.3. But when I launch my first test program from <a href=""https://github.com/Qiskit/qiskit-terra"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra</a> I received a couple of messages like </p>

<pre><code>{
""message"": ""Instance of 'QuantumCircuit' has no 'h' member"",
""message"": ""Instance of 'QuantumCircuit' has no 'cx' member"",
""message"": ""Instance of 'QuantumCircuit' has no 'measure' member"",
}
</code></pre>

<p>What I do wrong?</p>

<p>This is my code:</p>

<pre><code>from qiskit import *
q = QuantumRegister(2)
c = ClassicalRegister(2)
qc = QuantumCircuit(q, c)
qc.h(q[0])
qc.cx(q[0], q[1])
qc.measure(q, c)
backend_sim = BasicAer.get_backend('qasm_simulator')
result = execute(qc, backend_sim).result()
print(result.get_counts(qc))
</code></pre>
",<programming><qiskit>,3/14/2019 10:31,5713.0,5713.0,"<p>The problem was at linter.</p>

<p>It's necessary to add </p>

<pre><code> ""python.linting.pylintArgs"": [
        ""--disable=E1101""
    ]
</code></pre>

<p>to the <code>settings.json</code>.</p>
",3/15/2019 7:29,Errors,"The user is encountering an error when running a Qiskit program, specifically related to missing members in the QuantumCircuit class, and is seeking assistance in resolving the error.",Errors,,,,Errors,
5729.0,Import from qiskit-aqua error,"<p>I try to use Quantum SVM kernel algorithm: multiclass classifier extension. This is my code section with imports</p>

<pre><code>import numpy as np
import scipy
from scipy.linalg import expm
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.decomposition import PCA


from qiskit import BasicAer
from qiskit_aqua import run_algorithm
from qiskit_aqua.input import SVMInput
import qsvm_datasets 
</code></pre>

<p>I have an error at import any library. I received the <code>ImportError: DLL load failed:</code> message. All libs are installed correctly. I found in my folders needed file at <code>\Python\Libs\site-packages\qiskit_aqua\input\svminput.py</code>.</p>

<p>That's my debug log:</p>

<pre><code>Warning (from warnings module):
  File ""D:\QASM\Python368\lib\site-packages\sklearn\externals\joblib\externals\cloudpickle\cloudpickle.py"", line 47
    import imp
DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
Traceback (most recent call last):
  File ""\1.py"", line 14, in &lt;module&gt;
    from qiskit_aqua import run_algorithm
  File ""D:\QASM\Python368\lib\site-packages\qiskit_aqua\__init__.py"", line 29, in &lt;module&gt;
    from .utils.backend_utils import (get_aer_backend,
  File ""D:\QASM\Python368\lib\site-packages\qiskit_aqua\utils\__init__.py"", line 31, in &lt;module&gt;
    from .qpsolver import optimize_svm
  File ""D:\QASM\Python368\lib\site-packages\qiskit_aqua\utils\qpsolver.py"", line 21, in &lt;module&gt;
    from cvxopt import matrix, solvers
  File ""D:\QASM\Python368\lib\site-packages\cvxopt\__init__.py"", line 50, in &lt;module&gt;
    import cvxopt.base
ImportError: DLL load failed
</code></pre>
",<programming><qiskit>,3/18/2019 10:53,5737.0,5737.0,"<p>You are probably running Python 3.7 on Windows.  There is a known issue for the bug you are seeing: <a href=""https://github.com/Qiskit/qiskit-aer/issues/80"" rel=""noreferrer"">https://github.com/Qiskit/qiskit-aer/issues/80</a></p>
",3/19/2019 7:50,Errors," The user is encountering an error related to DLL load failure when trying to import certain libraries in their code, particularly related to Qiskit Aqua, and is seeking assistance in resolving this import error.",Errors,,,,Errors,
5773.0,Evolving a quantum circuit using a genetic algorithm,"<p>I've written a small quantum circuit simulator in python, so now I'm trying to evolve some circuits via genetic algorithms. My encoding is very simple, it's just a rectangular table of strings representing the gates. Here's a example of a random circuit:</p>

<pre><code>+--------+--------+--------+-------+--------+-------+
| qubit  | col_0  | col_1  | col_2 | col_3  | col_4 |
+--------+--------+--------+-------+--------+-------+
| q0--&gt;  |   I    | CNOT_2 |   S   |   Z    |   H   |
| q1--&gt;  | CNOT_0 |   T    |   S   |   I    |   T   |
| q2--&gt;  |   S    |   I    |   S   | CNOT_1 |   S   |
+--------+--------+--------+-------+--------+-------+
</code></pre>

<p>My first attempt is to generate the Toffoli gate, which input/output I encoded as follows:</p>

<pre><code>inputs = [[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 0]]
output_zero_probs = [[1, 1, 1], [1, 0, 1], [0, 1, 1], [0, 0, 0]]
</code></pre>

<p>So there are 4 input tests, and for each one there is the correspondent output. The variable <em>output_zero_probs</em> is the probability of measuring 0 for each wire for each input. Note that the last qubit holds the answer.</p>

<p>So for example, if the input is [1, 1, 0], the output should be [1, 1, 1], which correspondes to output_zero_probs of [0, 0, 0].</p>

<p>The fitness functions is just some measure of similarity between the circuit output and the expected output probabilities. The circuit dimension was fixed to 3 x 17, ie, 3 qubits x 17 columns. The mutation operator just changes a random cell, and the crossover operator exchanges an entire 'column' between 2 circuits.</p>

<p>So far it was not able to find the correct solution, it seems to evolve a bit, then it get stuck. Is this a feasible problem for a GA? If so, how can I improve on this? I mean, how can I 'push' the circuit to the right direction?</p>

<p>Thanks for your attention!</p>

<hr>

<p><strong>EDIT:</strong></p>

<p>Now I think it's better to compare the final state of the system with the expected final state, instead of using probabilities, because these may change depending on the measures (I'm not sure if this reasoning is correct).</p>

<p>Follow up question: <a href=""https://quantumcomputing.stackexchange.com/questions/5833/genetic-algorithm-does-not-converge-to-exact-solution"">Genetic algorithm does not converge to exact solution</a></p>
",<programming><circuit-construction><optimization>,3/26/2019 3:09,5774.0,5774.0,"<p>So in your example, you try to find the quantum circuit representing the Toffoli operation.
I would then change my objective/fitness function and compare the unitary matrix representing the operation. You can use an minimization objective like : 
<span class=""math-container"">$$ \mathcal{F} = 1-\frac{1}{2^n} |\operatorname{Tr}(U_aU_t^{\dagger})| $$</span></p>

<p>with <span class=""math-container"">$ U_a $</span> is the unitary of the generated solution and <span class=""math-container"">$ U_t $</span> the unitary you are trying to get. The trace part of this objective means try to get <span class=""math-container"">$ U_aU_t^{\dagger} $</span> to the identity matrix on <span class=""math-container"">$n$</span> qubits.</p>

<p>Also, when using a genetic algorithm, many strategies can be tried, and may generate better solutions than others. You can look at this <a href=""https://quantumcomputing.stackexchange.com/questions/4426/understanding-the-group-leaders-optimization-algorithm"">question</a> where a genetic algorithm is used for circuit decomposition.</p>
",3/26/2019 8:04,Theoretical,"The user question falls under the Theoretical category as it involves understanding and application of quantum circuits and genetic algorithms, which are theoretical concepts in quantum computing. The user is seeking advice on how to improve the performance of a genetic algorithm for evolving quantum circuits",Conceptual,The user is discussing the feasibility of using a genetic algorithm to evolve quantum circuits and is seeking advice on improving the optimization process. This pertains to a conceptual understanding of how to approach the problem and improve the algorithm's performance.,No,77.0,Theoretical," The user's question involves understanding and applying theoretical concepts in quantum computing, specifically regarding the evolution of quantum circuits using a genetic algorithm. They seek advice on improving the algorithm's performance, which aligns with the theoretical aspects of quantum circuit design and optimization."
5829.0,"Implementing ""Classical AND Gate"" and ""Classical OR Gate"" with a quantum circuit","<h1>Quantum cNOT Gate (Classical XOR Gate)</h1>

<p>A ""Controlled NOT (cNOT) Gate"" flips the 2nd qubit if the 1st qubit is <span class=""math-container"">$\left|1\right&gt;$</span>, and returns the 2nd qubit as-is if the 1st qubit is <span class=""math-container"">$\left|0\right&gt;$</span>. The 1st qubit is simply not changed.</p>

<p>The net effect of this gate is a classical XOR gate:</p>

<ul>
<li>It keeps the 1st qubit unchanged</li>
<li>It outputs ""the 1st qubit XOR the 2nd qubit"" as the result of the 2nd qubit</li>
</ul>

<p>In table form, the function looks like:</p>

<p><span class=""math-container"">$$
\begin{array}{|c|c|}
 \hline
 \text{Input} &amp; \text{Output} \\
 \hline
 \begin{array}{cc}0 &amp; 0\end{array} &amp; \begin{array}{cc}0 &amp; 0\end{array} \\
 \hline  
 \begin{array}{cc}0 &amp; 1\end{array} &amp; \begin{array}{cc}0 &amp; 1\end{array} \\
 \hline
 \begin{array}{cc}1 &amp; 0\end{array} &amp; \begin{array}{cc}1 &amp; \color{red}{1}\end{array} \\
 \hline  
 \begin{array}{cc}1 &amp; 1\end{array} &amp; \begin{array}{cc}1 &amp; \color{red}{0}\end{array} \\
 \hline  
\end{array}
$$</span></p>

<p>Therefore, an input:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\gamma\left|10\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>is mapped to:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\gamma\left|1\color{red}{1}\right&gt;+\delta\left|1\color{red}{0}\right&gt;$$</span></p>

<p>Or, in other words:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\color{red}{\delta}\left|10\right&gt;+\color{red}{\gamma}\left|11\right&gt;$$</span></p>

<p>In matrix form, we need to find the all the <span class=""math-container"">$a_{ij}$</span>'s that satisfy the following:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
    a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
    a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
    a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \color{red}{\delta} \\
    \color{red}{\gamma} \\
    \end{pmatrix}
$$</span></p>

<p>It is trivial to find the solution:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \color{red}{0} &amp; \color{red}{1} \\
    0 &amp; 0 &amp; \color{red}{1} &amp; \color{red}{0} \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \color{red}{\delta} \\
    \color{red}{\gamma} \\
    \end{pmatrix}
$$</span></p>

<hr>

<h1>Quantum AND Gate?</h1>

<p>Similarly, if there exists a gate that mimics the classical AND gate, it should have the following net effect:</p>

<ul>
<li>It keeps the 1st qubit unchanged</li>
<li>It outputs ""the 1st qubit AND the 2nd qubit"" as the result of the 2nd qubit</li>
</ul>

<p>In table form, the function looks like:</p>

<p><span class=""math-container"">$$
\begin{array}{|c|c|}
 \hline
 \text{Input} &amp; \text{Output} \\
 \hline
 \begin{array}{cc}0 &amp; 0\end{array} &amp; \begin{array}{cc}0 &amp; 0\end{array} \\
 \hline  
 \begin{array}{cc}0 &amp; 1\end{array} &amp; \begin{array}{cc}0 &amp; \color{red}{0}\end{array} \\
 \hline
 \begin{array}{cc}1 &amp; 0\end{array} &amp; \begin{array}{cc}1 &amp; 0\end{array} \\
 \hline  
 \begin{array}{cc}1 &amp; 1\end{array} &amp; \begin{array}{cc}1 &amp; 1\end{array} \\
 \hline  
\end{array}
$$</span></p>

<p>Therefore, an input:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\gamma\left|10\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>should be mapped to:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|0\color{red}{0}\right&gt;+\gamma\left|10\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>Or, in other words:</p>

<p><span class=""math-container"">$$\color{red}{(\alpha+\beta)}\left|00\right&gt;+\color{red}{0}\left|01\right&gt;+\gamma\left|10\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>In matrix form, we need to find the all the <span class=""math-container"">$a_{ij}$</span>'s that satisfy the following:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
    a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
    a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
    a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \color{red}{\alpha+\beta} \\
    \color{red}{0} \\
    \gamma \\
    \delta \\
    \end{pmatrix}
$$</span></p>

<p>It is trivial to find the solution:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    1 &amp; \color{red}{1} &amp; 0 &amp; 0 \\
    0 &amp; \color{red}{0} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \color{red}{\alpha+\beta} \\
    \color{red}{0} \\
    \gamma \\
    \delta \\
    \end{pmatrix}
$$</span></p>

<hr>

<h1>Quantum OR Gate?</h1>

<p>Similarly, if there exists a gate that mimics the classical OR gate, it should have the following net effect:</p>

<ul>
<li>It keeps the 1st qubit unchanged</li>
<li>It outputs ""the 1st qubit OR the 2nd qubit"" as the result of the 2nd qubit</li>
</ul>

<p>In table form, the function looks like:</p>

<p><span class=""math-container"">$$
\begin{array}{|c|c|}
 \hline
 \text{Input} &amp; \text{Output} \\
 \hline
 \begin{array}{cc}0 &amp; 0\end{array} &amp; \begin{array}{cc}0 &amp; 0\end{array} \\
 \hline  
 \begin{array}{cc}0 &amp; 1\end{array} &amp; \begin{array}{cc}0 &amp; 1\end{array} \\
 \hline
 \begin{array}{cc}1 &amp; 0\end{array} &amp; \begin{array}{cc}1 &amp; \color{red}{1}\end{array} \\
 \hline  
 \begin{array}{cc}1 &amp; 1\end{array} &amp; \begin{array}{cc}1 &amp; 1\end{array} \\
 \hline  
\end{array}
$$</span></p>

<p>Therefore, an input:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\gamma\left|10\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>should be mapped to:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\gamma\left|1\color{red}{1}\right&gt;+\delta\left|11\right&gt;$$</span></p>

<p>Or, in other words:</p>

<p><span class=""math-container"">$$\alpha\left|00\right&gt;+\beta\left|01\right&gt;+\color{red}{0}\left|10\right&gt;+\color{red}{(\gamma+\delta)}\left|11\right&gt;$$</span></p>

<p>In matrix form, we need to find the all the <span class=""math-container"">$a_{ij}$</span>'s that satisfy the following:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
    a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
    a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
    a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \color{red}{0} \\
    \color{red}{\gamma+\delta} \\
    \end{pmatrix}
$$</span></p>

<p>It is trivial to find the solution:</p>

<p><span class=""math-container"">$$
    \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \color{red}{0} &amp; 0 \\
    0 &amp; 0 &amp; \color{red}{1} &amp; 1 \\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \gamma \\
    \delta \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    \alpha \\
    \beta \\
    \color{red}{0} \\
    \color{red}{\gamma+\delta} \\
    \end{pmatrix}
$$</span></p>

<hr>

<p>However, since:</p>

<p><span class=""math-container"">$$
    A
    =
    \begin{pmatrix}
    1 &amp; \color{red}{1} &amp; 0 &amp; 0 \\
    0 &amp; \color{red}{0} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    \end{pmatrix}
$$</span></p>

<p>and</p>

<p><span class=""math-container"">$$
    B
    =
    \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \color{red}{0} &amp; 0 \\
    0 &amp; 0 &amp; \color{red}{1} &amp; 1 \\
    \end{pmatrix}
$$</span></p>

<p>are not unitary matrices, as shown by <span class=""math-container"">$\det(A) = \det(B) = 0 \ne 1$</span>, they could not be implemented directly as a quantum logic gate.</p>

<p>I have read the answer here:</p>

<p><a href=""https://quantumcomputing.stackexchange.com/a/132/6152"">If quantum gates are reversible how can they possibly perform irreversible classical AND and OR operations?</a></p>

<p>but it is not intuitive enough for me:</p>

<ul>
<li>to understand what the final solution is; and</li>
<li>to visualize how it achieves the same result as the matrix <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> above.</li>
</ul>

<p>Does anyone have any idea on how to implement ""Classical AND"" and ""Classical OR"" with an explanation in matrix form? Thanks!</p>
",<quantum-gate><classical-computing><unitarity>,04/01/2019 15:04,5838.0,5838.0,"<p>Your <em>construction by gueswork</em> in <a href=""https://quantumcomputing.stackexchange.com/a/5834"">this answer</a>  is OK but not really elegant. Moreover, it's a convention to start in the state <span class=""math-container"">$|0\rangle$</span>; we usually don't initialize a qubit with the state <span class=""math-container"">$|1\rangle$</span>. It's better to follow the general construction which I illustrate here. </p>

<hr>

<p>The idea here is to use ancillary qubits and impose unitary evolution on the larger system instead i.e. by treating the two-qubit system as a subsystem. There's a general method for constructing such gates. Essentially, you are trying to construct a quantum gate that'll perform a Boolean mapping like <span class=""math-container"">$f: \{0, 1\}^n \longrightarrow \{0, 1\}$</span>. You've noted that for <span class=""math-container"">$n=2$</span> (two qubits), you cannot constructing unitary gates corresponding to some classical operations like the AND and OR as there's a rank deficiency (this happens precisely because those classical operations <a href=""https://quantumcomputing.stackexchange.com/a/5276"">are irreversible</a>). So we'll try with <span class=""math-container"">$n=3$</span> instead. Let's take the example of the quantum OR gate, which would perform the mapping <span class=""math-container"">$$|a \ b \ c\rangle \mapsto |a \ b \ c\oplus(a+b)\rangle$$</span> where <span class=""math-container"">$a,b,c \in \{0,1\}$</span>. By the way, <span class=""math-container"">$\oplus$</span> here stands for XOR and <span class=""math-container"">$+$</span> stands for OR. You do know that <span class=""math-container"">$0 \oplus x = x$</span> for any <span class=""math-container"">$x \in \{0,1\}$</span>? Otherwise, check the <a href=""https://en.wikipedia.org/wiki/XOR_gate"" rel=""noreferrer"">XOR table</a>. Thus, if we set the additional qubit to <span class=""math-container"">$|0\rangle$</span> initially, it boils down to <span class=""math-container"">$$|a \ b \ 0\rangle \mapsto |a \ b \ a+b\rangle.$$</span> </p>

<p>Let's construct the table now.</p>

<p><span class=""math-container"">$$\begin{array}{|c c c|c c c|}
\hline
a &amp; b &amp; c &amp; a &amp; b &amp; c\oplus (a+b) \\ \hline
0 &amp; 0 &amp; \color{red}{0} &amp; 0 &amp; 0 &amp; \color{red}{0}       \\ \hline
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1       \\ \hline
0 &amp; 1 &amp; \color{red}{0} &amp; 0 &amp; 1 &amp; \color{red}{1}       \\ \hline
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0       \\ \hline
1 &amp; 0 &amp; \color{red}{0} &amp; 1 &amp; 0 &amp; \color{red}{1}       \\ \hline
1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0       \\ \hline
1 &amp; 1 &amp; \color{red}{0} &amp; 1 &amp; 1 &amp; \color{red}{1}       \\ \hline
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0       \\ \hline
\end{array}$$</span></p>

<p>We're only only concerned with the cases where <span class=""math-container"">$c=0$</span> i.e. the ones marked in red. Half done now! If we translate this to mapping of the computational basis vectors of the three-qubit system, we get</p>

<p><span class=""math-container"">$$|000\rangle \mapsto |000\rangle \equiv [1 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0]^T \mapsto \color{blue}{[1 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|001\rangle \mapsto |001\rangle \equiv [0 \ 1 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0]^T \mapsto \color{brown}{[0 \ 1 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|010\rangle \mapsto |011\rangle \equiv [0 \ 0 \ 1 \ 0 \ 0 \ 0 \ 0 \ 0]^T \mapsto \color{teal}{[0 \ 0 \ 0 \ 1 \ 0 \ 0 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|011\rangle \mapsto |010\rangle \equiv [0 \ 0 \ 0 \ 1 \ 0 \ 0 \ 0 \ 0]^T \mapsto \color{violet}{[0 \ 0 \ 1 \ 0 \ 0 \ 0 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|100\rangle \mapsto |101\rangle \equiv [0 \ 0 \ 0 \ 0 \ 1 \ 0 \ 0 \ 0]^T \mapsto \color{green}{[0 \ 0 \ 0 \ 0 \ 0 \ 1 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|101\rangle \mapsto |100\rangle \equiv [0 \ 0 \ 0 \ 0 \ 0 \ 1 \ 0 \ 0]^T \mapsto \color{magenta}{[0 \ 0 \ 0 \ 0 \ 1 \ 0 \ 0 \ 0]^T}$$</span>
<span class=""math-container"">$$|110\rangle \mapsto |111\rangle \equiv [0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \ 0]^T \mapsto \color{orange}{[0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1]^T}$$</span>
<span class=""math-container"">$$|111\rangle \mapsto |110\rangle \equiv [0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1]^T \mapsto \color{purple}{[0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \ 0]^T}$$</span></p>

<p>The columns vectors highlighted in blue will the columns of the required matrix cf. <a href=""https://en.wikipedia.org/wiki/Change_of_basis#Transformation_matrix"" rel=""noreferrer"">change of basis transformation matrix</a>. The matrix is certainly unitary as basis vectors are simply getting mapped to basis vectors, and the mapping is <a href=""https://en.wikipedia.org/wiki/Bijection"" rel=""noreferrer"">bijective</a>. </p>

<p><span class=""math-container"">$$\color{red}{\text{quantum OR}} = \begin{pmatrix}
{\color{blue} 1} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\ 
{\color{blue} 0} &amp; {\color{brown} 1} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\ 
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 1} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 1} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 1} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 1} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 0} \\
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 0} &amp; {\color{purple} 1} \\
{\color{blue} 0} &amp; {\color{brown} 0} &amp; {\color{teal} 0} &amp; {\color{violet} 0} &amp; {\color{green} 0} &amp; {\color{magenta} 0} &amp; {\color{orange} 1} &amp; {\color{purple} 0} \\
\end{pmatrix}
$$</span></p>

<p>Calculate the determinant and convince yourself that it's unitary.</p>

<p><strong>Exercise:</strong> </p>

<ol>
<li><p>Use the method demonstrated here to construct the quantum gates corresponding to the classical NAND, NOR and XNOR gates. </p></li>
<li><p>Prove that the mapping defined by <span class=""math-container"">$(a,b,c)\mapsto (a, b, c\oplus f(a,b))$</span> is one-one and onto, where <span class=""math-container"">$f$</span> is any arbitrary <a href=""https://en.wikipedia.org/wiki/Boolean_function"" rel=""noreferrer"">Boolean function</a> of <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span>.</p></li>
</ol>
",04/02/2019 18:19, Theoretical ," The user is seeking to understand how to implement a quantum AND gate, similar to the classical AND gate, and how it would behave on certain inputs. This involves understanding the underlying principles and mathematical representations of quantum gates",Theoretical,,,, Theoretical ,
5866.0,Using latest (GitHub) version of Qiskit as Python library,"<p>I just started working in Qiskit and want to use some of the new functions available to Qiskit on Github. Unfortunately, I don't know how to implement the latest GitHub version into my Anaconda distribution of Python. </p>

<p>Anaconda uses an older Qiskit library which I installed using pip. I would now like to git clone the latest version of Qiskit into that location. How can I do this? When I just type <code>git clone https://github.com/Qiskit</code> or something similar, it doesn't work.</p>
",<programming><qiskit>,04/06/2019 19:26,5880.0,5880.0,"<p>Yes, installing Qiskit through <code>pip install</code> will install the latest, stable version of Qiskit onto your environment. So do note, the version you want to clone may not be functional with existing Jupyter Notebooks and other tutorials, since the code is not yet officially released.</p>

<p>That being said, cloning the repo is very easy. The URL that you were trying to clone, <code>https://github.com/Qiskit</code>, is the Qiskit Github user account page. That is why you were receiving an error. The repo that you are looking to clone would be <a href=""https://github.com/Qiskit/qiskit-terra"" rel=""nofollow noreferrer"" title=""qiskit-terra"">qiskit-terra</a>. Once you are there, you can follow this <a href=""https://help.github.com/en/articles/cloning-a-repository"" rel=""nofollow noreferrer"" title=""article on cloning github repositories"">article on cloning github repositories</a>.</p>

<p>Once you have cloned the repo, you can follow this <a href=""https://qiskit.org/documentation/install/terra.html#install-terra-source,"" rel=""nofollow noreferrer"" title=""guide"">guide</a> on how to install Qiskit Terra from the source code you just cloned.  </p>
",04/09/2019 13:38,Tooling,The user is seeking help on how to clone the latest version of Qiskit from GitHub and integrate it into their existing Anaconda environment.,Tooling,,,,Tooling,
5867.0,Qiskit DAG circuit - print information about individual gate/node by number,"<p>I created a DAG circuit in Qiskit and don't really understand how to see which gate is which. </p>

<p>I want to call a function like <code>dag_circuit.gate_info(gate_number)</code>, which will then print, for example, that gate number 9 is a hadamard gate <span class=""math-container"">$H$</span>, and that gate number 11 is a <span class=""math-container"">$U_3(\theta=0.1,\phi=0.2,\lambda=-0.5)$</span>.</p>

<p>How do I get this information?</p>
",<programming><qiskit>,04/06/2019 20:31,5882.0,5882.0,"<p><strong>NOTE: At the moment this method is correct, however, this information might be out of date once the 0.9 release of Qiskit is deployed.</strong></p>

<p>Hi Samuel, if you have a dag circuit and you want to access information about the nodes, you need to call <code>dag_circuit.multi_graph.nodes[index_of_node]</code></p>

<p>The information you can get from a node in the circuit is a dictionary containing the following:</p>

<ul>
<li>type (either ""in"", ""out"", or ""op"")</li>
<li>name (either a qubit, classical bit, or an operation name)</li>
<li>wire (the Register Object of the qubit or classical bit that the wire is attached to)</li>
</ul>

<p>An ""op"" node will will have these other values in addition to the ones above (excluding the ""wire"" value):</p>

<ul>
<li>'op' (The data type of the operation)</li>
<li>qargs (The qubits this gate is applied to)</li>
<li>cargs (The classical bits this gate is applied to)</li>
<li>condition</li>
</ul>

<p>In your example where you have an <span class=""math-container"">$H$</span> Gate at node 9 and a <span class=""math-container"">$U_3(\theta=0.1, \phi=0.2, \lambda=-0.5)$</span> Gate at node 11, if you were to call <code>print(dag_circuit.multi_graph.nodes[8])</code> and <code>print(dag_circuit.multi_graph.nodes[10])</code>, you would receive the following output:</p>

<p><code>{'type': 'op', 'op': &lt;qiskit.extensions.standard.h.HGate object at ""some_memory_address""&gt;, 'name': 'h', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None}</code><br>
<code>{'type': 'op', 'op': &lt;qiskit.extensions.standard.u3.U3Gate object at ""some_memory_address""&gt;, 'name': 'u3', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None}</code></p>
",04/09/2019 14:37,Tooling,"The user is asking about how to use a specific function in Qiskit, a software tool for quantum programming, to get information about gates in a DAG circuit. ",Tooling,,,,Tooling,
5869.0,(name of gate) is not in the list of basis operations,"<p>I'm trying to define a custom gate for my computations. I decided to copy the structure in one of the files in <code>qiskit.extensions.standard</code> package. Here is the code of <code>h.py</code> (Hadamard gate):</p>

<pre><code># -*- coding: utf-8 -*-

# Copyright 2017, IBM.
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.

# pylint: disable=invalid-name

""""""
Hadamard gate.
""""""
from qiskit.circuit import Gate
from qiskit.circuit import QuantumCircuit
from qiskit.circuit import InstructionSet
from qiskit.circuit import QuantumRegister
from qiskit.qasm import pi
from qiskit.dagcircuit import DAGCircuit
from qiskit.extensions.standard import header  # pylint: disable=unused-import
from qiskit.extensions.standard.u2 import U2Gate


class HGate(Gate):
    """"""Hadamard gate.""""""

    def __init__(self, qubit, circ=None):
        """"""Create new Hadamard gate.""""""
        super().__init__(""h"", [], [qubit], circ)

    def _define_decompositions(self):
        """"""
        gate h a { u2(0,pi) a; }
        """"""
        decomposition = DAGCircuit()
        q = QuantumRegister(1, ""q"")
        decomposition.add_qreg(q)
        decomposition.add_basis_element(""u2"", 1, 0, 2)
        rule = [
            U2Gate(0, pi, q[0])
        ]
        for inst in rule:
            decomposition.apply_operation_back(inst)
        self._decompositions = [decomposition]

    def inverse(self):
        """"""Invert this gate.""""""
        return self  # self-inverse

    def reapply(self, circ):
        """"""Reapply this gate to corresponding qubits in circ.""""""
        self._modifiers(circ.h(self.qargs[0]))


def h(self, q):
    """"""Apply H to q.""""""
    if isinstance(q, QuantumRegister):
        instructions = InstructionSet()
        for j in range(q.size):
            instructions.add(self.h((q, j)))
        return instructions

    if isinstance(q, QuantumRegister):
        instructions = InstructionSet()
        for j in range(q.size):
            instructions.add(self.h(q))
        return instructions

    self._check_qubit(q)
    return self._attach(HGate(q, self))


QuantumCircuit.h = h
</code></pre>

<p>Trying to change the names of the class, the property of <code>QuantumCircuit</code> and the name string in <code>Gate</code> constructor results in an exception <code>(name of the gate) is not in the list of basic operations</code>  if I try to either draw or execute an example circuit containing the gate.</p>

<p>""</p>

<pre><code>""""
[1]-const gate.
""""""
from qiskit.circuit import Gate
from qiskit.circuit import QuantumCircuit
from qiskit.circuit import InstructionSet
from qiskit.circuit import QuantumRegister
from qiskit.qasm import pi
from qiskit.dagcircuit import DAGCircuit
from qiskit.extensions.standard import header  # pylint: disable=unused-import
from qiskit.extensions.standard.u2 import U2Gate


class OneConstGate(Gate):

    def __init__(self, qubit, circ=None):
        super().__init__(""oneconst"", [], [qubit], circ)

    def _define_decompositions(self):
        decomposition = DAGCircuit()
        q = QuantumRegister(1, ""q"")
        decomposition.add_qreg(q)
        decomposition.add_basis_element(""u2"", 1, 0, 2)
        rule = [
            U2Gate(0, pi, q[0])
        ]
        for inst in rule:
            decomposition.apply_operation_back(inst)
        self._decompositions = [decomposition]

    def inverse(self):
        """"""Invert this gate.""""""
        return self  # self-inverse

    def reapply(self, circ):
        """"""Reapply this gate to corresponding qubits in circ.""""""
        self._modifiers(circ.oneconst(self.qargs[0]))


def oneconst(self, q):
    """"""Apply H to q.""""""
    if isinstance(q, QuantumRegister):
        instructions = InstructionSet()
        for j in range(q.size):
            instructions.add(self.oneconst((q, j)))
        return instructions

    if isinstance(q, QuantumRegister):
        instructions = InstructionSet()
        for j in range(q.size):
            instructions.add(self.oneconst(q))
        return instructions

    self._check_qubit(q)
    return self._attach(OneConstGate(q, self))


QuantumCircuit.oneconst = oneconst
</code></pre>

<p>Here is the example code:</p>

<pre><code>x = QuantumRegister(1, 'x')
gate = QuantumCircuit(x)
gate.oneconst(x[0])
gate.draw()
</code></pre>

<p>Note that I haven't changed any logic yet. Just the names. Did I forgot something?</p>

<h3>Edit (1):</h3>

<p>I had a look at <code>header.py</code> code in <code>qiskit.extensions.standard</code>. Adding these lines of code remove the error on <code>draw</code> method, but not in <code>execute</code> method:</p>

<pre><code>import sympy
from qiskit.circuit import QuantumCircuit
from qiskit.qasm import _node as node

QuantumCircuit.definitions[""oneconst""] = {
    ""print"": False,
    ""opaque"": False,
    ""n_args"": 0,
    ""n_bits"": 1,
    ""args"": [],
    ""bits"": [""a""],
    # gate x a { u3(pi,0,pi) a; }
    ""body"": node.GateBody([
        node.CustomUnitary([
            node.Id(""u3"", 0, """"),
            node.ExpressionList([
                node.Real(sympy.pi),
                node.Int(0),
                node.Real(sympy.pi)
            ]),
            node.PrimaryList([
                node.Id(""a"", 0, """")
            ])
        ])
    ])
}
</code></pre>
",<programming><qiskit>,04/07/2019 09:48,5884.0,5884.0,"<p>Did you add these lines to the file <code>qiskit/extensions/standard/__init__.py</code>:</p>

<p><code>from .oneconst import oneconst</code><br>
<code>from .oneconst import OneConstGate</code><br></p>

<p>I did everything you described doing, as well as added those lines to <code>__init__.py</code> and the following code ran without error:</p>

<pre><code>import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute
from qiskit import Aer

qr = QuantumRegister(1)
cr = ClassicalRegister(1)
gate = QuantumCircuit(qr, cr)
gate.oneconst(qr[0])
gate.measure(qr[0], cr[0])
print(gate.draw())

backend = Aer.get_backend(""qasm_simulator"")

job = execute(gate, backend, shots=100)

print(job.result().get_counts(gate))
</code></pre>
",04/09/2019 17:49,Tooling ,"The user is seeking guidance on how to modify and use custom gates in Qiskit, which involves tools and software usage in quantum programming.",Tooling,,,,Tooling ,
5877.0,How do I do printf debugging in Q# in a convenient way?,"<p>When initially writing an <code>operator</code> in Q#, I often want to see intermediate values of registers during the computation. This allows me to check that I haven't made mistakes. For example, if I was writing an addition circuit I would input a computational basis state and print out the computational basis states of qubits at particular key points.</p>

<p>I am not aware of a way to do this conveniently. If I print out the qubits like <code>Message($""{qubit}"")</code> then I get their IDs instead of their values. That makes sense. I have to do a measurement to access their value. But if I do a measurement, then Q# will e.g. not automatically generate an adjoint operation and this tends to cause compilation failures. Also, I don't actually want to perform a measurement (which may have side effects) I just want to peek at the simulator state.</p>

<p>(I originally thought I could package the concept of ""peeking"" at a value into an operation that did a hidden measurement, which would have resolved the issue. But Q# doesn't allow operations with an adjoint to have a return type.)</p>

<p>Is there some built-in way to get at the computational basis value of some qubits, and print it to the console during simulation under the Toffoli simulator?</p>
",<programming><q#>,04/08/2019 20:19,5878.0,5878.0,"<p>For Toffoli simulator in particular, <code>DumpRegister</code> will provide this information. For example, the following code</p>

<pre><code>operation XorTest() : Bool {
    using ((a, b) = (Qubit[2], Qubit[2])) {
        // initialize: a = 1, b = 2
        ApplyPauli([PauliI, PauliX], a);
        ApplyPauli([PauliX, PauliI], b);
        // check initialization
        Message(""a = "");
        DumpRegister((), a);
        Message(""b = "");
        DumpRegister((), b);
        // calculate a â b and write it to b
        CNOT(a[0], b[0]);
        CNOT(a[1], b[1]);
        // check result: a â b = 3
        Message(""a xor b = "");
        DumpRegister((), b);
    }
    return true;
}
</code></pre>

<p>will print the following result (and throw an exception in the end because the qubits are released not in zero state):</p>

<pre><code>a =
State:
0:      False
1:      True
b =
State:
2:      True
3:      False
a xor b =
State:
2:      True
3:      True
</code></pre>

<p>The numbers before values are qubit ids.</p>
",04/09/2019 01:14,Tooling,"The user is asking about how to use a specific function in Q#, a software tool for quantum programming, to see intermediate values of registers during the computation. ",Tooling,,,,Tooling,
5901.0,How do you start a simulation with a random initial state in Cirq?,"<p>How do you create a random initial state by modifying the <span class=""math-container"">$2^{n}$</span> vector amplitudes instead of starting every simulation at <span class=""math-container"">$|0000...000\rangle$</span>?</p>
",<programming><cirq>,04/12/2019 15:03,5902.0,5902.0,"<p>If you want a random computational basis state, set the input state to the integer <code>random.randint(0, 2**qubits-1)</code>.</p>

<p>If you want a random superposition sampled from the Haar measure, there is a method <code>cirq.testing.random_superposition(dim=2**qubits)</code>.</p>

<p>Once you have created your initial state, you pass it into the simulator like <code>cirq.Simulator().simulate(circuit, initial_state=...)</code>. Note that <code>run</code> methods do not support an initial state, because they are supposed to more closely mimic the hardware.</p>
",04/12/2019 15:50,Theoretical ,"The user is seeking to understand how to create a random initial state by modifying the amplitudes of a 2^n vector, instead of always starting every simulation at the state |0000000>.",Theoretical,,,,Theoretical ,
5904.0,Experiment runtime on IBMQ,"<p>I have been trying to get the runtime of my experiment on IBM's quantum computer. I am using the classic stuff, i.e</p>

<pre><code>job = execute(qwalk_circuit, backend='ibmq_16_melbourne', shots=1000)
results = job.result()
results.get_counts()
print(results.data())
</code></pre>

<p>I saw on another post that you could see the runtime by using <code>results.get_data()</code>, but that doesnt work anymore, giving me an error that the <code>get_data()</code> attribute does not exist. Is there another way to pull the runtime of my experiment from IBM's quantum computer backend?</p>

<p>My imports, in case I am missing something there:</p>

<pre><code># importing QISKit
from qiskit import Aer, IBMQ
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit import IBMQ, BasicAer
from qiskit.providers.ibmq import least_busy
from qiskit.tools.monitor import job_monitor
</code></pre>
",<programming><ibm-q-experience><ibm>,4/13/2019 10:22,9911.0,9911.0,"<p>I was recently looking for a similar solution. Hope this helps.</p>

<pre><code>job = execute(qc, backend=backend, shots=1024)
results = job.result()
print(results.time_taken)
</code></pre>

<p>You can also check all the values stored in result as it is a dictionary by printing it:</p>

<pre><code>print(results)
</code></pre>

<p>Here you can check for all the information that is available within the dictionary and you can also observe the value for <em>'time_taken'</em>                    </p>
",2/19/2020 15:37,API Usage,The user is seeking information on how to retrieve the runtime of their experiment from IBM's quantum computer backend using Qiskit's API. This question pertains to the correct usage of the API for accessing experiment results.,API Usage,,,,API Usage,
5959.0,Grover's algorithm returns skewed probability distribution,"<p>I wrote an implementation of Grover's algorithm that looks like this:</p>

<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute

# Initialize circuit
m_qubit = QuantumRegister(1)
search_register = QuantumRegister(4)
result_register = ClassicalRegister(4)
ancillaries = QuantumRegister(3)
circuit = QuantumCircuit(search_register, result_register, m_qubit, ancillaries)

# Put M qubit into 1-superposition
circuit.x(m_qubit)
circuit.h(m_qubit)

# Put search qubits into superposition
circuit.h(search_register)

for _ in range(2):

    # Encode S1 * !S2 * S3
    circuit.x( search_register[2] )
    circuit.ccx( search_register[1], search_register[2], ancillaries[0] )
    circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )
    circuit.x( search_register[2] )

    # Encode S0 * S1
    circuit.ccx( search_register[0], search_register[1], ancillaries[2] )

    # Encode oracle ((S0 * S1) + (S1 * !S2 * S3))
    circuit.x(ancillaries)
    circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] )
    circuit.x(ancillaries)
    circuit.x(m_qubit)

    # Reset ancillaries to be used later
    circuit.reset(ancillaries)

    # Do rotation about the average
    circuit.h(search_register)
    circuit.x(search_register)
    circuit.ccx( search_register[0], search_register[1], ancillaries[0] )
    circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )
    circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] )
    circuit.x(search_register)
    circuit.x(m_qubit)
    circuit.h(search_register)

    # Reset ancillaries for use later
    circuit.reset(ancillaries)

circuit.measure(search_register, result_register)

# Run the circuit with a given number of shots
backend_sim = Aer.get_backend('qasm_simulator')
job_sim = execute(circuit, backend_sim, shots = 1024)
result_sim = job_sim.result()

# get_counts returns a dictionary with the bit-strings as keys
# and the number of times the string resulted as the value
print(result_sim.get_counts(circuit))
</code></pre>

<p>Essentially, this circuit should search for any value that matches <span class=""math-container"">$X_1 X_2 X_3 + X_0 X_1$</span>. When I do the math for this circuit I get the following:</p>

<p><span class=""math-container"">$$\frac{1}{1024 \sqrt{2}} \left( -304 \left( \sum_{x \in \{00, 01, 11\}} \left| x \right&gt; \left( \left|00\right&gt; + \left|01\right&gt; + \left|10\right&gt; \right) + \left|1000\right&gt; + \left|1001\right&gt; \right) + 80 \left( \sum_{x = 00}^{11} \left|x\right&gt; \left|11\right&gt; + \left|1010\right&gt; \right) \right) \left( \left|0\right&gt; - \left|1\right&gt; \right)$$</span></p>

<p>These amplitudes correspond to probabilities of <span class=""math-container"">$-\frac{{304}^{2}}{2({1024}^{2})} = -\frac{{19}^{2}}{2({64}^{2})}$</span> and <span class=""math-container"">$\frac{{80}^{2}}{2({1024}^{2})} = \frac{{5}^{2}}{2({64}^{2})}$</span> for the unsuccessful and successful probabilities, respectively.</p>

<p>What I don't understand from this is how the successful outputs would appear over the unsuccessful ones, because the magnitude of the probability for the unsuccessful results is much higher. Can someone explain how the normalization is done in this case?</p>

<p>Furthermore, these results do not obtain when I actually <em>run</em> the circuit. Instead of a step-function for the probabilities, when I run 1024 shots I tend to get between 30 and 50 for the unsuccessful results and the successful results are spread between 200 and 460. While it's obvious that the successful results have been selected, the spread is concerning because the math seems to indicate that they should be fairly close together. Moreover, the successful results always fall in the same order, which is also counter-intuitive given that results are probabilistic. This implies one of two things to me:</p>

<ol>
<li>The superposition isn't actually equal (i.e. there's some bias towards one value versus the other). However, this doesn't make sense as these results were obtained with a simulator so they should be very close to optimal.</li>
<li>I have inadvertently entangled the qubits in such a way that the result is affected.</li>
</ol>

<p>Any insight into this would be greatly appreciated. </p>
",<programming><qiskit><measurement><grovers-algorithm>,4/23/2019 2:10,6083.0,6083.0,"<p>It turns out the issue with this circuit was in the use of the <code>reset</code> operator in conjunction with entanglement and superposition.</p>
<p>In the oracle code I submitted, I use a Toffoli gate several times, which creates an entanglement between both input qubits and the output qubit. Since the input qubits are in superposition, that superposition state then &quot;spreads&quot; (for lack of a better term) to the output qubit. So, when the output qubit is reset using the <code>reset</code> operator, its superposition state and entanglements with the input qubits causes certain states to collapse, which changes the output of the circuit as a whole.</p>
<p>This had confused me earlier because using <code>reset</code> with either superposition <em>or</em> entanglement causes no issue, because both can collapse without change to the input; because, in a sense, the output and input qubits are separated. It is only, therefore, when they are used in conjunction that <code>reset</code> causes this behavior.</p>
<p>The solution then, is quite simple: reverse the circuit to return the output qubit to a <span class=""math-container"">$\left|0\right&gt;$</span> state after it is no longer needed:</p>
<pre><code># Encode S1 * !S2 * S3
circuit.x( search_register[2] )
circuit.ccx( search_register[1], search_register[2], ancillaries[0] )
circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )

# Encode S0 * S1
circuit.ccx( search_register[0], search_register[1], ancillaries[2] )

# Encode oracle ((S0 * S1) + (S1 * !S2 * S3))
circuit.x(ancillaries)
circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] )
circuit.x(m_qubit)

# Return ancillaries to 0s so they can be used later
circuit.x(ancillaries)
circuit.ccx( search_register[0], search_register[1], ancillaries[2] )
circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )
circuit.ccx( search_register[1], search_register[2], ancillaries[0] )
circuit.x( search_register[2] )

# Do rotation about the average
circuit.h(search_register)
circuit.x(search_register)
circuit.ccx( search_register[0], search_register[1], ancillaries[0] )
circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )
circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] )
circuit.x(search_register)
circuit.x(m_qubit)

# Return ancillaries to 0s for use later
circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )
circuit.ccx( search_register[0], search_register[1], ancillaries[0] )
circuit.h(search_register)
</code></pre>
<p>Doing this instead produced the desired result.</p>
",05/07/2019 01:52, Theoretical,"The user is seeking an explanation for the differences between the expected theoretical probabilities and the actual simulation results of Grover's algorithm. This involves understanding the theoretical aspects of quantum algorithms and how they behave in practice, which falls under the theoretical category.",Theoretical,,,, Theoretical,
5964.0,Drawing tangent vectors to the Bloch sphere with qutip,"<p>I need to plot drawings of qubit dynamics on the Bloch sphere. I know QuTip allows to do such drawings but I specifically need to represent evolution velocities on the Bloch sphere so I need to draw tangent vectors. Is there a way I can do it with QuTip? More generally it would be good to be able to draw affine vectors with QuTip. Do you know of any way I can do it? If this cannot be done with QuTip do you know of any other software that allows me to do it?</p>
",<programming><bloch-sphere><qutip>,4/23/2019 14:46,5971.0,5971.0,"<p>First of all, <code>qutip</code> is not a visualisation library, even though it does provide some visualisation functionalities, mostly leveraging <code>matplotlib</code>.
However, because <code>qutip</code> does provide handy functionalities to plot Bloch spheres and points on it, it does make sense to ask how one can tweak such functionalities to for example add tangent vectors to the bloch sphere.</p>

<p>Reading <a href=""http://qutip.org/docs/4.1/guide/guide-bloch.html"" rel=""noreferrer"">the relevant doc page</a>, this functionality does not seem to have been implemented.
However, having a look at the <a href=""https://github.com/qutip/qutip/blob/199bed53d3745e6400990fa259d9e7e6862781fa/qutip/bloch.py"" rel=""noreferrer"">relevant source code</a>, it does not seem particularly difficult to add manually additional vectors to the Bloch sphere.</p>

<p>In particular, at least in the current version of <code>qutip</code>, the vectors are added via the method <a href=""https://github.com/qutip/qutip/blob/199bed53d3745e6400990fa259d9e7e6862781fa/qutip/bloch.py#L538"" rel=""noreferrer""><code>plot_vectors</code></a>, which <a href=""https://github.com/qutip/qutip/blob/199bed53d3745e6400990fa259d9e7e6862781fa/qutip/bloch.py#L555-L559"" rel=""noreferrer"">creates the arrows using an <code>Arrow3D</code> object</a>.
One can add any other vector to the sphere by simply adding new <code>Arrow3D</code> objects to the underlying matplotlib <code>axes</code> object.</p>

<p>Here is an example of how to do this:</p>

<pre><code>import matplotlib.pyplot as plt
%matplotlib inline
import qutip
b = qutip.Bloch()
b.render(b.fig, b.axes)
new_arrow = qutip.bloch.Arrow3D(xs=[1, 1], ys=[0, .5], zs=[0, .5],
                    mutation_scale=b.vector_mutation,
                    lw=b.vector_width, arrowstyle=b.vector_style, color='blue')
b.axes.add_artist(new_arrow)
</code></pre>

<p>which gives</p>

<p><a href=""https://i.stack.imgur.com/a5Mnp.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/a5Mnp.png"" alt=""enter image description here""></a></p>

<p>note that we need to call explicitly <code>b.render</code> instead of <code>b.show</code> because we need the <code>axes</code> object to be created but the plot to not be drawn before we add the new arrow.</p>

<p>Just change the coordinates given to the parameters <code>xs</code>, <code>ys</code>, <code>zs</code> to decide what vectors to draw.</p>

<p>As a final more or less unrelated note, you might also be interested in the drawing library <code>plotly</code>, which allows to build very nice 3d plots (see e.g. <a href=""https://plot.ly/python/3d-parametric-plots/"" rel=""noreferrer"">these examples</a>).</p>
",4/24/2019 11:36,Tooling,"The user is inquiring about software tools or libraries that can be used to plot qubit dynamics on the Bloch sphere with the ability to represent tangent vectors, which pertains to the tools and software usage in quantum programming.",Tooling,,,,Tooling,
5973.0,Counting in Q#: number of solutions,"<p>I have this program derived from Microsoft Quantum Katas for counting (see <a href=""https://gist.github.com/friguzzi/84fbba72f7b6ba7bd58b0c4f8a8be60f"" rel=""nofollow noreferrer"">here</a>):</p>

<pre><code>namespace Quantum.Sample
{
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Extensions.Convert;
    open Microsoft.Quantum.Extensions.Math;

    operation SprinklerAnc (queryRegister:  Qubit[],  target : Qubit,ancilla: Qubit[]) : Unit {
        body (...) {
            X(queryRegister[2]);
            X(queryRegister[3]);
            X(queryRegister[4]);
            X(queryRegister[5]);
            X(queryRegister[6]);
            X(ancilla[0]);
            X(ancilla[1]);
            X(ancilla[2]);

            CCNOT(queryRegister[0],queryRegister[1],ancilla[0]);
            CCNOT(queryRegister[1],queryRegister[2],ancilla[1]);
            CCNOT(queryRegister[0],queryRegister[2],ancilla[2]);
            (Controlled X)([ancilla[0],ancilla[1],ancilla[2],queryRegister[3],queryRegister[4],queryRegister[5],queryRegister[6]],target);
            CCNOT(queryRegister[0],queryRegister[2],ancilla[2]);
            CCNOT(queryRegister[1],queryRegister[2],ancilla[1]);
            CCNOT(queryRegister[0],queryRegister[1],ancilla[0]);

            X(ancilla[2]);
            X(ancilla[1]);
            X(ancilla[0]);
                        X(queryRegister[2]);
            X(queryRegister[6]);
            X(queryRegister[5]);
            X(queryRegister[4]);
            X(queryRegister[3]);


        }
        adjoint invert;
        controlled auto;
        controlled adjoint auto;
    }           
    operation OracleConverterImpl (markingOracle : ((Qubit[], Qubit) =&gt; Unit : Adjoint, Controlled), register : Qubit[]) : Unit {

        body (...) {
            using (target = Qubit()) {
                // Put the target into the |-â© state
                X(target);
                H(target);

                // Apply the marking oracle; since the target is in the |-â© state,
                // flipping the target if the register satisfies the oracle condition will apply a -1 factor to the state
                markingOracle(register, target);

                // Put the target back into |0â© so we can return it
                H(target);
                X(target);
            }
        }

        adjoint invert;
        controlled auto;
        adjoint controlled auto;
    }

    operation HadamardTransform (register : Qubit[]) : Unit {

        body (...) {
            //ApplyToEachA(H, register);

            // ApplyToEach is a library routine that is equivalent to the following code:
             let nQubits = Length(register);
             for (idxQubit in 0..nQubits - 1) {
                 H(register[idxQubit]);
             }
        }

        adjoint invert;
        controlled auto;
        controlled adjoint auto;
    }
    operation Oracle_ArbitraryPattern (queryRegister : Qubit[], target : Qubit, pattern : Bool[]) : Unit {

        body (...) {
            (ControlledOnBitString(pattern, X))(queryRegister, target);
        }

        adjoint invert;
        controlled auto;
        controlled adjoint auto;

    }   

    // Task 2.2. Conditional phase flip
    operation ConditionalPhaseFlip (register : Qubit[]) : Unit {

        body (...) {
            // Define a marking oracle which detects an all zero state
            let allZerosOracle = Oracle_ArbitraryPattern(_, _, new Bool[Length(register)]);

            // Convert it into a phase-flip oracle and apply it
            let flipOracle = OracleConverter(allZerosOracle);
            flipOracle(register);
        }

        adjoint self;
        controlled  auto;

        controlled adjoint auto;

    }



    // Task 2.3. The Grover iteration
    operation GroverIteration (register : Qubit[], oracle : (Qubit[] =&gt; Unit :   Adjoint, Controlled)) : Unit {

        body (...) {
            oracle(register);
            HadamardTransform(register);
            ConditionalPhaseFlip(register);
            HadamardTransform(register);
        }

        adjoint invert;
              controlled auto;
        controlled adjoint auto;
    }    
    function OracleConverter (markingOracle : ((Qubit[], Qubit) =&gt; Unit : Adjoint, Controlled)) : (Qubit[] =&gt; Unit : Adjoint, Controlled) {
        return OracleConverterImpl(markingOracle, _);
    }

    operation UnitaryPowerImpl (U : (Qubit[] =&gt; Unit : Adjoint, Controlled), power : Int, q : Qubit[]) : Unit {
        body (...) {
            for (i in 1..power) {
                U(q);
            }
        }
        adjoint auto;
        controlled auto;
        controlled adjoint auto;
    }

    operation QPE() : Double {
        mutable phase = -1.0;
        let n=8;
                       using ((reg,phaseRegister,ancilla)=(Qubit[7 ], Qubit[n],Qubit[3]))
                       {
        // Construct a phase estimation oracle from the unitary
                         let phaseOracle = OracleConverter(SprinklerAnc(_,_,ancilla));

        let oracle = DiscreteOracle(UnitaryPowerImpl(GroverIteration(_, phaseOracle), _, _));

              //  let markingOracle = Sprinkler(_, _);

        // Allocate qubits to hold the eigenstate of U and the phase in a big endian register 

            let phaseRegisterBE = BigEndian(phaseRegister);
            // Prepare the eigenstate of U
                HadamardTransform(reg);

            // Call library
            QuantumPhaseEstimation(oracle, reg, phaseRegisterBE);
            // Read out the phase
            set phase = ToDouble(MeasureIntegerBE(phaseRegisterBE)) / ToDouble(1 &lt;&lt;&lt; (n));

            ResetAll(reg);
            ResetAll(phaseRegister);
        }
        let angle = PI()*phase;
        let res = 128.0 *(1.0- PowD(Sin(angle),2.0));

        return res;
    }



}
</code></pre>

<p>with driver (see <a href=""https://gist.github.com/friguzzi/3c7b836d572c26450efbdc2380cbc97e"" rel=""nofollow noreferrer"">this</a>):</p>

<pre><code>using System;

using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace Quantum.Sample
{
    class Driver
    {
        static void Main(string[] args)
        {
            using (var qsim = new QuantumSimulator())
            {
                for (int i = 0; i &lt; 100; i++)
                {
                    var res = QPE.Run(qsim).Result;
                    System.Console.WriteLine($""Res:{res}"");
                }
            }
        }
    }
}
</code></pre>

<p>It should count the solutions of the 3 bits formula
(not reg[0] or reg[2]) and (not reg[1] or reg[2]) and (not reg[0] or not reg[1])
This formula has 4 solutions.
I consider an extended formula with 7 bits that is true when the first three bit satisfy the above formula and the other four bits are at 0. The extended formula this has 4 solutions as well but I can increase easily the number of solutions by excluding variables from the formula.
I compute the phase <span class=""math-container"">$\phi$</span> with the linked program, then I compute <span class=""math-container"">$\theta/2$</span> as <span class=""math-container"">$2\pi\phi/2=\pi\phi$</span>
Now the number of solutions should be 
<span class=""math-container"">$$128\sin(\theta/2)^2$$</span>
 right?
I get the correct number of solutions if I compute 
<span class=""math-container"">$$128(1-\sin(\theta/2)^2)$$</span>
It's as if the formula is negated but I can't find where the negation is.
This same formula with <code>GroverSearch</code> from Microsoft Quantum Katas returns correct solutions.</p>
",<algorithm><programming><grovers-algorithm><q#>,4/24/2019 13:33,6446.0,6446.0,"<p>I have a theory as for where the issue comes from (huge thanks to <a href=""https://quantumcomputing.stackexchange.com/users/1763/robin-kothari"">Robin</a> for helping me figure it out!)</p>

<p>Grover iteration consists of four steps:</p>

<ul>
<li>Apply the oracle.</li>
<li>Apply the Hadamard transform.</li>
<li>Perform a conditional phase shift.</li>
<li>Apply the Hadamard transform.</li>
</ul>

<p><code>ConditionalPhaseFlip</code> operation in the Q# code implements the third step: it gives a phase shift of -1 to the <span class=""math-container"">$|0\rangle$</span> state (if you follow Q# code closely, this routine takes a marking oracle which marks the <span class=""math-container"">$|0\rangle$</span> state and converts it to phase-flipping oracle which flips the phase of this state only).</p>

<p>This implementation differs from the description in Nielsen and Chuang, which says that each basis state <em>except</em> <span class=""math-container"">$|0\rangle$</span> gets a phase shift of -1 (the difference is global phase of -1). When you use this Grover iteration as part of Grover search algorithm, this extra global phase has no effect on measurement outcomes.</p>

<p>However, when you use this iteration as part of quantum counting algorithm, this global phase can actually be detected! Since phase estimation uses controlled versions of the iteration, the phase becomes relative instead of global, and starts affecting the computation.</p>

<p>Let's denote the Grover iteration as <span class=""math-container"">$G$</span> with eigenvalues <span class=""math-container"">$e^{i\theta}$</span> and <span class=""math-container"">$e^{i (2 \pi - \theta)}$</span> (with the correct number of solutions calculated as <span class=""math-container"">$M_c = N \sin^2 \frac{\theta}{2}$</span>). The Grover iteration with an global phase of <span class=""math-container"">$-1$</span> <span class=""math-container"">$(-G)$</span> will have eigenvalues multiplied by <span class=""math-container"">$-1$</span>: <span class=""math-container"">$-e^{i\theta}$</span> and <span class=""math-container"">$-e^{i (2 \pi - \theta)}$</span>. Given that <span class=""math-container"">$e^{i\pi} = -1$</span>, we can write them as <span class=""math-container"">$e^{i(\pi + \theta)}$</span> and <span class=""math-container"">$e^{i (\pi - \theta)}$</span>. When you feed the unitary <span class=""math-container"">$(-G)$</span> into the quantum counting algorithm, you'll get <span class=""math-container"">$M_{-1} = N \sin^2 \frac{\theta + \pi}{2} = N \cos^2 \frac{\theta}{2}$</span> - which is exactly the answer you're getting!</p>

<p>The fix is a lot easier than figuring out what went wrong - just add a global phase of -1 to <code>ConditionalPhaseFlip</code>. You can use <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.r"" rel=""nofollow noreferrer"">R operation</a> for that: <code>R(PauliI, 2.0 * PI(), register[0]);</code>.</p>
",6/14/2019 0:00,API Usage ,The user question falls under the API Usage category as it involves understanding how to use specific functions in the Q# quantum computing language to implement Grovers algorithm. The user is seeking help on how to correctly and effectively use Q#'s API to achieve their goal.,Errors,"The question pertains to an issue with the output of a quantum program, where the number of solutions appears to be negated or incorrectly computed. The user is seeking assistance in identifying the source of this error in the quantum code, making it an ""Errors"" category question.",No,78.0,Errors,"The user's question involves identifying and resolving an issue with the output of a quantum program, where the computed number of solutions appears to be negated or incorrect. They seek assistance in debugging the code to identify the source of this error, aligning with the ""Errors"" category."
5984.0,Is it possible to construct an equivalent quantum circuit from a CORDIC-based digital circuit?,"<p><a href=""https://quantumcomputing.stackexchange.com/users/1837"">DaftWullie</a> mentions an interesting point <a href=""https://quantumcomputing.stackexchange.com/a/4421"">here</a>:</p>

<blockquote>
  <p>let's assume that we know an <strong>efficient classical computation</strong> of <span class=""math-container"">$f(x)$</span>. That means we can build a <strong>reversible quantum computation</strong> that <strong>runs in the same time</strong>.</p>
</blockquote>

<p><strong>Questions</strong>:</p>

<ol>
<li><p>What exactly is meant by <em>efficient</em> ""classical computation"" here? Does it mean something like the <a href=""https://en.wikipedia.org/wiki/CORDIC"" rel=""nofollow noreferrer"">Volder's algorithm</a> for implementing trigonometric, hyperbolic and exponential functions? </p></li>
<li><p>Say, we know how to implement <span class=""math-container"">$\sin^{-1}(x)$</span> using a <a href=""https://en.wikibooks.org/wiki/Digital_Circuits/CORDIC"" rel=""nofollow noreferrer"">CORDIC</a>-based digital circuit (with registers, multiplexers, adders and all that). Can we build an equivalent quantum circuit that has the same computational complexity as its digital counterpart? If yes, how? </p></li>
<li><p>How do we prove that the time complexities of the digital and quantum counterparts are equal (or nearly equal)?</p></li>
</ol>
",<circuit-construction><complexity-theory><classical-computing>,4/27/2019 7:25,5986.0,5986.0,"<p>DaftWullie's comments aren't special to 'efficiently computable' functions <span class=""math-container"">$f(x)$</span> &mdash; any function at all which we know how to compute by conventional means, we can compute reversibly with at most a (small!) constant factor overhead.</p>

<h2>How to reversibly compute a function</h2>

<p>The proof is simple. For any procedure to compute something conventionally &mdash; classically and without regard to reversibility &mdash; we can suppose that it is described in terms of a circuit consisting of FANOUT, NOT, XOR, and AND gates. (If you prefer a different set of universal logic gates, a very slightly different proof can easily be found for that gate set &mdash; but it <em>is</em> important that we explicitly account for when we make copies of a bit, which is what we use FANOUT for.) Then we can stimulate each of the gates FANOUT, XOR, and AND using CNOT and TOFFOLI gates as follows:
<span class=""math-container"">$$\begin {aligned}
\mathrm{FANOUT} (a)&amp; = \mathrm{CNOT} (a, 0) \\
\bigl(a, \mathrm{XOR} (a, b) \bigr) &amp; = \mathrm{CNOT} (a, b) \\
\bigl(a, b, \mathrm{AND} (a, b) \bigr) &amp; = \mathrm{TOFFOLI} (a, b, 0)
\end {aligned} $$</span>
Thus it takes exactly one of either CNOT or TOFFOLI (and possibly a fresh bit with the value 0) to simulate the computation of a single FANOUT, XOR, or AND gate. </p>

<p>Composing these in the appropriate way, we can compute any classical function that we know how to compute, using only reversible gates.</p>

<ul>
<li><p>If (as is usually the case for quantum computation) the TOFFOLI or CNOT operations are not primitive operations of your computational model, the more important thing is that it be possible to realise those operations <em>somehow</em>. If you can decompose them into a fixed size sequence of primitive operations, then doing the computation reversibly only requires an overhead up to some constant factor, <em>i.e.</em> the size of the most complicated decomposition of those reversible gates. For quantum circuits, it is reasonable to suppose that this factor is at most 15 (which is not wonderful, but from a theoretical standpoint is also not terrible, and can be improved depending on what operations you allow).</p></li>
<li><p>This reversible realisation of the computation may require some extra workspace: a number of bits which is at most the number of logic gates in your procedure. In some cases, there may be cleverer ways to reversibly realise the computation which requires fewer additional bits than this: coming up with the most sparing such reversible realisation is not necessarily easy. </p></li>
</ul>

<h2>On efficient functions</h2>

<p>The above remarks apply in principle to any classical circuit construction, and indeed to the primitive operations in any higher-level gate model (e.g. the CORDIC-based circuits of your question or any digit-extraction algorithm to compute some function). In principle, given a modest amount of (sufficiently high quality) additional memory, we can simulate any such circuit on a gate-by-gate basis to provide reversible equivalents with the same number of gates, or nearly so.</p>

<p>For more complicated functions, there is ironically enough more opportunities to save on the additional workspace required, which are impossible for the simpler gates (because those gates are <em>too</em> simple to provide opportunities to save) &mdash; economies of scale become possible, though not guaranteed. </p>

<p>The important part is that, additional workspace aside, these realisations will respect most notions of 'efficiency'. It does not increase the depth or size of the circuit by more than a constant factor, if at all. If you care about polynomial-size, linear-size, poly-log-depth, what-have-you &mdash; this simulation method preserves it. </p>
",4/27/2019 13:19,Theoretical,"The user question falls under the Theoretical category as it involves understanding the theoretical concepts of quantum computing, specifically the relationship between classical computation and quantum computation, and the concept of computational complexity in both domains. ", Theoretical,,,,Theoretical,
6003.0,How to draw a multiple qubit controlled NOT gate using qasm2circ?,"<p>In <a href=""https://www.media.mit.edu/quanta/qasm2circ/test6.qasm"" rel=""nofollow noreferrer"">Example 6</a>, the case of multiple qubit controlled custom <span class=""math-container"">$U$</span> gate is covered, but I want to reuse the standard NOT symbol i.e. <span class=""math-container"">$\bigoplus$</span>.  </p>

<p><a href=""https://i.stack.imgur.com/af4e0m.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/af4e0m.png"" alt=""enter image description here""></a></p>

<p>Say I want to draw this circuit, but with a <span class=""math-container"">$\bigoplus$</span> instead of the <span class=""math-container"">$U$</span> in a box. Clearly, <em>defining</em> a new custom gate isn't going to work as it'll still place the <span class=""math-container"">$\bigoplus$</span> in a box. I was trying to do something like this:</p>

<pre><code>qubit   j0
qubit   j1
qubit   j2
qubit   j3

toffoli j0,j1,j2
X   j0
cnot    j2,j3,j0,j1
H   j2
measure j3
</code></pre>

<p>but as expected, I get the <code>ERROR: [qgate] OOPS! line 8 wrong number of qubits in cnot j2,j3,j0,j1</code>. There's also the <code>toffoli</code> but even that is limited to a maximum of two control qubits. It's surprising that none of the other examples cover this case. So, any idea whether it's possible to draw a multiple qubit controlled NOT using the qasm2circ package?</p>
",<programming><qasm2circ>,4/29/2019 6:02,6007.0,6007.0,"<p>I checked the source code in the <code>qasm2tex.py</code> file. On line 410 the <code>if</code> structure goes like:</p>

<pre><code>if(m):
    (name,nctrl) = m.group(1).split(',')
    tex = m.group(2)
    if(tex=='bullet'):        # special for bullet, no \op{}
        texsym = r'\b'
    elif(tex.find(r'\dmeter')&gt;=0):  # if meas, don't put in \op{}
        texsym = tex
    else:
        texsym = '\op{%s}' % tex
    nctrl = int(nctrl)
    if GateMasterDef.has_key(name):
        print ""[qasm_parser] oops! duplicate def for op %s"" % line
    else:
        GateMasterDef[name] = (nctrl+1, nctrl, texsym)
    # print ""definition: %s"" % m.group(1)
    continue
</code></pre>

<p>So there are no cases for handling <code>oplus</code> and <code>times</code> is handled, although they're defined along with <code>bullet</code> in the <code>xyqcirc.tex</code> file, as single qubit operations, i.e.</p>

<pre><code>% single qubit operations

\def\op#1{*+[F]{\rule[-0.2ex]{0ex}{2.1ex}#1}}   % operator in box
\def\b{*={\bullet}}
\def\o{*={\oplus}}
\def\t{*={\times}}              % for swap gate
\def\sq{*=&lt;6pt,6pt&gt;[F]{}}           % square, for controlled-phase
\def\m#1{\left[\matrix{#1}\right]}      % matrix shortcut
\def\z{*+[]{\rule[-0.2ex]{0ex}{2.1ex}~|0\&gt;}}    % re-init to |0&gt;
\def\discard{*[]{\rule[-0.2ex]{0.75pt}{2.1ex}~}}    % vertical ``|''
\def\slash{*={/}}               % slash for wire bundles
</code></pre>

<p>This is most likely a bug. However, according to the <code>qasm2tex.py</code> docstring it was last updated by Ike (Isaac Chuang) on 2004/03/25 15:36:59, so I'm not hoping that it'll ever be officially fixed. Anyhow, the fix is just a four-line addition to <code>qasm2tex.py</code>, so I'm writing it down here just in case someone finds it helpful or wishes to write their own extension to the code:</p>

<pre><code>if(m):
    (name,nctrl) = m.group(1).split(',')
    tex = m.group(2)
    if(tex=='bullet'):        # special for bullet, no \op{}
        texsym = r'\b'
    if(tex=='oplus'):
        texsym = r'\o'        # special for oplus, no \op{}
    if(tex=='times'):
        texsym = r'\t'        # special for times, no \op{}        
    elif(tex.find(r'\dmeter')&gt;=0):  # if meas, don't put in \op{}
        texsym = tex
    else:
        texsym = '\op{%s}' % tex
    nctrl = int(nctrl)
    if GateMasterDef.has_key(name):
        print ""[qasm_parser] oops! duplicate def for op %s"" % line
    else:
        GateMasterDef[name] = (nctrl+1, nctrl, texsym)
    # print ""definition: %s"" % m.group(1)
    continue
</code></pre>

<p>Now to answer the <a href=""https://quantumcomputing.stackexchange.com/questions/6003"">original question</a>, after the above fix has been made, the required QASM code and the corresponding TeX output is:</p>

<pre><code>%   def cccnot,3,'oplus'
% 
%   qubit   j0
%   qubit   j1
%   qubit   j2
%   qubit   j3
% 
%   toffoli j0,j1,j2
%   X   j0
%   cccnot  j2,j3,j0,j1
%   H   j2
%   measure j3
% 

%  Time 01:
%    Gate 00 toffoli(j0,j1,j2)
%  Time 02:
%    Gate 01 X(j0)
%  Time 03:
%    Gate 02 cccnot(j2,j3,j0,j1)
%  Time 04:
%    Gate 03 H(j2)
%    Gate 04 measure(j3)

% Qubit circuit matrix:
%
% j0: gAxA, gBxA, gCxA, n  , n  
% j1: gAxB, n  , gCxB, n  , n  
% j2: gAxC, n  , gCxC, gDxC, n  
% j3: n  , n  , gCxD, gDxD, N  

\documentclass[11pt]{article}
\input{xyqcirc.tex}

% definitions for the circuit elements

\def\gAxA{\b\w\A{gAxA}}
\def\gAxB{\b\w\A{gAxB}}
\def\gAxC{\o\w\A{gAxC}}
\def\gBxA{\op{X}\w\A{gBxA}}
\def\gCxC{\b\w\A{gCxC}}
\def\gCxD{\b\w\A{gCxD}}
\def\gCxA{\b\w\A{gCxA}}
\def\gCxB{\o\w\A{gCxB}}
\def\gDxC{\op{H}\w\A{gDxC}}
\def\gDxD{\meter\w\A{gDxD}}

% definitions for bit labels and initial states

\def\bA{ \q{j_{0}}}
\def\bB{ \q{j_{1}}}
\def\bC{ \q{j_{2}}}
\def\bD{ \q{j_{3}}}

% The quantum circuit as an xymatrix

\xymatrix@R=5pt@C=10pt{
    \bA &amp; \gAxA &amp;\gBxA &amp;\gCxA &amp;\n   &amp;\n  
\\  \bB &amp; \gAxB &amp;\n   &amp;\gCxB &amp;\n   &amp;\n  
\\  \bC &amp; \gAxC &amp;\n   &amp;\gCxC &amp;\gDxC &amp;\n  
\\  \bD &amp; \n   &amp;\n   &amp;\gCxD &amp;\gDxD &amp;\N  
%
% Vertical lines and other post-xymatrix latex
%
\ar@{-}""gAxC"";""gAxA""\ar@{-}""gAxC"";""gAxB""
\ar@{-}""gCxB"";""gCxC""\ar@{-}""gCxB"";""gCxD""\ar@{-}""gCxB"";""gCxA""
}

\end{document}
</code></pre>

<h2>Circuit Diagram:</h2>

<p><a href=""https://i.stack.imgur.com/NUBQi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NUBQi.png"" alt=""qasm2circ: Example 6 (replaced U with oplus)""></a></p>
",4/29/2019 10:01,Tooling," The user is seeking help and guidance on how to draw a multiple qubit controlled NOT gate using the qasm2circ package, which falls under the category of tooling-related questions related to quantum circuit visualization and drawing.",Tooling,,,,Tooling,
6059.0,Default value for a state created by QuantumRegister,"<p>What's the default value for a state created by <code>QuantumRegister(1,'name_of_the_register')</code>? Is it a <span class=""math-container"">$|0\rangle$</span> or a <span class=""math-container"">$|1\rangle$</span>?</p>
",<quantum-state><programming><qiskit><initialization>,05/05/2019 11:07,6060.0,6060.0,"<p>Here's the source code for <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/quantumregister.py"" rel=""nofollow noreferrer"">quantumregister.py</a> and <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/quantumcircuit.py"" rel=""nofollow noreferrer"">quantumcircuit.py</a>.</p>

<p>The default is <span class=""math-container"">$|0\rangle$</span>. The code goes like:</p>

<pre><code>from qiskit import QuantumCircuit, QuantumRegister
qr = QuantumRegister(1) 
circuit = QuantumCircuit(qr) 
</code></pre>

<p>By the way, if you're just beginning with Qiskit, you could check out <a href=""https://books.google.co.in/books/about/Mastering_Quantum_Computing_with_IBM_QX.html?id=jCWGDwAAQBAJ&amp;redir_esc=y"" rel=""nofollow noreferrer"">Dr. Moran's textbook</a> (this specific example is covered in chapter 5, ~p. 83).</p>
",05/05/2019 12:06,Conceptual,"The user is seeking clarification on a conceptual aspect of quantum computing, specifically regarding the default state of a quantum register created in Qiskit. This question falls under the category of conceptual inquiries related to the fundamental concepts of quantum computing.",Conceptual,,,,Conceptual,
6070.0,How does the cnx gate work in Qiskit (Python)?,"<p>Could somebody explain the cnx operator, and how it operates on its qubit parameters to flip the target qubit in Qiskit (Python)?</p>
",<quantum-gate><programming><qiskit>,05/06/2019 13:13,6071.0,6071.0,"<p>The documentation for <code>cnx</code> says <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/47a0a30949f41c7cf901d5562b225e7fc8f45c21/community/games/game_engines/composite_gates.py#L58"" rel=""nofollow noreferrer""><code>Control n-1 qubits, apply 'not' to last one</code></a>.</p>

<p>So basically <span class=""math-container"">$C^n(X)$</span> in Qiskit is defined like <span class=""math-container"">$$C^n(X)|x_1\cdots x_{n-1}\rangle|\psi\rangle = |x_1\cdots x_{n-1}\rangle X^{x_1\cdots x_{n-1}}|\psi\rangle$$</span> where <span class=""math-container"">$x_1\cdots x_{n-1}$</span> in the exponent of <span class=""math-container"">$U$</span> means the <em>product</em> of the bits <span class=""math-container"">$x_1,\cdots, x_{n-1}$</span>. That is, the <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-X_gate"" rel=""nofollow noreferrer"">Pauli-X gate</a> gate gets applied to the <span class=""math-container"">$n$</span>-th qubit <span class=""math-container"">$|\psi\rangle$</span> only when all of the first <span class=""math-container"">$n-1$</span> bits are <span class=""math-container"">$1$</span>.</p>
",05/06/2019 15:01, Tooling,"The user is asking about how to use a specific operator in Qiskit, a software tool for quantum programming, to understand its operation on qubit parameters.s", Tooling,,,, Tooling,
6074.0,Order of controls and targets of cnx gates in Qiskit (Python),"<p>In the following piece of code:</p>

<pre><code>cnx(qwc, q[0], q[1],q[2],q[3])
</code></pre>

<p>in what order control qubits and target qubit are? Which qubit is inverted for which values of which ones?</p>
",<quantum-gate><programming><qiskit>,05/06/2019 16:51,6075.0,6075.0,"<p>As explained <a href=""https://quantumcomputing.stackexchange.com/a/6071"">here</a>, if <em>all</em> of <code>q[0]</code>, <code>q[1]</code> and <code>q[2]</code> (the n-1 qubits) are 1, then <code>q[3]</code> (the n-th qubit) is inverted. That is, <code>q[3]</code> is the target qubit and the rest (<code>q[0]</code>, <code>q[1]</code> and <code>q[2]</code>) are controls.</p>
",05/06/2019 16:55,API Usage,"The question is about the usage of the cnx operator in a specific piece of code, asking for the order of control qubits and target qubit, and which qubit is inverted for which values. This falls under API usage as its about how to correctly use a specific function in the Qiskit API.",API Usage,,,,API Usage,
6183.0,"How to prepare a statistical mixture of $|0,0\rangle $ and $ |1,1\rangle $ in QuTiP?","<p>A QuTiP novice here. It's easy to prepare a pure state in QuTiP. For example, to prepare <span class=""math-container"">$\frac{1}{\sqrt{2}}(|0,0\rangle + |1,1\rangle)$</span>:</p>

<pre><code>psi = (ket('00') + ket('11')).unit()
psi = (tensor(basis(2,0), basis(2,0)) + tensor(basis(2,1), basis(2,1))).unit()
</code></pre>

<p>But what code would you use to prepare a statistical mixture of <span class=""math-container"">$ |0,0\rangle $</span> and <span class=""math-container"">$ |1,1\rangle $</span>?</p>
",<quantum-state><programming><qutip>,5/18/2019 0:55,6184.0,6184.0,"<p>Mixed states are represented by <a href=""https://en.wikipedia.org/wiki/Density_matrix"" rel=""nofollow noreferrer"">density matrices</a> cf. <a href=""https://quantumcomputing.stackexchange.com/questions/2347/density-matrices-for-pure-states-and-mixed-states?noredirect=1&amp;lq=1"">Density matrices for pure states and mixed states</a>. <a href=""http://qutip.org/docs/3.1.0/guide/guide-states.html#density-matrices"" rel=""nofollow noreferrer"">This</a> is the QuTiP documentation for density matrices; check the 4th example. The <a href=""http://qutip.org/docs/3.1.0/apidoc/functions.html?highlight=ket2dm#qutip.states.ket2dm"" rel=""nofollow noreferrer""><code>ket2dm</code></a> function takes input a ket or bra vector and returns density matrix formed by the outer product. So say for a 50-50 mixture the following code should work:</p>

<pre><code>from qutip import *
0.5*ket2dm(tensor(basis(2,0), basis(2,0))) + 0.5*ket2dm(tensor(basis(2,1), basis(2,1)))
</code></pre>

<p>This returns the required density matrix representing a 50-50 statistical mixture of <span class=""math-container"">$|0,0\rangle$</span> and <span class=""math-container"">$|1,1\rangle$</span>.</p>

<pre><code>Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True
Qobj data =
[[0.5 0.  0.  0. ]
 [0.  0.  0.  0. ]
 [0.  0.  0.  0. ]
 [0.  0.  0.  0.5]]
</code></pre>
",5/18/2019 4:05,API Usage,"The question involves using QuTiP, a quantum computing library, to prepare a statistical mixture of quantum states. It falls under the ""API Usage"" category as it pertains to how to utilize QuTiP's functions to create a specific quantum state composition.",API Usage,,,,API Usage,
6187.0,How do I translate a quantum circuit for computing x + y mod 8 into a program?,"<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:[[%22Sample3%22,1,1,%22Sample3%22,1,1,%22Sample1%22],[1,%22%E2%80%A2%22,1,1,%22%E2%80%A2%22,1,%22X%22],[1,%22%E2%80%A2%22,1,1,1,1,%22X%22],[1,1,1,1,%22%E2%80%A2%22,1,%22X%22],[%22%E2%80%A2%22,1,1,%22%E2%80%A2%22,1,%22X%22,%22%E2%80%A2%22],[%22%E2%80%A2%22,1,1,%22%E2%80%A2%22,%22X%22],[%22%E2%80%A2%22,1,1,%22X%22],[1,%22%E2%80%A2%22,1,1,%22X%22],[1,1,%22%E2%80%A2%22,1,1,%22X%22],[1,1,1,%22Sample3%22]],%22init%22:[1,1,1,1,1,1]%7D"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CrcOy.gif"" alt=""""></a></p>

<p>I have made the above quantum circuit that gives the mod <span class=""math-container"">$8=2^3$</span>
operation between <span class=""math-container"">$|x\rangle$</span> and <span class=""math-container"">$|y\rangle$</span>. Now I want to write its corresponding program using some language. Where can I do that i.e. online or on my hardware? And what programming language can I use for this purpose? Also please check my circuit for correctness. </p>
",<programming><circuit-construction>,5/18/2019 17:19,6212.0,6212.0,"<p>I'm not sure if you are trying to represent <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> in little-endian or big-endian format, but either way the circuit does not look correct. </p>

<p>Let's consider the case of <span class=""math-container"">$x = 2$</span> and <span class=""math-container"">$y = 2$</span>: they are conveniently represented the same way in LE and BE formats, as <span class=""math-container"">$010$</span>, so the encoding will only matter when reading out the answer.</p>

<ul>
<li>You start with <span class=""math-container"">$|010\ 010\ 0\rangle$</span> (writing the states of the qubits in top-to-bottom order). </li>
<li>After the first 3 gates you'll get <span class=""math-container"">$|010\ 010\ 1\rangle$</span> - indeed, OR of these wires is 1.</li>
<li>The next three gates are controlled on the first qubit, which is in state <span class=""math-container"">$|0\rangle$</span>, so we can ignore them: still <span class=""math-container"">$|010\ 010\ 1\rangle$</span>.</li>
<li>The second-to-last CNOT is executed: <span class=""math-container"">$|010\ 000\ 1\rangle$</span>.</li>
<li>The last CNOT has no effect again, so the final answer is <span class=""math-container"">$000$</span> - no matter whether you read it as little-endian or big-endian, it yields an incorrect sum of 0.</li>
</ul>

<p>I believe this circuit doesn't handle the second carry bit properly.</p>

<hr>

<p>For reference, here is the Q# code I wrote to test this circuit and find a test case for which it fails (you mentioned in the chat that you tried Quantum Development Kit, so this might be helpful):</p>

<pre><code>// Allocate x, y and auxiliary qubits
using ((x, y, a) = (Qubit[3], Qubit[3], Qubit())) {
    for (xint in 0..7) {
        for (yint in 0..7) {
            // x and y qubits start in |0â© state; set them to their starting values - in little-endian
            ApplyPauliFromBitString(PauliX, true, IntAsBoolArray(xint, 3), x);
            ApplyPauliFromBitString(PauliX, true, IntAsBoolArray(yint, 3), y);

            // Calculate x + y mod 8 using the circuit
            // (assume the wires top to bottom are x0, x1, x2, y0, y1, y2, a)
            CCNOT(x[1], y[1], a);
            CNOT(x[1], a);
            CNOT(y[1], a);
            Controlled X([x[0], y[0], a], y[2]);
            CCNOT(x[0], y[0], y[1]);
            CNOT(x[0], y[0]);
            CNOT(x[1], y[1]);
            CNOT(x[2], y[2]);

            // Read out the result from y register (still as LE)
            let sum = MeasureInteger(LittleEndian(y));
            if (sum != (xint + yint) % 8) {
                Message($""Incorrect sum for x = {xint}, y = {yint}: sum = {sum}"");
            }

            // Reset all qubits before next iteration
            ResetAll(x);
            ResetAll(y);
            Reset(a);
        }
    }
}
</code></pre>

<p>You can switch it to using big-endian by wrapping <code>IntAsBoolArray</code> and <code>y</code> register in measurement line in <code>Reverse</code> function to reverse the order of qubits.</p>

<hr>

<p>As a side note, Q# has a library implementation of an adder, you can look it up <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Standard/src/Arithmetic/Integer.qs#L355"" rel=""nofollow noreferrer"">here</a>.</p>
",5/21/2019 22:53,Tooling ,"The question is about finding an online platform or local hardware setup to write a quantum program, and also about choosing a suitable quantum programming language. Its asking for tools and software that can be used for quantum programming",Tooling,,,,Tooling ,
6236.0,"How to quickly calculate the custom U3 gate parameters $\theta, \phi$ and $\lambda$ for any unitary?","<p>In IBM Qiskit and Quantum Experience, the custom <code>U3</code> gate is defined as </p>

<p><span class=""math-container"">$$
U(\theta, \phi, \lambda) = 
\begin{pmatrix} 
\cos\left(\frac{\theta}{2}\right) &amp; -e^{i\lambda} \sin\left(\frac{\theta}{2}\right) \\
e^{i\phi} \sin\left(\frac{\theta}{2}\right) &amp; e^{i(\lambda + \phi)} \cos\left(\frac{\theta}{2}\right)
\end{pmatrix}
$$</span> </p>

<p>Is there any way to quickly obtain the parameters <span class=""math-container"">$\theta, \phi$</span> and <span class=""math-container"">$\lambda$</span> for any arbitrary <span class=""math-container"">$2\times 2$</span> unitary <span class=""math-container"">$X$</span>? I know it's possible to write up a lengthy program which could do this, but is there already a similar program out there? Any of the common programming languages would be fine.</p>

<hr>

<p><sup><strong>Related</strong>: <a href=""https://quantumcomputing.stackexchange.com/questions/2707/what-are-theta-phi-and-lambda-in-cu1theta-ctl-tgt-and-cu3theta-phi-lam"">What are theta, phi and lambda in cu1(theta, ctl, tgt) and cu3(theta, phi, lam, ctl, tgt)? What are the rotation matrices being used?</a></sup></p>
",<programming><qiskit><resource-request><ibm-q-experience>,5/26/2019 2:35,6240.0,6240.0,"<h1>Python - Sympy</h1>

<p>It could be done in python using <code>sympy</code>. I am not really an expert and maybe there could be ways to optimize this, but the following works fine for me.
Assuming you have the matrix 
<span class=""math-container"">$$\begin{bmatrix}a &amp; b\\ c &amp; d\end{bmatrix}$$</span></p>

<p>My program</p>



<pre><code>from sympy import *

def get_angles(a, b, c, d):
    if im(a) == 0:
        print(""Not phasing"")
        s = _compute_angles(a, b, c, d)
        res = _final_constraint(s)
        if len(res) != 0:
            return res
    print(""Phasing by first element..."")
    matr = Matrix([[a, b], [c, d]])
    ph = arg(matr[0])
    matr_phased = simplify(matr/(cos(ph) + I*sin(ph)))
    s = _compute_angles(matr_phased[0], matr_phased[1], matr_phased[2],
                        matr_phased[3])
    return _final_constraint(s)


def _compute_angles(a, b, c, d):
    theta, phi, lamb = symbols('\\theta \\phi \\lambda', real=True)
    a_eq = Eq(cos(theta / 2), a)
    b_eq = Eq(-exp(I * lamb) * sin(theta / 2), b)
    c_eq = Eq(exp(I * phi) * sin(theta / 2), c)
    d_eq = Eq(exp(I * (phi + lamb)) * cos(theta / 2), d)
    return solve([a_eq, b_eq, c_eq, d_eq], [theta, phi, lamb], dict=True)


def _final_constraint(result):
    res = []
    for sol in result:
        to_add = True
        for k, v in sol.items():
            if str(k) == '\\theta' and (v &lt; 0 or v &gt; pi):
                to_add = False
                break
            elif str(k) == '\\phi' and (v &lt; 0 or v &gt;= 2 * pi):
                to_add = False
                break
        if to_add:
            res.append(simplify(sol))
    return res
</code></pre>

<p>Note that for Qiskit <code>U</code> matrix you should only check if the first number is imaginary and, if it so, you could divide the whole matrix by it. It is not really necessary to divide by the determinant, provided that the matrix represent indeed a valid quantum gate (or, said differently, the magnitude are all less than 1).</p>

<p>To avoid Python evaluation of fractions, instead of simply using <code>1/2</code> a common trick is to use <code>S(1)/2</code> or <code>Rational(1,2)</code></p>

<h2>Examples</h2>

<h3>A generic unitary</h3>

<p><code>get_angles(sqrt(S(1)/5), sqrt(S(4)/5), -sqrt(S(4)/5), sqrt(S(1)/5))</code>
returns </p>

<p><span class=""math-container"">$$
\left[ \left\{ \lambda : \pi, \  \phi : \pi, \  \theta : 2 \operatorname{acos}{\left(\frac{\sqrt{5}}{5} \right)}\right\}\right]
$$</span></p>

<h3>Pauli-Y matrix</h3>

<p><span class=""math-container"">$$\begin{bmatrix} 0 &amp; -i \\ i &amp; 0 \end{bmatrix}$$</span></p>

<p><code>get_angles(0, -I, I, 0)</code> returns 
<span class=""math-container"">$$
\left[ \left\{ \lambda : \frac{\pi}{2}, \  \phi : \frac{\pi}{2}, \  \theta : \pi\right\}\right]
$$</span></p>

<h3><span class=""math-container"">$\sqrt{NOT}$</span></h3>

<pre><code>sqnot = Matrix([[1+I, 1-I], [1-I, 1+I]]) * Rational(1,2)
get_angles(sqnot[0], sqnot[1], sqnot[2], sqnot[3])
</code></pre>

<p><span class=""math-container"">$$
\left[ \left\{ \lambda : \frac{\pi}{2}, \  \phi : \frac{3 \pi}{2}, \  \theta : \frac{\pi}{2}\right\}\right]
$$</span></p>

<h3>Matrix of Sanchayan Dutta <a href=""https://quantumcomputing.stackexchange.com/a/6237/4848"">answer</a></h3>

<p><code>get_angles(-1/sqrt(2), I/sqrt(2), I/sqrt(2), -1/sqrt(2))</code>
<span class=""math-container"">$$
\left[ \left\{ \lambda : \frac{\pi}{2}, \  \phi : \frac{3 \pi}{2}, \  \theta : \frac{\pi}{2}\right\}\right]
$$</span></p>
",5/26/2019 14:42,API Usage,"The user is asking about how to use a specific function in Qiskit,quantum programming, to obtain the parameters for any arbitrary 2x2 unitary",API Usage,,,,API Usage,
6326.0,How to calculate the fidelity of a certain gate of a IBMQ device in Qiskit using randomized benchmarking/tomography?,"<p>For example, I want to calculate the fidelity of a 1-qubit and 2-qubit gates (similar to the result shown in figure 2 in <a href=""https://arxiv.org/abs/1811.02292"" rel=""noreferrer"">this paper</a>). Is there any way to do that in Qiskit? I've gone through the Qiskit Ignis documentation, but I didn't see if it's relevant. </p>
",<programming><qiskit><fidelity><tomography>,06/04/2019 17:50,6361.0,6361.0,"<p>Fidelity is a single-number measure of how good a gate is. Since there are many ways that a gate can go wrong, there are multiple ways that the fidelity can be defined. The exact answer to your question will therefore depend on which kind of fidelity you want.</p>

<p>Any measure of fidelity will typically involve comparing the gate that you wanted to the channel that actually happened. This channel can be described by a Choi matrix. More discussion of channels and Choi matrices can be found in the answer <a href=""https://quantumcomputing.stackexchange.com/questions/5794/what-is-a-complementary-map/5797#5797"">to this question</a>.</p>

<p>For a concrete example in Qiskit, see the notebook on how to use the <a href=""https://qiskit.org/documentation/ignis/tomography.html"" rel=""nofollow noreferrer"">tomography tool from Qiskit Ignis</a>. For example, here is the tomography of a single qubit Hadamard gate.</p>

<pre><code># Process tomography of a Hadamard gate
q = QuantumRegister(1)
circ = QuantumCircuit(q)
circ.h(q[0])

# Run circuit on unitary simulator to find ideal unitary
job = qiskit.execute(circ, Aer.get_backend('unitary_simulator'))
ideal_unitary = job.result().get_unitary(circ)
# convert to Choi-matrix in column-major convention
choi_ideal = outer(ideal_unitary.ravel(order='F'))

# Generate process tomography circuits and run on qasm simulator
qpt_circs = process_tomography_circuits(circ, q)
job = qiskit.execute(qpt_circs, Aer.get_backend('qasm_simulator'), shots=4000)

# Extract tomography data so that counts are indexed by measurement configuration
qpt_tomo = ProcessTomographyFitter(job.result(), qpt_circs)
qpt_tomo.data
</code></pre>

<p>Given the data, we can then find the best fit to a Choi matrix. For example, using the MLE Least-Squares tomographic reconstruction.</p>

<pre><code>choi_lstsq = qpt_tomo.fit(method='lstsq')
</code></pre>

<p>By comparing this with the ideal Choi matrix, we can calculate the fidelity using the <code>state_fidelity</code> and <code>process_fidelity</code> tools. For the latter, we'll need to use <code>require_cptp=False</code> in case the Choi matrix doesn't quite describe a cptp map.</p>

<pre><code>print('fit fidelity (state):', state_fidelity(choi_ideal / 2, choi_lstsq.data / 2))
print('fit fidelity (process):', np.real(process_fidelity(choi_ideal, choi_lstsq.data, require_cptp=False)))
</code></pre>

<p>This should give an output that is something like</p>

<pre><code>fit fidelity (state): 0.9976767994222256
fit fidelity (process): 0.995358994837865
</code></pre>
",06/06/2019 12:53,API Usage,"The question is about how to use the Qiskit API to calculate the fidelity of 1-qubit and 2-qubit gates, similar to the results shown in a specific research paper. Its asking for a method or existing program that can achieve this",Tooling,The question is asking about how to use Qiskit to calculate the fidelity of quantum gates. This is a question about how to use a particular software tool for quantum programming.,No,79.0,API Usage,"The user's question specifically asks how to use the Qiskit API to calculate gate fidelity, similar to the results in a research paper, indicating a need for guidance on utilizing existing functionality or methods within the Qiskit API to achieve this task"
6328.0,How to see the QASM code corresponding to compiled Q# function?,"<p>I'm learning Q#. Is there any way to see the QASM code of a Q# function I write, the same way I can see the disassembly of a C# function?</p>
",<programming><q#><qasm>,06/04/2019 18:14,6345.0,6345.0,"<p>Q# is not compiled into QASM, so that would be tricky. Q# compilation and execution process is approximately as follows:</p>

<ul>
<li>Q# code is parsed into an internal data structure representing an abstract syntax tree. This data structure undergoes some transformations (for example, to generate adjoint and controlled versions of operations used in the code). I don't know a way to see this representation directly.</li>
<li>Next, to execute the code on a simulator this data structure is used to generate C# code. This code doesn't look particularly assembly-like, since it maintains a lot of high-level language constructs. If your Q# code was stored in file <code>MyCode.qs</code> in folder <code>A</code>, the C# result of code generation will be found in <code>A\obj\qsharp\src\MyCode.g.cs</code>.</li>
<li>C# compiler compiles this generated code into a classical executable and runs it.</li>
</ul>

<hr>

<p>Having said that, it is possible to write a separate tool that will convert a subset of Q# operations into OpenQasm; <a href=""https://github.com/qsharp-community/qsharp-integrations/tree/master/src/OpenQasm"" rel=""nofollow noreferrer"">this example</a> by Rolf Huisman shows a way to do that.</p>
",06/05/2019 06:45,Tooling,"The question is about the tooling aspect of quantum programming and specifically asks for a way to view the QASM (Quantum Assembly Language) code generated by a Q# function, which relates to the tools and software used in quantum programming.",Tooling,,,,Tooling,
6364.0,About the Qiskit draw function,"<p>Where does Qiskit put the rendered figure created by <code>circuit.draw(output='mpl')</code>? </p>
",<programming><qiskit>,06/06/2019 14:40,6369.0,6369.0,"<p>Qiskit does not save the rendered <code>Figure</code> of the circuit anywhere, unless you provide a <code>filename</code> to the call. </p>

<p>For example: <code>circuit.draw(filename='&lt;file_path&gt;')</code>.</p>

<p>In regards to having the <code>Figure</code> render and stay open, you simply need to remove a line of code. If you go to where qiskit is installed in your environment, go into the file <code>qiskit/visualization/matplotlib.py</code>, and go to line 436 you will see the line <code>plt.close(self.figure)</code>. Comment this line out, and run your program again. You should see the <code>Figure</code> in a new window.</p>
",06/06/2019 19:30,Tooling,The question is about the location where Qiskit saves the rendered figure created by the circuit.draw(output='mpl') function. Its asking for information about the tools behavior and output., Tooling,,,,Tooling,
6433.0,Perform quantum gate operations using state vectors and matrices,"<p>I am getting confused as to how to perform gate operations using matrices and am hoping someone will help me walk through this example.</p>

<p>Say I want to perform a Pauli-X gate on the 3rd qubit in a 3-qubit system. That operation would be: </p>

<pre><code>U = I â I â X
</code></pre>

<p>Then say I have the state <span class=""math-container"">$|001\rangle$</span> so after applying U the state would become <span class=""math-container"">$|000\rangle$</span>. I am trying to use Python and NumPy to calculate this but I believe I am missing something.</p>

<pre><code>i = np.array([[1, 0],
              [0, 1]])

x = np.array([[0, 1],
              [1, 0]])

state_0 = np.array([[1],
                    [0]])
state_1 = np.array([[0],
                    [1]])

x_3 = np.kron(np.kron(i,i),x)

v = np.kron(np.kron(state_0, state_0), state_1)

print(x_3.dot(v))
</code></pre>

<p>This code outputs:</p>

<pre><code>[[1]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]
 [0]]
</code></pre>

<p>I am unsure if this output is correct and if it is how would I see this as the state <span class=""math-container"">$|000\rangle$</span>? Any clarifications would be very useful! Thank you!</p>
",<programming><quantum-gate>,06/12/2019 20:33,6434.0,6434.0,"<p>You can use the same tools you used to get this output to check that it is correct: the state <span class=""math-container"">$|000\rangle$</span> would be represented as tensor product <span class=""math-container"">$|0\rangle \otimes |0\rangle \otimes |0\rangle$</span>, which in your Python notation would be <code>np.kron(np.kron(state_0, state_0), state_0)</code>. This should give you the same column vector you got from running your code, with the first element 1 and the rest of them 0s.</p>
",06/12/2019 21:07, Tooling,"The user is asking about how to use Python and NumPy, software tools for programming, to perform gate operations using matrices in a quantum system.", Tooling,,,, Tooling,
6436.0,How to program a controlled Hadamard-Hadamard gate?,"<p>I'm trying to program a controlled gate as the figure below in Qiskit. Should it be sufficient to separate and control individually the Hadamard gates?</p>

<p><a href=""https://i.stack.imgur.com/fJVgh.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/fJVgh.png"" alt=""enter image description here""></a></p>
",<programming><circuit-construction><qiskit>,6/13/2019 3:19,6461.0,6461.0,"<p>It seems like this gate is controlled on the top qubit (which I will call qubit 0) and performs a hadamard on both the other qubits (qubits 1 and 2) when the control is in state <span class=""math-container"">$|1\rangle$</span>. In this case it is equivalent to separte two controlled-hadamards: each controlled on qubit 0, with qubit 1 as the target for one and qubit 2 as the target for the other.</p>

<p>The controlled-hadamard can be implemented with <code>ch</code>. The entire three qubit gate is then as follows.</p>

<pre><code>qc = QuantumCircuit(3)
qc.ch(0,1)
qc.ch(0,2)
</code></pre>
",6/14/2019 13:16,Tooling,"The user is asking about how to program a specific controlled gate in Qiskit, a software tool for quantum programming.",Tooling,,,,Tooling,
6472.0,Implementing a complex circuit for a Szegedy quantum walk in qiskit,"<h1>Problem definition</h1>
<p>I'm implementing a quantum circuit in qiskit for a Szegedy quantum walk, <a href=""https://arxiv.org/abs/1609.00173"" rel=""nofollow noreferrer"">(reference, Fig 21.)</a>. It uses two registers of dimension <span class=""math-container"">$N$</span> (<span class=""math-container"">$N=3$</span>) each one. The challenges I'm facing are:</p>
<ol>
<li>Multiple controlled gates (2 and 3 controls and targets like <span class=""math-container"">$H$</span>, <span class=""math-container"">$R_{y}$</span>).</li>
<li>Hermitian conjugate of an operator (Dagger).</li>
<li>Ancilla qubits, that increase the complexity of the circuit.</li>
</ol>
<p>Here is a main part of the circuit:</p>
<p><a href=""https://i.stack.imgur.com/iNjGN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iNjGN.png"" alt=""circuit"" /></a></p>
<p>For example, we have <span class=""math-container"">$K_{b_{2}}$</span> controlled by zero and one controls.</p>
<p><a href=""https://i.stack.imgur.com/ue1oy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ue1oy.png"" alt=""This is the K_{b_{2} without dagger}"" /></a></p>
<h1>Main questions</h1>
<ul>
<li><p>How do I implement the controlled-dagger operator <span class=""math-container"">$K^{\dagger}_{b_{2}}$</span>, of operator <span class=""math-container"">$K_{b_2}$</span>? Does qiskit provide dagger operators of the principal gates? I have a little insight <a href=""https://quantumcomputing.stackexchange.com/questions/3809/what-is-the-purpose-of-the-tdg-gate-in-qiskit"">here</a>. Should I apply tdg to all gates in <span class=""math-container"">$K_{b_{2}}$</span>?</p>
</li>
<li><p>For multiple-controlled qubits operations, I base the construction of the multiple-controlled gates in the Nielsen&amp;Chuang book, as <a href=""https://quantumcomputing.stackexchange.com/questions/2177/how-can-i-implement-an-n-bit-toffoli-gate"">Toffoli gates</a>. So, we must use ancilla qubits. For <span class=""math-container"">$N$</span> controls we use <span class=""math-container"">$N-1$</span> ancilla qubits.</p>
</li>
<li><p>Is the following proposal correct?</p>
</li>
</ul>
<h1>proposition</h1>
<p>So, for <span class=""math-container"">$K_{b_{2}}$</span>, I control individually all the gates as follows, is this approximation correct?</p>
<p><a href=""https://i.stack.imgur.com/Ox5Wb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ox5Wb.png"" alt=""K_{b_{2}}"" /></a></p>
<p>How do I control the <span class=""math-container"">$R_{y}$</span>  gate? I could not find a Controlled rotation around Y-axis only for Z axis (crz).</p>
<h1>qiskit</h1>
<p>I would define for each gate of the above figure, the &quot;compute-copy-uncompute&quot; method <a href=""https://quantumcomputing.stackexchange.com/questions/2177/how-can-i-implement-an-n-bit-toffoli-gate"">here</a>.</p>
<pre><code>def kb2(qw, q0, q1, anc):
    qw.ccx(q0[0], q0[1], anc[0])
    qw.cry(np.pi/2, anc[0], q1[0])
    qw.ccx(q0[0], q0[1], anc[0])
    qw.ccx(q0[0], q0[1], anc[0])
    qw.ccx(anc[0], q1[0], anc[1])
    qw.cry(np.pi/2, anc[1], q1[1])
    qw.ccx(anc[0], q1[0], anc[1])
    qw.ccx(q0[0], q0[1], anc[0])
    qw.ccx(q0[0], q0[1], anc[0])
    qw.ccx(anc[0], q1[0], anc[1])
    qw.ch(anc[1], q1[1])
    qw.ccx(anc[0], q1[0], anc[1])
    qw.ccx(q0[0], q0[1], anc[0])
    
    #... and so on
    
    return kb2

q0 = QuantumRegister(3, 'q0')
q1 = QuantumRegister(3, 'q1')
anc = QuantumRegister(2, 'a')

qwcirc = QuantumCircuit(q0, q1, anc)

qwcirc.x(q0[1]) # for 0-control
kb2(qwcirc, q0, q1, anc)
qwcirc.x(q0[1]) #for 0-control

# Matplotlib Drawing
qwcirc.draw(output='mpl')
</code></pre>
<p>I think half of the Toffoli's gates may be avoided...but I really hope to start a conversation. Thanks in advance.</p>
",<quantum-gate><programming><circuit-construction><qiskit>,6/16/2019 7:02,6474.0,6474.0,"<p>This is an interesting question here.</p>
<blockquote>
<p>How do I implement the controlled-dagger operator <span class=""math-container"">$K^{\dagger}_{b_{2}}$</span>, of operator <span class=""math-container"">$K_{b_2}$</span>? Does qiskit provide dagger operators of the principal gates? I have a little insight <a href=""https://quantumcomputing.stackexchange.com/questions/3809/what-is-the-purpose-of-the-tdg-gate-in-qiskit"">here</a>. Should I apply tdg to all gates in <span class=""math-container"">$K_{b_{2}}$</span>?</p>
</blockquote>
<p>The dagger operation is quite simple to implement and can be seen as a recursive operation.</p>
<p>The only requirement is that the dagger of each gate in your gateset is also in your gateset. This means that if <span class=""math-container"">$U$</span> is a gate in your gateset (i.e. a &quot;primitive&quot; gate), then <span class=""math-container"">$U^\dagger$</span> should also be present in your gateset.</p>
<p>If this requirement is checked (and it is checked for IBM gateset, which is the answer to your second question), then here is a pseudo-algorithm using Python syntax implementing a generic dagger operation:</p>
<pre><code>def dagger(quantum_gate):
    if quantum_gate in gateset:
        return quantum_gate.dagger() # just returning a gate from the gateset.
    # else, quantum_gate is a sequence of other quantum gates (primitive or not)
    daggerized_gate = []
    for gate in reversed(quantum_gate):
        daggerized_gate.append(dagger(quantum_gate)) # recursive call
    return daggerized_gate
</code></pre>
<p>This algorithm is fully-generic: it works for every gates, even for controlled ones, provided the requirement is checked.</p>
<blockquote>
<p>For multiple-controlled qubits operations, I base the construction of the multiple-controlled gates in the Nielsen&amp;Chuang book, as <a href=""https://quantumcomputing.stackexchange.com/questions/2177/how-can-i-implement-an-n-bit-toffoli-gate"">Toffoli gates</a>. So, we must use ancilla qubits. For <span class=""math-container"">$N$</span> controls we use <span class=""math-container"">$N-1$</span> ancilla qubits.</p>
</blockquote>
<p>There are several algorithms that implement a generic <span class=""math-container"">$N$</span>-controlled (controlled by <span class=""math-container"">$N$</span> qubits) <span class=""math-container"">$X$</span> gate. As far as I know, there are 3 distinct classes:</p>
<ol>
<li>The algorithms requiering <span class=""math-container"">$N-1$</span> ancilla qubits as you mention. These algorithms have the best gate-count and circuit-depth complexity.</li>
<li>The algorithms requiering only <span class=""math-container"">$1$</span> ancilla qubit, at the expense of a bigger gate-count and circuit-depth.</li>
<li>Hybrid algorithms between the 2 previous classes: they need more than one ancilla qubit but less than <span class=""math-container"">$N-1$</span> and also have a gate complexity between the 2 previous classes.</li>
</ol>
<p>I don't have links right now, but will edit as soon as possible to provide you links to papers describing algorithms in the 3 previous classes.</p>
<p>Note: if someone has access to some papers, please edit my answer if possible or leave the link in comments.</p>
<blockquote>
<p>Is the following proposal correct?</p>
<p>So, for <span class=""math-container"">$K_{b_{2}}$</span>, I control individually all the gates as follows, is this approximation correct?</p>
<p><a href=""https://i.stack.imgur.com/Ox5Wb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ox5Wb.png"" alt=""K_{b_{2}}"" /></a></p>
<p>How do I control the <span class=""math-container"">$R_{y}$</span>  gate? I could not find a Controlled rotation around Y-axis only for Z axis (crz).</p>
</blockquote>
<p>This is not an approximation: it is 100% correct. Controlling a composed-quantum gate is equivalent to controlling all the gates composing it (may be used recursively).</p>
<p>About the implementation of the <span class=""math-container"">$R_y$</span> gate, you can implement it with the circuit given <a href=""https://quantumcomputing.stackexchange.com/a/2144/1386"">here</a>.</p>
<p><a href=""https://i.stack.imgur.com/sdiGz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sdiGz.png"" alt=""Implementation of the controlled-Ry gate"" /></a></p>
<p>For multiply-controlled <span class=""math-container"">$R_y$</span> gates, you can apply this definition recursively.</p>
<p><strong>A quick observation</strong>: you can remove the 3rd control from the last 2 <span class=""math-container"">$H$</span> gates. If the first 2 controls are verified, the <span class=""math-container"">$H$</span> gate will be applied only once to the last qubit, independently of the value of third control-qubit.</p>
",6/16/2019 13:18, Conceptual,"This question falls into the ""Conceptual"" category because it involves understanding the conceptual aspects of implementing complex quantum circuits for a Szegedy quantum walk in Qiskit. The user is asking about controlled-dagger operators, the use of ancilla qubits, and the construction of multiple-controlled gates, which all relate to the underlying concepts and principles of quantum programming.",Conceptual,,,, Conceptual,
6477.0,How to compute the inverse of an operation in Q#?,"<p>I want to implement amplitude amplification using Q#. I have the operation <span class=""math-container"">$A$</span>
 that prepares my initial state and I need to compute <span class=""math-container"">$ A^{-1} $</span> to implement the algorithm.</p>

<p>Is there an easy way to do that in Q# (a keyword or operation)?</p>
",<programming><q#>,6/16/2019 17:06,6478.0,6478.0,"<p>As given in the <a href=""https://docs.microsoft.com/en-us/quantum/techniques/operations-and-functions?view=qsharp-preview"" rel=""noreferrer"">documentation</a>, if your operation is unitary, you can add the statement <code>adjoint auto;</code> within the operation after the body block. This will generate the adjoint (which is the inverse for unitary).</p>

<p>Then, to use the inverse call <code>Adjoint A(parameters)</code></p>
",6/16/2019 17:33,API Usage,"The question is about how to use the Q# API to implement amplitude amplification, specifically computing the inverse of an operation. Its asking for a specific function or keyword in Q# that can achieve this.",Tooling," The user is asking about how to use a specific function in Q#, a software tool for quantum programming, to implement amplitude amplification. Belong to tooling",No,80.0,API Usage,"The user's question specifically asks about a feature or operation within the Q# language to compute the inverse of an operation, indicating a need for guidance on using the Q# API to achieve this task."
6584.0,How to do randomised benchmarking for non-Clifford gates on Qiskit?,"<p>For my summer research internship I'm looking to randomized benchmark (RB) <em>non</em>-Clifford gates for a single qubit. Since I found out that Qiskit ignis <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/qiskit/ignis/randomized_benchmarking.ipynb"" rel=""nofollow noreferrer"">allows for the RB of Clifford gates</a>, naturally I thought I'd start there. However, the Ignis RB module doesn't seem to allow the RB of non-Clifford gates, or at least it doesn't seem like there's a straightforward way to modify it for non-Clifford gates simulation.  I wondering if anyone has any idea as to what modifications I could be making, or if there's any modules out there that could help me with what I want?</p>
",<quantum-gate><programming><qiskit><randomised-benchmarking>,6/25/2019 9:26,6614.0,6614.0,"<p>Quite simply: it's on the to-do list.</p>

<p><a href=""https://arxiv.org/abs/1510.02720"" rel=""nofollow noreferrer"">Here</a> is a sneak peak of how it will be done.</p>
",6/26/2019 22:40,Tooling,The question is about finding a way to modify the Qiskit Ignis module or finding another module for randomized benchmarking of non-Clifford gates. Its asking for tools and software that can be used for this specific purpose,Tooling,,,,Tooling,
6629.0,Can a quantum computer run classical algorithms?,"<p>I realize that fundamentally speaking quantum and classical computers might as well be apples and oranges, and that for very specific problems such as integer factorization with Shor's algorithm quantum computers blow conventional computers out of the water, but could a quantum computer run classical algorithms?</p>

<p>If so, using a comparable classical computer, how would the calculation speed of a quantum computer running a classical algorithm compare to the calculation speed of the classical computer?</p>
",<classical-computing><classical-quantum>,6/29/2019 7:24,6630.0,6630.0,"<p>Quantum computers can run classical computations using exactly the same algorithms, and hence have the same running time in terms of scaling. For example, if you look at shorâs algorithm, a major component of that is modular exponentiation, but nobody ever draws the circuit because they just say âuse the classical algorithmâ.</p>

<p>In terms of absolute running time, that is heavily hardware dependant so you canât make comparisons so easily.</p>

<p>Quantum computers offer the possibility of other algorithms in addition to the classical ones that could be faster, but thereâs no standard method for generating an improvement.</p>
",6/29/2019 9:42,Conceptual,"This question falls into the ""Conceptual"" category because it seeks to understand the conceptual aspects of quantum computing and its relationship to classical computing. The user is inquiring about whether a quantum computer can run classical algorithms and how the computational speed would compare, which involves discussing the fundamental principles and capabilities of quantum and classical computing.", Conceptual,,,,Conceptual,
6760.0,Hamming with prefix oracle,"<p>I'm doing the Q# quantum katas and I'm stuck on an oracle in the Deutsch-Jozsa algorithm katas.</p>
<p>Let <span class=""math-container"">$|x\rangle=|x_0x_1\dots x_{n-1}\rangle$</span> be a qubit array and <span class=""math-container"">$r$</span> be  bit string of <span class=""math-container"">$k\leq n$</span>. The <span class=""math-container"">$k$</span>-prefix of a bit string <span class=""math-container"">$x$</span>, <span class=""math-container"">$P_k(x)$</span>, is the string obtained by cutting off everything except the first <span class=""math-container"">$k$</span> bits. An oracle for a function <span class=""math-container"">$f$</span> is a unitary operator that performs the following transformation</p>
<p><span class=""math-container"">$$O_f|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\rangle $$</span>
where <span class=""math-container"">$\oplus$</span> represents sum modulo <span class=""math-container"">$2$</span> and <span class=""math-container"">$|y\rangle$</span> in this case is a single qubit.</p>
<p>The task is to write an oracle for the following function</p>
<p><span class=""math-container"">$$f(x)=\left( \bigoplus_{i=0}^{n-1}x_i \right) \oplus g(x,r)$$</span></p>
<p>where <span class=""math-container"">$$ g(x,r)=\begin{cases}
1\quad \textrm{ if } P_k(x)=r\\
0\quad \textrm{ otherwise } 
\end{cases}$$</span></p>
<p>The first term is easy to implement: just apply CNOT on <span class=""math-container"">$y$</span> with |<span class=""math-container"">$x_k\rangle$</span> as a control qubit for each <span class=""math-container"">$k$</span>, this way <span class=""math-container"">$y$</span> is flipped as many times as there are <span class=""math-container"">$1$</span>s in the string <span class=""math-container"">$x$</span>, which is equivalent to flipping if the sum modulo <span class=""math-container"">$2$</span> is <span class=""math-container"">$1$</span>.</p>
<p>The second term is giving me more trouble. I defined the qubit array <span class=""math-container"">$|r\rangle$</span> that contains the state equal to the bit string <span class=""math-container"">$r$</span> and another qubit array of the same length, <span class=""math-container"">$|z\rangle$</span> initially set to <span class=""math-container"">$|00\dots 0\rangle$</span> and I perform the following operation for every <span class=""math-container"">$j=0,\dots k-1$</span></p>
<p><span class=""math-container"">$$\mathrm{CCNOT}|r_j\rangle|x_j\rangle|z_j\rangle $$</span>
<span class=""math-container"">$$X\otimes X |r_j\rangle|x_j\rangle $$</span>
<span class=""math-container"">$$\mathrm{CCNOT}|r_j\rangle|x_j\rangle|z_j\rangle $$</span>
<span class=""math-container"">$$X\otimes X |r_j\rangle|x_j\rangle $$</span></p>
<p>this way the bit <span class=""math-container"">$|z_j\rangle$</span> is flipped if and only if the state of <span class=""math-container"">$|r_j\rangle|x_j\rangle $</span> is <span class=""math-container"">$|0\rangle|0\rangle$</span> or <span class=""math-container"">$|1\rangle|1\rangle$</span>. After this I apply a multi controlled <span class=""math-container"">$X$</span> gate with control <span class=""math-container"">$|z\rangle$</span> and target <span class=""math-container"">$|y\rangle$</span>, the idea being that if <span class=""math-container"">$|z\rangle$</span> contains only <span class=""math-container"">$1$</span> then <span class=""math-container"">$P_k(x)$</span> and <span class=""math-container"">$r$</span> are equal. The test fails, and I can't understand why. Could anybody help?</p>
<p>Here is my code:</p>
<pre><code>        for(k in 0..Length(x)-1) //first term
        {
            CNOT(x[k],y);
        }

        using(register = Qubit[Length(prefix)])
        {
            for(k in 0..Length(prefix)-1)           //copy the bit string prefix in a qubit array
            {                                       //01001... -&gt; |01001..â©
                if(prefix[k]==1)
                {
                    X(register[k]);
                }
            }
            using(z = Qubit[Length(prefix)])
            {
                for(k in 0..Length(prefix)-1)
                {
                    CCNOT(register[k],x[k],z[k]);  //flips the state of the qubit z[k] if register[k] and x[k] are equal
                    X(register[k]);                 //000 -&gt; 000 -&gt; 110 -&gt; 111 -&gt; 001
                    X(x[k]);                        //010 -&gt; 010 -&gt; 100 -&gt; 100 -&gt; 010
                    CCNOT(register[k],x[k],z[k]);  //100 -&gt; 100 -&gt; 010 -&gt; 010 -&gt; 100
                    X(x[k]);                        //110 -&gt; 111 -&gt; 001 -&gt; 001 -&gt; 111
                    X(register[k]);
                }
                Controlled X(z,y);
                for(k in 0..Length(prefix)-1)  //resets z
                {
                    if(M(z[k])==One)
                    {
                        X(z[k]);
                    }
                }
            }
            for(k in 0..Length(prefix)-1) //resets register
            {
                if(M(register[k])==One)
                {
                    X(register[k]);
                }
            }
        }
</code></pre>
",<programming><circuit-construction><q#><oracles>,7/13/2019 12:03,6767.0,6767.0,"<p>One problem is that you are resetting the <span class=""math-container"">$\left|z\right\rangle$</span> register after applying the <code>Controlled X(z, y)</code> operation. Right before you reset, your <span class=""math-container"">$\left|z\right\rangle$</span> register is entangled with the other two registers, such that resetting in that way collapses any superposition on the <span class=""math-container"">$\left|x\right\rangle \left|y\right\rangle$</span> registers. While that's not a problem if you only ever provide as input qubits in a computational basis state, the DeutschâJozsa algorithm uses inputs in states such as <span class=""math-container"">$\left|++\cdots+\right\rangle\left|-\right\rangle$</span>.</p>

<p>If you want to use this approach, you'll need to first <em>uncompute</em> the information stored in <span class=""math-container"">$\left|z\right\rangle$</span>.
Here, that means running the following loop over again after applying <code>Controlled X(z, y)</code>:</p>

<pre><code>for(k in 0..Length(prefix)-1)
{
    CCNOT(register[k],x[k],z[k]);  //flips the state of the qubit z[k] if register[k] and x[k] are equal
    X(register[k]);                 //000 -&gt; 000 -&gt; 110 -&gt; 111 -&gt; 001
    X(x[k]);                        //010 -&gt; 010 -&gt; 100 -&gt; 100 -&gt; 010
    CCNOT(register[k],x[k],z[k]);  //100 -&gt; 100 -&gt; 010 -&gt; 010 -&gt; 100
    X(x[k]);                        //110 -&gt; 111 -&gt; 001 -&gt; 001 -&gt; 111
    X(register[k]);
}
</code></pre>

<p>Doing so will deterministically return <span class=""math-container"">$\left|z\right\rangle$</span> to the all-zeros state, without using measurement.
This is very common in quantum programming, and is why the Q# standard libraries include operations like <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.canon.applywithca"" rel=""nofollow noreferrer""><code>ApplyWithCA</code></a>.</p>
",7/13/2019 17:13,Errors,The question is about an issue the user is facing while implementing a quantum circuit for a Szegedy quantum walk in Q#. They are seeking help to understand and resolve the errors they are encountering in their code,Errors,,,,Errors,
6799.0,A quantum computer that doesn't use entangled qubits has the same computational power as a classical one?,"<p>Is the statement in the question correct?
I would love to receive an explanation as to why it is or isn't.</p>

<p>I have a computer science degree background and I am a beginner learning the fundamental of QC from scratch.</p>
",<classical-computing>,7/17/2019 22:07,6801.0,6801.0,"<p>Assuming you are talking about starting from a <em>pure</em> state, your statement is true. There are two steps to the proof:</p>

<ul>
<li><p>Show that a system without entanglement can implement any classical computation.</p></li>
<li><p>Show that a system that remains separable can be simulated by a classical computation, proving that there are no calculations it can implement that a classical computer cannot.</p></li>
</ul>

<p>The first is straightforward. Every classical computation can be written as a classical reversible computation. The Toffoli gate (controlled-controlled-not) is universal for classical reversible computation, so any circuit can be entirely decomposed in terms of that. But Quantum computers can implement the Toffoli gate, so they can implement any classical computation, and the state of the system at any intermediate point must be the same as in the classical computation, and therefore separable.</p>

<p>The second is also reasonably straightforward. If we know that every qubit remains separable, then we can hold in memory just the set of <span class=""math-container"">$N$</span> qubit states, comprising <span class=""math-container"">$N$</span> 2-element normalised complex vectors (as compared to the general case of a single <span class=""math-container"">$2^N$</span> element normalised complex vector). Whatever set of gates we use to describe the computation will act on some finite number of qubits, say <span class=""math-container"">$k$</span> at maximum (independent of <span class=""math-container"">$N$</span>). So each computational step requires the action of a <span class=""math-container"">$2^k\times 2^k$</span> matrix, which we just have to apply to the appropriate set of <span class=""math-container"">$k$</span> separable states. We extract the separable states at the end, and continue. The total simulation time is <span class=""math-container"">$O(NM)$</span> for a sequence of <span class=""math-container"">$M$</span> gates on a classical computer.</p>
",7/18/2019 6:42, Learning,"The question is asking for an explanation of a statement in the question, which suggests that the user is trying to learn about the topic. Additionally, the user states that they are a beginner learning the fundamentals of quantum computing, which further supports the categorization of the question as learning-oriented.", Learning,,,, Learning,
6940.0,How to calculate an Expected Value of some operator acting on qubits?,"<p>I'm trying to implement the Variational Quantum Eigensolver in Qiskit.</p>

<p>Suppose, I have an operator <span class=""math-container"">$A = \sigma_1^z\sigma_2^z$</span> acting on some two-qubit state <span class=""math-container"">$|\psi\rangle$</span>. After a measurement I get a set of probabilities corresponding to  states <span class=""math-container"">$|00\rangle$</span>, <span class=""math-container"">$|01\rangle$</span>, <span class=""math-container"">$|10\rangle$</span>, <span class=""math-container"">$|11\rangle$</span>.</p>

<p>My question is: How to calculate <span class=""math-container"">$\langle\psi|A|\psi\rangle$</span> using known set of probabilities?</p>
",<programming><qiskit><measurement><textbook-and-exercises><vqe>,08/04/2019 12:05,6944.0,6944.0,"
<p>Qiskit currently supports measurements in the computational basis from Qiskit Terra and Aer, that is, returning <code>1</code> if the qubit is in state <span class=""math-container"">$|1\rangle$</span>, and <code>0</code> if the qubit is measured to be in state <span class=""math-container"">$|0\rangle$</span>.</p>
<p>However, it is relatively easy to perform a change of basis unitary to our quantum circuit just prior to measurement, in order to instead measure in the eigenbasis of an arbitrary operator <span class=""math-container"">$A$</span>:</p>
<ol>
<li><p>First, we need to compute the eigendecomposition of our Hermitian observable <span class=""math-container"">$A|v_i\rangle=\lambda_i|v_i\rangle$</span>.</p>
</li>
<li><p>Since <span class=""math-container"">$A$</span> is Hermitian, we are always able to diagonalize <span class=""math-container"">$A$</span> in this eigenbasis:</p>
<p><span class=""math-container"">$$A = \sum_{i}\lambda_i |v_i\rangle \langle v_i|= U^\dagger \Lambda U$$</span></p>
<p>where <span class=""math-container"">$\Lambda = \text{diag}(\lambda_1,\dots,\lambda_n)$</span> and <span class=""math-container"">$U$</span> is a unitary matrix composed of the eigenvectors down the columns.</p>
</li>
<li><p>Next, we apply the unitary operation <span class=""math-container"">$U$</span> to the end of our quantum circuit, using <code>qc.unitary</code>.</p>
<p>To see why, note that <span class=""math-container"">$$\langle\psi|A|\psi\rangle = \langle\psi|U^\dagger \Lambda U|\psi\rangle = \langle\psi'|\Lambda|\psi'\rangle $$</span> where <span class=""math-container"">$|\psi'\rangle = U|\psi\rangle.$</span>  Since <span class=""math-container"">$\Lambda$</span> is diagonal, we have transformed the problem from one where we must perform a measurement in an arbitrary basis, to one where we simply measure in the computational basis.</p>
</li>
<li><p>Finally, we measure the state <span class=""math-container"">$|\psi'\rangle$</span> in the computational basis <span class=""math-container"">$|i \rangle$</span>  using <code>qc.measure(q, c)</code>, and execute the jobs to get the counts and probabilities <span class=""math-container"">$\mathbb{P}_i = |\langle i|\psi'\rangle|^2$</span>. Using the previously computed eigenvalues of <span class=""math-container"">$A$</span>, we can now reconstruct the expectation value:</p>
<p><span class=""math-container"">$$\langle \psi | A | \psi\rangle = \langle\psi'|\Lambda|\psi'\rangle = \sum_i \langle\psi'|i\rangle \langle i | \Lambda | i\rangle \langle i|\psi'\rangle = \sum_i \lambda_i \mathbb{P}_i$$</span></p>
</li>
</ol>
<p>For example,</p>
<pre><code>shots = result.results[0].shots
counts = result.get_counts()
probs = sorted([(i, c/shots) for i, c in counts.items()])
P = np.float64(np.array(probs)[:, 1])
A_expectation = lambda @ p
</code></pre>
<hr />
<p>For a more high-level interface to coding and running variational quantum algorithms, you can also check out the PennyLane Python library, which has a Qiskit plugin available for using Qiskit simulators and IBM hardware as a backend.</p>
<p>For example, a expectation values of arbitrary operators in PennyLane using qiskit looks like this:</p>
<pre><code>import pennylane as qml

dev = qml.device('qiskit.basicaer', wires=2)
# use 'qiskit.ibm' instead to run on hardware

@qml.qnode(dev)
def circuit(x, y, z):
    qml.RX(x, wires=0)
    qml.RY(y, wires=1)
    qml.RZ(z, wires=0)
    qml.CNOT(wires=[0, 1])
    return qml.expval(qml.Hermitian(A, wires=[0, 1]))

def cost(x, y, z):
    return (1-circuit(x, y, z))**2

# optimization follows
</code></pre>
<p>You can use NumPy, TensorFlow, or PyTorch to do the optimization - check out some of the tutorials.</p>
<p><strong>Disclaimer:</strong> I am one of the developers on PennyLane.</p>
",08/05/2019 05:21,Theoretical ,The question is about the theoretical concept of calculating the expectation value of an operator given a set of probabilities in the context of the Variational Quantum Eigensolver. Its asking for an explanation of this concept.,Theoretical ,,,,Theoretical ,
6978.0,Are there many practical problems for which Grover's algorithm beats the best heuristic classical algorithm?,"<p>It's well known that, given an oracle for a function <span class=""math-container"">$f$</span> from a very large set <span class=""math-container"">$S$</span> (of order <span class=""math-container"">$N \gg 1$</span>) to <span class=""math-container"">$\{0, 1\}$</span>, Grover's algorithm can find an element of <span class=""math-container"">$S$</span> that maps to 1 with <span class=""math-container"">$\sim \sqrt{N}$</span> oracle queries, whereas the best classical oracle search algorithm requires <span class=""math-container"">$\sim N$</span> queries.</p>

<p>From this, it's often claimed that a quantum computing running Grover's algorithm could give useful speedups for many practical computational problems (since many such problems, e.g. numerical optimization, can be framed in this form).</p>

<p>But Grover's algorithm is a ""black-box"" algorithm that treats the oracle as the only method of getting any information at all about the solution to your problem. It completely ignores any possible correlations between the oracle's responses for different inputs, or any other ""structure"" behind the computation to be solved. Grover's algorithm therefore gives a square-root speedup over <em>completely naive, brute-force search</em> of every possible solution.</p>

<p>But it seems to me that (loosely speaking), most ""interesting"" or ""practical"" computational problems have enough structure that complete brute-force guessing is rarely the best classical approach. As a simple example, for numerically optimizing some complicated but differentiable function, gradient descent (plus some means of escaping from local minima) is typically vastly more efficient than random sampling.</p>

<p>Now an <em>exponential</em> (classical) speedup over brute-force guessing is too much to hope for in general: if <span class=""math-container"">$\mathrm{P} \neq \mathrm{NP}$</span> (which is presumably the case), then there exist problems in NP that do not admit exponential (classical) improvements over brute-force guessing that work even in the worst case. But even NP-complete problems often admit heuristic algorithms that allow for efficient solutions ""in practice"", e.g. they work for most problem instances. Even when this is not the case, my intuition is that most ""practical"" problems admit classical algorithms that provide an algebraic speedup over brute-force guessing that is better than square-root, at least for many problem instances. So my intuition is that for most ""practical"" problems, there's usually a heuristic classical algorithm that's more efficient than using Grover's algorithm for a square-root speedup over brute-force search.<sup>1</sup></p>

<p>Is my intuition correct? Are they many practical problems for which the best known classical algorithms deliver less than a square-root speedup over brute force guessing ""in practice""? (I guess the somewhat sharper version of ""in practice"" means ""in the average case"", but I'm also interested in less formal interpretations of ""in practice"" as well.) More bluntly, would a quantum computing running Grover's algorithm actually be that useful for many practical computational problems?</p>

<p>(Strictly speaking, this is just a question about classical algorithms, but I think this is the right place to ask it, because people here are more likely to have thought about quantum speedups for these kind of problems.)</p>

<hr>

<p><sup>1</sup> The only type of problem for which I <em>wouldn't</em> expect any classical algorithm to provide a significant improvement over brute-force search is one where the mathematical structure has been <em>deliberately</em> chosen to be as complicated and obfuscated as possible. For example, inverting cryptographic hash functions or cracking a symmetric-key encryption algorithm like AES. This means that, ironically, the only type of math problem for which I can intuitively see Grover's algorithm delivering a clear quantum speedup is breaking symmetric-key encryption and hashes. (This is ironic because the main application for the <em>other</em> most famous quantum algorithm, Shor's algorithm, is of course <em>also</em> for breaking cryptography, although public-key rather than symmetric-key.)</p>
",<grovers-algorithm><complexity-theory><classical-computing><speedup>,08/09/2019 02:28,6991.0,6991.0,"<p>I found the answer in <a href=""https://www.scottaaronson.com/qclec/22.pdf"" rel=""nofollow noreferrer"">these notes</a>:</p>

<blockquote>
  <p>For an âNPâ-complete problem like CircuitSAT, we can be pretty confident that the Grover speedup is real, because no one has found any classical algorithm thatâs even slightly better than brute force.  On the other hand, for more âstructuredâ âNPâ-complete problems, we â<em>do</em>â know exponential-time algorithms that are faster than brute force: for example, 3SAT is solvable in about <span class=""math-container"">$O(1.3â^nâ)$</span> time. So then the question becomes a subtle one, of whether Groverâs algorithm can be <em>âcombinedâ</em> with the best classical tricks that we know, to achieve a polynomial speedup even compared to a classical computer that uses the same tricks.  For many âNPâ-complete problems, the answer seems to be yes, but it need not be yes for all of them.</p>
</blockquote>
",08/12/2019 01:05,Conceptual,"This question falls into the ""Conceptual"" category because the user is seeking a conceptual understanding and discussion regarding the potential usefulness of Grover's algorithm in practical computational problems compared to classical algorithms. They are exploring the theoretical implications and limitations of quantum speedup for various problem types, making it a conceptual inquiry.",Conceptual,,,,Conceptual,
6993.0,"Q#: How to setup a project correctly (on Linux, command line)?","<p>When setting up projects with Q# I used to start with the given <a href=""https://docs.microsoft.com/en-us/quantum/quickstart?tabs=tabid-vscode&amp;view=qsharp-preview"" rel=""nofollow noreferrer"">Quick-Starting Guide</a>. Following the tutorial I am able to setup the example problem and the program works well.</p>

<p>However, there seems to be some issues when trying to use the Q# Libraries, e.g., the Arithmetic libraries or Arrays. Consider the following minimal working example created from the tutorial:</p>

<p><em>Driver.cs</em>
<code>
using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;
using System.Diagnostics;</p>

<p>namespace Microsoft.Quantum.Numerics.Samples
{
    class Program
    {
        static void Main(string[] args)
        {
            using (var qsim = new QuantumSimulator())
            {
                RunAll.Run(qsim).Wait();
            }
        }
    }
}
</code></p>

<p><em>Operation.qs</em>
<code>
namespace Bell
{
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Arithmetic;  // Added this line
    operation HelloQ () : Unit {
        Message(""Hello quantum world!"");
        using ( (xQb, yQb) = (Qubit[5], Qubit[5]) ) // And this block
        {
            AddI(LittleEndian(xQb), LittleEndian(yQb));
        }
    }
}
</code></p>

<p>Where only the line indicating the usage of the Microsoft.Quantum.Arithmetic library and the code block using the <code>AddI($\cdot$)</code> operation (or function?) have been added to the tutorial code. This results in an error :</p>

<p><em>error QS5022: No identifier with that name exists.</em></p>

<p>Whereas I am sure that this is not a Q# issue, I do wonder if anybody stumbled upon a similar problem, or know how to fix that?</p>

<p><strong>Solution:</strong> Using any of the example code from GitHub, <em>all</em> functionalities that I was able to add work without any problems. Using such a sample project I can just delete all the code and rewrite it, which works well.</p>

<p><strong>Question:</strong> While copy-paste-delete using sample projects is a viable approach to set up new projects, I do wonder what I am missing in the ""normal"" project setup?</p>
",<programming><q#>,08/12/2019 06:28,6994.0,6994.0,"<p>(I tried the fix in Visual Studio, but I'm pretty sure that will work with command line as well)</p>

<p>You need to add <code>Microsoft.Quantum.Numerics</code> NuGet package reference to your project, as described <a href=""https://docs.microsoft.com/quantum/libraries/numerics/installation"" rel=""nofollow noreferrer"">here</a>. That is the package in which <code>AddI</code> is defined, and by default a newly created Q# project doesn't include this reference.</p>

<p>If you copy an existing project from Numerics section of the samples, it will already include the reference to this package (see, for example, <a href=""https://github.com/microsoft/Quantum/blob/master/Numerics/CustomModAdd/CustomModAdd.csproj"" rel=""nofollow noreferrer"">this .csproj file</a>).</p>
",08/12/2019 08:05,Errors,"The question is seeking a solution to an error in setting up a Q# project where the user is encountering issues when trying to use Q# libraries, specifically the Microsoft.Quantum.Arithmetic library. They are looking for help in resolving the error message they received, making it appropriate for the ""Errors"" category.",Errors,,,,Errors,
7012.0,Q#: dynamically assigning (or updating) multidimensional Qubit arrays,"<p><strong>Question: how to dynamically assign qubits to variables?</strong></p>

<p>e.g., say I want to represent a matrix of qubits:</p>

<p><span class=""math-container"">$matrix := \{\vec{v_1}, \vec{v_2}, ..., \vec{v_r}\}$</span></p>

<p>where each vector consists of <span class=""math-container"">$dim$</span> many coefficients of each <span class=""math-container"">$bitlength$</span> many qubits.</p>

<p>(To the best of my knowledge) Q# only allows to initiate one-dimensional Qubit arrays:</p>

<pre><code>using ( allQubits = Qubit[rank * dim * bitlength] ) {
    // Some Code
}
</code></pre>

<p>Which leaves us with the task to assign a partition of that qubit array to variables.</p>

<p>I see three ways of doing that, that first seems very messy, the other two I did not get to work:</p>

<ol>
<li>Remembering indices in the qubit array (this will be messy)</li>
<li>Getting a representation of a three dimensional qubits array: <span class=""math-container"">$Qubit[rank][dim][bitlength]$</span></li>
<li>Getting a custom type of QubitVectors and getting an array of those.</li>
</ol>

<p><em>Any solution is welcome, does not have to follow any of these approaches.</em></p>

<hr>

<p>Lets start with a <span class=""math-container"">$Qubit[rank][dim][bitl]$</span> array. Using the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arrays.partitioned?view=qsharp-preview"" rel=""nofollow noreferrer"">Partitioned</a> function, one can split the <em>allQubits</em> array into smaller parts, e.g., the qubits that represent a single vector.</p>

<pre><code>// Splits a given qubit array into chunks of length size
operation splitQubitArray( allQubits : Qubit[], chunkSize : Int ) : Qubit[][]
{   
    Fact(Length(allQubits) % chunkSize == 0, ""Qubit array can not be splitted into equally sized chunks"");
    Fact(Length(allQubits) / chunkSize &gt; 0, ""Qubit array length is smaller than chunk size."");
    let numChunks = Length(allQubits) / chunkSize;
    mutable arraySplit = new Int[numChunks];
    for (i in 0..(numChunks - 1))
    {
        set arraySplit w/= i &lt;- chunkSize;
    }
    let res = Partitioned(arraySplit, allQubits);
    Fact(Length(res[numChunks]) == 0, ""Qubit array not split equally."");
    return res;
}

// Split AllQubits into rank many parts.
// Each part contains dim * bitl many qubits.
mutable allVecQubits = splitQubitArray( allQubits, dim * bitl );
</code></pre>

<p>Now we have a two dimensional array, where each entry of the first dimension represents a vector. One can split these further to get out a single vector variable, but I could not figure out how to put this into a iterable array...</p>

<pre><code>mutable vec_1 = splitQubitArray(allVecQubits[0], rank);
mutable vec_2 = splitQubitArray(allVecQubits[1], rank);
...
</code></pre>

<hr>

<p>Option 3, the <a href=""https://docs.microsoft.com/en-us/quantum/language/type-model?view=qsharp-preview"" rel=""nofollow noreferrer"">type model</a>: we define a type that contains a vector.</p>

<pre><code>newtype customVec = (Data : Qubit[][]);
</code></pre>

<p>This leaves me with the problem that I am not able to initialize an array of that type...</p>

<pre><code>mutable qbVectorArray = customVec[0]; // this does not work
mutable qbVectorArray = new customVec[0]; // this does not work
mutable qbVectorArray = customVec(new Qubit[][]); // this does not work
</code></pre>

<hr>

<p>As a note on the side: 
I tried to consule the documentation in <a href=""https://docs.microsoft.com/en-us/quantum/language/expressions?view=qsharp-preview#copy-and-update-expressions"" rel=""nofollow noreferrer"">copy-and-update expressions</a> but could not figure out how to do this, if the custom type contains Qubits. Furthermore the webpage containing the ""update-and-reassign statements"" for Q# Arrays which is linked in the <a href=""https://docs.microsoft.com/en-us/quantum/language/type-model?view=qsharp-preview"" rel=""nofollow noreferrer"">type model</a> page seems to be unavailable.
An example or guide on how to deal with custom types with Qubits would be very much appreciated.</p>
",<programming><q#>,8/14/2019 8:17,7017.0,7017.0,"<p>One important thing to note is that arrays of <code>Qubit</code> aren't special in Q#, such that a solution that allows for splitting an array of type <code>'T[]</code> into <code>'T[][][]</code> will also work for arrays of qubits such as what you get from a <code>using</code> statement.</p>

<p>From that perspective, your solution is almost there already; you just need to generalize <code>splitQubitArray</code> into a function that takes <code>'T</code> instead, then you can call that with <code>'T</code> being <code>Qubit[]</code> instead of <code>Qubit</code>.
Turning your operation into a function and adding a type parameter, we get the following:</p>

<pre><code>open Microsoft.Quantum.Arrays;
open Microsoft.Quantum.Diagnostics;

function Chunked&lt;'T&gt;(array : 'T[], chunkSize : Int) : 'T[][] {
    Fact(Length(array) % chunkSize == 0, ""Array can not be splitted into equally sized chunks"");
    Fact(Length(array) / chunkSize &gt; 0, ""Array length is smaller than chunk size."");
    let numChunks = Length(array) / chunkSize;
    let res = Partitioned(ConstantArray(numChunks, chunkSize), array);
    Fact(Length(res[numChunks]) == 0, ""Qubit array not split equally."");
    // Note that since Parititoned always returns
    // one more array than the length of the array
    // of chunk sizes, chop off the last element of its result.
    return Most(res);
}
</code></pre>

<p>This can then be used twice to turn an array of type <code>'T[]</code> into an array of type <code>'T[][][]</code> <em>for any</em> element type <code>'T[]</code>. For example, we can chunk an array of type <code>Int[]</code> into a rank-three array of integers:</p>

<pre><code>open Microsoft.Quantum.Arrays;
open Microsoft.Quantum.Convert;

function Example() : Unit {
    let rank3 = Chunked(Chunked(RangeAsIntArray(1.. 5 * 2 * 3), 2), 3);
    Message(<span class=""math-container"">$""Rank-3 array: {rank3}"");
    Message($</span>""Length(rank3) = {Length(rank3)}"");
    Message(<span class=""math-container"">$""Length(rank3[0]) = {Length(rank3[0])}"");
    Message($</span>""Length(rank3[0][0]) = {Length(rank3[0][0])}"");
}
</code></pre>

<p>This gives us as our output:</p>

<pre><code>Rank-3 array: [[[1,2],[3,4],[5,6]],[[7,8],[9,10],[11,12]],[[13,14],[15,16],[17,18]],[[19,20],[21,22],[23,24]],[[25,26],[27,28],[29,30]]]
Length(rank3) = 5
Length(rank3[0]) = 3
Length(rank3[0][0]) = 2
</code></pre>

<p>In your example above, then, you could use this new function to make a rank-3 array of qubits:</p>

<pre><code>let qubitsAsRank3Array = Chunked(Chunked(allVecQubits), dim), bitlength);
let vec1 = qubitsAsRank3Array[0];
let vec1 = qubitsAsRank3Array[1];
// ...
</code></pre>

<hr>

<p>This example can be run online at: <a href=""https://mybinder.org/v2/gist/cgranade/e4a837dcb37a4e60f8e971cf1372a2ef/master"" rel=""nofollow noreferrer"">https://mybinder.org/v2/gist/cgranade/e4a837dcb37a4e60f8e971cf1372a2ef/master</a></p>
",8/14/2019 17:28,Tooling,"The question is about how to implement a specific feature in Q# (dynamically assigning qubits to variables). This is a tooling question, as it is about the specific implementation of the feature in Q#.",API Usage," The user is trying to implement a specific functionality in Qiskit, a quantum computing framework, and is asking for help on how to use the API to dynamically assign qubits to variables. This involves understanding how to use the Qiskit API effectively and correctly, which is the focus of the API Usage category.",No,81.0,Tooling,"The user's question is specifically about how to implement a feature within Q#, the quantum programming language. It pertains to the tooling aspect of Q# development, focusing on the implementation details and techniques within the language itself."
7188.0,How to understand run_algorithm() inputs in qiskit,"<p>I'd like to better understand the Max-Cut algorithm from the <a href=""https://github.com/Qiskit/qiskit-community-tutorials/blob/master/optimization/max_cut.ipynb"" rel=""nofollow noreferrer"">qiskit tutorials</a>. Particularly, the run_algorithm function inputs. The inputs are two dictionaries, but I can't find any documentation or explanation as to why these dictionaries are structured the way they are. Example from the tutorial:</p>

<pre><code>algorithm_cfg = {
    'name': 'ExactEigensolver',
}

params = {
    'problem': {'name': 'ising'},
    'algorithm': algorithm_cfg
}
result = run_algorithm(params,algo_input)
</code></pre>

<p>Why is the 'problem' key in the params dictionary labeled with 'Ising'? Why bother including the 'problem' entry if the algorithm is an exact eigensolver? For non-exact eigensolver algorithms, why would the algorithm need to know it's mapping to an Ising model if also_input already has the qubit operator mapping? I'm confused about these hyper parameters and can't seem to find resources/explanations for them. Please help!</p>

<p>There are great tutorials solving interesting problems with qiskit, but all the approaches are how to solve one specific problem using one specific algorithm. For example, the max-cut tutorial doesn't use the QAOA, but it should be able to solve the problem just as well as VQE which is used. Are there no tutorials/resources on the general use of qiskit Aqua algos? (e.g. how to implement each algorithm, explanations on the required inputs, what happens to the underlying quantum computing structure, and the math behind it?)</p>
",<algorithm><programming><qiskit><qaoa>,09/05/2019 13:59,8389.0,8389.0,"<p><a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/aqua/optimization/max_cut_and_tsp.ipynb"" rel=""nofollow noreferrer"">That tutorial</a> was recently updated. In it you'll find a more familiar way to declare and execute algorithms. </p>

<pre><code>ee = ExactEigensolver(qubitOp, k=1)
result = ee.run()
</code></pre>

<p>The <code>problem</code> section of the older <em>declarative</em> form of Aqua execution (which is gradually being moved away from) is a way for the Aqua UI to display a list of algorithms applicable to a user-selected ""problem."" It doesn't add anything here.</p>
",10/03/2019 01:46,Tooling,"The user is asking about how to use the Qiskit Aqua library, which is a tool for quantum programming.",Tooling,,,,Tooling,
7201.0,How do these alternative Q# algorithms produce the same set of Bell states?,"<p>In the ""Superposition"" Microsoft quantum katas (<a href=""https://github.com/microsoft/QuantumKatas/blob/master/Superposition/ReferenceImplementation.qs"" rel=""nofollow noreferrer"">https://github.com/microsoft/QuantumKatas/blob/master/Superposition/ReferenceImplementation.qs</a>) the solution for Task 7 looks like this:</p>

<pre><code>// ------------------------------------------------------
// Task 7. All Bell states
// Inputs:
//      1) two qubits in |00â© state (stored in an array of length 2)
//      2) an integer index
// Goal: create one of the Bell states based on the value of index:
//       0: |Î¦âºâ© = (|00â© + |11â©) / sqrt(2)
//       1: |Î¦â»â© = (|00â© - |11â©) / sqrt(2)
//       2: |Î¨âºâ© = (|01â© + |10â©) / sqrt(2)
//       3: |Î¨â»â© = (|01â© - |10â©) / sqrt(2)

operation AllBellStates_Reference (qs : Qubit[], index : Int) : Unit is Adj {
H(qs[0]);
CNOT(qs[0], qs[1]);

// now we have |00â© + |11â© - modify it based on index arg
if (index % 2 == 1) {
    // negative phase
    Z(qs[1]);
}
if (index / 2 == 1) {
    X(qs[1]);
}
</code></pre>

<p>}</p>

<hr>

<p>And my alternative solution looks like this:</p>

<pre><code>// Task 7. All Bell states 
// Inputs: 
//      1) two qubits in |00â© state (stored in an array of length 2) 
//      2) an integer index 
// Goal: create one of the Bell states based on the value of index: 
//    0: |Î¦âºâ© = (|00â© + |11â©) / sqrt(2) 
//    1: |Î¦â»â© = (|00â© - |11â©) / sqrt(2) 
//    2: |Î¨âºâ© = (|01â© + |10â©) / sqrt(2) 
//    3: |Î¨â»â© = (|01â© - |10â©) / sqrt(2)

operation AllBellStates (qs : Qubit[], index : Int) : Unit 
{
H(qs[0]);
CNOT(qs[0], qs[1]);

if (index == 0){ 
} elif(index == 1) {
    Z(qs[0]);
} elif(index == 2){
    X(qs[0]);
} elif(index == 3){
    X(qs[0]);
    Z(qs[1]);
}
</code></pre>

<p>}</p>

<hr>

<p><strong>Yet BOTH solutions pass the unit tests</strong>. How is that possible, since the X-gate and Z-gate operators are being applied to the <strong>other</strong> qubit in the pair?
Could the unit test logic be incorrect?</p>
",<quantum-gate><programming><q#>,09/07/2019 21:40,7202.0,7202.0,"<p>The unit test logic is correct, no worries there! One of the really neat things about the four Bell states is that you can transform between each using single-qubit operations.
For example, consider the Bell state <span class=""math-container"">$\left|\Phi^{+}\right\rangle = \frac{1}{\sqrt{2}} \left(\left|00\right\rangle + \left|11\right\rangle\right)$</span>. Flipping the first qubit with an <code>X</code> instruction transforms the state of your qubits to <span class=""math-container"">$\frac{1}{\sqrt{2}} \left(\left|10\right\rangle + \left|01\right\rangle\right)$</span>, while flipping the second qubit with <code>X(qs[1])</code> transforms your qubits into the state <span class=""math-container"">$\frac{1}{\sqrt{2}} \left(\left|01\right\rangle + \left|10\right\rangle\right)$</span>. Since addition is commutative (that is, <span class=""math-container"">$a + b = b + a$</span>), these two states are equal.</p>

<p>Thus, even though <code>X(qs[0])</code> and <code>X(qs[1])</code> are very different instructions, they do the same thing in the special case of the Bell state <span class=""math-container"">$\left|\Phi^{+}\right\rangle$</span>.
In the same way, <code>Z(qs[0])</code> and <code>Z(qs[1])</code> do the same thing to <span class=""math-container"">$\left|\Phi^{+}\right\rangle$</span>.
Another way of thinking of why this is is that the quantum programs <code>ApplyToEach(X, qs)</code> and <code>ApplyToEach(Z, qs)</code> do <em>nothing</em> to qubits in the state <span class=""math-container"">$\left|\Phi^{+}\right\rangle$</span>, similarly to how <code>Z(q)</code> does nothing when <code>q</code> is in the state |0â©.
If you're interested, there's a beautiful mathematical framework known as the <em>stabilizer formalism</em> for helping to track these kinds of symmetries of quantum states.</p>
",09/07/2019 22:01,Errors ,"The user is seeking an explanation for an unexpected behavior in their quantum program, which is that two seemingly different solutions are both passing the unit tests.",Errors,,,,Errors ,
7216.0,How to add scalar to quantum string,"<p>I need a way to add scalar values to a quantum string. </p>

<p>Say if 
<span class=""math-container"">$| v \rangle = |1 1 0 \rangle + |1 0 1 \rangle$</span>  then <span class=""math-container"">$|v \rangle + 5 = |1 0 1 1 \rangle + |1 1 0 0\rangle$</span></p>

<p>Is there a known method to do this?</p>

<p>I don't want tot express 5 as a qubit string in order to save qubits.</p>
",<programming><q#>,09/10/2019 16:17,7220.0,7220.0,"<p>Generally you have to perform the addition modulo some constant; you can't grab another qubit if you need to overflow. Code for modular addition of a constant is available in the <a href=""https://github.com/microsoft/QuantumLibraries/blob/master/Standard/src/Arithmetic/Increment.qs"" rel=""nofollow noreferrer"">Increment.qs</a> file in the Q# standard library, in the <code>IncrementByInteger</code> operation. Check out the documentation <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arithmetic.incrementbyinteger?view=qsharp-preview"" rel=""nofollow noreferrer"">here</a>.</p>
",09/10/2019 20:11,Theoretical,"The user is asking about a theoretical concept in quantum computing, specifically about adding scalar values to a quantum string. This question delves into the theoretical aspects of quantum computing and quantum state manipulation.",Theoretical,,,,Theoretical,
8238.0,Ground state energy estimation - VQE vs. Ising vs. TrotterâSuzuki,"<p><strong><em>Disclaimer:</strong> I am a software engineer who is curious about quantum computing. Although I understand some basic concepts, theory and math behind it, I am by no means experienced in this domain.</em></p>

<p>I am doing some preliminary research on the state of quantum software development. Part of my research is to evaluate Microsoft's QDK and some of its samples (written in Q#).</p>

<p>As I understand, certain optimization problems (the traveling salesman sort) may be tackled by first reducing them as QUBO or Ising problems and then solving them via quantum annealing or VQE algorithms. Part of this process is finding out the Hamiltonian and solving Schrodinger's equation. This is my understanding, kindly correct me if wrong.</p>

<p>QDK's <a href=""https://github.com/microsoft/Quantum/tree/master/samples/simulation"" rel=""nofollow noreferrer"">Hamiltonian simulation samples</a> have examples for Ising and TrotterâSuzuki based simulations. But recently 1Qbit has released a <a href=""http://openqemist.1qbit.com/docs/vqe_microsoft_qsharp.html"" rel=""nofollow noreferrer"">VQE-based solution</a>.</p>

<p>My question is: do all the methods listed above (VQE, Ising, TrotterâSuzuki) do the same thing? That is, estimate ground state energy of a given system? For example, do the H2 simulation examples based on <a href=""http://openqemist.1qbit.com/docs/vqe_microsoft_qsharp.html"" rel=""nofollow noreferrer"">VQE</a> and <a href=""https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line"" rel=""nofollow noreferrer"">TrotterâSuzuki</a> pretty much do the same thing in different ways? If so, which method should be preferred?</p>
",<algorithm><hamiltonian-simulation><q#><trotterization>,09/12/2019 06:53,8248.0,8248.0,"<p>In each of the examples you mentioned, the task breaks very roughly down into two steps: finding a Hamiltonian that describes the problem in terms of qubits, and finding the ground state energy of that Hamiltonian. From that perspective, the JordanâWigner transform is a way to find a qubit Hamiltonian corresponding to a given fermionic Hamiltonian.</p>

<p>Once you have your problem specified in terms of a qubit Hamiltonian, there's (again, very roughly) two families of approaches to finding a ground state energy. With variational approaches, you prepare states from a family of states called an <em>ansatz</em>, then estimate the expectation value of the Hamiltonian for each different input state, and minimize. To get each expectation value, you can do something like break the Hamiltonian <span class=""math-container"">$H$</span> up into a sum <span class=""math-container"">$H = \sum_i h_i H_i$</span>, where each <span class=""math-container"">$h_i$</span> is a real number and each <span class=""math-container"">$H_i$</span> is a Hamiltonian that's easier to estimate the expectation value of, such as a Pauli operator. You can then estimate <span class=""math-container"">$\langle H \rangle$</span> by estimating each <span class=""math-container"">$\langle H_i \rangle$</span> in turn.</p>

<p>The other broad approach is to turn your energy estimation problem into a frequency estimation problem by evolving an input state under the qubit Hamiltonian <span class=""math-container"">$H$</span> that represents your problem. As you note in your question, this implicitly uses the Schrodinger equation <span class=""math-container"">$|\psi(t)\rangle = e^{-i H t} |\psi(0)\rangle$</span>. In the special case that <span class=""math-container"">$|\psi(0)\rangle$</span> is the ground state (say, as the result of an adiabatic preparation), then this gives you that <span class=""math-container"">$|\psi(t)\rangle = e^{-i E t} |\psi(0)\rangle$</span>; that is, a global phase about your initial state. Since global phases are unobservable, you can use the phase kickback trick (see Chapter 7 of my book once it's posted for more details) to make that global phase into a local phase. From there, as you vary <span class=""math-container"">$t$</span>, the ground state energy appears as a frequency that you can learn using phase estimation. Phase estimation itself comes in two broad flavors (there's a bit of a theme here...), namely quantum and iterative phase estimation. In the first case, you use extra qubits to read out the phase into a quantum register, which is very helpful if you want to do further quantum processing of that energy. In the second case, you use one additional qubit to do classical measurements with phase kickback, letting you reuse your copy of the ground state. At that point, learning <span class=""math-container"">$E$</span> from your classical measurements is a classical stats problem that you can solve in a number of different ways, such as with Kitaev's algorithm, maximum likelihood estimation, Bayesian inference, robust phase estimation, random walk phase estimation, or many others.</p>

<p>That then leaves the problem of how to evolve under <span class=""math-container"">$H$</span>. That's where techniques like TrotterâSuzuki come in. Using the TrotterâSuzuki decomposition, you break <span class=""math-container"">$H$</span> into a sum of terms that are each easy to simulate (that can be the same as the the decomposition you would use for VQE, but need not be), then rapidly switch between simulating each term. There's many other simulation algorithms out there, such as qubitization, but TrotterâSuzuki is a great place to start.</p>

<p>Given the plethora of different techniques, then, would you choose VQE over phase estimation or vice versa? That comes down to what kinds of quantum resources you want to use to solve your problem. At a very very high level, VQE tends to generate a very large number of quantum circuits that are each pretty shallow. By contrast, phase estimation uses quantum programs that dramatically reduce the amount of data you need by using coherent evolution (again roughly, this is the difference between Heisenberg-limited precision and the ""standard quantum limit,"" which is neither standard, quantum, nor a limit â but I digress). The downside is that phase estimation can use more qubits and deeper quantum programs. Understanding that trade-off is a large part of where tools like the trace simulator and resources estimator provided with the Quantum Development Kit come in. There's a lot out there, and being able to write up concrete implementations of each is now we can understand where each technique is most helpful.</p>
",9/13/2019 0:05,Conceptual,"The question seeks a conceptual understanding of different quantum computing methods and their applications, specifically focusing on VQE, Ising, and TrotterSuzuki methods for estimating ground state energy. It doesn't involve detailed theoretical or technical aspects but rather aims to clarify the conceptual differences and preferences among these methods in quantum software development.",Theoretical,"This question is related to the theoretical aspects of quantum computing, specifically the different methods for estimating the ground state energy of quantum systems, such as VQE, Ising, and TrotterSuzuki, and seeks to understand the similarities and differences between these methods.",No,82.0,Conceptual,"The user's question is focused on understanding the conceptual differences between various quantum computing methods for estimating ground state energy, without delving into deep theoretical or technical details. It seeks to clarify the conceptual distinctions and preferences among these methods in quantum software development."
8244.0,Big Endian vs. Little Endian in Qiskit,"<p>I've noticed that Q# favors Little Endian. Meaning that most operations are designed for this type of encoding. 
Is is it the same with Qiskit?</p>
",<programming><qiskit><q#>,09/12/2019 15:34,8370.0,8370.0,"<p>Qiskit uses little-endian for both classical bit ordering and qubit ordering.</p>
<p><em>For classical bits:</em></p>
<p>A 3-bit classical register <code>creg</code> with value <code>abc</code> has <code>creg[0]=c</code>, <code>creg[1]=b</code>, <code>creg[2]=a</code>.</p>
<p><em>For qubits:</em></p>
<p>The ordering is with respect to the tensor-product structure of the state space. So a 3-qubit quantum register <code>qreg</code> with wave-function <span class=""math-container"">$|\psi\rangle = |A\otimes B\otimes C\rangle = |ABC\rangle$</span> has <code>qreg[0]</code><span class=""math-container"">$= |C\rangle$</span>, <code>qreg[1]</code><span class=""math-container"">$= |B\rangle$</span>, <code>qreg[2]</code><span class=""math-container"">$= |A\rangle$</span>.</p>
<p>Similarly for representing unitary matrices of a circuit. <span class=""math-container"">$U = U_A \otimes U_B \otimes U_C = U_A U_B U_C$</span> would have <span class=""math-container"">$U_C$</span> acting on <code>qreg[0]</code>, <span class=""math-container"">$U_B$</span> acting on <code>qreg[1]</code> and <span class=""math-container"">$U_A$</span> acting on <code>qreg[2]</code>.</p>
",9/30/2019 17:40,API Usage,"The user question is primarily concerned with the behavior of the Qiskit API and how it handles endianness, making it more aligned with the category of API Usage. While there are conceptual and tooling aspects to the question, the API usage aspect is the central focus of the query.",API Usage,,,,API Usage,
8264.0,Question on using the Collect2qBlocks() and ConsolidateBlocks() optimizations,"<p>I'd like to run the optimizations from Qiskit's level 3 transpiler pass on some example programs for benchmarking, but when I try to include the Collect2qBlocks() and ConsolidateBlocks() passes I get an error. The code below is based on the example <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/transpiler/preset_passmanagers/level3.py"" rel=""nofollow noreferrer"">here</a>. </p>

<pre><code>from qiskit import QuantumCircuit
from qiskit.compiler import transpile
from qiskit.transpiler import PassManager
from qiskit.transpiler.passes import Unroller, Optimize1qGates, CommutativeCancellation, CXCancellation, Depth, FixedPoint, Collect2qBlocks, ConsolidateBlocks

circ = QuantumCircuit.from_qasm_file(""example.qasm"")

basis_gates = ['u1', 'u2', 'u3', 'cx']
_unroll = Unroller(basis_gates)
_depth_check = [Depth(), FixedPoint('depth')]
def _opt_control(property_set):
    return not property_set['depth_fixed_point']
_opt = [Collect2qBlocks(), ConsolidateBlocks(),
        Unroller(basis_gates),  # unroll unitaries
        Optimize1qGates(), CommutativeCancellation()]
pm = PassManager()
pm.append(_unroll)
pm.append(_depth_check + _opt, do_while=_opt_control)
circ = pm.run(circ)
print(circ.count_ops())
</code></pre>

<p>This seems to run fine if I exclude the Collect2qBlocks() and ConsolidateBlocks() passes, but when I include them I get the following error:</p>

<pre><code>Traceback (most recent call last):
  File ""test_qiskit.py"", line 19, in &lt;module&gt;
    circ = pm.run(circ)
  File ""/usr/local/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py"", line 146, in run
    dag = self._do_pass(pass_, dag, passset.options)
  File ""/usr/local/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py"", line 183, in _do_pass
    pass_.run(FencedDAGCircuit(dag))
  File ""/usr/local/lib/python3.7/site-packages/qiskit/transpiler/passes/collect_2q_blocks.py"", line 59, in run
    these_qubits = sorted(nd.qargs)
TypeError: '&lt;' not supported between instances of 'QuantumRegister' and 'QuantumRegister'
</code></pre>

<p>Am I invoking the methods incorrectly? I have the most recent version of Qiskit available on pip. Please let me know if you have any advice, thanks.</p>
",<programming><qiskit>,9/17/2019 1:12,8268.0,8268.0,"<p>Answering my question, as per the comments above. The solution was installing the latest version of qiskit. To get 0.12.0, I needed to 'pip uninstall' qiskit and then 'pip install' it again.</p>
",9/18/2019 12:58,Errors,The user is encountering an error while trying to run a quantum computing program using Qiskit. They are seeking help to understand and fix the error.,Errors,,,,Errors,
8269.0,Backend Warning: The skip Qobj validation does not work for IBMQ provider. Disable it,"<p>I am using QAOA to solve the max-cut problem. On my machine, 10 qubits already takes a minute or two to simulate. I'm hoping that the ibmq-qasm-simulator could simulate 32 qubits faster than my laptop would. Here's my code:</p>

<p>After loading in my IBMQ token and such...</p>



<pre><code>optimizer = COBYLA()
# Simulate using IBM's cloud service
backend = provider.get_backend('ibmq_qasm_simulator')
quantum_instance = QuantumInstance(backend, shots=1)

part_array = part.values
w = calc_w(part_array)  # Calculate pairwise distances between points

# Execute algorithm
qubit_ops, offset = max_cut.get_max_cut_qubitops(w)
qaoa = QAOA(qubit_ops, optimizer, p)
result = qaoa.run(quantum_instance)
</code></pre>

<p>While the code runs a message in red (like a warning but without ""Warning:"") displays saying, ""The skip Qobj validation does not work for IBMQ provider. Disable it."" How do I do what this message is asking?</p>
",<programming><qiskit><ibm-q-experience><qaoa>,9/19/2019 0:43,8271.0,8271.0,"<p>There is a parameter when instantiating a <code>QuantumInstance()</code> called <code>skip_qobj_validation</code>. This parameter is set to <code>True</code> by default. When creating the QuantumInstance, you can set it to False, and that will get rid of the warning.</p>

<pre><code>q_instance = QuantumInstace(skip_qobj_validation=False)
</code></pre>
",9/19/2019 14:14,Errors ,The user is encountering an error message while running a quantum computing program using Qiskits QAOA for the max-cut problem. They are seeking help to understand and resolve the warning message,Errors,,,,Errors ,
8280.0,"In Qiskit, when creating multi-bit quantum and classical registers, what is the ordering of MSB to LSB?","<p>When creating multi-bit quantum and classical registers, what is the ordering of MSB to LSB? For instance, I created a quantum register via</p>



<pre><code>import qiskit
qr = qiskit.QuantumRegister(2, name='qr')
</code></pre>

<p>Is <code>qr[1]</code> the MSB, or is it <code>qr[0]</code>?</p>

<p>For an example of why I'm asking, please review the following:</p>



<pre><code>import qiskit
qr = qiskit.QuantumRegister(2, name='qr')
cr = qiskit.ClassicalRegister(2, name='cr')
qc = qiskit.QuantumCircuit(qr, cr)

# Result should be Bell state (|00&gt;+|11&gt;)/sqrt(2)
qc.h(qreg[0])
qc.cx(qreg[0], qreg[1])

# Result should be state |00&gt;
qc.cx(qreg[0], qreg[1])
qc.h(qreg[0])

# Result should be state |10&gt;
qc.x(qreg[0])

qc.measure(qreg, creg)
qc.draw()
</code></pre>

<p><a href=""https://i.stack.imgur.com/lpr4o.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lpr4o.png"" alt=""quantum circuit""></a></p>

<p>At the end here I expect the quantum register to be in the state <code>|10&gt;</code>, but the histogram below shows the state <code>|01&gt;</code>. This indicates to me the MSB is the right-most bit, but I don't understand why the authors would do that. Is there some fundamental misunderstanding in my approach?</p>

<p>EDIT: Also the example is a bit convoluted--I initialized a Bell state because that's what the input to my circuit will be, but the same result happens with just the NOT gate on <code>qr[0]</code>.</p>

<p><a href=""https://i.stack.imgur.com/SMCwY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SMCwY.png"" alt=""enter image description here""></a></p>
",<programming><qiskit><quantum-state>,9/21/2019 3:01,8294.0,8294.0,"<p>Pulling from another question (<a href=""https://quantumcomputing.stackexchange.com/questions/8244/big-endian-vs-little-endian-in-qiskit"">Big Endian vs. Little Endian in Qiskit</a>) and their documentation (<a href=""https://qiskit.org/textbook/ch-appendix/qiskit.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-appendix/qiskit.html</a>), it appears that the register is intentionally labeled right-to-left so that integers are intuitively represented. Consider your example, where you applied X(qr[0]):</p>
<p><span class=""math-container"">$ |00\rangle \rightarrow |01\rangle $</span>, which is &quot;1&quot; as an integer. <span class=""math-container"">$1 = 2^0$</span></p>
<p>There example used X(qr[7]) on an 8 qubit register:</p>
<p><span class=""math-container"">$ |00000000\rangle \rightarrow |10000000\rangle = 32 = 2^7 $</span></p>
",9/23/2019 15:25,Conceptual,"The user is seeking an understanding of the ordering of qubits in quantum and classical registers in Qiskit. They are also trying to reconcile their circuit's results with their expected outcomes, indicating a conceptual query about the representation of qubits in the framework.",Conceptual,,,,Conceptual,
8290.0,Newbie Project: Calculate a Mersenne Prime with Quantum Computing,"<p>I am new to the quantum world and wondering the bounds of which the technology is at the current state of the art: specifically in computing prime numbers.</p>

<p>I would like to, if possible, create a project that seeks to find Mersenne prime numbers (see <a href=""https://www.mersenne.org/"" rel=""nofollow noreferrer"">here</a> and <a href=""https://en.wikipedia.org/wiki/Mersenne_prime"" rel=""nofollow noreferrer"">here</a> for more info).</p>

<p>I know there have been an <a href=""https://phys.org/news/2013-03-quantum-algorithm-prime.html"" rel=""nofollow noreferrer"">algorithm(s)</a> proposed for finding primes, but are there any actual languages I can make use of at the current state of the art? I have <a href=""https://www.rigetti.com"" rel=""nofollow noreferrer"">access</a> to a QPU/Lattices using the <a href=""http://docs.rigetti.com/en/stable/index.html"" rel=""nofollow noreferrer"">pyquil</a> language but haven't seen anything in the documentation that does this (at least in English I understand).</p>
",<algorithm><programming><rigetti><pyquil>,9/23/2019 8:07,8295.0,8295.0,"<p>It's likely that this algorithm hasn't yet been implemented in QISKit / Q# / pyquil etc. It's also important to note that you would not be discovering new Mersenne primes with a quantum computer - the <a href=""https://arxiv.org/pdf/1302.6245.pdf"" rel=""nofollow noreferrer"">paper referenced</a> says:</p>

<blockquote>
  <p>We propose a quantum circuit that creates a pure state corresponding to the quantum superposition of all prime numbers less than <span class=""math-container"">$2^n$</span>, where <span class=""math-container"">$n$</span> is the number of qubits of the register.</p>
</blockquote>

<p>Even with new quantum computers, this might only amount to <span class=""math-container"">$ 2^{73} $</span>, at best. And, there's no guarantee that these quantum computers will have the required coherence times. </p>

<p>This doesn't mean that it would be a waste to implement this algorithm - any contribution to a quantum programming language (QISKit / Q# / pyquil) is welcomed! But this algorithm won't be beating classical computers anytime soon.</p>
",9/23/2019 15:37,Learning,The user is new to quantum computing and is seeking information on how to use quantum computing to find Mersenne prime numbers. They are looking for learning resources and guidance on how to implement this in a specific quantum programming language (pyquil),Learning ,,,,Learning,
8299.0,Running jobs on different backends at the same time,"<pre><code>qr = QuantumRegister(2,'qr')
cr = ClassicalRegister(2,'cr')
circ = QuantumCircuit(qr,cr)

circ.x(qr[0])
circ.measure(qr,cr)

provider = IBMQ.get_provider(group = 'open')
backends = provider.get_backend(['ibmqx2', 'ibmq_16_melbourne', 'ibmq_vigo', 'ibmq_ourense'])
job = execute(circ, backend=backends, shots=1024) 
job_monitor(job, interval = 5)

result = job.result()
counts = result.get_counts(circ)
plot_histogram(counts)
</code></pre>

<p>How do I run my quantum code on more than one backend at the same time?</p>
",<programming><qiskit><ibm-q-experience>,9/23/2019 18:59,8307.0,8307.0,"<p>You would need to send a job to each backend you want to run on. For example, if you wanted to send to <code>ibmqx2</code> and <code>ibmq_ourense</code> you could execute code similar to this:</p>

<pre><code>backend_1 = provider.get_backend('ibmqx2')
backend_2 = provider.get_backend('ibmq_ourense')

job_1 = execute(circuit, backend_1)  # Sends a job to run on ibmqx2
job_2 = execute(circuit, backend_2)  # Sends a job to run on ibmq_ourense
</code></pre>

<p>You can then get the results from each job normally:</p>

<pre><code>result_1 = job_1.result().get_counts(circuit)
result_2 = job_2.result().get_counts(circuit)
</code></pre>
",9/24/2019 13:36,Tooling, The user is asking about how to use a specific tool (Qiskit) to run quantum code on multiple backends simultaneously. This involves understanding the practical aspects of working with quantum computing frameworks and tools.,API Usage,"This question pertains to the usage of the IBM Quantum API in Qiskit for running quantum circuits on different backends simultaneously, which falls under the API Usage category.",No,83.0,Tooling,"The user is seeking guidance on how to practically execute their quantum code on multiple backends simultaneously using Qiskit, a specific quantum computing framework, which aligns with the Tooling category."
8304.0,How to unpickle a Result object returned by an IBMQ experiment?,"<p>I have executed an experiment using IBMQ and receive a <code>Result</code> object.
I am writing the ASCII repr of the result with <code>f.write(res)</code> into a file and see a line like </p>

<pre><code>Result(backend_name='ibmq_16_melbourne', backend_version='1.1.0',...
</code></pre>

<p>How can I reconstruct the Result object from that line? Which methods do I have to call?</p>
",<programming><qiskit><ibm-q-experience>,9/24/2019 10:34,8306.0,8306.0,"<p>I found a solution:
to serialise instead of <code>print(res)</code> I need to do:</p>

<pre><code>print(res.to_dict())
</code></pre>

<p>To load the serialized string (eg. <code>line</code> from a file)</p>

<pre><code>dict = eval(line)
res = Result.from_dict(dict)
</code></pre>

<p>all of the above with</p>

<pre><code>from qiskit.result import Result
</code></pre>
",9/24/2019 12:51,Tooling ,The user is asking about how to use a specific tool (IBMQ) to reconstruct a Result object from its ASCII representation. This involves understanding the practical aspects of working with quantum computing frameworks and tools,Tooling,,,,Tooling ,
8308.0,How many classical registers are there on (IBM) quantum computers?,"<p>I have a circuit where I only use 3 qubits but need to utilize hundreds of classical registers. My questions are: what is the maximum number of classical bits on the current IBM Qs? What is the quantum computer with the highest number of classical bits right now that is available for researchers and the public?</p>
",<programming><qiskit><ibm-q-experience>,9/25/2019 5:59,8309.0,8309.0,"<p>As far as I am aware you can have as many <code>ClassicalRegister</code>s as you need, assuming they fit in the memory of the classical device controlling the Quantum Computer. I would suggest trying to reuse them if possible if you are concerned about this!</p>
",9/25/2019 7:18,API Usage,The user is seeking information about the maximum number of classical bits available on current IBM Q quantum computers and also inquiring about the quantum computer with the highest number of classical bits available to researchers and the public. This question pertains to the capabilities of quantum computing hardware and their usage through APIs,API Usage,,,,API Usage,
8388.0,How can classical computations be non-unitary?,"<p>Given that classical physics emerges from quantum physics on a macroscopic scale, and all quantum operators are unitary, how are we able to perform non-unitary operations (such as setting a register to zero) in classical computation?</p>

<p>I suspect that unitarity must be preserved because information leaks to the environment as heat. However if this is the case, it begs a second question, why can quantum computers not 'simply' leak information to the environment as a hack to allow non-unitary transformations?</p>
",<classical-computing><unitarity>,10/02/2019 22:17,8391.0,8391.0,"<p>Quantum computers <em>can</em> leak information to the environment in order to perform non-unitary transformations. The problem is that this irreversibly entangles the computer's state with the environment, i.e. it is equivalent to measuring the qubits that were leaked. This will collapse the state of the computer and prevent the interference effects that are needed if you want to do a quantum computation that's not secretly just a classical computation.</p>
",10/03/2019 05:30,Theoretical,"The user is asking about theoretical concepts in quantum computing, specifically about the unitarity of quantum operations and how non-unitary operations are possible in classical computation",Theoretical ,,,,Theoretical,
8412.0,ResetAll with adjoint auto,"<pre><code>operation Task12 (queryRegister : Qubit[], target : Qubit, pattern : Int[]) : Unit {

    body (...) {
        using (c = Qubit[Length(queryRegister)]) {

           ApplyToEachA(X, c);

            for (i in 0..Length(queryRegister) - 1) {

                if (pattern[i] == 0) {
                    CNOT(queryRegister[i], c[i]);
                } elif (pattern[i] == 1)  {
                    X(c[i]);
                    CNOT(queryRegister[i], c[i]);
                }
            }

            Controlled X(c, target);
            // ResetAll(c);
        }
    }

    adjoint auto;
}
</code></pre>

<p>I want to uncomment that ResetAll(c) line as I believe the right thing to do is to return the system the qubits in the same state as they were borrowed. But somehow the adjoint auto gives an error to the ResetAll(c) line. Will my code work just fine without the Reset line?</p>

<p><strong>Edit:</strong> </p>

<pre><code>operation Task12 (queryRegister : Qubit[], target : Qubit, pattern : Int[]) : Unit {

        body (...) {
            using (c = Qubit[Length(queryRegister)]) {

                within {

                    ApplyToEachA(X, c);

                    for (i in 0..Length(queryRegister) - 1) {

                        if (pattern[i] == 0) {
                            CNOT(queryRegister[i], c[i]);
                        } elif (pattern[i] == 1)  {
                            X(c[i]);
                            CNOT(queryRegister[i], c[i]);
                        }
                    }
                }

                apply {

                    Controlled X(c, target);
                }
            }
        }

        adjoint auto;
    }
</code></pre>

<p>Will this work? I don't have the driver file of this code, hence have to rely completely off the error detection of vscode. Thanks for help.</p>
",<programming><q#>,10/05/2019 01:10,8414.0,8414.0,"<p>Yes, removing the ResetAll will prevent your code from running. Q# assumes that released qubits are in the 00..0 state.</p>

<p>One option is uncomputation - essentially, applying the adjoint of the operations you've applied. For instance,</p>

<p><a href=""https://i.stack.imgur.com/9esGI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9esGI.png"" alt=""Uncomputation example""></a></p>

<p>The first two ancilla qubits are left unchanged by the last operation, but the last qubit has been modified and is dependent on <span class=""math-container"">$x_1, x_2, x_3 $</span>. In your case, you'd want to apply the adjoints of your operations in reverse order (<span class=""math-container"">$U_a U_b CX U_b^{\dagger} U_a^{\dagger}$</span>, where <span class=""math-container"">$U_a U_b$</span> are arbitrary unitaries and <span class=""math-container"">$CX$</span> is the CNOT gate).</p>

<p>Q# has <a href=""https://docs.microsoft.com/en-us/quantum/language/statements?view=qsharp-preview#conjugations"" rel=""nofollow noreferrer""><em>conjugation</em> functionality</a> that may be useful in your case! </p>
",10/05/2019 04:51, Errors,"The user is encountering an error in their quantum computing program written in Q#. They are seeking help to understand why the adjoint auto gives an error when the ResetAll© line is uncommented, and whether their code will work without the Reset line. ",Errors,,,, Errors,
8415.0,Unable to recognise little-endian format,"<p>I'm told that the input register is in little-endian format. But the vscode gives me error telling me that it is wrong argument for QFT even after using a suitable converter. Am I missing something here?</p>

<pre><code>    operation Task31 (qs : Qubit[]) : Unit {
        X(qs[Length(qs)-1]);
        ApplyReversedOpBE(QFT, qs);
    }
</code></pre>
",<q#><quantum-fourier-transform>,10/05/2019 08:08,8419.0,8419.0,"<p>You'll need to cast your qubit array as type <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arithmetic.littleendian?view=qsharp-preview"" rel=""nofollow noreferrer"">LittleEndian</a>:</p>

<pre><code>let LEArray = LittleEndian(qs);
</code></pre>

<p>A good example of this is in the QuantumKatas under <a href=""https://github.com/microsoft/QuantumKatas/blob/8621795b0d8e2005ff7037f814718669b84697e8/PhaseEstimation/ReferenceImplementation.qs#L81"" rel=""nofollow noreferrer"">Quantum Phase Estimation</a>. </p>
",10/05/2019 15:07,Errors,"This question falls under the ""Errors"" category because the user is encountering an error in their quantum program when applying the QFT (Quantum Fourier Transform) operation. They mention that they've already tried converting the input register to little-endian format but are still facing issues, indicating a problem related to programming errors or argument mismatch.", Errors,,,,Errors,
8505.0,How to prepare a specific initial state of three qubits?,"<p>I would like to prepare the following initial state for variational quantum algorithms:
<span class=""math-container"">$$
\sin\theta_1 \sin\theta_2 \sin\theta_3 |000\rangle + \sin\theta_1 \sin\theta_2 \cos\theta_3 |001\rangle + \sin\theta_1 \cos\theta_2 |010\rangle + \cos\theta_1 |100 \rangle.
$$</span></p>

<p>Should I make a circuit for this state from scratch?
Or is there any library to find a circuit to make this state such as Cirq or Qiskit? </p>
",<programming><qiskit><cirq>,10/17/2019 8:43,8509.0,8509.0,"<p>If you call initialize in this case, you will be specifying a general state in <span class=""math-container"">$\mathbb{C}^8$</span>. However what you have is more specialized. For example only having 4 nonzero amplitudes. So the call to initialize won't know this a priori. So it won't realize the initialization circuit can be decomposed easily. Or at least it will need to do some extra simplification steps before realizing this.</p>

<p>I'm going to change <span class=""math-container"">$\sin$</span> and <span class=""math-container"">$\cos$</span> from your state. You can fix this by changing the angles with appropriate angle redefinitions. <span class=""math-container"">$\theta \to \frac{\pi}{2}-\theta$</span>.</p>

<p><span class=""math-container"">$$
| \psi_1 \rangle = (\mathrm{R}(\theta_1) \otimes I_4) | 0 0 0 \rangle = \cos \theta_1 | 0 0 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\
| \psi_2 \rangle = (\mathrm{CR}(0,\theta_2) \otimes I_2) | \psi_1 \rangle = \cos \theta_1 \cos \theta_2 | 0 0 0 \rangle + \cos \theta_1 \sin \theta_2 | 0 1 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\
| \psi \rangle = \mathrm{CCR}(00,\theta_3) | \psi_2 \rangle
$$</span></p>

<p>where <span class=""math-container"">$\mathrm{R}(\theta)$</span> is to indicate a 2 by 2 rotation matrix.</p>

<p><span class=""math-container"">$\mathrm{CR}(0,\theta)$</span> is to indicate controlled <span class=""math-container"">$\mathrm{R}(\theta)$</span> on the second index but controlled on 0 instead of 1 on the first.</p>

<p><span class=""math-container"">$\mathrm{CCR}(00,\theta)$</span> is to indicate controlled <span class=""math-container"">$\mathrm{R}(\theta)$</span> on the third index but controlled on 00 instead of 11 on the first two.</p>

<p>You should be able to fix the angles and get the controls back to normal from here.</p>
",10/17/2019 15:18,Tooling,The user is asking about how to use a particular software or tool (Cirq or Qiskit) for quantum programming to prepare a specific initial state for variational quantum algorithms,Tooling,,,,Tooling,
8592.0,How to parallelly run a quantum circuit on IBMQ?,"<p>I am trying to implement the following circuit <a href=""https://i.stack.imgur.com/eWtAC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eWtAC.png"" alt=""enter image description here""></a></p>

<p>and my code is </p>

<p><a href=""https://i.stack.imgur.com/mxCpZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mxCpZ.png"" alt=""""></a></p>

<p>The above circuit has size 5 and depth 3. My question is, how can I run the circuit parallelly. I mean, the gate <code>circuit.cx(qr[0], qr[1])</code> and gate <code>circuit.cx(qr[2], qr[3])</code> will be run at the same time and the total running time is dominated by the depth.</p>

<p>I found a related question in <a href=""https://quantumcomputing.stackexchange.com/questions/6697/creating-and-running-parallel-circuits-in-qiskit"">Creating and running parallel circuits in Qiskit</a>. However, in that question, the author tries to run several independent experiments rather than run the gates in a circuit parallelly.</p>
",<programming><qiskit><ibm-q-experience>,10/28/2019 8:10,8596.0,8596.0,"<p>Qiskit implements a transpiler which optimizes the circuits that you provide. This means it modifies the circuit so that it can be run on the backend and also optimizes it so that anything that can possibly be run in parallel is done so. To run with the maximum level of optimization you can run <code>execute(circuit, optimization_level=3)</code>. There is more information about the transpiler <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/fundamentals/5_using_the_transpiler.ipynb"" rel=""noreferrer"">here</a>. </p>

<p>If you would like even finer control of when things are executed you can create a Pulse Schedule. There is more information about this <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/terra/5_pulse_schedules.ipynb"" rel=""noreferrer"">here</a>.</p>
",10/28/2019 12:04,Conceptual,"This question belongs to the ""Conceptual"" category because the user is seeking an understanding of how to run certain gates in a quantum circuit in parallel to reduce the circuit's depth. The question involves conceptualizing the parallel execution of gates within a quantum circuit, which is an important concept in quantum computing.",Conceptual,,,,Conceptual,
8679.0,The Elevator Problem,"<p>Today I(z) walked into an elevator and did not press the key to the floor to which I wanted to go.</p>

<p>As there were 2 other people x and y who had pressed the keys 2 and 3 respectively.</p>

<p>I wanted to go to the 2nd floor but nither x or y knew about it, so using a quantum computer or circuit how can x or y deduce whether I want to go to there floor or the probabilities of me going to 2nd or the 3rd floor.</p>

<p>Can we transform the question to ask what is the probability of z exiting on every floor, Please suggest?</p>
",<algorithm><quantum-state><programming>,11/05/2019 06:10,8680.0,8680.0,"<p>Any ""person"" (x or y) can obtain the state of z using the quantum circuit consisting of CNOT and Hadamard gates and <span class=""math-container"">$Z$</span> gate; the circuit is actually a simplified version of quantum teleportation; let x be in the state <span class=""math-container"">$|0\rangle$</span>, that is he wants to go to the floor 2 (state <span class=""math-container"">$|1\rangle$</span> means floor 3). Applying CNOT to z (control qubit) and x entangles z and x, and then you need to apply Hadamard gate to z and measure it.</p>

<p>If you measure <span class=""math-container"">$|1\rangle$</span>, x already contains the initial state of z; if you measure <span class=""math-container"">$|0\rangle$</span>, you need to apply <span class=""math-container"">$Z$</span> gate to x.</p>

<p>Either way in the end x contains the initial state of z while the state of z is destroyed by measurement.</p>

<p>For more details see <a href=""https://www.youtube.com/watch?v=X5NylvbqY44"" rel=""nofollow noreferrer"">Prof. Vazirani's lecture</a>.</p>
",11/05/2019 08:43,Conceptual,"This question falls under the ""Conceptual"" category because it seeks to understand the conceptual aspects of using quantum computing or circuits to deduce the probability of a person (z) exiting on a specific floor in the context of an elevator scenario. It involves discussing the potential application of quantum computing concepts to a real-world scenario and understanding the probabilistic nature of quantum computations.",Conceptual,,,,Conceptual,
8692.0,Can my MatLab code be used as a good simulator of a quantum computer?,"<p>I have tried to program <strong>universal quantum computer simulator</strong> in MatLab.
Please find a code here: </p>

<p><a href=""https://www.mathworks.com/matlabcentral/fileexchange/73035-quantum-computer-simulator"" rel=""nofollow noreferrer"">https://www.mathworks.com/matlabcentral/fileexchange/73035-quantum-computer-simulator</a></p>

<p>Can be this code used as a good simulator of quantum computer?
Thanks for answer.</p>
",<algorithm><programming><simulation><matlab>,11/06/2019 05:51,8713.0,8713.0,"<p>After using the simulator, I am very impressed!  From what I can tell, it has everything necessary to be universal.  I will likely be using this quite a bit.</p>

<p>To test drive it, I implemented a simple 3-qubit Fourier transform and applied it to a set of random initial states, then compared the result to the well known 3-qubit unitary DFT (<code>dft</code>) applied to the same set of states.  The code I ran is below, and the results agreed.</p>

<p>There are a few quirks, but they are relatively minor.  For example, several design constraints led me (for the sake of simplicity) to make the circuit ""upside down"" and invert the initial register tensor product rather than bit-swap at the end.</p>

<p>This made me interested in attempting to build out a simulation of Shor's algorithm based on this library.</p>

<pre><code>&gt;&gt; circ=fourier_3bit

circ = 

  3Ã6 string array

    ""I""    ""I""    "".""    ""I""    "".""    ""H""
    ""I""    "".""    """"     ""H""    ""S""    ""I""
    ""H""    ""S""    ""T""    ""I""    ""I""    ""I""

&gt;&gt; dft=fourier_3bit_mtx

dft =

   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i   0.3536 + 0.0000i
   0.3536 + 0.0000i   0.2500 + 0.2500i   0.0000 + 0.3536i  -0.2500 + 0.2500i  -0.3536 + 0.0000i  -0.2500 - 0.2500i   0.0000 - 0.3536i   0.2500 - 0.2500i
   0.3536 + 0.0000i   0.0000 + 0.3536i  -0.3536 + 0.0000i   0.0000 - 0.3536i   0.3536 + 0.0000i   0.0000 + 0.3536i  -0.3536 + 0.0000i   0.0000 - 0.3536i
   0.3536 + 0.0000i  -0.2500 + 0.2500i   0.0000 - 0.3536i   0.2500 + 0.2500i  -0.3536 + 0.0000i   0.2500 - 0.2500i   0.0000 + 0.3536i  -0.2500 - 0.2500i
   0.3536 + 0.0000i  -0.3536 + 0.0000i   0.3536 + 0.0000i  -0.3536 + 0.0000i   0.3536 + 0.0000i  -0.3536 + 0.0000i   0.3536 + 0.0000i  -0.3536 + 0.0000i
   0.3536 + 0.0000i  -0.2500 - 0.2500i   0.0000 + 0.3536i   0.2500 - 0.2500i  -0.3536 + 0.0000i   0.2500 + 0.2500i   0.0000 - 0.3536i  -0.2500 + 0.2500i
   0.3536 + 0.0000i   0.0000 - 0.3536i  -0.3536 + 0.0000i   0.0000 + 0.3536i   0.3536 + 0.0000i   0.0000 - 0.3536i  -0.3536 + 0.0000i   0.0000 + 0.3536i
   0.3536 + 0.0000i   0.2500 - 0.2500i   0.0000 - 0.3536i  -0.2500 - 0.2500i  -0.3536 + 0.0000i  -0.2500 + 0.2500i   0.0000 + 0.3536i   0.2500 + 0.2500i

&gt;&gt; regs=initializeRegisters(v1,v2,v3)

regs =

   0.0000 - 0.2804i
  -0.2349 + 0.0000i
   0.0000 + 0.5541i
   0.4643 + 0.0000i
   0.2029 + 0.0000i
   0.0000 - 0.1700i
  -0.4009 + 0.0000i
   0.0000 + 0.3359i

&gt;&gt; regs_rev=initializeRegisters(v3,v2,v1)

regs_rev =

   0.0000 - 0.2804i
   0.2029 + 0.0000i
   0.0000 + 0.5541i
  -0.4009 + 0.0000i
  -0.2349 + 0.0000i
   0.0000 - 0.1700i
   0.4643 + 0.0000i
   0.0000 + 0.3359i

&gt;&gt; dft*regs

ans =

   0.0111 + 0.1555i
  -0.4009 + 0.2265i
   0.3923 - 0.5422i
   0.3405 - 0.3100i
  -0.1511 + 0.0381i
  -0.1343 - 0.1412i
   0.0346 - 0.0478i
  -0.0921 - 0.1717i

&gt;&gt; quantumComputer(circ,[1 2 3],regs_rev)

ans =

   0.0111 + 0.1555i
  -0.4009 + 0.2265i
   0.3923 - 0.5422i
   0.3405 - 0.3100i
  -0.1511 + 0.0381i
  -0.1343 - 0.1412i
   0.0346 - 0.0478i
  -0.0921 - 0.1717i
</code></pre>

<p><a href=""https://i.stack.imgur.com/wg1bH.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wg1bH.jpg"" alt=""Probability Dist""></a></p>
",11/07/2019 22:59,Tooling,"This question falls under the ""Tooling"" category because the user is inquiring about the suitability of a specific tool (the MatLab-based universal quantum computer simulator) for simulating quantum computers. They are seeking feedback on whether this simulator can be considered a good choice for quantum computer simulation.",Tooling,,,,Tooling,
8702.0,What is the location of the Qiskit config file?,"<p>I'm trying to follow the instructions here <a href=""https://qiskit.org/documentation/getting_started.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/getting_started.html</a>. It says</p>

<blockquote>
  <p>The default backend for qiskit.visualization.circuit_drawer() or
  QuantumCircuit.draw() is the text backend. However, depending on your
  local environment you may want to change these defaults to something
  better suited for your use case. This is done with the user config
  file. By default the user config file should be located in
  ~/.qiskit/settings.conf and is a .ini file.</p>
</blockquote>

<p>I don't see this config file anywhere. Can anyone tell me how I can find the location of this file in order to make the change from the text based plotter to the nicer plotter? </p>
",<qiskit><programming>,11/06/2019 19:03,8704.0,8704.0,"<p>If you are working in Windows, the default location should be <code>C:\Users\[user]\.qiskit</code>, which might be hidden by default. Create a text file in that folder named <code>settings.conf</code> and set it up how you like.</p>

<p>For example by default</p>

<pre><code>from qiskit import *
qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)
qc.draw()
</code></pre>

<p>produces</p>

<p><a href=""https://i.stack.imgur.com/WDVnW.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/WDVnW.png"" alt=""text drawer circuit output""></a></p>

<p>With <code>settings.conf</code> in the folder referenced above, containing the two lines</p>

<pre><code>[default]
circuit_drawer=mpl
</code></pre>

<p>the same code produces</p>

<p><a href=""https://i.stack.imgur.com/4NcZS.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/4NcZS.png"" alt=""mpl drawer circuit output""></a></p>
",11/06/2019 19:57,Tooling,"The user is asking for help with a specific tool, Qiskit, and how to locate and modify a configuration file as part of its usage. ",Tooling,,,,Tooling,
8744.0,What is the time zone for the time returned by backend.properties()?,"<p>For example, backend.properties() returns following:</p>

<pre><code>{'last_update_date': '2019-11-11T07:16:13+00:00',
 'backend_name': 'ibmq_essex',
 'general': [],
 'qubits': ...
</code></pre>

<p>Is the above time UTC or local time(although in Essex it is the same value)?</p>
",<programming><qiskit>,11/12/2019 00:19,8747.0,8747.0,"<p>The time you are looking at there, <code>last_update_time</code>, shows when the properties dict was last updated, so you can see whether it is a recent dict or an older one. This is why you are getting the same value for multiple backends.</p>

<p>This time is set <a href=""https://github.com/Qiskit/qiskit-ibmq-provider/blob/4cd1bf1980e79efac4eef07fe6937334c497d7fc/qiskit/providers/ibmq/api/rest/backend.py#L61"" rel=""nofollow noreferrer"">here</a> and so it shows the local date and time with the UTC offset, +0:00 in this case. All the times returned for the different properties are in UTC.</p>
",11/12/2019 09:11,API Usage,"The user is asking about the output of a specific API function, backend.properties(), and how to interpret the last_update_date field in its response",API Usage,,,,API Usage,
8752.0,Trying to make irreversable operation in the quantum circuit,"<p>I want to make a 2 qubit circuit such that the non-unitary program will transform the regular basis in the way that:</p>

<p><span class=""math-container"">$|0 0\rangle \to |00\rangle$</span></p>

<p><span class=""math-container"">$|0 1\rangle \to |01\rangle$</span></p>

<p><span class=""math-container"">$|10\rangle \to |01\rangle$</span> (the only one that affected)</p>

<p><span class=""math-container"">$|11\rangle \to |11\rangle$</span></p>

<p>The only way I think of doing it, is after measuring the circuit I will change the classical outcomes so it will fit the transformation, for example in the classic way I would code:</p>

<pre><code>if c[0]==1 &amp; c[1]==0
       c[0]==0
       c[1]==1
</code></pre>

<p>but I didn<span class=""math-container"">`</span>t find a way to write it in Qiskit language, please help.</p>
",<quantum-gate><programming><qiskit><unitarity>,11/12/2019 16:44,8754.0,8754.0,"<p>I tried to implement your transformation on IBM Q. Here is the result:
<a href=""https://i.stack.imgur.com/7BbWF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7BbWF.png"" alt=""Circuit""></a></p>

<p>Input is <span class=""math-container"">$|00\rangle$</span> in this case. You can set input values by application of <span class=""math-container"">$X$</span> gates on q-bits <span class=""math-container"">$|q0\rangle$</span> and <span class=""math-container"">$|q1\rangle$</span>.</p>

<p>Please note that this circuit run on a simulator only as reset gate has not been implemented on real IBM Q quantum hardware. But it is possible to simply measure <span class=""math-container"">$|q2\rangle$</span> and <span class=""math-container"">$|q3\rangle$</span>. In that case your transformation become reversible.</p>
",11/12/2019 19:15,Conceptual,"This question belongs to the ""Conceptual"" category because the user is seeking guidance on how to create a 2-qubit quantum circuit that transforms the basis states as described. The question involves a conceptual understanding of quantum circuit design to achieve a specific transformation.",Tooling,"The question pertains to how to implement a specific transformation using Qiskit, which falls under the tooling category related to quantum programming software and tools.",No,84.0,Tooling,"The user is asking for assistance in implementing a specific transformation using Qiskit, which involves understanding how to use the Qiskit language to achieve the desired operation, aligning with the Tooling category."
8776.0,Quantum pricing of financial derivatives (call option) in Qiskit Aqua,"<p>In finance, a <strong>European call</strong> gives the buyer the right to buy some underlying asset such as a stock at some pre-determined strike price at a specific expiration date. The <strong>Black-Scholes equation</strong> is a fairly simple formula that can be easily written in Python for classical computing to value financial derivatives like the call option.</p>

<p>At the link below, IBM's cross-displinary quantum package for <strong>Python</strong>, <strong>Qiskit Aqua</strong>, seems to use qubits to price a European call option instead. Could someone give me a walk-through of what the code is doing line by line and how it compares to a classical Python code for pricing a European call? Are there any theoretical or numerical differences between classical and quantum pricing?</p>

<p><a href=""https://github.com/Qiskit/qiskit-aqua/blob/master/qiskit/finance/components/uncertainty_problems/european_call_expected_value.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/blob/master/qiskit/finance/components/uncertainty_problems/european_call_expected_value.py</a></p>

<p>Also, is there an article being used as the source for the above Python script? My guess is that it's this one, but not sure since I don't yet have a background in matching quantum code with quantum formulas: </p>

<p><em>""Towards Pricing Financial Derivatives with an IBM Quantum Computer""</em>
<a href=""https://arxiv.org/pdf/1904.05803.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1904.05803.pdf</a></p>
",<algorithm><programming><qiskit><quantum-computing-for-finance>,11/14/2019 22:16,8793.0,8793.0,"<p>There are tutorials for a lot of the Qiskit Aqua functions kept in the tutorials repository, and I think <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/4e76af1f26af57f3a1112318e5c611c52cf960de/qiskit/advanced/aqua/finance/simulation/european_call_option_pricing.ipynb"" rel=""nofollow noreferrer"">this</a> talks about the finance problem you are interested in. </p>

<p>All of these tutorials are also available on the <a href=""https://quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">IBM Q Experience</a> where you can run them in a browser.</p>
",11/15/2019 8:27,Learning ," The user is asking for learning resources and a detailed explanation of a specific quantum computing code for pricing a European call option, and how it compares to classical Python code for the same task. ", Learning ,,,,Learning ,
8778.0,Translating classical math and code to quantum math and code,"<p>I am starting to see a lot of classical quantitative problems such as linear regression being represented in quantum math, which suggests that almost anything based on frequentist statistics could be upgraded to the fancy 'braket' notation found in quantum math, in the same way that Bayesian interpretations of classical math models are currently abundant on the side line.</p>
<p>Ignoring the fact that anyone without a Masters in physics does not have the background to grasp or make a career out of quantum programming applied to their own discipline, at least what fundamental tenets, principles, and approaches, beyond just the qubit and circuitry theory, would help with the practical translation of existing classical math and Python code to their quantum counterparts? And is there a foreseeable demand in this sort of work, assuming that the quantumification of maths and code for some antiquated problem specific to some discipline at least generates a small speed-up over classical formulas and code?</p>
<p>Any holistic sources that discuss the impending migration from the classical to quantum paradigm math-wise would be great as well.</p>
",<programming><mathematics><classical-quantum>,11/14/2019 23:18,8782.0,8782.0,"<p>Bra-ket notation is not necessarily tied to ""quantum math,"" it's simply a convenient notation in many circumstances.  It may seem intimidating at first, but once you understand the basics (ket = vector, bra = covector) it's straightforward to grasp, as long as you have a solid understanding of Linear Algebra.  If you are shaky on Linear Algebra, different notation is unlikely to help.</p>

<p>Quantum algorithms on the other hand are entirely different.  These involve deep insights that may span several fields (particularly Math, CS and Physics), and I doubt that understanding them is easy for anybody (including physicists).  Anybody from one of these three fields will certainly have a head start, but anyone with a STEM background and sufficient motivation should be able to learn the material.  <a href=""https://rads.stackoverflow.com/amzn/click/com/1107002176"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Nielsen and Chuang</a> cite ""mathematical maturity"" as the key prerequisite.</p>

<p>Once the hardware is available to run meaningful quantum algorithms, I have no doubt that demand will vastly exceed supply of people capable of applying quantum algorithms to domain specific tasks.  There is, however, a fair amount of uncertainty as to when that day will come.</p>

<p>I don't really know any references that match your request well, but you might find John Preskill's keynote address on <a href=""https://arxiv.org/abs/1801.00862"" rel=""nofollow noreferrer"">NISQ era quantum computing</a> helpful.</p>
",11/15/2019 1:13,Conceptual," The question is asking about the fundamental tenets, principles, and approaches that would help with the practical translation of existing classical math and Python code to their quantum counterparts, as well as the foreseeable demand for this sort of work. This is a conceptual question because it is asking about the big-picture aspects of quantum computing, such as how to translate existing classical algorithms to quantum algorithms and what the potential benefits of doing so are.",Conceptual,,,,Conceptual,
8800.0,Problem in installing Qiskit,"<p>When I try to install Qiskit using Pip install Qiskit I get the error as shown in the attached snapshot.</p>

<p>Any help will be highly appreciated.</p>

<p><a href=""https://i.stack.imgur.com/LdpmD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LdpmD.png"" alt=""Qiskit install error""></a></p>
",<programming><qiskit>,11/15/2019 16:25,8801.0,8801.0,"<p>This issue is within the <code>pyscf</code> package that is required by qiskit. It says <a href=""https://sunqm.github.io/pyscf/install.html"" rel=""nofollow noreferrer"">here</a> that this error may occur with certain versions of python, and I have seen it commonly coming up with python 3.8. There are some workarounds in that link, but if you have nothing forcing you to use python 3.8, I would suggest downgrading to the next newest version before that. </p>

<p>I have been running on python 3.7.5 (which you should be able to install by simply specifying <code>python=3.7</code> when creating a new anaconda environment) and I do not see this error.</p>
",11/15/2019 18:45,Errors, The user is seeking solutions and explanations for errors and exceptions encountered while installing Qiskit using pip.,Errors ,,,,Errors,
8817.0,Are binary states (bits) pervasive in classical physics?,"<p>If </p>

<ol>
<li>quantum physics is a refinement of classical physics, and</li>
<li>quantum computing is a refinement of classical computing, and</li>
<li>classical computers use bits (binary digits) whereas quantum computers use qubits</li>
</ol>

<p>then are binary states (0,1) a significant and pervasive construct underpinning the theory of classical <em>physics</em> as opposed to quantum physics?</p>
",<classical-computing>,11/17/2019 12:01,8819.0,8819.0,"<ol>
<li><p>Quantum computing is <em>not</em> a refinement of classical computing; it's simply a different paradigm of computing aimed at solving specific categories of problems more efficiently. </p></li>
<li><p>Quantum computing doesn't necessarily require qubits (cf. <a href=""https://en.wikipedia.org/wiki/Qubit#Variations_of_the_qubit"" rel=""nofollow noreferrer"">qudit</a>); that's just a theoretical and experimental convenience. In fact, <a href=""https://en.wikipedia.org/wiki/Continuous-variable_quantum_information"" rel=""nofollow noreferrer"">continuous-variable quantum computing</a> seems to be a hot research area these days.</p></li>
<li><p>As for the broader question of whether the universe is 'discrete' or 'quantizable', you might find the concepts of <a href=""https://en.wikipedia.org/wiki/Digital_physics"" rel=""nofollow noreferrer"">digital physics</a> and <a href=""https://en.wikipedia.org/wiki/Bit-string_physics"" rel=""nofollow noreferrer"">bit string physics</a> interesting. </p></li>
</ol>
",11/17/2019 13:57,Conceptual,"This question falls under the ""Conceptual"" category because the user is seeking to understand the conceptual relationship between binary states (0 and 1) and classical physics as opposed to quantum physics. It involves exploring the foundational concepts underlying classical and quantum physics in relation to binary states.",Conceptual ,,,,Conceptual,
8836.0,How does one get the attributes of a circuit from its DAG in qiskit?,"<p>I have the following code, which runs properly.</p>

<pre><code>from qiskit import *
from qiskit.converters import *

ghz2 = QuantumCircuit(5, 5)
ghz2.h(2)
ghz2.cx(2, 1)
ghz2.cx(1, 0)
ghz2.cx(2, 3)
ghz2.cx(3, 4)


ghz_dag = circuit_to_dag(ghz2)
</code></pre>

<p>How do I access properties of this dag? For instance, I would like to get all the 2-qubit gates using the <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/transpiler/passes/collect_2q_blocks.py"" rel=""nofollow noreferrer"">collect 2qubit gates method</a> (the output is supposed to be a dictionary) or simply draw the DAG but again, dag_drawer(ghz_dag) throws up an error (<code>'MultiDiGraph' object has no attribute 'number_of_selfloops'</code>) even though, that's done in an example <a href=""https://medium.com/qiskit/terra-0-7-better-visualization-compilation-memorization-895b05b7197f"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Maybe this is just a Python usage question but how does one access the properties of the DAG? </p>
",<programming><qiskit>,11/18/2019 11:37,8838.0,8838.0,"<p>Properties of the DAG are simply accessed using dot notation. For example, if you would like to get all the two qubit gates you would do <code>dag.twoQ_gates()</code> which returns a list of the two qubit gates present in the dag.</p>

<p>The code you have linked to is a transpiler pass. This is a method that looks over the dag to identify some property or to perform some optimization. It stores variables to the property set, <code>self.property_set</code>. There is more information about using the transpiler <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/fundamentals/5_using_the_transpiler.ipynb"" rel=""nofollow noreferrer"">here</a>.</p>
",11/18/2019 14:23,API Usage,"The question is asking about how to access the properties of a Qiskit DAG object, specifically the collect_2q_blocks method and the dag_drawer. This is an API usage question because it is asking about how to use specific APIs in Qiskit to access properties of a DAG object.",Errors," The user is seeking solutions and explanations for errors they encountered while trying to access properties of a Directed Acyclic Graph (DAG) in their quantum program, which falls under the category of errors and exceptions in quantum program development",No,85.0,API Usage,"The user is seeking guidance on how to use specific methods and functionalities provided by the Qiskit API to access properties of a DAG object, aligning with the API Usage category."
8837.0,Which algorithm in quantum computing can be implemented for a HPC system?,"<p>I am new to quantum computing and I wanted to do a project for one of my classes where I study a specific algorithm from the field and then insert parallelism in it so it can be executed more efficiently on a cluster i.e., high-performance computing (HPC) system.</p>

<p>I would appreciate any suggestions which algorithm should I pursue to implement, as well as any resources available to study its background. Thanks in advance!</p>
",<algorithm><programming><quantum-parallelism>,11/18/2019 13:14,8915.0,8915.0,"<p>If I understand you correctly, your goal is:</p>

<ol>
<li><p>To choose some quantum algorithm (your question is: which algorithm would be good?)</p></li>
<li><p>Instead of running the quantum algorithm on a real quantum computer, you want to run a simulation of a quantum computer on a classical computer to simulate the execution of the quantum algorithm. </p></li>
<li><p>You want to optimize your classical simulator to make efficient use of the special capabilities offered by a High Performance Cluster (e.g. parallelism) and demonstrate that the simulation runs faster.</p></li>
</ol>

<p>If so, it really does not matter which quantum algorithm you choose, as long as it involves many qubits and many gates.</p>

<p>You are probably best off choosing some very well-known algorithm that is well described in the literature, e.g. Grover or Shor.</p>

<p>Your simulation will involve multiplying very large matrices with each other.</p>

<p>The more qubits, the larger the matrices. The growth is exponential: if you have <span class=""math-container"">$N$</span> qubits, you will be multiplying <span class=""math-container"">$2^N$</span> by <span class=""math-container"">$2^N$</span> matrices.</p>

<p>The more gates, the more multiplications.</p>

<p>You will make life easier on yourself if you assume the qubits are perfect (no noise, no errors).</p>

<p>Since the main point of your exercise is to parallelize some code for an HPC, it probably doesn't matter that the simulation is less realistic.</p>
",11/24/2019 7:49,Learning,The user is asking for learning resources and suggestions for a specific quantum computing algorithm to study and implement with parallelism for a class project.,Learning ,,,,Learning,
8844.0,ImportError: cannot import name 'matplotlib_circuit_drawer',"<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import matplotlib_circuit_drawer as drawer
from qiskit import Aer
from qiskit import execute
import numpy as np
%matplotlib inline
</code></pre>

<p>This is the code cell that I am trying to implement. The error is in the second line.</p>

<pre><code>Error--&gt; ImportError: cannot import name 'matplotlib_circuit_drawer'
</code></pre>

<p>I'm using Google Colab to execute the code. How to solve this?</p>
",<programming><qiskit>,11/19/2019 6:53,8845.0,8845.0,"<p><code>qiskit.tools.visualization</code> has been moved to <code>qiskit.visualization</code> and <code>matplotlib_circuit_drawer</code> has been removed. Instead of using it, try using <code>qiskit.visualization.circuit_drawer()</code> with the appropriate arguments. </p>

<p>So in this case it should be <code>qiskit.visualization.circuit_drawer(my_circuit, output='mpl', filename='my_circuit.png')</code></p>
",11/19/2019 7:23, Errors,"This question belongs to the ""Errors"" category because the user is encountering an ImportError while trying to execute a code cell in Google Colab. They are seeking a solution to resolve this import error related to the 'matplotlib_circuit_drawer' module, which involves troubleshooting and resolving a programming issue.",Errors,,,, Errors,
8849.0,"Quantum circuits explain algorithms, why didn't classical circuits?","<p>When explaining a <em>quantum</em> algorithm, many revert to 'circuit-speak' by drawing a diagram of how qubits split off into transformations and measurements, however, rarely if not never would someone explaining a <em>classical</em> math algorithm revert to its representation in binary circuits. I would understand that this is because transforms and such don't exist in the binary world, but:</p>

<p>Doesn't this unnecessary focus on the computational details relating to <em>computing</em>-computing, rather than the mathematical/statistical/optimization problem that the circuitry merely only underlies, detract from the main problem/application at hand? Is the classical mindset just that intuitive and aligned to general human thought, that quantum circuits, on the other hand, will remain to be a standard explanation strategy?</p>
",<algorithm><classical-computing>,11/19/2019 9:51,8851.0,8851.0,"<p>You might find this analogy helpful: the development of quantum algorithms is <em>still</em> in the <a href=""https://en.wikipedia.org/wiki/Booth&#39;s_multiplication_algorithm"" rel=""noreferrer"">Booth's multiplication algorithm</a> stage; we haven't quite reached <a href=""https://en.wikipedia.org/wiki/Dynamic_programming"" rel=""noreferrer"">dynamic programming</a> or <a href=""https://en.wikipedia.org/wiki/Backtracking"" rel=""noreferrer"">backtracking</a>. You'll find that most textbooks explain the Booth's algorithm using the following circuit. </p>

<p><a href=""https://i.stack.imgur.com/3cmLy.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3cmLy.jpg"" alt=""Multiplier circuit""></a></p>

<p>That <em>is</em> in fact, the method in which the multiplication logic is implemented in most modern processors (with some minor modifications depending on the version). However, this kind of representation quickly becomes tedious when you move to on algorithmic techniques like looping and recursion which may involve multiple multiplication and division steps, among others. It would be crazy for textbooks to explain more advanced algorithms using hardware-level implementations like this. Not to mention that the basic hardware circuitries vary with the processor. If you've ever done <a href=""https://en.wikipedia.org/wiki/Assembly_language"" rel=""noreferrer"">assembly language programming</a> this should resonate. </p>

<p>Classical algorithm textbooks like the <a href=""https://en.wikipedia.org/wiki/Introduction_to_Algorithms"" rel=""noreferrer"">CLRS</a> evade this problem by framing the algorithms without any particular processor in mind. The basic algorithmic procedures like addition, multiplication, looping, etc. are all considered as black boxes. If you're interested to see the processor-specific implementation of a CLRS algorithm you could certainly write it up in some high-level language like C and then <a href=""https://www.geeksforgeeks.org/convert-cc-code-to-assembly-language/"" rel=""noreferrer"">convert it to assembly</a>. Fortunately, compilers do that tedious conversion on our behalf! </p>

<p>Now the interesting part is that the basic building blocks of quantum algorithms are not addition or multiplication as such, but rather operations like <a href=""https://en.wikipedia.org/wiki/Quantum_Fourier_transform"" rel=""noreferrer"">Fourier transform</a> and <a href=""https://en.wikipedia.org/wiki/Amplitude_amplification"" rel=""noreferrer"">amplitude amplification</a>. Quantum algorithms are largely framed in terms of these basic transformations that are very easy to visualize using quantum circuits (at least, if we're using the gate model). It's really much more about convenience and much less about intuition. </p>

<p>Rest assured that if a textbook ever states a generalized quantum equivalent of the <a href=""https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"" rel=""noreferrer"">Dijkstra's algorithm</a> it wouldn't be showing you all the gates required to implement it, but rather in terms of the elementary quantum operations whose hardware implementations would largely vary depending on the quantum processor you're using.  The bottom line is that we're still in the assembly language stage of quantum computing. </p>
",11/19/2019 13:10,Conceptual,"The user is discussing the conceptual differences between explaining quantum and classical algorithms, questioning the focus on circuit representations in quantum computing explanations, and pondering whether this approach will remain standard. ", Conceptual,,,,Conceptual,
8882.0,Can't plot points on the Bloch sphere (QuTip),"<p>I have the really odd problem when it comes to plotting Bloch spheres using QuTip. Plotting state vectors works perfectly fine e.g.</p>

<pre><code>from qutip import *
import numpy as np
import matplotlib.pyplot as plt

b = Bloch()
s = Qobj([[1],[0]])
b.add_states(s)
b.show()    
</code></pre>

<p>But when I try to plot points on the Bloch sphere using QuTiP</p>

<pre><code>from qutip import *
import numpy as np
import matplotlib.pyplot as plt

b = Bloch()
pnt = [1,1,1]
b.add_points(pnt)
b.show()
</code></pre>

<p>I get the following error message</p>

<pre><code>Traceback (most recent call last):
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/matplotlib/backends/backend_macosx.py"", line 80, in _draw
    self.figure.draw(renderer)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper
    return draw(artist, renderer, *args, **kwargs)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/matplotlib/figure.py"", line 1709, in draw
    renderer, self, artists, self.suppressComposite)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/matplotlib/image.py"", line 135, in _draw_list_compositing_images
    a.draw(renderer)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/matplotlib/artist.py"", line 38, in draw_wrapper
    return draw(artist, renderer, *args, **kwargs)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/axes3d.py"", line 292, in draw
    reverse=True)):
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/axes3d.py"", line 291, in &lt;lambda&gt;
    key=lambda col: col.do_3d_projection(renderer),
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/art3d.py"", line 545, in do_3d_projection
    ecs = (_zalpha(self._edgecolor3d, vzs) if self._depthshade else
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/mpl_toolkits/mplot3d/art3d.py"", line 847, in _zalpha
    rgba = np.broadcast_to(mcolors.to_rgba_array(colors), (len(zs), 4))
  File ""&lt;__array_function__ internals&gt;"", line 6, in broadcast_to
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/numpy/lib/stride_tricks.py"", line 182, in broadcast_to
    return _broadcast_to(array, shape, subok=subok, readonly=True)
  File ""/Users/turbotanten/anaconda3/lib/python3.7/site-packages/numpy/lib/stride_tricks.py"", line 127, in _broadcast_to
    op_flags=['readonly'], itershape=shape, order='C')
ValueError: operands could not be broadcast together with remapped shapes [original-&gt;remapped]: (0,4) and requested shape (2,4)
</code></pre>

<p>I have tried using different matplotlib backends like TkAgg without any success. I don't know how to fix this problem.</p>
",<programming><qutip>,11/21/2019 9:13,8884.0,8884.0,"<p>I found a solution to my problem here <a href=""https://github.com/qutip/qutip/issues/1027"" rel=""nofollow noreferrer"">https://github.com/qutip/qutip/issues/1027</a></p>

<p>Apparently plotting points on the Bloch sphere does not work with Matplotlib v3.1.0.
So I had to downgrade to v.3.0.3 for it to work!</p>
",11/21/2019 10:56,Errors,"This question belongs to the ""Errors"" category because the user is encountering an error when trying to plot points on a Bloch sphere using QuTiP. The provided error message indicates a problem with the matplotlib backend and incompatible shapes, and the user is seeking help to resolve this issue, which involves troubleshooting and resolving a programming error related to plotting.",Errors ,,,,Errors,
8883.0,Moments-based quantum circuit in Cirq,"<p>In Cirq, quantum circuit consists of moments, which in turn consists of operations. This is different from Qiskit/OpenQASM, which doesnât have the concept of moments. What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it? </p>

<p>As a result of moments, one can insert operations in different moments using different insert strategies. It seems to me the earliest insert strategy is always preferred, which is the same as Qiskit/OpenQASM. What are the use cases for different insert strategies?</p>
",<programming><cirq>,11/21/2019 10:09,8891.0,8891.0,"<blockquote>
  <p>What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it?</p>
</blockquote>

<p>The basic idea is that we wanted to give users more control over what will actually happen on hardware. Whether or not two gates are run in parallel is really important information when dealing with noise (e.g. it determines total runtime), so it's important for users to be able to determine-whether that's happening and also control-if that's happening.</p>

<p>The philosophy of giving more control isn't limited to moments. Cirq also requires users to specify specific qubits (no implicit placement), and to use the native gateset of whatever device they are targeting (no implicit decomposition). The important thing is that you should be able to have a clear concrete idea of what will actually happen on the device.</p>

<p>Cirq also has the concept of a ""schedule"", which has even more control over timing. But ironically we've found that users don't want to use it, and programmers don't like consuming it. So we're actually cutting that next version.</p>

<p>The list-of-moments structure seems to be a nice sweet spot in terms of flexibility, ease of production, and ease of consumption. You can certainly put the abstraction boundary in other places, but that's where we've found ourselves pulled towards.</p>

<blockquote>
  <p>It seems to me the earliest insert strategy is always preferred</p>
</blockquote>

<p>It's a good rule of thumb, which is why it's the default. But it's not always optimal. For example, hardware may perform best when circuits are stratified into layers of single-qubit gates and layers of two-qubit gates (but never a layer with both single and two qubit gates). So even if you can move a single qubit operation earlier, that may result in it being in the same layer as two qubit operations. Moving it would not be a fatal mistake, the circuit would still run, but it might be slightly noisier. There are lots of ""little things"" like that when dealing with hardware.</p>
",11/21/2019 19:36,Conceptual,"The user is asking about the conceptual underpinnings of quantum circuits in Cirq, specifically the design philosophy behind the moment-based quantum circuit and the use cases for different insert strategies",Conceptual,,,,Conceptual,
8888.0,qiskit - Creating your own ExperimentResultData object,"<p>Could someone guide me on how to create my own <code>qiskit.result.models.ExperimentResultData</code> object? I would simply like to create an object with some self-created dict of counts.</p>

<p>Creating <code>qiskit.result.models.ExperimentalResults</code> object is somehow easy, since by calling it from <code>qiskit.result.models.ExperimentResults</code>, I simply pass the required attributes. But somehow I was not able to figure out how to do the same with <code>qiskit.result.models.ExperimentResultData</code>, which should be passed as ""data"" attribute to <code>qiskit.result.models.ExperimentalResults</code> object.</p>
",<programming><qiskit><ibm-q-experience>,11/21/2019 16:02,8890.0,8890.0,"<p>You should be able to do this by simply creating an instance of the class. This can be done as follows </p>

<pre><code>from qiskit.validation import base
raw_counts = {'0x0': 4, '0x2': 10}
data = models.ExperimentResultData(counts=base.Obj(**raw_counts))
</code></pre>

<p>There are lot of examples of how to do this in the <a href=""https://github.com/Qiskit/qiskit-terra/blob/0caab4a3ec1f8ced437be59d1e77657922771392/test/python/result/test_result.py"" rel=""nofollow noreferrer"">testing file</a> for these classes.</p>
",11/21/2019 16:59,API Usage,"This question falls under the ""API Usage"" category because the user is seeking guidance on how to create their own qiskit.result.models.ExperimentResultData object, which is part of the Qiskit API. They are looking for assistance in working with this specific API component to create an object with custom count data.",Errors ,"The user is seeking solutions and explanations for a problem they encountered while trying to create their own qiskit.result.models.ExperimentResultData object in their quantum program, which falls under the category of errors and exceptions in quantum program development",No,86.0,API Usage,"The user is seeking guidance on how to create a specific object from the Qiskit API, specifically the qiskit.result.models.ExperimentResultData object, aligning with the API Usage category."
8893.0,Why is the order reversed on measurement?,"<p>Why is the order reversed on measurement?</p>

<pre><code>from qiskit import(
  QuantumCircuit,
  execute,
  Aer)
from qiskit.visualization import plot_histogram

# Use Aer's qasm_simulator
simulator = Aer.get_backend('qasm_simulator')

# Create a Quantum Circuit acting on the q register
circuit = QuantumCircuit(3, 3)

# Add a X gate on qubit 0
circuit.x(0)

# Add a CX (CNOT) gate on control qubit 0 and target qubit 1
circuit.cx(0, 1)

circuit.barrier()
# Map the quantum measurement to the classical bits
circuit.measure([0,1,2], [0,1,2])

# Execute the circuit on the qasm simulator
job = execute(circuit, simulator, shots=1000)

# Grab results from the job
result = job.result()

# Returns counts
counts = result.get_counts(circuit)
print(""\nTotal count:"",counts)

# Draw the circuit
circuit.draw()
</code></pre>

<p>Got result:</p>

<blockquote>
  <p>Total count for 00 and 11 are: {'011': 1000}</p>
</blockquote>

<p>But I'm expecting '110'.</p>
",<quantum-gate><programming><qiskit>,11/21/2019 21:23,8894.0,8894.0,"<p>I still run into this issue too. If you consider <span class=""math-container"">$|q0\rangle$</span> to be the most significant bit (MSB) you have to map it to the most significant classical bit as well, which is in your case a bit no. 2. Or you can flip your quatnum circuit upside down and then <span class=""math-container"">$|q0\rangle$</span> become the least significant bit (LSB) and the measurement will meet your expectation.</p>

<p>A code</p>

<pre><code>circuit.measure([0,1,2], [0,1,2])
</code></pre>

<p>is valid in case <span class=""math-container"">$|q0\rangle$</span> is LSB and</p>

<pre><code>circuit.measure([0,1,2], [2,1,0])
</code></pre>

<p>in case <span class=""math-container"">$|q0\rangle$</span> is MSB.</p>

<p>I think that the reason for this arrangement is simply a convention, so you can choose whether <span class=""math-container"">$|q0\rangle$</span> is MSB or LSB and set the measurement procedure accordingly.</p>
",11/21/2019 22:39,Errors,"This question belongs to the ""Errors"" category because the user is encountering an unexpected result in their quantum circuit, and they are seeking an explanation for why the order of measurement outcomes is reversed from their expectation. They are experiencing an error in their quantum circuit and are looking for assistance in understanding and resolving it.",Errors,,,,Errors,
8898.0,What concepts from classical computing are vital for quantum programmers?,"<p>Many scientific programmers get by fine without having a computer science background, i.e. they don't need to know the machinery behind the prevailing paradigm of 0's and 1's (bits), let alone basic logic, to code. </p>

<p>Given this lack of awareness of <em>classical</em> computing's inner workings, what are stand-out concepts from classical computing that every aspiring <em>quantum</em> programmer should know?</p>
",<programming><classical-computing>,11/22/2019 1:27,9300.0,9300.0,"<p>I take your statement that programmers ""don't need to know the machinery behind the prevailing paradigm"" to mean that most scientific programmers need not know how a <span class=""math-container"">$\mathsf{NAND}$</span> gate is realized, with, say, a set of <span class=""math-container"">$6$</span> or so transistors.</p>

<p>However, probably a concept that is fundamental in quantum computing, that can be understood by anyone familiar with logical operations like <span class=""math-container"">$\mathsf{AND}$</span>, <span class=""math-container"">$\mathsf{OR}$</span>, etc. is that of <a href=""https://en.wikipedia.org/wiki/Reversible_computing"" rel=""nofollow noreferrer"">reversible computing</a>.  For example quantum computing logical gates <em>must</em> be reversible, and gates like <span class=""math-container"">$\mathsf{NAND}$</span> etc. are ruled out.  Information is lost in such gates.</p>

<p>However, gates like <span class=""math-container"">$\mathsf{XNOR}$</span> are still allowed in quantum computing (because they are reversible, and the input could be recovered.)</p>

<p>Because information cannot be erased in quantum circuits, it becomes difficult, though not impossible, to program recursive subroutines with reversible gates.  See e.g. this <a href=""https://www.quantamagazine.org/a-new-approach-to-multiplication-opens-the-door-to-better-quantum-computers-20190424/"" rel=""nofollow noreferrer"">Quanta article</a> on the problems of recursion in quantum computing, and the recent breakthrough of Gidney.</p>
",12/22/2019 23:55,Conceptual,"This question falls under the ""Conceptual"" category because the user is seeking an understanding of the fundamental concepts from classical computing that are essential for aspiring quantum programmers to know. It involves conceptual considerations related to the knowledge prerequisites for entering the field of quantum programming.",Conceptual,,,,Conceptual,
8935.0,How to draw Qiskit's HHL algorithm as a circuit?,"<p>Qiskit Aqua has a module that implements the HHL algorithm:</p>
<p><a href=""https://qiskit.org/documentation/stable/0.32/stubs/qiskit.aqua.algorithms.HHL.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.32/stubs/qiskit.aqua.algorithms.HHL.html</a></p>
<p>How does one draw the implemented circuit?</p>
<p>*** EDIT ***
I'm working with an example from the github.  I modified it as follows:</p>
<pre><code>#
# Example from 
# https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/aqua/linear_systems_of_equations.ipynb
#


from qiskit.aqua import run_algorithm
from qiskit.aqua.input import LinearSystemInput
from qiskit.quantum_info import state_fidelity
from qiskit.aqua.algorithms.classical import ExactLSsolver
import numpy as np


params = {
    'problem': {
        'name': 'linear_system'
    },
    'algorithm': {
        'name': 'HHL'
    },
    'eigs': {
        'expansion_mode': 'suzuki',
        'expansion_order': 2,
        'name': 'EigsQPE',
        'num_ancillae': 3,
        'num_time_slices': 50
    },
    'reciprocal': {
        'name': 'Lookup'
    },
    'backend': {
        'provider': 'qiskit.BasicAer',
        'name': 'statevector_simulator'
    }
}

# The 2 x 2 System to solve 
#


matrix = [[1, 0], [0, 2]]
vector = [1, 4]
params['input'] = {
    'name': 'LinearSystemInput',
    'matrix': matrix,
    'vector': vector
}


# Run the HHL Algorithm
result = run_algorithm(params)
</code></pre>
<p><code>result</code> is the following:</p>
<pre><code>{'probability_result': 0.024629684664855277,
 'output': array([0.46919178+0.00000000e+00j, 0.8830963 -6.70000184e-15j]),
 'solution': array([1.05859322-8.03148712e-15j, 1.99244701-3.02331663e-14j]),
 'matrix': array([[1, 0],
        [0, 2]]),
 'vector': array([1, 4]),
 'circuit_info': {'size': 28870,
  'depth': 28820,
  'width': 7,
  'qubits': 7,
  'bits': 0,
  'factors': 1,
  'operations': {'u3': 6011,
   'u1': 8021,
   'cx': 14066,
   'barrier': 700,
   'u2': 6,
   'cu3': 42,
   'x': 24}
  }
}
</code></pre>
<p>I tried the following</p>
<p><code>HHL.construct_circuit(result.circuit_info).draw()</code></p>
<p>but that resulted in</p>
<pre><code>---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-13-4cf1b322ed4c&gt; in &lt;module&gt;
----&gt; 1 HHL.construct_circuit(result.circuit_info).draw()

NameError: name 'HHL' is not defined
</code></pre>
<p>So it may very well be that I didn't import something or that I just don't understand the syntax for the HHL.</p>
<p>So how should I form the instructions to generate the circuit?   (I'm not very good at python so if this question is trivial, I do apologize.)   I checked the qiskit documentation but I couldn't understand it well.  It didn't give an explicit example so if there's something I need to learn to be able to do this, please let me know.  Thank you for your time.</p>
",<algorithm><programming><qiskit><hhl-algorithm>,11/25/2019 16:43,8938.0,8938.0,"<p>You can draw the circuit using <code>construct_circuit().draw()</code>.</p>

<p>In the tutorial you are talking about, if you scroll down to the 4x4 randomly generated section that uses <code>params5</code> you can run <code>print(hhl.construct_circuit())</code>, after the line <code>hhl = HHL.init_params(params5, algo_input)</code>.</p>

<p>This may take a little while to complete but it should eventually print out ASCII art of the circuit. Other drawing options can be configured using <code>.draw()</code>.</p>

<p>NB this isn't to say that you can't draw any of the other circuits, if you follow the way the HHL object is created in this section you can draw any of the configurations specified by the params. For example, you could draw the circuit you are creating using</p>

<pre><code>from qiskit.aqua.input import LinearSystemInput
from qiskit.aqua.algorithms.single_sample import HHL
algo_input = LinearSystemInput(matrix=matrix, vector=vector)
hhl = HHL.init_params(params, algo_input)
</code></pre>
",11/25/2019 19:12,Tooling,"This question falls under the ""Tooling"" category because the user is seeking guidance on how to draw the circuit implemented by the HHL (Harsha Hassabis Lloyd) algorithm in Qiskit Aqua. It involves understanding the tool or library-specific methods and functions to visualize the quantum circuit for this algorithm.",Tooling   ,,,,Tooling,
8958.0,How good is basic_device_noise_model() simulating the noise in the quantum computer?,"<p>Is there any paper or article about the performance of the noise model using <code>basic_device_noise_model()</code>? For example, like the noise model in the code below.</p>

<pre><code>device = IBMQ.get_backend('ibmq_16_melbourne')
properties = device.properties()
noise_model = noise.device.basic_device_noise_model(properties)
</code></pre>

<p>I used that model to test some short-depth circuits and the results are pretty good actually. But I do not think IBM provide any paper or similar thing in the documentation or tutorial about this part. I wonder how they valid their model.</p>
",<programming><qiskit><noise>,11/26/2019 19:32,8968.0,8968.0,"<p>There is no specific paper for this, though information on the model can be found in the Qiskit Aer API documentation and is based on the research of IBMQ quantum computing group. As examples you can read some of the following papers for more information about errors in IBMQ devices:</p>

<ul>
<li><a href=""https://arxiv.org/abs/1410.6419"" rel=""noreferrer"">arXiv:1410.6419</a> -- The Methods section at the end has a summary of gate calibration and readout error characterization</li>
<li><a href=""https://arxiv.org/abs/1603.04821"" rel=""noreferrer"">arXiv:1603.04821</a> -- Described types of errors which occur in the way IBMQ devices implement the CNOT gate</li>
</ul>

<h2>TL,DR</h2>

<p><em>This noise model is a greatly simplified approximate error model and you should not expect it to exactly reproduce errors from a real device.</em></p>

<p>This is because the model is derived from a very small set of parameters which are obtained from device calibration experiments. For example: For gates errors are derived from a single <code>gate_error</code> parameter along with the gate length and the <span class=""math-container"">$T_1$</span> and <span class=""math-container"">$T_2$</span> relaxation time constants for the qubits involved. General 1 and 2 qubit error maps are described by 4x4 matrix and 16x16 complex matrices (CPTP Choi-matrix), which require a lot more than the given parameters to specify in general. </p>

<h2>More details</h2>

<p>To summarize the documentation the basic noise model consists of:</p>

<ol>
<li>Single qubit readout errors</li>
<li>Single qubit gate errors on u1, u2, u3 gatese</li>
<li>Two-qubit gate errors on cx.</li>
</ol>

<p>I'll go into more detail below for each case</p>

<h3>Readout Errors</h3>

<p>Readout errors are based on two parameters:</p>

<ol>
<li>The probability of recording an outcome as 0 given it was actually 1</li>
<li>The probability of recording an outcome as 1 given it was actually 0</li>
</ol>

<p>This assumes readout error are not correlated between qubits for multi-qubit measurements. It also means that measure errors are purely classical (no back action on qubit state), which is accurate for the case where measurements occur at the end of a circuit (which they must currently for actual devices). In practice these errors are quite a good approximation for the readout errors of IBMQ devices.</p>

<h3>Gate errors</h3>

<p>The 1 and 2-qubit gate errors are derived from following parameters:</p>

<ol>
<li>The length of the specific gate</li>
<li>The <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span> relaxation time values for each qubit in the gate</li>
<li>A <code>gate_error</code> parameter obtained from 1 or 2-qubit randomized benchmarking</li>
</ol>

<p>The <code>gate_error</code> represents the overall error of the gate as is defined as <span class=""math-container"">$1 - F$</span> where <span class=""math-container"">$F$</span> is the average gate fidelity. </p>

<p>The gate error model assumes this error is described by an error channel <span class=""math-container"">$\cal{E} = \cal{E}_{\text{depol}} \circ \cal{E}_{\text{relax}}$</span> where <span class=""math-container"">$\cal{E}_{\text{depol}}$</span> is a n-qubit depolarizing-error channel and <span class=""math-container"">$\cal{E}_{\text{relax}}$</span> is a tensor product of 1-qubit thermal relaxation error channels on each qubit.</p>

<p>The main limitations/approximations of this model are:</p>

<ul>
<li>It approximates all non-relaxation gate errors as depolarizing errors (so there are no coherent errors)</li>
<li>Errors are only applied to gates, so it does not automatically include relaxation errors on idle qubits</li>
<li>It does not include any non-local errors such as cross-talk</li>
</ul>

<p>The thermal relaxation error channel used is very standard and a good model for relaxation errors during gates, so if gate error is completely due to <span class=""math-container"">$T_1$</span> relaxation (we call this <span class=""math-container"">$T_1$</span>-limited) the model is very good. If gate error is only partially due to to relaxation then it becomes much more approximate. </p>

<p>In practice this model is quite good for 1-qubit gate errors where error rates are quite low and close to being <span class=""math-container"">$T_1$</span>-limited, but it will not be for CNOT gates which are not <span class=""math-container"">$T_1$</span> limited. CNOT gates also tend to have higher levels of cross-talk errors which are not captured in this model. </p>

<p>Another limitation is if you circuit has a lot of idle qubits (qubits not participating in a gate during any point in time) it will underestimate <span class=""math-container"">$T_1$</span> relaxation errors unless you add idle (<code>""id""</code>) gates to those qubits. This is partially a limitation of thee quantum circuit format (since it has no notion of gate scheduling) and is something I hope to address in future updates to Qiskit Aer.</p>

<h3>References</h3>

<p>Sources: The Qiskit Aer API documentation and source code, and myself (I wrote the code in question).</p>
",11/27/2019 16:52,Learning,"The user is asking for learning resources, specifically any papers or articles, that discuss the performance and validation of the basic_device_noise_model() in Qiskit.",Learning,,,,Learning,
8966.0,How can I implement a kraus_error in qiskit?,"<p>I have successfully run <code>bit_flip_error</code> in Qiskit by function <code>pauli_error</code>, but I can not find how to implement a <code>kraus_error</code>.</p>

<p><code>pauli_error</code> works as follows: </p>

<pre><code>pauli_error([('X', p_reset), ('I', 1 - p_reset)])
</code></pre>

<p><code>kraus_error</code>?</p>
",<programming><qiskit><noise>,11/27/2019 14:17,8967.0,8967.0,"<p>I believe you can implement it a similar way you implemented the <code>pauli_error</code>, just with different parameter input. You need to pass in a <code>(list[matrix]): Kraus matrices</code>. The <code>kraus_error</code> method is defined <a href=""https://github.com/Qiskit/qiskit-aer/blob/stable/qiskit/providers/aer/noise/errors/standard_errors.py#L32"" rel=""nofollow noreferrer"">here</a>. You should be able to import it from the same module you import <code>pauli_error</code> from: <code>qiskit.providers.aer.noise.errors.standard_errors</code></p>
",11/27/2019 15:00,API Usage,"The question pertains to how to implement a kraus_error in Qiskit, specifically regarding the usage of the kraus_error function or method. It involves understanding the API usage for error modeling in quantum circuits.", API Usage,,,,API Usage,
9025.0,Understanding quantum teleportation algorithm from qiskit tutorials,"<p>I am very new to quantum computing and I have recently started to experiment with <code>qiskit</code> module in python, by following tutorials and implementing simple algorithms.</p>

<p>I constructed the quantum circuit described on this page: <a href=""https://community.qiskit.org/textbook/ch-algorithms/teleportation.html"" rel=""nofollow noreferrer"">Qiskit teleportation</a> And got same results that were expected:</p>

<p>my circuit:</p>

<p><a href=""https://i.stack.imgur.com/80KuB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/80KuB.png"" alt=""Teleportation""></a></p>

<p>my results:</p>

<p><a href=""https://i.stack.imgur.com/wRQbF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wRQbF.png"" alt=""results""></a></p>

<p>Which are apparently expected results, since </p>

<blockquote>
  <p>""we will always measure 0 from Bob's qubit because we started off with
  |0â©""</p>
</blockquote>

<p>However, if I apply NOT Gate at the start of q0, I still get the exact same results. Is my understanding of algorithm wrong? Shouldnt I be getting q2 as 1 after applying the NOT gate at start?</p>

<p>code:</p>

<pre><code>import qiskit as q
from qiskit.visualization import plot_histogram

circuit = q.QuantumCircuit(3, 3)

# entangle cubit 1 &amp; 2

circuit.h(1)

circuit.cx(1, 2)

# apply CNOT to qubit we want to send
circuit.cx(0, 1)

circuit.h(0)

circuit.measure([0,1], [0,1])

circuit.cx(1, 2)

circuit.cz(0, 2)

print(circuit)

backend = q.Aer.get_backend('qasm_simulator')
job = q.execute(circuit, backend, shots=1024)
result = job.result()

counts = result.get_counts(circuit)
plot_histogram(counts)
</code></pre>

<p>Outcomes when NOT gate is inserted at the start of q0:</p>

<p><a href=""https://i.stack.imgur.com/ik8QI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ik8QI.png"" alt=""enter image description here""></a></p>
",<algorithm><programming><qiskit><teleportation>,12/02/2019 11:16,9028.0,9028.0,"<p>Your circuit does not measure <span class=""math-container"">$q_2$</span> qubit after teleportation; I guess that is why teleportation of <span class=""math-container"">$|1\rangle$</span> qubit is shown incorrectly. </p>
",12/02/2019 12:44,Errors," The user is seeking solutions and explanations for an unexpected result they encountered while running the quantum teleportation algorithm in Qiskit, which falls under the category of errors ",Errors,,,,Errors,
9047.0,How to specify the CNOT gate direction (control qubit to target qubit) in Qiskit?,"<p>If I act a CNOT gate on quantum circuit:</p>



<pre><code>from qiskit import QuantumCircuit
qc = QuantumCircuit(2, 2)
qc.cx(0, 1)
</code></pre>

<p>it means that qubit_0 is the control qubit, and qubit_1 is the target qubit.
And if I switch 0 and 1, it means that qubit_1 is the control qubit, and qubit_0 is the target qubit.</p>

<p>But I remember that the CNOT gate is a one-direction gate, which means that one of the case would be the same as the other one but with some hadamard gates acting before and after it on the real device.</p>

<p>So, what I would like to ask is that:<br>
""How can I specify which is the one that would not act other gates when executing on the real device.""</p>

<p>I had also checked for the coupling_map:</p>



<pre><code>backend.configuration().coupling_map
</code></pre>

<p>and it returns both [0, 1] and [1, 0]</p>

<p>I'm not sure which is the one that won't act other hadamard gates, or is the real devices of IBMQ now support both kinds of CNOT operation?</p>

<p>Or, (I'm guessing) the smaller index would be the control qubit?</p>
",<programming><qiskit>,12/03/2019 09:03,9048.0,9048.0,"<p>What you are asking here is a valid question, but it does depend on what backend you are using. The CNOT gate, when implemented on real hardware, is generally only implementable in one direction betweem any two pair of qubits, especially for transmon qubits (i.e. the types of qubits IBM uses).</p>
<p>However, simulators and emulators generally do not hold this constraint. Moreover, general quantum computing on a higher abstraction level also benefits from being able to apply these entangling gates in both directions.</p>
<p>To this end, one can indeed reverse the direction of a CNOT gate by changing both qubits to the Hadamard basis before application of the CNOT gate, and back from the Hadamard basis to the computational basis after the application of the CNOT gate. It is a good exercise to assert this for yourself; a straightforward way to check this is by writing out the matrix multiplications that form this operation.</p>
<p>The coupling map that you have obtained does indicate that you have either used a simulator backend, or that you have used a physical backend where these bi-directional CNOT gates are possible. After checking the updated <a href=""https://quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">IBM Q website</a>, I just realized that there are now indeed physical backends that do posses these gates. They are indicated by bi-directional arrows between the qubits (i.e. circles) if you click on the backends to show the diagrams.</p>
",12/03/2019 10:13,Tooling ,The user is asking about the specifics of using the CNOT gate in the Qiskit library for quantum computing. They are trying to understand how to specify the control and target qubits when executing on a real device.,Tooling,,,,Tooling ,
9059.0,What can be done so far with cloud quantum computing?,"<p>As a developer myself, I still do not understand what can be done so far with services like <a href=""https://aws.amazon.com/about-aws/whats-new/2019/12/introducing-amazon-braket/"" rel=""nofollow noreferrer"">AWS BRAKET</a> or <a href=""https://www.ibm.com/quantum-computing/technology/experience"" rel=""nofollow noreferrer"">IBM CLOUD QUANTUM COMPUTING</a>.
Can someone explain me the practical purpose of it in the present? Or is it mostly a PR move to create hype?
Thank you</p>
",<programming><ibm-q-experience><superconducting-quantum-computing>,12/04/2019 09:24,9060.0,9060.0,"<p>They are resources to help people get started with learning about quantum computing. They are also useful to help further research as services such as IBM Q Experience provide access to real quantum computers, and so people can conduct research using them. </p>
",12/04/2019 10:01,Conceptual,The question is seeking a conceptual understanding of the practical applications and purposes of cloud quantum computing services like AWS Braket and IBM Cloud Quantum Computing. It involves understanding the real-world utility and use cases of these services.,Conceptual,,,,Conceptual,
9119.0,How can I transform a Result into a Bool in Q# + C# environment?,"<p>I'm writing a Q# program and I'm calling an operation defined in the program that outputs a <code>Result</code> (<code>One</code> or <code>Zero</code>).</p>

<p>For example something like this:</p>

<pre><code>output = QuantumOperation.Run(sim).Result;
</code></pre>

<p>I want to convert now <code>output</code> to a <code>bool</code> within C#, but I don't know how.</p>

<p>One way to go around this is to change the output of <code>QuantumOperation</code> to be a <code>bool</code> and transforming the result at the end of the operation with <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.convert.resultasbool?view=qsharp-preview"" rel=""nofollow noreferrer""><code>ResultAsBool(result)</code></a>. However, I want to maintain the output of the operation to be a <code>Result</code>. So ideally the conversion should happen within the C# host code.</p>
",<q#>,12/08/2019 19:50,9131.0,9131.0,"<p>Q# type <code>Result</code> is represented by C# class <code>Microsoft.Quantum.Simulation.Core.Result</code>; in particular, it has constants <code>Result.Zero</code> and <code>Result.One</code> that you can compare the return of your operation to.</p>

<pre><code>using Microsoft.Quantum.Simulation.Core;

boolOutput = (QuantumOperation.Run(sim).Result == Result.One);
</code></pre>
",12/09/2019 17:56,Tooling, The user is asking about a specific issue related to the usage of Q# and C# in quantum programming. They are trying to convert the output of a quantum operation from a Result to a bool within the C# host code,Tooling,,,,Tooling,
9190.0,Custom gates on IBM Q,"<p>I realized that QASM supports custom gates. However, when I tried to create the gate, transpiling error appeared both on simulator and real quantum processor. I suspect that IBM has not implemented this functionality fully yet.</p>

<p><strong>Does anybody (maybe from IBM) know when IBM will provide users with possibility to use custom gates?</strong></p>
",<quantum-gate><programming><ibm-q-experience>,12/13/2019 13:04,9193.0,9193.0,"<p>This is possible by using Composite Gates in Qiskit. With composite gates, you can create a circuit of gates, turn that circuit into an Instruction, and attach it to a new circuit which will perform the gates that were within your old circuit. Here is an example:</p>

<pre><code>from qiskit import QuantumCircuit

qc = QuantumCircuit(2, name='bell')
qc.h(0)
qc.cx(0, 1)
custom_gate = qc.to_instruction()

new_circ = QuantumCircuit(2)

# Append custom gate. The parameters are the Instruction you made, and the qubits you will use with it
new_circ.append(custom_gate, [0, 1])

print(new_circ)

'''
This is the output
        âââââââââ
q_0: |0&gt;â¤0      â
        â  bell â
q_1: |0&gt;â¤1      â
        âââââââââ
'''
</code></pre>

<p>The <code>to_instruction()</code> method from <code>QuantumCircuit</code> turns your circuit into an instruction which can then be appended to another circuit in the future. It appears as a single gate on the new circuit, which you can name to make it more organized. When the new circuit is executed, it will run this composite gate, which will make it run through the bell state code we set earlier.</p>

<p>For more information about composite gates, you can go to this <a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/terra/1_advanced_circuits.ipynb"" rel=""noreferrer"">tutorial</a> and scroll down to the ""Composite Gates"" section</p>
",12/13/2019 15:34, Tooling,"The user is asking about a specific feature (custom gates) in QASM, a tool used in quantum programming. They are seeking information about when IBM will fully implement this feature.",Tooling,,,, Tooling,
9195.0,AttributeError: 'Result' object has no attribute 'get_data',"<p>Below is the code that I am trying to execute on Google Colab using Qiskit.
I'll also paste the error that I am getting. </p>

<p><strong>Code</strong></p>



<pre><code>backend = Aer.get_backend('qasm_simulator')
# create Quantum Register called ""qr"" with 4 qubits
qr = QuantumRegister(4, name=""qr"")
# create Quantum Register called ""cr"" with 4 qubits
cr = ClassicalRegister(4, name=""cr"")
# Creating Quantum Circuit called ""qc"" involving your Quantum Register ""qr""
# and your Classical Register ""cr""
qc = QuantumCircuit(qr, cr, name=""solve_linear_sys"")        

# Initialize times that we get the result vector 
n0 = 0
n1 = 0

for i in range(10):
    #Set the input|b&gt; state""
    qc.x(qr[2])

    #Set the phase estimation circuit
    qc.h(qr[0])
    qc.h(qr[1]) 
    qc.u1(pi, qr[0])
    qc.u1(pi/2, qr[1])
    qc.cx(qr[1], qr[2])

    #The quantum inverse  Fourier transform 
    qc.h(qr[0])
    qc.cu1(-pi/2, qr[0], qr[1])
    qc.h(qr[1])

    #Rï¼lamda^-1ï¼ Rotation
    qc.x(qr[1])
    qc.cu3(pi/16, 0, 0, qr[0], qr[3])
    qc.cu3(pi/8, 0, 0, qr[1], qr[3])   

    #Uncomputation
    qc.x(qr[1])
    qc.h(qr[1])
    qc.cu1(pi/2, qr[0], qr[1])
    qc.h(qr[0])

    qc.cx(qr[1], qr[2])
    qc.u1(-pi/2, qr[1])
    qc.u1(-pi, qr[0])

    qc.h(qr[1]) 
    qc.h(qr[0])

    # To measure the whole quantum register
    qc.measure(qr[0], cr[0])
    qc.measure(qr[1], cr[1])
    qc.measure(qr[2], cr[2])
    qc.measure(qr[3], cr[3])

    job = execute(qc, backend=backend, shots=8192,)
    result = job.result()

    # Get the sum og all results
    n0 = n0 + result.get_data(""solve_linear_sys"")['counts']['1000']
    n1 = n1 + result.get_data(""solve_linear_sys"")['counts']['1100']

    # print the result
    print(result)
#     print(result.get_data(qc))
    plot_histogram(result.get_counts())


#     Reset the circuit
    qc.reset(qr)

    # calculate the scale of the elements in result vectot and print it.
    p = n0/n1
    print(n0)
    print(n1)
    print(p)
</code></pre>

<p><strong>Error</strong></p>

<pre><code>AttributeError                            Traceback (most recent call last)
&lt;ipython-input-15-0331fdb77f03&gt; in &lt;module&gt;()
     54 
     55     # Get the sum og all results
---&gt; 56     n0 = n0 + result.get_data(""solve_linear_sys"")['counts']['1000']
     57     n1 = n1 + result.get_data(""solve_linear_sys"")['counts']['1100']
     58 

AttributeError: 'Result' object has no attribute 'get_data'
</code></pre>

<p>Has the item get_data been removed?</p>
",<programming><qiskit>,12/13/2019 19:58,9196.0,9196.0,"<p>I believe <code>result.get_data()</code> was renamed to just <code>result.data()</code></p>

<p><a href=""https://github.com/Qiskit/qiskit-terra/blob/stable/0.11/qiskit/result/result.py#L57"" rel=""nofollow noreferrer"">Here</a> is the source code for the method</p>
",12/13/2019 20:52,Errors,"The user is encountering an error while executing a Qiskit program in Google Colab. They are seeking help to understand and resolve the AttributeError they received, which states that the Result object has no attribute get_data.",Errors,,,,Errors,
9282.0,What is the corresponding code for finding the state of a qubit on the Bloch sphere?,"<p>To find the state of a qubit on the <em>Bloch sphere</em> we use the following formula:</p>

<p><span class=""math-container"">\begin{equation}
|\psi\rangle=\mathrm{cos}\frac{\theta}{2}|0\rangle+\mathrm{e}^{i\phi}\mathrm{sin}\frac{\theta}{2}|1\rangle
\end{equation}</span>
Is there any built-in function/operation for that in Q#? If not, how to implement this formula in the Q# code? I'm interested in both preparing a qubit in this state given the two angles, and finding the angles given a qubit in some unknown state.</p>

<p>Thanks.</p>
",<quantum-gate><quantum-state><programming><q#><bloch-sphere>,12/21/2019 20:09,9298.0,9298.0,"<p><strong>Prepare a qubit in state <span class=""math-container"">$|\psi\rangle=\mathrm{cos}\frac{\theta}{2}|0\rangle+\mathrm{e}^{i\phi}\mathrm{sin}\frac{\theta}{2}|1\rangle$</span>, given the angles <span class=""math-container"">$\psi$</span> and <span class=""math-container"">$\theta$</span>.</strong></p>

<p>Let's start with a qubit in the <span class=""math-container"">$|0\rangle$</span> state, as is customary for Q#. </p>

<ul>
<li>You can use one of the general library operations to prepare the state, such as <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.preparation.preparearbitrarystate"" rel=""noreferrer"">PrepareArbitraryState</a>.</li>
<li>Or you can easily do it yourself using a sequence two gates:  

<ul>
<li><a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.ry"" rel=""noreferrer"">Ry(<span class=""math-container"">$\theta$</span>)</a> will transform the qubit from the <span class=""math-container"">$|0\rangle$</span> state to <span class=""math-container"">$|\psi\rangle=\cos\frac{\theta}{2}|0\rangle+\sin\frac{\theta}{2}|1\rangle$</span>,</li>
<li><a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1"" rel=""noreferrer"">R1(<span class=""math-container"">$\phi$</span>)</a> will further transform that state into the state you need.</li>
</ul></li>
</ul>

<hr>

<p><strong>Figure out the angles <span class=""math-container"">$\psi$</span> and <span class=""math-container"">$\theta$</span>, given a qubit in some unknown state.</strong></p>

<p>This is not possible to do in Q#, unless you're willing to do some hacks that will not work on a quantum device. Since real quantum systems don't allow you to peek into their state to get their exact coefficients, Q# doesn't allow you to do this on language level either. </p>

<p>However, if you're running a program on a full-state simulator, you can work around this and use <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpmachine"" rel=""noreferrer"">DumpMachine</a> function to output the qubit state and then analyze it. Here is an example of such output for state <span class=""math-container"">$|-i\rangle = \frac{1}{\sqrt2}|0\rangle - \frac{i}{\sqrt2}|1\rangle$</span>:</p>

<pre><code># wave function for qubits with ids (least to most significant): 0
â£0â­:     0.707107 +  0.000000 i  ==     ***********          [ 0.500000 ]     --- [  0.00000 rad ]
â£1â­:     0.000000 + -0.707107 i  ==     ***********          [ 0.500000 ]    â    [ -1.57080 rad ]
</code></pre>

<p>Given the complex amplitudes of the state, you can figure out <span class=""math-container"">$\psi$</span> and <span class=""math-container"">$\theta$</span>.</p>
",12/22/2019 19:39,API Usage,"The user is asking about how to use Q# to implement a specific quantum operation. They are seeking to understand if there is a built-in function in Q# for representing the state of a qubit on the Bloch sphere, and if not, how to implement this functionality.",API Usage,,,,API Usage,
9495.0,OPENQASM: How to include my own libraries,"<p>I studied the <code>OPENQASM 2.0</code> spec a few times but failed to find a way to include my own libraries. Have I missed anything?</p>

<p>Right now, the only way is to use <code>include ""qelib1.inc""</code> mechanism to separate the library from my own code. When the circuit starts to grow, there is a real need to group various components to different files. How can that be achieved without contaminating the <code>qelib1.inc</code>?</p>
",<programming><ibm-q-experience><qasm>,01/11/2020 23:10,9498.0,9498.0,"<p>According to the openqasm spec the include statement will insert the contents of the files with the name relative to the current working directory:</p>

<p><a href=""https://github.com/Qiskit/openqasm/blob/master/spec/qasm2.rst#language"" rel=""nofollow noreferrer"">https://github.com/Qiskit/openqasm/blob/master/spec/qasm2.rst#language</a></p>

<p>If you're using qiskit-terra as your parser this should work unless you name the local file ""qelib1.inc"". The parser included in the qiskit-terra parser uses the cwd unless the filename is present in the libs dir (the only current one being <code>qelib1.inc</code>: <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/qasm/qasmlexer.py#L131-L163"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/qasm/qasmlexer.py#L131-L163</a> If you're using openqasm with another parser that parser should implement the same behavior (for example see: <a href=""https://github.com/libtangle/qasm-rust/blob/master/src/lib.rs#L188-L244"" rel=""nofollow noreferrer"">https://github.com/libtangle/qasm-rust/blob/master/src/lib.rs#L188-L244</a> for how it's implemented in qasm-rust).</p>
",01/12/2020 11:53,Tooling ,"The user is asking about a specific feature (including libraries) in OPENQASM 2.0, a tool used in quantum programming. They are seeking to understand how to include their own libraries without contaminating the qelib1.inc",Tooling ,,,,Tooling ,
9522.0,Logical Explanation behind second reflection in Grover's algorithm,"<p>Logically, what does the second reflection in Grover's algorithm do? I currently don't have a lot of background in linear algebra so I'm failing to understand what exactly its purpose is and what it does.</p>
",<algorithm><programming><grovers-algorithm>,1/13/2020 18:40,9527.0,9527.0,"<p>An application of the reflection operator change each amplitude of a basis state <span class=""math-container"">$ |i\rangle$</span> by
<span class=""math-container"">$$ \alpha_i \rightarrow- \alpha_i + 2 \langle\alpha\rangle\ $$</span>
where <span class=""math-container"">$ \langle\alpha\rangle\ $</span> is the average of all amplitudes. 
It follows the oracle which is use to ""mark"" the seeked elements <span class=""math-container"">$ |i\rangle$</span>. </p>

<p>Say for instance that you have 8 elements, so you work on 3 qubits and you want to output <span class=""math-container"">$ |011\rangle$</span> with high probability. At the beginning, each basis state has <span class=""math-container"">$\frac{1}{8}$</span> probability to be measured as their amplitude are <span class=""math-container"">$\frac{1}{\sqrt{8}}$</span>.
The oracle first will mark <span class=""math-container"">$ |011\rangle$</span>, so its amplitude will be <span class=""math-container"">$-\frac{1}{\sqrt{8}} = -\frac{1}{2\sqrt{2}}$</span>.</p>

<p><span class=""math-container"">$$ \langle\alpha\rangle\ = \frac{1}{8} (7* \frac{1}{\sqrt{8}} - \frac{1}{\sqrt{8}}) = \frac{6}{8\sqrt{8}} = \frac{3}{8\sqrt{2}}$$</span></p>

<p>So the amplitude of <span class=""math-container"">$ |011\rangle$</span> after the reflection operator becomes 
<span class=""math-container"">$$ - (-\frac{1}{2\sqrt{2}}) + 2\langle\alpha\rangle\ = \frac{5}{4\sqrt{2}} $$</span>
while others will have a new amplitude:
<span class=""math-container"">$$ - (\frac{1}{2\sqrt{2}}) + 2*\frac{3}{8\sqrt{2}} = \frac{1}{4\sqrt{2}}$$</span></p>

<p>If you square those amplitudes, then <span class=""math-container"">$ |011\rangle$</span> has <span class=""math-container"">$\frac{25}{32} \approx 0.78 &gt; \frac{1}{8}$</span> probability to be measured, while another state will have <span class=""math-container"">$\frac{1}{32}$</span> probability to be measured. You see the probability of the solution to be outputed increased while non-solutions less likely to be.</p>
",1/13/2020 23:16,Conceptual,"The user is seeking an explanation of the purpose and function of the second reflection in Grover's algorithm. This question falls under the ""Conceptual"" category because it requires an understanding of the conceptual aspects of Grover's algorithm and its mathematical principles.",Theoretical,"The question seeks an understanding of the purpose and functionality of a specific component (the second reflection) within Grover's algorithm, which relates to the theoretical aspects of quantum computing and algorithms. It delves into the theoretical concept of Grover's algorithm and its operations.",No,87.0,Conceptual,"The user seeks an explanation of the purpose and function of a component in Grover's algorithm, requiring a conceptual understanding rather than a detailed theoretical explanation, which aligns with the Conceptual category."
9641.0,How is quantum error applied to the qubits?,"<p>I am trying to check the way qiskit has the noise implemented. I have read how is this theoretically done using quantum channels (see Nielsen and Chuang chapter 8) and I want to verify if qiskit follows the same procedure. I have started by the bit-flip error using the pauli_error function. Finally it creates a quantum error object which can be added to the NoiseModel object. However when adding this you have to use the add_all_qubit_quantum_error function and I do not really understand how this works. It is supposed to add the quantum error to all qubits when given a set of gates as an argument, as in the following example:</p>

<pre><code># Example error probabilities
p_reset = 0.03
p_meas = 0.1
p_gate1 = 0.05

# QuantumError objects
error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])
error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])
error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])
error_gate2 = error_gate1.tensor(error_gate1)

# Add errors to noise model
noise_bit_flip = NoiseModel()
noise_bit_flip.add_all_qubit_quantum_error(error_reset, ""reset"")
noise_bit_flip.add_all_qubit_quantum_error(error_meas, ""measure"")
noise_bit_flip.add_all_qubit_quantum_error(error_gate1, [""u1"", ""u2"", ""u3""])
noise_bit_flip.add_all_qubit_quantum_error(error_gate2, [""cx""])

print(noise_bit_flip)
</code></pre>

<p>However I do not know when the bit-flit is applied. Is it applied everytime one gate that can be decomposed in any of the ones of the list <code>[""u1"", ""u2"", ""u3""]</code>? What I need to know is how often it is applied and with which criterion.</p>

<p>Thank you for your help!</p>
",<qiskit><programming><noise>,1/25/2020 9:22,9653.0,9653.0,"<p>Qiskit simulator behaves like this for your code snippet: whenever it encounters one of u1, u2, or u3 gates (in the compiled circuit), it first applies the gate; then it performs an X gate according to the provided probability (0.05 in our case).</p>
",1/26/2020 9:05,Tooling,"The user is asking about the specifics of using the add_all_qubit_quantum_error function in the Qiskit library for quantum computing. They are trying to understand how this function works, specifically when and how often the bit-flip error is applied",Tooling,,,,Tooling,
9658.0,Controlled NOT gate using multiple control qubits in Q#,"<p>I am trying to implement the Grover's search algorithm using Q# and I am not able to implement the oracle (black box) part for the search of state <span class=""math-container"">$|1010\rangle$</span>. How to implement the controlled NOT gate using 5 qubits with 4 qubits (<code>q[0]</code> ... <code>q[3]</code>) used as the control qubits and <code>q[4]</code> as the target qubit in Q#?</p>

<p>Please correct me if this is wrong, I am trying to implement Grover's algorithm using 4 qubits where 3 qubits are for the states and the 4th qubit is the auxiliary qubit so the auxiliary bit should be the target qubit? </p>
",<quantum-gate><entanglement><grovers-algorithm><q#><oracles>,1/26/2020 15:46,9660.0,9660.0,"<p>You can implement a controlled version of any gate in Q# using <a href=""https://docs.microsoft.com/quantum/language/type-model#controlled"" rel=""nofollow noreferrer"">Controlled</a> functor; for the oracles, you'll use something like <code>Controlled X(controlQubits, targetQubit)</code>, where <code>controlQubits</code> is an array of qubits that have to be in 1 state for the X gate to be applied and <code>targetQubit</code> is the qubit to which the gate is applied.</p>

<p>Q# also has a neat library function <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.canon.controlledonbitstring"" rel=""nofollow noreferrer"">ControlledOnBitString</a> which allows to apply controlled version of the gate if the control qubits are in a state given by the bit string. So if you want to encode a specific state to use as control, like <span class=""math-container"">$|1010\rangle$</span> in your example, you can use </p>

<pre><code>(ControlledOnBitString([true, false, true, false], X))(controlQubits, targetQubit);
</code></pre>

<p>You can see examples of implementing Grover's search using Q# in the <a href=""https://github.com/microsoft/QuantumKatas/tree/master/GroversAlgorithm"" rel=""nofollow noreferrer"">GroverSearch kata</a> (task 1.2 is almost exactly your example of looking for a state 1010).</p>
",1/26/2020 18:57,Tooling, The user is asking about how to implement a specific part of Grovers algorithm using Q#. They are trying to understand how to use multiple qubits as control qubits for a controlled NOT gate in the context of implementing Grovers algorithm.,Tooling,,,,Tooling,
9663.0,"Strange Behaviour of MeSolve, McSolve","<p>I'm using Qutip to plot some basic two level dynamics using hamiltonians with a temporal envelope defined as the sum of two error functions, designed to make it more representative of experimental conditions.</p>

<p>I'm using the following code.</p>

<pre><code>import numpy as np
from qutip import * 
from scipy.special import erf
import matplotlib.pyplot as plt

def pulseEdge(x, x0, sigma):
    pulseEdge = ((erf((x-x0)/sigma)) +1.)/2.
    return pulseEdge

def pulse(t, tOn, tOff, sigma):
    return pulseEdge(t, tOn, sigma)* (1.-pulseEdge(t, tOff, sigma))

def H(t, args):
    H = Qobj([[0.,1],[1,0.0]])
    envelope = pulse(t, 2,2+np.pi/2,0.2)
    return H*envelope

tlist = np.linspace(0,10,1000)
h = np.array([H(t,0)[0][0] for t in tlist])
H_list = H

psi0 = basis(2,0)
basisStates = [basis(2,i) for i in range(2)]
e_ops = [b*b.dag() for b in basisStates]

me =mesolve(H_list, psi0, tlist,  progress_bar = None, e_ops = e_ops)

plt.plot(me.expect[0])
plt.plot(me.expect[1])

plt.plot(h)
plt.show()
</code></pre>

<p>Which works really well and produces the desired output, a <span class=""math-container"">$\pi$</span> Rabi oscillation driven by a <span class=""math-container"">$\pi$</span> pulse. The red is the envelope of the Rabi hamiltonian, and the orange and blue are the (expected) populations of the upper and lower states of a two level system undergoing a pi pulse. This is the expected behaviour.</p>

<p><a href=""https://i.stack.imgur.com/RuHmq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RuHmq.png"" alt=""enter image description here""></a></p>

<p>Except if I want the pulse one time unit later, when no evolution is driven. The code is exactly the same, except the hamiltonian function is modified to the following</p>

<pre><code>def H(t, args):
    H = Qobj([[0.,1],[1,0.0]])
    envelope = pulse(t, 3,3+np.pi/2,0.2)
    H*=envelope
    return H
</code></pre>

<p>which produces</p>

<p><a href=""https://i.stack.imgur.com/dKL4r.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dKL4r.png"" alt=""enter image description here""></a></p>

<p>Or if I want the edges to be sharper, when again, no evolution occurs</p>

<pre><code>def H(t, args):
    H = Qobj([[0.,1],[1,0.0]])
    envelope = pulse(t, 2,2+np.pi/2,0.01)
    H*=envelope
    return H
</code></pre>

<p><strong><a href=""https://i.stack.imgur.com/F7JG7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F7JG7.png"" alt=""strong text""></a></strong></p>

<p>What element of these time dependent Hamiltonians functions is causing mesolve to correctly calculate the dynamics in some cases, and completely fail in others?</p>

<p>The difference between the Hamiltonians in the above plots seems minor and arbitrary to me, and the rest of the code is identical between plots.</p>

<p><strong>EDIT</strong></p>

<p>After Paul Nation's answer, here is updated, working code.</p>

<pre><code>import numpy as np
from qutip import * 
from scipy.special import erf
import matplotlib.pyplot as plt

def pulseEdge(x, x0, sigma):
    pulseEdge = ((erf((x-x0)/sigma)) +1.)/2.
    return pulseEdge

def pulse(t, tOn, tOff, sigma):
    return pulseEdge(t, tOn, sigma)* (1.-pulseEdge(t, tOff, sigma))

def H(t, args):
    H = Qobj([[0.,1],[1,0.0]])
    envelope = pulse(t, 2,2+np.pi/2,0.01)
    H*=envelope
    return H

tlist = np.linspace(0,10,1000)
h = np.array([H(t,0)[0][0] for t in tlist])
H_list = H

psi0 = basis(2,0)
basisStates = [basis(2,i) for i in range(2)]
e_ops = [b*b.dag() for b in basisStates]

options = Options(max_step = 1)
me =mesolve(H_list, psi0, tlist,  progress_bar = None, e_ops = e_ops, options = options)

plt.plot(me.expect[0])
plt.plot(me.expect[1])

plt.plot(h)
plt.show()
</code></pre>

<p><a href=""https://i.stack.imgur.com/zBvsx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zBvsx.png"" alt=""enter image description here""></a></p>
",<programming><simulation><hamiltonian-simulation><qutip>,1/26/2020 23:52,9667.0,9667.0,"<p>So, this can happen when the ode solvers automatic step size solver thinks that nothing is going on and takes a big step over the pulse. There is a max_step option that you can set. In practice, setting this to something like half the width of the smallest pulse in a pulse sequence works quite well. Then the solver sees the pulses and adjusts accordingly. </p>
",1/27/2020 11:46,Errors ,The user is encountering an error while executing a Qutip program. They are seeking help to understand and resolve the issue related to the mesolve function missing rapid changes in the Hamiltonian.,Errors,,,,Errors ,
9672.0,Does the massive parallelization in Quantum computing imply parallelization of input (as opposed to Turing machine)?,"<p>Being a newbie in this field, I'm trying to understand what types of real-life workloads are suitable for migrating to Quantum computers.
Intuitively, it seems to me that if a Quantum computer ingests data by reading symbols one-by-one from a tape, exactly like a classical Turing machine, it would be impossible for it to outperform the Turing machine. It seems that optimization can be achieved only if a parallel method of ingesting the input is implemented.
Is this true? Does this mean that, if I want to migrate a workload to a Quantum computer for better performance, I should first try to parallelize it as much as possible?</p>

<p><em>I'd like to clarify my question with an example:</em></p>

<p>The classical <a href=""https://en.wikipedia.org/wiki/String-searching_algorithm"" rel=""nofollow noreferrer"">multiple string-match problem</a> - namely, ""Given a string-set <span class=""math-container"">$L \subseteq \Sigmaâ$</span> and an input stream <span class=""math-container"">$W \in \Sigmaâ$</span>, find all occurrences of any of the strings in <span class=""math-container"">$L$</span> that are substrings of <span class=""math-container"">$W$</span>"" - is considered a 'solved problem', where many algorithms solve it in <span class=""math-container"">$O(n)$</span>. However, almost all of these algorithms have a hidden constraint - they assume that the input is fed to them sequentially.</p>

<p>It is obvious that when a cell extracts information from its DNA strand, or when a person reads a newspaper, they do not read the 'symbols' from left to right, or in any strict order for that matter. Still, strict order is usually enforced both in DNA analysis algorithms and in text analysis algorithms.</p>

<p><strong>So my question is:</strong> do we need to come up with completely different quantum-based solutions for such problems, or is there a way to 'interpret' existing algorithms to the quantum domain and still expect some speedup?</p>

<p><em>Edit (and some thoughts):</em></p>

<p>Arguing that speedup requires handling parallelized input may lead to the following (pretty radical) conclusion: <strong>Order is overrated.</strong></p>

<p><em>Computer Science 101</em> is all about <code>for()</code> loops - maybe out of habit. Yet multithreading, hyperthreading, multicore, SIMD, DPDK, FPGA, and Quantum Computing, all considered major advancements, are all about parallelizing workloads and breaking the 'serial computing' paradigm. But at the moment we are stuck with cloud servers running endless loops and contributing to <strong><em>'Pollution-as-a-Service'</em></strong>.</p>

<p>The next generation of programmers should probably learn Parallel and Quantum Computing in <em>Computer Science 101</em>, and treat <code>for()</code> loops as a last resort...</p>
",<classical-computing><performance><quantum-parallelism><quantum-turing-machine>,1/28/2020 0:24,9674.0,9674.0,"<p>The reason that a quantum computer is faster in same tasks is given by different computational paradigm based on quantum mechanics laws. They mainly exploit superposition (i.e. state of qubit is linear combination of zero state and one state) and quantum entanglement (i.e. two or more qubits are connected and they behave as one system, or in other words there is some dependency among qubits values).  </p>

<p>It is not easy, or even impossible, to explain in plain words, hence mathematical proof for each task is needed to evaluate speed-up and decide wheter there is any.</p>

<p>Commnon misunderstanding is that quantum computers are based on paralelism and provide exponential speed-up always as they process all possible values in <span class=""math-container"">$n$</span> qubits (i.e. <span class=""math-container"">$2^n$</span> values) at once. This is not true. If it was, all tasks would record exponential speed-up but this is not the case. While some tasks are speeded up exponentially (i.e. Shor algorithm for integer factoring), for others the speed-up is quadratic (i.e. Grover algorithm for searching in database).</p>
",1/28/2020 5:51,Conceptual,"The user  is asking  about the broader implications of quantum computing for computer science, including the potential to revolutionize the way we think about and design algorithms. It also raises interesting questions about the role of order and sequentiality in computing",Conceptual,,,,Conceptual,
9684.0,How does qiskit finally implement a noise model?,"<p>I have been reading qiskit documentation for hours and I still don't get how does it implements noise in the circuit. I have understood that it works with a objects of the class QuantumError which finally gives a zip of the quantum instructions (quantum gates that can be applied to the circuit) and the probability of each instruction. Once we have this, how is it really applied to the circuit when we use the add_all_qubit_quantum_error to add the error to the noise model? What I want to do is to check if it is theoretically correct as for a quantum channel the most efficient form to apply this will be to use the Kraus representation:</p>
<p><span class=""math-container"">$$\mathcal E(\rho)=\sum_{k=1}^M E_k \rho E_k^\dagger.$$</span></p>
<p>For example for the bit-flip case the corresponding Kraus operators E_k will be:</p>
<p><a href=""https://i.stack.imgur.com/hVSyE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hVSyE.png"" alt=""enter image description here"" /></a></p>
<p>Therefore to add the quantum noise for the bit-flip case we will need to multiply the density matrix of our state by the Kraus operator and its hermitian conjugate as we can see in the Kraus representation of a quantum channel. However I don't understand how can this corresponds with what I have read in the documentation as finally the functions such as pauli_error and so on end up returning a QuantumError object which is finally written as a zip of instructions and probabilities which I guess are append to the circuit in someway. I have carefully read the source code of every noise function that is used to implement the different types of noise and I am not able to figure out whether it is the same as implementing the corresponding Kraus errors, I would be extremely grateful if someone could answer me.</p>
",<qiskit><programming><quantum-operation><noise><kraus-representation>,1/29/2020 7:32,9685.0,9685.0,"<p>A probability distribution over unitaries <span class=""math-container"">${(p_1, U_1),..., (p_k, U_K)}$</span>, where you select <span class=""math-container"">$U_i$</span> with probability <span class=""math-container"">$p_i$</span>, is equivalent to Kraus operators <span class=""math-container"">$\sqrt{p_1}U_1,..., \sqrt{p_k}U_k$</span>. For example, the bit flip error can be implemented by randomly deciding whether to leave the state unchanged (with probability <span class=""math-container"">$p$</span>) or apply an <span class=""math-container"">$X$</span> gate (with probability <span class=""math-container"">$1-p$</span>). With an infinite number of shots, where each shot randomizes independently from the other shots, all measurement statistics will converge to those obtained from the density matrix.</p>
",1/29/2020 8:57,Theoretical,"The user is seeking a theoretical understanding of how Qiskit implements noise in quantum circuits, particularly with respect to the application of quantum errors and the relationship between QuantumError objects, quantum gates, and probabilities. The question involves a detailed exploration of the theoretical aspects of noise modeling in quantum computing.",Theoretical,,,,Theoretical,
9729.0,Does quantum computing already possess the level of abstraction to be explicable even without knowledge of physics?,"<p>Currently, quantum computer science (in contrast to classical computer science) can mostly only be understood if one has a good inside knowledge of physics, or more precisely quantum physics. Only then one can really understand the explanations of superposition, coherence, entanglement, etc. in relation to Qubits. I felt the same way and had to take the extra physics course, in order to really get into Quantum Computing.</p>

<p>However, I heard more and more that it is ""theoretically"" possible to abstract quantum computer science to such a degree, that knowledge in physics is no longer required. Is there any truth to this or is it just way too conceptual so far?</p>

<p>(And yes, I am aware that this question might be more related to didactics rather than on-topic with this board. But I wasn't quite sure if I should've posted it on StackOverflow. So, forgive my error, given I've done one)</p>
",<programming><quantum-state><entanglement><classical-computing>,02/03/2020 16:01,9733.0,9733.0,"<p>I don't think you need to know quantum physics to understand quantum computing - similarly to how you don't think about the hardware implementation of the classical computers when you write high-level code for them. </p>

<p>The field of quantum computing has grown to the point where one cannot really teach all of it in one course, so different approaches to teaching emerge. Some courses indeed start with quantum mechanics, introducing qubits as particles and operations as physical processes on them. Others choose to abstract the physics away and to discuss the quantum computing algorithms in mathematical terms - representing states as vectors, operators as matrices and so on. Examples include: </p>

<ul>
<li><a href=""https://www.scottaaronson.com/blog/?p=3943"" rel=""noreferrer"">""Introduction to Quantum Information Science""</a> course by Scott Aaronson</li>
<li><a href=""http://cleve.iqc.uwaterloo.ca/qic710.html"" rel=""noreferrer"">""Introduction to Quantum Information Processing""</a> by Richard Cleve</li>
<li><a href=""https://people.eecs.berkeley.edu/~vazirani/quantum.html"" rel=""noreferrer"">""Quantum Computation""</a> course by Umesh Vazirani (which mentions physics now and then but more as an illustration)</li>
<li>Our group took a similar approach when we taught a class ""Introduction to Quantum Computing and Quantum Programming in Q#"" last year.</li>
</ul>

<p>There is plenty of material to cover even without diving deep into physics, and there are lots of programming languages that allow the learner to focus on studying and implementing the high-level algorithms instead.</p>
",02/03/2020 19:17,Conceptual,The question is asking about the conceptual possibility of abstracting quantum computer science to a degree where knowledge of physics is no longer required. It delves into the conceptual aspects of quantum computing and its accessibility to individuals without a strong physics background.,Conceptual,,,,Conceptual,
9748.0,How to encode eigenvalues of matrix $A$ in solving $A\vec{x} = \vec{b}$ using the HHL Algorithm,"<p>I am trying to implement multiple parallel subroutines of HHL algorithm, each working on a different set of matrix <span class=""math-container"">$A$</span> (when solving for <span class=""math-container"">$x$</span>, in <span class=""math-container"">$A\vec{x} = \vec{b}$</span>), to find the expectation values of <span class=""math-container"">$|x\rangle$</span>. The matrix <span class=""math-container"">$A$</span> is randomly generated Hermitian matrix, and may/may not be sparse (checking what happens, is also something I'm wondering). </p>

<p><strong>I have the following queries:</strong></p>

<ol>
<li>If I understand correctly, I need to encode eigenvalues of a <span class=""math-container"">$2 \times 2$</span> matrix <span class=""math-container"">$A$</span>, say <span class=""math-container"">$\lambda_1$</span> and <span class=""math-container"">$\lambda_2$</span> in the quantum register. Is that right? How do I do that? </li>
<li>Is the quantum register initialized with the binary values of <span class=""math-container"">$\lambda_1$</span> and <span class=""math-container"">$\lambda_2$</span>? Does that mean 2 runs of HHL? Is finding Eigenvalues of matrix <span class=""math-container"">$A$</span> supposed to be a classical subroutine?</li>
</ol>
",<algorithm><programming><hhl-algorithm>,02/06/2020 04:02,9757.0,9757.0,"<p>Finding the eigenvalues of <span class=""math-container"">$A$</span> is an intermediate part of the HHL algorithm (although it will not output them). It is a quantum routine known as phase estimation, for which you need to be able to implement a controlled-unitary evolution where the unitary is determined by <span class=""math-container"">$U=e^{iAt}$</span> for some <span class=""math-container"">$t$</span>. You do not need to find them by any classical routine. However, you do need some prior information: a bound on the range that the eigenvalues can occupy (this determines the <span class=""math-container"">$t$</span> in the previous relation), and a bound on how close to zero these eigenvalues might be (this determines how large a register you need for performing the phase estimation).</p>
",02/06/2020 12:29,Theoretical," The question is asking about the theoretical underpinnings of the HHL algorithm, specifically how to encode eigenvalues of a 2x2 matrix A in the quantum register. This is a theoretical question because it requires knowledge of the fundamental principles of the HHL algorithm and quantum computing.",Theoretical,,,,Theoretical,
9931.0,Can we add two classical registers in IBM Quantum Experience?,"<p>Suppose I have 01 and 11 in classical register 1 and 2 respectively in IBM quantum experience circuit. I want 01 + 11 = 00 mod 4. Can it be done?</p>
",<programming><circuit-construction><ibm-q-experience>,2/21/2020 4:40,9934.0,9934.0,"<p>You can add two qubits firstly in quantum registers and then measure qubit with results and put it to classical register.</p>

<p>Adding two qubits modulo 4 can be do with this circuit:</p>

<p><a href=""https://i.stack.imgur.com/a4NVE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a4NVE.png"" alt=""Circuit""></a></p>

<p>First <span class=""math-container"">$CNOT$</span> is fan-out and make a ""copy"" of qubit <span class=""math-container"">$q_0$</span> to <span class=""math-container"">$q_2$</span>, second <span class=""math-container"">$CNOT$</span> realizes XOR function between <span class=""math-container"">$q_1$</span> and <span class=""math-container"">$q_2$</span>. Eventually you have <span class=""math-container"">$(q_0 + q_1) \mod 4$</span> in <span class=""math-container"">$q_2$</span></p>

<hr>

<p><strong>EDIT:</strong> Expanded for two qubits adder modulo 4, based on comment by Adam <em>Levine</em>:</p>

<p>Here is a code implementing a modulo 4 adder for two qubits:</p>

<pre><code>OPENQASM 2.0;
include ""qelib1.inc"";

qreg q[6];
creg c[6];

//first input q[0]q[1]
//second input q[2]q[3]
//output q[4]q[5]

//input
//q[0]q[1] = 01
id q[0];
x q[1];
//q[2]q[3] = 11
x q[2];
x q[3];

//first qubit:
//q[1] + q[3] - sum
cx q[1],q[5];
cx q[3],q[5];
//q[1], q[3] - carry
ccx q[1], q[3], q[4];

//second qubit:
//q[0] + q[2] - sum
cx q[0],q[4];
cx q[2],q[4];
//no carry, modulo 4 sum
</code></pre>

<p><span class=""math-container"">$I$</span> and <span class=""math-container"">$X$</span> gates set an input (<em>based on the comment</em>), <span class=""math-container"">$CNOT$</span> gates acting on qubit <span class=""math-container"">$q_5$</span> return sum of last (<em>lower</em>) qubits of input numbers. Toffoli gate is used for calculation of carry form last qubits and next two <span class=""math-container"">$CNOT$</span> gates add together the carry and first (<em>higher</em>) qubits of input numbers. Carry from this sum is not performed as the adder is modulo 4. The result is in qubits <span class=""math-container"">$q_4$</span> and <span class=""math-container"">$q_5$</span> where higher qubit is <span class=""math-container"">$q_4$</span> and lower <span class=""math-container"">$q_5$</span>.</p>

<p><em>Note: this is based on classical approach how to construct an adder. There is also quantum approach based on quantum Fourier transform. See details here: <a href=""https://arxiv.org/abs/quant-ph/0008033"" rel=""nofollow noreferrer"">Addition on a Quantum Computer</a></em></p>
",2/21/2020 7:01,Tooling ,"The user is asking about a specific feature in the IBM Quantum Experience circuit, specifically how to perform a modulo operation on classical registers. They are trying to understand if its possible to add two classical registers and get the result modulo 4.",Conceptual,"The question pertains to a conceptual understanding of quantum computing and its capabilities in performing operations on classical registers. It asks whether a specific mathematical operation can be achieved using quantum computation, indicating a need for conceptual insight rather than technical implementation.",No,88.0,Tooling,"The user is inquiring about a specific feature within the IBM Quantum Experience circuit, seeking to understand if a particular operation can be performed on classical registers, which aligns with the Tooling category focused on practical aspects of quantum computing tools and platforms."
9943.0,How to make circuit for randomly selected gate?,"<p>I am trying to make a circuit for the randomly selected gates from a <code>gate_list</code> but I don't know how to put these selected gates in front of <code>qr.</code> statement. I don't know how to do this exactly is there any batter way to do this?</p>

<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import Aer, execute
import random

n = 8
gate_list = ['u1', 'u2', 'u3', 'id', 'x', 'y', 'z', 'h', 's'] 

selected_gates= []

for i in range(0,8):
  x = random.choice(gates)
  a = '({})'.format(i)
  k = x+a
  selected_gates.append(k)

print(selected_gates)
qr = QuantumCircuit(n)
qr.selected_gates[0]
qr.selected_gates[1]
qr.selected_gates[2]
qr.selected_gates[3]
qr.selected_gates[4]
qr.selected_gates[5]
qr.selected_gates[6]
qr.selected_gates[7]

qr.draw()
</code></pre>
",<qiskit><programming><random-quantum-circuit>,2/22/2020 10:31,9944.0,9944.0,"<p>This is very similar to an function in terra <code>random_circuit</code>: <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/random/utils.py#L30-L113"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/random/utils.py#L30-L113</a> It randomly picks gates from the list of all the standard gates in terra. For example, you can run something like:</p>



<pre><code>from qiskit.circuit.random import random_circuit

qr = random_circuit(10, 10, max_operands=3, measure=True)
</code></pre>

<p>Which will return a 10 qubit circuit of depth 10 with measurements at the end. </p>

<p>What this function is missing is an option to specify the list of gates to select from, but I think if you opened an issue about this no one would be opposed to adding that functionality in the future. But, regardless the implementation of that function shows how you would implement a version with your own list of gates, just make a local copy of the function and modify the lists <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/random/utils.py#L52-L59"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/random/utils.py#L52-L59</a>.</p>
",2/22/2020 12:14,Tooling,The user is asking about a specific feature in the Qiskit library for quantum computing. They are trying to understand how to implement a quantum circuit with randomly selected gates using the Qiskit library.,Tooling,,,,Tooling,
9951.0,Is there anything that can be programmed on a classical computer but not on a quantum computer?,"<p>Would we need to create new algorithms that only work on quantum computers or would be simply edit codes in languages such as C++ to involve the new primitives from quantum computing?  Are there things that can be programmed on a classical computer that canât be programmed ona. Quantum computer? I know that quantum computer are turing complete. </p>
",<algorithm><classical-computing>,2/23/2020 18:14,9954.0,9954.0,"<p>Short answer: no. Any classical algorithm can be transformed into quantum algorithm. This result has little practical value, because you don't obtain quantum speedup, but it is important from theoretical point of view.</p>
",2/23/2020 18:58,Conceptual,"The question is asking about the conceptual aspects of quantum computing and classical computing, specifically whether new algorithms are needed for quantum computers or if classical code can be edited to include quantum primitives. It also inquires about potential differences in programmability between classical and quantum computers, which are conceptual topics.",Conceptual,,,,Conceptual,
9957.0,IBMQ: `from qiskit import QISKitError` gives 'cannot import name QISKitError',"<p>When I run:</p>

<pre><code>from qiskit import QISKitError
</code></pre>

<p>I get the error:</p>

<pre><code>ImportError: cannot import name 'QISKitError'
</code></pre>

<p>I need QISKitError for exception handling with my program. Did IBMQ recently update this import?</p>
",<qiskit><programming><ibm-q-experience>,2/23/2020 21:43,9958.0,9958.0,"<p>This has been moved to <code>from qiskit.exceptions import QiskitError</code></p>
",2/23/2020 22:26,Errors," The user is encountering an error while trying to import the QISKitError from the Qiskit library in their Python program. They are seeking help to understand and resolve the ImportError they received, which states that the name QISKitError cannot be imported.", Errors,,,,Errors,
9966.0,Why I am getting transpilation error while executing the following IBM Quantum Experience code?,"<p>While executing the following circuit (consisting 16 qubit and 4 classical bits) I am getting ""Error in transpilation process. [1003]"" error. I have a group of 2 operations (you can observe circuit duplication in the figure). Is it a valid circuit? If not why it is not?. Why am I getting error? (My target backend is ibmq_16_melbourne). </p>

<p><a href=""https://i.stack.imgur.com/AafTI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AafTI.png"" alt=""figure""></a></p>

<pre><code>OPENQASM 2.0;
include ""qelib1.inc"";

qreg q[8];
qreg qGrp1[8];
creg c[2];
creg cGrp1[2];


h q[2];
h q[4];
h q[6];
x q[7];
x qGrp1[1];
h qGrp1[2];
h qGrp1[4];
h qGrp1[6];
x qGrp1[7];
cx q[2],q[3];
cx q[4],q[5];
cx q[6],q[7];
cx qGrp1[2],qGrp1[3];
cx qGrp1[4],qGrp1[5];
cx qGrp1[6],qGrp1[7];
ccx q[6],q[0],q[4];
ccx qGrp1[6],qGrp1[0],qGrp1[4];
ccx q[7],q[1],q[5];
ccx qGrp1[7],qGrp1[1],qGrp1[5];
x q[6];
x q[7];
x qGrp1[6];
x qGrp1[7];
ccx q[6],q[0],q[2];
ccx qGrp1[6],qGrp1[0],qGrp1[2];
ccx q[7],q[1],q[3];
ccx qGrp1[7],qGrp1[1],qGrp1[3];
cx q[2],q[3];
cx q[4],q[5];
cx qGrp1[2],qGrp1[3];
cx qGrp1[4],qGrp1[5];

measure q[3] -&gt; c[0];
measure q[5] -&gt; c[1];
measure qGrp1[3] -&gt; cGrp1[0];
measure qGrp1[5] -&gt; cGrp1[1];
</code></pre>
",<programming><circuit-construction><ibm-q-experience>,2/24/2020 14:36,9972.0,9972.0,"<p>Your circuit looks fine, but it has 16 qubits, and the largest IBM public backend currently has 15 qubits (note that <code>Melbourne</code> has 16 but one of the qubits is off right now). So in order to run it, you need a larger backend. The 20+ qubit hardware is currently accessible by IBMQ Network institution members.</p>

<p>But if you just want to play around you can simulate your circuit under realistic noise models and see how transpilation changes the circuit. For this you can use the ""fake"" backends in Qiskit. For example:</p>

<pre><code>from qiskit.test.mock import FakeAlmaden
backend = FakeAlmaden()

# you can see how this differs from original circuit and can plan
# with some transpilation options
new_circuit = transpile(circuit, backend) 
</code></pre>

<p>And then you can refer to this tutorial on how to simulate this backend. Almaden is a 20-qubit backend.
<a href=""https://github.com/Qiskit/qiskit-iqx-tutorials/blob/09ea113fdeb340f4f2d71c862126ee35a676b754/qiskit/advanced/aer/2_device_noise_simulation.ipynb"" rel=""noreferrer"">https://github.com/Qiskit/qiskit-iqx-tutorials/blob/09ea113fdeb340f4f2d71c862126ee35a676b754/qiskit/advanced/aer/2_device_noise_simulation.ipynb</a></p>
",2/24/2020 16:21,Errors,The user is encountering an error in the transpilation process when executing a specific quantum circuit on the IBMQ Melbourne backend. They are seeking an explanation for the error and whether the circuit is valid.,Errors,,,,Errors,
9967.0,How to use external .csv data file in quantum support vector machine qiskit python code?,"<p>I am new to python programming and Qiskit. I would like to ask can we use sklearn for adding external .csv data file before Qiskit libraries, or without sklearn, we can do or is there any other Qiskit library to add any external .csv file, to run the python code of quantum support vector machine?</p>

<p>How I can use .csv data file with Qiskit libraries to run quantum SVM ?</p>

<p>I am following the code written below, where I should put my own .csv data file</p>

<pre><code>import numpy as np
from dataset import breast_cancer
from sklearn.datasets.samples_generator import make_blobs
from qiskit.aqua.utils import split_dataset_to_data_and_labels 
from sklearn import svm
from utils import svm_utils 
from matplotlib import pyplot as plt
#matplotlib inline
#load_ext autoreload
#autoreload 2   % Breast Cancer dataset

n = 2 # number of principal components kept
training_dataset_size = 20
testing_dataset_size = 10

sample_Total, training_input, test_input, class_labels = breast_cancer(training_dataset_size, testing_dataset_size, n)

data_train, _ = split_dataset_to_data_and_labels(training_input)
data_test, _ = split_dataset_to_data_and_labels(test_input)  # %%Breast Cancer dataset

##%% Linear Support vector machine
# We use the function of scikit learn to generate linearly separable blobs
centers = [(2.5,0),(0,2.5)]
x, y = make_blobs(n_samples=100, centers=centers, n_features=2,random_state=0,cluster_std=0.5)


fig,ax=plt.subplots(1,2,figsize=(10,5))


ax[0].scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1])
ax[0].set_title('Breast Cancer dataset');

ax[1].scatter(x[:,0],x[:,1],c=y)
ax[1].set_title('Blobs linearly separable');

##%% Hands-on session on support vector machine

plt.scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1])
plt.title('Breast Cancer dataset');

model= svm.LinearSVC()
model.fit(data_train[0], data_train[1])
accuracy_train = model.score(data_train[0], data_train[1])
accuracy_test = model.score(data_test[0], data_test[1])


X0, X1 = data_train[0][:, 0], data_train[0][:, 1]
xx, yy = svm_utils.make_meshgrid(X0, X1)
Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

fig,ax=plt.subplots(1,2,figsize=(15,5))
ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)
ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1])
ax[0].set_title('Accuracy on the training set: '+str(accuracy_train));

ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)
ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1])
ax[1].set_title('Accuracy on the test set: '+str(accuracy_test));

##%% We now implement a SVM with gaussian kernel
clf = svm.SVC(gamma = 'scale')
clf.fit(data_train[0], data_train[1]);
accuracy_train = clf.score(data_train[0], data_train[1])
accuracy_test = clf.score(data_test[0], data_test[1])


X0, X1 = data_train[0][:, 0], data_train[0][:, 1]
xx, yy = svm_utils.make_meshgrid(X0, X1)
Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

fig,ax=plt.subplots(1,2,figsize=(15,5))
ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)
ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1])
ax[0].set_title('Accuracy on the training set: '+str(accuracy_train));

ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)
ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1])
ax[1].set_title('Accuracy on the test set: '+str(accuracy_test));

##%% First steps in Qiskit
import qiskit as qk

# Creating Qubits
q = qk.QuantumRegister(2)
# Creating Classical Bits
c = qk.ClassicalRegister(2)

##%% Define and print empty circuit
circuit = qk.QuantumCircuit(q, c)
print(circuit)

##%%% Add gates to the qubits
# Initialize empty circuit
circuit = qk.QuantumCircuit(q, c)
# Hadamard Gate on the first Qubit
circuit.h(q[0])
# CNOT Gate on the first and second Qubits
circuit.cx(q[0], q[1])
# Measuring the Qubits
circuit.measure(q, c)
print (circuit)

##%% Run the circuit on the quantum simulator
# Using Qiskit Aer's Qasm Simulator: Define where do you want to run the simulation.
simulator = qk.BasicAer.get_backend('qasm_simulator')

# Simulating the circuit using the simulator to get the result
job = qk.execute(circuit, simulator, shots=100)
result = job.result()

# Getting the aggregated binary outcomes of the circuit.
counts = result.get_counts(circuit)
print (counts)

from qiskit.aqua.components.feature_maps import SecondOrderExpansion

feature_map = SecondOrderExpansion(feature_dimension=2, 
                                   depth=1)

##%%Print the feature map circuit
x = np.array([0.6, 0.3])
print(feature_map.construct_circuit(x))

##%%% QSVM Algorithm
from qiskit.aqua.algorithms import QSVM

qsvm = QSVM(feature_map, training_input, test_input)

##%% Run QSVM
from qiskit.aqua import run_algorithm, QuantumInstance
from qiskit import BasicAer

backend = BasicAer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=10598, seed_transpiler=10598)

result = qsvm.run(quantum_instance)

##%%% Analyze output
plt.scatter(training_input['Benign'][:,0], training_input['Benign'][:,1])
plt.scatter(training_input['Malignant'][:,0], training_input['Malignant'][:,1])
plt.show()
length_data = len(training_input['Benign']) + len(training_input['Malignant'])
print(""size training set: {}"".format(length_data))
print(""Matrix dimension: {}"".format(result['kernel_matrix_training'].shape))

print(""testing success ratio: "", result['testing_accuracy'])

test_set = np.concatenate((test_input['Benign'], test_input['Malignant']))
y_test = qsvm.predict(test_set, quantum_instance)

##%% And here we plot the results. The first plot shows the label predictions of the QSVM and the second plot shows the test labels.
plt.scatter(test_set[:, 0], test_set[:,1], c=y_test)
plt.show()

plt.scatter(test_input['Benign'][:,0], test_input['Benign'][:,1])
plt.scatter(test_input['Malignant'][:,0], test_input['Malignant'][:,1])
plt.show()

</code></pre>
",<algorithm><qiskit><programming>,2/24/2020 15:24,9968.0,9968.0,"<p>I have previously used this function to load a custom data set - it should still work but I haven't tried it with more recent releases of Aqua</p>



<pre><code>def userDefinedData(location, file, class_labels,training_size, test_size, n=2, PLOT_DATA=True):


    data, target, target_names = load_data(location, file)
    # sample_train is of the same form as data
    sample_train, sample_test, label_train, label_test = train_test_split(
        data, target,test_size=0.25, train_size=0.75 ,random_state=22)


    # Now we standarize for gaussian around 0 with unit variance
    std_scale = StandardScaler().fit(sample_train)
    sample_train = std_scale.transform(sample_train)
    sample_test = std_scale.transform(sample_test)


    # Now reduce number of features to number of qubits
    pca = PCA(n_components=n).fit(sample_train)
    sample_train = pca.transform(sample_train)
    sample_test = pca.transform(sample_test)


    # Samples are pairs of points
    samples = np.append(sample_train, sample_test, axis=0)
    minmax_scale = MinMaxScaler((-1, 1)).fit(samples)
    sample_train = minmax_scale.transform(sample_train)
    sample_test = minmax_scale.transform(sample_test)


    # If class labels are numeric
    if class_labels[0].isdigit():
        # Pick training size number of samples from each distro
        training_input = {key: (sample_train[label_train == int(key), :])[:training_size] for k, key in enumerate(class_labels)}
        test_input = {key: (sample_test[label_test == int(key), :])[: test_size] for k, key in enumerate(class_labels)}

    else:
        # if they aren't
        training_input = {key: (sample_train[label_train == k, :])[:training_size] for k, key in
                         enumerate(class_labels)}
        test_input = {key: (sample_train[label_train == k, :])[training_size:(
                training_size + test_size)] for k, key in enumerate(class_labels)}



    if PLOT_DATA:
        for k in range(0, 9):
            plt.scatter(sample_train[label_train == k, 0][:training_size],
                        sample_train[label_train == k, 1][:training_size])

        plt.title(""PCA dim. reduced user dataset"")
        plt.show()

    return sample_train, training_input, test_input, class_labels

</code></pre>
",2/24/2020 15:37,Tooling,The question is asking about how to use the Qiskit libraries to run a quantum support vector machine (QSVM) on external data. This is a tooling question because it requires knowledge of the specific features and capabilities of the Qiskit libraries.,Tooling,,,,Tooling,
9976.0,Will quantum computers pass the Turing test?,"<p>Will quantum computers be able to pass the Turing test sooner than classical computers?</p>
",<classical-computing><quantum-turing-machine>,2/24/2020 18:47,9982.0,9982.0,"<p>I think a better phrasing to this question is - will cloud access to a quantum computer enable a classical computer to pass the Turing test sooner than a classical computer with no such access? </p>

<p>A quantum computer ""alone"" is very unlikely to pass the Turing test earlier than the above mentioned device, since quantum computers have technical difficulties performing large-scale simple tasks (e.g. multiply two 2048-digit numbers). Our usage of quantum computers relies on their ability to perform <strong>very specific</strong> tasks that are out of reach for classical computers.</p>

<p>In order to pass the Turing test, the computer needs to be able to cover an extremely wide variety of tasks; there is no reason to assume a quantum computer will be better than a classical computer in such a wide variety.</p>

<p>So the question remains - will cloud access to a quantum computer help with passing the Turing test? Here we can only speculate as well. For example, one can guess that good machine learning capabilities are essential to passing the Turing test (since you need to be able to tell the difference between a picture of a cat and a picture of a dog), and we <strong>hope</strong> that quantum computers will help us with machine learning. But this is still only in the realm of speculation.</p>

<p>My personal guess: Yes, it will help. But only because we have many years ahead of us until a computer passes the Turing test, and I believe(/hope/dream) that quantum computing will mature by then.</p>
",2/25/2020 8:37,Theoretical,"The user is asking about the theoretical possibility of quantum computers passing the Turing test before classical computers. This involves understanding the capabilities and limitations of quantum computers in relation to the Turing test, a concept in theoretical computer science",Conceptual,"The question is about the potential of quantum computers to surpass classical computers in terms of general intelligence, which is a topic of much debate and speculation. Answering the question requires a deep understanding of the Turing test, the limitations of classical computers, and the potential capabilities of quantum computers.",No,89.0,Theoretical,"The question pertains to the theoretical capabilities of quantum computers compared to classical computers in passing the Turing test, which involves understanding the fundamental principles of quantum computation and its potential impact on computational tasks like passing the Turing test."
9984.0,symbolic quantum computing using sympy : how to use arbitrary gate?,"<p>I'm trying to use sympy to compute symbolic results of quantum circuits using dirac notation. 
More specifically, I'd like to use the three rotation gates. I try to implement them in the following way, using sympy symbolic quantum physics package : </p>



<pre><code>from IPython.display import display

from sympy import init_printing
init_printing(use_latex=True)
from sympy import expand, Eq, Symbol, simplify, exp, sin,cos,I,srepr,Matrix
from sympy.physics.quantum import *
from sympy.physics.quantum.qubit import *
from sympy.physics.quantum.gate import *
from sympy.physics.quantum.circuitplot import circuit_plot


theta = Symbol('theta')

Ry_mat = Matrix([[cos(theta/2), -sin(theta/2)],[sin(theta/2),cos(theta/2)]]) #check
Rx_mat = Matrix([[cos(theta/2), -I*sin(theta/2)],[-I*sin(theta/2),cos(theta/2)]]) #check

Ry = UGate((0,), Ry_mat)
Rx= UGate((1,), Rx_mat)
c = Ry*Rx
circuit_plot(c, nqubits=2);

qapply(c*Qubit('00'))
</code></pre>

<p>I get the error <strong>unhashable type: 'MutableDenseMatrix'</strong>
when executing qapply. I tried to replace the line :</p>



<pre><code>c = Rx*Ry
</code></pre>

<p>with</p>



<pre><code>c = Rx
</code></pre>

<p>and then there is no more errors. Does someone know what's going on ? What am I doing wrong ?</p>
",<programming>,2/25/2020 12:17,10007.0,10007.0,"<p>I don't know why this doesn't work with <code>Matrix</code>, but a fix for this would be to use <code>ImmutableMatrix</code> instead</p>

<pre><code>from sympy import Symbol, sin, cos, I, ImmutableMatrix
from sympy.physics.quantum import qapply
from sympy.physics.quantum.qubit import Qubit
from sympy.physics.quantum.gate import UGate

theta = Symbol('theta')

Ry_mat = ImmutableMatrix([[cos(theta/2), -sin(theta/2)],
                        [sin(theta/2),cos(theta/2)]])
Rx_mat = ImmutableMatrix([[cos(theta/2), -I*sin(theta/2)],
                        [-I*sin(theta/2) ,cos(theta/2)]])

Ry = UGate((0,), Ry_mat)
Rx= UGate((1,), Rx_mat)
c = Ry* Ry

print(qapply(c*Qubit('00'))) # -sin(theta/2)**2*|00&gt; + 2*sin(theta/2)*cos(theta/2)*|01&gt; + cos(theta/2)**2*|00&gt;

</code></pre>

<p>I've filed an <a href=""https://github.com/sympy/sympy/issues/18733"" rel=""nofollow noreferrer"">issue</a> for your problem. In the meantime, use <code>ImmutableMatrix</code>. </p>
",2/26/2020 18:02,Errors,"The user is encountering an error while using the sympy symbolic quantum physics package to compute symbolic results of quantum circuits. They are seeking assistance in resolving the ""unhashable type"" error they are facing when using the qapply function.",Errors,,,,Errors,
9996.0,How to read the elements of a circuit in qiskit?,"<p>I would like to know if there is a way to read the elements of a circuit. What I mean is if I have a <code>QuantumCircuit</code> object, can I obtain the gates that are applied to each qubit in order? </p>

<p>I would like to implement certain noise gate after each Hadamard and I would have therefore to identify each Hadamard in the <code>QuantumCircuit</code> object. So I need a function that gives me all the gates in a circuit and that allows me to modificate what it returns so I can construct a modified quantum circuit.</p>
",<quantum-gate><qiskit><programming>,2/26/2020 14:45,10013.0,10013.0,"<p>You can play with the circuit's <code>data</code>. First write:</p>

<pre><code>print(circ.data)
</code></pre>

<p>or</p>

<pre><code>from pprint import pprint
pprint(vars(circ.data))
</code></pre>

<p>Then you'll understand the structure and how to modify it.</p>
",2/27/2020 6:46,Tooling,"The user is seeking information on how to programmatically access the elements (gates) of a QuantumCircuit object and modify them. They are looking for a tool or method to analyze and manipulate quantum circuits, making it a tooling-related question.",Tooling,,,,Tooling,
10006.0,How do I know in which state the qubit is in each step of the circuit for the simulator in qiskit?,"<p>I would like to know how to know in which state a qubit is (I am talking about single-qubit errors), because in order to apply a non unitary gate in the simulator I have to renormalize the state or the corresponding non unitary Kraus operator (the non unitary gate in my circuit). Therefore I need to know in which state the circuit it. I am of course talking about the simulator, which in fact is classical and therefore it must be a way to know the state at each point of the circuit.</p>
",<quantum-gate><qiskit><programming><noise>,2/26/2020 17:51,10008.0,10008.0,"<p>You can take snapshots of the statevector of the circuit when you use the <code>'qasm_simulator'</code>. You simply append snapshot instructions into your circuit where you would like to see the statevector, and then can see the values in the result object that is returned. You add a snapshot instruction using </p>

<pre><code>from qiskit.extensions.simulator import snapshot
qc.snapshot('my_label')
</code></pre>
",2/26/2020 18:03,Tooling,"The user is asking about the tools or methods available to determine the state of a qubit at different points in a quantum circuit when using a simulator. They are seeking information on how to programmatically access and analyze the qubit states during circuit simulation, making it a tooling-related question.",Tooling,,,,Tooling,
10092.0,What do the numbers of the operation object in QuantumCircuit.data outputs?,"<p>When you have a quantum circuit and use QuantumCircuit.data you get a list with objects of this type (this is the one for a X gate acting on qubit 0 y a 2 qubits Quantum Circuit):</p>

<p>(qiskit.extensions.standard.x.XGate object at 0x0000019B8DEC2EB8, [Qubit(QuantumRegister(2, 'q'), 0)], [])</p>

<p>The first element represents the operation. What does the sequence of digits 0x0000019B8DEC2EB8 mean? I suppose it has something to do with the location or the time, but I do not know how to obtain each digit. I need to know exactly how to reproduce one of these sequences myself.</p>

<p>Thank you so much in advance.</p>
",<qiskit><programming>,03/04/2020 18:30,10093.0,10093.0,"<p>That is the address in memory (represented as a hexademical number) of that specific gate object. It can be used to differentiate that specific X gate object from a different X gate object. Other than that it general is not useful, and it's definitely not something you would ever need to manually reproduce.</p>
",03/04/2020 19:04,Tooling,"The user is inquiring about the format and significance of the sequence of digits in the object representation of a quantum gate obtained from QuantumCircuit.data. They are looking for information related to the internal representation of quantum gates, which falls under the tooling category.", Tooling,,,,Tooling,
10101.0,What does the $\sqrt{NOT}$ gate have to do with irreversibility?,"<p>In his essay <a href=""https://arxiv.org/abs/1501.00011"" rel=""nofollow noreferrer""><em>""Why now is the right time to study quantum computing""</em></a> Aram Harrow writes, after describing the action of the <span class=""math-container"">$\sqrt{NOT}$</span> gate, that:</p>

<blockquote>
  <p>However, if we apply <span class=""math-container"">$\sqrt{NOT}$</span> a second time before measuring, then we always obtain the outcome 1. This demonstrates a key difference between quantum superpositions and random mixtures; placing a state into a superposition can be done without any irreversible loss of information.</p>
</blockquote>

<p>I'm confused by what he meant here. How does the existence of a <span class=""math-container"">$\sqrt{NOT}$</span> gate in quantum computation demonstrate a difference in irreversibility as opposed to classical computation?</p>
",<quantum-gate><classical-computing>,03/05/2020 20:38,10104.0,10104.0,"<p>I wouldn't say it's the existence of the <span class=""math-container"">$\sqrt{NOT}$</span> gate that demonstrates reversibility per se. It's the specific example that Harrow is using.</p>

<p>When you measure the output of applying a <span class=""math-container"">$\sqrt{NOT}$</span> gate to a <span class=""math-container"">$|0\rangle$</span>, it looks just like a coin flip. It could be either <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> with a 50% chance. So far, nothing has been demonstrated that a random mixture can't do. A random mixture is perfectly capable of replacing a single bit with the results of a coin flip.</p>

<p>When you apply <span class=""math-container"">$\sqrt{NOT}$</span> a second time, the <span class=""math-container"">$\sqrt{NOT}$</span> gate recovers the initial information. But recovering information would be impossible if there was simply a random mixture. That's the demonstration of the key difference between superposition and random mixture. Information used in the creation of a superposition can be recovered; information lost in a random mixture cannot be.</p>
",03/06/2020 00:23, Conceptual,The question seeks an explanation regarding the statement made by Aram Harrow about the difference between quantum superpositions and classical random mixtures in terms of the irreversibility of operations involving the $\sqrt{NOT}$ gate. It involves understanding the conceptual difference between classical and quantum computing principles.,Conceptual,,,, Conceptual,
10109.0,How to calculate the Von Neuman entropy on qiskit with the module quantum_info?,"<p>I am trying to wrap my head around he <code>quantum_info</code> module on qiskit, since most of the functions on <code>qiskit.tools</code> are going to be deprecated, but I am very confused with the Statevector and DensityMatrix objects. For example, with this snippet of code:</p>

<pre><code>simulator = BasicAer.get_backend('statevector_simulator') # the device to run on
result6 = execute(circuit6, simulator).result()
outputstate6 = result6.get_statevector(circuit6, decimals=3)
probability = np.abs(np.array(outputstate6))**2
outstatevector=quantum_info.states.Statevector(outputstate6)
print(type(outstatevector))
print(type(outputstate6))
print(outputstate6)
print(quantum_info.entropy(outputstate6))
</code></pre>

<p>I get:</p>

<pre><code>&lt;class 'qiskit.quantum_info.states.statevector.Statevector'&gt;
&lt;class 'numpy.ndarray'&gt;
[0.447+0.j 0.   +0.j 0.632+0.j 0.632+0.j]
</code></pre>

<p>as expected but then I get the error on <code>quantum_info.entropy(outputstate6)</code>:</p>

<pre><code>QiskitError: 'Input quantum state is not a valid'
</code></pre>

<p>How can I solve this?</p>
",<qiskit><programming><entropy>,03/06/2020 23:08,10124.0,10124.0,"<p><strong>Short answer</strong> </p>

<p>You are getting that error because your example does not use a valid (normalized) statevector. If you remove the <code>decimals=3</code> kwarg where you call <code>result.get_statevector</code> it will work.</p>

<p><strong>Long Answer</strong></p>

<p>The Von-Neuman <code>entropy</code> function in the <code>qiskit.quantum_info</code> works with either <code>Statevector</code> or <code>DensityMatrix</code> object inputs, or inputs that can be implicitly converted to those objects (ie a list or np.array for a vector or a square matrix). So you can do any of the following for example:</p>



<pre><code>import numpy as np
from qiskit.quantum_info import entropy, Statevector, DensityMatrix

# Pure state entropy (Note this is always 0)
# The following are equivalent:

s1 = entropy([1, 0, 0, 0])  # Statevector as list
s2 = entropy(np.array([1, 0, 0, 0])) # Statevector as array
s3 = entropy(Statevector([1, 0, 0, 0]))  # Statevector object

print(s1, s2, s3)

# Mixed state entropy
# The following are equivalent

s1 = entropy([[0.75, 0], [0, 0.25]])  # Density matrix as list
s2 = entropy(np.array([[0.75, 0], [0, 0.25]])) # density matrix as array
s3 = entropy(DensityMatrix([[0.75, 0], [0, 0.25]]))  # Density matrix object

print(s1, s2, s3)
</code></pre>

<p>As for your specific issue: the entropy is only well-defined for a valid quantum state, so the function checks the input state is valid. In the case of a statevector this is checking it has norm 1, in the case of a density matrix that it is trace 1 and postive-semidefinite.</p>

<p>Your example does not have a norm-1 input state because you truncated the decimals when you got the output state from the simulator. You can check this using the statevector object for example: </p>

<pre><code># Returns True:
Statevector([1 / np.sqrt(2), 1 / np.sqrt(2)]).is_valid()

# Returns False:
Statevector([0.707, 0.707]).is_valid()
</code></pre>

<p><em>Entropy base:</em> Another thing you should keep in mind if you didn't already notice is that the <code>qiskit.quantum_info.entropy</code> function takes logarithms in base 2 by default (and you can use a different base using the <code>base</code> kwarg). The deprecated <code>qiskit.tools.qi.entropy</code> function was always taken in log base <code>e</code>:</p>



<pre><code>import numpy as np
from qiskit.quantum_info import entropy
from qiskit.tools.qi import entropy as old_entropy

rho = [[0.75, 0], [0, 0.25]]

s1 = entropy(rho)  # base-2
s2 = entropy(rho, base=np.e)  # base-e
s3 = old_entropy(rho)  # base-e

print(s1, s2, s3, s2 == s3)
<span class=""math-container"">```</span>
</code></pre>
",03/08/2020 15:58,Errors ,The user is encountering an error related to the quantum_info module in Qiskit when trying to calculate the entropy of a quantum state. They need assistance in resolving this specific error and understanding how to correctly use the quantum_info module for entropy calculations.,Errors,,,,Errors ,
10142.0,"CPTP, Kraus representation and classical registers","<p>What is the best mathematical representation of a quantum system that has some classical registers and some quantum registers?</p>

<p>I'm asking because I'm considering any ""physical"" process <span class=""math-container"">$\pi()$</span> that takes no input, but that outputs both <strong>classical</strong> and quantum values, like for example a tuple <span class=""math-container"">$(x, \rho)$</span>, with <span class=""math-container"">$x \in \{0,1\}^n$</span> a classical string, and <span class=""math-container"">$\rho$</span> a quantum state on <span class=""math-container"">$m$</span> qubits, and I'd like to find a kind of <strong>Kraus</strong> representation of <span class=""math-container"">$\pi$</span>.</p>

<p>I wanted to use the usual formalism of CPTP, but it's not clear in which Hilbert space lives <span class=""math-container"">$(x, \rho)$</span>... Indeed, usually, a Hilbert space is stable by superposition, but here the first ""register"" cannot be in superposition. Of course, I could say that <span class=""math-container"">$x$</span> is in fact <span class=""math-container"">$|x\rangle$</span> and therefore the output of <span class=""math-container"">$\pi()$</span> is strictly contained in a Hilbert space of size <span class=""math-container"">$2^n$</span>, but then <span class=""math-container"">$\pi()$</span> is not simply <span class=""math-container"">$\sigma = \sum_i B_i 1 B_i^\dagger$</span>, as I'd also need to ""measure"" <span class=""math-container"">$\sigma$</span> to extract a random <span class=""math-container"">$x$</span>, and then set <span class=""math-container"">$\rho$</span> to be the matrix <span class=""math-container"">$\sigma$</span> ""postselected"" on <span class=""math-container"">$x$</span>.</p>

<p>Is there some better representation for such process that makes the difference between quantum outputs and classical outputs?</p>
",<mathematics><measurement><quantum-operation><classical-computing>,03/09/2020 17:44,10143.0,10143.0,"<p>CPTP map is a map from operators on one Hilbert space to operators on another Hilbert space (usually we consider only density matrices as inputs and outputs). There are no separated classical registers in this formalism.<br>
There are some generalizations, though, like this <a href=""https://en.wikipedia.org/wiki/Quantum_instrument"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Quantum_instrument</a>. But in essence the idea is the same as you've described <span class=""math-container"">$-$</span> we model classical register with values <span class=""math-container"">$x$</span> as a quantum register with orthogonal states <span class=""math-container"">$|x\rangle$</span>. You can model a measurement in this way, for example. If <span class=""math-container"">$\sum_i B_iB_i^\dagger=I$</span> describes a measurement, then 
<span class=""math-container"">$$\Phi(\rho) = \sum_i |i\rangle\langle i| \otimes B_i \rho B_i^\dagger = \sum_i |i\rangle\langle i| \otimes \frac{B_i \rho B_i^\dagger}{ \text{Tr}(B_i \rho B_i^\dagger)} \cdot \text{Tr}(B_i \rho B_i^\dagger)$$</span>
is a corresponding quantum channel where the first quantum register of the output encodes the classical result <span class=""math-container"">$i$</span> and the second register contains the quantum state after the measurement.</p>
",03/09/2020 18:47,Theoretical,"The user is asking about the theoretical concept of representing a quantum system that includes both classical and quantum registers, and is seeking a mathematical representation that distinguishes between quantum and classical outputs",Theoretical,,,,Theoretical,
10164.0,"In Qiskit, where is the floating point operation performed?","<p>I am using Qiskit  - the simple circuits I am writing can either run on the hardware backend (using least_busy) or the QASM simulator backend. </p>

<p>If I have statements like the following - (<code>random_numbers</code> were generated using QRNG in the circuits - not shown here)</p>

<pre><code>b = .6
a = .3
flt = []

for rn_num in random_numbers:
     flt.append( b*(a-rn_num) + a * rn_num)
</code></pre>

<p>Where are these floating point operations performed? I am connected to IBM Quantum Experience - using Jupyter. Are these operations performed on a traditional machine or a quantum backend?</p>

<p>My understanding is unless it is related to a Quantum circuit - everything gets executed on a traditional machine (similar to print or sockets?)</p>

<p>Is there a document that explains this further? I read release notes - I found them a bit ambiguous. I found this comment in <strong>Aer 0.3</strong> release note </p>

<blockquote>
  <p>Increased performance with simulations that require less floating
  point numerical precision.</p>
</blockquote>

<p>Maybe this note is referring to statevectors in floating point ...??</p>
",<qiskit><programming><ibm-q-experience>,03/12/2020 09:43,10165.0,10165.0,"<p>The Qiskit backends (quantum devices or simulators) work only when you explicitly invoke them, usually with <code>execute</code>. The code in your snippet does not call <code>qiskit</code>, and runs on a traditional machine.</p>
",03/12/2020 09:54, Tooling,"The user is seeking clarification on where floating-point operations are executed when running Qiskit circuits, specifically whether they are performed on a traditional machine or a quantum backend. This falls under the category of tooling as it relates to the practical usage and behavior of the Qiskit framework.",Tooling,,,, Tooling,
11338.0,Entanglement Swapping Circuit,"<p>I implemented 2 versions of the entanglement swapping circuit in IBM Q. One is using classical measurement to control X, Z gates. Another is just us C-NOT and Controlled-Z. They should be equivalent. The 1st and 2nd bits were entangled. After teleportation of the 2nd bit to the 4th bit, I expect the 1st and the 4th bit will be entangled. I can see that when using the 2nd method. But not the case for 1st method. Did I make a mistake or there is a bug?</p>

<p>Method 1:</p>

<p><a href=""https://i.stack.imgur.com/wWTjD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wWTjD.png"" alt=""enter image description here""></a></p>

<p>Method 2:</p>

<p><a href=""https://i.stack.imgur.com/soObP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/soObP.png"" alt=""enter image description here""></a></p>
",<programming><ibm-q-experience><simulation><teleportation><entanglement-swapping>,3/30/2020 5:39,11339.0,11339.0,"<p>There is a mistake in design of the first circuit. Both <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> gate work when value 1 is in classical register.</p>

<p>Gate <span class=""math-container"">$X$</span> should work in case qubit <span class=""math-container"">$q_2$</span> is in state <span class=""math-container"">$|1\rangle$</span>. Similarly <span class=""math-container"">$Z$</span> acts when <span class=""math-container"">$q_1$</span> in state <span class=""math-container"">$|1\rangle$</span>. Also you have to deal with state when both <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> have to act. In your case you conditioned both <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> on <code>c==1</code>. It means that both gates act in case <span class=""math-container"">$q_1$</span> is in state <span class=""math-container"">$|1\rangle$</span>. Another mistake come from measuring qubits <span class=""math-container"">$q_1$</span> and <span class=""math-container"">$q_2$</span> in the first circuit while not to measure them in the second one (in this case they are alway zero).</p>

<p>Please see here QASM commented code producing results you desired:</p>

<pre><code>OPENQASM 2.0;
include ""qelib1.inc"";

qreg q[4];
creg c[5];

//teleport
h q[0];
h q[2];
cx q[0],q[1];
cx q[2],q[3];
cx q[1],q[2];
h q[1];

//measuring q1 and q2
//for controlled gates

measure q[2] -&gt; c[0];
measure q[1] -&gt; c[1];

//set q1 and q2 to |0&gt; to
//emulate they are not measured
reset q[1];
reset q[2];

//controlled gates
  //q1 = |0&gt;, q2 =|1&gt;
if (c==1) x q[3];
  //q1 = |1&gt;, q2 =|0&gt;
if (c==2) z q[3];
  //q1 = |1&gt;, q2 =|1&gt;
if (c==3) x q[3];
if (c==3) z q[3];

//measure qubits
measure q[3] -&gt; c[3];
measure q[0] -&gt; c[0];
measure q[1] -&gt; c[1];
measure q[2] -&gt; c[2];
</code></pre>
",3/30/2020 6:45,Errors,The user is experiencing a discrepancy in the behavior of two different implementations of the entanglement swapping circuit in IBM Q. They are seeking clarification on whether they made a mistake or if there might be a bug in their implementations. This falls under the category of errors as it relates to unexpected behavior or discrepancies in the circuit implementations.,Errors,,,,Errors,
11349.0,What exactly does it mean to embed classical data into a quantum state?,"<p>As the title states.</p>

<p>I am a Machine Learning Engineer with a background in physics &amp; engineering (post-secondary degrees). I am reading the Tensorflow Quantum paper. They say the following within the paper:</p>

<blockquote>
  <p>One key observation that has led to
  the application of quantum computers to machine learning is their ability to perform fast linear algebra on a
  state space that grows exponentially with the number of
  qubits. These quantum accelerated linear-algebra based
  techniques for machine learning can be considered the
  first generation of quantum machine learning (QML) algorithms tackling a wide range of applications in both supervised and unsupervised learning, including principal
  component analysis, support vector machines, kmeans clustering, and recommendation systems.
  These algorithms often admit exponentially faster solutions compared to their classical counterparts on certain
  types of quantum data. This has led to a significant
  surge of interest in the subject. <strong>However, to apply
  these algorithms to classical data, the data must first
  be embedded into quantum states</strong>, a process whose
  scalability is under debate.</p>
</blockquote>

<p>What is meant by this sentence <strong><em>However, to apply these algorithms to classical data, the data must first be embedded into quantum states</em></strong>? </p>

<p>Are there resources that explain this procedure? Any documentation or links to additional readings would be greatly appreciated as well.</p>

<p>Thanks in advance!</p>

<p><strong>Note:</strong> I did look at this previous question for reference. It helped. But if anyone can provide more clarity from a more foundational first principles view (ELI5 almost), I would be appreciative</p>

<ul>
<li><a href=""https://quantumcomputing.stackexchange.com/questions/5761/how-do-i-embed-classical-data-into-qubits"">How do I embed classical data into qubits?</a></li>
</ul>
",<algorithm><quantum-state><programming><physical-qubit><embedding>,3/30/2020 15:27,11350.0,11350.0,"<p>First it is instructive to ask oneself: ""how does classical data get into my computer?"" In a classical computer, your data is always stored in bits. Because calculations in base 2 are not very straightforward for most people there are abstractions like <code>int</code> types for integers and <code>float</code> types for rational numbers with the associated math operations readily abstracted for the user -- which means that you can easily add, multiply, divide and so on.</p>

<p>Now, on a quantum computer you run into a fundamental problem: <em>Qubits are really expensive</em>. When I say <em>really expensive</em>, this does not only mean that building a quantum computer costs a fortune, but also that in current applications you only have a handful of them (Google's <a href=""https://www.nature.com/articles/s41586-019-1666-5"" rel=""noreferrer"">quantum advantage experiment</a> used a device with <em>53</em> qubits) -- which means that you have to economize your use of them. In machine learning applications you usually use single precision floating point numbers, which use 32 bits. This means a single ""quantum float"" would also need 32 qubits, which means that state of the art quantum computers can't even be used to add two floating point numbers together due to the lack of qubits.</p>

<p>But you can still do useful stuff with qubits, and this is because they have additional degrees of freedom! One particular thing is that you can encode an angle (which is a real parameter) bijectively into a single qubit by putting it into the relative phase 
<span class=""math-container"">$$
| \theta \rangle = \frac{1}{\sqrt{2}}(|0\rangle + \mathrm{e}^{i\theta} |1\rangle)
$$</span></p>

<p>And this is the heart of <em>embedding data into quantum states</em>. You simply can't do the same thing you would be doing on a classical computer due to a lack of sufficient qubit numbers and therefore you have to get creative and use the degrees of freedom of qubits to get your data into the quantum computer. To learn more about very basic embeddings, you should have a look at <a href=""https://arxiv.org/abs/1803.07128"" rel=""noreferrer"">this paper</a>. One particular example I want to highlight is the so-called ""amplitude embedding"" where you map the entries of a vector <span class=""math-container"">$\boldsymbol{x}$</span> into the different amplitudes of a quantum state
<span class=""math-container"">$$
| \boldsymbol{x} \rangle \propto \sum_i x_i | i \rangle
$$</span>
There is no equals sign because the state needs to be normalized, but for the understanding this is not important. The special thing about this particular embedding is that it embeds a vector with <span class=""math-container"">$d$</span> elements into <span class=""math-container"">$\log_2 d$</span> qubits which is a nice feature in our world where qubits are expensive!</p>
",3/30/2020 17:51,Learning,"The user is seeking an explanation and resources to understand the concept of embedding classical data into quantum states, as mentioned in the Tensorflow Quantum paper. This falls under the category of learning as it involves gaining a better understanding of a fundamental concept in quantum machine learning.",Learning,,,,Learning,
11409.0,Finding minimum with Grover,"<p>I am a beginner in quantum computing. I have already computed the sat quantum solver with Grover search and then, I would like to compute the ""minimum search"" of DÃ¼r and Hoyer. My question is: Is it possible to encode a list with two registers of qubits?</p>

<p>If it is possible, I would like to see a general methods with explanations of how to encode a list in a quantum circuit. :)</p>

<p>Ref: <a href=""https://arxiv.org/abs/quant-ph/9607014"" rel=""nofollow noreferrer"">A Quantum Algorithm for Finding the Minimum</a></p>
",<algorithm><programming><grovers-algorithm>,04/04/2020 23:47,11668.0,11668.0,"<p>This <a href=""https://arxiv.org/pdf/1502.04943.pdf"" rel=""nofollow noreferrer"">article</a> purpose a method to encode a list in quantum circuit. </p>

<p>An example for the list : [1, 3, 0, 2] and the Grover search, where is 0 ? 
<a href=""https://i.stack.imgur.com/ZOd28.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZOd28.png"" alt=""Grover search""></a></p>

<p>And the result : index 2
<a href=""https://i.stack.imgur.com/Jbke3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Jbke3.png"" alt=""Result""></a></p>
",4/23/2020 20:36, Learning,"The user is a beginner in quantum computing and is seeking guidance on encoding a list with two registers of qubits for the purpose of implementing the ""minimum search"" quantum algorithm described in the referenced paper. This falls under the category of learning as it involves understanding how to encode classical data into a quantum format for computation.",Learning,,,, Learning,
11432.0,Error parameters from Qiskit backends,"<p>In order to build a <a href=""https://qiskit.org/documentation/apidoc/aer_noise.html#device-noise-parameters"" rel=""nofollow noreferrer"">custom noise model in Qiskit Aer</a>, I requested the error parameters from different backends and got 3 (9) parameters for each single-qubit (two-qubit) gate as output. However, I could not find any documentation of what these numbers are actually specifying. Based on a <a href=""https://quantumcomputing.stackexchange.com/questions/8958/how-good-is-basic-device-noise-model-simulating-the-noise-in-the-quantum-compu?rq=1"">previous stack-exchange question</a> about Qiskit's <code>basic_device_noise_model()</code>, I would guess that the first parameter is giving the gate fidelity. Is this true? What are the other 2 (8) numbers specifying? </p>

<p>Here is an example for a single-qubit (<code>id</code>) and a two-qubit (<code>cx</code>) gate from the backend <code>orense</code>:</p>

<pre><code>   {'type': 'qerror',
   'operations': ['id'],
   'instructions': [[{'name': 'id', 'qubits': [0]}],
    [{'name': 'z', 'qubits': [0]}],
    [{'name': 'reset', 'qubits': [0]}]],
   'probabilities': [0.9996936442814689,
    5.460519336879117e-05,
    0.0002517505251623531],
   'gate_qubits': [[0]]},

   {'type': 'qerror',
   'operations': ['cx'],
   'instructions': [[{'name': 'id', 'qubits': [1]}],
    [{'name': 'z', 'qubits': [0]}],
    [{'name': 'reset', 'qubits': [0]}],
    [{'name': 'z', 'qubits': [1]}],
    [{'name': 'z', 'qubits': [0]}, {'name': 'z', 'qubits': [1]}],
    [{'name': 'reset', 'qubits': [0]}, {'name': 'z', 'qubits': [1]}],
    [{'name': 'reset', 'qubits': [1]}],
    [{'name': 'z', 'qubits': [0]}, {'name': 'reset', 'qubits': [1]}],
    [{'name': 'reset', 'qubits': [0]}, {'name': 'reset', 'qubits': [1]}]],
   'probabilities': [0.9893181752693058,
    0.0004106923127677822,
    0.001895703775229592,
    0.002657456705309657,
    1.1031810267579292e-06,
    5.092144099539429e-06,
    0.005698491726413379,
    2.365595624250726e-06,
    1.0919290223224507e-05],
   'gate_qubits': [[0, 1]]},
</code></pre>
",<qiskit><programming><ibm-q-experience><noise>,04/06/2020 16:00,11461.0,11461.0,"<p>Each of those dicts are a <code>QuantumError</code>. You can learn more about the structure of a <code>QuantumError</code> <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.noise.QuantumError.html"" rel=""nofollow noreferrer"">here</a>. That documentation is most likely what you were looking for.</p>

<p>Each <code>instruction</code> is an operation being applied on the qubit(s) in <code>qubits</code>. Each value in <code>probabilities</code> corresponds to the respective operation in <code>instructions</code>. </p>
",04/08/2020 15:25,Tooling,"The user is inquiring about the meaning of the error parameters provided by Qiskit Aer when constructing a custom noise model. They seek an understanding of these parameters for the purpose of building an accurate noise model, which falls under the category of tooling as it pertains to the tools and functionalities of Qiskit Aer.",Tooling,,,,Tooling,
11441.0,"I made a simple circuit on qiskit,but I have some question on this result","<p><a href=""https://i.stack.imgur.com/oaSdi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oaSdi.png"" alt=""enter image description here""></a>
I made a simple circuit that we can see. In my view, <span class=""math-container"">$|00000\rangle$</span> should appear  in one result, but I didn't see it. why?
<a href=""https://i.stack.imgur.com/121hu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/121hu.png"" alt=""enter image description here""></a></p>
",<programming><circuit-construction><ibm-q-experience>,04/07/2020 05:20,11443.0,11443.0,"<p>The problem is that IBM Q environment does not show all results in case there is more than 16 results (there is maximally 20 columns in the histogram). To get all results, you have to click on Download in the top right corner of a page with results. Two files with extension *.json are downloaded. Then open file ending with <em>_results.json</em> in notepad and look for string <em>results</em>. There will be something like this:</p>

<pre><code>""results"":[{""data"":{""counts"":""{""0x0"":27,""0x1"":33,""0x10"":36,""0x11"":41,""0x12"":21,""0x13"":32,
</code></pre>

<p>Instead of binary numbers, the results are expressed in hexadecimal format.</p>

<p>The result for state <span class=""math-container"">$|00000\rangle$</span> you were looking for is</p>

<pre><code>""0x0"":27
</code></pre>

<p>This means the number of occurences of <span class=""math-container"">$|00000\rangle$</span> is 27 (I used 1,024 shots).</p>
",04/07/2020 07:05,Conceptual,The question is asking why the state ?00000? does not appear in the results of the quantum circuit. This is a conceptual question because it requires an understanding of how quantum circuits work and how to measure the state of a quantum system., Errors,"The user is experiencing an issue where they expected to see the state |00000? in the results of their quantum circuit, but it did not appear as expected. They are seeking an explanation for this discrepancy, which falls under the ""Errors"" category related to issues and explanations.",No,90.0,Conceptual,"The user is seeking an explanation for why the state |00000? does not appear in the results of their quantum circuit, indicating a need for conceptual understanding of quantum circuit behavior and measurement outcomes."
11526.0,Error using FixedIncomeExpectedValue sample,"<p>I am working with Aqua sample (<code>qiskit-aqua/test/finance/test_readme_sample.py</code> ) that uses the <code>FixedIncomeExpectedValue</code> and the <code>AmplitudeEstimation</code>.</p>

<p>It is <code>qiskit 0.18</code> </p>

<p>This sample was previously working with qiskit 0.16.2 when <code>Statevector_simulator</code> was used for <code>AmplitudeEstimation</code>. Though I used to run  into an error ERROR_RUNNING_JOB when running on <code>ibmq_</code> hardware. I was told to upgrade to <code>qiskit 0.18</code> to fix that.</p>

<p>Since the update it now fails in <code>_check_conflicting_argument</code> with  the message ""<code>The parameters pass_manager conflicts with the following parameter(s): backend.</code>"" as shown below is a stack trace</p>

<pre><code>    :
qc = compiler.transpile(circuit, BasicAer.get_backend('qasm_simulator'), pass_manager=p_m)

File ""C:\Users\-----\Anaconda3\envs\qiskite\lib\site-packages\qiskit\compiler\transpile.py"", line 188, in transpile
        routing_method=routing_method, backend=backend)

File ""C:\Users\------\Anaconda3\envs\qiskite\lib\site-packages\qiskit\compiler\transpile.py"", line 225, in _check_conflicting_argument
        ""parameter(s): {}."".format(', '.join(conflicting_args)))

TranspilerError: 'The parameters pass_manager conflicts with the following parameter(s): backend.'
</code></pre>

<p>Further walk through the stack trace shows the following</p>

<pre><code>bckend = set_backend('STATEVEC')

ampest = AmplitudeEstimation(m, fixed_income)
result = ampest.run(quantum_instance=bckend)
..quantum_algorithm.run()
....ae.run
......if _quantum_instance.is_statevector:
........construct_circuit(measurement = False)
..........pec = PhaseEstimationCircuit(...)
..........pec.construct_circuit(measurement = False)
............._state_n_circuit_factory(qc,q,aux)
................uncertainty_model.build(...) #fixed_income_....py
..................cs = Custom(...) #multivariate_distribution.py
..................extend(cs.construct_circuit('circuit',q))   
.....................cs.construct_circuit('circuit')
........................svc = StateVectorCircuit(_state_vector)
........................sv.construct_circuit(...)
..........................convert_to_basis_gates()
............................Unroller(...)
............................PassManager(...)
............................compiler.transpile(circuit, BasicAer.get_backend('qasm_simulator)...)
.............................. transpile (....)
................................._check_conflicting_argument(...backend=backend)
</code></pre>

<p>It is in this <code>_check_conflicting_argument</code> that the error message is raised <code>""The parameters pass_manager conflicts with the following parameter(s): backend.""</code> and the script stops execution.</p>

<p>Please let me know what am I missing something here.</p>

<p>Thank you</p>
",<qiskit><programming><quantum-computing-for-finance>,4/13/2020 10:36,11559.0,11559.0,"<p>The quick answer to your problem is to install Qiskit Aqua directly from GitHub instead of via pip. On the lastest master version, this bug is fixed. You can do this using</p>

<pre><code>git clone https://github.com/Qiskit/qiskit-aqua
cd qiskit-aqua
pip install .
</code></pre>

<p>more detailed instructions are given on <a href=""https://qiskit.org/documentation/contributing_to_qiskit.html#installing-aqua-from-source"" rel=""nofollow noreferrer"">Qiskit's webpage</a>.</p>

<p>As to why you're getting this error: This comes from a change in Qiskit Terra which resulted in an incompatibility with the current implementation in Qiskit Aqua. That was fixed <a href=""https://github.com/Qiskit/qiskit-aqua/commit/ecf62693ea82ae360beb2d017fdffe220f740f14"" rel=""nofollow noreferrer"">in this commit</a> on GitHub. This fix is in the master branch of the repository, however when you're installing via pip you're getting the last stable version, where this fix is not yet included. With the next release of Aqua (this will be 0.7.0) this bug is resolved in the pip version, too.</p>
",4/14/2020 20:48,Errors,"The user is encountering an error while running a Qiskit Aqua sample script after updating their Qiskit version, which falls under the category of Errors",Errors,,,,Errors,
11562.0,How to use ApplyToEach when operation has parameters?,"<p><strong>Problem</strong></p>

<p>Apply a global phase -1 to all qubits <code>x : Qubit[]</code>.</p>

<p><strong>My solution</strong></p>

<p><code>ApplyToEach(R, PauliI, 2.0 * PI(), x)</code></p>

<p>However this yields a syntax error.</p>

<p>From the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applytoeach"" rel=""nofollow noreferrer"">ApplyToEach doc</a>, it works if the operation has no parameters:</p>

<pre><code>using (register = Qubit[3]) {
    ApplyToEach(H, register);
}
</code></pre>

<p>Thank you for your expertise. Happy qubitting!</p>
",<q#>,4/15/2020 4:19,11563.0,11563.0,"<p>You need to use <a href=""https://docs.microsoft.com/en-us/quantum/language/expressions#partial-application"" rel=""nofollow noreferrer"">partial application</a> to specify the rest of the parameters passed to the R gate. The result of partial application will be a gate that takes a single qubit as an argument, and <code>ApplyToEach</code> will be able to apply it to each element of the array:</p>



<pre><code>using (register = Qubit[3]) {
    let globalPhaseGate = R(PauliI, 2.0 * PI(), _);
    ApplyToEach(globalPhaseGate, qs);
}
</code></pre>

<p>You can also write this shorter, without using an extra constant to name the gate that is the result of partial application:</p>



<pre><code>using (register = Qubit[3]) {
    ApplyToEach(R(PauliI, 2.0 * PI(), _), register);
}
</code></pre>
",4/15/2020 5:51,Tooling,The question is asking how to apply a global phase of -1 to all qubits using Q#. This is a tooling question because it requires knowledge of the specific features and capabilities of the Q# programming language.,Tooling,,,,Tooling,
11568.0,Can I learn Quantum Programming and then go back to learn the Mathematics / Physics behind it later?,"<p>Learning from the ground up (while great) is an overdose of the mathematics behind quantum computing and is taking way too long to grasp.</p>

<p>I have a Computer Science / Programming background. I am happy to learn the programming aspects and then go back and learn the math behind it or learn the background math whenever it is necessary while programming.</p>

<p>I started with MacMahon's book and now on Nielsen and Chuang.. but I feel it is taking longer to get to the application layer.</p>
",<algorithm><resource-request><classical-computing>,4/16/2020 7:38,11570.0,11570.0,"<p>Quantum computing is completely different paradigm in comparison with classical computers. Therefore an approach to programming quantum computers is different as well. It is not only about learning a new programming language but also about understanding underlying technology. Currently, there is only a little abstraction between quatum algorithms (programs) and quantum hardware. Nowadays, programming a quantum computer is similar to approach used in 1950's when computers were programmed in assembler or even microinstructions (what is different that we have common quantum gates). </p>

<p>There are some higher programming languages (for example Qiskit based on Python) helping you to load data into a quantum computer and postprocess results. However, quantum algorithm is still expressed on quantum gates level. </p>

<p><strong>Overall, to be able to program quantum computer and understand why you do so, you should learn at least basic mathematical background of quantum computing.</strong></p>
",4/16/2020 8:06, Learning,"The user is expressing a preference for a more practical and application-oriented approach to learning quantum computing, focusing on programming aspects first before delving into the mathematical foundations. This falls under the learning category as it pertains to the user's learning approach and preferences.",Learning,,,, Learning,
11610.0,Why don't I get what I expect when measuring with respect to a different basis?,"<p><span class=""math-container"">$\newcommand{\bra}[1]{\left&lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&gt;}\newcommand{\bk}[2]{\left&lt;#1\middle|#2\right&gt;}\newcommand{\bke}[3]{\left&lt;#1\middle|#2\middle|#3\right&gt;}$</span>
If I make a rotation of <span class=""math-container"">$\frac{\pi}{4}$</span> around the x axis, starting from <span class=""math-container"">$\ket{0}$</span>, I expect <span class=""math-container"">$\alpha = \frac{\sqrt{2 + \sqrt{2}}}{2}$</span> and <span class=""math-container"">$\beta= \frac{\sqrt{2 - \sqrt{2}}}{2}$</span> when measured with respect to the computational basis states of <span class=""math-container"">$\ket{0}$</span> and <span class=""math-container"">$\ket{1}$</span>. I can verify this is correct empirically using a quantum simulator. I want to measure with respect to new basis states <span class=""math-container"">$\ket{+}$</span> and <span class=""math-container"">$\ket{-}$</span>, defined in <em>Quantum Computation and Quantum Information</em> as follows <span class=""math-container"">$\ket{+} \equiv \frac{\ket{0}+\ket{1}}{\sqrt{2}}$</span>, <span class=""math-container"">$\ket{-} \equiv \frac{\ket{0}-\ket{1}}{\sqrt{2}}$</span>, and corresponding to the poles of the x axis of the Bloch sphere. </p>

<p>Looking at the Bloch sphere, I would expect to get <span class=""math-container"">$\ket{+}$</span> half of the time, and <span class=""math-container"">$\ket{-}$</span> the other half, and I have been able to empirically verify this. However, according to the mathematics presented in the aforementioned book, I should be able to express this state <span class=""math-container"">$\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$</span>, with the <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> previously mentioned, as follows: </p>

<p><span class=""math-container"">$$\ket{\psi} = \alpha\ket{0} + \beta\ket{1} = \alpha\frac{\ket{+} + \ket{-}}{\sqrt{2}} + \beta\frac{\ket{+} - \ket{-}}{\sqrt{2}} = \frac{\alpha + \beta}{\sqrt{2}}\ket{+} + \frac{\alpha -\beta}{\sqrt{2}}\ket{-}$$</span></p>

<p>This math seems sound to me, however if I attempt to translate to this new basis using my <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span>, I get</p>

<p><span class=""math-container"">$$ \frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{+} + \frac{\sqrt{2+\sqrt{2}} -\sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{-} $$</span></p>

<p>Since <span class=""math-container"">$\left(\frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\right)^2 \approx 0.85$</span> this is not at all what I expect from looking at the Bloch sphere, and does not match what I am able to demonstrate empirically. What am I missing?</p>

<p>For reference, the important bit of my Q# code I've been using to test this is:</p>

<pre><code>Rx(PI()/4.0, qubit);
set state = Measure([PauliX], [qubit]);
</code></pre>
",<quantum-state><mathematics><nielsen-and-chuang><q#><superposition>,4/19/2020 14:45,11613.0,11613.0,"<p>I think there should be <span class=""math-container"">$-i$</span> in the expression for <span class=""math-container"">$\beta$</span>:</p>

<p><span class=""math-container"">\begin{equation}
R_x\left(\frac{\pi}{4}\right) |0\rangle= 
\begin{pmatrix}
\cos\left(\frac{\pi}{8}\right) &amp; -i \sin\left(\frac{\pi}{8}\right) \\
-i \sin\left(\frac{\pi}{8}\right) &amp; \cos\left(\frac{\pi}{8}\right)
\end{pmatrix} 
\begin{pmatrix} 1 \\ 0\end{pmatrix} = \\
=\frac{\sqrt{2 + \sqrt{2}}}{2} |0\rangle - i \frac{\sqrt{2 - \sqrt{2}}}{2} |1\rangle
\end{equation}</span></p>

<p>So, we will have:</p>

<p><span class=""math-container"">$$|\psi\rangle = \frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |+\rangle +  \frac{\sqrt{2 + \sqrt{2}} + i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |-\rangle$$</span></p>

<p>Then:</p>

<p><span class=""math-container"">$$\left|\frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}}\right|^2 = 0.5 $$</span></p>
",4/19/2020 16:29,Conceptual,The question is about understanding the mathematical representation of quantum states in different bases and why the expected results don't match the theoretical calculation when measuring in the new basis. It involves a conceptual understanding of quantum states and basis transformations.,Conceptual,,,,Conceptual,
11620.0,How to create states in Qiskit using complex phase angles?,"<p>How do we create an arbitrary vector of the following form in Qiskit?</p>

<p>Say, we want to initialize a qubit with a vector,
<span class=""math-container"">$$
\vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle
$$</span></p>

<p>If I put it in the form
<span class=""math-container"">$$
\vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle = cos(\frac{\theta}{2})|0&gt; + e^{i\phi}sin(\frac{\theta}{2})|1&gt;
$$</span> where <br>
<span class=""math-container"">$0 &lt; \theta &lt; \pi$</span> and <span class=""math-container"">$0 &lt; \phi &lt;2\pi$</span>
and then calculate <span class=""math-container"">$\theta$</span> and <span class=""math-container"">$\phi$</span></p>

<p>So,
<span class=""math-container"">$$
cos(\frac{\theta}{2}) = \frac{1+i}{\sqrt{3}}\\
e^{i\phi}sin(\frac{\theta}{2}) = - \frac{i}{\sqrt{3}}
$$</span>
Therefore,
<span class=""math-container"">$$
\theta = 2 * \arccos{\frac{1+i}{\sqrt{3}}} \\
\phi = i * ln(\frac{- \frac{i}{\sqrt{3}}}{sin(\frac{\theta}{2})})
$$</span></p>

<p>Now, I am using the following code..</p>

<pre><code>#We create the quantum state manually first
arb_quantum_state = ((1+1.j)/math.sqrt(3))*ket_0 - (1.j/math.sqrt(3))*ket_1
print(arb_quantum_state)

theta = 2*cmath.acos((1+1.j)/cmath.sqrt(3))
print('theta : ',theta)
sinValue = cmath.sin(theta/2)
print(sinValue)
phase = -1*(1.j/cmath.sqrt(3))/sinValue
phi = cmath.log(phase)/1.j
print('phi : ',phi)

# Use these theta and phi to create the circuit
circ = QuantumCircuit(1,1)
#Verify why complex values are not allowed
#circ.u3(theta.real,phi.real,0,0)
circ.u3(theta,phi,0,0)

results = execute(circ, backend=Aer.get_backend('statevector_simulator')).result()
quantum_state = results.get_statevector(circ, decimals=3)
print (quantum_state)
</code></pre>

<p>The above code creates the gate alright, but the execute function is returning the following error,</p>

<pre><code>TypeError: can't convert complex to float
</code></pre>

<p>However, if I use just the real values of theta and phi, then the execute function returns a state vector, which is different than the one it should be.</p>
",<qiskit><programming><quantum-state>,4/20/2020 12:52,11621.0,11621.0,"<p>The problem is that you're trying to equate <span class=""math-container"">$\cos(\theta/2)$</span> (a real number) with <span class=""math-container"">$(1+i)/\sqrt{3}$</span> (a complex number). The way around this is you need to take into account a global phase <span class=""math-container"">$\gamma$</span> such that
<span class=""math-container"">$$
e^{i\gamma}|\psi\rangle=\cos\frac{\theta}{2}|0\rangle+e^{i\phi}\sin\frac{\theta}{2}|1\rangle.
$$</span>
To do this, it helps to express your initial state as complex exponentials:</p>
<p>As a first step your state can be reduced to
<span class=""math-container"">$$
|\psi\rangle=\sqrt{\frac{2}{3}}\left(\frac{1}{\sqrt{2}} + \frac{1}{\sqrt{2}}i\right)|0\rangle+\frac{1}{\sqrt{3}}\left(0 - i*1\right)|1\rangle
$$</span>
Then to,
<span class=""math-container"">$$
|\psi\rangle=\sqrt{\frac{2}{3}}e^{i\pi/4}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{3}{2}\pi}|1\rangle
$$</span>
so that we can rewrite it as
<span class=""math-container"">$$
|\psi\rangle=e^{i\pi/4}\left(\sqrt{\frac{2}{3}}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{5}{4}\pi}|1\rangle\right).
$$</span>
Now you can easily see that
<span class=""math-container"">$$
\cos\frac{\theta}{2}=\sqrt{\frac{2}{3}},\qquad \phi=\frac{5\pi}{4},\qquad \gamma=\frac{\pi}{4}.
$$</span></p>
",4/20/2020 13:14,Errors,The user is encountering an error related to complex numbers when attempting to create an arbitrary quantum state in Qiskit and use it in a quantum circuit. The issue falls under the category of Errors as it involves resolving a specific problem with the code.,Errors ,,,,Errors,
11768.0,Using entropy_mutual function in QuTiP,"<p>I am trying to calculate mutual entropies using QuTiP, but I am being unsuccessful so far. More specifically, I consider a 2^n x 2^n matrix representing the density operator of a n-qubit bipartite system AB made of system A (first m &lt; n qubits) and B (remaining n-m qubits). No tutorial nor material on the internet addressed this specific task.</p>

<p>For simplicity, let us consider a 1-qubit system A and a 2-qubit system B and a density operator of dimension 8x8 representing AB in computational basis.</p>

<p>More practically in python, let 
<code>rhoAB = Qobj=(np.random.rand(8,8))</code>, and assume that this is a valid density operator.</p>

<p>How should I call <em>entropy_mutual</em> so that I can get this measure between A and B, in particular, regarding the arguments <em>selA</em> and <em>selB</em>? Ideally, I would call something like <code>entopy_mutual(rhoAB, selA=[1], selB=[2,3])</code> but this not the approach how the function interprets the subsystems and their respective dimensions.</p>
",<programming><entropy><qutip>,4/30/2020 13:25,11795.0,11795.0,"<p>Best to look at the source code when the documentation isn't helpful enough. The definition of entropy_mutual is </p>

<pre><code>def entropy_mutual(rho, selA, selB, base=e, sparse=False):
    """"""
    Calculates the mutual information S(A:B) between selection
    components of a system density matrix.

    Parameters
    ----------
    rho : qobj
        Density matrix for composite quantum systems
    selA : int/list
        `int` or `list` of first selected density matrix components.
    selB : int/list
        `int` or `list` of second selected density matrix components.
    base : {e,2}
        Base of logarithm.
    sparse : {False,True}
        Use sparse eigensolver.

    Returns
    -------
    ent_mut : float
       Mutual information between selected components.

    """"""
    if isinstance(selA, int):
        selA = [selA]
    if isinstance(selB, int):
        selB = [selB]
    if rho.type != 'oper':
        raise TypeError(""Input must be a density matrix."")
    if (len(selA) + len(selB)) != len(rho.dims[0]):
        raise TypeError(""Number of selected components must match "" +
                        ""total number."")

    rhoA = ptrace(rho, selA)
    rhoB = ptrace(rho, selB)
    out = (entropy_vn(rhoA, base, sparse=sparse) +
           entropy_vn(rhoB, base, sparse=sparse) -
           entropy_vn(rho, base, sparse=sparse))
    return out
</code></pre>

<p>So we see selA and selB are passed as arguments to compute the partial trace. I am not too familiar with qutip but here is an example computing <span class=""math-container"">$S(A:B)$</span> for <span class=""math-container"">$\rho_{AB}$</span> where <span class=""math-container"">$A$</span> is a qubit system and <span class=""math-container"">$B$</span> is a two-qubit system. </p>

<pre><code>import qutip as qtp
# note there is a rand_dm function
# We should also let qutip know how are systems are partitioned
# This is so it knows how to correctly compute the partial trace
rho = qtp.rand_dm(8, dims=[[2,4],[2,4]])
qtp.entropy_mutual(rho,0,1)
</code></pre>

<p>With the above example we could also specify the second system as two-qubits instead of a four dimensional system i.e.</p>

<pre><code>rho = qtp.rand_dm(8, dims=[[2,2,2],[2,2,2]])
qtp.entropy_mutual(rho,0,[1,2])
</code></pre>
",05/01/2020 16:38,Tooling," The user is asking about how to use the entropy_mutual function in QuTiP, a specific quantum computing software tool, to calculate mutual entropies for a bipartite system. ",Tooling,,,,Tooling,
11778.0,Access IBM Q processors from MatLab,"<p>Qiskit allows a user to directly access IBM Q quantum processors (both real ones and simulator). Each user is given a <em>personal code</em> which is entered into source code and serves as a login to the IBM Q platform.</p>

<p><strong>My question is:</strong> Is there a similar possibility in MatLab? In other words, is there any module/code in MatLab allowing to access IBM Q processors?</p>
",<programming><ibm-q-experience><matlab>,4/30/2020 21:44,11782.0,11782.0,"<p>As far as I know, there is no MatLab library for the IBM quantum experience. It may be possible to call <a href=""https://www.mathworks.com/help/matlab/getting-started-with-python.html"" rel=""nofollow noreferrer"">Qiskit from Matlab</a></p>
",4/30/2020 23:58,Tooling,"The user is inquiring about the availability of a module or code in MATLAB that would allow them to access IBM Q quantum processors, similar to how Qiskit provides this functionality. This falls under the category of tooling as it pertains to the tools and software usage in quantum programming.",Tooling,,,,Tooling,
11827.0,How to correctly define $U_\omega$ for Grover's search algorithm,"<p>I am working on Grover's algorithm and I am trying to implement the algorithm. I am following the Microsoft quantum katas and I finished and did everything correctly. I am trying to implement the algorithm for a specific case, but I am stuck writing the marking oracle (defined as <span class=""math-container"">$U_\omega$</span> on the Wikipedia page). I tried to look into the kata tests but I wasn't very successful.</p>

<p>The goal of the operator is to flip the sign of a state if it is correct. The mathematical representation for this is : <span class=""math-container"">$$|x\rangle \, \overset{U_\omega} \longrightarrow \, (-1)^{f(x)}|x\rangle$$</span>This is the problem, I do not know how to implement this sign flipping. Is it done case by case ? Or is the a general ""formula"" to do so ?</p>

<p>Thanks for reading.</p>
",<programming><mathematics><grovers-algorithm>,05/03/2020 17:16,11829.0,11829.0,"<p>There are two types of oracles you can implement (Wikipedia article happily uses them interchangeably, which I don't think helps a lot): a marking oracle and a phase oracle.</p>

<p>Marking oracles are the ones that flip the state of the qubit <span class=""math-container"">$|y\rangle$</span> if <span class=""math-container"">$f(x) = 1$</span>:</p>

<p><span class=""math-container"">$$|x\rangle|y\rangle \, \overset{U_\omega} \longrightarrow \, |x\rangle|y \oplus f(x)\rangle$$</span></p>

<p>Marking oracles are much easier to build using reversible approach: break down your function into logical steps (such as AND, OR and NOT), implement each step in a reversible manner (using X, CNOT and Toffoli gates) and combine them. <a href=""https://github.com/microsoft/QuantumKatas/tree/master/SolveSATWithGrover"" rel=""nofollow noreferrer"">SolveSATWithGrover</a> and <a href=""https://github.com/microsoft/QuantumKatas/tree/master/GraphColoring"" rel=""nofollow noreferrer"">GraphColoring</a> show how to take a problem and implement it this way.</p>

<p>Phase (or sign flipping) oracles are the ones that flip the sign of the register <span class=""math-container"">$|x\rangle$</span> if <span class=""math-container"">$f(x) = 1$</span>:</p>

<p><span class=""math-container"">$$|x\rangle \, \overset{U_\omega} \longrightarrow \, (-1)^{f(x)}|x\rangle$$</span></p>

<p>Grover's search algorithm uses phase oracles, so you need to convert a marking oracle into a phase oracle using phase kickback trick (if you follow the katas, that's task 1.4 from <a href=""https://github.com/microsoft/QuantumKatas/tree/master/GroversAlgorithm"" rel=""nofollow noreferrer"">GroversAlgorithm kata</a>).</p>
",05/03/2020 18:28,Conceptual,"The user is seeking an understanding of how to implement the marking oracle (denoted as U?) in Grover's algorithm, specifically regarding how to flip the sign of a state if it is correct. This question pertains to the underlying concepts and principles of quantum programming, falling under the conceptual category.",Conceptual,,,,Conceptual,
11886.0,How can I make qiskit output raw data?,"<p>I am new to quantum computing, and I want to make a program to output 0 or 1 randomly by Hadamard gate, and use that information to make a GUI interface. For example, a coin flip program that output ""Tail"" when it is 1, and ""Head"" when it is 0. However, when I try to get raw data by <code>job.result(job)</code>, I get the information of the result instead. By the way, here is the code:</p>

<pre><code>from qiskit import *
simulator = Aer.get_backend('qasm_simulator')
qr = QuantumRegister(1)
cr = ClassicalRegister(1)
circuit = QuantumCircuit(qr, cr)
circuit.h(qr[0])
circuit.measure(qr, cr)
job = execute(circuit, backend = simulator, shots=1024)
a = job.result(job) #the problematic code
print(a)
</code></pre>

<p>I use Qiskit with Python, and do not use Jupyter notebooks.</p>
",<qiskit><programming><hadamard>,05/07/2020 11:03,11887.0,11887.0,"<p>You need to do <code>.get_counts()</code> to get a dictionary of the counts returned by the circuit. You would do this as follows</p>

<pre><code>job = execute(circuit, backend = simulator, shots=100)
result = job.result()
counts_dict = result.get_counts()
</code></pre>

<p>Using your circuit and this code, <code>counts_dict</code> will look something like <code>{'0':497, '1':503}</code>. From there you might want to extract the key which has a higher value to be the result of your coin flip.</p>
",05/07/2020 11:30,Errors,The user is encountering an issue with their code where they expect to get raw data from a quantum program but are instead getting information about the result. This falls under the category of errors in quantum program development.,Errors,,,,Errors,
11913.0,Generic matrix exponential in Q#,"<p>I am trying to find a way to implement a unitary transformation in Q# that implements e^(iA) where A is a square matrix. However, I only found ways to do this in Q# if A can be represented as a tensors of Paulis (the Exp operation: <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.primitive.exp"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.primitive.exp</a> or using a PauliEvolutionSet when trying to do Hamiltonian simulation: <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.simulation.paulievolutionset"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.simulation.paulievolutionset</a>).</p>

<p>Does anyone know how to do this for a generic matrix A? If for example you want to use a 8x8 matrix, you can't express it in terms of tensors of Paulis...</p>

<p>Thanks in advance for the help!</p>
",<programming><q#><hamiltonian-simulation><matrix-representation>,05/08/2020 10:27,11972.0,11972.0,"<p>One thing to point out is that because the Paulis form a basis, you <em>can</em> actually represent any <span class=""math-container"">$2^n \times 2^n$</span> matrix in terms of a sum of tensors of Paulis, i.e., members of the <span class=""math-container"">$n$</span>-qubit Pauli group. That is, you can write any <span class=""math-container"">$8 \times 8$</span> matrix <span class=""math-container"">$A$</span> as a sum of the form
<span class=""math-container"">$$A =\sum_{i,j,k}h_{ijk}\ \sigma_i\otimes\sigma_j\otimes\sigma_k$$</span>
where <span class=""math-container"">$h_{ijk}$</span> are the coefficients in the Pauli basis. The answer to <a href=""https://quantumcomputing.stackexchange.com/questions/8725/can-arbitrary-matrices-be-decomposed-using-the-pauli-basis"">this related question</a> describes how to solve for these coefficients.</p>

<p>Now, once you have expressed <span class=""math-container"">$A$</span> in the Pauli basis, you can use the Q# operations you mention to implement the evolution. Some more background on implementing this in Q# is available at <a href=""https://docs.microsoft.com/en-us/quantum/libraries/standard/data-structures#dynamical-generator-modeling"" rel=""nofollow noreferrer"">this link</a>. The general idea is that once you have expressed the matrix <span class=""math-container"">$A$</span> in the Pauli basis, you can now use something like a <a href=""https://docs.microsoft.com/en-us/quantum/libraries/chemistry/concepts/algorithms#trottersuzuki-formulas"" rel=""nofollow noreferrer"">TrotterâSuzuki expansion</a> to approximately express the exponential <span class=""math-container"">$e^{iA}$</span> as a product of exponentials of Paulis, which can then in turn be implemented on a quantum computer (and also via built-in Q# tools such as <code>Exp</code> and <code>PauliEvolutionSet</code>).</p>

<p>Why doesn't a language like Q# include a built-in library for implementing a matrix exponential <span class=""math-container"">$e^{iA}$</span> for some general matrix <span class=""math-container"">$A$</span>? Essentially because such an operation is, in general, extremely inefficient to implement on a quantum computer. To understand why, note that for a general <span class=""math-container"">$n$</span>-qubit unitary, there are <span class=""math-container"">$4^n$</span> coefficients required to represent it in a basis like the Pauli basis, which means that your resulting circuit depth will be on the order of <span class=""math-container"">$4^n$</span> -- far too deep to be practical for anything beyond very small systems.</p>

<p>The exception is the case where the matrix <span class=""math-container"">$A$</span> has ""sparsity"" in some representation -- for example, if only a constant number of the <span class=""math-container"">$4^n$</span> coefficients in the Pauli basis are non-zero. In that case, the circuit resulting from a Trotter-Suzuki decomposition would have only constant depth, rather than going as <span class=""math-container"">$4^n$</span>.</p>
",05/11/2020 18:05,Tooling,"The user is asking about how to implement a specific unitary transformation in Q#, which is a question about the usage of specific software tools in quantum computing.", Tooling,,,,Tooling,
11932.0,How to make circuit for n-control Z gate( i.e $C^3Z$ )?,"<p>I am trying to make circuit for <span class=""math-container"">$C^3Z$</span> gate I have seen a circuit for <span class=""math-container"">$C^2Z$</span> or <span class=""math-container"">$CCZ$</span> gate made by using <span class=""math-container"">$CCX$</span> gate so is there any way to make circuit for <span class=""math-container"">$C^3Z$</span> in this similar manner( i.e by using <span class=""math-container"">$CCX$</span> gate) or i have to do something different then this method Fig. is below for <span class=""math-container"">$CCZ$</span> gate
<a href=""https://i.stack.imgur.com/4gQ6y.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4gQ6y.jpg"" alt=""enter image description here""></a></p>
",<qiskit><programming><circuit-construction><ibm-q-experience>,05/09/2020 19:06,11933.0,11933.0,"<p>The circuit you showed above for the double-controlled <span class=""math-container"">$Z$</span> gate can be extended to a triple-controlled <span class=""math-container"">$Z$</span> by adding an extra Toffoli and ancilla:</p>

<p><a href=""https://i.stack.imgur.com/bzEFpm.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/bzEFpm.jpg"" alt=""enter image description here""></a></p>

<p>Qiskit offers such circuits readily in the <a href=""https://qiskit.org/documentation/apidoc/circuit_library.html"" rel=""noreferrer"">circuit library</a>, where you have many different possibilities to implement your multi-controlled Z gate.</p>

<p>Using the <strong>MCMT</strong> (multi-controlled multi-target circuit) is one option.
You can either use the v-chain version with ancillas, which produces the same circuit as above:</p>



<pre><code>from qiskit.circuit.library import MCMTVChain
c3z = MCMTVChain('z', num_ctrl_qubits=3, num_target_qubits=1)
c3z.draw(output='mpl')
</code></pre>

<p><a href=""https://i.stack.imgur.com/bzEFpm.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/bzEFpm.jpg"" alt=""enter image description here""></a></p>

<p>Or you can use an ancilla-free version:</p>



<pre><code>from qiskit.circuit.library import MCMT
c3z = MCMT('z', num_ctrl_qubits=3, num_target_qubits=1)
c3z.decompose().decompose().draw(output='mpl')
</code></pre>

<p><a href=""https://i.stack.imgur.com/YCz11.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/YCz11.jpg"" alt=""enter image description here""></a></p>

<p>In principle you there's always a tradeoff in the number of ancilla qubits you can use and the depth of the circuit. More ancillas usually allows to use less gates, but more ancillas are costly or may not be available at all! </p>

<h3>Excursion to multi-controlled <span class=""math-container"">$X$</span> gates</h3>

<p>Since you know that <span class=""math-container"">$Z = HXH$</span> another possibility would be to use the multi-controlled <span class=""math-container"">$X$</span> gate from Qiskit. Since there are different methods on how the multi-controlled <span class=""math-container"">$X$</span> can be implemented you can choose the <em>mode</em> you want as either of <code>'noancilla' 'recursion' 'v-chain' 'v-chain-dirty-ancilla'</code>:</p>

<pre><code>from qiskit import QuantumCircuit

noancilla = QuantumCircuit(4)
noancilla.h(3)  # H on target qubit
noancilla.mcx([0, 1, 2], 3, mode='noancilla')
noancilla.h(3)  # again H on target qubit
noancilla.draw()


q_0: ââââââââ âââââââ
            â       
q_1: ââââââââ âââââââ
            â       
q_2: ââââââââ âââââââ
     ââââââââ´âââââââ
q_3: â¤ H ââ¤ X ââ¤ H â
     âââââââââââââââ
</code></pre>

<p>The recursion mode uses only one ancilla and recursively splits the number of controls until we have a 3 or 4 controls for which the controlled-X is hardcoded. Here, since you only have 3 controls, it does not need an ancilla (since Qiskit knows a concrete 3-controlled X implementation). But if you have more than 4 qubits you need an ancilla.</p>

<pre><code>n = 5  # number of controls
recursion = QuantumCircuit(n + 1 + 1)  # one for target, one as ancilla
recursion.h(n)  # H on target qubit
recursion.mcx(list(range(n)), n, ancilla_qubits=[n + 1], mode='recursion')
recursion.h(n)  # again H on target qubit
recursion.decompose().draw()

q_0: âââââââââââââââ ââââââââââ âââââââââââââââââââ
                   â         â                   
q_1: âââââââââââââââ ââââââââââ âââââââââââââââââââ
                   â         â                   
q_2: âââââââââââââââ ââââââââââ âââââââââââââââââââ
                   â         â                   
q_3: âââââââââââââââ¼âââââ âââââ¼âââââ ââââââââââââââ
                   â    â    â    â              
q_4: âââââââââââââââ¼âââââ âââââ¼âââââ ââââââââââââââ
     ââââââââââââ  â  âââ´ââ  â  âââ´ââââââââââââââ
q_5: â¤ U2(0,pi) ââââ¼âââ¤ X ââââ¼âââ¤ X ââ¤ U2(0,pi) â
     âââââââââââââââ´âââââ¬âââââ´âââââ¬ââââââââââââââ
q_6: âââââââââââââ¤ X ââââ âââ¤ X ââââ ââââââââââââââ
                 âââââ     âââââ                 
</code></pre>

<p>The v-chain implementation is similar to the <span class=""math-container"">$Z$</span> gate implementations with the Toffolis. Here you need <span class=""math-container"">$n - 2$</span> ancillas, if <span class=""math-container"">$n$</span> is the number of controls. </p>

<pre><code>vchain = QuantumCircuit(n + 1 + n - 2)  # needs n - 2 ancillas
vchain.h(n)  # H on target qubit
vchain.mcx(list(range(n)), n, ancilla_qubits=list(range(n+1, 2*n-1)), mode='v-chain')
vchain.h(n)  # again H on target qubit


q_0: ââââââââ ââââââââ
            â        
q_1: ââââââââ ââââââââ
            â        
q_2: ââââââââ ââââââââ
     ââââââââ´ââââââââ
q_3: â¤ H ââ¤0   ââ¤ H â  # if you decompose this you'll see
     ââââââ  X ââââââ  # the exact implementation, try
q_4: ââââââ¤1   ââââââ  # vchain.decompose().decompose().draw()
          ââââââ     
</code></pre>
",05/09/2020 21:53,Tooling ,The question is about how to implement a specific quantum gate (the C 3 Z gate) using a specific circuit element (the CCX gate).,Tooling ,,,,Tooling ,
11934.0,ModuleNotFoundError: No module named 'qiskit.circuit.library',"<p>I am importing <code>from qiskit.circuit.library import MCMTVChain</code> on python IDLE editor but it showing error <code>ModuleNotFoundError: No module named 'qiskit.circuit.library'</code> although it's working fine on <code>google colab</code>. Also why Qiskit does not work properly on python IDLE it's show lots of other error not just this one?</p>
",<qiskit><programming><circuit-construction><ibm-q-experience>,05/10/2020 02:11,11936.0,11936.0,"<p>You most probably haven't installed the qiskit module. Qiskit can be installed via :</p>

<pre><code>pip install qiskit
</code></pre>

<p>Try the following commands in command prompt, one of them should work (if your PATH variables are appropriately set):</p>

<pre><code>py -m pip install qiskit
</code></pre>

<p>Or</p>

<pre><code>python -m pip install qiskit
</code></pre>

<p>Or if you have more than one python versions, you can try:</p>

<pre><code>py -'version number like 3.7' pip install qiskit
</code></pre>

<p>without the quotes.</p>

<p>This should install the qiskit module and then you can import it.</p>
",05/10/2020 05:47,Errors,The user is encountering import errors when trying to use a specific module from Qiskit in a Python IDLE editor. This falls under the category of Errors as it pertains to issues with the functionality and compatibility of the software environment.,Errors,,,,Errors,
11987.0,Inner product of states in Q#,"<p>I have a state <span class=""math-container"">$|x\rangle$</span> and I want to get the expected result when measuring observable <span class=""math-container"">$A$</span> (i.e. get the result of <span class=""math-container"">$\langle x| A | x \rangle$</span>). In my case <span class=""math-container"">$A$</span> can be any of the Pauli gates. Does anyone know how to do this in <code>Q#</code>? There doesn't seem to be an inner product function in the libraries.</p>

<p>Thanks for the help!</p>
",<q#>,05/12/2020 15:19,11988.0,11988.0,"<p>It sounds like you're really asking about how to <em>measure</em> in a given Pauli basis. (I'm assuming for simplicity that you are working with only a single qubit, but the below is generalizable to multiple qubits as well.)</p>

<p>Q# has a <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.measure"" rel=""nofollow noreferrer"">Measure operation</a> which performs a measurement in a given Pauli basis. For example, if you have a <code>Qubit</code> object <code>q</code> in some state <span class=""math-container"">$|\psi\rangle$</span> and you want to measure it in the <span class=""math-container"">$X$</span> basis, you can write:</p>

<pre><code>   let result = Measure([PauliX], [q]);
</code></pre>

<p>Here <code>result</code> will be either <code>Zero</code> or <code>One</code>. If you want to then estimate the expectation value of the measurement, you would need to repeat your full operation (including whatever you did to prepare your qubit in the state <span class=""math-container"">$|\psi\rangle$</span>) many times and take an average of the measurement results.</p>
",05/12/2020 17:39,Tooling , The question is asking how to use a particular tool (Q#) to perform a specific task (calculate the expected value of a Pauli gate on a given state).,Tooling ,,,,Tooling ,
11995.0,Classical computations from restricted quantum gates,"<p>The CNOT gate together with phase shift gates for all possible angles are not universal for quantum computing. </p>

<p>Are they also not universal for classical (reversible) computing?</p>

<p>Is it possible to characterize the set of classical Boolean functions that can be obtained using this set of gates?</p>
",<quantum-gate><circuit-construction><classical-computing>,05/12/2020 23:50,11997.0,11997.0,"<p>Firstly, let us assume that we are restricted to measurements in the computational basis, i.e. outcomes of <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span>. </p>

<p>Next, since neither gates create any superposition (when applied to computational basis states) we can observe that without a Hadamard gate, our qubit state is always in a single computational basis state.</p>

<p>Hence, we can see that the computational power of our CNOT + phase gate set is not greater than that of just a simple CNOT, and so we can reduce the initial problem to simply considering the computational power of the classical CNOT. </p>

<p>So, in answer to the first question, a quick bit of googling <a href=""https://www.wikiwand.com/en/Toffoli_gate#/Universality_and_Toffoli_gate"" rel=""nofollow noreferrer"">reveals</a> the answer is no, since the CNOT gate is not universal for classical computation, reversible or otherwise.</p>

<p>In answer to your second question, I guess the best answer I can give is simply that it is the same as the set produceable by circuits of CNOTs. I am not sure if this set of Boolean functions is well characterised or not, but perhaps this is worth posing in the <a href=""https://scicomp.stackexchange.com/"">CompSci stack exchange</a>.</p>
",5/13/2020 5:05,Theoretical,"The user is asking theoretical questions about the universality of gates in both quantum and classical (reversible) computing, as well as inquiring about the set of classical Boolean functions that can be obtained using a specific set of gates. These questions pertain to theoretical concepts and principles in computing.",Theoretical,,,,Theoretical,
12073.0,How to reduce unnecessary waiting time when using IBM's backend?,"<p>I'm working with a program, which needs iterations of quantum computation like this</p>



<pre><code>def quantum(n):
    Grover(oracle).run(QuantumInstance(...))
    #n is input size associated with oracle, 
    #and some other components are omitted.

for n in range(0,10):
    start = time.time()
    quantum(n)
    end = time.time()
</code></pre>

<p>Now I have to wait for hours to run this on the 16-qubit quantum computer. So is there any way to pack all computation into one round?</p>
",<qiskit><programming><ibm-q-experience>,5/19/2020 8:41,12074.0,12074.0,"<p>Assuming your <code>quantum()</code> method creates a circuit, you can run lots of circuits in one go by using the <code>execute</code> command. For example <code>execute([grover_1, grover_2, grover_3], backed=my_backend)</code>.</p>
",5/19/2020 10:03,Tooling,"The question is asking how to use a particular tool (Grover's algorithm) to perform a specific task (search for a marked state in a database), and how to optimize the code for a specific hardware platform (16-qubit quantum computer",Tooling,,,,Tooling,
12080.0,Evaluating expectation values of operators in Qiskit,"<p>I'm wondering how in Qiskit one can calculate the expectation value of an operator given as a <code>WeightedPauli</code> (or, at least, of a single <code>Pauli</code> operator...) in a certain state (given as a <code>QuantumCircuit</code> object â â meaning that the actual state is the result of the action of this circuit on the computational basis state). I would like the inputs of such a procedure to be <code>float</code>s, not <code>Parameter</code>s (it is an essential requirement â I'm using an external library to form the circuit for each set of parameters, and then converting it gate-by-gate to Qiskit format).</p>

<p>This would be useful if, say, we wanted to manually implement VQE, and for that needed a function calculating the expectation value of the Hamiltonian on a quantum computer. More importantly, we would need this for implementing generalizations of VQE, such as subspace search.</p>

<p>I guess, <code>PauliBasisChange</code> may be involved...</p>
",<qiskit><programming>,5/19/2020 12:04,12210.0,12210.0,"<p><strong>Note:</strong> This post is a bit older and Qiskit Aqua is now deprecated. Replace all occurences of <code>qiskit.aqua.operators</code> with <code>qiskit.opflow</code> to be compatible with Qiskit Terra 0.17.0 and above.</p>
<p>The operators in Qiskit Aqua allow the evaluation of expectation values both exactly (via matrix multiplication) or on shot-based sampling (closer to real quantum computers). The basic principle is the same both times, it only differs in how the expectation value is evaluated in the end.</p>
<p>First, you need to define the operator <span class=""math-container"">$O$</span> you're interested in and the state <span class=""math-container"">$|\psi\rangle$</span> with respect to which you want to compute the expecation value. So we're looking for
<span class=""math-container"">$$
E = \langle\psi|O|\psi\rangle.
$$</span>
In the code below we have <span class=""math-container"">$O$</span> = <code>op</code> and <span class=""math-container"">$|\psi\rangle$</span> = <code>psi</code>.
See also there for your use-case of a <code>WeightedPauliOperator</code>.</p>
<pre><code># you can define your operator as circuit
circuit = QuantumCircuit(2)
circuit.z(0)
circuit.z(1)
op = CircuitOp(circuit)  # and convert to an operator

# or if you have a WeightedPauliOperator, do
op = weighted_pauli_op.to_opflow()

# but here we'll use the H2-molecule Hamiltonian
from qiskit.aqua.operators import X, Y, Z, I
op =  (-1.0523732 * I^I) + (0.39793742 * I^Z) + (-0.3979374 * Z^I) \
    + (-0.0112801 * Z^Z) + (0.18093119 * X^X)

# define the state you w.r.t. which you want the expectation value
psi = QuantumCircuit(2)
psi.x(0) 
psi.x(1)

# convert to a state
psi = CircuitStateFn(psi)
</code></pre>
<p>There are now different ways to evaluate the expectation value. The straightforward, &quot;mathematical&quot;, approach would be to take the adjoint of <span class=""math-container"">$|\psi\rangle$</span> (which is <span class=""math-container"">$\langle\psi|$</span>) and multiply with <span class=""math-container"">$O$</span> and then <span class=""math-container"">$|\psi\rangle$</span> to get the expectation. You can actually do exactly this in Qiskit:</p>
<pre><code># easy expectation value, use for small systems only!
print('Math:', psi.adjoint().compose(op).compose(psi).eval().real)
</code></pre>
<p>to get</p>
<pre><code>Exact: -1.0636533199999998
</code></pre>
<p>This is only suitable for small systems though.</p>
<p>To use the simulators, and the also get the shot-based result, you can use the <code>PauliExpectation</code> (shots), <code>AerPauliExpectation</code> (exact) or <code>MatrixExpectation</code> (exact).
Here's how to do it:</p>
<pre><code>from qiskit import Aer
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn

# define your backend or quantum instance (where you can add settings)
backend = Aer.get_backend('qasm_simulator') 
q_instance = QuantumInstance(backend, shots=1024)

# define the state to sample
measurable_expression = StateFn(op, is_measurement=True).compose(psi) 

# convert to expectation value
expectation = PauliExpectation().convert(measurable_expression)  

# get state sampler (you can also pass the backend directly)
sampler = CircuitSampler(q_instance).convert(expectation) 

# evaluate
print('Sampled:', sampler.eval().real)  
</code></pre>
<p>which yields</p>
<pre><code>Sampled: -1.0530518430859401
</code></pre>
<p>This result varies if you execute multiple times.</p>
<p>For comparison, here the other methods to evaluate the expecation value</p>
<pre><code>expectation = AerPauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(backend).convert(expectation)  
print('Snapshot:', sampler.eval().real) 

expectation = MatrixExpectation().convert(measurable_expression)
sampler = CircuitSampler(backend).convert(expectation)  
print('Matrix:', sampler.eval().real) 
</code></pre>
<p>which produces</p>
<pre><code>Snapshot: -1.06365328
Matrix: -1.06365328
</code></pre>
<p>I hope that clarifies how to compute the expectation value!</p>
",5/27/2020 17:40,Tooling,"The user is asking about how to calculate the expectation value of an operator in a certain state using Qiskit, which is a question about the usage of specific software tools in quantum computing. ", Tooling,,,,Tooling,
12094.0,Tensor Product in Q#,"<p>Does anyone know how you can obtain a new state <code>|z&gt;</code> from two pre-existing states <code>|x&gt;</code> and <code>|y&gt;</code> using the Tensor product in <code>Q#</code>? i.e. <code>|z&gt; = |x&gt; â|y&gt;</code> ?</p>

<p>Thanks in advance for the help! </p>

<p>Edit: for clarity, the states that I am working with are   </p>

<p><span class=""math-container"">$|x\rangle = \frac{1}{\sqrt{2}} \sum^{3}_{j=0} \sin \frac{\pi (j + 0.5)}{4} |j\rangle$</span></p>

<p><span class=""math-container"">$|y\rangle = \sum^{1}_{i=0} b_i |i\rangle$</span> </p>

<p>where the <span class=""math-container"">$b_i$</span>'s are just real numbers.</p>
",<programming><q#><tensor-product>,5/20/2020 12:53,12098.0,12098.0,"<p>If you have an array of <code>Qubit</code> objects, and you prepare the individual qubits into arbitrary states, then the array effectively contains the tensor product of all of the original qubits.</p>

<p>To quickly illustrate what I mean:</p>

<pre><code>using (qubits = Qubit[2]) {
    // do something to prepare qubits[0] individually
    // do something to prepare qubits[1] individually

    // now the state of ""qubits"" is the tensor product of the two
    // individual qubit states that you prepared
}
</code></pre>

<p>This also generalizes if you're preparing groups of qubits within the array that you allocated.</p>
",5/20/2020 15:59,Conceptual,The user is inquiring about how to obtain a new quantum state by taking the tensor product of two pre-existing quantum states in Q#. This falls under the conceptual category as it pertains to understanding the concept and implementation of tensor product operations in quantum computing, Conceptual,,,,Conceptual,
12154.0,How to plot custom labels for quantum registers in Qiskit?,"<p>How can I plot custom labels for specific qubits on the left and right side similar to the picture shown here (A, B, Sum ...):</p>

<p><img src=""https://lahirumadushankablog.files.wordpress.com/2020/02/fulladder.jpg?w=616"" alt=""""></p>
",<qiskit><programming>,5/24/2020 0:56,12155.0,12155.0,"<p><strong>A partial answer.</strong></p>

<p>How to customize the labels of <code>QuantumRegister</code>s:</p>

<pre><code>from qiskit import *

red_qubit = QuantumRegister(1,'red')
blue_qubit = QuantumRegister(1, 'blue')
green_qubit = QuantumRegister(2, 'green')

circuit = QuantumCircuit(red_qubit, blue_qubit, green_qubit)

circuit.h(red_qubit[0])
circuit.x(blue_qubit[0])
circuit.x(green_qubit[0])
circuit.cx(red_qubit[0], blue_qubit[0])
circuit.cx(red_qubit[0], green_qubit[0])
circuit.cx(red_qubit[0], green_qubit[1])

%matplotlib inline
circuit.draw(output=""mpl"")
</code></pre>

<p>The output:</p>

<p><img src=""https://i.stack.imgur.com/J1LD9.png"" width=""350"" /></p>
",5/24/2020 5:51, Tooling,"The user is asking about how to customize labels for specific qubits in a quantum circuit plot, which is a question about the usage of specific software tools or libraries to create quantum circuit visualizations.",Tooling,,,, Tooling,
12160.0,How can I run Q# program in Azure Quantum,"<p>I have already made a small Q# program and ran it using Python on VSCode, my question is <strong>how can I run it on Azure Quantum</strong> to make it run faster?</p>

<ul>
<li><p>Q# program :</p>

<pre><code>namespace QubitTest {
open Microsoft.Quantum.Convert;
open Microsoft.Quantum.Math;
open Microsoft.Quantum.Measurement;
open Microsoft.Quantum.Canon;
open Microsoft.Quantum.Intrinsic;

operation QChange() : Int {
// on retourne un qubit   
 using ( q = Qubit()) {
 for (i in 1..500000){
     H(q);
     Message($"" Qubit {i} : {q}"");
 }
 return 0;
 }
}

}
</code></pre></li>
<li><p>Python Simulation :</p>

<pre><code> import qsharp

 from QubitTest import QChange 

 QChange.simulate()
</code></pre></li>
</ul>
",<algorithm><q#>,5/24/2020 16:29,12165.0,12165.0,"<p>Azure Quantum is in private preview right now. You can sign up to request early access <a href=""https://azure.microsoft.com/en-us/services/quantum/#contact"" rel=""nofollow noreferrer"">here</a>.</p>
",5/25/2020 8:38,Tooling,The user is inquiring about running a Q# program on Azure Quantum to potentially accelerate its execution. This falls under the category of tooling as it involves using specific quantum computing tools and services to optimize the program's performance.,Tooling,,,,Tooling,
12176.0,Modifying measurements in a Qiskit circuit,"<p>Assume my function Qiskit receives a certain <code>circuit</code> as an input. How do I check if this circuit already has some measurements appended to it? If so, how can I modify them? For example, if there are measurements on certain qubits, I would like to remove those in order to add some more gates, and then add the measurement of all qubits.</p>
",<qiskit><programming>,5/25/2020 17:06,12182.0,12182.0,"<p>The easiest way to do this is probably by converting the circuit to a <code>DAGCircuit</code>, which can be done using the method <code>from qiskit.converters import circuit_to_dag</code>. From the DAG you can get properties, such as any measurement operations, by using the function <code>my_dag.named_nodes('measurement')</code>. <code>DAGNode</code> objects are returned which will tell you the properties of the measurement. You can then remove nodes using <code>my_dag.remove_op_node(a_measurement_node)</code>, it is preferable to remove and add nodes than to modify inplace. Following this you could convert the <code>DAGCircuit</code> back to a <code>QuantumCircuit</code> using <code>from qiskit.converters import dag_to_circuit</code> and then append any measurement operations as desired.</p>
",5/25/2020 19:38,Tooling,"The user is asking about how to inspect and modify a quantum circuit in Qiskit, specifically checking for measurements and potentially altering the circuit. This question pertains to the usage of specific software tools in quantum computing, making it a tooling-related inquiry.",Tooling,,,,Tooling,
12216.0,'Unable to import' error message in Q# using VS Code,"<p>I'm a complete beginner in Q#.</p>

<p>Consider the code in the following image:</p>

<p><a href=""https://i.stack.imgur.com/pMmkX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pMmkX.png"" alt=""enter image description here""></a></p>

<p>For some reason, there always is an error message when I try to import anything. It also implies to keywords like <code>Length</code>. The error message is :</p>

<pre><code>No namespace with the name ""Microsoft.Quantum.Canon"" exists.
</code></pre>

<p>However, my code works just fine. The code in the image is taken directly from user guide of Q#.</p>

<p>Any Suggestions?</p>
",<programming><q#>,5/28/2020 5:21,12276.0,12276.0,"<p>If your code builds and runs successfully, this error has to come from IntelliSense.</p>

<p>Are you using .NET Core 3.1.300? I think QDK release 0.11.2004.2825 has IntelliSense issues with .NET Core 3.1.300 specifically, and downgrading .NET Core to 3.1.201 fixes this issue - you can try that.</p>

<p>Edit: the <a href=""https://github.com/microsoft/qsharp-compiler/issues/434"" rel=""nofollow noreferrer"">relevant issue on GitHub</a>.</p>
",06/01/2020 17:22,Errors,"The user is encountering an error related to importing namespaces and keywords in Q#. They are seeking help to resolve this issue, which falls under the category of Errors in programming.",Errors,,,,Errors,
12241.0,Change single qubit state in Q#,"<p>I am starting with Q# and I would like to know how can I get the following qubit state:</p>

<pre><code>0.8|0â© + 0.2|1â©
</code></pre>

<p>from a qubit initialized as |0â©.</p>

<p>Thanks in advance!</p>
",<q#>,5/30/2020 10:04,12245.0,12245.0,"<p>First, a clarification that in order to have a properly-normalized state, you probably intend to create a state something like:
<span class=""math-container"">$\sqrt{0.8}  \left| 0 \right&gt; + \sqrt{0.2} \left| 1 \right&gt;$</span>.
Here the probability of measuring <span class=""math-container"">$\left| 0 \right&gt;$</span> is 0.8 and the probability of measuring <span class=""math-container"">$\left| 1 \right&gt;$</span> is 0.2, when measuring in the computational basis.</p>

<p>Now, starting with a qubit in the <span class=""math-container"">$\left| 0 \right&gt;$</span> state, you can just apply an <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.ry"" rel=""nofollow noreferrer"">Ry operation</a> with the appropriate angle. You need to choose the angle such that <span class=""math-container"">$\cos({\theta}/{2}) = \sqrt{0.8}$</span>. The <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.math.arccos"" rel=""nofollow noreferrer"">ArcCos function</a> will help you here.</p>
",5/30/2020 18:25,Tooling,The question is asking how to use a particular tool (Q#) to perform a specific task (create a superposition state of |0? and |1?).,Tooling,,,,Tooling,
12258.0,Generic 2-qubit gate in qiskit,"<p>I need to implement a 2-qubit gate of the following form in qiskit (I've barely started using it, so I'm happy to try a different package if that's worth it)</p>

<p><span class=""math-container"">$$ A(\vec c)=\prod_{j=1}^3[I\otimes I\cos(c_j/2)-i\sigma_j\otimes\sigma_j\sin(c_j/2)] $$</span></p>

<p>(this is taken from this paper <a href=""https://arxiv.org/abs/1306.2811"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1306.2811</a>).</p>

<p>Perhaps qiskit is the wrong tool, but I've been trying to find something in the documentation, but I find it very difficult to parse. There is UnitaryGate <a href=""https://qiskit.org/documentation/stubs/qiskit.extensions.UnitaryGate.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.extensions.UnitaryGate.html</a>
and Gate <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.Gate.html#qiskit.circuit.Gate"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.Gate.html#qiskit.circuit.Gate</a>, 
but apart from saying that the function needs parameters, there isn't any more documentation. </p>

<p>There is also the UnitaryGate.power(x) which could be useful if I knew how to define say  a function that returns a generic XX gate. </p>

<p>Yet another option could be to have a function that would take a matrix, such as</p>

<pre><code>g = twoQubitGateFrom4-by-4Matrix( -- some 4x4 matrix that is the desired unitary -- )
</code></pre>

<p>Such that later I can apply it some where, e.g.,</p>

<pre><code>myQuantumCircuit.g(3,5)
</code></pre>

<p>or even parameterized?</p>

<pre><code>myQuantumCircuit.g(3,5,vecAlpha)
</code></pre>
",<quantum-gate><qiskit><programming>,5/31/2020 20:34,12259.0,12259.0,"<p>The iso() function allows you to add a gate, defined by means of a unitary, to your quantum circuit:</p>

<p><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html</a></p>
",5/31/2020 20:55,Tooling, The user is asking how to implement a specific 2-qubit gate in Qiskit and is seeking guidance on using Qiskit's tools and features to achieve this. This question falls under the category of using quantum computing software tools effectively.,Tooling,,,,Tooling,
12285.0,IBM Q Experience - Can it be used draw out ML inferences?,"<p>Are there Quantum-enhanced Machine Learning algorithms that can be implemented via Qiskit in IBM Q Experience and obtain valuable inferences faster than their classical counterparts from datasets of let's say Kaggle?</p>

<p>Please also link important papers and articles that you think are worth reading. Thank you!</p>
",<programming><ibm-q-experience><machine-learning><computational-models>,06/02/2020 01:53,12328.0,12328.0,"<p>Quantum machine learning can help you to enhance classical machine learning algorithms by outsourcing difficult calculations to a quantum computer. You can also optimise quantum algorithms using classical machine learning architectures. </p>

<p>IBM researchers have developed a series of quantum algorithms that show how entanglement can improve AI classification accuracy. It is demonstrating a Quantum Classifier. It is available online on IBM Bluemix in the following <a href=""https://ibm-q4ai.mybluemix.net"" rel=""nofollow noreferrer"">link</a>. Also IBM has demonstrated Hybrid quantum - classical neural networks with PyTorch and Qiskit online in the following <a href=""https://qiskit.org/textbook/ch-machine-learning/machine-learning-qiskit-pytorch.html"" rel=""nofollow noreferrer"">documentation</a>. </p>

<p>When you are working on a Quantum Classifier for a dataset, we need to first encode the data into the amplitudes of a quantum state. In fact, one needs to first normalise the data such that it can be represented as a vector on a high-dimensional Bloch sphere. Quantum routines to encode data in amplitudes, so called arbitrary state preparation routines, are known to do this with a runtime that is linear in the data size, and this is arguably the best our algorithm can do in terms of runtime, since the data is the input to the problem.</p>
",06/04/2020 13:23,Learning ," The user is asking for resources (papers and articles) to learn about Quantum-enhanced Machine Learning algorithms that can be implemented via Qiskit, which falls under the category of requests for learning resources.",Learning ,,,,Learning ,
12287.0,Problem with code in 'Learning quantum computation using qiskit,"<p>I've started learning quantum computing using 'Learn quantum computation using qiskit',
and I've stumbled upon what I think is a bug in the code in chapter 1.3: Representing Qubit States
when I reached the part and run the code:</p>

<pre><code>qc = QuantumCircuit(1) 
initial_state = [0,1]   
qc.initialize(initial_state, 0)
qc.draw()   
</code></pre>

<p>It returned <code>'Attribute Error'</code>
Saying that <code>'Initialize' object has no attribute 'label'</code></p>
",<qiskit><programming><ibm-q-experience>,06/02/2020 05:17,12289.0,12289.0,"<p>This is a known bug in Qiskit (<a href=""https://github.com/Qiskit/qiskit-terra/issues/4439"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/4439</a>).</p>

<p>As a workaround, you can create an initialize gate and add the missing label using:</p>

<pre><code>from qiskit.extensions import Initialize

qc = QuantumCircuit(1)
initial_state = [0,1]

init_gate = Initialize(initial_state) # Create a new initialize gate
init_gate.label = ""init""    # Add a label to avoid the bug

qc.append(init_gate, 0)     # Perform the gate on the 0th qubit
qc.draw()    # Draw the circuit (to complete your code block)
</code></pre>

<p>Hope this helps!</p>
",06/02/2020 07:46,Tooling,"The question is asking about a bug in the Qiskit library, which is a question about the usage of a specific software tool in quantum computing.", Tooling ,,,,Tooling,
12301.0,How can I code a Conditional phase shift transform?,"<p>I am interested in implementing a operation in Q#. The operation should follow the algorithm below:
<a href=""https://i.stack.imgur.com/0coAf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0coAf.png"" alt=""Taken from a paper on quantum algorithms""></a></p>

<p>When <span class=""math-container"">$A=0$</span> it is quite easy to see that the algorithm states if the qubitt is in nullspace apply a transformation to flip the sign of the qubit.</p>

<p>I am not sure how to use the algorithm for the 'i is in A' case. </p>
",<quantum-gate><q#>,06/03/2020 00:37,12302.0,12302.0,"<p>The trick here is to define a new operation whose unitary representation is
<span class=""math-container"">\begin{align}
    S_a|i\rangle = \begin{cases}
        -|i\rangle \text{ if } i = a \\
         |i\rangle \text{ otherwise }
    \end{cases}.
\end{align}</span></p>

<p>At that point, <span class=""math-container"">$S_A = \prod_{a \in A} S_a$</span>.
In Q#, you can implement <span class=""math-container"">$S_a$</span> easily using the <code>ControlledOnInt</code> operation, an auxillary qubit in the <span class=""math-container"">$|-\rangle$</span> state, and an <code>X</code> operation:</p>



<pre><code>operation ApplyConditionalPhase(subset : Int[], register : LittleEndian)
: Unit is Adj + Ctl {
    using (aux = Qubit()) {
        within {
            // prepare aux in the |ââ© state. 
            H(aux);
            Z(aux);
        } apply {
            for (element in subset) {
                (ControlledOnInt(element, X))(register!, aux);
            }
        }
    }
}
</code></pre>

<p>This works using the same <strong>phase kickback</strong> principle as in the DeutschâJozsa algorithm; for more details on how phase kickback works, check out Chapters 6 and 7 of <a href=""https://www.manning.com/books/learn-quantum-computing-with-python-and-q-sharp?a_aid=learn-qc-granade&amp;a_bid=ee23f338"" rel=""nofollow noreferrer"">my book</a>.</p>
",06/03/2020 03:21,Theoretical,"The question is about understanding and implementing a quantum algorithm operation described in a paper. It falls under the ""Theoretical"" category as it pertains to the theoretical aspects of implementing this algorithm in Q#",Theoretical,,,,Theoretical,
12334.0,How to turn off multiprocessing in TensorFlow Quantum,"<p><strong>Some background:</strong> I'm currently running the same training algorithm with a classical neural network and a quantum circuit, respectively. The NN is implemented in Keras with a TensorFlow backend, the circuit is implemented in TFQ.</p>

<p>My circuit has only 4 qubits and 88 trainable parameters, and training is still at least a factor 10 slower than training a NN with two dense layers (10 units each) and 182 trainable parameters. (All hyperparameters are identical.) At this moderate circuit size I don't expect circuit training to be that much slower than training the classical NN.</p>

<p>Looking at the CPU usage, I see that TFQ uses all cores, but only to a fraction. My suspicion is that the circuit is too small to reach the threshold where multiprocessing makes sense, so this might be a source of the slowness. However, I can't seem to find a way to turn multiprocessing off.</p>

<p><strong>Question: Is there a way to disable multiprocessing in TensorFlow Quantum?</strong></p>
",<programming><simulation><machine-learning><tfq>,06/04/2020 16:57,15732.0,15732.0,"<p>There is no way to disable multiprocessing in TensorFlow Quantum without also affecting TensorFlow. That being said, there are still some workarounds to your problem that might be worth trying. It might help to take a look at changing the <a href=""https://www.tensorflow.org/api_docs/python/tf/config/threading/set_inter_op_parallelism_threads"" rel=""nofollow noreferrer"">inter and intra op parallelism in tensorflow</a> . If you are finding that TFQ isn't making full use of multiprocessing you might want to turn down the intra op parallelism.</p>
<p>In the past when I've seen patterns like that in my code, a lot of times it had to do with other things like waiting for the <code>tfq.convert_to_tensor</code> function to finish running in between each epoch and the fast C++ portion of my model finished so quickly that it just looked like a little blip on all the cores. Another common hiccup I'd hit is accidentally gathering the contents of a tensor and doing something like printing it, in between &quot;hot paths&quot; in the model. A good way to make these kinds of problems more apparent is to temporarily crank up the number of qubits and then try to isolate the major stages of your training loop to find the bottleneck. My personal guess in your case is that pure python code like <code>tfq.convert_to_tensor</code> is being called in between the training epochs and the epochs themselves are still very fast.</p>
<p>There was no code provided so I can't give any more help than just general advice, but if you are absolutely convinced it is not any of the things I mentioned above then you could use TensorBoard (tutorial with TFQ <a href=""https://www.tensorflow.org/quantum/tutorials/research_tools"" rel=""nofollow noreferrer"">here</a>) to profile the underlying model code and see where things might be slowing down.</p>
",1/28/2021 19:10,Tooling,The user is asking about a specific functionality related to TensorFlow Quantum (TFQ) and whether it's possible to disable multiprocessing to potentially improve the training speed. This question falls under the category of Tooling as it pertains to the usage of specific software tools in quantum computing.,Tooling,,,,Tooling,
12356.0,Transpiler Error: Number of qubits greater than maximum in coupling map,"<p>Transpiler Error: <em>Number of qubits (2) in circuit11 is greater than maximum (1) in the couplings map</em></p>

<pre><code># Initialize two qubits and create Entanglement using Hadamard and CX/CNOT Gate
q = qiskit.QuantumRegister(2)
c = qiskit.ClassicalRegister(2)
qc = qiskit.QuantumCircuit(q, c)
qc.h(q[0])
qc.cx(q[0], q[1])
qc.measure(q, c)
job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3)

</code></pre>

<p>Error:</p>

<pre><code>---------------------------------------------------------------------------
TranspilerError                           Traceback (most recent call last)
&lt;ipython-input-11-7b13276b10ae&gt; in &lt;module&gt;()
      9 qc.cx(q[0], q[1])
     10 qc.measure(q, c)
---&gt; 11 job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3)

2 frames
/usr/local/lib/python3.6/dist-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, **run_config)
    249                                 seed_transpiler=seed_transpiler,
    250                                 optimization_level=optimization_level,
--&gt; 251                                 backend=backend)
    252 
    253     if schedule_circuit:

/usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, seed_transpiler, optimization_level, pass_manager, callback, output_name)
    205                                            callback, output_name)
    206 
--&gt; 207     _check_circuits_coupling_map(circuits, transpile_args, backend)
    208 
    209     # Transpile circuits in parallel

/usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend)
    245                                   'in {} '.format(circuit.name) +
    246                                   'is greater than maximum ({}) '.format(max_qubits) +
--&gt; 247                                   'in the coupling_map')
    248 
    249 

TranspilerError: 'Number of qubits (2) in circuit11 is greater than maximum (1) in the coupling_map'
</code></pre>
",<qiskit><programming>,06/06/2020 06:42,12359.0,12359.0,"<p>This error means that you are trying to execute a circuit on a backend that has fewer qubits than used in your circuit. In this case you are trying to execute a 2 qubit circuit on a device that only has one qubit. To fix this I would use a different backend which has 2 or more qubits. You can see how many qubits a backend has by looking at it on the IBM Quantum website or by calling <code>backend.configuration()</code></p>
",06/06/2020 10:45, Errors  ,"The user is seeking a solution for a specific error encountered while implementing a quantum circuit in Qiskit, which falls under the category of error resolution in quantum programming", Errors  ,,,, Errors  ,
12369.0,Jordan-Wigner $\leftrightarrow$ Bravyi-Kitaev transformation in Qiskit,"<p>A couple of questions regarding the conversion between Jordan-Wigner (JW) and Bravyi-Kitaev (BK) states in Qiskit.</p>

<p>The JW <span class=""math-container"">$\rightarrow$</span> BK conversion matrix I refer to below is the one from equation (29) <a href=""https://arxiv.org/abs/1208.5986"" rel=""nofollow noreferrer"">here</a>. (I'm not referring to equation (24) in <em>Ibid.</em> for it contains a typo.)</p>

<ol>
<li><p>Is there a way to generate a circuit which would map JW-encoded states to BK-encoded states? (The circuit is actually very simple since it multiplies the input <span class=""math-container"">$n$</span>-qubit vector by a <span class=""math-container"">$n\times n$</span> matrix <span class=""math-container"">$\operatorname{mod} 2$</span>; since the matrix is upper-triangular, it is rather trivial to construct it out of CNOTs.)</p></li>
<li><p>Assuming that the answer to the previous question is NO: is there a way to, at least, generate the matrix implementing the conversion between the Jordan-Wigner and Bravyi-Kitaev states, for a given number of qubits <span class=""math-container"">$n$</span>?</p></li>
</ol>
",<qiskit><programming>,06/07/2020 22:36,12427.0,12427.0,"<p>I have not found such functionality in Qiskit. However, one can use the <code>openfermion</code> function <code>openfermion.transforms._encoder_bk()</code>:</p>

<pre><code>def _encoder_bk(n_modes):
    """""" Helper function for bravyi_kitaev_code that outputs the binary-tree
    (dimension x dimension)-matrix used for the encoder in the
    Bravyi-Kitaev transform.

    Args:
    n_modes (int): length of the matrix, the dimension x dimension

    Returns (numpy.ndarray): encoder matrix
    """"""
    reps = int(numpy.ceil(numpy.log2(n_modes)))
    mtx = numpy.array([[1, 0], [1, 1]])
    for repetition in numpy.arange(1, reps + 1):
        mtx = numpy.kron(numpy.eye(2, dtype=int), mtx)
        for column in numpy.arange(0, 2 ** repetition):
            mtx[2 ** (repetition + 1) - 1, column] = 1
    return mtx[0:n_modes, 0:n_modes]
</code></pre>

<p>With the aid of this function, one constructs the JW â BK circuit as follows:</p>

<pre><code>def jw_to_bk_circuit_qiskit(n):
    """"""
    Creates a Qiskit circuit which performs the JW -&gt; BK transformation on qubits.
    One needs this function to prepare initial states when using BK encoding.
    :param n: Number of qubits.
    :return:
    """"""

    # Initializing qubits:
    qc = qiskit.QuantumCircuit( n )

    # JW-&gt;BK encoder (lower-triangluar!) matrix
    bk_encoder = openfermion.transforms._encoder_bk( n )
    # print(bk_encoder)
    # Matrix multiplication mod 2 using CNOTs (starting from the bottom row)
    for i in reversed( range( 1, n ) ):
        for j in range( i  ):
            if bk_encoder[i, j] == 1:
                qc.cx(j,i)

    return qc
</code></pre>

<p>Not that it is crucial to perform the matrix multiplication using CNOTs <strong>starting from the bottom row</strong>, since the encoder matrix is lower-triangular.</p>
",06/11/2020 18:39, Tooling," The question is asking about how to generate circuits and matrices for the Jordan-Wigner (JW) to Bravyi-Kitaev (BK) state conversion in Qiskit, which is a question about the usage of a specific software tool in quantum computing.",Tooling ,,,, Tooling,
12378.0,Trotterizing a Pauli sum in Qiskit,"<p>In Qiskit, how do I construct a circuit corresponding to the Trotter expansion of a Pauli sum <span class=""math-container"">$A+B+C+\ldots$</span> given as a <code>WightedPauliSum</code> object?</p>

<p><span class=""math-container"">$$
\operatorname{e}^{A + B + C + \ldots } \overset{?}{\mapsto}
\left\{\begin{alignedat}{9}
U &amp;= \operatorname{e}^{A}\operatorname{e}^{B}\operatorname{e}^{C}\ldots \ &amp;&amp;, \quad &amp;&amp;\text{(first order)}\\
U &amp;= \operatorname{e}^{A/2}\operatorname{e}^{B/2}\operatorname{e}^{C/2}\ldots\operatorname{e}^{C/2}\operatorname{e}^{B/2}\operatorname{e}^{A/2} \ &amp;&amp;, \quad &amp;&amp;\text{(second order)}\\
 &amp; \ldots
\end{alignedat}\right.
$$</span>
I guess, <code>PauliTrotterEvolution</code> should do the job, but I have not found a tutorial.</p>
",<qiskit><programming>,06/08/2020 18:24,12412.0,12412.0,"<p>Looks like this works:</p>

<pre><code>qc_trotter = paulistring.evolve( evo_time = 1, 
                                 expansion_order = 2)
</code></pre>

<p>where <code>qc_trotter</code> is an object of type <code>WeightedPauliOperator</code>, see <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.legacy.WeightedPauliOperator.evolve.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Be mindful though that using circuits generated in this way may sometimes result in errors, as reported <a href=""https://github.com/Qiskit/qiskit-aqua/issues/1034"" rel=""nofollow noreferrer"">here</a>.</p>
",06/10/2020 23:44,Tooling," The user is asking about how to implement a specific quantum computing operation (Trotter expansion of a Pauli sum) in Qiskit, which falls under the category of tools and software usage in quantum programming. ",Tooling,,,,Tooling,
12387.0,How to decompose unitary quantum gate in current simulator or emulator?,"<p>I have a question about how to decompose a unitary quantum gate in a currently existing simulator or emulator. I have read some papers about SK algorithm and other algorithms which aim to decompose unitary quantum gates. Is there any specific method to decompose a quantum gate in a currently existing simulator? Some papers about decomposition methods mention Trotter-Suzuki decomposition but I don't exactly know if this is true? To be more specific, what is the decomposition algorithm in Qiskit or Project Q?</p>
",<quantum-gate><programming><algorithm>,06/09/2020 12:05,12388.0,12388.0,"<p>In Qiskit, the iso() function allows you to add a gate, defined by means of a unitary, to your quantum circuit:</p>

<p><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html</a></p>

<p>The decomposition used in the iso() function was introduced by Iten et al. in <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1501.06911</a>.</p>

<p>Of course this is related to the circuit, not to the backend (which can be real or simulated).</p>
",06/09/2020 12:11,Tooling,"The user is inquiring about the decomposition algorithms available in existing quantum simulators and emulators like Qiskit and Project Q. This question pertains to the usage of specific software tools and techniques in quantum computing, falling under the Tooling category.",Tooling,,,,Tooling,
12398.0,a question about quantum gate decomposition on simulator or emulator,"<p>I have read a paper about ""approximated decomposition"" of a unitary single gate (<a href=""https://arxiv.org/pdf/quant-ph/0505030.pdf"" rel=""nofollow noreferrer"">Solovay-Kitaev algorithm</a>) which told us a any unitary single gate can be decomposed into {Hadamard, Phase} with any accuracy <span class=""math-container"">$\epsilon$</span> . The number of {Hadamard, Phase} grows exponentially as the <span class=""math-container"">$\epsilon$</span> becomes lower and the result is a better approximation of the gate. However, in simulator or emulator such as project Q and Qiskit, the <span class=""math-container"">$U3$</span> gate seems exacted decomposition which means only one parameterized <span class=""math-container"">$U3$</span> gate can realize any unitary single gate. </p>

<p><strong>So if we can realize ""exact unitary single gate"" in quantum computer, why still so many people focus on the ""approximated one"" and try to optimized the sequence after decomposition?</strong></p>
",<quantum-gate><algorithm><programming><solovay-kitaev-algorithm>,06/10/2020 00:10,12400.0,12400.0,"<p>The restricted gate set of, for example, <span class=""math-container"">$\{H,T\}$</span>, is more relevant when you start talking about error corrected quantum computation. It may be that when you act on individual, physical, qubits, you can implement and arbitrary single-qubit rotation. </p>

<p>However, when you encode in an error correcting code, and you want to implement a gate directly on the logical qubit, the set of logical gates that you can enact may be restricted. For example, it is common to restrict to a set of gates comprising the Clifford gates + <span class=""math-container"">$T$</span>. This is because, for many codes, the Clifford gates can be implemented with relatively low cost. The fault-tolerant threshold (the limit of error rate that you need to be under in order to have properly managed errors) is primarily dependent on the implementation of any other gates. So, we keep things as simple as possible and implement a single extra gate that we try to do as well as possible. Typically, that's the <span class=""math-container"">$T$</span> gate.</p>

<p>Yes, it is possible to implement other logical gates, and it might be in practice that this is what you'd do, but it's still going to be a finite set of gates and you have to trade off between the complications and added overheads of extending the gate set versus the reduction in sequence length.</p>
",06/10/2020 06:43, Conceptual,The user is inquiring about the concept of approximated vs. exact unitary single gates in quantum computing and why there is a focus on approximated gates even though exact unitary gates are possible. This question falls under the Conceptual category as it pertains to understanding the principles and considerations in quantum computing.,Conceptual,,,, Conceptual,
12420.0,"Is there a ""parameterized initialization"" that I can apply to a QuantumRegister to re-use a circuit?","<p>I'm working on a QuantumCircuit which measures the fidelity of one point (my ""test vector"") and two other points (my ""data set"", containing of states <code>phi_1</code> and <code>phi_2</code>) <strong>at once</strong>. I'm using <a href=""http://arxiv.org/abs/2003.09187"" rel=""nofollow noreferrer"">Afham; Basheer, Afrad; Goyal, Sandeep (2020)</a> to reproduce their circuit. My circuit right now looks as follows:</p>

<pre><code>                                          â âââââ                    âââââ â âââ   
          control_0: ââââââââââââââââââââââââ¤ H ââââââââââââââ âââ âââ ââ¤ H âââââ¤Mââââ
                     ââââââââââââââââââââ â âââââ            â  â  â âââââ â ââ¥â   
state_to_classify_0: â¤0                 âââââââââââââââââââââXâââ¼âââ¼âââââââââââ«ââââ
                     â                  â â                  â  â  â       â  â    
state_to_classify_1: â¤1 INIT TEST STATE ââââââââââââââââââââââ¼ââXâââ¼âââââââââââ«ââââ
                     â                  â â                  â  â  â       â  â    
state_to_classify_2: â¤2                 ââââââââââââââââââââââ¼âââ¼ââXâââââââââââ«ââââ
                     ââââââââââââââââââââ â      âââââââââââ â  â  â       â  â    
     train_states_0: âââââââââââââââââââââââââââââ¤0        ââXâââ¼âââ¼âââââââââââ«ââââ
                                          â      â         â    â  â       â  â    
     train_states_1: âââââââââââââââââââââââââââââ¤1        âââââXâââ¼âââââââââââ«ââââ
                                          â      â  oracle â       â       â  â    
     train_states_2: âââââââââââââââââââââââââââââ¤2        ââââââââXâââââââââââ«ââââ
                                          â ââââââ         â               â  â âââ
       comp_basis_0: ââââââââââââââââââââââââ¤ H ââ¤3        ââââââââââââââââââââ«ââ¤Mâ
                                          â ââââââââââââââââ               â  â ââ¥â
     meas_control_0: ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©âââ¬â
                                                                                 â 
  meas_comp_basis_0: âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
</code></pre>

<p>Where the <code>INIT TEST STATE</code> is used to initialise my test state on a 3-qubit register, and my <code>oracle</code> is defined as follows:</p>

<pre><code>                     ââââââââââ     ââââââââââ
train_states_0: ââââââ¤0       âââââââ¤0       â
                     â        â     â        â
train_states_1: ââââââ¤1 phi_0 âââââââ¤1 phi_1 â
                     â        â     â        â
train_states_2: ââââââ¤2       âââââââ¤2       â
                ââââââââââ¬âââââââââââââââ¬âââââ
  comp_basis_0: â¤ X ââââââ ââââââ¤ X ââââââ âââââ
                âââââ          âââââ          
</code></pre>

<p>So that my <code>train_states</code> register is in a superposition of my full data set. I want to be able to measure the fidelity between multiple points, so what I'm doing right now is just create my circuit where I call <code>qiskit.extensions.quantum_initializer.Isometry</code> to initialize my registers into the desired state. If I want to test another test state, I reproduce my entire circuit. </p>

<p>For now this works, but eventually I want to move onto larger datasets with thousands of points, I can imagine that recreating a QuantumCircuit from scratch for every data point can become a bottleneck. Hence my question: can I make <code>INIT TEST STATE</code> in such a way that I can define an example function like:</p>

<pre><code>def apply_new_datapoint(new_init_gate, old_circuit):
    old_circuit.data.replace(0, new_init_gate)
</code></pre>

<p>I have no idea if the above works, but this is what I'm trying to reach eventually.</p>
",<programming><circuit-construction><machine-learning><research><initialization>,06/11/2020 12:17,12424.0,12424.0,"<p>There is no replace() method, but you can do the trick by means of pop() and insert().</p>

<p>Example:</p>

<pre><code>from qiskit import QuantumCircuit, Aer, execute
from qiskit.extensions.standard import XGate

simulator = Aer.get_backend(""qasm_simulator"")

qc = QuantumCircuit(4,4)
qc.h([0,1,2,3])
qc.measure([0,1,2,3], [0,1,2,3])
print(qc.draw())
result = execute(qc, backend=simulator, shots=1000).result()
counts = result.get_counts(qc)
print(""\nTotal counts:"",counts)

qc.data.pop(0)
qc.data.insert(0,(XGate(),[qc.qregs[0][0]],[]))
print(qc.draw())
result = execute(qc, backend=simulator, shots=1000).result()
counts = result.get_counts(qc)
print(""\nTotal counts:"",counts)
</code></pre>
",06/11/2020 16:07,Tooling,The user is asking about how to use the Qiskit library to efficiently initialize a quantum circuit with different data points.,Tooling,,,,Tooling,
12429.0,How can I install the 'ibmq_qasm_simulator' backend?,"<p>I'm having trouble running the following cell:</p>

<p><a href=""https://i.stack.imgur.com/fVtPz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fVtPz.png"" alt=""enter image description here""></a></p>

<p>The system told me ""The 'ibmq_qasm_simulator' backend is not installed in your system."" I'm so confused. Is there a way I can install this backend in my system? Thanks!</p>

<p><a href=""https://i.stack.imgur.com/OkLdv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OkLdv.png"" alt=""enter image description here""></a></p>
",<programming><ibm-q-experience><ibm><qasm>,06/11/2020 22:45,12430.0,12430.0,"<p>The ibmq_qasm_simulator is a cloud-based simulator. You need to say</p>

<pre><code>from qiskit import IBMQ
provider = IBMQ.load_account()
sim = provider.backends.ibmq_qasm_simulator
</code></pre>
",06/11/2020 22:48,Errors,"The user is encountering a specific error (The ibmq_qasm_simulator backend is not installed in your system) while running a quantum circuit in Qiskit, which falls under the category of seeking solutions for errors and exceptions in quantum program development",Errors,,,,Errors,
12450.0,How to apply a gate to a LittleEndian in Q#,"<p>I have been given a LittleEndian register. I want to know the following things:</p>

<ol>
<li>How many bits there are in the LittleEndian?</li>
<li>How to convert the LittleEndian into a Qubit[] Array.</li>
<li>How to access individual qubits of LittleEndian?</li>
<li>How to apply simple and controlled gates onto individual qubits of LittleEndian?</li>
</ol>
",<programming><q#>,6/13/2020 5:38,12451.0,12451.0,"<p>The <code>LittleEndian</code> type is basically a wrapper for a register of qubits to let the user know how to interpret it as another value. It changes nothing about the register it wraps.</p>

<ol>
<li>There is no fixed number of bits in a <code>LittleEndian</code>, it only documents that the least significant bit of a register is index 0 (on the left).</li>
<li>If you want to get back just the register not wrapped in the <code>LittleEndian</code> type, you can use the <a href=""https://docs.microsoft.com/quantum/user-guide/language/expressions#unwrap-expressions"" rel=""nofollow noreferrer""><code>!</code> operator</a> like this:</li>
</ol>



<pre><code>using (register = LittleEndian(Qubit[3]) {
    ResetAll(register!);
}
</code></pre>

<ol start=""3"">
<li>Similar to #2 if you us <code>!</code> to unwrap the <code>LittleEndian</code> type you can then index it like normal.</li>
<li>Same as #3, just unwrap the type and you should be able to do the gates as you would regularly. The <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/language/types#operation-and-function-types"" rel=""nofollow noreferrer"">controlled functor</a> may be of use to you. </li>
</ol>

<p>I also have a <a href=""https://livebook.manning.com/book/learn-quantum-computing-with-python-and-q-sharp/chapter-8/section-8-2?origin=product-toc"" rel=""nofollow noreferrer"">section in my book</a> that talks about how to use UDTs or User Defined Types which <code>LittleEndian</code> is an example of (provided by the <a href=""https://docs.microsoft.com/en-us/quantum/libraries/numerics/"" rel=""nofollow noreferrer"">Numerics library</a>)</p>
",6/13/2020 6:03,API Usage,"The question is related to how to work with a specific quantum programming API, specifically dealing with a LittleEndian register and performing various operations on it, which falls under API Usage.",API Usage,,,,API Usage,
12466.0,qsharp.reload() throws error in python,"<p>I'm trying to add the Q# machine learning library to my program by</p>

<pre><code>import qsharp
qsharp.packages.add(""Microsoft.Quantum.MachineLearning::0.11.2004.2825"")
qsharp.reload()
</code></pre>

<p>but it throws the errors below. Any solutions?</p>

<p>P.S. I have the qsharp package and iqsharp installed. Normal programs in python that use qsharp work correctly.</p>

<pre><code>dotnet iqsharp --version
iqsharp: 0.11.2006.403
Jupyter Core: 1.3.60623.0
.NET Runtime: .NETCoreApp,Version=v3.1
</code></pre>

<p>and</p>

<pre><code>'iqsharp': LooseVersion ('0.11.2006.403'),
 'Jupyter Core': LooseVersion ('1.3.60623.0'),
 '.NET Runtime': LooseVersion ('.NETCoreApp,Version=v3.1'),
 'qsharp': LooseVersion ('0.11.2006.403')
</code></pre>

<p>Also even if I don't add the Machine Learning library and just run </p>

<pre><code>import qsharp
qsharp.reload()
</code></pre>

<p>It still throws the same error</p>

<p>Errors:</p>

<pre><code>Adding package Microsoft.Quantum.MachineLearning::0.11.2004.2825.
---------------------------------------------------------------------------
IQSharpError                              Traceback (most recent call last)
&lt;ipython-input-15-b3244a777be2&gt; in &lt;module&gt;
      1 import qsharp
      2 qsharp.packages.add(""Microsoft.Quantum.MachineLearning::0.11.2004.2825"")
----&gt; 3 qsharp.reload()

~\anaconda3\lib\site-packages\qsharp\__init__.py in reload()
     70     Q# compilation errors are raised as an exception.
     71     """"""
---&gt; 72     client.reload()
     73 
     74 def get_available_operations() -&gt; List[str]:

~\anaconda3\lib\site-packages\qsharp\clients\iqsharp.py in reload(self)
    117 
    118     def reload(self) -&gt; None:
--&gt; 119         return self._execute(f""%workspace reload"", raise_on_stderr=True)
    120 
    121     def add_package(self, name : str) -&gt; None:

~\anaconda3\lib\site-packages\qsharp\clients\iqsharp.py in _execute(self, input, return_full_result, raise_on_stderr, output_hook, **kwargs)
    207         # There should be either zero or one execute_result messages.
    208         if errors:
--&gt; 209             raise IQSharpError(errors)
    210         if results:
    211             assert len(results) == 1

IQSharpError: The Q# kernel raised the following errors:
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(2,10): error QS6104: No namespace with the name ""Microsoft.Quantum.Convert"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(3,10): error QS6104: No namespace with the name ""Microsoft.Quantum.Intrinsic"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(60,21): error QS5022: No identifier with the name ""Default"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(61,16): error QS5022: No identifier with the name ""Structure"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(62,16): error QS5022: No identifier with the name ""Parameters"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(63,16): error QS5022: No identifier with the name ""Bias"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(11,16): error QS5022: No identifier with the name ""Length"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(30,23): error QS5022: No identifier with the name ""Mapped"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(32,13): error QS5022: No identifier with the name ""Zip"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(35,13): error QS5022: No identifier with the name ""Mapped"" exists.
    C:/Users/Shreyas/Documents/jupyter/Quantum/MLADS2020-QuantumClassification-master/MLADS2020-QuantumClassification-master/test/Operation.qs(46,9): error QS5022: No identifier with the name ""Message"" exists.
</code></pre>
",<programming><q#>,6/13/2020 20:28,12468.0,12468.0,"<p>@ChrisGranade <a href=""https://quantumcomputing.stackexchange.com/questions/12466/qsharp-reload-throws-error-in-python#comment16425_12466"">solved my problem</a>:</p>

<blockquote>
  <p>It looks like your IQ# version is 0.11.2006.403, but you're trying to add version 0.11.2004.2825 of the Microsoft.Quantum.MachineLearning package. I'd suggest either downgrading IQ# to 0.11.2004.2825, or modifying the <code>qsharp.packages.add</code> call to use 0.11.2006.403</p>
</blockquote>
",6/13/2020 23:28,Errors," The user is encountering a specific error while trying to add the Q# machine learning library to their program, which falls under the category of seeking solutions for errors and exceptions in quantum program development. ",Errors,,,,Errors,
12471.0,How do I encode integers into BigEndian in Q#?,"<p><a href=""https://export.arxiv.org/ftp/arxiv/papers/1908/1908.07943.pdf"" rel=""nofollow noreferrer"">https://export.arxiv.org/ftp/arxiv/papers/1908/1908.07943.pdf</a>
page 4 point 1 states that we use the bits of an integer as a basis in our space. I understand that BigEndian grabs our largest bit and creates a qubit. I am wondering if there is a function within Q# that does this for me. </p>
",<programming><q#>,6/14/2020 5:06,12472.0,12472.0,"<p>I don't think there's a single function, but here's how you can do this with several library functions:</p>

<pre><code>open Microsoft.Quantum.Arrays;
open Microsoft.Quantum.Convert;
open Microsoft.Quantum.Diagnostics;

operation Demo () : Unit {
    let N = 12;
    Message(<span class=""math-container"">$""Number: {N}"");
    let bitsLE = IntAsBoolArray(N, 4);
    Message($</span>""Bits in little endian: {bitsLE}"");
    let bitsBE = Reversed(bitsLE);
    Message($""Bits in big endian: {bitsBE}"");
    using (qs = Qubit[N]) {
        ApplyPauliFromBitString(PauliX, true, bitsBE, qs);
        DumpMachine();
        ResetAll(qs);
    }
}
</code></pre>

<ul>
<li><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.convert.intasboolarray"" rel=""nofollow noreferrer"">IntAsBoolArray</a> converts an integer to a bit string with the given number of bits (in this case <code>[False,False,True,True]</code>).</li>
<li><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arrays.reversed"" rel=""nofollow noreferrer"">Reversed</a> returns the bits of the array in reverse order, i.e., converts them from little endian to big endian (<code>[True,True,False,False]</code>).</li>
<li><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applypaulifrombitstring"" rel=""nofollow noreferrer"">ApplyPauliFromBitString</a> applies an X gate to each of the qubits that correspond to <code>true</code> elements of the <code>bitsBE</code> array (<span class=""math-container"">$|1100\rangle$</span>).</li>
</ul>
",6/14/2020 5:52,Tooling,"The user is asking about how to use the bits of an integer as a basis in their space in Q#, which involves understanding and using specific functions in the Q# programming language",Tooling,,,,Tooling,
12474.0,How does a classical computer simulate nonclassical correlations?,"<p>This may be a dumb question, if so please forgive me, it is late at night.</p>

<p>I have learned that a classical computer can simulate a quantum computer in exponential time and space, but classical computers are bound to non-quantum phenomenon.</p>

<p>How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate?</p>

<p>In general, how could a classical computer simulate quantum phenomena that cannot be explained classically (such as the dynamics of more than a single particle)? I would think that one could not generate random numbers violating any of Bell's inequalities, i.e. necessarily quantum correlations are off limits.</p>
",<entanglement><simulation><classical-computing><nonlocal-games><non-locality>,6/14/2020 9:16,12479.0,12479.0,"<blockquote>
  <p>How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate?</p>
</blockquote>

<p>Quantum phenomena cannot be ""explained classically"" only when locality is taken into consideration.
In other words, classical phenomena cannot reproduce (some types of) quantum correlations <em>provided that we don't allow for certain types of correlations</em>.</p>

<p>As a concrete example, consider a standard CHSH scenario. We can compute the outcome probability distributions for each measurement setting (it's what you do when you study the protocol), therefore you can trivially write some code to ""simulate"" the results of an experiment, meaning to draw a possible sequence of measurement outcomes you would find in an experiment. But this is clearly not the same as observing nonlocality with a classical computer: you would just be crunching some numbers that <em>you</em> know, in some situations, can be interpreted as markers of nonclassical correlations. </p>

<p>Put in another way, you can always sample from an arbitrary probability distribution <span class=""math-container"">$p(ab|xy)$</span>. Whether such a distribution is ""nonclassical"" is only meaningful in relation to some imposed restriction (<em>e.g.</em> defining ""classical"" when it can be written as <span class=""math-container"">$p(ab|xy)=\sum_\lambda p_\lambda p_\lambda(a|x) p_\lambda(b|y)$</span>). When you simulate such a distribution on a computer, you don't need to respect such restrictions, so there is no problem.</p>

<blockquote>
  <p>In general, how could a classical computer simulate quantum phenomena that cannot be explained classically</p>
</blockquote>

<p>Aside from locality constraints, such as those described above, quantum mechanics does not predict output probability distributions that are incompatible with classical physics. The difference is in <em>how</em> those outputs can be obtained: quantum mechanic can produce output probability distributions in a radically different way than what classical physics allows for, and in some cases these new behaviours are more efficient.</p>
",6/14/2020 12:46, Conceptual  ,The question is related to understanding the conceptual and theoretical aspects of quantum phenomena and their simulation on classical computers. It seeks clarification on how classical computers can simulate quantum phenomena that exhibit fundamentally quantum probabilities., Conceptual  ,,,, Conceptual  ,
12493.0,A question about a real programmable quantum computer,"<p>In the theory of universal quantum gates,I have known a common universal gate set is the Clifford + T gate set, which is composed of the CNOT, H, S and T gates. Then there is a concept called ""accuracy"", which means use the composition of this set of gates can achieve any accuracy of the gate we want to approximately simulate. </p>

<p>However, in real quantum computer hardware, for example, ion-trapped quantum computers, the two parameterized gates in this paper can be regareded as universal quantum gates to realize any quantum gates (<a href=""https://arxiv.org/pdf/1603.07678.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1603.07678.pdf</a>), and the concept of ""accuracy"" is also no longer mentioned.</p>

<p>It mentioned a concept of ""fidelity"" instead. So does that means, the process of simulation will be 100% right if we don't take the influence of hardware realization into account? If so, why do we still need to learn so much about ""universal quantum gates""?</p>
",<quantum-gate><algorithm><quantum-state><programming>,6/15/2020 10:09,12495.0,12495.0,"<p>The author in that paper allows himself arbitrary angle single and two qubit gates. With this set it is generally pretty easy to exactly match a given unitary, since the two qubit gates can give you the backbone of the correct entanglement structure, and the single qubit gates can conjugate the gate into the exactly correct basis.</p>

<p>The reason that accuracy is a concern for the CNOT/H/T gate set is that it is a discrete set, so for a rotation of some irrational angle (in multiples of <span class=""math-container"">$\pi$</span>), I believe you would generically need infinite gates to exactly match it. The reason this gate set is still considered is that due to the Eastin-Knill theorem, Quantum Error Correcting Codes can only allow a discrete logical gate set, so in Fault-Tolerant Quantum Computers, a discrete set might be the best that we can do.</p>
",6/15/2020 15:07,Theoretical ,"The user is asking about the theoretical concepts of universal quantum gates, accuracy, and fidelity in quantum computing, which involves understanding the principles and theories behind quantum computing.",Theoretical ,,,,Theoretical ,
12509.0,Is there a way to grab probablities of my qubits in Q#?,"<p><a href=""https://qiskit.org/textbook/ch-algorithms/grover.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/grover.html</a>
I am looking for a visual, or just probabilities like the ones given in the link.Is this possible on Q#?</p>
",<programming><q#>,6/16/2020 8:11,12510.0,12510.0,"<p>You can use <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpmachine"" rel=""nofollow noreferrer"">DumpMachine</a> to dump the amplitudes and probabilities of the states; for Grover search it will give you something like this:</p>

<p><a href=""https://i.stack.imgur.com/0MHs0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0MHs0.png"" alt=""enter image description here""></a></p>
",6/16/2020 8:23,Tooling,The question is related to the possibility of creating visual representations or probability distributions similar to the ones shown in a provided link using Q#. It pertains to the use of Q# and associated tools to achieve a specific visualization or result.,Tooling,,,,Tooling,
12520.0,"Q# Error: No namespace with the name ""Microsoft.Quantum.MachineLearning"" exists","<p>I'm having trouble getting the namespace <code>Microsoft.Quantum.MachineLearning</code>.</p>

<p>Here is an example Q# code:</p>

<pre><code>namespace Temp {
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.MachineLearning;

    operation Hello () : Unit{
        Message(""Hello"");
    }
}
</code></pre>

<p>Here is the python script which drives the code:</p>

<pre><code>import qsharp
from qsharp import Result
import json
import os
from Temp import Hello
Hello.simulate()
</code></pre>

<p>Here's the error that the VSCode terminal shows:</p>

<pre><code>Preparing Q# environment...
fail: Microsoft.Quantum.IQSharp.Workspace[0]
      QS6104: No namespace with the name ""Microsoft.Quantum.MachineLearning"" exists.
Traceback (most recent call last):
  File ""Driver.py"", line 5, in &lt;module&gt;
    from Temp import Hello
ModuleNotFoundError: No module named 'Temp'
</code></pre>

<p>Here are my component versions:</p>

<pre><code>&gt;&gt;&gt; qsharp.component_versions()
{'iqsharp': LooseVersion ('0.11.2004.2825'), 'Jupyter Core': LooseVersion ('1.3.52077.0'), '.NET Runtime': LooseVersion ('.NETCoreApp,Version=v3.1'), 'qsharp': LooseVersion ('0.11.2004.2825')}
</code></pre>

<p>I've tried adding the package manually into my conda environment:</p>

<pre><code>&gt;&gt;&gt; qsharp.packages.add(""Microsoft.Quantum.MachineLearning::0.11.2004.2825"")
Adding package Microsoft.Quantum.MachineLearning::0.11.2004.2825.&gt;&gt;&gt; qsharp.reload()
</code></pre>

<p>But that doesn't help.</p>

<p>Also, it's worth to note that there is no such problem when I try to do the same in a local Jupyter Notebook which is weird since they run in the same environment.</p>
",<programming><q#><machine-learning>,6/17/2020 10:59,12522.0,12522.0,"<p>You'll need to actually add these two lines into your Python script:</p>

<pre><code>qsharp.packages.add(""Microsoft.Quantum.MachineLearning::0.11.2004.2825"")
qsharp.reload()
</code></pre>

<p>This causes the packages to be loaded and available at runtime.</p>

<p>You need those two lines before you call <code>from Temp import Hello</code>, otherwise you will get the errors since you try to open the <code>Microsoft.Quantum.MachineLearning</code> namespace inside your <code>Temp</code> namespace.</p>

<p>Notice that you may still see an error message that says <code>No namespace with the name ""Microsoft.Quantum.MachineLearning"" exists</code> due to the behavior of <code>import qsharp</code> (see <a href=""https://github.com/microsoft/iqsharp/issues/171"" rel=""nofollow noreferrer"">this issue</a> for more details), but your code should then compile and run successfully anyway, in which case you can ignore that error message.</p>
",6/17/2020 13:53, Errors,"This question falls under the ""Errors"" category because it pertains to a specific error message related to the absence of the ""Microsoft.Quantum.MachineLearning"" namespace, and the user is seeking a solution or explanation for this error in quantum program development.",Errors,,,, Errors,
12542.0,Graph coloring - Q# -,"<p>I am checking Q# - Graph coloring</p>
<pre><code>                for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) {
                InitializeColor(C, register);
</code></pre>
<p>Can you help me explain this part of the code?</p>
<p>Thnx</p>
<pre><code>        for (N in 1 .. 4) {
            using (register = Qubit[N]) {
                for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) {
                    InitializeColor(C, register);
                    let measurementResults = MultiM(register);
                    Fact(ResultArrayAsInt(measurementResults) == C, 
                        $&quot;Unexpected initialization result for N = {N}, C = {C} : {measurementResults}&quot;);
                    ResetAll(register);
                }
            }
        }
    }


</code></pre>
",<programming><q#>,6/18/2020 20:33,12555.0,12555.0,"<p>This is part of the <strong>Graph Coloring Kata</strong>. The <code>InitializeColor</code> is an operation that you must implement. The code above is part of the checker code to confirm the working of the implementation.</p>
<p>The code is used to check if the <code>InitializeColor</code> operation is implemented correctly. It is supposed to take an input <code>C</code> denoting the color as an non-negative integer. It is supposed to apply a unitary to convert the state <span class=""math-container"">$|000...0\rangle$</span> to state denoted by LittleEndian encoding of <span class=""math-container"">$|C\rangle$</span>.</p>
<p>The <code>InitializeColor</code> operation is supposed to take a register which is in the state <span class=""math-container"">$|0..0\rangle$</span> and applies a Unitary which transforms it into a register in the state <span class=""math-container"">$|C\rangle$</span>. The nextline measures the register using the <code>MultiM</code> operation.
The <code>Fact</code> function essentially confirms if the measured result in the state <span class=""math-container"">$|C\rangle$</span> and if not it print the error statement. The last line resets the register and brings it back to the state <span class=""math-container"">$|000..0\rangle$</span>.</p>
<p>An example can be with <span class=""math-container"">$C=2$</span> and <span class=""math-container"">$N=4$</span>. Then <code>InitializeColor</code> should apply a Unitary Operation which transform <span class=""math-container"">$|0000\rangle$</span> into <span class=""math-container"">$|0100\rangle$</span> assuming LittleEndian encoding or <span class=""math-container"">$|0010\rangle$</span> assuming BigEndian encoding.</p>
",6/19/2020 13:00, Conceptual,"This question belongs to the ""Conceptual"" category because it seeks an explanation and understanding of a specific part of the code related to graph coloring in Q#. The user is not encountering an error but is looking for clarification and comprehension of the code's functionality.",Conceptual,,,, Conceptual,
12550.0,How to append an Instruction to a QuantumCircuit with variable length of QuantumRegisters as qargs?,"<p>I <em>think</em> it is a bug but I'm not really sure. Basically, what I'm trying to do is the following: I have an Oracle Instruction which I want to append to my QuantumCircuit, looks as follows:</p>
<pre><code># initialising registers for readability
[control, train_register] = circ.qregs

circ.h(control)

# create and append oracle
oracle = create_oracle(train_register, control)  # returns an Instruction
circ.append(oracle, [train_register, control])
</code></pre>
<p>If my <code>train_register</code> and <code>control</code> are both <code>QuantumRegisters</code> with length 1, this works perfectly fine. But I want to make this work for variable length of these registers, I get the error <code>qiskit.circuit.exceptions.CircuitError: 'The amount of qubit arguments does not match the instruction expectation.'</code>.</p>
<p>This is logical, since this error occurs because qiskit checks the length of my provided <code>qargs</code> in <code>QuantumCircuit.append()</code>, and I provided two registers in a list with both one qubit, so the length of the list happens to be the same as the number of qubits.</p>
<p>However, I want this to work for variable length. If I <em>know</em> what the length of my <code>QuantumRegister</code>s are, say <code>len(train_register)</code> is 3 and <code>len(control)</code> is 1 I can use</p>
<pre><code>circ.append(oracle, [0, 1, 2, 3])
</code></pre>
<p>Or to make it work for unspecified lengths, I can write something like:</p>
<pre><code>indices_to_append_to = list(np.arange(len(train_register) + len(control)))
circ.append(oracle, indices_to_append_to)
</code></pre>
<p>But I just really like the idea of just plugging in the names of the <code>qregs</code> as <code>qargs</code>. Is there something to make this work like that?</p>
",<quantum-gate><algorithm><qiskit><programming><circuit-construction>,6/19/2020 8:32,12551.0,12551.0,"<p>If you pass a list of qubits instead of a list of register this works. For this do</p>
<pre><code>circ.append(oracle, train_register[:] + control[:])
</code></pre>
<p>where <code>train_register</code> and <code>control</code> are <code>QuantumRegister</code>s.</p>
",6/19/2020 8:49,Errors,"The user is encountering an error message while trying to append an oracle to a QuantumCircuit in Qiskit, and is seeking a solution.",API Usage,"The user is encountering an issue related to how to correctly use Qiskit's QuantumCircuit API to append an Oracle Instruction to a variable number of qubits within QuantumRegisters. This falls under the API Usage category, as it pertains to the usage of Qiskit's API for building quantum circuits.",No,91.0, API Usage," The user is seeking guidance on how to correctly use the Qiskit QuantumCircuit API to append an Oracle Instruction to a variable number of qubits within QuantumRegisters, indicating a need for understanding and utilizing the API effectively."
12572.0,Is it possible to create a gate in Q# that is dictated by a matrix?,"<p>When observing the Hadamard gate it is simply a transformation matrix. I am wondering if there is functionality to hard code an arbitrary transformation matrix and its family members up till <span class=""math-container"">$m \times n$</span> size depending on the limitations of the simulation. From here I would like the hard coded gate to transform my register of qubits.</p>
",<quantum-gate><programming><circuit-construction><q#>,6/20/2020 4:16,12818.0,12818.0,"<p>There is currently an Issue (<a href=""https://github.com/microsoft/QuantumLibraries/issues/291"" rel=""nofollow noreferrer"">#291</a>) raised on the <em>Microsoft QuantumLibraries GitHub</em> regarding an operation called <code>ApplyUnitaryOperation(unitary: Complex[][], qubits : LittleEndian)</code> which aims to do what you are asking. This functionality doesn't exist right now but it was also discussed on the <a href=""https://gitter.im/qsharp-community/community"" rel=""nofollow noreferrer"">Q# Community Gitter</a> a while ago. Hopefully it will be added as a feature in the future.</p>
",07/07/2020 21:24,Tooling,"The question is primarily focused on the practical implementation aspect of using a quantum programming framework to implement an arbitrary transformation matrix as a gate and applying it to a quantum register. This falls under the ""Tooling"" category.",Tooling ,,,,Tooling,
12574.0,How can I create a basis state of $n$ qubits in Q#?,"<p>I would like to create a set of basis qubits. For example if I have <span class=""math-container"">$n=2$</span> I should get 4 states being 01 10 11 00. Generalized for <span class=""math-container"">$2^n$</span>. Is there a way to do this in Q#?</p>
",<quantum-state><programming><q#>,6/20/2020 5:07,12612.0,12612.0,"<p><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.preparation.prepareuniformsuperposition"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.preparation.prepareuniformsuperposition</a>
Provides a nice operation to set register as LE and create the above script but a bit more efficiently without use of for loop.</p>
",6/22/2020 19:49, Tooling,"The user is asking about a specific functionality in the Q# programming language, which involves understanding and using the tool correctly. ",Tooling,,,, Tooling,
12585.0,Representation of rotation operators $e^{-i\theta(I-Z_1\otimes Z_2 \otimes Z_3)}$ about arbitrary axis for $3$ qubits,"<p>I was wondering in how to interpret and represent the operator <span class=""math-container"">$e^{-i\theta(I-Z_1\otimes Z_2 \otimes Z_3)}$</span> for a 3 qubit system in a circuit using qiskit.</p>
<p>I was thinking I could just perform an individual <span class=""math-container"">$\theta$</span> degree rotation about each qubit Z axis but what about the identity? <span class=""math-container"">$e^{-i\theta I} = \begin{bmatrix}
e^{-i \theta } &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 
0 &amp;  e^{-i\theta}&amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 
 0 &amp; 0 &amp; e^{-i\theta} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\ 
 0 &amp; 0 &amp; 0 &amp; e^{-i\theta} &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{-i\theta} &amp; 0 &amp; 0 &amp; 0  \\ 
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp;e^{-i\theta} &amp; 0 &amp; 0  \\ 
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp;e^{-i\theta}  &amp; 0 \\  
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{-i\theta}
\end{bmatrix} $</span></p>
<p>I can construct this operator with the identity operator in 2 qubits and one identity with a global phase <span class=""math-container"">$e^{-i\theta}$</span>. Isn't this just an identity with a global phase factor?</p>
",<qiskit><programming><circuit-construction><hamiltonian-simulation><matrix-representation>,6/20/2020 23:14,12591.0,12591.0,"<p>We can't implement <span class=""math-container"">$e^{iZ_1 \otimes Z_2 \otimes Z_3 \theta}$</span> with three separate rotations. In other words:</p>
<p><span class=""math-container"">$$e^{iZ_1 \otimes Z_2 \otimes Z_3 \theta} \ne e^{i Z_1 \theta} \otimes e^{i Z_2 \theta} \otimes e^{i Z_3 \theta}$$</span></p>
<p>The implementation of this gate can be found in this <a href=""https://quantumcomputing.stackexchange.com/a/11373/9459"">answer</a>. The <span class=""math-container"">$e^{-iI \otimes I \otimes I\theta} = e^{-i\theta} I \otimes I \otimes I$</span> term is a global phase gate and can be ignored for the case described in the question.</p>
<hr />
<p><strong>An implementation with Qiskit:</strong></p>
<pre><code>from qiskit import *
from qiskit.aqua.operators import WeightedPauliOperator

theta = 1.7
pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0.0, &quot;real&quot;: theta}, &quot;label&quot;: &quot;ZZZ&quot;},
                         {&quot;coeff&quot;: {&quot;imag&quot;: 0.0, &quot;real&quot;: -theta}, &quot;label&quot;: &quot;III&quot;}
                         ]
              }
operator = WeightedPauliOperator.from_dict(pauli_dict)
circuit = operator.evolve(evo_time=1).decompose()
print(circuit)
</code></pre>
<p>The output:</p>
<pre><code>q3_0: âââ ââââââââââââââââââââââââââ ââ
      âââ´ââ                     âââ´ââ
q3_1: â¤ X ââââ ââââââââââââââââ âââ¤ X â
      ââââââââ´ââââââââââââââââ´âââââââ
q3_2: ââââââ¤ X ââ¤ U1(3.4) ââ¤ X ââââââ
           âââââââââââââââââââââ     
</code></pre>
<p>That coincides with the ideas discussed in this <a href=""https://quantumcomputing.stackexchange.com/a/11373/9459"">answer</a> (<span class=""math-container"">$u1$</span> and <span class=""math-container"">$R_z$</span> gates are different just by a global phase). Note, that here <span class=""math-container"">$e^{-iI\theta}$</span> is a global phase and can be neglected (as was done in the circuit). However, as was discussed in this <a href=""https://quantumcomputing.stackexchange.com/a/11406/9459"">answer</a> the controlled-<span class=""math-container"">$e^{-i I \theta}$</span> should be implemented if one needs to construct controlled-<span class=""math-container"">$e^{-i H \theta}$</span>, where <span class=""math-container"">$H$</span> is a sum of tensor product terms of Pauli matrices with real coefficients (like <span class=""math-container"">$H = I - Z\otimes Z\otimes Z$</span> in the question's example) and one of the terms is <span class=""math-container"">$I$</span>. Also, note that the code presented above works only for such <span class=""math-container"">$H$</span> whose terms commute. For more general cases one should also specify the rest of the arguments of the <code>evolve</code> method in order to implement for example first-order Trotter decomposition.</p>
",6/21/2020 9:41,Conceptual,"This question falls under the ""Conceptual"" category as it seeks an understanding of how to interpret and represent a specific quantum operator involving Pauli-Z gates and identity operators in Qiskit. The user is looking for a conceptual explanation of whether this operator can be simplified and whether it is equivalent to an identity with a global phase factor.", Conceptual ,,,,Conceptual,
12592.0,What's the relationship between output of qubit measurements and classification of data in Quantum Machine Learning?,"<p>I'm training a model in Q# which has more than 2 features. <br>
I have trouble understanding the following things:</p>
<ul>
<li>How is the data classified based on the qubit states?</li>
</ul>
<p>For example: If I have only 2 features (and want to classify our input as class A and class B) then only a single qubit would be used.<br> After measuring if the qubit turns out to be in the 0 state then its class A and in case of 1 its class B (or vice-versa).
<br><br>
But now if I have say 4 features then 2 qubits would be used and i could have 4 possible outcomes:<br></p>
<p><span class=""math-container"">$$
|00\rangle,\quad  |01\rangle,\quad  |10\rangle,\quad  |11\rangle.
$$</span></p>
<p>So how would the data be classified based on these states?</p>
<ul>
<li>Also am I correct in thinking that all the qubits are measured or is only 1 qubit measured and classified as class A/B?</li>
</ul>
",<q#><machine-learning>,6/21/2020 9:42,12641.0,12641.0,"<p>Only one qubit is measured; the frequency of getting 0/1 result in this measurement (rather than a single measurement result) is used together with the bias to assign the class.</p>
<p>If you dig into the source code of the QML library, the measurement is performed in <a href=""https://github.com/microsoft/QuantumLibraries/blob/bb75af3caa54b99b6e68989fe9fb1de0cc6d0b65/MachineLearning/src/Classification.qs#L40"" rel=""nofollow noreferrer"">EstimateClassificationProbability</a> operation, which measures the last qubit of the register.</p>
",6/24/2020 18:30, Conceptual,"This question falls under the ""Conceptual"" category as it seeks an understanding of how quantum machine learning models classify data based on the states of qubits. The user is looking for a conceptual explanation of how qubits are used for classification and whether all qubits are measured or just one for classification.", Conceptual,,,, Conceptual,
12598.0,What is the shortest sequence of decomposition a given single-qubit unitary gate,"<p>Given a single-qubit unitary matrix, can we find the shortest sequence of Clifford + T gates that correspond to that unitary?</p>
<p>According to <a href=""https://arxiv.org/abs/1206.5236"" rel=""nofollow noreferrer"">Fast and efficient exact synthesis of single qubit unitaries generated by Clifford and T gates</a> , which is Solovay-Kitaev decomposition, I learned single-qubit decomposition may need <span class=""math-container"">$O(\log^{3.97} (1/\delta))$</span> clifford+T gates with the accuracy <span class=""math-container"">$\delta$</span>.</p>
<p>And later many optimization is worked on it.
For example:
<a href=""https://arxiv.org/pdf/1306.3200.pdf"" rel=""nofollow noreferrer"">Synthesis of unitaries with Clifford+T circuits</a></p>
<p>So I want to know if there exists a shortest sequence of Clifford + T gates that correspond to decompose any single-qubit unitary into Clifford+T?
If it existed, what is commonly used in current compiler?</p>
",<quantum-gate><quantum-state><programming>,6/22/2020 5:10,12599.0,12599.0,"<p>In the abstract of the first paper you cite (which, incidentally, is <em>not</em> Solovay-Kitaev, it's an improvement), they say</p>
<blockquote>
<p>We report an efficient synthesis algorithm, with an exact optimality guarantee on the number of Hadamard and T gates used</p>
</blockquote>
<p>In other words, this is the best that can be done. It yields the shortest possible sequence. This best is <span class=""math-container"">$O(\log\frac{1}{\delta})$</span> Hadamard + T.</p>
",6/22/2020 7:17,Theoretical,"This question falls under the ""Theoretical"" category as it pertains to the theoretical aspect of decomposing single-qubit unitary matrices into sequences of Clifford + T gates. The user is inquiring about the existence of a shortest sequence for this decomposition and its practical use in current quantum compiler technologies.",Theoretical,,,,Theoretical,
12602.0,Finding phase angle in Q#,"<p>I've trying to measure the phase angle from X axis of a qubit, but unable to find any function in Q# documentation, can anyone help me with this?</p>
",<quantum-state><entanglement><q#><phase-estimation>,6/22/2020 9:43,12768.0,12768.0,"<p>If this is part of a debugging effort then you can use the <code>DumpRegister</code> function.
If you have a qubit <code>q</code> which is in the general state <span class=""math-container"">$\alpha|0\rangle + \beta|1\rangle$</span> where <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> are complex numbers such that <span class=""math-container"">$|\alpha|^2+|\beta|^2=1$</span>.</p>
<pre><code>DumpRegister([q])
</code></pre>
<p>will give an output like this (<em>Having Different Numbers</em>)</p>
<pre><code># wave function for qubits with ids (least to most significant): 1
â£0â­:     0.707107 +  0.000000 i  ==     ***********          [ 0.500000 ]     --- [  0.00000 rad ]
â£1â­:    -0.500000 + -0.500000 i  ==     ***********          [ 0.500000 ]  /      [ -2.35619 rad ]
</code></pre>
<p>However if the qubit is entangled with some other qubit the result would be</p>
<pre><code>Qubits provided (0;) are entangled with some other qubit.
</code></pre>
<p>Each row of the output tells the Amplitude of the Qubit along the Particular Computational Basis. The left hand values are in the Regular Complex Notation (Real and Imaginary Parts) and right hand values are in [Probability] [Phase].<br />
The phase angle with <span class=""math-container"">$X$</span> axis is simply the <span class=""math-container"">$\arctan$</span> of the ratio of the absolute values of the amplitudes.</p>
<p><strong>Proof:</strong></p>
<p>Let us say the results give the amplitudes of basis states <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> as <span class=""math-container"">$\alpha = \alpha_R + i\alpha_I = |\alpha|e^{i\theta_1}$</span> and <span class=""math-container"">$ \beta = \beta_R + i\beta_I =|\beta|e^{i\theta_2} $</span> respectively.<br />
Then <code>q</code> is in the state <span class=""math-container"">$\alpha|0\rangle + \beta|1\rangle = |\alpha|e^{i\theta_1}|0\rangle + |\beta|e^{i\theta_2}|1\rangle$</span>.<br />
We can remove the global phase and thus the relative phase will be <span class=""math-container"">$e^{i\theta_1-i\theta_2} = e^{i\theta}$</span> and let <span class=""math-container"">$\phi = 2\arctan\frac{|\beta|}{|\alpha|}$</span>.<br />
Thus <code>q</code> is in the state <span class=""math-container"">$\cos\frac{\theta}{2}|0\rangle + e^{i\theta}\sin\frac{\theta}{2}|1\rangle$</span>.
This state can be represented on the Bloch Sphere by the coordinates <span class=""math-container"">$(\sin\theta\cos\phi, \sin\theta\sin\phi, \cos\theta)$</span>. Consequently the phase angle with X axis is given by <span class=""math-container"">$\arctan$</span> of the <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> coordinates. Thus the phase angle is <span class=""math-container"">$\phi=2\arctan\frac{|\beta|}{|\alpha|}$</span></p>
",07/03/2020 15:47, Tooling," The user is asking for help with a specific function in Q#, a quantum programming language, to measure the phase angle of a qubit",Tooling,,,, Tooling,
12604.0,Quantum Katas - Tutorials - SingleQubitGates - Exercise 2 - GlobalPhaseI,"<p>Program.qs</p>
<pre><code>namespace Quantum.Kata.SingleQubitGates {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Math;
    
    
     operation GlobalPhaseI (q : Qubit) : Unit is Adj+Ctl {
        X(q);
        Z(q);
        Y(q);

    }
}
</code></pre>
<p>Reference.qs</p>
<pre><code>namespace Quantum.Kata.SingleQubitGates {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Math;
    

    
    operation GlobalPhaseI_Reference (q : Qubit) : Unit is Adj+Ctl {
        X(q);
        Z(q);
        Y(q);
    }
}
</code></pre>
<p>Test.qs</p>
<pre><code>    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Convert;
    

    operation ControlledArrayWrapperOperation (op : (Qubit =&gt; Unit is Adj+Ctl), qs : Qubit[]) : Unit is Adj+Ctl {
        Controlled op([qs[0]], qs[1]);
    }

    operation AssertEqualOnZeroState (testImpl : (Qubit =&gt; Unit is Ctl), refImpl : (Qubit =&gt; Unit is Adj+Ctl)) : Unit {
        using (qs = Qubit[2]) {
            within {
                H(qs[0]);
            }
            apply {
               
                Controlled testImpl([qs[0]], qs[1]);

              
                Adjoint Controlled refImpl([qs[0]], qs[1]);
            }

          
            AssertAllZero(qs);
        }
    }

    operation T2_GlobalPhaseI_Test () : Unit {
        AssertOperationsEqualReferenced(2, ControlledArrayWrapperOperation(GlobalPhaseI, _), ControlledArrayWrapperOperation(GlobalPhaseI_Reference, _));
    }

</code></pre>
<p>Driver.cs</p>
<pre><code>
using Microsoft.Quantum.Simulation.XUnit;
using Microsoft.Quantum.Simulation.Simulators;

using Xunit.Abstractions;

namespace Quantum.Kata.SingleQubitGates
{
    public class TestSuiteRunner
    {
        private readonly ITestOutputHelper output;

        public TestSuiteRunner(ITestOutputHelper output)
        {
            this.output = output;
        }

        /// &lt;summary&gt;
   
        /// &lt;/summary&gt;
        [OperationDriver(TestNamespace = &quot;Quantum.Kata.SingleQubitGates&quot;)]
        public void TestTarget(TestOperation op)
        {
            using (var sim = new QuantumSimulator())
            {
    
                sim.OnLog += (msg) =&gt; { output.WriteLine(msg); };
                sim.OnLog += (msg) =&gt; { Debug.WriteLine(msg); };
                op.TestOperationRunner(sim);
            }
        }
    }
}

</code></pre>
",<programming><q#>,6/22/2020 10:54,12608.0,12608.0,"<p>Yes, this sequence of gates will work to apply the global phase of <span class=""math-container"">$i$</span>. You can check it using matrix multiplication - a product of matrices <span class=""math-container"">$Y \cdot Z \cdot X$</span> will give you a matrix <span class=""math-container"">$\begin{bmatrix} i &amp; 0 \\ 0 &amp; i \end{bmatrix}$</span>, which corresponds to applying a global phase.</p>
<p>Alternatively, you can implement it using <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.r"" rel=""nofollow noreferrer"">R gate</a> with the phase <span class=""math-container"">$-\pi$</span>: <code>R(PauliI, -PI(), q);</code></p>
<p>As a side note, performing measurements this way is not going to detect a global phase introduced by the gate; you need to work with a controlled version of the gate to detect it.</p>
",6/22/2020 17:59,Tooling,"The provided code snippets and files appear to be related to setting up a testing framework for quantum operations in Q#. The code involves creating a test suite runner, defining test operations, and using a quantum simulator for testing. This falls under the ""Tooling"" category as it pertains to the tools and setup for testing quantum operations.",Tooling,,,,Tooling,
12619.0,Error code: 3458,"<p>I ran my qsvm code on the quantum computer and I'm facing the following error:</p>
<pre><code>FAILURE: Can not get job id, Resubmit the qobj to get job id. Terra job error: &quot;Error submitting job: '400 Client Error: Bad Request for url: https://api.quantum-computing.ibm.com/api/Network/ibm-q/Groups/open/Projects/main/Jobs. Reached maximum number (5) of concurrent jobs, **Error code: 3458.**'&quot; 
Job limit reached, waiting for job 5ef1bc3ecd20b1001387fa06 to finish before submitting the next one.
FAILURE: Job id: 5ef1bc4edab6ee0013416233 is cancelled. Re-submit the Qobj.
FAILURE: Job id: 5ef1bc546daf510014814cd8 is cancelled. Re-submit the Qobj.
FAILURE: Job id: 5ef1bc5a13b5f900139e97c5 is cancelled. Re-submit the Qobj.
FAILURE: Job id: 5ef1bc62c7453600138726d0 is cancelled. Re-submit the Qobj.
</code></pre>
<p>The last line is repeating every few minutes. The url does not exist. I did run my code on the simulator and it worked.
It uses <strong>5 features and hence 5 qubits</strong>. Could anyone please help me out?
The code:</p>
<pre><code>data = np.genfromtxt('diabetes.csv', delimiter=',', names=True, case_sensitive=True)
data = np.array(data.tolist()) # was an array of arrays earlier
data = np.delete(data, 7, axis = 1)
data = np.delete(data, 3, axis = 1)
data = np.delete(data, 2, axis = 1)
print(data.shape)
x = np.copy(data[:,0:5]) #features
y = np.copy(data[:,5]) #targets
features = 5
from sklearn.model_selection import train_test_split
import qiskit
from qiskit import BasicAer
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import QSVM
  
from qiskit.aqua.components.multiclass_extensions import one_against_rest, all_pairs
from qiskit.aqua.components.feature_maps import SecondOrderExpansion
provider = qiskit.IBMQ.load_account()
backend = provider.get_backend('ibmq_16_melbourne')
train_x, test_x, train_y, test_y = train_test_split(x[0:101], y[0:101], test_size=0.2)

training_data = {'A':train_x[train_y==0],'B':train_x[train_y==1]}
testing_data = {'A':test_x[test_y==0],'B':test_x[test_y==1]}
feature_map = SecondOrderExpansion(feature_dimension=features,depth=2,entanglement='full')
svm = QSVM(feature_map,training_data,testing_data)
shots = 1 
quantum_instance = QuantumInstance(backend,shots=shots,skip_qobj_validation=False)
%%time
result = svm.run(quantum_instance) 
</code></pre>
",<qiskit><programming>,6/23/2020 8:53,12623.0,12623.0,"<p>tldr: this is caused by a change in behavior of the IQX server that needs to be fixed.</p>
<p>Aqua may submit multiple jobs for an experiment under the cover. However, with a public account, you can only have 5 jobs running in parallel at the same time. That's what caused the first error:</p>
<pre><code>FAILURE: Can not get job id, Resubmit the qobj to get job id. Terra job error: &quot;Error submitting job: '400 Client Error: Bad Request for url: https://api.quantum-computing.ibm.com/api/Network/ibm-q/Groups/open/Projects/main/Jobs. Reached maximum number (5) of concurrent jobs, **Error code: 3458.**'&quot; 
</code></pre>
<p>Aqua then tried to wait for the oldest job to finish before submitting the next one, as indicated by this message:</p>
<pre><code>Job limit reached, waiting for job 5ef1bc3ecd20b1001387fa06 to finish before submitting the next one.
</code></pre>
<p>Instead of waiting indefinitely for the oldest, the code retries the submit every 5 minutes, in case a spot frees up for some reason. It looks like there is a behavior change so that instead of getting another 3458 error, the retried submit went through but the job was immediately cancelled, giving the rest of the error messages. Without the 3458 error, Aqua just kept re-submitting the jobs which kept getting cancelled.</p>
",6/23/2020 13:17, Errors,"The user is encountering an error while running their quantum support vector machine (QSVM) code on a quantum computer, specifically an issue with job submission and receiving the error code 3458",Errors,,,, Errors,
12627.0,"If two reduced density matrices are equal, does that mean that the two subsystems are the same?","<p>Suppose we have a <span class=""math-container"">$3$</span>-qubit system at time <span class=""math-container"">$t_0$</span> in the state
<span class=""math-container"">$$\vert{\psi(t_0)}\rangle= \vert{q_0}\rangle \otimes \vert{q_1} \rangle \otimes \vert{q_2}\rangle.
$$</span>
<img src=""https://i.stack.imgur.com/IgnEa.png"" alt=""1"" />
We want to check if, for instance, the first qubit at time <span class=""math-container"">$t_1$</span> is equals to itself at time <span class=""math-container"">$t_0$</span>:</p>
<p><span class=""math-container"">$$\vert{\psi(t_1)} \rangle = \vert{q_0} \rangle \otimes \vert{\phi} \rangle,
$$</span>
where <span class=""math-container"">$\vert{\phi} \rangle$</span> is the state of the qubits <span class=""math-container"">$q_1, q_2$</span> after the operations.</p>
<p>My first attempt is to calculate the reduced density matrix using the partial trace over the two other qubits, to get the reduced density matrix at <span class=""math-container"">$t_0$</span> and <span class=""math-container"">$t_1$</span>:</p>
<p><span class=""math-container"">$$\rho^0(t_0) = \operatorname{Tr}_{12}(\rho(t_0)),\\
\rho^0(t_1) = \operatorname{Tr}_{12}(\rho(t_1)).$$</span>
So my question is:
is there an equivalence relation between the equality of the reduced matrices and the two subsystems being in the same state?</p>
<p><span class=""math-container"">$$\rho^0(t_0) = \rho^0(t_1) \Leftrightarrow \vert{q_0}\rangle = \text{the state of the subsystem at }t_1 $$</span></p>
",<quantum-state><programming><entanglement><random-quantum-circuit>,6/23/2020 20:59,12629.0,12629.0,"<p>Density matrix completely describes the state of a system (or a subsystem). So if two density matrices are equal then the two states are equal (and vice versa).</p>
<p>But you should not forget that</p>
<ol>
<li>The state of a subsystem can be mixed (e.g. look at the Bell state <span class=""math-container"">$\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)$</span>). Density matrices uniquely describe mixed states as well, so calculating the partial trace is the most general method for checking the equality.</li>
<li>In general, the state of the whole system isn't completely determined by the states of subsystems. So, we can't deduce the equality of the whole states if states of subsystems are equal.</li>
</ol>
",6/24/2020 4:53,Theoretical,"This question belongs to the ""Theoretical"" category as it involves a theoretical concept related to quantum states and reduced density matrices. The user is seeking to understand if there is an equivalence between the equality of reduced density matrices and the subsystems being in the same state, which is a theoretical aspect of quantum mechanics.",Theoretical ,,,,Theoretical,
12639.0,Find orthogonal state for random 7 qubit state,"<p>I have a system that generates a random 7 qubit state and I need a method to always find the orthogonal state.</p>
<p>I'm currently using python and qutip for this, representing this 7 qubit state by a 128-dimensional vector.</p>
",<algorithm><programming><qutip>,6/24/2020 17:19,12640.0,12640.0,"<p>Basically, you divide the entire <span class=""math-container"">$7$</span>-qubit Hilbert space into two subspaces: the one spanned by your state (let's call the state <span class=""math-container"">$|\psi\rangle$</span>), let's call that subspace <span class=""math-container"">$W$</span>, and it's orthogonal complement <span class=""math-container"">$V = W^{\perp}$</span>. You want <em>any</em> vector from <span class=""math-container"">$V$</span>, because this will by definition be orthogonal.</p>
<p>We know that <span class=""math-container"">$P_{V}$</span> + <span class=""math-container"">$P_{W} = I$</span>, with <span class=""math-container"">$P_{V}$</span> and <span class=""math-container"">$P_{W}$</span> being the projectors upon the <span class=""math-container"">$V$</span> and <span class=""math-container"">$W$</span> subspaces. Since <span class=""math-container"">$P_{W} = |\psi\rangle\langle\psi|$</span>, we can easily calculate <span class=""math-container"">$P_{V}$</span>:</p>
<p><span class=""math-container"">$$
P_{V} = I - |\psi\rangle\langle\psi|.
$$</span>
We can let this projection matrix act on virtually <em>any</em> state to obtain a state orthogonal on <span class=""math-container"">$|\psi\rangle$</span>, lets use the <span class=""math-container"">$0$</span> vector <span class=""math-container"">$|00....0\rangle$</span>. An orthogonal state <span class=""math-container"">$|\psi^{\perp}\rangle$</span> to <span class=""math-container"">$|\psi\rangle$</span> is thus:</p>
<p><span class=""math-container"">$$
|\psi^{\perp}\rangle = P_{V}|00...0\rangle = (I - |\psi\rangle\langle\psi|)|00...0\rangle = |00...0\rangle - \langle\psi|00...0\rangle|\psi\rangle
$$</span></p>
<p>which is more or less the Gram-Schmidt process.</p>
<p>Note that you can use (almost) <em>any</em> state instead of <span class=""math-container"">$|00...0\rangle$</span>; the only state that you <em>cannot</em> use is <span class=""math-container"">$|\psi\rangle$</span> itself.</p>
<p>In python, this becomes something like:</p>
<p><code>from numpy import zeros_like, inner</code></p>
<p><code>zeros_vect = zeros_like(psi_orig)</code></p>
<p><code>psi_orth = zeros_vect - inner(zeros_vect,psi_orig).conj()*psi_orig</code></p>
",6/24/2020 17:42,Theoretical ,"The user is asking about theoretical concepts in quantum computing, specifically about finding an orthogonal state to a given 7-qubit state. ",Theoretical,,,,Theoretical ,
12662.0,How can I create an n-dimensional Hadamard transform in Q#?,"<p>I would like to create a n-dimensional Hadamard transform in Q# with n in set of even integers.</p>
",<q#>,6/26/2020 1:06,12664.0,12664.0,"<p>If you're looking to implement <span class=""math-container"">$H^\otimes$</span> (i.e., applying the Hadamard transform to each of the <span class=""math-container"">$n$</span> qubits), you can use library operation <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applytoeach"" rel=""nofollow noreferrer"">ApplyToEach</a>:</p>
<pre><code>using (register = Qubit[n]) {
    ApplyToEach(H, register);
}
</code></pre>
<hr />
<p>If you are indeed looking for quantum Fourier transform, as the other answer suggests, the Q# library operation that implements it is <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applyquantumfouriertransform"" rel=""nofollow noreferrer"">ApplyQuantumFourierTransform</a>.</p>
",6/26/2020 1:45, Tooling," The user is asking about how to use Q#, a quantum programming language, to create an n-dimensional Hadamard transform. ",Tooling,,,, Tooling,
12683.0,What would be the difference between using qsharp library on python vs learning the Q# langauge?,"<p>One difference of course is the syntax. But I'm guessing the idea is eventually quantum computers will be able run Q#, whereas now it uses simulations. Will code written in Python with the qSharp library also be able to do this?</p>
",<simulation><q#>,6/27/2020 10:45,12691.0,12691.0,"<p>There are several separate questions entangled here.</p>
<p>Using Q# with Python as the host language is similar to using Q# with C# or another classical host language: it allows you to run Q# code and do necessary classical processing (for example, preparing the data or analyze the results). The Q# code invoked from the classical host language has to be written somewhere - it will be either the library code or the code you wrote yourself.</p>
<p>Learning Q# language itself allows you to implement any algorithm you want; without doing that, you'll be limited to using algorithms implemented by somebody else. That's certainly possible.</p>
<p>Running the program on quantum hardware vs in simulation is completely independent from the way you run it (from Python, C# or in standalone mode) - it's a matter of configuring the right target machine.</p>
",6/27/2020 18:51,Tooling," The user is asking about the differences between Q# and Python with the qSharp library, specifically in terms of their capabilities to run on quantum computers, which is a question about the usage of specific quantum programming languages and libraries.",Tooling,,,,Tooling,
12718.0,Entangling a register with another register using phase flips,"<p><a href=""https://i.stack.imgur.com/Bhaul.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Bhaul.jpg"" alt=""enter image description here"" /></a></p>
<pre><code> operation Algorithm() : Unit
 {
    using (register = Qubit[4])
    {
        within
            {
                PrepareUniformSuperposition(4,LittleEndian(register));
                ApplyToEach(register[2],register);
            }
    
</code></pre>
<p>I am having trouble with the ApplyToEach line. I am wondering if there is a way to entangle all the qubits in my register with another qubit, more broadly the 2(a) line 1. To my understanding I am satisfying the j term with uniform superposition. I am under the impression that when I apply the y-th qubit to my register I will entangle them. Maybe I am using the term entanglement wrong.</p>
",<programming><q#>,6/30/2020 8:34,12719.0,12719.0,"<p><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applytoeach"" rel=""nofollow noreferrer"">ApplyToEach</a> operation applies an operation to each element of the array, you can't apply a qubit to each element of the array.</p>
<p>It sounds like you're trying to prepare a state in which all qubits will be entangled (the definition of entanglement is that you can't represent a state of the system as a tensor product of states of subsystems, so entangling each qubit with one of them will mean the whole system will be entangled). There are lots of ways to do this (since there are a lot of entangled states); if you don't care which state it is, the first thing that comes to mind is applying a Controlled Z gate to change the phase of the <span class=""math-container"">$|1...1\rangle$</span> state to <span class=""math-container"">$-1$</span>:</p>
<pre><code>Controlled Z(register[0..2], register[3]);
</code></pre>
<p>If you're looking to prepare a specific state, you might want to clarify this in the question.</p>
<hr />
<p>To address the updated question:</p>
<ul>
<li>You need to allocate two registers, one to hold the values <span class=""math-container"">$|j\rangle$</span> and another to hold the values <span class=""math-container"">$|y\rangle$</span>.</li>
<li>The first line of 2(a) is almost satisfied with <code>PrepareUniformSuperposition</code>: after this the first register will hold <span class=""math-container"">$\sum_j\frac{1}{\sqrt{N}}|j\rangle$</span> and the second one <span class=""math-container"">$|0\rangle$</span>.</li>
<li>To finish preparing the state described in the first line of 2(a) you need to prepare the state <span class=""math-container"">$|y\rangle$</span> on the second register. That can be done by converting <span class=""math-container"">$y$</span> to binary and applying X gate to each qubit that corresponds to 1 bit.</li>
<li>To implement the second line of 2(a), you need to write some extra code that compares <span class=""math-container"">$j$</span> with <span class=""math-container"">$y$</span> and &quot;marks&quot; the state (I'm assuming flips the phase? It's not clear from the screenshot) - this step will indeed entangle the qubits of the two registers. You might want to read more about reversible computing and quantum oracles to do this.</li>
</ul>
",6/30/2020 8:42,Conceptual,"This question is related to the conceptual understanding of quantum programming, specifically about entanglement and the purpose of the ApplyToEach operation. The user is seeking clarity on the entanglement of qubits within a quantum register.",Conceptual,,,,Conceptual,
12728.0,A question about how does the single qubit gate simulated in simulator?,"<p>I have found the procedure of simulation process as this picture :
<a href=""https://i.stack.imgur.com/kzbY1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kzbY1.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://iopscience.iop.org/article/10.1088/2058-9565/aaa5cc/meta"" rel=""nofollow noreferrer"">Image reference</a>. So in the low-level compilers, all single-qubit gates are approximated by the universal gate set (CNOT, H, T, S).</p>
<p>When implementing arbitrary gates, I want to know if all simulators (like Qiskit) will do the low-level compilers job in this picture with a fixed accuracy. If so, what is the algorithm during this process? Are they using the Solovay-Kitaev Decomposition strategy (or some improved algorithm)?</p>
",<quantum-gate><quantum-state><programming><simulation>,07/01/2020 02:57,12731.0,12731.0,"<p>Generally, a simulator does not have to do any decomposition of gates to hardware-level specifics. Simulators only follow a mathematical model of a gate (described by matrix). Since each algorithm can be described by a matrix, whole simulation can be expressed as <span class=""math-container"">$|\psi_1\rangle = U |\psi_0\rangle$</span>, where <span class=""math-container"">$|\psi_0\rangle$</span> is initial state of a quantum computer, <span class=""math-container"">$|\psi_1\rangle$</span> is its final state and <span class=""math-container"">$U$</span> is a matrix describing algorithm. Hence, a simulation is reduced to matrix multiplication.</p>
<p>Some simulators artifically introduce noise present on real quantum hardware. This can be done by perturbation of matrices describing gates by a random variable.</p>
<p>Of course, it is possible to constrain a gate set on a simulator to have it more similar to real quantum processors. However, as I mentioned above, in the end you can have any gate you want, you are not constrained by quantum hardware specifics (unless you want to be) and any decomposition is not necessary.</p>
<p><em>Note: My answer is concerning gate-based computers. Adiabatic quantum computers case may be different.</em></p>
",07/01/2020 07:11,Tooling,"The user is asking about the low-level compilation process in quantum simulators like Qiskit, which involves the usage of specific quantum programming tools and software.", Tooling,,,,Tooling,
12729.0,How to do error mitigation on the ibmq_16_melbourne?,"<p>I'm trying to make a calibration matrix using CompleteMeasFitter as in <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">here</a> on IBMQ Melbourne, but I need to use all 15 qubits, which mean it has to run 32768 calibration circuit, far exceeding the 75 limit of the deivce (It returns <code>The number of experiments in the Qobj (32768) is higher than the number of experiments supported by the device (75) [1102]</code>.)</p>
<p>Is there any way for me to retrieve the mitigation matrix in this case? Maybe something IBM generates every time they calibrate the machine? Thank you!</p>
",<qiskit><programming><ibm-q-experience><error-correction><error-mitigation>,07/01/2020 05:34,13170.0,13170.0,"<p>I think in this case you can split the experiments into multiple jobs. The idea is that you split measurement calibration circuits generated by <code>complete_meas_cal</code> into a number of batches, execute the first batch and use the corresponding results to initialize a measurement correction fitter with <code>CompleteMeasFitter</code>. Then you can use the <code>CompleteMeasFitter.add_data</code> method to update the measurement correction fitter with the rest of calibration circuit batches. Finally, you will get the fitter you want. Here is a sample code for explanation. I use only four qubits for simplicity but this code can be generalized to 15 qubits for your case.</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer, IBMQ
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
device = provider.get_backend('ibmq_16_melbourne')

from qiskit.ignis.mitigation.measurement import (complete_meas_cal,CompleteMeasFitter)
# Generate the calibration circuits
qr = qiskit.QuantumRegister(4)
meas_calibs, state_labels = complete_meas_cal(qr=qr, circlabel='mcal')

#Split calibration circuits into two batches
job1_res = qiskit.execute(meas_calibs[0:8], backend=device, shots=1024,optimization_level=0).result()
job2_res = qiskit.execute(meas_calibs[8:16], backend=device, shots=1024,optimization_level=0).result()

#Initialize the measurement correction fitter with the first 8 calibration circuits
meas_fitter = CompleteMeasFitter(job1_res, state_labels, circlabel='mcal')
meas_fitter.plot_calibration()
</code></pre>
<p><a href=""https://i.stack.imgur.com/64nm2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/64nm2.png"" alt=""enter image description here"" /></a></p>
<pre><code>#Update the measurement correction fitter with the second 8 calibration circuits
meas_fitter.add_data(new_results=job2_res)
meas_fitter.plot_calibration()
</code></pre>
<p><a href=""https://i.stack.imgur.com/K7mVc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/K7mVc.png"" alt=""enter image description here"" /></a></p>
<p>We create a circuit with four qubits, so we get 16 calibration circuits. we split them into two batches. As you can see, if we plot the calibration matrix after initializing the measurement correction fitter with the first batch of calibration circuits, it only shows a half calibration matrix. After we update the fitter with the last batch of calibration circuits, we can see the full calibration matrix.</p>
<p>I hope my answer would help.</p>
",08/04/2020 18:33,Errors,The user is encountering an error while trying to create a calibration matrix using CompleteMeasFitter on IBMQ Melbourne due to the limit on the number of experiments that can be run on the device. ,Errors ,,,,Errors,
12739.0,How to implement a while loop in a quantum computer?,"<p>How can a while loop be implemented in a quantum computer?</p>
<p>If quantum computing consists of :</p>
<ol>
<li>preparing a state</li>
<li>applying a unitary operator</li>
<li>measuring,</li>
</ol>
<p>then it seems like it's not possible to wait for an indefinite amount of time before measuring.
How can one know that the while loop ended and that it's time to mesure ?</p>
",<algorithm><programming><physical-realization>,07/01/2020 17:06,12747.0,12747.0,"<p>The way that many algorithms would deal with such a desire is to incorporate the measurement at a more fundamental level, essentially making it part of the 'while' condition. i.e. you have an output qubit that is 0/1 for computation complete or not, you measure it, and decide whether to continue or not. Because that's a bit of classical processing, it doesn't have to be reversible, and you avoid the need for infinite space.</p>
<p>For example, many quantum algorithms only have a finite probability of success. For example, search or Factoring. In both of these cases, you know if you succeeded, and so there's an additional bit of classical logical that says &quot;repeat until successful&quot; i.e. a while loop.</p>
",07/02/2020 07:22, Conceptual,"The question is asking about how to implement a while loop in a quantum computer, which is a conceptual question about the limitations of quantum computing. The question is not about a specific tool or technique, and it is not about a specific problem that the user is trying to solve. Instead, the question is about the underlying principles of quantum computing and how they relate to the implementation of while loops.",Conceptual,,,, Conceptual,
12757.0,What is the difference between Qiskit execute and the IBMQJobManager?,"<p>I was researching how to submit multiple pulse schedules/circuits in the same job and came across 2 methods:</p>
<ol>
<li>Executing Experiments with <a href=""https://qiskit.org/documentation/apidoc/execute.html"" rel=""nofollow noreferrer""><code>qiskit.execute</code></a></li>
<li>and <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.run.html"" rel=""nofollow noreferrer""><code>IBMQJobManager.run</code></a></li>
</ol>
<p>What are the advantages and disadvantages of using either over the other?</p>
",<qiskit><programming><ibm-q-experience>,07/02/2020 15:27,12758.0,12758.0,"<p><code>qiskit.execute</code> is a convenience function that does both <code>transpile</code> and <code>assemble</code> under the cover.</p>
<p><code>IBMQJobManager.run</code> does <em>not</em> do <code>transpile</code>, but it does <code>assemble</code>. <code>IBMQJobManager</code> will, however, split your schedules/circuits into multiple jobs, submit them, and consolidate the results if the number of schedules/circuits exceed the maximum allowed for a backend per job. <code>qiskit.execute</code> doesn't do this and the job will just fail the limit is reached.</p>
",07/02/2020 15:56,Tooling,"The user is asking about the usage of specific functions in quantum programming, specifically the differences between qiskit.execute and IBMQJobManager.run in Qiskit.",Tooling,,,,Tooling,
12760.0,What are some general concepts of how a classical computer would interface with a quantum computer?,"<p>Very general question so I'm not looking for an exact answer.</p>
<p>I just want a basic description of certain ways it can be done and then if possible the names of those ways, so that I can look them up further.</p>
<p>But I want to know, if I was to run some code in a quantum computing language, how would a classical computer interface with the quantum one to instruct it?</p>
<p>Contact the machinery that directly builds a full circuit and then run it?
Does it go line by line and apply the gate at each stage?
Can it just directly communicate with the qubits?</p>
<p>Note: I am looking for answers for both gate based and continous computing</p>
",<quantum-gate><physical-realization><physical-qubit><classical-computing>,07/02/2020 19:37,12761.0,12761.0,"<p>It would be really platform specific - for example, suppose you have a quantum program ready using some gate set. But, the quantum hardware you have implements a different set. Well, you'd need to convert from your original gates into a new set of gates (and potentially perform some optimizations). Overall, this can probably be broken into a few steps:</p>
<ol>
<li><strong>Prepare</strong> a quantum program (Q#, Qiskit, etc.)</li>
<li><strong>Compile</strong> into the device's gate set (RZ, X, etc.)</li>
<li><strong>Convert gates</strong> into hardware instruction (Laser pulse of XYZ with frequency ABC, for example)</li>
<li><strong>Report results</strong> mechanically (e.g. measure qubit) and return to operating machine</li>
</ol>
<p>Here's an <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/host-programs?tabs=tabid-python"" rel=""nofollow noreferrer"">example</a> of how Q# thinks of the classical/quantum interaction. What we discussed occurs between &quot;Q# operation&quot; and &quot;Target machine.&quot;
<a href=""https://i.stack.imgur.com/agiVe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/agiVe.png"" alt=""Q# architecture"" /></a></p>
",07/03/2020 01:49,Conceptual,"This question falls under the ""Conceptual"" category as it seeks a conceptual understanding of how a classical computer interfaces with a quantum computer to instruct it. The user is looking for a basic description of the methods or approaches used for this interaction, both in gate-based and continuous-variable quantum computing.",Conceptual,,,,Conceptual,
12785.0,Can you transform a quantum program into an arrangement of slits?,"<p>Is it possible (in theory) to convert any problem that can be solved on a quantum computer into an arrangement of slits carved into a piece of metal foil, and then to run the program by shining light on the foil and observing the pattern of light that it produces?</p>
<p>It seems to me that this <em>should</em> be possible, just as any program on a conventional computer can be transformed into a boolean circuit (in theory).</p>
",<programming>,07/04/2020 22:21,12817.0,12817.0,"<p>If it were as easy as cutting slits into metal foil, or even doing photolithography at the sub-10nm regime, then it would have been done by now, but that might not be a satisfactory answer.  It's a good question and should not be dismissed.</p>
<p>The question is similar to &quot;what is stopping us from achieving a computational speedup by running Shor's algorithm by merely cutting a bunch of slits into a metal foil, and looking at the interference patterns when light is shown through?&quot;  .</p>
<p>Indeed, Shor has <a href=""https://www.youtube.com/watch?v=hOlOY7NyMfs"" rel=""noreferrer"">referred to</a> Shor's algorithm as a &quot;computational interferometer.&quot;  For example, one thing that quantum computers can do, and that diffraction gratings can do, is perform Fourier transforms on large data sets.</p>
<p>But diffraction gratings don't have much in the way of adaptive control, and you have to spend exponential resources before-hand in order to leverage the constructive and destructive interference of the photons.</p>
<p>For example, you could cut slits in your foil in a manner where the spacing is <span class=""math-container"">$a^x\bmod N$</span>.  Shining light through such a diffraction grating, even a single photon of light, will perform the quantum Fourier transform.</p>
<p>However, in this case you had to cut your diffraction grating <em>a-priori</em> into <span class=""math-container"">$a^x\bmod N$</span>; that is, you had to perform an exponential number of cuts in the first place.</p>
<p>It's not clear how such non-adaptivity is still powerful enough to solve Shor's algorithm, or whether you would always need to pre-cut your grating with an exponential number of cuts in the first place.</p>
",07/07/2020 21:20,Theoretical,"This question belongs to the ""Theoretical"" category as it involves a theoretical discussion about the possibility of converting any problem solvable on a quantum computer into an arrangement of slits on a piece of metal foil and using light to execute the program. The user is exploring a theoretical concept related to quantum computing and its potential physical implementations.",Theoretical,,,,Theoretical,
12822.0,Question About How Qiskit Reset Gate Affects Other Entangled Qubits,"<p>I am trying to understand how the reset gate in Qiskit affects qubits its entangled with. Consider the following circuit with qubits <span class=""math-container"">$q_0$</span> and <span class=""math-container"">$q_1$</span>:</p>
<p><a href=""https://i.stack.imgur.com/SYIGs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SYIGs.png"" alt=""enter image description here"" /></a></p>
<p>Where circuit240 takes <span class=""math-container"">$|0\rangle$</span> to <span class=""math-container"">$a|0\rangle + b|1\rangle$</span> and circuit 244 takes <span class=""math-container"">$|0\rangle$</span> to <span class=""math-container"">$c|0\rangle + d|1\rangle$</span>. Right before the reset gate on qubit <span class=""math-container"">$q_1$</span> the state of this circuit is <span class=""math-container"">$$\frac{1}{\sqrt{2}}(c|1\rangle + d|0\rangle)|0\rangle + \frac{1}{\sqrt{2}}(a|1\rangle + b|0\rangle)|1\rangle \tag{1}$$</span></p>
<p>I'm not quite sure how to mathematically represent what this quantum reset gate does to the quantum entangled state. For example, I tried a few tests with this circuit where I played with the values <span class=""math-container"">$a$</span> and <span class=""math-container"">$c$</span> and tested how the quantum reset gate affects the measurement of the qubit <span class=""math-container"">$q_0$</span>. It seems that whether or not the quantum reset gate is added, it doesn't affect the measurements of the other entangled qubit. Does this generally hold?</p>
<p>Furthermore, when I take the qubit expression above and just reset qubit <span class=""math-container"">$q_1$</span>to <span class=""math-container"">$|0\rangle$</span> I get the following:</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{2}}(c|1\rangle + d|0\rangle)|0\rangle + \frac{1}{\sqrt{2}}(a|1\rangle + b|0\rangle)|0\rangle \tag{2}$$</span></p>
<p><span class=""math-container"">$$= \frac{1}{\sqrt{2}}((a + c)|1\rangle + (b + d)|0\rangle)|0\rangle \tag{3}$$</span></p>
<p>But, mathematically, the probability of measuring <span class=""math-container"">$q_0$</span> as <span class=""math-container"">$|0\rangle$</span> in <span class=""math-container"">$(3)$</span> is not the same as the probability in  qubit expression <span class=""math-container"">$(1)$</span>(even though the tests show that removing the reset gate did not change the probability of measuring a <span class=""math-container"">$|0\rangle$</span> in the qubit <span class=""math-container"">$q_0$</span>. What is the correct way to represent what the qubit reset gate does to an entangled qubit?</p>
",<quantum-gate><qiskit><programming><ibm-q-experience><measurement>,07/08/2020 04:04,12823.0,12823.0,"<p>A reset gate is equivalent to a swap gate between the target qubit and a new ancilla qubit in the <span class=""math-container"">$|0\rangle$</span> state. So you can replace your question with &quot;how does swapping a qubit Q with an fresh ancilla qubit affect the qubits Q is entangled with?&quot; or &quot;how does discarding Q affect the qubits Q is entangled with&quot;. And the answer is that, for all intents and purposes, it doesn't affect them at all.</p>
<p>There is no test you can do on the qubits entangled with Q that can determined whether or not Q was discarded, or whether or not Q was swapped for a fresh ancilla qubit. Therefore there is no test you can do on the qubits entangled with Q (that don't involve measuring Q's value) whose outcome depends on whether or not Q was reset.</p>
",07/08/2020 04:24,Conceptual," This question belongs to the ""Conceptual"" category as it seeks an understanding of the mathematical representation and the effects of the quantum reset gate on entangled qubits in a quantum circuit. The user is looking for a conceptual explanation of how the reset gate influences the quantum state and measurements of entangled qubits.",Conceptual,,,,Conceptual,
12825.0,How can I represent mixed states in Q#?,"<p>I have a mixed state with a density matrices corresponding to <span class=""math-container"">$\rho=\sum_0^{2^n-1}p_i|i\rangle\langle i|$</span>. How would i represent this in Q#? How would I go about applying Unitary Operations <span class=""math-container"">$U$</span> on this mixed state in Q#?</p>
",<quantum-state><programming><q#>,07/08/2020 06:50,12830.0,12830.0,"<p>It can be helpful to step back and look at what a density matrix describes: a probability distribution over projectors onto pure states. In your example, for instance, <span class=""math-container"">$\rho$</span> represents a distribution in which <span class=""math-container"">$|\psi\rangle = |i\rangle$</span> with probability <span class=""math-container"">$p_i$</span>. That is, a density operator describes a probability over an <em>ensemble</em> of state vectors.</p>
<p>From that perspective, we easily write pseudocode for a quantum program that prepares <span class=""math-container"">$\rho = \sum_i p_i |\psi_i\rangle\langle\psi_i|$</span>:</p>
<ul>
<li>Draw a random <span class=""math-container"">$i$</span> with probability <span class=""math-container"">$p_i$</span>.</li>
<li>Prepare the pure state <span class=""math-container"">$|\psi_i\rangle$</span>.</li>
</ul>
<p>Thinking of state vectors like <span class=""math-container"">$|\psi_i\rangle$</span> as <a href=""https://www.cgranade.com/blog/2019/09/08/this-is-not-a-qubit.html"" rel=""nofollow noreferrer"">quantum programs that prepare those states</a>, this is already a complete description of how to prepare <span class=""math-container"">$\rho$</span>. You can, for instance, use the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.preparation.preparearbitrarystate"" rel=""nofollow noreferrer""><code>PrepareArbitraryState</code> operation</a> to prepare each <span class=""math-container"">$|\psi_i\rangle$</span> on a freshly allocated register of qubits.</p>
<p>In practice, however, you'll often have a much more efficient implementation of the state preparation programs for each <span class=""math-container"">$|\psi_i\rangle$</span>. For example, there's no need to use <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.preparation.preparearbitrarystate"" rel=""nofollow noreferrer""><code>PrepareArbitraryState</code> operation</a> to prepare <span class=""math-container"">$|+\rangle$</span>, as the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.h"" rel=""nofollow noreferrer""><code>H</code> operation</a> does just fine.</p>
<p>This is, for instance, how the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.preparation.preparesinglequbitidentity"" rel=""nofollow noreferrer""><code>PrepareSingleQubitIdentity</code> operation</a> prepares the particular mixed state <span class=""math-container"">$\rho = ð / 2$</span> on a single qubit.</p>
",07/08/2020 15:05,Tooling,"The user is asking about how to represent a mixed state and apply unitary operations on it in Q#, which involves understanding and using the Q# programming language correctly.",Tooling,,,,Tooling,
12828.0,What extra functionality is available to an IBM Q Network member over a regular IBM Q Experience user,"<p>I've been trying to figure out the extra functionality available to <code>IBM Q Network</code> members that are not available to normal <code>IBM Q Experience</code> users.</p>
<p>I couldn't find anything that says that Network members have access to better quantum processors or perhaps access to functionality within the Qiskit library that isn't available to Experience users.</p>
<p>Could someone please list all the benefits of having Network membership?</p>
",<qiskit><programming><ibm-q-experience><ibm>,07/08/2020 11:44,12829.0,12829.0,"<p>Basically being IBM Q Network member give you the possibility to access IBMâs most-powerful quantum computing systems through the cloud (currently 20Q, 27Q, 28Q, 53Q devices with Quantum Volume between 8 and 32 depending the device). Some of the premium devices are visible in this post: <a href=""https://www.ibm.com/blogs/research/2020/07/qv32-performance/"" rel=""nofollow noreferrer"">https://www.ibm.com/blogs/research/2020/07/qv32-performance/</a>
Depending on your engagement you also have access to different levels of collaboration from simple support to joint development.
No special qiskit library for IBM Q Network but special content/documentation and education materials.
Note that between the common user and the IBM Q Network member there is also a new way to engage for academic researchers: <a href=""https://www.ibm.com/blogs/research/2020/07/quantum-researcher-program/"" rel=""nofollow noreferrer"">https://www.ibm.com/blogs/research/2020/07/quantum-researcher-program/</a></p>
",07/08/2020 12:58,Tooling," The user is asking about the specific benefits and functionalities provided by the IBM Q Network membership, which involves understanding and using this quantum computing tool",Tooling,,,,Tooling,
12838.0,Visualizing custom gates in Cirq,"<p>I'm trying to visualize a custom gate in Cirq. I have through <a href=""https://cirq.readthedocs.io/en/stable/gates.html"" rel=""nofollow noreferrer"">this</a> page, which briefly mentions how to create custom gates in Cirq. However, I'm getting errors when trying to visualize it.</p>
<p>My current code defines a class <code>CustomGate</code>, which inherits from <code>cirq.Gate</code> class.</p>
<pre><code>import numpy as np
import cirq 
class CustomGate(cirq.Gate):
    def __init__(self, unitary):
        self.unitary = unitary
        self.numQubits = int(np.log2(unitary.shape[0]))

    def _num_qubits_(self):
        return self.numQubits

    def _unitary_(self):
        return self.unitary

    def _circuit_diagram_info_(self, args='cirq.CircuitDiagramInfoArgs') -&gt; 'cirq.CircuitDiagramInfo':
        return cirq.CircuitDiagramInfo(wire_symbols=(&quot;CG&quot;,), exponent=1.0, connected=True)
</code></pre>
<p>The usage is as follows:</p>
<pre><code># Define custom gate
customUnitary = np.eye(4)    # The custom unitary matrix would go here
CG = CustomGate(customUnitary)

# Setup circuit
q = cirq.LineQubit.range(2)
circuit=cirq.Circuit()
circuit.append(CG(q[0], q[1]))

# Visualize circuit
print(circuit)
</code></pre>
<p>I'm getting the following error:</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 42, in &lt;module&gt;
    print(circuit)
  File &quot;/Users/pgu/opt/anaconda3/lib/python3.7/site-packages/cirq/circuits/circuit.py&quot;, line 338, in __str__
    return self.to_text_diagram()
  File &quot;/Users/pgu/opt/anaconda3/lib/python3.7/site-packages/cirq/circuits/circuit.py&quot;, line 1609, in to_text_diagram
    transpose=transpose)
  File &quot;/Users/pgu/opt/anaconda3/lib/python3.7/site-packages/cirq/circuits/circuit.py&quot;, line 1668, in to_text_diagram_drawer
    get_circuit_diagram_info, include_tags)
  File &quot;/Users/pgu/opt/anaconda3/lib/python3.7/site-packages/cirq/circuits/circuit.py&quot;, line 1924, in _draw_moment_in_diagram
    info = get_circuit_diagram_info(op, args)
  File &quot;/Users/pgu/opt/anaconda3/lib/python3.7/site-packages/cirq/circuits/circuit.py&quot;, line 1818, in _get_operation_circuit_diagram_info_with_fallback
    info))
ValueError: Wanted diagram info from &lt;__main__.CustomGate object at 0x10379bb90&gt;.on(cirq.LineQubit(0), cirq.LineQubit(1)) for 2 qubits but got cirq.CircuitDiagramInfo(wire_symbols=('CG',), exponent=1.0, connected=True, exponent_qubit_index=None, auto_exponent_parens=True)

</code></pre>
",<quantum-gate><programming><cirq>,07/08/2020 19:26,12839.0,12839.0,"<p>You're making a two qubit gate but the circuit diagram info only has one wire label. Change <code>wire_symbols=(&quot;CG&quot;,)</code> to <code>wire_symbols=(&quot;CG&quot;, &quot;#2&quot;)</code>.</p>
<p>Note that, since you're using default values for the diagram info you can just return the tuple <code>return &quot;CG&quot;, &quot;#2&quot;</code> instead of bothering to wrap it in the more complicated data type.</p>
<p>Note that cirq does include <code>cirq.MatrixGate</code>, which takes an arbitrary unitary similar to what your custom gate is doing.</p>
",07/08/2020 20:00,Errors,"The user is encountering an error while trying to visualize a custom gate in Cirq, a quantum computing framework. This falls under the Errors category as they are seeking solutions and explanations for errors and exceptions in quantum program development. ",Errors,,,,Errors,
12841.0,Applying a gate to all line qubits without explicitly listing them in Cirq,"<p>Say we have a custom gate <code>CG</code>, defined by a unitary matrix <code>U</code>, and line qubits <code>qubits</code> in Cirq. Something like this:</p>
<pre><code>import numpy
import cirq

U = np.eye(8)    # The custom unitary matrix goes here
CG = cirq.MatrixGate(U)
qubits = cirq.LineQubit.range(3)
</code></pre>
<p>We build the circuit as follows:</p>
<pre><code>circuit = cirq.Circuit()
circuit.append(CG(qubits[0], qubits[1], qubits[2]))
</code></pre>
<p>Is it possible to build the circuit without explicitly specifying all the qubits? Something like <code>circuit.append(CG(qubits))</code>, which would apply the <code>CG</code> gate to all the qubits?</p>
",<quantum-gate><programming><circuit-construction><cirq>,07/08/2020 22:18,12842.0,12842.0,"<p>In Python you can say <code>callable(*args)</code> instead of <code>callable(args[0], args[1], args[2])</code>.</p>
",07/08/2020 23:34,Tooling,"The user is asking about how to apply a custom gate to all qubits in Cirq without explicitly specifying each qubit, which involves understanding and using the Cirq programming tool correctly.",Tooling,,,,Tooling,
12844.0,How the simulator work?,"<p>Recently I focused on how to simulate in classical computer, and I found Qiskit offers <code>qasmsimulator</code> and <code>statevector simulator</code>. And others such as project Q also can simulate on classical computer. So is there a general way to simulate on classical computer? And what are differences among simulators? I mean actually it seems like we just need to multiply gate operation as matrixes.</p>
",<quantum-gate><quantum-state><qiskit><programming><simulation>,07/09/2020 06:21,12852.0,12852.0,"<p>There are three major levels of simulation difficulty (broadly, there are a bunch of others, but these are the main levels.)</p>
<p>Clifford simulators can simulate circuits composed of only Clifford elements on stabilizer states. This is classically efficient, since it is classically efficient to calculate the propagation of a Pauli operator through a Clifford gate. As a result, the simulator takes the stabilizers of the input state, propagates them through the circuit, and the resulting stabilizer group represents the final state. The idea that a quantum algorithm needs non-Clifford gates to be better than a classical one comes from the fact that a fully Clifford quantum algorithm could be simulated classically in polynomial time.</p>
<p>The second level of simulation is State Vector simulation. In this case, we are basically doing what you mentioned in your question. We take an input state (of size <span class=""math-container"">$2^n$</span>, where n is the number of qubits) and then apply gates to it through matrix multiplication. Due to the exponential size of the state, this requires resources exponential in the system size to be simulated, and as a result is not considered classically efficient. The only restriction on these simulations is that the gates must all be unitary and all states must be pure.</p>
<p>The last level is Density Matrix simulation. Here, we store the full <span class=""math-container"">$2^n \times 2^n$</span> density matrix of the state. As a result we can simulate any quantum channel, and mixed states are permissible. However we now have an even bigger object to work with. These simulations are often necessary for doing work on simulating physical noise or other non-unitary processes, but are extremely limited in size due to their exponential resource requirements.</p>
",07/09/2020 19:03,Conceptual,"This question falls under the ""Conceptual"" category as it seeks an understanding of the general principles behind simulating quantum circuits on classical computers and the differences among various simulators. The user is looking for a conceptual explanation of the simulation process and the distinctions between simulators, rather than specific technical implementation details.",Tooling,"This question is about different tools and simulators available for simulating quantum computations on classical computers, including Qiskit's qasm simulator and statevector simulator, and ProjectQ. It's seeking information on these tools and the differences between them, making it a tooling-related question.",No,92.0,Conceptual,"The user seeks a conceptual understanding of simulating quantum circuits on classical computers and the differences among simulators, indicating a need for a high-level explanation of the simulation process and distinctions between various approaches."
12849.0,How to implement Cx mod N unitary,"<p>The following links provides circuts for <span class=""math-container"">$a\in\{2,7,8,11,13\}$</span> and <span class=""math-container"">$N=15$</span>: <a href=""https://qiskit.org/textbook/ch-algorithms/shor.html#3.-Qiskit-Implementation"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/shor.html#3.-Qiskit-Implementation</a>
<a href=""https://arxiv.org/abs/1202.6614v3"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1202.6614v3</a>.</p>
<p>I am interested in implementing circuts for the case when <span class=""math-container"">$a=2$</span>, <span class=""math-container"">$N=21$</span> and <span class=""math-container"">$a=3$</span>, <span class=""math-container"">$N=14$</span> or a generic way to generate them.</p>
<p>I've tried to generate the unitary matrix by classical computation classically, but I don't know how to fill remaining space and when input state 0 is treat it as state 15 output.</p>
",<algorithm><qiskit><programming><circuit-construction><shors-algorithm>,07/09/2020 16:02,12861.0,12861.0,"<p>Firstly, these circuits only need to work for states <span class=""math-container"">$C^k \pmod{N}$</span> since these are the only states used in Shor's algorithm. I do not think you could have a circuit that works for the states 0 and <span class=""math-container"">$N \bmod N$</span> without outputting to a different register since this would not be reversible.</p>
<h2>Below is how I came to an answer for your specific question (not a general method):</h2>
<p>For the specific cases you stated, you can find a circuit analytically. I'll create <span class=""math-container"">$2x \bmod 21$</span>.</p>
<p>Start with a working circuit, for example the <span class=""math-container"">$2x \bmod 15$</span> circuit from the paper you linked. I have added one qubit since we'll need it later to create <span class=""math-container"">$2x \bmod 21$</span>. I have also included a function that cycles through the states and checks everything works correctly.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

def test_cycles(circuit, cycles):
    i = 1
    for application in range(cycles):
        print(&quot;Apply %s, %i times: %i&quot; % (circuit.name, application, i))
        sv = Statevector.from_int(i, 32)  # 32 is no. of elements in vector (dimension)
        sv = sv.evolve(circuit)
        output = sv.sample_memory(1)[0]  # simulate one shot (circuit is deterministic)
        i = int(output, 2)  # convert binary output to int

tm15 = QuantumCircuit(5)  # 2x mod 15
tm15.name = &quot;2x (mod 15)&quot;
tm15.swap(0,3)
tm15.swap(3,2)
tm15.swap(2,1)
        
test_cycles(tm15, 6)
tm15.draw()
</code></pre>
<p>Output:</p>
<pre><code>Apply 2x (mod 15), 0 times: 1
Apply 2x (mod 15), 1 times: 2
Apply 2x (mod 15), 2 times: 4
Apply 2x (mod 15), 3 times: 8
Apply 2x (mod 15), 4 times: 1
Apply 2x (mod 15), 5 times: 2
</code></pre>
<p><a href=""https://i.stack.imgur.com/jPy4r.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jPy4r.png"" alt=""2x mod 15 circuit"" /></a></p>
<p>We can see the state of the state of the register follows the sequence <code>1, 2, 4, 8, 1...</code> with successvie applications of the circuit. To make <span class=""math-container"">$2x \bmod 21$</span> we want the sequence to be:</p>
<pre><code>1, 2, 4, 8, 16, 11, 1... 
</code></pre>
<p>Next, we want the state 8 to be transformed to the state 16 upon running the circuit, we can accomplish this with a single swap gate to get <span class=""math-container"">$2x \bmod 31$</span>:</p>
<pre><code>tm31 = QuantumCircuit(5)
tm31.name = &quot;2x mod 31&quot;
tm31.swap(3,4)
tm31 += tm15
test_cycles(tm31, 6)
tm31.draw()
</code></pre>
<p>Output:</p>
<pre><code>Apply 2x mod 31, 0 times: 1
Apply 2x mod 31, 1 times: 2
Apply 2x mod 31, 2 times: 4
Apply 2x mod 31, 3 times: 8
Apply 2x mod 31, 4 times: 16
Apply 2x mod 31, 5 times: 1
</code></pre>
<p><a href=""https://i.stack.imgur.com/RYdLB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RYdLB.png"" alt=""2x mod 31 circuit"" /></a></p>
<p>We need to modify our circuit to do the transformation: 16 -&gt; 11. In binary, this is the transformation:</p>
<pre><code>10000 -&gt; 01011
</code></pre>
<p>and leave the states 1, 2, 4 and 8 unchanged. Since the most significant qubit will only be on when our register is in the state 16, we can use this to recognise the special case:</p>
<pre><code>tm21 = QuantumCircuit(5)
tm21.name = &quot;2x mod 21&quot;
tm21.cx(4, 2)
tm21.cx(4, 0)
tm21 += tm32
test_cycles(tm21, 16)
tm21.draw()
</code></pre>
<p>Output:</p>
<pre><code>Apply 2x mod 21, 0 times: 1
Apply 2x mod 21, 1 times: 2
Apply 2x mod 21, 2 times: 4
Apply 2x mod 21, 3 times: 8
Apply 2x mod 21, 4 times: 16
Apply 2x mod 21, 5 times: 11
Apply 2x mod 21, 6 times: 22
Apply 2x mod 21, 7 times: 7
Apply 2x mod 21, 8 times: 14
Apply 2x mod 21, 9 times: 28
Apply 2x mod 21, 10 times: 19
Apply 2x mod 21, 11 times: 13
Apply 2x mod 21, 12 times: 26
Apply 2x mod 21, 13 times: 31
Apply 2x mod 21, 14 times: 21
Apply 2x mod 21, 15 times: 1
</code></pre>
<p><a href=""https://i.stack.imgur.com/Dbo4U.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Dbo4U.png"" alt=""incomplete 2x mod 21 circuit"" /></a></p>
<p>Here I have used the fact that the <span class=""math-container"">$2x\bmod 31$</span> circuit is simply a bit-shift along the register to work out which qubits to conditionally flip. Notice though that this circuit is incomplete as it does not do the transformation: 11 -&gt; 1. It does however do: 21 -&gt; 1. To complete our circuit, we must prepend a circuit that does the transformation: 11 -&gt; 21, or in binary:</p>
<pre><code>01011 -&gt; 10101
</code></pre>
<p>and must leave the states 1, 2, 4, 8 and 16 unchanged. We can use controlled swap gates to do this. Since 11 is the only state in our cycle that has multiple qubits in the state <span class=""math-container"">$|1\rangle$</span>, we know this will not adversely affect any of the other states in the cycle:</p>
<pre><code>tm21 = QuantumCircuit(5)
tm21.name = &quot;2x mod 21&quot;
tm21.cswap(0,3,4)
tm21.cswap(0,1,2)
tm21.cx(4, 2)
tm21.cx(4, 0)
tm21 += tm31
test_cycles(tm21, 8)
tm21.draw()
</code></pre>
<p>Output:</p>
<pre><code>Apply 2x mod 21, 0 times: 1
Apply 2x mod 21, 1 times: 2
Apply 2x mod 21, 2 times: 4
Apply 2x mod 21, 3 times: 8
Apply 2x mod 21, 4 times: 16
Apply 2x mod 21, 5 times: 11
Apply 2x mod 21, 6 times: 1
Apply 2x mod 21, 7 times: 2
</code></pre>
<p><a href=""https://i.stack.imgur.com/6RNcv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6RNcv.png"" alt=""complete 2x mod 21 circuit"" /></a></p>
<p>Above is a complete circuit for <span class=""math-container"">$2x \bmod 21$</span> that uses no extra qubits. It is probably not the most efficient circuit that accomplishes this, but it does work. This method is not generalisable, and will become unmanageable for larger circuits. For general circuits I believe you must take the extra qubit 'hit' and turn to <a href=""https://arxiv.org/pdf/quant-ph/0205095.pdf"" rel=""nofollow noreferrer"">this paper</a>.</p>
",07/10/2020 16:08,Tooling ,"The user is asking about how to implement specific quantum circuits using Qiskit, a quantum computing framework. This falls under the Tooling category as it involves using a specific quantum computing tool to perform a specific task",Tooling,,,,Tooling ,
12888.0,Is running a for loop faster on a quantum computer than a classical computer?,"<p>Curious to understand if I run for loop within a quantum algorithm, and lets say I want the quantum algorithm to run in classical run time of O(1). Can this be done?</p>
",<algorithm><programming>,7/13/2020 19:51,12889.0,12889.0,"<p>No, quantum computers can't run for-loops faster in general.</p>
<p>There are certain specific tasks that can be done using a for-loop that can instead be done in a different way on a quantum computer, with fewer total operations. For example, Grover search can replace the loop <code>for x in range(N): if predicate(x): y = x</code> with something that uses <span class=""math-container"">$O(\sqrt{N})$</span> calls to <code>predicate</code> instead of the <span class=""math-container"">$N$</span> that the for loop is using.</p>
",7/13/2020 21:00, Theoretical, The user is asking about the theoretical possibility of running a for loop within a quantum algorithm in classical run time of O(1). This falls under the Theoretical category as it involves understanding the principles and concepts behind quantum computing and computational complexity. ,Theoretical,,,, Theoretical,
12898.0,How to construct quantum circuit to count number of 0-qubits and 1-qubits,"<p>Suppose we have a 3-qubit input; each bit is either 0 or 1. How to decide if there are more 1's than 0's? Only 1 extra qubit may be used for the output. (Yes I know this can be achieved using 3 Toffoli gates, but can it be done without Toffoli gates?)</p>
<p>Now suppose we have an answer to the above question, then, how to extend the above circuit to deal with a 5-qubit input?</p>
",<programming><circuit-construction>,7/14/2020 15:27,12907.0,12907.0,"<p>Here's a general strategy that doesn't quite fulfil the brief: for an <span class=""math-container"">$n$</span>-qubit input where <span class=""math-container"">$n+1=2^k$</span>, <span class=""math-container"">$k$</span> an integer (e.g. <span class=""math-container"">$n=3,k=2$</span>), it uses <span class=""math-container"">$k$</span> ancilla qubits but no Toffolis. (You can do something similar if <span class=""math-container"">$n+1$</span> is not a powe of 2, but you'd need some classical post-processing and I'd have thought you might as well just measure the input qubits!)</p>
<p>The idea is to define a Hamiltonian
<span class=""math-container"">$$
H=\left(\sum_{j=1}^nZ_j+nI\right)/2.
$$</span>
Note that this has eigenvalues <span class=""math-container"">$0,1,2,3,\ldots,n$</span> corresponding to the number of 1s in the string it's acting on. So, let <span class=""math-container"">$U=e^{2i\pi H/2^k}$</span>. This is a unitary with the eigenvectors that we need. If you run a phase estimation procedure using <span class=""math-container"">$k$</span> ancilla qubits, it will exactly read out the number of 1s for you. This requires controlled-<span class=""math-container"">$U$</span>, which is just a bunch of controlled-phase gates (i.e. all two-qubit gates) and the Fourier transform which, again, is two-qubit gates. Actually you only need the semi-classical Fourier transform, so it's just one-qubit gates with feed-forward of measurement results.</p>
<p>So, once you know who many 1s there are, you can classically process that to decide if it's greater than <span class=""math-container"">$n/2$</span>. In the case of <span class=""math-container"">$n+1$</span> being a power of 2, this is particularly simple. You just look at the bit representation of the output, and the most significant bit will give you the answer. So, this would be the only qubit you would need to measure. (Note that this is the <em>last</em> bit output by the Fourier transform, not the first).</p>
",7/15/2020 7:32,Theoretical ,"The user is asking about the theoretical concepts of quantum computing, specifically how to construct a quantum circuit to solve a specific problem. This falls under the Theoretical category as it involves understanding the principles and concepts behind quantum gate operations. ",Theoretical,,,,Theoretical ,
12906.0,Is there a tool to get the quantum circuit corresponding to a sparse matrix?,"<p>If I know a sparse matrix, is there any tool that allows me to get the corresponding quantum circuit directly?</p>
<p>If not what should I do?</p>
<p>For exampleï¼I want to try hamilton simulation and I have the sparse matrix. How can I get the corresponding quantum circuit? By code or by some software? Or get enough training?</p>
<p>I'm new in this field.</p>
<p>Need your help</p>
",<quantum-gate><programming><circuit-construction><hamiltonian-simulation>,7/15/2020 6:40,12908.0,12908.0,"<p>Concerning Hamiltonian simulation, you can find very useful guide in <a href=""https://quantumcomputing.stackexchange.com/questions/5567/circuit-construction-for-hamiltonian-simulation"">this question</a>.</p>
<p>General approach to quantum circuit construction is explained in paper <a href=""https://arxiv.org/abs/quant-ph/9503016"" rel=""nofollow noreferrer"">Elementary gates for quantum computation</a>.</p>
<p>Also paper <a href=""https://arxiv.org/abs/quant-ph/0308006"" rel=""nofollow noreferrer"">Optimal Quantum Circuits for General Two-Qubit Gates</a> can be helpful.</p>
",7/15/2020 8:22,Tooling,"The user is inquiring about tools or software that can facilitate the conversion of a sparse matrix into a corresponding quantum circuit, indicating a need for practical guidance on how to achieve this. ",Tooling,,,,Tooling,
12918.0,Is it possible to detect the phase $\pi$ or 0 for the single qubit circuit X H P?,"<p>I found an <a href=""https://quantumcomputing.stackexchange.com/a/11356/12416"">answer</a> that shows how to detect the phase in cases like <span class=""math-container"">$0$</span>, <span class=""math-container"">$\pi/8$</span>, <span class=""math-container"">$\pi/2$</span>, <span class=""math-container"">$\pi/4$</span> or <span class=""math-container"">$\pi$</span> for circuit to prepare state as H P, where P is a phase gate like <span class=""math-container"">$I$</span>,  <span class=""math-container"">$U1(\pi/8)$</span>, <span class=""math-container"">$S$</span>, <span class=""math-container"">$T$</span> or <span class=""math-container"">$Z$</span>.</p>
<p>But in my case the circuit to prepare state is <span class=""math-container"">$X H P$</span>, where <span class=""math-container"">$P$</span> is <span class=""math-container"">$X$</span> gate (conditionally phase <span class=""math-container"">$\pi$</span>) or <span class=""math-container"">$ID$</span> (conditionally phase 0).</p>
<p>This circuit in Qasm with conditionally phase equal to <span class=""math-container"">$\pi$</span>:</p>
<pre><code>x q[0];
h q[0];
x q[0];
</code></pre>
<p>with conditionally phase equal to <span class=""math-container"">$0$</span>:</p>
<pre><code>x q[0];
h q[0];
id q[0];
</code></pre>
<p>Appending <span class=""math-container"">$H$</span> gate (as in the above answer) don't detect a difference for conditionally phase <span class=""math-container"">$\pi$</span> and phase <span class=""math-container"">$0$</span> (but does detect for phases <span class=""math-container"">$\pi/2$</span>, <span class=""math-container"">$\pi/4$</span>, <span class=""math-container"">$\pi/8$</span> if <span class=""math-container"">$P$</span> is <span class=""math-container"">$S$</span>, <span class=""math-container"">$T$</span>, <span class=""math-container"">$U1(\pi/8)$</span>, respectively).</p>
<p>Is it possible to detect the conditionally phase <span class=""math-container"">$P$</span> <span class=""math-container"">$\pi$</span> or 0 for this circuit to prepare state?</p>
",<quantum-state><programming><measurement><phase-estimation>,7/16/2020 5:57,12920.0,12920.0,"<p>I think unlike the relative phase in the answer you reference, it is a global phase in your case:</p>
<p>Your XHP-circuit where P=ID, prepares the state: [0.707+0j,-0.707+0j], where P=X, prepares the state: [-0.707+0j, 0.707+0j].
These states are differ by a global phase <span class=""math-container"">${e}^{i\pi}=-1$</span>.</p>
<p>But the global phase is undetectable <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Single-Qubit-Quantum-states"" rel=""nofollow noreferrer""><span class=""math-container"">$|Ïâ©:={e}^{iÎ´}|Ïâ©$</span></a>, also see the <a href=""https://quantumcomputing.stackexchange.com/a/9630/12416"">answer</a>.</p>
",7/16/2020 6:58,Theoretical,"The user is asking about the theoretical concepts of quantum computing, specifically how to detect the conditional phase for a specific quantum circuit. This falls under the Theoretical category as it involves understanding the principles and concepts behind quantum gate operations.",Theoretical,,,,Theoretical,
12985.0,Is there a standard way to save pulse schedules akin to a qasm for a circuit?,"<p>If I create a QuantumCircuit, I can save all the information necessary to reconstruct the circuit using the qasm method. In addition, these qasm strings can be sent directly to the IBM quantum computers (and some others). This makes it convenient for storing these circuits locally and passing them around to collaborators when I want them to test the same circuit unambiguously. In addition, it's faster to load in and send qasms than it is to create circuits every time I want to create the same (large) circuit to run over different calibration cycles.</p>
<p>Is there an analogous method for OpenPulse Schedules?</p>
<p>The closest I could find was the .instructions method, but this creates an unwieldy tuple which cannot be sent directly to the QCs. This means I cannot just call the instructions method, save the string to a text file, and pass this to a collaborator. While I could write a file parser which reads these strings, this would take a long time and would break if the API is changed. Furthermore, even if I did do this, these tuples saved as a string to a .txt file take up an enormous amount of disk space, so it's actually not faster to manipulate the instructions, and I'm better of re-creating the pulses from scratch every time (which is also slow).</p>
<p>If not, has anyone come up with a &quot;schedule qasm&quot; workaround/hack for the time being?</p>
",<qiskit><programming><qasm><openpulse>,7/21/2020 5:18,12993.0,12993.0,"<p>I believe there are several developments about this on Qiskit to make the use of Pulse easier. Try to check the <a href=""https://github.com/Qiskit/qiskit-terra/pulls"" rel=""nofollow noreferrer"">PR</a> or the <a href=""https://github.com/Qiskit/qiskit-terra/issues?q=is%3Aissue+is%3Aopen+pulse"" rel=""nofollow noreferrer"">issues</a> regarding Pulse, maybe you'll find what you are looking for.<br />
I also found an <a href=""https://github.com/qiskit-community/qiskit-camp-asia-19/issues/28"" rel=""nofollow noreferrer"">issue</a> about a QASM 3.0, I think this will interest you! :)</p>
",7/21/2020 14:18,Tooling,"The user is asking about a specific feature in the OpenPulse tool, specifically a method analogous to the qasm method for QuantumCircuit but for Schedules. This falls under the Tooling category as it involves using a specific quantum computing tool to perform a specific task.",Tooling,,,,Tooling,
13058.0,Queue disabled and HTTP 403 error,"<p>I have already visited this <a href=""https://quantumcomputing.stackexchange.com/questions/6571/what-does-it-mean-to-get-403-error-when-running-a-code-on-qiskit"">What does it mean to get 403 error when running a code on Qiskit?</a> which did not help me fix my problem.
I want to test the quantum circuit that I have designed using the following code, (the histogram of the circuit is being plotted perfectly so I don't believe that there is any problem with it)</p>
<pre><code>IBMQ.load_account()
provider = IBMQ.get_provider('ibm-q')
qcomp = provider.get_backend('ibmq_16_melbourne')
job = execute(circuit, backend=qcomp)
</code></pre>
<p>I do not understand the problem with the above code. The last line is not executing in the Jupiter notebook cell. Is it a location problem of Melbourne, because me residence is India? What would I do?</p>
",<qiskit><programming><ibm-q-experience>,7/27/2020 19:16,13059.0,13059.0,"<p>You're getting the 403 because <code>ibmq_16_melbourne</code> is currently offline for maintenance. You can checkout the status of each backend on the IBM Quantum Experience website, or do <code>backend.status().operational</code>. Furthermore, you can get the least busy operational backend with something like</p>
<pre><code>from qiskit.providers.ibmq import least_busy
backend = least_busy(provider.backends(simulator=False, filters=lambda b: 
    b.configuration().n_qubits &gt;= 5))
</code></pre>
",7/27/2020 19:43,Tooling,"This question falls under the ""Tooling"" category as the user is encountering an issue related to running a quantum circuit on a specific backend (IBM Q Melbourne) using Qiskit, a quantum computing tool. They are seeking assistance in resolving this technical problem.",Tooling,,,,Tooling,
13063.0,Is it possible to convert classical algorithms to quantum ones?,"<p>I am new in this field and I am considering to do research for my engineering degree.</p>
<p>First, I would like to have an opinion from more experienced people. <strong>Do you think it is possible to convert classic algorithms to quantum algorithms? Having in mind that the conversion will take in consideration the particularities of quantum algorithms</strong>.</p>
<p>If so, can you explain your point of view and if it is possible, an example?</p>
",<algorithm><classical-computing>,7/28/2020 5:47,13065.0,13065.0,"<p>It depends on what you mean by converting classical algorithm to quantum one.</p>
<p>One angle of view can be: <em>Is it possible to run any classical algorithm on quantum computer?</em> If this is a case then answer is yes. Since so-called Toffoli gate is effectivelly NAND gate (in case the controlled qubit is set to state <span class=""math-container"">$|1\rangle$</span> before) and such gate enables to implement any logical function. Hence, you can use universal gate-based quantum computer for implementation of any classical algorithm.</p>
<p>Seconde angle of view could be: <em>Is there a qunatum counterpart to any classical algorithm?</em> In this case the answer is difficult and I am not sure whether it has been resolved already. However, there are some examples of quantum algorithms solving problems we have classical ones for. For instance: Shor's algorithm is used for integers factoring, Grover's algorithm for searching in unordered databases, HHL algorithm for solving systems of linear equations, there are Monte Carlo algorithms useful in finance, Hamiltonian simulations algorithms useful in simulation of quantum systems (the original purpose the quantum computers have been developed for) etc. Moreover, there is a family of so-called quantum annealers. These are single purpose quantum computers implementing quantum annealing algorithm on hardware level.</p>
",7/28/2020 7:34,Theoretical,"The user is asking about the theoretical possibility of converting classical algorithms into quantum algorithms, which involves understanding the principles and concepts behind quantum computing and algorithm design.",Theoretical,,,,Theoretical,
13080.0,How to undo an operation in qiskit on jupyter notebook?,"<p>I am not able to undo an operation. For example, I want a single Hadamard gate on a single qubit but by mistake two Hadamard gate added. Now I want to remove one of them without interrupting kernel. Is there any easy way. Please help me. Thank you.</p>
",<qiskit><programming><hadamard>,7/29/2020 7:43,13087.0,13087.0,"<p>To remove the last gate you can do <code>qc.data.pop()</code>.</p>
<p>Example:</p>
<pre><code>qc = QuantumCircuit(1)
qc.h(0)
qc.draw('text')
</code></pre>
<p>output:</p>
<pre><code>     âââââ
q_0: â¤ H â
     âââââ
</code></pre>
<p>Then:</p>
<pre><code>qc.data.pop()
qc.draw('text')
</code></pre>
<p>output:</p>
<pre><code>q_0: 
</code></pre>
",7/29/2020 13:41,Errors,"This question falls under the ""Errors"" category because the user is seeking help to resolve an issue related to undoing an operation (removing an unintended Hadamard gate) in quantum programming without interrupting the kernel, which is a common problem encountered during quantum program development.",Errors,,,,Errors,
13092.0,IBMQ_Melbourne Readout error,"<p>I am trying to simulate an experiment on IBM's melbourne quantum computer and here are the results</p>
<ol>
<li><p>Qasm simulator :<a href=""https://i.stack.imgur.com/yhLt9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yhLt9.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>ibmq_16_melbourne:
<a href=""https://i.stack.imgur.com/7SQ02.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7SQ02.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>error<a href=""https://i.stack.imgur.com/MJyJy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MJyJy.png"" alt=""enter image description here"" /></a></p>
</li>
</ol>
<p>why is there such high probability of unwanted states i.e <code>01</code> and <code>10</code>. Also when the circuit is transpiled on the melbourne computer the circuit operates between <span class=""math-container"">$q[4]$</span> and <span class=""math-container"">$q[10]$</span>, is these usual.</p>
",<programming><ibm-q-experience><simulation>,7/29/2020 17:36,13094.0,13094.0,"<p>Every rotation or controlled operation you perform on each individual qubit has an error associated to it, you can check it <a href=""https://quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">here</a> by selecting a computer and hovering over each Qubit, through the error range bar or through Python as you seem to have done.</p>
<p>What I've found in my experiments is that what usually ruins an experiment is the error associated with the CNOT operation, you can keep track of their count by using something along these lines <code>qc.count_ops().get('cx')</code>. Another thing that may help is setting the layout method to &quot;noise adaptive&quot;, by including <code>layout_method='noise_adaptive'</code> into the transpiler parameters. You should check the <a href=""https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html"" rel=""nofollow noreferrer"">transpiler documentation</a> and play around with the different parameters in order to best optimize your gate count. Ultimately the transpiler can only do so much and your circuit might just not be able to run on a real device.</p>
<p>I'm currently working on some circuits that require a decent amount of SWAP operations that are decomposed into 3 CNOTs each, at the very minimum. I was thinking that running them on Melbourne computer would yield better results, since it has the best suited connectivity for my specific needs. What i found was that the results were very, very bad when compared to a computer that has less connectivity but also less error associated with the CNOT operation.</p>
",7/29/2020 18:53,Errors ,"The user is encountering an unexpected result while simulating an experiment on IBMs Melbourne quantum computer, specifically a high probability of unwanted states. This falls under the Errors category as they are seeking solutions and explanations for this unexpected behavior in their quantum computing experiment.",Errors ,,,,Errors ,
13121.0,Does Qiskit offer a stack of functions to generate and manipulate graph states?,"<p>I'm looking for a way to test graph state verification protocols on the IBM Q. Has anyone yet written code to generate a graph state on IBM Q and also generate its stabilizer generators given the adjacency matrix of the graph as input?</p>
",<qiskit><programming><ibm-q-experience><graph-states>,7/31/2020 14:19,13125.0,13125.0,"<p>There is a Graph State circuit available on IBM Qiskit. Graph state preparation circuits are Clifford circuits, and thus easy to simulate classically. However, by adding a layer of measurements in a product basis at the end, there is evidence that the circuit becomes hard to simulate. The circuit prepares a graph state with the given adjacency matrix. Given a graph G = (V, E), with the set of vertices V and the set of edges E, the corresponding graph state is defined as the following</p>
<pre><code>|ðºâ© = â(ð,ð)âð¸ð¶ð(ð,ð)|+â©âð
</code></pre>
<p>Such a state can be prepared by first preparing all qubits in the + state, then applying a ð¶ð gate for each corresponding graph edge. The reference circuit is depicted in the IBM Qiskit library as below. Please find all the details of the Graph State circuit attributes and functions in the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.GraphState.html#graphstate"" rel=""nofollow noreferrer"">following link</a> in the IBM Qiskit library.</p>
<p><a href=""https://i.stack.imgur.com/2CQH1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2CQH1.png"" alt=""enter image description here"" /></a></p>
",7/31/2020 18:33, Tooling ,The user is looking for code or tools to generate graph states on IBM Q and obtain their stabilizer generators from an adjacency matrix. This falls under the Tooling category as it involves seeking tools or code to perform specific tasks related to quantum computing on a specific platform (IBM Q).,Tooling,,,, Tooling ,
13142.0,What is the certain error rate in a quantum channel?,"<p>Quantum error correction is a fundamental aspect of quantum computation. I have read some material about &quot;Quantum Channel&quot; and &quot;Quantum error correction&quot;.</p>
<p>I have known the formula of gate error which has close relationship with decoherence time. However, no one tell me what is the certain probability of each error is reliable or what is the exact possibility in real environment.</p>
<p>For example, in depolarizing channel, each error can be approximated into pauli error, which is X,Y,Z error with their own possibility <span class=""math-container"">$p_x$</span>,<span class=""math-container"">$p_y$</span> and <span class=""math-container"">$p_z$</span>. So is that a certain scale of possibility (just for example, <span class=""math-container"">$1\%&lt;p_x&lt;10\%$</span>) of each error is reliable or something close to that?</p>
",<quantum-gate><programming><error-correction><quantum-operation>,08/02/2020 06:08,13154.0,13154.0,"<p>As I explained in <a href=""https://quantumcomputing.stackexchange.com/a/13099/8141"">my answer</a> on <a href=""https://quantumcomputing.stackexchange.com/q/13096/8141"">a previous question</a> of yours, the depolarizing channel is not really 'physical' - actual quantum systems don't really behave that way.</p>
<p>So for simulations where you, for instance, investigate the performance of some code against the depolarizing channel, it doesn't <em>really</em> matter what the exact value of <span class=""math-container"">$p$</span> is in your simulations. Moreover, what is much more interesting is to perform the simulation for a <em>range of values</em> of <span class=""math-container"">$p$</span>, and see how the performance of the code depends on <span class=""math-container"">$p$</span>. As you may be aware, for higher <span class=""math-container"">$p$</span>, a code may do more bad than good (i.e. it creates more errors than it can correct); for a low <span class=""math-container"">$p$</span> the code will actually do some good, and thus an interesting value for <span class=""math-container"">$p$</span> might be the point where the code starts to add benefit - this value is often referred to as the <em>pseudo threshold</em>. <a href=""https://quantumcomputing.stackexchange.com/a/12963/8141"">This excellent answer</a> elaborates a bit on why we call it the <em>pseudo</em> threshold, and not just threshold.</p>
<p>Now, if you want to simulate actual systems more closely, as I explained in my answer linked above, it's 'better' to use the amplitude damping and dephasing channel. The error rates are mostly expressed in the damping time <span class=""math-container"">$T_{1}$</span> and dephasing time <span class=""math-container"">$T_{2}$</span>; what exactly these values are is <strong>highly</strong> dependent on what system you are simulating.</p>
<p>For instance, the <a href=""https://en.wikipedia.org/wiki/Transmon"" rel=""nofollow noreferrer"">transmon qubits</a> from <a href=""https://quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">IBM</a> have a typical <span class=""math-container"">$T_{1}$</span> of <span class=""math-container"">$~50 \mu s$</span> and a <span class=""math-container"">$T_{2}$</span> of <span class=""math-container"">$~60 \mu s$</span>. As another example, the quantum dot based <a href=""https://en.wikipedia.org/wiki/Loss%E2%80%93DiVincenzo_quantum_computer"" rel=""nofollow noreferrer"">semiconductor qubits</a> of QuTech's <a href=""https://www.quantum-inspire.com/backends/spin-2/"" rel=""nofollow noreferrer"">Quantum Inspire</a> have a typical <span class=""math-container"">$T_{1}$</span> of <span class=""math-container"">$&gt; 20 ms$</span> and a <span class=""math-container"">$T_{2}$</span> of <span class=""math-container"">$&gt; 6 \mu s$</span>.</p>
<p>As you can see, these values vary quite a bit; one of the main pillars of current physical qubit systems development is to increase these characteristic times.</p>
<p>Note that this is just one part of the story; <span class=""math-container"">$T_{1}$</span> and <span class=""math-container"">$T_{2}$</span> say only something about what happens to your qubits when they are <em>idle</em>. The operations that you perform on the qubits are faulty themselves as well, and in a proper simulation of a QECC this has to be taken into account. Errors in operations can be seen as the perfect operation followed by some error in the form of a quantum channel, but what channel is applicable here is another question entirely and out of the scope for this answer; of course you're welcome to ask a separate question about this!</p>
",08/03/2020 10:15, Theoretical,"The question is asking about the fundamental principles of quantum error correction and the probability of errors in a quantum channel. This is a theoretical question because it is asking about the underlying physical principles of quantum computing. The question is not about a specific algorithm or implementation, and it is not asking for help with a specific problem. Instead, the question is asking about the fundamental principles of quantum computing.",Theoretical,,,, Theoretical,
13181.0,Suppress deprecation warnings from Qiskit,"<p>I am running a standard VQE from the example shown in here <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/vqe-molecules.html</a>, however I keep getting this output constantly (as many times the vqe runs which is a lot).</p>
<pre><code>DeprecationWarning: The Python built-in `round` is deprecated for complex scalars, 
and will raise a `TypeError` in a future release. Use `np.round` or `scalar.round` 
instead.
</code></pre>
<p>is there any way to suppress this without suppressing the entire python terminal as I need the output for other things.</p>
",<qiskit><programming><vqe>,08/05/2020 13:04,13182.0,13182.0,"<p>You can add the following before running the VQE to suppress the deprecation warning</p>
<pre><code>import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
# run VQE here
</code></pre>
<p>That turns <strong>all</strong> the deprecation warnings off, if you want to turn them on again you can add</p>
<pre><code>warnings.filterwarnings('always', category=DeprecationWarning)
</code></pre>
<p>I don't think there is a way to turn off just Qiskit's deprecation warnings.</p>
",08/05/2020 13:27,Errors,"The user is encountering a deprecation warning in their code and is seeking a way to suppress it, which falls under the Errors category.",Errors,,,,Errors,
13186.0,Is there a Q# funtion which returns the type of a variable?,"<p>As the title says, I am asking myself is there is a specific function which returns the type of something. Ideally, I would work as follows :</p>
<pre><code>let a = 4.0;
Message(Type(a));
</code></pre>
<p>This would print :</p>
<pre><code>double
</code></pre>
<p>Is there anything similar to this ? I tried to look at the api, but didn't find anything, I could definitely have missed something there.</p>
",<programming><q#>,08/05/2020 16:27,13188.0,13188.0,"<p>No, there isn't. We are avoiding having the means for types to impact the program flow, but I'd be interested to hear what the use case is. If is it only a matter of wanting to print the type rather than getting something that can be used within the program, then that is certainly something we could cover in the future (please consider making a feature request).</p>
",08/05/2020 19:28,API Usage ,"The user is asking about a  function in a programming language, which is API usage in quantum programming.",API Usage,,,,API Usage ,
13189.0,Usage of partial application in Q#,"<p>I am working with multiple operations and used partial application in different cases in Q#. I have 2 questions :</p>
<ul>
<li>Can a partial applicated operation be passed as an argument ?</li>
<li>Lets say you have an operation with 3 parameters. Can you first fill one argument, store it, fill another argument, store it, and then finally call the operation by filling the last argument ?</li>
</ul>
<p>Of course, I you need clarifications, I will comment and edit appropriately. Thanks for reading !</p>
",<programming><q#>,08/05/2020 20:22,13190.0,13190.0,"<blockquote>
<p>Can a partial applicated operation be passed as an argument ?</p>
</blockquote>
<p>Yes.</p>
<p>For example, let's say you want to pass an argument of type <code>(Qubit =&gt; Unit)</code> (an operation applied to a single qubit, say, a gate), and you want to get it by using <code>Ry</code> gate with a fixed rotation angle parameter. The signature of <code>Ry</code> operation is <code>operation Ry (theta : Double, qubit : Qubit) : Unit</code>, so its type is <code>((Double, Qubit) =&gt; Unit)</code>. If you use partial application to define a new operation</p>
<pre><code>let RyHalfPi = Ry(PI() / 2.0, _);
</code></pre>
<p>the signature of the new operation will be <code>(Qubit =&gt; Unit)</code> (since you already defined the first parameter), and it will behave as an operation that takes a single qubit parameter for all purposes, including passing it as an argument.</p>
<blockquote>
<p>Can you first fill one argument, store it, fill another argument, store it, and then finally call the operation by filling the last argument ?</p>
</blockquote>
<p>Yes, in exactly the same way as in the first case!</p>
<p>If, for example, you want to use <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1frac"" rel=""nofollow noreferrer""><code>R1Frac</code></a> gate with signature <code>(Int, Int, Qubit) : Unit</code>, you can first fill in the numerator:</p>
<pre><code>let R1Frac10 = R1Frac(10, _, _);
</code></pre>
<p>to get operation with signature <code>(Int, Qubit) : Unit</code>, and then fill in the power to get a single-qubit gate:</p>
<pre><code>for (power in 0 .. 1 &lt;&lt; 10) {
    let R1Frac10Power = R1Frac10 (power, _);
    // ...
}
</code></pre>
<p>You can also fill in parameters out of order (not necessarily left to right like I did in the example), following the same principle: you'll get an operation which takes all leftover (unsupplied) arguments in the order in which they are left.</p>
<ul>
<li>You can check the testing harnesses of the <a href=""https://github.com/microsoft/QuantumKatas/"" rel=""nofollow noreferrer"">Quantum Katas</a> for more examples - they use partial application quite extensively to use unified testing harness for tasks with slightly different operation signatures.</li>
</ul>
",08/05/2020 20:55,API Usage,"The user is asking about the usage of partial application in Q#, which is a feature of the Q# API. This falls under the category of API usage in quantum programming. ",Tooling, The question is asking about how to use partial application in Q# to pass partial applied operations as arguments and to fill arguments one at a time.,No,93.0,API Usage,"The user's inquiry pertains to understanding how to use partial application in Q#, which falls under the domain of API usage, as they seek guidance on utilizing this feature within the Q# programming interface."
13202.0,Qiskit: Initializing $n$ qubits with binary values ($0$s and $1$s),"<p>Is there a way in Qiskit to initialize <span class=""math-container"">$n$</span> qubits with binary values (0s and 1s)? For example, how can I initialize two qubits in the state <span class=""math-container"">$|11\rangle$</span>? Here is a code snippet:</p>
<pre><code>from qiskit import QuantumCircuit
import numpy as np

n = 2
circuit = QuantumCircuit(n, n)

# Seeking some sort of initialization routine like this
circuit.initializeQubits(initialState=np.ones(n), ...)   

# Define rest of the circuit
...
</code></pre>
<p>I am aware of the method in <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/circuits/3_summary_of_quantum_operations.ipynb"" rel=""nofollow noreferrer"">this</a> tutorial, which is also referenced <a href=""https://quantumcomputing.stackexchange.com/questions/1413/how-to-create-an-arbitrary-state-in-qiskit-for-a-local-qasm-simulator"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/9766/prepending-initial-state-to-a-quantum-circuit-in-qiskit"">here</a>. This method creates an arbitrary qubit state by defining an <span class=""math-container"">$N$</span> dimensional (<span class=""math-container"">$N = 2^n$</span>) state vector of amplitudes. The problem with this method is it requires creating a state vector which is exponentially large. I'm trying to initialize the qubits by defining an <span class=""math-container"">$n$</span> dimensional binary vector, which for the above example would be <code>[1, 1]</code>.</p>
",<quantum-state><qiskit><programming><ibm><initialization>,08/07/2020 02:20,13226.0,13226.0,"<p>You can also create a <code>Statevector</code>, that can be directly initialized as follows:</p>
<pre><code>from qiskit.quantum_info import Statevector
sv = Statevector.from_label('11')
</code></pre>
<p>You can use <code>sv.evolve(qc)</code> to apply an operator/circuit to the state, where <code>qc</code> is the operator/circuit. <code>sv.data</code> gives you the <code>numpy</code> array, containing the actual implementation of the state.</p>
<p>Check <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html"" rel=""noreferrer"">this</a> for more details.</p>
",08/08/2020 09:47, API Usage ,"The user is inquiring about whether there is a specific API or method in Qiskit to initialize qubits with binary values (0s and 1s) in a more convenient manner. This question falls under the ""API Usage"" category as it pertains to the usage of the Qiskit framework to achieve a specific task related to qubit initialization.", API Usage ,,,, API Usage ,
13213.0,Testing superposition states in Q#,"<p>I am learning Q# so, as I often do, I am writing some unit tests to play with quantum gates.
I was able to write these tests for X gate:</p>
<pre><code>    @Test(&quot;QuantumSimulator&quot;)
    operation XGateAppliedToZeroShouldTransformIntoOne() : Unit {
        
        using (q = Qubit()) {
            X(q);
            Assert([PauliZ], [q], One, &quot;X gate transform |0&gt; state in |1&gt; state.&quot;);

            X(q);
            Assert([PauliZ], [q], Zero, &quot;X gate transform |1&gt; state in |0&gt; state.&quot;);
        }
        
        Message(&quot;Test passed.&quot;);
    }
</code></pre>
<p>I am wondering how to write similar tests for the H gate: from what I know it will put the system in a superposition state that will give me 0 or 1 with a probability of 50%. How can I test an expected probability? Am I completely in the wrong direction here?</p>
",<programming><q#><superposition>,08/07/2020 13:41,13227.0,13227.0,"<p>As @JSdJ indicated in their comment, one approach is to perform the assertion in the ð-basis instead of the ð-basis:</p>
<pre><code>    open Microsoft.Quantum.Diagnostics;

    @Test(&quot;QuantumSimulator&quot;)
    operation CheckThatHPreparesPlus() : Unit {        
        using (q = Qubit()) {
            within { H(q); }
            apply {
                AssertMeasurement([PauliZ], [q], Zero, &quot;H operation did not prepare |+â©, given input in |0â©.&quot;);
            }
        }
    }
</code></pre>
<p>Another approach would be to use the <code>AssertMeasurementProbability</code> operation, which asserts that the probability of a given hypothetical measurement is equal to an expected probability:</p>
<pre><code>    open Microsoft.Quantum.Diagnostics;

    @Test(&quot;QuantumSimulator&quot;)
    operation CheckThatHPreparesPlus() : Unit {        
        using (q = Qubit()) {
            within { H(q); }
            apply {
                AssertMeasurementProbability(
                    [PauliZ], [q], Zero, 0.5,
                    &quot;State prepared by H operation does not admit 50/50 measurement in ð basis.&quot;, 1e-8
                );
            }
        }
    }
</code></pre>
<p>This second approach checks a weaker condition than the asserting in the ð-basis, since measuring a qubit in either the |+â© or |ââ© state will result in 50/50 probabilities when measured in the ð-basis, but only the |+â© has a 100% probability of returning a <code>Zero</code> when measured in the ð-basis.</p>
<p>Either way, though, one thing to keep in mind is that these assertions use that they're run on a simulator to do their job. By design, these assertions can be safely stripped when run on hardware, such that the no-cloning theorem applies. As Chris Kang notes in his answer, to test that hardware does what you expect can be involve some fairly different techniques compared to using a simulator to check that your program does what you expect. There's a lot of neat research out there (that's my main area of research, for example) on how to do that â you might find <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/18/3/033024/meta"" rel=""nofollow noreferrer"">quantum tomography</a> to be an interesting place to start!</p>
",08/08/2020 17:24,Learning,"The user is learning Q# and is asking for help in understanding how to write unit tests for quantum gates, specifically the H gate. This falls under the category of learning in quantum programming.", Learning,,,,Learning,
13248.0,Can a Qubit belong to 2 different registers?,"<p>I'm starting with Qiskit in Python.</p>
<p>My question is regarding to have registers and sub-register. Something like this</p>
<pre><code>axreg=QuantumRegister(4,name='ax')
ahreg=QuantumRegister(axreg[:2],name='ah')
alreg=QuantumRegister(axreg[2:],name='al')
</code></pre>
<p>The constructor of QuantumRegister has only the number of qubits to create, and I find no way to add previously existing qubit to other register</p>
",<qiskit><programming>,08/10/2020 17:25,13256.0,13256.0,"<p>If you want to add previously existing qubits to other register you can obviously compose or append to add previously existing qubits to other register, let's say we have have two qubits who are in state |++&gt; and we want to add them to our register which has for example 4 qubits, we can do</p>
<pre><code>sub_circuit = QuantumCircuit(2)
circuit = QuantumCircuit(4)
qr = circuit.qregs[0]
circuit.x(range(4))
sub_circuit.h(range(2))
circuit = circuit.append(sub_circ.to_instruction(), [qr[0], qr[1]])
</code></pre>
<p>You'll get something like this</p>
<p><a href=""https://i.stack.imgur.com/mgoYZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mgoYZ.png"" alt=""picture of the final circuit"" /></a></p>
",08/11/2020 04:33,Tooling,"The user is asking about how to work with QuantumRegisters in Qiskit, specifically how to create sub-registers and add previously existing qubits to other registers. This falls under the ""Tooling"" category as it involves using a specific quantum computing tool (Qiskit) to perform a specific task",Tooling,,,,Tooling,
13266.0,How to initialize a random state in Qiskit?,"<p>I know I can make a <code>random_circuit</code>, but I see that Qiskit has <code>random_statevector</code>. I'd like to optimize computation time by initializing a state by that instead of putting a random circuit at the beginning. Is it possible and how do I do it? Thank you!</p>
",<qiskit><programming>,08/11/2020 15:55,13270.0,13270.0,"<p>here is an example of how to initialize the random statevector then send it to the quantum circuit:</p>
<pre><code>from qiskit.quantum_info import random_statevector, Statevector
from qiskit import QuantumCircuit
# import numpy as np

vec = random_statevector(2)
# vec = Statevector([1, 0])
print('before circuit: {}'.format(vec)) 

qc = QuantumCircuit(1)
qc.x(0)
qc.draw()

new_vec = vec.evolve(qc)
print('after circuit: {}'.format(new_vec))
</code></pre>
<p>you should notice that the dim of state vector is 2 so the quantum circuit is 1 qubit.</p>
",08/12/2020 00:27,API Usage,"The user is asking about a specific feature in the Qiskit API, specifically how to initialize a state with a random statevector instead of using a random circuit. This falls under the category of API usage in quantum programming",API Usage,,,,API Usage,
13268.0,Qiskit error on get_backend(),"<p>Im trying to use IBM quantum machine instead of qiskit aer simulator with the following command:</p>
<pre><code>backend = IBMQ.get_backend('ibmq_16_melbourne', 'ibm-q')
</code></pre>
<p>It's giving me the following error:</p>
<hr />
<pre><code>AttributeError    Traceback (most recent call last)

 
 &lt;ipython-input-22-39269ac2204d&gt; in &lt;module&gt;
----&gt; 1 backend = IBMQ.get_backend('ibmq_16_melbourne', 'ibm-q')

AttributeError: 'IBMQFactory' object has no attribute 'get_backend'
</code></pre>
<p>What syntax I should try to submit the job to designated quantum machine?</p>
",<qiskit><programming><ibm-q-experience>,08/11/2020 22:29,13275.0,13275.0,"<p>First, check <a href=""https://quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">the IBM Quantum Services</a> page to see if you have access to any additional systems.  Make sure you are logged in with your IBMid to see what your account can access.</p>
<p>By default, basic users have access to the 5 qubit machines, but do not have access to 15 qubit machines like <code>ibmq_16_melbourne</code>.</p>
<p>Also, it looks like the snippet you provided is in an older syntax.</p>
<p>Check the <a href=""https://github.com/Qiskit/qiskit-ibmq-provider"" rel=""nofollow noreferrer"">IBM Quantum Provider</a> page on GitHub for information for the modern syntax. The new syntax would look like this:</p>
<pre><code>provider = IBMQ.get_provider('ibm-q')
backend = provider.get_backend('ibmq_16_melbourne')
</code></pre>
<p>Keep in mind that you can always use the simulators provided in Aer:</p>
<pre><code>from qiskit import Aer
Aer.backends()    # lists the available simulators
backend = Aer.get_backend('aer_simulator')
</code></pre>
<p>More information about Aer's simulators is available in <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/eb189a64cf6890474c25afb5612d8dff1f336beb/tutorials/simulators/1_aer_provider.ipynb"" rel=""nofollow noreferrer"">the relevant tutorial</a>.</p>
",08/12/2020 07:33,Errors,"The user is encountering an error while trying to use the IBMQ backend in Qiskit, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development",Errors,,,,Errors,
13273.0,Existence of multiple job monitor in qiskit,"<p>I can see in example code of qiskit, to implement job monitors on IBM Quantum machines, example uses any of the following</p>
<pre><code>from qiskit.tools.monitor import job_monitor
from qiskit.providers.ibmq.job import job_monitor
</code></pre>
<p>I have downloaded qiskit in my laptop and used both of them. Could not see any differences.</p>
<p>What is the difference between them? Does the invocation vary depending on the Quantum machine on which job is being executed?</p>
",<qiskit><programming><ibm-q-experience>,08/12/2020 06:32,13284.0,13284.0,"<p>They both are (almost) identical:
<a href=""https://qiskit.org/documentation/_modules/qiskit/tools/monitor/job_monitor.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/_modules/qiskit/tools/monitor/job_monitor.html</a>
<a href=""https://qiskit.org/documentation/_modules/qiskit/providers/ibmq/job/job_monitor.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/_modules/qiskit/providers/ibmq/job/job_monitor.html</a></p>
<p>The only difference is that <code>qiskit.tools.monitor.job_monitor()</code> have a argument named <code>quiet</code>, which is set to <code>false</code> by default:</p>
<pre><code>job_monitor(job, interval=None, quiet=False, output=sys.stdout)
</code></pre>
<p>If we set to to <code>true</code>, it will not print any status message.</p>
<p>As a best practice, you can use <code>help()</code> function.</p>
<p>If we import the first version:</p>
<pre><code>from qiskit.tools.monitor import job_monitor
help(job_monitor)
</code></pre>
<p>Corrosponding output shows:</p>
<pre><code>Help on function job_monitor in module qiskit.tools.monitor.job_monitor:

job_monitor(job, interval=None, quiet=False, output=&lt;ipykernel.iostream.OutStream object at 0x7fa9383ff7c0&gt;)
    Monitor the status of a IBMQJob instance.

    Args:
        job (BaseJob): Job to monitor.
        interval (int): Time interval between status queries.
        quiet (bool): If True, do not print status messages.
        output (file): The file like object to write status messages to.
        By default this is sys.stdout.
</code></pre>
<p>Now, if we import the second version:</p>
<pre><code>from qiskit.providers.ibmq.job import job_monitor
help(job_monitor)
</code></pre>
<p>Corrosponding output shows:</p>
<pre><code>Help on function job_monitor in module qiskit.providers.ibmq.job.job_monitor:

job_monitor(job: qiskit.providers.ibmq.job.ibmqjob.IBMQJob, interval: Union[float, NoneType] = None, output: &lt;class 'TextIO'&gt; = &lt;ipykernel.iostream.OutStream object at 0x7fa9383ff7c0&gt;) -&gt; None
    Monitor the status of an ``IBMQJob`` instance.

    Args:
        job: Job to monitor.
        interval: Time interval between status queries.
        output: The file like object to write status messages to.
            By default this is sys.stdout.
</code></pre>
",08/12/2020 14:55,Tooling,The user is inquiring about the difference between two different methods for implementing job monitors in Qiskit when using IBM Quantum machines. This question pertains to the practical usage and tooling within the Qiskit framework and how to effectively monitor jobs on IBM Quantum machines.,Tooling,,,,Tooling,
13341.0,Can classical linear algebra solvers implement quantum algorithms with similar speed-ups?,"<p>A quantum algorithm begins with a register of qubits in an initial state, a unitary operator (the algorithm) manipulates the state of those qubits, and then the state of the qubits is read out (or at least some information about the state on a single run of the algorithm).</p>
<p>It seems to me that a quantum computer answers the question of the unitary acts on the quantum state. This is &quot;just&quot; a matter of linear algebra. It strikes me, then, that quantum computers can be seen as linear algebra calculators.</p>
<p>Why then do we need quantum mechanics? Can we not find a classical system which implements linear algebra operations and use this to implement the algorithms which have been designed for quantum computers? Of course classical digital computers will not suffice, these machines are based on binary processing of information rather than the manipulation of vectors in a high dimensional space.</p>
<p>Question: Are there any candidates for classical linear algebra solvers (classical analog computers) which could implement the &quot;quantum computer&quot; algorithms whiles enjoying a similar speedup over digital classical computers?</p>
<p>Question 2: Perhaps I'm over simplifying by reducing a quantum computer to being simply a linear algebra solver. Is this the case? What complexity am I glossing over?</p>
",<algorithm><classical-computing><speedup><information-theory>,8/16/2020 2:56,13344.0,13344.0,"<p>The complexity that you are glossing over is that in the general case you need to store <span class=""math-container"">$2^n$</span> complex amplitudes to even represent an <span class=""math-container"">$n$</span> qubit system classically. Therefore, for a quantum computer of let's say 1000 qubits you need to store  <span class=""math-container"">$2^{1000}$</span> complex amplitudes. Even if you use one atom per amplitude to do this, you still run out of atoms in the observable universe.</p>
<p>As far as I know, the above is the general argument. However, there might still be ways to represent certain quantum algorithms in a classically tractable manner by utilising some clever insight to save on the representational needs of the algorithm, thereby going below the <span class=""math-container"">$2^n$</span> requirement. But this is likely to be problem-specific and unlikely to work in the general case.</p>
",8/16/2020 11:59,Theoretical,"The user is asking about the theoretical aspects of quantum computing, specifically the role of quantum mechanics and the possibility of classical systems implementing quantum algorithms. This falls under the category of inquiries about theoretical concepts, algorithms, and principles in quantum computing.",Theoretical ,,,,Theoretical,
13388.0,What is the analysis of the Bell Inequality protocol in Cirq's 'examples'?,"<p>This question is taken from <a href=""https://github.com/quantumlib/Cirq/issues/3032"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/issues/3032</a>.</p>
<p>The &quot;standard&quot; protocol measures Alice's and Bob's qubits in different bases, while the one in Cirq measures in the same basis. I can't prove the equivalence of these seemly different protocols that violate Bell's inequality.</p>
",<programming><circuit-construction><cirq><bell-experiment>,8/18/2020 19:42,13390.0,13390.0,"<p>The part you're overlooking is these lines:</p>
<pre><code>    # Players do a sqrt(X) based on their referee's coin.
    circuit.append([
        cirq.CNOT(alice_referee, alice)**0.5,
        cirq.CNOT(bob_referee, bob)**0.5,
    ])
</code></pre>
<p>The players rotate their qubits conditioned on what the local referee said. This is equivalent to changing the measurement basis conditioned on what the local referee said.</p>
<p>The only relevant property is that the effective measurement bases start off offset by -45 degrees (mostly agree), so that a 90 degree rotation by one player gets you to +45 degrees (still mostly agree) while a rotation by both players gets you to +135 degrees (mostly disagree). The example sets up such a situation.</p>
",8/19/2020 1:14, Theoretical,"The user is asking about the theoretical equivalence of two different protocols that violate Bells inequality, one standard and one implemented in Cirq. This falls under the category of inquiries about theoretical concepts, algorithms, and principles in quantum computing.",Theoretical,,,, Theoretical,
13421.0,How to get state vector probabilities in Q#,"<p>Is there a similare function in Q# like Statevector.probabilities in Qiskit to get state vector probability, for example, if my circuit contains one qubit with one <span class=""math-container"">$H$</span> gate, the function returns something like <code>[0.5, 0.5]</code>.</p>
",<quantum-state><programming><q#>,8/21/2020 21:55,13423.0,13423.0,"<p>You may be looking for <code>DumpMachine</code> which will gove you all the information about the whole quantum machine including complex amplitudes and phases. You can find the tutorials here : <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/using-qsharp/testing-debugging?tabs=tabid-vs2019#dump-functions"" rel=""nofollow noreferrer"">here</a></p>
",8/21/2020 22:27,API Usage,"The user is asking about a specific function or feature in Q# that allows them to obtain state vector probabilities, similar to Statevector.probabilities in Qiskit. This falls under the category of API usage in quantum programming, as the user is seeking information on how to use a particular feature of the Q# programming language.",API Usage ,,,,API Usage,
13433.0,Implementing block of gates at different times in a same qiskit program,"<p>I am implementing an Ising chain over 8 qubits. It involves pair-wise CNOT between all the qubits. In the first time step, I am doing CNOTs between qubits  0 and 1, 2 and 3, 4 and 5, and 6 and 7. In the second time step, I would do CNOTs between qubits 1 and 2, 3 and 4, and 5 and 6. I have written the code as follows:</p>
<pre><code># Block A for the first time step
qp.cx(q0,q1)
qp.cx(q2,q3)
qp.cx(q4,q5)
qp.cx(q6,q7) 

# Block B for the second time step
qp.cx(q1,q2)
qp.cx(q3,q4)
qp.cx(q5,q6)
</code></pre>
<p>I would like the gates in Block A to be applied simultaneously. Then, in the next step, gates in Block B should be applied simultaneously. How to convey to the compiler that I do not want the above written code to be compiled sequentially, rather I want it to be applied block-wise.</p>
",<qiskit><programming><ibm-q-experience>,8/22/2020 14:39,13457.0,13457.0,"<p>Did you try to put a barrier between your two blocks? You can do this by writing this <code>qp.barrier()</code> right after your first block, then Qiskit will transpile separately the two blocks. Is this what you were searching for?</p>
",8/24/2020 14:16,Tooling,"The user is inquiring about how to instruct the quantum compiler to apply gates simultaneously in blocks, rather than sequentially. This falls under the ""Tooling"" category as it pertains to the practical usage and configuration of quantum computing tools and compilers.",Tooling,,,,Tooling,
13481.0,Optimization using Quantum Logics,"<p>Is it possible to solve the following kind of optimization using Quantum Computing?</p>
<pre><code>Minimize
5*x1 - 7*x2

binary
x1
x2
</code></pre>
<p>If yes, is it possible to have a sample code using <code>QISKit</code>?</p>
",<qiskit><programming><resource-request><optimization>,8/26/2020 20:50,13486.0,13486.0,"<p>Qiskit has an optimization module and you can find tutorials that illustrate its functionality <a href=""https://qiskit.org/documentation/tutorials/optimization/index.html"" rel=""nofollow noreferrer"">here</a>.</p>
<p>To solve the example you posted, e.g., with the Quantum Approximate Optimization Algorithm (QAOA), you can do the following:</p>
<pre><code>from qiskit import Aer
from qiskit.optimization import QuadraticProgram
from qiskit.aqua.algorithms import QAOA
from qiskit.optimization.algorithms import MinimumEigenOptimizer

# construct optimization problem
qp = QuadraticProgram()
qp.binary_var('x1')
qp.binary_var('x2')
qp.minimize(linear=[5, -7])

# initialize optimizer
qaoa_mes = QAOA(quantum_instance=Aer.get_backend('statevector_simulator'))
qaoa = MinimumEigenOptimizer(qaoa_mes)

# solve problem
result = qaoa.solve(qp)
print(result)
</code></pre>
<p>which prints:</p>
<pre><code>optimal function value: -7.0
optimal value: [0. 1.]
status: SUCCESS
</code></pre>
<p>Qiskit's optimization module also provides other quantum optimization algorithms for quadratic programs and you can find a more detailed description <a href=""https://medium.com/qiskit/towards-quantum-advantage-for-optimization-with-qiskit-9a564339ef26"" rel=""nofollow noreferrer"">here</a>.</p>
",8/27/2020 7:14,API Usage,"The user is asking about how to implement a specific optimization problem using Qiskit, which falls under the category of API usage in quantum programming",Conceptual,"This question falls under the ""Conceptual"" category because the user is inquiring about the conceptual feasibility of solving a specific optimization problem using quantum computing. They are looking for information and guidance regarding the potential for quantum computing to address such optimization problems, which is a conceptual consideration.",No,94.0,API Usage,"The user's question directly pertains to implementing a specific optimization problem using Qiskit, indicating a need for understanding how to utilize the Qiskit API effectively for optimization tasks."
13488.0,Reordering commuting gates in cirq to reduce circuit depth?,"<p>The main functionality for ordering gates in a cirq circuit that I'm aware of is using the predefined insert strategies of <code>cirq.Circuit.insert()</code>. As far as I see, none of the predefined strategies use the possibility to shuffle commuting gates to reduce circuit depth, i.e. that CNOTs that share the same target or control commute, etc. The docs also don't seem to mention anything like this.</p>
<p>I'd like to specifically use the commutation rules of CNOTs to reduce the depth of my circuits, and before I start writing my own code, my question is: does cirq provide any functionality of this sort?</p>
",<programming><cirq>,8/27/2020 11:02,13491.0,13491.0,"<p>No, there's no built-in functionality to optimize the circuit in that way.</p>
<p>There is <code>cirq.commutes(A, B)</code> which will tell you if A and B commute. However, <code>cirq.commutes</code> is permitted to fail instead of giving a result, and it is somewhat new so there's still several landmines you can hit when using it. For example, it currently will <a href=""https://github.com/quantumlib/Cirq/issues/3274"" rel=""nofollow noreferrer"">refuse to check if an operation commutes with a moment</a>. You can instead use <code>cirq.definitely_commutes(A, B)</code>, which replaces the failures with false negatives, keeping in mind that you will sometimes see things that you know commute not moving through each other because the comparison isn't supported yet.</p>
",8/27/2020 21:24,Tooling,"The user is asking about a specific feature in Cirq, a quantum computing framework,  so belong to  Tooling category.",Tooling,,,,Tooling,
13503.0,"When defining the state vector of a qubit in qiskit, what difference does putting ""j"" make?","<p>I'm following the Qiskit textbook. I'm currently here: <a href=""https://quantum-computing.ibm.com/jupyter/user/qiskit-textbook/content/ch-states/representing-qubit-states.ipynb"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/jupyter/user/qiskit-textbook/content/ch-states/representing-qubit-states.ipynb</a></p>
<p>Here's an example of my initialization code:</p>
<pre><code>initial_state = [1/sqrt(2), 1j/sqrt(2)]

qc = QuantumCircuit(1)

qc.initialize(initial_state, 0)

state = execute(qc,backend).result().get_statevector() 

print(state) 
</code></pre>
<p>[0.70710678+0.j         0.        +0.70710678j]</p>
<pre><code>results = execute(qc,backend).result().get_counts()

plot_histogram(results)
</code></pre>
<p>When I plot this to a histogram, the same 50/50 distribution occurs as when I remove the imaginary &quot;j&quot; from the initialization.  Why is the j in there?</p>
",<qiskit><programming>,8/29/2020 9:00,13504.0,13504.0,"<p>Those two states are different quantum states (with different relative phases) that have the same probabilities of measurement outcomes when we measure in <span class=""math-container"">$Z$</span> basis. The first state without <span class=""math-container"">$i$</span> (<span class=""math-container"">$j$</span> in the Python):</p>
<p><span class=""math-container"">$$|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$$</span></p>
<p>with <span class=""math-container"">$i$</span>:</p>
<p><span class=""math-container"">$$|i\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)$$</span></p>
<p>In order to show the difference between these two states let's apply <span class=""math-container"">$H S^{\dagger}$</span> gates to each of them and see how much different results we can obtain:</p>
<p><span class=""math-container"">$$ H S^{\dagger} |+\rangle = H \frac{1}{\sqrt{2}}(|0\rangle - i|1\rangle) = \frac{1}{2}((1-i)|0\rangle + (1 + i)|1\rangle)$$</span></p>
<p>The probability of measuring <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> is equal to <span class=""math-container"">$|\frac{1-i}{2}|^2 = |\frac{1+i}{2}|^2 = 0.5$</span>. Now let's apply the same gates to the <span class=""math-container"">$|i\rangle$</span>:</p>
<p><span class=""math-container"">$$ H S^{\dagger} |i\rangle = H \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) = |0\rangle$$</span></p>
<p>The probability of measuring <span class=""math-container"">$|0\rangle$</span> is equal to <span class=""math-container"">$1$</span>. These two states (<span class=""math-container"">$|+\rangle$</span> and <span class=""math-container"">$|i\rangle$</span>) can lead to different results, so <span class=""math-container"">$i$</span> (or <span class=""math-container"">$j$</span> in Python) does make a difference.</p>
<hr />
<p><strong>Answer to the questions in the comments</strong></p>
<p>Measurement in <span class=""math-container"">$Z$</span> basis is the conventional measurement: measuring if the state is in <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> state (there are other basis measurements: a related example can be found in this <a href=""https://quantumcomputing.stackexchange.com/a/11791/9459"">answer</a>). <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> are eigenvectors (also eigenbasis) of <span class=""math-container"">$Z=\begin{pmatrix} 1&amp;0 \\ 0 &amp; -1 \end{pmatrix}$</span> operator. <span class=""math-container"">$HS^{\dagger}$</span> is two separate gates: <span class=""math-container"">$H$</span> and <span class=""math-container"">$S^{\dagger}$</span>. Here I have applied firstly <span class=""math-container"">$S^\dagger = \begin{pmatrix} 1&amp;0 \\ 0 &amp; -i \end{pmatrix}$</span> gate, then <span class=""math-container"">$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1&amp;1 \\ 1 &amp; -1 \end{pmatrix}$</span> gate.</p>
",8/29/2020 10:21,Conceptual,"This question is categorized under ""Conceptual"" because the user is seeking a conceptual understanding of the presence of the imaginary unit ""j"" in their initialization code and its impact on the quantum state. They want to understand the significance of ""j"" in this context, indicating a conceptual inquiry related to quantum states and complex numbers in quantum programming..",Conceptual,,,,Conceptual,
13529.0,How can I create an arbitrary superposition state of two qubits in Qiskit?,"<p>I am trying to produce any arbitrary superposition state of two qubits, for example <span class=""math-container"">$a|00\rangle + b|01\rangle + c|10\rangle + d|11\rangle$</span>, such that <span class=""math-container"">$a^2 + b^2 + c^2 + d^2 = 1$</span> . How can I do that with Qiskit?</p>
<p>One way that I have found out is to use <span class=""math-container"">$U_3(\theta, 0, 0)$</span> gates for suitable values of <span class=""math-container"">$\theta$</span> on both of the qubits. Is there another way?</p>
",<qiskit><programming>,8/31/2020 23:32,13533.0,13533.0,"<p><code>qiskit.quantum_info</code> has a useful <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.random_statevector.html"" rel=""nofollow noreferrer"">random_statevector</a> function that you can use to generate a random statevector that's sampled from the uniform measure.
For a 2-qubit state, you would call it as follows:</p>
<pre><code>from qiskit.quantum_info import random_statevector
state = random_statevector(4) # note: the parameter you pass is the number of entries in the vector, not the number of qubits
</code></pre>
<p>Once you have this statevector, the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html#qiskit.circuit.QuantumCircuit.initialize"" rel=""nofollow noreferrer"">initialize</a> function lets you initialize your qubits to the state you just created. The documentation for <code>initialize</code> is not very helpful so here's how you would use it:</p>
<pre><code>from qiskit import QuantumCircuit
qc = QuantumCircuit(2)
qc.initialize(state.data, [0,1])
</code></pre>
<p>Note that you will have to use <code>state.data</code> to get the underlying array representing the statevector, because <code>initialize</code> doesn't accept an argument of type <code>StateVector</code>.</p>
<p>Hope this helps!</p>
",09/01/2020 03:21,Theoretical,"The user is asking about the theoretical aspects of creating an arbitrary superposition state in quantum computing, which falls under the Theoretical category.",Theoretical,,,,Theoretical,
13532.0,Principal square root of Pauli Y gate in Qiskit?,"<p>I've seen a similar question asked (<a href=""https://quantumcomputing.stackexchange.com/questions/11677/how-do-i-compute-the-square-root-of-the-y-gate"">How do I compute the square root of the $Y$ gate?</a>) but I'm trying to understand how I can use the gates <span class=""math-container"">$Y^{\frac{1}{2}}$</span> or <span class=""math-container"">$Y^{\frac{1}{4}}$</span> in Qiskit in terms of other building blocks, if it is possible.</p>
<p>Is there a way to use the gate <span class=""math-container"">$Y^{\frac{1}{2}} = \begin{bmatrix}
\frac{1}{2}
 + \frac{1}{2}i &amp; -\frac{1}{2} - \frac{1}{2}i\\
\frac{1}{2} + \frac{1}{2}i &amp; \frac{1}{2} + \frac{1}{2}i
\end{bmatrix}$</span> in Qiskit? I can say that <span class=""math-container"">$Y = iRY(\pi)$</span> and compute the square root manually, but how can I describe such an operation, if possible, in Qiskit?</p>
",<quantum-gate><qiskit><programming><gate-synthesis><pauli-gates>,09/01/2020 01:04,13536.0,13536.0,"<p>For some reason this took a while to find, but has a simple solution:</p>
<pre><code>circ.append(YGate().power(1/2), [qbit])
</code></pre>
<p>Where <code>circ</code> is the <code>QuantumCircuit</code> object and <code>qbit</code> is the register to apply the gate on.</p>
",09/01/2020 04:36,Theoretical,"The user is asking about the theoretical aspects of quantum gates, specifically the square root of the Y gate, and how to implement it in Qiskit, which falls under the Theoretical category.",Theoretical,,,,Theoretical,
13535.0,Can I append gates in a certain position in a Qiskit circuit,"<p>I have a question regarding modifying Qiskit circuits. I have a set of circuits that are pretty similar to each other. The only difference being some gates in the beginning of each circuit. I was wondering if instead of creating new circuits each time, I could just append gates to the beginning of the circuit. However, currently, all the methods I am aware of that act on the QuantumCircuit only append to the end of the circuit.</p>
<p>Is there a way I can add certain gates to the beginning of a Qiskit Circuit as opposed to creating new ones each time?</p>
",<quantum-gate><qiskit><programming>,09/01/2020 03:37,13537.0,13537.0,"<p>Have a look at <a href=""https://arxiv.org/abs/1903.04359"" rel=""nofollow noreferrer"">Introduction to Coding Quantum Algorithms: A Tutorial Series Using Qiskit</a>.</p>
<p>In lesson 2, there is a lot of statements allow you manipulate circuits. You can add a gate on specific place, delete a gate, combine circuits etc.</p>
<p>The manual I refer to is very easy to understand. Each manipulation is documented with examples.</p>
<p><strong>Concerning combining of the circuit, you can use this statement:</strong></p>
<pre><code>newCircuit = oldCircuit1 + oldCircuit2
</code></pre>
<p>or</p>
<pre><code>newCircuit = oldCircuit2 + oldCircuit1
</code></pre>
<p>So, you can easily add one circuit to the end or the begin of another circuit.</p>
",09/01/2020 06:59,Tooling ,"The user is asking about how to append gates to the beginning of a Qiskit Circuit, which is a tooling question.",Tooling ,,,,Tooling ,
13544.0,How to build an ExpectationBase object?,"<p>I'm trying to wrap my head around the expectation argument in Qiskit's <code>VQE</code> class, so to understand it I'm trying to create an ExpectationBase object to understand it better, but I'm getting nowhere. Can anyone give a hand?</p>
",<qiskit><programming><vqe>,09/01/2020 14:19,13545.0,13545.0,"<p>The VQE computes the expectation values of the input operator with respect to the parameterized ansatz circuit. There are different ways to compute this expectation value, e.g. you could</p>
<ul>
<li>convert operator to a matrix, the ansatz circuit to a statevector and compute the dot-product, or</li>
<li>convert the operator to Pauli strings, diagonalize the ansatz circuit in each basis of the Pauli strings and measure.</li>
</ul>
<p>The <code>expectation</code> argument allows you to choose the kind of expectation computation you want to use.</p>
<ul>
<li><code>qiskit.aqua.operators.MatrixExpectation</code> does the dot product</li>
<li><code>qiskit.aqua.operators.PauliExpectation</code> does the Pauli string transform (this is what you would do on real quantum hardware)</li>
<li><code>qiskit.aqua.operators.AerPauliExpectation</code> uses a special expectation value from Qiskit's Aer element</li>
</ul>
<hr />
<p>A bit more advanced:</p>
<p>If you were to create your own kind of expectation computation you can check how <a href=""https://github.com/Qiskit/qiskit-aqua/blob/master/qiskit/aqua/operators/expectations/matrix_expectation.py"" rel=""nofollow noreferrer""><code>MatrixExpectation</code></a> or <a href=""https://github.com/Qiskit/qiskit-aqua/blob/master/qiskit/aqua/operators/expectations/pauli_expectation.py"" rel=""nofollow noreferrer""><code>PauliExpectation</code></a> are implemented. They require some knowledge of how the operator flow in Aqua works though. In brief, the <code>ExpectationValue</code> provides a <code>convert</code> method that maps an operator expression that realizes the expectation value (something like <code>OperatorMeasurement @ StateFn</code>) to a new expression that implements your expectation value scheme. For <code>MatrixExpectation</code> this means converting all operators to matrices and for <code>PauliExpectation</code> this means converting the operator to Pauli strings and applying the right basis transformations to the ansatz circuit.</p>
",09/01/2020 15:43,Tooling,"The user is asking about how to use the ExpectationBase class in Qiskit, which is a tooling question.",Tooling,,,,Tooling,
13579.0,How to create a qubit in an arbitrary state in PyQuil,"<p>In PyQuil, a qubit is initialised as <span class=""math-container"">$|0\rangle$</span> by default. Suppose, I want to initialise a qubit in an arbitrary state, say <span class=""math-container"">$\frac{1}{\sqrt{3}}|0\rangle+\sqrt{\frac{2}{3}}|1\rangle$</span>. How to do this arbitrary qubit initialisation in PyQuil?</p>
",<programming><pyquil><rigetti>,09/03/2020 07:05,13588.0,13588.0,"<p>As far as I know, you can only do this with the <a href=""https://pyquil-docs.rigetti.com/en/stable/apidocs/autogen/pyquil.reference_simulator.ReferenceDensitySimulator.html#pyquil.reference_simulator.ReferenceDensitySimulator"" rel=""nofollow noreferrer"">ReferenceDensitySimulator</a>, which contains a <code>set_initial_state</code> method. This is unfortunate because density matrix simulation is very costly.</p>
<p>In your case:</p>
<pre><code>from pyquil import Program
from pyquil.simulation import ReferenceDensitySimulator
from pyquil.pyqvm import PyQVM
from pyquil.gates import I

state_ket = np.array([1/np.sqrt(3), np.sqrt(2/3)])
state_bra =  np.array([[1/np.sqrt(3)], [np.sqrt(2/3)]])

rho1 = state_ket * state_bra

prog = Program(I(0))
qam = PyQVM(n_qubits=1, quantum_simulator_type=ReferenceDensitySimulator)

# must call reset() to change the current state of the density matrix
density_matrix = qam.wf_simulator.set_initial_state(rho1).reset()
qam.execute(prog)
np.testing.assert_array_equal(qam.wf_simulator.density, rho1)
</code></pre>
",09/03/2020 15:38,Tooling ,"The user is asking about a specific feature in PyQuil, a quantum computing framework, which falls under the Tooling category",Tooling ,,,,Tooling ,
13581.0,How to implement quantum gate from matrix in Q#,"<p>Is it possible to implement a quantum gate from a matrix in Q#, the equivalent of unitary function in Qiskit ? My final goal is to implement cirq CZPowGate in Q#.</p>
<p>Thank you.</p>
",<programming><q#><matrix-representation>,09/03/2020 07:35,13594.0,13594.0,"<p>There's a <a href=""https://github.com/microsoft/QuantumLibraries/issues/291"" rel=""nofollow noreferrer"">feature request</a> for a Q# operation to apply an arbitrary unitary operation given its representation as a matrix; if you're interested, please go on and leave a comment on that request!</p>
<p>In the meantime, though, it's actually really straightforward to implement the same unitary operation as <code>cirq.CZPowGate</code> in Q#.</p>
<pre><code>open Microsoft.Quantum.Math as Math;

operation ApplyCZPow(t : Double, control : Qubit, target : Qubit) : Unit is Adj + Ctl {
    Controlled R1([control], (t * Math.PI(), target));
}
</code></pre>
<p>This uses the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1"" rel=""nofollow noreferrer""><code>R1</code> operation</a> provided with the Microsoft.Quantum.Intrinsic namespace together with the <a href=""https://docs.microsoft.com/quantum/user-guide/using-qsharp/operations-functions#controlled-functor"" rel=""nofollow noreferrer""><code>Controlled</code> keyword</a> to apply the same rotation as <code>cirq.CZPowGate</code>.</p>
<hr />
<p>To see how this works, note that as per the <a href=""https://cirq.readthedocs.io/en/stable/generated/cirq.CZPowGate.html"" rel=""nofollow noreferrer"">Cirq documentation for CZPowGate</a>, that instruction is represented by the unitary matrix
<span class=""math-container"">$$
U_{\text{CZPowGate}}(t) = \left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; e^{i \pi t}
\end{matrix}\right).
$$</span>
This is a special case of a controlled operation with a single control qubit, as it has the pattern
<span class=""math-container"">$$
\Lambda(U) = \left(\begin{matrix}
ð &amp; 0 \\
0 &amp; U
\end{matrix}\right) = |0\rangle\langle0| \otimes ð + |1\rangle\langle1| \otimes U
$$</span>
for some unitary matrix <span class=""math-container"">$U$</span>. In particular, <span class=""math-container"">$U$</span> in this case represents a rotation that leaves the <span class=""math-container"">$|0\rangle$</span> state alone but that applies a phase to the <span class=""math-container"">$|1\rangle$</span> state; precisely the action of the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1"" rel=""nofollow noreferrer""><code>R1</code> operation</a>.</p>
<p>In Q#, the <code>Controlled</code> keyword can be used to get the controlled version of any controllable operation (that is, an operation with <code>is Ctl</code> in its signature). Each <code>Controlled</code> operation takes as its first input an array of controls, and takes all of the original inputs to the uncontrolled operation as the second input. For example, <code>CNOT(control, target)</code> in Q# is shorthand for <code>Controlled X([control], target)</code>.
Similarly, a Toffoli in Q# can be written as <code>Controlled X([control1, control2], target)</code> and the Fredkin operation can be written as <code>Controlled SWAP([control], (target1, target2))</code>.</p>
<p>Using the same pattern here works since <code>R1</code> is a controllable operation. We can check  that we get what we expect by using the <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpoperation"" rel=""nofollow noreferrer""><code>Microsoft.Quantum.Diagnostics.DumpOperation</code>  operation</a> to check the unitary representation of our new <code>ApplyCZPow</code> operation (<a href=""https://mybinder.org/v2/gist/cgranade/b8cefb19b63154f343c790c035a8e161/master"" rel=""nofollow noreferrer"">run online without installing</a>):</p>
<pre><code>open Microsoft.Quantum.Diagnostics as Diag;

operation DumpApplyCZPow(t : Double) : Unit {
    Diag.DumpOperation(2, ApplyToFirstTwoQubitsCA(ApplyCZPow(t, _, _), _));
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/BF9U9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BF9U9.png"" alt=""Using %simulate to run DumpCZPow"" /></a></p>
",09/04/2020 16:58,Tooling," The user is asking about a specific feature in Q#, a quantum computing framework, which falls under the Tooling category",Tooling,,,,Tooling,
13584.0,How can I print out the probability of a certain state in histogram?,"<p><a href=""https://i.stack.imgur.com/t8zUw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t8zUw.png"" alt=""enter image description here"" /></a></p>
<p>This is a simulation I did in my program. I'm hoping to print out the probability of the state <span class=""math-container"">$|0001\rangle$</span> (which is <span class=""math-container"">$0.052$</span>), and store this number in a letter (a). How can I do this? Thanks!!</p>
",<quantum-state><qiskit><programming><simulation>,09/03/2020 14:24,13585.0,13585.0,"<p><code>.get_counts()</code> returns a dictionary with the keys being the measured state and their corresponding values being the number of times that result was measured. To get the number of times that state was measured you can do:</p>
<pre><code>print(counts['0001'])
</code></pre>
<p>To get probability, you need to divide this by the total number of shots. If you're not sure of the number of shots, you can sum the total number of shots in the dictionary using:</p>
<pre><code>sum(counts.values())
</code></pre>
<p>and from this print the probability:</p>
<pre><code>print(counts['0001'] / sum(counts.values()))
</code></pre>
",09/03/2020 15:13,Tooling,"The user is asking about how to print the probability of a specific state in a quantum circuit and store it in a variable, which is a tooling question.",Tooling,,,,Tooling,
13605.0,How to measure in another basis,"<p>I am new to qiskit and I have to simulate a quantum circuit. I read this documentation <a href=""https://qiskit.org/textbook/ch-states/single-qubit-gates.html"" rel=""noreferrer"">https://qiskit.org/textbook/ch-states/single-qubit-gates.html</a> where it is left as an exercise to the reader to write a function to measure in the <span class=""math-container"">$|+i\rangle$</span> and <span class=""math-container"">$|-i\rangle$</span> or the y-basis. I want to know if I've done it correctly or not.</p>
<p>I need to measure a state in the y-basis after preparing it in an equal superposition the <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> states. To do this, I first applied the Hadamard gate which does the first part and takes the <span class=""math-container"">$|0\rangle$</span> state to the <span class=""math-container"">$|+\rangle$</span> state. Now comes the measurement part. To do this I applied an <span class=""math-container"">$S^\dagger$</span> and then the <span class=""math-container"">$H$</span> gate again.</p>
<p>Now I simply measure the state</p>
<pre><code>def Y_measurement(qc,qubit,cbit):
    qc.sdg(qubit)
    qc.h(qubit)
    qc.measure(qubit,cbit)
    return qc

circuit = QuantumCircuit(1,1)
circuit.h(0)
circuit.barrier()


Y_measurement(circuit, 0, 0)

circuit.draw(output='mpl') 
</code></pre>
<p><a href=""https://i.stack.imgur.com/xrfQn.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/xrfQn.png"" alt=""enter image description here"" /></a></p>
<p>Is this correct?</p>
",<qiskit><programming><circuit-construction><measurement>,09/05/2020 15:47,13611.0,13611.0,"<p>Yes, your solution is correct.</p>
<p>Please find here circuits for measurement in <em>z</em> (computational), <em>y</em> (circular) and <em>x</em> (Hadamard) bases:</p>
<p><a href=""https://i.stack.imgur.com/Bil8h.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Bil8h.png"" alt=""enter image description here"" /></a></p>
<p>Source: <a href=""https://arxiv.org/abs/1804.03719"" rel=""noreferrer"">Quantum Algorithm Implementations for Beginners</a>, pg. 68.</p>
<p>Note that the blue Hadamard gate is used for preparing state <span class=""math-container"">$|+\rangle$</span> which is then measured. Pink gates are those needed for measuring in different basis. So, measurement in <em>z</em> basis needs no additional gate (left circuit), measuring in <em>y</em> basis needs <span class=""math-container"">$S^\dagger$</span> and <span class=""math-container"">$H$</span> additional gates (middle circuit) and measuring in <em>x</em> basis needs additional <span class=""math-container"">$H$</span> gate (right circuit).</p>
",09/06/2020 06:15,Learning,"The user is learning Qiskit and is asking for feedback on whether they have correctly implemented a function to measure a state in the y-basis. This falls under the category of requests for learning resources, tutorials, and references in quantum computing.",Learning,,,,Learning,
13615.0,Qiskit plot_state_qsphere phase error,"<p>I'm trying to visualize a simple circuit in Qiskit. A single gate <span class=""math-container"">$Y$</span> is applied to the single-qubit register. The expected state is:</p>
<p><span class=""math-container"">$$ Y |0\rangle 
= \begin{bmatrix} 0 &amp; -i \\ i &amp; 0 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix}
= \begin{bmatrix} 0 \\ i \end{bmatrix}
= i |1\rangle $$</span></p>
<p>Then I visualize the final state with <code>plot_state_qsphere</code> function (<a href=""https://qiskit.org/documentation/stubs/qiskit.visualization.plot_state_qsphere.html"" rel=""nofollow noreferrer"">documentation</a>). Since the coefficient of <span class=""math-container"">$|1\rangle$</span> is <span class=""math-container"">$i$</span> I'm expecting phase <span class=""math-container"">$\pi/2$</span> since <span class=""math-container"">$i = e^{i \pi/2}$</span>.</p>
<pre><code>from qiskit import *
from qiskit.tools.visualization import plot_state_qsphere
print(qiskit.__qiskit_version__) # {'qiskit-terra': '0.15.1', 'qiskit-aer': '0.6.1', 'qiskit-ignis': '0.4.0', 'qiskit-ibmq-provider': '0.8.0', 'qiskit-aqua': '0.7.5', 'qiskit': '0.20.0'}
circuit = QuantumCircuit(1)
circuit.y(0)
statevector = execute(circuit, backend=Aer.get_backend('statevector_simulator')).result().get_statevector()
print(statevector) # [0.-0.j 0.+1.j]
plot_state_qsphere(statevector)
</code></pre>
<p>In this representation, <span class=""math-container"">$\pi/2$</span> phase corresponds to green color. However, I visualize the red color (<span class=""math-container"">$0$</span> phase). Is it a known bug? Am I missing something?</p>
<p><a href=""https://i.stack.imgur.com/yvXTJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yvXTJ.png"" alt=""Jupyter notebook with phase bug shown"" /></a></p>
",<qiskit><programming>,09/06/2020 17:16,13631.0,13631.0,"<p>This is due to an internal normalization based on setting the phase of the largest magnitude element to one. This cannot be changed without modifications to the source code. As an alternative, see the following examples from the Kaleidoscope package I made: <a href=""https://nonhermitian.org/kaleido/tutorials/interactive/qsphere.html"" rel=""nofollow noreferrer"">https://nonhermitian.org/kaleido/tutorials/interactive/qsphere.html</a></p>
",09/07/2020 14:25,Errors ,"The user is encountering an unexpected behavior while using the plot_state_qsphere function in Qiskit, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development. ",Errors,,,,Errors ,
13626.0,Run circuit N times in Q#,"<p>I use dotnet run command to run my .qs quantum circuit. Is there a way to run my circuit N times, and get results of each run (like the shots parameter in Qiskit) ?</p>
<p>Thank you.</p>
",<programming><q#>,09/07/2020 10:00,13640.0,13640.0,"<p>Quantum programs in Q# can include classical logic as well as low-level quantum instructions, such that you can directly include the &quot;shot&quot; concept from circuits in your Q# programs by using a <code>for</code>-loop.</p>
<pre><code>@EntryPoint()
operation RunSeveralTimes(nTimes : Int) : Result[] {
    mutable results = new Result[nTimes];
    for (idx in 0..nTimes - 1) {
        set results w/= idx &lt;- DoSomething();
    }
    return results;
}
</code></pre>
<p>When running this program with <code>dotnet run</code>, you can now pass <code>--n-times</code> as a command-line argument to control how many times your <code>DoSomething()</code> operation gets called. Similarly, if you're using Q# in Jupyter Notebooks, you can use a command like <code>%simulate RunSeveralTimes nTimes=50</code>. From Python interoperability, you can pass <code>nTimes</code> as a keyword argument, e.g.: <code>RunSeveralTimes.simulate(nTimes=50)</code>.</p>
<p>The Q# standard libraries also offer several functions and operations to make this sort of loop easier to write:</p>
<ul>
<li><a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.characterization.estimatefrequency"" rel=""nofollow noreferrer""><code>EstimateFrequency</code></a> and <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.characterization.estimatefrequencya"" rel=""nofollow noreferrer""><code>EstimateFrequencyA</code></a>: run an operation many times, and collect the probability with which a measurement at the end returns <code>One</code>.</li>
<li><a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.arrays.drawmany"" rel=""nofollow noreferrer""><code>DrawMany</code></a>: run an operation many times with the same input, and collect all outputs.</li>
<li><a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.arrays.foreach"" rel=""nofollow noreferrer""><code>ForEach</code></a>: run an operation once for each of many inputs, and collect all outputs.</li>
</ul>
",09/08/2020 01:01,API Usage,"The user is asking about running a quantum circuit multiple times and obtaining the results of each run, which relates to the usage of the Q# API.",API Usage,,,,API Usage,
13634.0,How to split a Quantum Circuit on a barrier in Qiskit?,"<p>Let's say I have a <code>QuantumCircuit</code> with multiple <code>barrier</code>s as shown in the visual below:
<a href=""https://i.stack.imgur.com/LV5ss.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LV5ss.png"" alt=""Quantum Circuit with Multiple Barriers"" /></a></p>
<p>How would I split up the <code>QuantumCircuit</code> on the <code>barrier</code>s into a list of 3 <code>QuantumCircuit</code>s in <strong>Qiskit</strong>?</p>
<p>NB: Not directly relevant to the question, but the circuit is a random Unitary circuit, as I'm doing randomised-benchmarking. The circuit is generated as shown in the <a href=""https://qiskit.org/textbook/ch-quantum-hardware/randomized-benchmarking.html"" rel=""nofollow noreferrer"">Qiskit Textbook: 5.3 Randomized Benchmarking</a>.</p>
",<qiskit><programming><circuit-construction><random-quantum-circuit><randomised-benchmarking>,09/07/2020 18:00,13636.0,13636.0,"<p>For such a simple circuit, probably the easier way is to dump it as QASM and read it back.</p>
<pre><code>def split_circuit_by_barrier(circuit):
    qasm = circuit.qasm()
    prelude = []
    circuits = [[]]
    for line in qasm.splitlines():
        if any([line.startswith(t) for t in ['OPENQASM', 'include', 'qreg', 'creg']]):
            prelude.append(line)
        elif line.startswith('barrier'):
            circuits.append([])
        else:
            circuits[-1].append(line)
    circuits_with_prelude = [prelude+circuit for circuit in circuits]
    for circuit_with_prelude in circuits_with_prelude:
        yield QuantumCircuit.from_qasm_str('\n'.join(circuit_with_prelude))
</code></pre>
<p>Taking your example:</p>
<pre><code>for subcircuit in (split_circuit_by_barrier(circuit)):
    print(subcircuit)
</code></pre>
<pre><code>                             âââââ âââââ
   q_0: ââââââââââââââââââ ââââ¤ H âââ¤ S ââââââ
        ââââââââââââââââââ´ââââ´ââââ´ââââââ¤âââââ
   q_1: â¤ H ââ¤ H ââ¤ S ââ¤ X ââ¤ SDG ââ¤ H ââ¤ X â
        âââââââââââââââââââââââââââââââââââââ
meas: 2/âââââââââââââââââââââââââââââââââââââ

        ââââââââââââ
   q_0: â¤ SDG ââ¤ H âââââââââ âââââââââââââââââââ
        ââ¬ââââ¬ââââââ¤ââââââââ´âââââââââââââââââââ
   q_1: ââ¤ X âââ¤ H ââ¤ S ââ¤ X ââ¤ SDG ââ¤ H ââ¤ H â
         âââââ ââââââââââââââââââââââââââââââââ
meas: 2/âââââââââââââââââââââââââââââââââââââââ

        âââ
   q_0: â¤Mââââ
        ââ¥ââââ
   q_1: ââ«ââ¤Mâ
         â ââ¥â
meas: 2/ââ©âââ©â
         0  1
</code></pre>
",09/07/2020 19:29,API Usage ,"The user is asking how to split a QuantumCircuit into multiple QuantumCircuits at specific points (barriers), which involves using the Qiskit API for circuit manipulation.",API Usage,,,,API Usage ,
13637.0,Implement U2 and U3 gate in Q#,"<p>I know that U1 equivalent gate of Qiskit in Q# is R1, but I would like to implement U2 and U3 gate of Qiskit in Q#, what is the best way ?</p>
<p>Thank you.</p>
",<quantum-gate><programming><q#>,09/07/2020 20:06,13641.0,13641.0,"<p>The gates <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.rx"" rel=""nofollow noreferrer"">Rx</a>, <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.ry"" rel=""nofollow noreferrer"">Ry</a> and <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.rz"" rel=""nofollow noreferrer"">Rz</a> in Q# have the same definition as RXGate, RYGate and RZGate in Qiskit, and the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.U2Gate.html"" rel=""nofollow noreferrer"">U2Gate</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.U3Gate.html"" rel=""nofollow noreferrer"">U3Gate</a> documentation offers decomposition of these gates into Rx, Ry and Rz, so I would just use that decomposition:</p>
<pre><code>operation U2(psi : Double, lambda : Double, q : Qubit) : Unit is Adj + Ctl {
    Rz(lambda, q);
    Ry(0.5 * PI(), q);
    Rz(psi, q);
}
</code></pre>
<p>and a similar one for U3.</p>
",09/08/2020 02:11,API Usage,"The user is asking how to implement specific quantum gates (U2 and U3 gates from Qiskit) in Q#, which involves using the Q# API for quantum programming.",API Usage,,,,API Usage,
13651.0,How to remove last n layers of Quantum Circuit in Qiskit?,"<p>Let's say I have a <code>QuantumCircuit</code> with <code>depth</code> <span class=""math-container"">$d$</span> layers. How can I generate a new <code>QuantumCircuit</code> with the last <strong>n</strong> layers removed. For example, let's say the <code>QuantumCircuit</code> has <span class=""math-container"">$d=8$</span> layers as follows:</p>
<p><a href=""https://i.stack.imgur.com/ijwqy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ijwqy.png"" alt=""Quantum Circuit with Depth 8 Layers"" /></a></p>
<p>And let's say the last <strong>n=4</strong> layers are desired to be removed then the resulting <code>QuantumCircuit</code> should be as follows leaving only the first 4 layers of the above <code>QuantumCircuit</code>:</p>
<p><a href=""https://i.stack.imgur.com/Lt2dx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Lt2dx.png"" alt=""Removed Last 4 Layers from QC"" /></a></p>
<p>How can this be done in Qiskit?</p>
",<qiskit><programming><circuit-construction>,09/08/2020 12:42,13824.0,13824.0,"<p>Please notice that the previous answer may unnecessarily remove gates.
It depends on the order you insert them in your circuit.</p>
<p>For example, constructing the circuit you provided with the following code</p>
<pre><code>qc = QuantumCircuit(2)

qc.sdg(0)
qc.h(0)

qc.y(1)
qc.h(1)
qc.s(1)

qc.cx(0, 1)
qc.cx(1, 0)

qc.h(0)
qc.s(0)
qc.h(0)

qc.h(1)
qc.s(1)
qc.h(1)

print(qc)
---
     ââââââââââââ          ââââââââââââââââââââ
q_0: â¤ SDG ââ¤ H âââââââââ âââ¤ X ââ¤ H ââ¤ S ââ¤ H â
     ââ¬ââââ¬ââââââ¤ââââââââ´âââââ¬âââââââ¤âââââ¤âââââ¤
q_1: ââ¤ Y âââ¤ H ââ¤ S ââ¤ X ââââ âââ¤ H ââ¤ S ââ¤ H â
      âââââ âââââââââââââââ     âââââââââââââââ
</code></pre>
<p>and after removing the last 2 layers with your method we get</p>
<pre><code>     ââââââââââââ          ââââââââââ
q_0: â¤ SDG ââ¤ H âââââââââ âââ¤ X ââ¤ H â
     ââ¬ââââ¬ââââââ¤ââââââââ´âââââ¬âââââââ
q_1: ââ¤ Y âââ¤ H ââ¤ S ââ¤ X ââââ âââââââ
      âââââ âââââââââââââââ          
</code></pre>
<p>Notice how the last 3 gates acting on qubit 1 disappear although we should keep one extra Hadamard.</p>
<p>For a more robust solution, we should work with a representation of the circuit that captures the topological dependencies present, i.e <code>DAGCircuit</code>.</p>
<pre><code>from qiskit.converters import circuit_to_dag, dag_to_circuit

dag = circuit_to_dag(qc)
layers = list(dag.multigraph_layers())

n_remove = 2

# the extra minus 1 since the last layer consists of output nodes (qubits and clbits).
for layer in layers[- n_remove - 1:]:

    for node in layer:
        if node.type == 'op':
            dag.remove_op_node(node)
                   
new_qc = dag_to_circuit(dag)

print(new_qc)
---
     ââââââââââââ          ââââââââââ
q_0: â¤ SDG ââ¤ H âââââââââ âââ¤ X ââ¤ H â
     ââ¬ââââ¬ââââââ¤ââââââââ´âââââ¬âââââââ¤
q_1: ââ¤ Y âââ¤ H ââ¤ S ââ¤ X ââââ âââ¤ H â
      âââââ âââââââââââââââ     âââââ
</code></pre>
",9/19/2020 17:02, API Usage," The user is asking how to manipulate a QuantumCircuit object in Qiskit, specifically how to remove the last n layers from the circuit, which involves using the Qiskit API for circuit manipulation.",API Usage,,,, API Usage,
13652.0,How do I compute the fidelity on the IBM Q using qiskit without the statevector simulator?,"<p>I want to compare the fidelity of a circuit implemented on IBMQ Santiago with the ideal circuit simulated using the statevector backend. Is there a way to do this? So far I have only seen examples where both circuits involve the statevector backend.</p>
",<qiskit><programming><ibm-q-experience><fidelity>,09/08/2020 12:51,13660.0,13660.0,"<p>It is not possible to compare the statevector of a circuit run on the statevector_simulator and on a real device, like IBMQ Santiago, because the result of a job run on hardware is in the form of counts. You can see this by running the following command in qiskit:</p>
<pre><code>job.result().data(circuit)
</code></pre>
<p>for a specific circuit and job run on a real IBMQ device. The output you will get will be in the form of</p>
<pre><code>{'counts': {...}}
</code></pre>
<p>where {...} is a dictionary mapping states to counts for those states.</p>
<p>If you run the same command on a job run on the statevector simulator, you will get</p>
<pre><code>{'counts':{...}, 'statevector': array([...])}
</code></pre>
<p>where array([...]) is an array form of the resulting statevector, and the dictionary for counts maps that same statevector to a count of 1.</p>
<p><strong>However, you can compute the hellinger fidelity, which compares counts instead of state vectors. You can read more about it here: <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.hellinger_fidelity.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.hellinger_fidelity.html</a></strong></p>
",09/08/2020 19:26,API Usage,"The user is asking about how to compare the fidelity of a quantum circuit implemented on a real quantum device (IBMQ Santiago) with an ideal circuit simulated using the statevector backend. This question falls under the category of API usage in quantum programming, as it involves using the Qiskit API to perform the fidelity comparison between circuits run on different backends.",API Usage,,,,API Usage,
13662.0,Error while running Qiskit code on real quantum hardware,"<p>I started to learn Qiskit, so sorry if my question is very basic.  So far I used <code>qasm_simulator</code> or <code>state_vectorsimulator</code>, however, now I would like to run my circuit on real IBM Q processor.</p>
<p>Here is my code, I wanted to execute:</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries and configuring account
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *

provider = IBMQ.load_account()
backend = provider.backends(name='ibmq_ourense')

q = QuantumRegister(5, name = 'q')
c = ClassicalRegister(2,name = 'c')

circuit = QuantumCircuit(q,c)
circuit.h(q[0])
circuit.cx(q[0],q[1])
circuit.measure(q[0],c[0])
circuit.measure(q[1],c[1])

job = execute(circuit, backend, shots = 1024)
counts = job.result().get_counts()
plot_histogram(counts)
</code></pre>
<p>However, this error was shown:</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-26-b48ae13f56aa&gt; in &lt;module&gt;
     11 circuit.measure(q[1],c[1])
     12 
---&gt; 13 job = execute(circuit, backend, shots = 1024)
     14 counts = job.result().get_couns()
     15 plot_histogram(counts)

/opt/conda/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config)
    258                                 seed_transpiler=seed_transpiler,
    259                                 optimization_level=optimization_level,
--&gt; 260                                 backend=backend)
    261 
    262     if schedule_circuit:

/opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, seed_transpiler, optimization_level, pass_manager, callback, output_name)
    211                                            callback, output_name)
    212 
--&gt; 213     _check_circuits_coupling_map(circuits, transpile_args, backend)
    214 
    215     # Transpile circuits in parallel

/opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend)
    244 
    245         # If coupling_map is None, the limit might be in the backend (like in 1Q devices)
--&gt; 246         elif backend is not None and not backend.configuration().simulator:
    247             max_qubits = backend.configuration().n_qubits
    248 

AttributeError: 'list' object has no attribute 'configuration'
</code></pre>
<p>I think that the problem is hidden in getting backends or <code>execute</code> command.</p>
<p><em>Note: I run my code in Quantum Lab on IBM Q website interface.</em></p>
<p><strong>Could any please help me how to change my code to run it on real IBM Q processor?</strong></p>
",<qiskit><programming><ibm-q-experience>,09/09/2020 11:08,13663.0,13663.0,"<p>Looks like <code>backend = provider.backends(name='ibmq_ourense')</code> returns a list of backends whose name is <code>ibmq_oursense</code> (a list whose length is obviously 1). Try <code>backend = provider.backends(name='ibmq_ourense')[0]</code>.</p>
",09/09/2020 11:18,Errors ,The user is seeking a solution for an error they encountered while trying to run their quantum circuit on a real IBM Q processor using Qiskit. ,Errors,,,,Errors ,
13667.0,Qiskit: Get gates from circuit object,"<p>Is there a way in Qiskit to take a circuit object and return a list of tuples where each tuple consists of a gate and the qubit(s) they act on? The list obeys some partial order since the gate order cannot be swapped unless they commute.</p>
",<quantum-gate><qiskit><programming>,09/09/2020 18:36,13668.0,13668.0,"<p>You can inspect the QuantumCircuit.data structure:</p>
<p><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html</a></p>
<p>For example, here is a loop that prints the name, qubits and any other parameters for all the gates in a circuit.</p>
<pre><code>for gate in qc.data:
    print('\ngate name:', gate[0].name)
    print('qubit(s) acted on:', gate[1])
    print('other paramters (such as angles):', gate[0].params)
</code></pre>
",09/09/2020 18:51,API Usage,"The user is asking how to programmatically extract information from a Qiskit quantum circuit object, specifically, how to obtain a list of tuples containing gates and the qubits they act on. This falls under the category of API usage because it involves interacting with the Qiskit API to retrieve circuit information.",API Usage,,,,API Usage,
13677.0,Qiskit: Add a standard gate to circuit from a string,"<p>Given a circuit, if one wishes to add a gate, it is done through a line like the one below</p>
<pre><code>mycircuit.cx(0, 1)
</code></pre>
<p>Here, we have added a control-X gate on the 0 and 1 qubits. This is probably a Python question but how can one do this given the string <code>'cx'</code> and integers <code>0</code> and <code>1</code> i.e. without manually typing them?</p>
<p>I tried using <a href=""https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string"">https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string</a> but getattr did not work for me.</p>
<pre><code>from qiskit import QuantumCircuit
circ = QuantumCircuit(2)
circ.draw()
a = ('cx', 0, 1)
circ = getattr(circ, a[0])(a[1], a[2])
circ.draw()
</code></pre>
",<qiskit><programming>,09/10/2020 17:15,13678.0,13678.0,"<p>You are getting <code>AttributeError: 'InstructionSet' object has no attribute 'draw'</code> because <code>getattr</code> doesn't return a <code>QuantumCircuit</code>. It returns an <code>InstructionSet</code>, which doesn't have a <code>draw()</code> method.</p>
<pre><code>from qiskit import QuantumCircuit
circuit = QuantumCircuit(2)
print(type(circuit)) # prints &lt;class 'qiskit.circuit.quantumcircuit.QuantumCircuit'&gt;
circuit.draw()
a = ('cx', 0, 1)
circuit = getattr(circuit, a[0])(a[1], a[2])
print(type(circuit)) # prints &lt;class 'qiskit.circuit.instructionset.InstructionSet'&gt;

</code></pre>
<p>Removing the assignment of <code>circuit</code> to what is returned from <code>getatrr</code> should get rid of the error.</p>
<pre><code>from qiskit import QuantumCircuit
circuit = QuantumCircuit(2)
circuit.draw()
a = ('cx', 0, 1)
getattr(circuit, a[0])(a[1], a[2])
circuit.draw()
</code></pre>
",09/10/2020 18:51,API Usage,The user question is about how to use the Qiskit API to add a gate to a quantum circuit using a string representation of the gate and the qubits it acts on.,Errors,"The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are trying to add a gate to a quantum circuit using a string and integers, but are encountering issues with the getattr function.",No,95.0,API Usage,"The user is asking specifically about how to use the Qiskit API to add gates to a quantum circuit using a string representation of the gate and qubit indices, indicating a need for understanding the API functionality for circuit manipulation."
13681.0,How to execute many circuits on an IBMQ backend?,"<p>I attempted to <code>execute</code> a list of <span class=""math-container"">$3200$</span> <code>QuantumCircuit</code>s in Qiskit, each with the <code>max_shots</code> of <span class=""math-container"">$8096$</span> as follows:</p>
<pre><code>ibmq_manhattan = provider.get_backend('ibmq_manhattan')
job = execute(all_qc, backend=ibmq_manhattan, shots=8096)
job_monitor(job)
</code></pre>
<p>and got the following response:</p>
<blockquote>
<p>Job Status: job has been cancelled</p>
</blockquote>
<p>Furthermore, I successfully performed the exact same execution locally using the Aer <code>qasm_simulator</code>. Presumably this is because there is a runtime timeout on the IBMQ backend device which is triggered as one might expect for such a large list. Is this correct? and if so how can I bypass this limitation?</p>
<p>This is a summary of the job on IBMQ:
<a href=""https://i.stack.imgur.com/jSdXz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jSdXz.png"" alt=""job summary on IBMQ"" /></a></p>
",<qiskit><programming><ibm-q-experience>,09/10/2020 20:47,13683.0,13683.0,"<p>If you have more circuits than what the backend allows, consider using <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.html#qiskit.providers.ibmq.managed.IBMQJobManager"" rel=""nofollow noreferrer"">IBMQJobManager</a>, which will divide the circuits and collect results for you.</p>
",09/10/2020 21:54,Errors ,The user is seeking a solution for an error they encountered while trying to execute a large list of QuantumCircuits on the IBMQ backend. , Errors,,,,Errors ,
13701.0,What is the connection between $RX$ gates and $X$ gates (similar for $Y$ and $Z$)?,"<p>I am new to quantum gates but do not understand the connection between the <span class=""math-container"">$RX$</span> and <span class=""math-container"">$X$</span> gates. I know that</p>
<p><span class=""math-container"">$$R X(\theta)=\exp \left(-i \frac{\theta}{2} X\right)=\left(\begin{array}{cc}
\cos \frac{\theta}{2} &amp; -i \sin \frac{\theta}{2} \\
-i \sin \frac{\theta}{2} &amp; \cos \frac{\theta}{2}
\end{array}\right)$$</span></p>
<p>Meanwhile the <span class=""math-container"">$X$</span> gate is given by</p>
<p><span class=""math-container"">$$X = \left(\begin{array}{cc}
0 &amp; 1 \\
1 &amp; 0
\end{array}\right)$$</span></p>
<p>Is there a value of <span class=""math-container"">$\theta$</span> such that the two are the same? I see that choosing <span class=""math-container"">$\theta = \pi/2$</span> gives the result upto an overall factor of <span class=""math-container"">$-i$</span>. Is that it or is there a deeper connection between the two gates? Is there a similar connection between the <span class=""math-container"">$Y$</span> and <span class=""math-container"">$RY$</span> gates and the <span class=""math-container"">$Z$</span> and <span class=""math-container"">$RZ$</span> gates such that the rotated gates are more general than the <span class=""math-container"">$X, Y$</span> and <span class=""math-container"">$Z$</span> gates?</p>
",<quantum-gate><programming>,09/11/2020 15:14,13703.0,13703.0,"<p>You're almost correct - choosing <span class=""math-container"">$ \theta = \pi$</span> does yield <span class=""math-container"">$$ \begin{bmatrix} 0 &amp; -i \\ -i &amp; 0 \end{bmatrix} $$</span></p>
<p>Because this differs from the <span class=""math-container"">$X$</span> gate by a constant factor global phase (<span class=""math-container"">$ -i$</span>), the gates are equivalent. (See <a href=""https://quantumcomputing.stackexchange.com/questions/12448/understanding-global-phase"">here</a> to learn more about the global phase).</p>
<p>This connection holds similarly for <span class=""math-container"">$ RY$</span> and <span class=""math-container"">$Y$</span>, and <span class=""math-container"">$RZ$</span> and <span class=""math-container"">$Z$</span>. A way to visualize this is the Bloch sphere: in essence, these gates are rotations about the <span class=""math-container"">$X, Y, Z$</span> axes (respectively):</p>
<p><a href=""https://i.stack.imgur.com/DjkNh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DjkNh.png"" alt=""Bloch sphere"" /></a></p>
<p>So essentially our Pauli primitives are <span class=""math-container"">$\pi$</span> rotations over the respective axis.</p>
",09/11/2020 16:19,Theoretical," The user question is about the theoretical concepts and principles in quantum computing, specifically the connection between RX and X gates, and similarly for Y, RY, Z, and RZ gates.",Theoretical,,,,Theoretical,
13705.0,Qiskit job not giving the right result after execution,"<p>Here is my code</p>
<pre><code>import numpy as np
import qiskit
from qiskit import *


number_of_qubits = 3
backend_sim = Aer.get_backend('qasm_simulator')

#Generate a circuit in qiskit
input_circuit = QuantumCircuit(number_of_qubits, number_of_qubits)
input_circuit.x(0)
input_circuit.h(1)
input_circuit.cx(0,1)
input_circuit.i(1) 
input_circuit.x(1)

job_sim = execute(input_circuit, backend_sim, shots=1024)
result_sim = job_sim.result()
counts = result_sim.get_counts(input_circuit)
print(counts)
</code></pre>
<p>No matter what gates I try (e.g. I can remove the last X gate), the result is always <code>'000': 1024</code>. What am I doing wrong?</p>
",<qiskit><programming>,09/11/2020 19:00,13706.0,13706.0,"<p>Your current circuit looks like this:</p>
<p><a href=""https://i.stack.imgur.com/NquYB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NquYB.png"" alt=""example circuit without measurements"" /></a></p>
<p>In order to get the &quot;counts&quot;, you need to measure at the end of the circuit, before <code>execute</code>.</p>
<pre><code>input_circuit.measure(range(number_of_qubits), range(number_of_qubits))
</code></pre>
<p><a href=""https://i.stack.imgur.com/q3FNb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q3FNb.png"" alt=""Example circuit with measurements"" /></a></p>
",09/11/2020 19:16, Errors ,The user is seeking a solution for an unexpected output they encountered while running their quantum circuit in Qiskit. ,Errors,,,, Errors ,
13707.0,How many shots are executed when using the IBMQJobManager?,"<p>When using qiskit <a href=""https://qiskit.org/documentation/apidoc/execute.html"" rel=""nofollow noreferrer""><code>execute</code></a> it is possible to stipulate the number of <code>shots</code> for each experiment/<code>QuantumCircuit</code>, however when using <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.html"" rel=""nofollow noreferrer""><code>IBMJobManager</code></a> this is seemingly not possible.</p>
<p>Is this correct and if so how many <code>shots</code> are executed by default? and if not how can the number of <code>shots</code> be specified?</p>
",<qiskit><programming>,09/11/2020 20:26,13709.0,13709.0,"<p>You can specify <code>IBMQJobManager.run(shots=my_shots)</code>. See <code>run_config</code> in <code>IBMQJobManager.run()</code> documentation: <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.run.html#qiskit.providers.ibmq.managed.IBMQJobManager.run"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.run.html#qiskit.providers.ibmq.managed.IBMQJobManager.run</a></p>
<p>The default is 1024 or the maximum allowed by the backend, whichever is smaller.</p>
",09/11/2020 21:31,API Usage,"The user question is about how to use the Qiskit API to specify the number of shots when using the IBMJobManager, which involves understanding and correctly using the Qiskit API.",API Usage,,,,API Usage,
13711.0,Is the combine_results method deprecated in qiskit v0.20.0,"<p>According to the <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.ManagedResults.html"" rel=""nofollow noreferrer"">ManagedResults Documentation</a> the class has a <code>combine_results</code> method, however when attempting to use it as follows:</p>
<pre><code>job_set = IBMQJobManager().run(circs, backend=ibmq_backend, name='job-set-abc')
job_results = job_set.results()
job_results_combined = job_results.combine_results() # fails on this line
job_counts_combined = job_results_combined.get_counts()
</code></pre>
<p>I get the following error:</p>
<blockquote>
<p>AttributeError: 'ManagedResults' object has no attribute 'combine_results'</p>
</blockquote>
<p>Furthermore, the <code>combine_results</code> method is not listed under <code>help(type(job_results))</code>:</p>
<p>Does this mean that the method has been deprecated? If so how can I overcome this?</p>
",<qiskit><programming>,09/11/2020 21:50,13712.0,13712.0,"<p>It's still there. See the source code: <a href=""https://github.com/Qiskit/qiskit-ibmq-provider/blob/stable/0.8/qiskit/providers/ibmq/managed/managedresults.py#L178"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-ibmq-provider/blob/stable/0.8/qiskit/providers/ibmq/managed/managedresults.py#L178</a></p>
<p>Are you using the right version of <code>qiskit-ibmq-provider</code>? <code>combine_results</code> was introduced in 0.8.</p>
<p>If you do</p>
<pre><code>import qiskit
print(qiskit.__qiskit_version__)
</code></pre>
<p>it'll show you the version of each element.</p>
",09/11/2020 23:01,Errors,The user is seeking a solution for an error they encountered while trying to use the combine_results method of the ManagedResults class in Qiskit, Errors,,,,Errors,
13720.0,Is there a way to generate random circuits in qiskit with only certain allowed gates?,"<p>It seems like I can use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.random.random_circuit.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.random.random_circuit.html</a> but I would like to control the gates that are allowed.</p>
<p>What is an efficient way to make random circuits with a fixed set of gates?</p>
",<qiskit><programming><circuit-construction>,09/12/2020 17:39,13721.0,13721.0,"<p>I think you should <a href=""https://github.com/Qiskit/qiskit-terra/issues/new/choose"" rel=""nofollow noreferrer"">report of &quot;feature request&quot; issue</a> if you have a good use case for this. It should not be hard to implement and I could help with it.</p>
<p>If by any chance your fixed set of gates is based on the amount of qubits involved in gate, you can control that with <code>max_operands</code>. For example, you can  exclude <code>CCXGate</code> and <code>CSwapGate</code> (3-qubit operands) with <code>max_operand=2</code>.</p>
<p>If this is not the case, <a href=""https://github.com/Qiskit/qiskit-terra/blob/7bc7f08bf64aa686694467e8f8be551e0b740213/qiskit/circuit/random/utils.py#L30"" rel=""nofollow noreferrer"">the source code for <code>random_circuit</code></a> seems straightforward to modify for your need. You can remove or add the gates from <code>*_q_ops</code> and <code>*_param</code> variables on top.</p>
<pre><code>def random_circuit(num_qubits, depth, max_operands=3, measure=False,
                   conditional=False, reset=False, seed=None):
    
    if max_operands &lt; 1 or max_operands &gt; 3:
        raise CircuitError(&quot;max_operands must be between 1 and 3&quot;)

    one_q_ops = [IGate, U1Gate, U2Gate, U3Gate, XGate, YGate, ZGate,
                 HGate, SGate, SdgGate, TGate, TdgGate, RXGate, RYGate, RZGate]
    one_param = [U1Gate, RXGate, RYGate, RZGate, RZZGate, CU1Gate, CRZGate]
    two_param = [U2Gate]
    three_param = [U3Gate, CU3Gate]
    two_q_ops = [CXGate, CYGate, CZGate, CHGate, CRZGate,
                 CU1Gate, CU3Gate, SwapGate, RZZGate]
    three_q_ops = [CCXGate, CSwapGate]

    qr = QuantumRegister(num_qubits, 'q')
    qc = QuantumCircuit(num_qubits)

    if measure or conditional:
        cr = ClassicalRegister(num_qubits, 'c')
        qc.add_register(cr)

    if reset:
        one_q_ops += [Reset]

    if seed is None:
        seed = np.random.randint(0, np.iinfo(np.int32).max)
    rng = np.random.default_rng(seed)

    # apply arbitrary random operations at every depth
    for _ in range(depth):
        # choose either 1, 2, or 3 qubits for the operation
        remaining_qubits = list(range(num_qubits))
        while remaining_qubits:
            max_possible_operands = min(len(remaining_qubits), max_operands)
            num_operands = rng.choice(range(max_possible_operands)) + 1
            rng.shuffle(remaining_qubits)
            operands = remaining_qubits[:num_operands]
            remaining_qubits = [q for q in remaining_qubits if q not in operands]
            if num_operands == 1:
                operation = rng.choice(one_q_ops)
            elif num_operands == 2:
                operation = rng.choice(two_q_ops)
            elif num_operands == 3:
                operation = rng.choice(three_q_ops)
            if operation in one_param:
                num_angles = 1
            elif operation in two_param:
                num_angles = 2
            elif operation in three_param:
                num_angles = 3
            else:
                num_angles = 0
            angles = [rng.uniform(0, 2 * np.pi) for x in range(num_angles)]
            register_operands = [qr[i] for i in operands]
            op = operation(*angles)

            # with some low probability, condition on classical bit values
            if conditional and rng.choice(range(10)) == 0:
                value = rng.integers(0, np.power(2, num_qubits))
                op.condition = (cr, value)

            qc.append(op, register_operands)

    if measure:
        qc.measure(qr, cr)

    return qc
</code></pre>
",09/12/2020 18:09,API Usage,"The user question is about how to use the Qiskit API to generate random circuits with a fixed set of gates, which involves understanding and correctly using the Qiskit API. ",API Usage,,,,API Usage,
13723.0,Test equivalence of circuits exactly on qiskit,"<p>I have two circuits that I believe are equivalent. When I say 'equivalent' I mean that they have equivalent unitary representations up to a global phase. How can one check this using Qiskit? How I would show equivalence isn't clear to me.</p>
",<qiskit><programming><circuit-construction>,09/12/2020 20:33,13724.0,13724.0,"<p>As <a href=""https://quantumcomputing.stackexchange.com/questions/13723/test-equivalence-of-circuits-exactly-on-qiskit/13724?noredirect=1#comment18445_13724"">it is point out</a>, depends on your notion of equivalence.</p>
<h2>State vectors</h2>
<p>Two circuits are equivalent upto global phase if they represent the same state vector. Consider the following two circuits:</p>
<pre><code>from qiskit import QuantumCircuit
import numpy as np

qc1 = QuantumCircuit(2)
qc1.h(0)
qc1.cx(0,1)

qc2 = QuantumCircuit(2)
qc2.u2(0, np.pi, 0)
qc2.cx(0,1)
</code></pre>
<p>It is possible to check if their state vector is the same with the Qiskit <code>qiskit.quantum_info</code> module:</p>
<pre><code>from qiskit.quantum_info import Statevector
Statevector.from_instruction(qc1).equiv(Statevector.from_instruction(qc2)) # True
</code></pre>
<h2>Unitary matrices</h2>
<p>If you need to consider global phase, in that case you need to compare their unitary matrices via simulation.</p>
<p>In the following case:</p>
<pre><code>qc1 = QuantumCircuit(1)
qc1.x(0)

qc2 = QuantumCircuit(1)
qc2.rx(np.pi, 0)
</code></pre>
<p>These circuit has the same state vector, but not the same unitary:</p>
<pre><code>Statevector.from_instruction(qc1).equiv(Statevector.from_instruction(qc2))  # True

backend_sim = Aer.get_backend('unitary_simulator')
job_sim = execute([qc1, qc2], backend_sim)
result_sim = job_sim.result()
unitary1 = result_sim.get_unitary(qc1)
unitary2 = result_sim.get_unitary(qc2)

np.allclose(unitary1, unitary2)  # False

</code></pre>
<h2>Counts</h2>
<p>If your circuits have measurements, you probably want to consider these to circuits equivalent, since their measured results are equivalent.</p>
<pre><code>qc1 = QuantumCircuit(2,2)
qc1.h(0)
qc1.measure(0,0)
qc1.measure(1,1)

qc2 = QuantumCircuit(2,2)
qc2.h(0)
qc2.swap(0,1)
qc2.measure(0,1)
qc2.measure(1,0)
</code></pre>
<p>In this case, you want to compare their result counts, considering some statistical error:</p>
<pre><code>backend_sim = Aer.get_backend('qasm_simulator')
job_sim = execute([qc1, qc2], backend_sim, shots=1000)
result_sim = job_sim.result()
counts1 = result_sim.get_counts(qc1)
counts2 = result_sim.get_counts(qc2)
print(counts1, counts2)
</code></pre>
<h2>Up to Ancillas</h2>
<p>You might want to consider these two circuits equivalent:</p>
<pre><code>qc1 = QuantumCircuit(3)
qc1.x(0)

qc2 = QuantumCircuit(1)
qc2.rx(np.pi, 0)
</code></pre>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/13723/test-equivalence-of-circuits-exactly-on-qiskit/13724?noredirect=1#comment18456_13724"">It was suggested</a> to invert one of them, compose them (wiring the ancillas) and check if it is the identity. For example:</p>
<pre><code>from qiskit.quantum_info import Operator

composed = qc1.compose(qc2.inverse(), qubits=range(len(qc2.qubits)))
Operator(composed).equiv(Operator.from_label('I'*len(qc1.qubits))) # True
</code></pre>
",09/12/2020 21:53,API Usage ,The user question is about how to use the Qiskit API to check if two quantum circuits are equivalent in terms of their unitary representations.,API Usage,,,,API Usage ,
13725.0,How to code a projector operator in qiskit?,"<p>I'm new to qiskit and I want to know how do I define a projector operator in qiskit? Specifically, I have prepared a 3 qubit system, and after applying a whole lot of gates and measuring it in a state vector simulator, I have to apply the projector operator <span class=""math-container"">$|0\rangle_{1}|0\rangle_{2} \langle0|_{1}\langle0|_{2}$</span> on the state that I get after I measured all the qubits in the circuit. I do know the physics and math behind it, and the tensor product it represents but I'm unable to code this successfully. I was thinking maybe a 4x4 matrix representation of this operator might help but I'm not sure about it.</p>
<p>So I'm asking 2 questions here-</p>
<ol>
<li>How do I define a projector operator like this in qiskit</li>
<li>How do I apply that operator to a state that I have measured with a state vector simulator?</li>
</ol>
<p>Thanks in advance</p>
",<qiskit><programming><quantum-operation><gate-synthesis><projection-operator>,09/12/2020 23:29,13797.0,13797.0,"<p>So, there actually is a method called to_operator() for the class Statevector which takes a statevector and converts it into a projector operator. Here is the code to write your specific projector operator:</p>
<pre><code>from qiskit.quantum_info import Statevector
zero = Statevector([1,0])
zero_state = zero.tensor(zero) # or zero_state = Statevector([1,0,0,0])
projector = zero_state.to_operator()
</code></pre>
<p>As you can see, you can input a state as a python list, or as a numpy array. If you print this projector, you will get the following output:<a href=""https://i.stack.imgur.com/t9D5n.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t9D5n.png"" alt=""What a projector operator looks like."" /></a></p>
<p>Then, after making your operator, you can use the method evolve() to apply the projector operator on a statevector:</p>
<pre><code>statevector.evolve(projector)
</code></pre>
",9/17/2020 19:19,Conceptual,"The question primarily seeks to understand the conceptual aspect of defining and applying a projector operator in quantum programming using Qiskit, focusing on the underlying concepts and methods. While it does involve API usage, the core of the question is about grasping the concept, making it a better fit for the ""Conceptual"" category.", Conceptual,,,,Conceptual,
13769.0,How to get state vector from QasmSimulator in Qiskit,"<p>I'm currently able to get state vector in Qiskit using state_vector backend using something like :</p>
<pre><code>backend = Aer.get_backend('statevector_simulator')
job = execute(qc, backend=backend, shots=1, memory=True)
job_result = job.result()
print(job_result.get_statevector(qc))
</code></pre>
<p>But now I would like to get state vector using qasm_backend, I have seen in the Qiskit doc this sample code :</p>
<pre><code>backend = QasmSimulator()
backend_options = {&quot;method&quot;: &quot;statevector&quot;}

# Circuit execution
job = execute(qc, backend, backend_options=backend_options)
</code></pre>
<p>So I tried this backend implementation then trying to get state vector with :</p>
<pre><code>job_result = job.result()
print(job_result.get_statevector(qc))
</code></pre>
<p>But it still gives me an error saying that get_statevector is not available, what is the right way to do that ?</p>
<p>Thank you.</p>
",<qiskit><programming>,9/16/2020 12:16,13770.0,13770.0,"<p>If you're using the <code>QasmSimulator</code> class from Aer it does not generate a state vector result. The <code>statevector</code> method you passed in as a backend option is the simulation method/technique that Aer will use for simulating the circuit, but it is still the QASM simulator which is expected to return measurement counts not a statevector. You can see a description of the different simulation methods in the <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.QasmSimulator.html#qiskit.providers.aer.QasmSimulator"" rel=""nofollow noreferrer""><code>QasmSimulator</code> Docs</a>.</p>
<p>When you were calling <code>Aer.get_backend('statevector_simulator')</code> that returns a <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.StatevectorSimulator.html#qiskit.providers.aer.StatevectorSimulator"" rel=""nofollow noreferrer""><code>StateVectorSimulator</code></a> backend object which will simulate the circuit and return the state vector at the end of the execution and return that in the result, which is why <code>get_statevector</code> works there. If you want to get the state vector while using the <code>QasmSimulator</code> you can use the <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.extensions.SnapshotStatevector.html#qiskit.providers.aer.extensions.SnapshotStatevector"" rel=""nofollow noreferrer""><code>SnapshotStatevector</code></a> instruction in your circuit which will return the state vector at that point in the circuit. Although, if you do this the state vector won't be returned by <code>get_statevector</code> (that will still fail) it will be in the snapshots under <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.html?highlight=result%20result%20data#qiskit.result.Result.data"" rel=""nofollow noreferrer""><code>Result.data</code></a>.</p>
",9/16/2020 12:58,Errors ," The user is encountering an error while trying to obtain a state vector using the Qiskit QasmSimulator backend. They are seeking a solution to this error, which falls under the ""Errors"" category.",Errors,,,,Errors ,
13774.0,My IBMQ job hangs forever?,"<p>I am running a very simple script just to learn how to use IBMQ, but my job will hang indefinitely and I am forced to terminate it.</p>
<pre><code>from qiskit import *
from qiskit.compiler import transpile, assemble
from qiskit import IBMQ
from qiskit import QuantumCircuit, execute, BasicAer
import logging


logging.basicConfig(filename='log',level=logging.DEBUG)

IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')

#SELECT A BACKEND
backend = provider.get_backend('ibmq_qasm_simulator')

#ALGO
qr = QuantumRegister(3)
cr = ClassicalRegister(3)
circuit = QuantumCircuit(qr, cr)
circuit.x(qr[0])
circuit.x(qr[1])
circuit.ccx(qr[0], qr[1], qr[2])
circuit.cx(qr[0], qr[1])
circuit.measure(qr, cr)

print('About to run job')   
job = execute(circuit, backend)
print('Job Finished')
result = job.result()
counts = result.get_counts(circuit)
print(counts)
</code></pre>
<p>In an attempt to debug, I am using &quot;logging.basicConfig&quot; which stops at:</p>
<pre><code>&quot;websocket._connect:DEBUG:2020-09-16 11:26:57,813: Starting new websocket connection: wss://wss.quantum-computing.ibm.com/jobs/5f6258f09234fe0012dbd748/status/v/1&quot;
</code></pre>
<p>When I go to my IBMQ home page it says that the job has run successfully. It is only at the line <code>result = job.result()</code> that it fails.</p>
<p>So it seems that the websocket is hanging forever. I'd appreciate any help I can get to fix this issue.</p>
",<qiskit><programming><ibm-q-experience>,9/16/2020 18:39,13775.0,13775.0,"<p>The function <code>execute</code> is non-blocking. That means that it will return after sending the job, but not necessarily with the result. In your code, you should wait for the status of the job to be <code>DONE</code>:</p>
<pre><code>print('About to run job')   
job = execute(circuit, backend)
job.status()
</code></pre>
<pre><code>JobStatus.QUEUED
</code></pre>
<p>After waiting some time:</p>
<pre><code>job.status()
</code></pre>
<pre><code>JobStatus.DONE
</code></pre>
<p>Then, <code>job.result()</code> will work.</p>
",9/16/2020 18:53, Errors,"The user is encountering an error where their job using IBMQ hangs indefinitely when trying to retrieve the results. They are seeking help to fix this issue, which falls under the ""Errors"" category.",Errors,,,, Errors,
13781.0,Implementing Partial Trace in IBMs quantum computer,"<p>I am trying to implement the partial trace operation on IBMs quantum computer. I am simulating the depolarising channel with the following code</p>
<pre><code>#aim here is to build the decoherence channel
p=0.1;
z=0.5+0.5*math.sqrt(1-p);
desiredvec=[
    math.sqrt(1-z),
    math.sqrt(z)]
circuit2 = QuantumCircuit(4,3);
circuit2.initialize(desiredvec,0)
circuit2.initialize(desiredvec,1)
circuit2.initialize(desiredvec,2)
circuit2.cx(0,3)
circuit2.h(3)
circuit2.s(3)
circuit2.cx(1,3)
circuit2.h(3)
circuit2.s(3)
circuit2.cx(2,3)
circuit2.h(3)
circuit2.s(3)
circuit2.draw()
</code></pre>
<p>I would now like to trace out all but qubit 3 as it is the only qubit I am interested in. I can get around this by just ignoring the other qubits but I would rather not do this. Is there any easy way to trace out unwanted qubits?</p>
<p>Or equivalently is there a way to initalise the qubit in a mixed state so that the extra ancillary qubits aren't needed in the first place?</p>
",<programming><decoherence><partial-trace>,9/17/2020 6:39,13786.0,13786.0,"<p><code>qiskit.quantum_info</code> has a <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.partial_trace.html"" rel=""nofollow noreferrer"">partial_trace</a> method you can use for this.</p>
<p>It takes as input either a <code>Statevector</code> or a <code>DensityMatrix</code> object. Both these classes implement the <code>from_instruction</code> routine that you can use with the <code>QuantumCircuit</code> object you already have. You would have to do something along the lines of:</p>
<pre><code>circuit2 = QuantumCircuit(4,3)

...
# your operations
...

statevec = Statevector.from_instruction(circuit2)
trace = partial_trace(statevec, 3)
</code></pre>
<p>Hope this helps!</p>
",9/17/2020 11:21,API Usage,"The user question is about how to use the Qiskit API to implement the partial trace operation and initialize a qubit in a mixed state, which involves understanding and correctly using the Qiskit API.",API Usage ,,,,API Usage,
13787.0,Quadratic optimization in Qiskit: Error when QuadraticProgram with quadratic constraint converted to QUBO,"<p>I prepared a quadratic optimization task with binary and integer variables and linear and quadratic constraints. I fed it into <code>QuadraticProgram</code> in Qiskit. After that, I tried to convert the program to binary optimization task with constraints in form of equality only. I used <code>InequalityToEquality</code> and <code>IntegerToBinary</code> converters to do this. However, an error was returned. After some trial and error, I realized that the problem is caused by the quadratic constraint, so I removed it and everything is fine.</p>
<p><strong>My questions are:</strong></p>
<ol>
<li>Is the problem really in the quadratic constraint? Or in other words, are such constraints forbidden when I want to use converters?</li>
<li>If so, is there any other way how to convert <code>QuadraticProgram</code> to QUBO in Qiskit?
<em>(note that <code>QuadraticProgramToQubo</code> also does not work since <code>IntegerToBinary</code> is part of it)</em></li>
</ol>
<p>Here is my code:</p>
<pre><code>%matplotlib inline
from qiskit.optimization import QuadraticProgram
from qiskit.optimization.converters import InequalityToEquality, IntegerToBinary, QuadraticProgramToQubo

#create empty optimization task (model)
mod = QuadraticProgram('Quadratic optimization problem') #string in brackets - user defined name of the task

#adding variables
mod.binary_var(name = 'x') #bin
mod.integer_var(name = 'y', lowerbound = 0, upperbound = 5) 
mod.integer_var(name = 'z', lowerbound = 0, upperbound = 5) 
#setting objective function
mod.minimize(constant = 3, linear = [1,0,1], quadratic = [[1, 0, 2],[0,1,0],[2,0,1]])
#adding constraints
mod.linear_constraint(linear = {'x': 1, 'y': 1, 'z':1}, sense = '==', rhs = 1, name = 'L1')
mod.linear_constraint(linear = {'x': -1, 'y': -1, 'z':2}, sense = '&gt;=', rhs = 0, name = 'L2')
mod.linear_constraint(linear = {'x': 10, 'y': 20, 'z':30}, sense = '&lt;=', rhs = 100, name = 'L3')

#PROBLEMATIC QUADRATIC CONSTAINT
mod.quadratic_constraint(linear = {'x':1, 'y':1}, quadratic = {('x','y'):1, ('x','z'):-1}, sense = '&lt;=', rhs = 2, name = 'Q1')

modConverted = InequalityToEquality().convert(mod)
modConverted = IntegerToBinary().convert(modConverted)
print(modConverted.export_as_lp_string())
</code></pre>
<p>And here is the returned error:</p>
<pre><code>---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-13-f345029f5fa8&gt; in &lt;module&gt;
     20 
     21 modConverted = InequalityToEquality().convert(mod)
---&gt; 22 modConverted = IntegerToBinary().convert(modConverted)
     23 print(modConverted.export_as_lp_string())

/opt/conda/lib/python3.7/site-packages/qiskit/optimization/converters/integer_to_binary.py in convert(self, problem)
     96                         )
     97 
---&gt; 98             self._substitute_int_var()
     99 
    100         else:

/opt/conda/lib/python3.7/site-packages/qiskit/optimization/converters/integer_to_binary.py in _substitute_int_var(self)
    199             )
    200             quadratic, q_linear, q_constant = self._convert_quadratic_coefficients_dict(
--&gt; 201                 constraint.quadratic.to_dict()
    202             )
    203 

/opt/conda/lib/python3.7/site-packages/qiskit/optimization/converters/integer_to_binary.py in _convert_quadratic_coefficients_dict(self, coefficients)
    137         quadratic = {}
    138         for (name_i, name_j), v in coefficients.items():
--&gt; 139             x = self._src.get_variable(name_i)
    140             y = self._src.get_variable(name_j)
    141 

/opt/conda/lib/python3.7/site-packages/qiskit/optimization/problems/quadratic_program.py in get_variable(self, i)
    243             return self.variables[i]
    244         else:
--&gt; 245             return self.variables[self._variables_index[i]]
    246 
    247     def get_num_vars(self, vartype: Optional[VarType] = None) -&gt; int:

KeyError: 0
<span class=""math-container"">```</span>
</code></pre>
",<qiskit><programming><ibm-q-experience><optimization>,9/17/2020 12:26,13791.0,13791.0,"<p>Thank you for your report.
I investigated the details and fixed the bug with <a href=""https://github.com/Qiskit/qiskit-aqua/pull/1256"" rel=""nofollow noreferrer"">this pull request</a>.</p>
",9/17/2020 14:44,Tooling,"The user question pertains to using Qiskit's optimization tools and converters to handle quadratic constraints in a QuadraticProgram. It involves troubleshooting issues related to these tools and their interactions, making it a question about tooling in quantum programming.",Tooling,,,,Tooling,
13820.0,How to optimize my HHL algorithm on qiskit?,"<p>I am following this <a href=""https://qiskit.org/textbook/ch-applications/hhl_tutorial.html#B.-Running-HHL-on-a-real-quantum-device:-optimised-example"" rel=""nofollow noreferrer"">HHL tutorial</a> to solve the <span class=""math-container"">$Ax=b$</span> problem and have been using the general (inefficient) approach with the BasicAer simulator that they describe in section 4a. I would now like to run on the actual IBMQ machines but I am finding that my circuit depth and CNOT counts are quite high. To solve this issue, I would like to optimize my circuit. In section 4b of the tutorial they outline a method of optimizing their specific problem which substantially reduces the qubit count, circuit depth, and CNOT count. The problem I am having is figuring out how to extend this to larger matrices <span class=""math-container"">$A$</span> than the <span class=""math-container"">$2$</span>x<span class=""math-container"">$2$</span> that they use. Is there a general approach to optimizing an HHL circuit?</p>
",<programming><ibm-q-experience><hhl-algorithm>,9/18/2020 23:18,13858.0,13858.0,"<p>There isn't any specific method to optimise HHL other than using the PassManager from Qiskit, but this is a more general circuit optimisation.
With the newest devices it might be possible to run larger circuits due to the reduced error, otherwise you will have to manually find circuit reductions.</p>
<p>In the last page of <a href=""https://arxiv.org/abs/2009.04484"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2009.04484</a> you can find the circuits for the example mentioned in the textbook and for the case of a <span class=""math-container"">$4\times 4$</span> matrix, maybe this helps to run your circuit.</p>
",9/21/2020 12:34,Conceptual,The user is seeking a conceptual understanding of how to optimize an HHL (Harrow-Hassidim-Lloyd) circuit for solving linear systems of equations on quantum devices. The question pertains to the conceptual aspect of circuit optimization in the context of quantum algorithms.,Conceptual,,,,Conceptual,
13822.0,Grover algorithm in Q#,"<p>I have this program derived from Microsoft Quantum Kata for quantum search (Grover algorithm) (see <a href=""https://gist.github.com/friguzzi/3fb1006d2b81fd97d92858d7ddf5a284"" rel=""nofollow noreferrer"">here</a>)</p>
<pre><code>namespace Quantum.Search {


open Microsoft.Quantum.Intrinsic;
open Microsoft.Quantum.Canon;
open Microsoft.Quantum.Convert;
open Microsoft.Quantum.Math;
open Microsoft.Quantum.Oracles;
open Microsoft.Quantum.Arithmetic;
open Microsoft.Quantum.Characterization;
open Microsoft.Quantum.Arrays;
open Microsoft.Quantum.Measurement;


operation SprinklerAnc (queryRegister:  Qubit[],  target : Qubit) : Unit is Adj+Ctl 
{
    using (ancilla=Qubit[3 ])
    {
        X(queryRegister[2]);
        X(ancilla[0]);
        X(ancilla[1]);
        X(ancilla[2]);
    
        CCNOT(queryRegister[0],queryRegister[1],ancilla[0]);
        CCNOT(queryRegister[1],queryRegister[2],ancilla[1]);
        CCNOT(queryRegister[0],queryRegister[2],ancilla[2]);
        (Controlled X)([ancilla[0],ancilla[1],ancilla[2],queryRegister[3]],target);
        CCNOT(queryRegister[0],queryRegister[2],ancilla[2]);
        CCNOT(queryRegister[1],queryRegister[2],ancilla[1]);
        CCNOT(queryRegister[0],queryRegister[1],ancilla[0]);

        X(ancilla[2]);
        X(ancilla[1]);
        X(ancilla[0]);
        X(queryRegister[2]);

    }
}

operation ApplyMarkingOracleAsPhaseOracle (markingOracle : ((Qubit[], Qubit) =&gt; Unit is Adj+Ctl),  register : Qubit[] ) :  Unit is Adj+Ctl 
{
    
    using (target = Qubit()) 
    {
        // Put the target into the |-â© state
        X(target);
        H(target);
            
        // Apply the marking oracle; since the target is in the |-â© state,
        // flipping the target if the register satisfies the oracle condition will apply a -1 factor to the state
        markingOracle(register, target);
            
        // Put the target back into |0â© so we can return it
        H(target);
        X(target);
    }
}


// The Grover iteration
operation GroverIteration (register : Qubit[], oracle : ((Qubit[],Qubit) =&gt; Unit is Adj+Ctl)) : Unit is Ctl+Adj
{
    
    ApplyMarkingOracleAsPhaseOracle(oracle,register);
    ApplyToEachCA(H, register);
    using (ancilla = Qubit()){
            (ControlledOnInt(0, X))(register, ancilla); // Bit flips the ancilla to |1â© if register is |0...0â©   
            Z(ancilla);                                 // Ancilla phase (and therefore whole register phase) becomes -1 if above condition is satisfied
            
            (ControlledOnInt(0, X))(register, ancilla); // Puts ancilla back in |0â©  
    } 
    Ry(2.0 * PI(), register[0]);
    ApplyToEachCA(H, register);
}    


operation Search() : Result[] 
{
    
    using (reg=Qubit[4 ])
    {


  H(reg[0]);
  H(reg[1]);
  H(reg[2]);
  H(reg[3]);
  for (i in 1 ..2) {
  GroverIteration(reg, SprinklerAnc);
  }
  let state = MultiM(reg);

  ResetAll(reg);
  return state;
  }

}
}
</code></pre>
<p>with driver</p>
<pre><code>using System;
using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;
using System.Collections.Generic;

namespace Quantum.Search
{
class Driver
{
    static void Main(string[] args)
    {

        using (var qsim = new QuantumSimulator())
        {
            IDictionary&lt;string, int&gt; dict = new Dictionary&lt;string, int&gt;();
            for (int i = 0; i &lt; 1000; i++)
            {
                IQArray&lt;Result&gt; res = QMPE.Run(qsim).Result;
                string s = Convert.ToString(res);
                int result;
                if (dict.TryGetValue(s, out result))
                {
                    dict.Remove(s);
                    dict.Add(s, result + 1);
                }
                else
                {

                    dict.Add(s, 1);
                }
                System.Console.WriteLine($&quot;Res:{s}&quot;);

            }
            foreach (KeyValuePair&lt;string, int&gt; item in dict)
            {
                Console.WriteLine(&quot;Key: {0}, Value: {1}&quot;, item.Key, item.Value);
            }
        }
    }
}
}
</code></pre>
<p>It should search for the solutions of the 3 bits formula (not reg[0] or reg[2]) and (not reg<a href=""https://gist.github.com/friguzzi/3fb1006d2b81fd97d92858d7ddf5a284"" rel=""nofollow noreferrer"">1</a> or reg[2]) and (not reg[0] or not reg<a href=""https://gist.github.com/friguzzi/3fb1006d2b81fd97d92858d7ddf5a284"" rel=""nofollow noreferrer"">1</a>) and reg[3]. This formula has 4 solutions: 0001, 0011, 0111 and 1011. However, the distribution over the solutions that I get in 1000 execution is</p>
<pre><code>Key: [One,One,One,Zero], Value: 57
Key: [One,One,Zero,Zero], Value: 63
Key: [Zero,One,One,One], Value: 58
Key: [Zero,One,One,Zero], Value: 74
Key: [One,Zero,One,One], Value: 70
Key: [One,Zero,One,Zero], Value: 70
Key: [Zero,Zero,One,Zero], Value: 76
Key: [One,Zero,Zero,One], Value: 47
Key: [Zero,Zero,Zero,Zero], Value: 79
Key: [Zero,One,Zero,Zero], Value: 66
Key: [One,One,One,One], Value: 52
Key: [Zero,Zero,Zero,One], Value: 55
Key: [One,Zero,Zero,Zero], Value: 58
Key: [Zero,One,Zero,One], Value: 58
Key: [Zero,Zero,One,One], Value: 63
Key: [One,One,Zero,One], Value: 54
</code></pre>
<p>so basically a uniform distribution over the whole set of 16 configurations. I don't understand why the solution of the equations are not getting higher frequencies.</p>
",<programming><grovers-algorithm><q#>,9/19/2020 12:02,13832.0,13832.0,"<p>Short answer: for this problem the optimal number of iterations is 1 - change the loop range to do just one iteration and the output will switch to showing only the solutions to the problem:</p>
<pre><code>Key: [Zero,Zero,One,One], Value: 255
Key: [Zero,Zero,Zero,One], Value: 251
Key: [Zero,One,One,One], Value: 233
Key: [One,Zero,One,One], Value: 261
</code></pre>
<hr />
<p>The general formula for the number of solutions is <span class=""math-container"">$\frac{\pi}{4}\sqrt{\frac{N}{M}}$</span>, where <span class=""math-container"">$N = 16$</span> and <span class=""math-container"">$M = 4$</span>, gives us <span class=""math-container"">$\frac{\pi}{2} \approx 1.5$</span>, which can be rounded either up or down.</p>
<p>If we look at the derivation of the formula, however, we'll see that the square root is an approximation made assuming that <span class=""math-container"">$M &lt;&lt; N$</span>, and the optimal number of iterations is <span class=""math-container"">$&gt;&gt; 1$</span>. The exact formula is <span class=""math-container"">$\frac12 \big( \frac{\pi}{2\arcsin \sqrt{\frac{M}{N}}}-1\big)$</span>, which will give us <span class=""math-container"">$\arcsin \sqrt{\frac{M}{N}} = \arcsin 0.5 = \frac{\pi}{6}$</span> and the optimal number of iterations equal to 1.</p>
<p>You can see the visual derivation of the formula in <a href=""https://github.com/microsoft/GHC19-GroverSearch/blob/master/GHC19-IntroToQuantumComputing-Grover.pptx"" rel=""nofollow noreferrer"">this slide deck</a> - it shows where these assumptions come from and how they affect the result.</p>
",9/20/2020 2:51, Conceptual,The user is seeking a conceptual understanding of why they are not getting higher frequencies for the solutions of the equations in their quantum search algorithm. The question pertains to the conceptual aspect of quantum algorithm behavior and result interpretation.,Conceptual,,,, Conceptual,
13830.0,Why does job execution time vary significantly across different IBMQ Backends?,"<p>I have run a batch of a few thousand random 2-qubit <code>QuantumCircuit</code>s on multiple different IBMQ Backends, and the execution times seem to significantly vary across the backends (obviously excluding time in queue). The general trend seems to be that increased:</p>
<ol>
<li>Qubits or</li>
<li>Quantum Volume(QV)</li>
</ol>
<p>results in faster execution. As per my knowledge, this could be explained either by</p>
<ol>
<li>increased parallel execution of the batch with more qubits or</li>
<li>systems with higher QV operate at proportionately higher clock speeds (I am more inclined to this explanation as the fastest job executed on <code>ibmq_montreal</code> despite having fewer qubits than <code>ibmq_rochester</code>)</li>
</ol>
<p>Are any of these explanations correct or is there an entirely different explanation for this observation?</p>
<p>I have used the following backends:</p>
<ul>
<li><code>ibmq_montreal</code> - 27 qubits with QV 32</li>
<li><code>ibmq_vigo</code> - 5 qubits with QV 16</li>
<li><code>ibmq_rochester</code> - 53 qubits QV 8</li>
</ul>
",<programming><ibm-q-experience><ibm>,9/19/2020 21:42,13867.0,13867.0,"<p>With a higher Quantum Volume, your circuits will run faster, partly because a backend with a higher quantum volume can run complex circuits with a greater width and depth than backends with lower quantum volume. However, the number of qubits on a backend does not affect the speed of a circuit, because each logical qubit in your circuit is mapped to one physical qubit on the backend, so having more physical qubits than needed does not affect your running time, since they are not involved in the circuit. There are a lot of factors that go into determining the quantum volume of a backend, so if you are interested I would read more about it at the following links: <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measuring-quantum-volume.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/measuring-quantum-volume.html</a> and <a href=""https://qiskit.org/documentation/tutorials/noise/5_quantum_volume.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/noise/5_quantum_volume.html</a></p>
",9/21/2020 19:08,Conceptual,"The user question is about understanding the observed variations in execution times for random 2-qubit QuantumCircuits on different IBMQ Backends. It pertains to the conceptual aspect of why these variations occur, and the user is not seeking information related to API usage or specific programming tasks.", Conceptual,,,,Conceptual,
13864.0,How to get the CNOT error rate between 2 qubits on a given IBMQ Backend?,"<p>How can the <code>CNOT</code> gate error between 2 qubits as shown on visual qubit coupling map on the IBMQ Dashboard be retrieved in Qiskit using the <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.models.BackendProperties.gate_error.html#qiskit.providers.models.BackendProperties.gate_error"" rel=""nofollow noreferrer"">BackendProperties.gate_error</a> method ?</p>
<p>I have been able to retrieve the <code>U2</code> error rates as follows:</p>
<pre><code>properties = backend.properties()
properties.gate_error('u2', 0) # u2 error rate for qubit-0
</code></pre>
",<qiskit><programming><ibm-q-experience>,9/21/2020 18:11,13865.0,13865.0,"<p>You can type the following:</p>
<pre><code>provider = IBMQ.get_provider(hub='YOUR-HUB-NAME', group='YOUR-GROUP-NAME', project='YOUR-PROJECT_NAME')
provider.backends.backend
</code></pre>
<p>You should see an interactive widget with 5 tabs. Under the <strong>Multi-Qubit Gates</strong> tab, you can see the CNOT error rate between any two connected qubits on that given backend.</p>
<p>If you don't see the widget, import qiskit.tools.jupyter and then try to run the commands again.</p>
",9/21/2020 18:40,API Usage,"The user question is specifically about how to retrieve the CNOT gate error between 2 qubits using the BackendProperties.gate_error method in Qiskit, which involves understanding how to use the Qiskit API to access this information from a quantum backend.",API Usage,,,,API Usage,
13874.0,Inconsistency in Qiskit Aqua CircuitSampler from Operator Flow,"<p>I am trying to wrap my head around Qiskit Aqua Operators and I stumbled upon this:</p>
<p><strong>My code</strong></p>
<pre><code>t=0.5
hamiltonian=get_hamiltonian(1,1) #a four 4 qubit hamiltonian (Transverse field Ising model)
evo_time=Parameter(&quot;t&quot;)

evo_op=(evo_time*hamiltonian).exp_i()
evo_op1 = evo_op @ (Zero^4)

trotter_op=PauliTrotterEvolution(trotter_mode=Suzuki(reps=10,order=1)).convert(evo_op1)
trotter_op_values=trotter_op.bind_parameters({evo_time: t})

circuit1=trotter_op_values.to_circuit()
backend=Aer.get_backend(&quot;qasm_simulator&quot;)
circuit1.measure_all()

counts1=execute(circuit1, backend=backend, shots=10024).result().get_counts()

for key in counts1.keys():
    counts1[key]=counts1[key]/10024

a=0
# I had to instantiate again the trotter_op because trotter_op_values.to_circuit()
#didn't create a new circuit and instead, by having done circuit1.measure_all()
# trotter_op was modified as well.

trotter_op=PauliTrotterEvolution(trotter_mode=Suzuki(reps=10,order=1)).convert(evo_op1)
trotter_op_values=trotter_op.bind_parameters({evo_time: t})
sampler=CircuitSampler(backend=Aer.get_backend(&quot;qasm_simulator&quot;))
sampler.quantum_instance.shots=10024
results1=sampler.convert(trotter_op_values).primitive

#normalize the results from the circuitsampler
for key in results1.keys():
    a+=results1[key]
for key in results1.keys():
    results1[key]=results1[key]/a

# assert counts1.keys()==results1.keys()
assert sum(counts1.values()) #check normalization
assert sum(results1.values()) #check normalization

for key in results1.keys():
    print(&quot;state: {} | Counts1: {} | Results1: {}&quot;.format(key,counts1[key], results1[key]))

    
plot_histogram([counts1, results1], legend=[&quot;Running the circuit&quot;,&quot;CircuitSampler from aqua&quot;])
</code></pre>
<p><strong>What I expected</strong>
Since the evo_op1 is just a <code>CircuitStateFn</code> whose initialization was the zero state for the 4 qubits then, passing this into <code>CircuitSampler</code> the <code>CircuitStateFn</code> would be replaced by a <code>DictStateFn</code> whose amplitudes would be the same as measuring all 4 qubits in the trotterization circuit with a zero state initialization (my <code>circuit1</code>).</p>
<p><strong>What I got</strong>
The histograms never match, for any value of <code>t</code> except <code>t=0</code>. However, there is always a clear similarity between the plots (for small <code>t</code> the probability for <code>0000</code> is always the biggest for example and all other states have similiar probabilities, but never exactly equal)</p>
<p><a href=""https://i.stack.imgur.com/jgmMZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jgmMZ.png"" alt=""enter image description here"" /></a></p>
<p>What am I missing? Was it a bad interpretation of the Operator Flow?</p>
",<qiskit><programming><simulation>,9/22/2020 16:32,13888.0,13888.0,"<p>Well, you are right. After <code>CircuitSampler</code> you are getting a <code>DictStateFn</code> with phase information lost (see the <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.converters.CircuitSampler.html#qiskit.aqua.operators.converters.CircuitSampler"" rel=""nofollow noreferrer"">docs</a>) in the amplitudes and you have to take the square of them for your histogram plot (not normalize).</p>
<p>Besides that, just keep in mind that the number of shots are not stored in the <code>QuantumInstance</code> of <code>CircuitSampler</code> (in the way you are setting them). You should rather do</p>
<pre><code>qinstance = QuantumInstance(backend, shots=10024)
sampler = CircuitSampler(qinstance)
</code></pre>
",9/23/2020 11:01,Tooling,"The user question involves a detailed code-related issue and interpretation of Qiskit Aqua's Operator Flow, which falls under the category of tooling. The user is seeking assistance in understanding and resolving a problem related to Qiskit Aqua's tools and libraries.", Tooling,,,,Tooling,
13878.0,Why does job appear to be stuck in queue on IBMQ backend?,"<p>I have submitted a batch of circuits to <code>ibmq_vigo</code> using the <code>IBMQJobManager</code> and the batch is correctly split properly into multiple jobs(as viewed on the dashboard), however the job at the front of the queue appears stuck at the front for multiple hours. The backend does not appear to be in reserve mode and I did not have this issue when I successfully executed the same batch of circuits on <code>ibmq_rochester</code>.</p>
<p>Does anyone know what might be the issue?
Also this is my second unsuccessful attempt at executing on <code>ibmq_vigo</code>.</p>
",<programming><ibm-q-experience>,9/22/2020 19:27,13881.0,13881.0,"<p>Sometime that happens. The controlled electronic might got a reboot during while your jobs were in queue or something of that sort... You can try to cancel your jobs and resubmitted them to see if that fixes it. Note that if you running jobs through Aqua, like performing QAOA or VQE, you can cancel the current jobs and they will create a replacement job automatically.</p>
",9/22/2020 22:54,Tooling," The users question relates to an issue they are facing with the IBM Quantum Experience platform (specifically, job execution on IBM Quantum devices), which falls under the Tooling category. The user is seeking help to diagnose and resolve this issue with the platform's tools and services.",Tooling,,,,Tooling,
13883.0,Can I get the job variable from the job_idï¼,"<p>Suppose I run the following codeï¼</p>
<p><code>job = execute(qc, backend = backend, shots = 1024, optimization_level = 0)</code></p>
<p>Then the job takes a long time to run. We know that job_id (from <code>job.job_id()</code>) is a unique identifier for a job. Can I just save job_id and then turn it off and restore the job variable with job_id the next day?</p>
<p>Or what information can I save that will allow me to get the <code>job.result()</code> after I drop the line?</p>
<p>The motivation for this problem is that I don't want to increase the workload due to network reasons when I am waiting for many tasks to run. It will be much easier to handle data when there is <code>job.result()</code>. Otherwise, I can only go to <code>https://quantum-computing.ibm.com/</code> to download the result data, and the data format is not easy to use.</p>
<p>thank you for your help!</p>
",<qiskit><programming><ibm-q-experience>,9/23/2020 8:21,13885.0,13885.0,"<p>I take it you're running the jobs on an IBMQ backend and not one of the local simulators.<br />
If so, just keep track of <code>job_id</code>, then use the <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.IBMQBackend.retrieve_job.html"" rel=""nofollow noreferrer"">retrieve_job</a> function to retrieve the job at a later point in time and get its result.</p>
",9/23/2020 10:26,API Usage,"The user is discussing how to use specific functions (like execute, job_id, and job.result) in a quantum programming API. They are seeking advice on how to effectively use these functions to manage and retrieve results from quantum computations. ",API Usage,,,,API Usage,
13893.0,Simulate a random quantum state time evolution in Qiskit Aqua,"<p>I am trying to evolve a quantum state through a <code>PauliTrotterEvolution</code> in aqua and I'm trying to do so by initializing a random state, by using <code>random_statevector</code> from <code>qiskit.quantum_info</code>.</p>
<p><strong>My code:</strong></p>
<pre><code>op=get_hamiltonian(-1,h) # a 4 qubit operator
evo_op=(t*op).exp_i()
evo_op=evo_op 

trotter_op=PauliTrotterEvolution(trotter_mode=Suzuki(reps=10,order=1)).convert(evo_op)
qinstance=QuantumInstance(backend=Aer.get_backend(&quot;qasm_simulator&quot;), shots=2048)
sampler=CircuitSampler(qinstance)

trotter_op=trotter_op @ StateFn(state)
results1=sampler.convert(trotter_op).primitive
</code></pre>
<p><strong>The error</strong></p>
<p>this returns the following error: <code>ValueError: Qiskit circuit Initializer cannot handle non-positive statevectors.</code> however, by the source code, the <code>Initializer</code> comes from <code>qiskit.extensions</code> which I believe is from this .py file (<a href=""https://github.com/Qiskit/qiskit-terra/blob/e784e743018676a7d497ec7ab9b8b1265b65fa5a/qiskit/extensions/quantum_initializer/initializer.py#L33"" rel=""nofollow noreferrer"">file</a>) whose docstring states:</p>
<pre><code>&quot;&quot;&quot;Complex amplitude initialization.
    Class that implements the (complex amplitude) initialization of some
    flexible collection of qubit registers (assuming the qubits are in the
    zero state).
    Note that Initialize is an Instruction and not a Gate since it contains a reset instruction,
    which is not unitary.
    &quot;&quot;&quot;
</code></pre>
<p>what am I missing?</p>
",<qiskit><programming><hamiltonian-simulation>,9/23/2020 21:10,13954.0,13954.0,"<p>This seems to be a bug on the <code>Circuit_state_fn</code>. I added a Issue on the aqua github repo: <a href=""https://github.com/Qiskit/qiskit-aqua/issues/1276"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/issues/1276</a>, thus in order to solve the problem you should pass the if statement on circuit_state_fn.py:</p>
<pre><code>if not np.all(np.abs(statevector) == statevector):
            # TODO maybe switch to Isometry?
            raise ValueError('Qiskit circuit Initializer cannot handle non-positive statevectors.')   
</code></pre>
",9/29/2020 17:52,Errors, The user is encountering an error when trying to evolve a quantum state using the PauliTrotterEvolution in Qiskit Aqua. This falls under the Errors category.,Errors,,,,Errors,
13894.0,Qiskit: Error when importing libraries for ADMM optimizer,"<p>I would like to try and ADMM optimizer as shown in Qiskit Tutorial in Quantum Lab. Firstly, I imported necessary libraries (copy/paste from the Tutorial):</p>
<pre><code>import time
from typing import List, Optional, Any
import numpy as np
import matplotlib.pyplot as plt 

from docplex.mp.model import Model

from qiskit import BasicAer
from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver
from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer
from qiskit.optimization.problems import QuadraticProgram
from qiskit.optimization.algorithms.admm_optimizer import ADMMParameters, ADMMOptimizer
</code></pre>
<p>When I started the import this error appeared:</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-32-c32e151d13df&gt; in &lt;module&gt;
     11 
     12 from qiskit import BasicAer
---&gt; 13 from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver
     14 from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer
     15 from qiskit.optimization.problems import QuadraticProgram

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/__init__.py in &lt;module&gt;
     75 from .aqua_globals import aqua_globals
     76 from .quantum_instance import QuantumInstance
---&gt; 77 from .algorithms import QuantumAlgorithm
     78 from ._logging import (QiskitLogDomains,
     79                        get_logging_level,

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/__init__.py in &lt;module&gt;
    190 from .eigen_solvers import NumPyEigensolver, ExactEigensolver, EigensolverResult
    191 from .factorizers import Shor
--&gt; 192 from .linear_solvers import HHL, NumPyLSsolver, ExactLSsolver
    193 from .minimum_eigen_solvers import (VQE, VQEResult, QAOA, IQPE, IQPEResult, QPE, QPEResult,
    194                                     ClassicalCPLEX, CPLEX_Ising, NumPyMinimumEigensolver,

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/__init__.py in &lt;module&gt;
     15 &quot;&quot;&quot; Linear Solvers Package &quot;&quot;&quot;
     16 
---&gt; 17 from .hhl import HHL
     18 from .numpy_ls_solver import NumPyLSsolver, ExactLSsolver
     19 

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/hhl.py in &lt;module&gt;
     24 from qiskit.aqua import QuantumInstance
     25 from qiskit.aqua.algorithms import QuantumAlgorithm
---&gt; 26 from qiskit.ignis.verification.tomography import state_tomography_circuits, \
     27     StateTomographyFitter
     28 from qiskit.converters import circuit_to_dag

/opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/__init__.py in &lt;module&gt;
     98 &quot;&quot;&quot;
     99 from .quantum_volume import qv_circuits, QVFitter
--&gt; 100 from .randomized_benchmarking import (CNOTDihedral,
    101                                       randomized_benchmarking_seq,
    102                                       RBFitter, InterleavedRBFitter,

/opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/__init__.py in &lt;module&gt;
     19 
     20 # Randomized Benchmarking functions
---&gt; 21 from .circuits import randomized_benchmarking_seq
     22 from .dihedral import (CNOTDihedral, decompose_cnotdihedral, random_cnotdihedral)
     23 from .fitters import (RBFitter, InterleavedRBFitter, PurityRBFitter,

/opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/circuits.py in &lt;module&gt;
    204                                 is_purity: bool = False,
    205                                 group_gates: Optional[str] = None,
--&gt; 206                                 rand_seed: Optional[Union[int, RandomState]] = None) -&gt; \
    207         (List[List[qiskit.QuantumCircuit]], List[List[int]],
    208          Optional[List[List[qiskit.QuantumCircuit]]],

AttributeError: module 'qiskit' has no attribute 'quantum_info'
</code></pre>
<p>Since I only copied the code, it seems there is some bug. <strong>Does anybody know how to solve this?</strong></p>
<p><em>Note: I work in Quantum Lab in IBM Q Experience interface</em></p>
",<qiskit><programming><ibm-q-experience><optimization>,9/24/2020 11:43,13897.0,13897.0,"<p>Looks like a glitch. It is not reproducible under my account. I've seen similar errors when there's mismatch in versions between Qiskit Aqua and Terra installed locally, but I don't think it is the case in Quantum Lab.
Try to restart the kernel or create a new notebook and run the same imports.</p>
",9/24/2020 15:01,Tooling,"The user is encountering an error related to the Qiskit libraries when working in the IBM Quantum Lab interface. The issue seems to be with the installation or compatibility of the Qiskit version used in the Quantum Lab, which falls under the tooling category as it involves working with the development environment and libraries.", Tooling,,,,Tooling,
13906.0,IF statement in OpenQASM on IBM Quantum Experience,"<p>This is a simple circuit introduced in Moran's book &quot;Mastering Quantum Computing with IBM QX&quot; to demonstrate how <em>if</em> works in OpenQASM:</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[5]; // Quantum Register
creg c[5]; // Classical Register
 
x q[0];
measure q[0] -&gt; c[0];
if (c==1) x q[1];
measure q[1] -&gt; c[1];
</code></pre>
<p>And this is how the circuit visually looks in IBM QX Circuit Composer:</p>
<p><a href=""https://i.stack.imgur.com/hrtEk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hrtEk.png"" alt=""enter image description here"" /></a></p>
<p>The book states that at the end of the circuit, the classical register should read <em>00011</em> because after the first measurement it holds a value 1 (as a decimal number), thus satisfying the <em>if</em> condition. However, when I test this exact circuit in IBM QX's Circuit Composer, the result shows <em>00001</em> with 100% probability.</p>
<p>Interestingly enough, when <code>if (c==1)</code> is changed to <code>if (c==0)</code>, the result is now <em>00011</em> with 100% probability, which I don't think is logically right.</p>
<p>What should be an explanation for this discrepancy? The book argues that the <em>if</em> statement is not supported by IBM QX (as of Jan 2019), so could this be a sort of bug?</p>
<p>Any help would be appreciated.</p>
",<programming><ibm-q-experience><textbook-and-exercises>,9/25/2020 6:59,13908.0,13908.0,"<p><del>I think is, indeed, a bug in IQX.</del> There is an explanation for this, but it is a bit obscure. It will be explained later.</p>
<p>Your code is correct:</p>
<p>Here is the result in Qiskit.</p>
<p>With <code>c==1</code>:</p>
<pre><code>from qiskit import *
qc = QuantumCircuit.from_qasm_str(&quot;&quot;&quot;
OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[5]; // Quantum Register
creg c[5]; // Classical Register
 
x q[0];
measure q[0] -&gt; c[0];
if (c==1) x q[1];
measure q[1] -&gt; c[1];
&quot;&quot;&quot;)
qc.draw('mpl')

backend = BasicAer.get_backend('qasm_simulator')
execute(qc,backend).result().get_counts()
</code></pre>
<pre><code>{'00011': 1024}
</code></pre>
<p>With <code>c==0</code>:</p>
<pre><code>from qiskit import *
qc = QuantumCircuit.from_qasm_str(&quot;&quot;&quot;
OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[5]; // Quantum Register
creg c[5]; // Classical Register
 
x q[0];
measure q[0] -&gt; c[0];
if (c==0) x q[1];
measure q[1] -&gt; c[1];
&quot;&quot;&quot;)
qc.draw('mpl')

backend = BasicAer.get_backend('qasm_simulator')
execute(qc,backend).result().get_counts()
</code></pre>
<pre><code>{'00001': 1024}
</code></pre>
<h2>Why this does not work on IQX visualizations</h2>
<p>There is note in <a href=""https://quantum-computing.ibm.com/docs/iqx/visualizations"" rel=""nofollow noreferrer"">the IQX documentation for visualizations</a>:
<a href=""https://i.stack.imgur.com/JxyJ7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JxyJ7.png"" alt=""enter image description here"" /></a></p>
<p>The key part is:</p>
<blockquote>
<p>The visualizations do not reflect any measurement operations in your circuit.</p>
</blockquote>
<p>That means that your <code>measure</code> statement is ignored, leaving your code like this:</p>
<pre><code>x q[0];
if (c==1) x q[1];
</code></pre>
<p>The initial state of <code>c</code> is 0. Therefore, just <code>x q[0];</code> resulting in <code>00001</code>.</p>
<p>When you changed to <code>c==0</code>, then the circuit is <code>x q[0]; x q[1];</code>, resulting in <code>00011</code>.</p>
<p>I talked with the IQX developers and they are working in a better solution to avoid skipping measurements silently. You can still run your program in IQX using a simulator backend and the result will be the correct one. This issue only pops up in the client-side visualizations, since they are statevector based.</p>
",9/25/2020 12:12,Tooling,"The user is encountering a discrepancy between the expected behavior of an OpenQASM circuit with an ""if"" statement and the actual behavior observed in the IBM Q Experience Circuit Composer. This discrepancy likely relates to the tooling and implementation of the circuit composer, as the user is questioning whether the ""if"" statement is supported correctly in IBM QX, making it a tooling-related issue.",Tooling,,,,Tooling,
13920.0,Change the position of a gate in Qiskit for better representation,"<p>I'm using Qiskit to demonstrate some circuits, and I want to change the position of some gates for better representation.</p>
<p>For example, look at this circuit: <a href=""https://i.stack.imgur.com/QhWXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QhWXf.png"" alt=""enter image description here"" /></a></p>
<p>I'd like for the last <span class=""math-container"">$R_x(\frac{-\pi}{2})$</span> to align with the last Hadamard gate. Is there a way to do this without using barriers?</p>
",<qiskit><programming>,9/26/2020 18:15,13923.0,13923.0,"<p>The <code>justify=</code> parameter might help.</p>
<pre><code>qc.draw('mpl', reverse_bits=True, justify='right')
</code></pre>
<p><a href=""https://i.stack.imgur.com/TR1Gl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TR1Gl.png"" alt=""enter image description here"" /></a></p>
<p>Other option is to add the <code>barrier</code> and then remove them from the plot (though that will skip all the barriers)</p>
<pre><code>...
qc.barrier(range(4))
qc.h(3)
qc.rx(-pi/2, 0)
qc.draw('mpl', reverse_bits=True, plot_barriers=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/eGCxO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eGCxO.png"" alt=""enter image description here"" /></a></p>
",9/26/2020 20:30,Tooling,The user is asking about how to manipulate the visual representation of quantum circuits in Qiskit for better demonstration. This involves using the features and functionalities of the Qiskit tool. ,Tooling,,,,Tooling,
13928.0,Why is local qasm simulation taking so long for VQE?,"<p>I've successfully run the <span class=""math-container"">$LiH$</span> VQE simulation detailed in <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">Simulating Molecules using VQE</a> using the <code>statevector_simulator</code>, however when attempting to run the same simulation on the <code>quantum_instance</code>(detailed in the same section) using the <code>NoiseModel</code> for <code>ibmq_manhattan</code> the simulation seems to run indefinitely without yielding results.</p>
<p>Is it expected that the <code>quantum_instance</code> simulation would be significantly longer (<span class=""math-container"">$&gt;100\times$</span>) than the <code>statevector_simulator</code> simulation?</p>
<p>Note: I'm using the following optimizer and variational form:</p>
<pre><code>optimizer = SPSA(maxiter=100)
var_form = EfficientSU2(qubitOp.num_qubits, entanglement=&quot;linear&quot;)
</code></pre>
",<qiskit><programming><textbook-and-exercises><vqe>,9/27/2020 22:25,13931.0,13931.0,"<p>statevector simulator is a perfect/ideal simulation. It basically just manipulate the quantum state according to linear algebra. qasm_simulator with or without noise model is a shot based simulation that mimic the behavior of the device.</p>
<p>In other words, you can think of statevector simulator as performing a 1 shot experiment, whereas qasm_simulator is performing multiple shots simulation, hence it will take longer.</p>
<p>Note that as you go up in size, statevector simulation is not ideal... as you will run into memory problem... since you have to generate the entire Hamiltonian matrix  and manipulate it. Whereas qasm simulator allows you to do this faster by not generating the entire Hamiltonian matrix.</p>
",9/27/2020 22:57,Tooling,"The user is asking about the expected runtime when using the quantum_instance simulation with a NoiseModel for ibmq_manhattan in Qiskit, compared to the statevector_simulator. This involves understanding the performance characteristics of these specific tools in the Qiskit library.",Tooling,,,,Tooling,
13933.0,On number of parameters and operators in UCCSD in qiskit,"<p>I have two questions on UCCSD in qiskit, please see the code below.</p>
<pre><code>import numpy as np
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver, UnitsType
from qiskit.chemistry import FermionicOperator
from qiskit.aqua import QuantumInstance
def get_qubit_op( atom , basis , map_type ):
    driver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, 
                         charge=0, spin=0, basis=basis)
    molecule = driver.run()
    repulsion_energy = molecule.nuclear_repulsion_energy
    num_particles = molecule.num_alpha + molecule.num_beta
    num_spin_orbitals = molecule.num_orbitals * 2
    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)
    qubitOp = ferOp.mapping(map_type=map_type, threshold=0.00000001)
#     qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    shift = repulsion_energy
    return qubitOp, num_particles, num_spin_orbitals, shift
atom='H .0 .0 .0; H .0 .0 0.74'
qubitOp, num_particles, num_spin_orbitals, shift = get_qubit_op( atom , basis = 'sto3g' , map_type = 'parity' )
num_qubits = qubitOp.num_qubits
print( 'num_qubits = ' , num_qubits ) 
from qiskit.chemistry.components.initial_states import HartreeFock    
init_state = HartreeFock( num_spin_orbitals , num_particles , 'parity' , two_qubit_reduction=False )
# setup the variational form for VQE
from qiskit.chemistry.components.variational_forms import UCCSD
var_form_vqe = UCCSD(
        num_orbitals=num_spin_orbitals,
        num_particles=num_particles,
        initial_state=init_state,
        qubit_mapping='parity' , 
        two_qubit_reduction = False
    )
print( 'var_form_vqe.num_parameters = ' , var_form_vqe.num_parameters )
var_form_vqe.construct_circuit([1,1,1]).draw() # Give some random para
</code></pre>
<p>The outputs are (without the plot of the circuit)</p>
<pre><code>num_qubits =  4
var_form_vqe.num_parameters =  3
</code></pre>
<p>My questions are</p>
<p>1.<br />
Why there are only 3 free parameters in UCCSD? Since I have 4 spin-orbs, I should expect there are at least 4^4 free parameters from the double excitation operators?</p>
<p>2.
Is there a way to see which operators are involved in UCCSD? I plot out the circuit, but there are âEvolution^1â block involved. If I use âdecompose().â, it shows all the 1 and 2 qubit operations? Would it be possible to show something in between, by which I mean for example adding barrier for the decomposed circuit, or showing which fermionic excitation operators are involved?
Many thanks!</p>
",<qiskit><programming><vqe>,9/28/2020 5:14,13934.0,13934.0,"<p>Since UCCSD is a particle- and spin-conserving variational form, the number of parameters does not only depend on the number of spin orbitals but also their &quot;nature&quot;. What I mean by that is that you also need to consider these conservation rules which leads to the following scenario in your case:</p>
<p>H2 has 2 electrons in 2 molecular orbitals, which correspond to 4 spin orbitals (and, thus, 4 qubits since you do not apply any reductions, here). Taking into account the spin-conservation you have the following possible single excitations:</p>
<pre><code>0 -&gt; 1
2 -&gt; 3
</code></pre>
<p>where I use Qiskit's notation in which spin orbitals are ordered block-wise (i.e. first all alpha orbitals, then all beta ones). <strong>If</strong> the spin was <strong>not</strong> conserved, then you would also see excitations such as <code>0 -&gt; 3</code> and <code>1 -&gt; 2</code>.</p>
<p>The double excitations are a little bit simpler in this case because there is only one possibility regardless:</p>
<pre><code>0, 1 -&gt; 2, 3
</code></pre>
<p>However, if the example was more complex, the same reasoning would apply here, too.</p>
<p>Regarding your second question: if you would like to see the excitation lists as I have written them above you can take a look at the <code>single_excitations</code> and <code>double_excitations</code> attributes of the <code>UCCSD</code> class.
I am not aware of any &quot;partial&quot; <code>decompose()</code> functionality which could otherwise provide that you describe above.</p>
",9/28/2020 6:14,Theoretical ,"The user is asking about the theoretical aspects of the UCCSD variational form in Qiskit, specifically about the number of free parameters and the operators involved in UCCSD. These questions are related to understanding the underlying principles and workings of the UCCSD method in quantum computing",Conceptual,"The questions involve understanding the conceptual aspects of the UCCSD variational form in Qiskit and how to interpret and visualize the circuit it generates. The user is seeking a conceptual explanation of why there are three free parameters in UCCSD and how to better visualize the involved operators, which pertains to the underlying concepts of quantum chemistry and quantum computing.",No,96.0,Theoretical,"The user is asking about the theoretical aspects of the UCCSD variational form in Qiskit, including the number of free parameters and the operators involved, which requires an understanding of the underlying principles and workings of the UCCSD method in quantum computing."
13936.0,Information about two algorithms of Matrix product state,"<p>In qiskit backends, there is Matrix_product_state.
With this backend, I can simulate circuit for several qubits. And I found some mysterious problem about MPS. With 25,26,27 qubits, the simulating time takes really really much. So, I asked here why it happened, and I got some answer here. But I want to know more detail about this MPS part. Where can I found the information about two algorithm of MPS? Please help.</p>
",<qiskit><algorithm><programming><density-matrix><matrix-representation>,9/28/2020 6:59,13940.0,13940.0,"<p>The performance issue that you see occurs in the measurements at the end of your circuit. Until then there is only one algorithm.</p>
<p>The statevector simulator (note - statevector - not MPS) has an optimization, that is applied when all measurement gates are at the end, and the simulation is not noisy. With this optimization, we perform only 1 shot, even if the user asked say for 1000 shots. We generate counts for 1000 shots from the probabilities at the end.</p>
<p>The MPS simulator cannot have this optimization, therefore for 1000 shots you'll have to apply the measurement gates 1000 times. Therefore, when there are many shots, it is preferable to convert from MPS to statevector for the measurement part. Note that this conversion is expensive, so should not happen for a small number of shots.</p>
<p>Here is a link to the closed pull request that introduced this conversion: <a href=""https://github.com/Qiskit/qiskit-aer/pull/808"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aer/pull/808</a></p>
<p>There is also an issue that you can track, following your query: <a href=""https://github.com/Qiskit/qiskit-aer/issues/944"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aer/issues/944</a></p>
",9/28/2020 13:00,Learning ," The user is trying to get more information about the Matrix Product State (MPS) simulation method used in Qiskit, specifically about the algorithms involved. This falls under the Learning category as the user is looking for resources to deepen their understanding of this topic. ",Learning,,,,Learning ,
13937.0,Why is circuit inverse not working for EfficientSU2?,"<p>For some reason I get the following error when attempting to find the inverse of the <code>EfficientSU2</code> VQE variational form:</p>
<blockquote>
<p>TypeError: 'NoneType' object is not reversible</p>
</blockquote>
<p>My code is as follows:</p>
<pre><code>var_form = EfficientSU2(6, entanglement=&quot;linear&quot;)
var_form_inv = var_form.inverse() # error thrown of this line
</code></pre>
<p>Is there a bug in the implementation of the <code>inverse</code> method? and if so how can I implement a working <code>inverse</code> function?</p>
<p>Note <code>qiskit.__qiskit_version__</code>:</p>
<pre><code>{'qiskit-terra': '0.15.2',
 'qiskit-aer': '0.6.1',
 'qiskit-ignis': '0.4.0',
 'qiskit-ibmq-provider': '0.9.0',
 'qiskit-aqua': '0.7.5',
 'qiskit': '0.21.0'}
</code></pre>
",<qiskit><programming><ibm-q-experience><vqe>,9/28/2020 8:38,13938.0,13938.0,"<p><code>EfficientSU2</code> is a <code>BlueprintCircuit</code> and does not populates its internal <code>data</code> field until you try to access them.</p>
<p>In this case, when you are calling the <code>inverse</code> function the <code>data</code> are still empty (<code>None</code>) and this is the error you are getting. It is probably a bug and should be fixed.</p>
<p>Nevertheless, as a workaround for now you can try:</p>
<pre><code>var_form = EfficientSU2(6, entanglement=&quot;linear&quot;)
# build the circuit
var_form._build() 
# or just print it
print(var_form)
var_form_inv = var_form.inverse() 
</code></pre>
",9/28/2020 9:31,Errors,The user is encountering a specific error (TypeError: 'NoneType' object is not reversible) when trying to find the inverse of the EfficientSU2 VQE variational form in Qiskit. They are seeking help to understand and resolve this error,Errors,,,,Errors,
13942.0,Why is there a significant variation between the exact and VQE energy results?,"<p>When running the VQE simulation for <span class=""math-container"">$H_2$</span> over a range of distances as detailed in the <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html#Running-VQE-on-a-Noisy-Simulator"" rel=""nofollow noreferrer"">Simulating Molecules using VQE</a> section of the Qiskit Textbook, the VQE energy deviation from the exact energy increases with distance as shown in the figure below:
<a href=""https://i.stack.imgur.com/w2qOT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/w2qOT.png"" alt=""H_2 Energy(Hartree ) vs Distance(Angstrom)"" /></a></p>
<p>How is this relation(<span class=""math-container"">$Error \propto distance$</span>) explained and how can it's effects be minimized?</p>
<p>My VQE code is as follows:</p>
<pre><code>distances = np.arange(0.2, 5, 0.5) # for a finer exact_energies plot run with step of 0.1
exact_energies = []
vqe_energies = []

optimizer = SPSA(maxiter=1000)

for dist in distances:
    molecule = &quot;H .0 .0 -&quot; + str(dist) + &quot;; H .0 .0 &quot; + str(dist)
    driver = PySCFDriver(atom = molecule, unit=UnitsType.ANGSTROM, charge=0, spin=0, basis='sto3g')
    qmolecule = driver.run()
    num_particles = qmolecule.num_alpha + qmolecule.num_beta
    qubitOp = FermionicOperator(h1=qmolecule.one_body_integrals, h2=qmolecule.two_body_integrals).mapping(map_type='parity')
    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    
    result = NumPyEigensolver(qubitOp).run()
    exact_energies.append(np.real(result.eigenvalues))
    
    var_form = EfficientSU2(qubitOp.num_qubits, entanglement=&quot;linear&quot;)
    vqe = VQE(qubitOp, var_form, optimizer)
    vqe_result = np.real(vqe.run(backend)['eigenvalue'])
    vqe_energies.append(vqe_result)
</code></pre>
<p>I expected the error to be very low as <code>maxiter = 1000</code>. Also note the <code>backend</code> is a <code>statevector_simulator</code>.</p>
",<qiskit><programming><vqe>,9/28/2020 17:59,13947.0,13947.0,"<p>The reason why you don't have the concave curve is because you are not taken into account of the nuclear repulsion (energy shift) term.</p>
<p>Note that the electronic Hamiltonian (using Born-Oppenheimer approximation) is:</p>
<p><span class=""math-container"">$$ H = -\sum_i \dfrac{\nabla^2_{r_i}}{2} - \sum \dfrac{Z_i}{|R_i - r_j|}  + \sum \dfrac{1}{|r_i - r_j|} + \sum \dfrac{Z_iZ_j}{|R_i - R_j|}  $$</span></p>
<p>Since the nuclei are fixed, the last term is a constant. This term is the nuclear repulsion. You must add it in at the end to get the electronic ground state energy.</p>
<hr />
<p>As to why you get better result at some distance compare to other is because of the structure of your var_form. You used the same var_form for every geometric configuration here. But in reality, a var_form might be good at one geometry configuration and bad at a different geometry configuration.
This is because you don't expect that single circuit structure can prepare an arbitrary quantum state... At some distance, the state might be more entangled, and the var_form you picked might not be suffice to generate that state.</p>
",9/29/2020 6:55,Errors,The user is encountering an unexpected increase in the error of a VQE simulation with increasing interatomic distance in a hydrogen molecule. They are seeking an explanation for this behavior and advice on how to minimize its effects,Errors,,,,Errors,
13948.0,How does the classical optimization of the angles $\gamma$ and $\beta$ in QAOA work?,"<p>I have been trying to implement QAOA with classical optimization of the angles <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span>, but I I'm failing at the classical part.</p>
<p>In paper <a href=""https://arxiv.org/pdf/1812.01041.pdf"" rel=""nofollow noreferrer"">Quantum Approximate Optimization Algorithm: Performance, Mechanism, and Implementation on Near-Term Devices</a> QAOA works with variational parameters <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span>   which are first chosen randomely and afer thar is in a loop of 3 steps.</p>
<p>Step1. Simulating  <span class=""math-container"">$\langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span> with the Quantum Computer.</p>
<p>Step2. Measure in the Z basis. And getting <span class=""math-container"">$\langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span>.</p>
<p>Step3. Use a classical optimizesers to calculate new angles <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span>.
In the paper it says that <span class=""math-container"">$F_p(\vec{\gamma},\vec{\beta}) = \langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span> is maximized.<br />
My Questions are:</p>
<ol>
<li>How does the measured expectiaon Value from step 2 is involved in the classical optimization?</li>
<li>Are the old <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span> involved in the classical optimization?</li>
<li>Are step 1 and step 2 only done once? Becuase then the measurement in step 2 will be very unreliable.</li>
<li>How is the function <span class=""math-container"">$F_p(\vec{\gamma},\vec{\beta}) = \langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span> written classicaly so that a classical optimizer can work with is?</li>
<li>Is there a paper where this is explained or programmed?</li>
</ol>
",<programming><optimization><qaoa>,9/29/2020 11:17,13965.0,13965.0,"<ol>
<li><p><span class=""math-container"">$\langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span> is basically the function evaluation step during the optimization. If you use a gradient-free optimizer, then it uses this information to drive its search.</p>
</li>
<li><p>Depending on the optimizer if it needs them to update the parameters.</p>
</li>
<li><p>You seem confused between the simulation and measurement part. <span class=""math-container"">$\langle \psi_p(\gamma,\beta)|H|\psi_p(\gamma,\beta)\rangle$</span> is the expression you want to optimize. But with a real quantum computer, you can only estimate it by doing many measurements (you get bitstrings which serve as candidates) and averaging the corresponding energies. So you need many measurements if you want a higher precision for that estimate.</p>
</li>
<li><p>It is not written. As said in 3, you estimate it. The optimizer uses that information in its optimization process.</p>
</li>
<li><p>There are many tutorials on many platforms such as <a href=""https://github.com/quantumlib/Cirq/blob/master/examples/qaoa.py"" rel=""nofollow noreferrer"">Cirq</a> or <a href=""https://pennylane.ai/qml/demos/tutorial_qaoa_maxcut.html"" rel=""nofollow noreferrer"">Pennylane</a>.</p>
</li>
</ol>
",9/30/2020 10:54,Theoretical ,"The user is asking about the theoretical aspects of the Quantum Approximate Optimization Algorithm (QAOA), specifically about the classical optimization of the angles in the algorithm. These questions are related to understanding the underlying principles and workings of the QAOA method in quantum computing",Theoretical,,,,Theoretical ,
13987.0,How to realize Su-Schrieffer-Heeger model in Qiskit,"<p>This is a very specific question, which I try to implement a simple dimerized tight-binding Hamiltonian on qiskit. The model is one dimensional, and defined as</p>
<p><span class=""math-container"">$$
H = \sum_{\langle i,j\rangle} t_{ij} c^\dagger_i c_j
$$</span></p>
<p>where <span class=""math-container"">$\langle i,j\rangle$</span> denotes the nearest neighbor coupling with strength <span class=""math-container"">$t_{ij}$</span>. The important aspect of the model is that the coupling is dimerized in the following sense. If we label the sites as 1,2,3,4...., then the nearest neighbor coupling <span class=""math-container"">$t_{ij}$</span> reads, for example,</p>
<p><span class=""math-container"">$$
t_{1,2} = 1, t_{2,3} = 2 , t_{3,4} = 1 , t_{4,5} = 2, etc
$$</span></p>
<p>which is alternating.</p>
<p>I try to pretend this is a molecular Hamiltonian and realize it in the same way with &quot;FermionicOperator&quot;. However, I am not sure how to properly index the &quot;one-body&quot; integral here, which is the nearest neighbor coupling <span class=""math-container"">$t_{ij}$</span> here.</p>
",<qiskit><programming><ibm-q-experience><hamiltonian-simulation>,10/01/2020 23:41,13991.0,13991.0,"<p>I don't think it really matter how you index your <span class=""math-container"">$t_{ij}$</span>. As you mentioned you can use <code>FermionicOperator</code> all you need to do is define the one body integral. This of course can be done in many ways. Here is a convenient way.</p>
<pre><code>def ssh_ham(gamma, lamda, n): 
    sigmax = np.array([[0,1],[1,0]], dtype=np.complex_)
    sigmay = np.array([[0,-1j],[1j,0]], dtype=np.complex_)

    op_eye_x = np.eye(n)
    op_cos_x = 1/2*(np.eye(n, k=1) + np.eye(n,k=-1))
    op_sin_x = 1j/2*(np.eye(n, k=1) - np.eye(n,k=-1))

    h = np.kron(gamma*op_eye_x + lamda*op_cos_x, sigmax) + np.kron(lamda*op_sin_x, sigmay)

    return h 
</code></pre>
<p>This function would return the one-body integral for you. In this function, the <span class=""math-container"">$\sigma$</span> degree of freedom represents the two atoms in the unit cell, and <span class=""math-container"">$n$</span> represents how many unit cells you have in the SSH chain, and for the dimmerized limit you asked for you can take <span class=""math-container"">$\gamma = 1,\ \lambda = 2 $</span>. You can use the output of this function <code>fer_op = FermionicOperator(h1 = ssh_ham(1,2,10))</code></p>
<p>That being said, I'm not sure what the benefit would be. Trying to solve this Hamiltonian using VQE for example is an over-kill since this Hamiltonian can be readily diagonalized from its one-body Hamiltonian. Putting this on a quantum computer would give you <span class=""math-container"">$2n$</span> qubits, this is a Hilbert space of <span class=""math-container"">$2^n$</span> dimensions, whereas you can diagonalize the the Hamiltonian by diagonalizing the <span class=""math-container"">$2n \times 2n$</span> matrix <span class=""math-container"">$t_{ij}$</span>.</p>
",10/02/2020 12:58,Tooling," The user is trying to implement a specific model, the dimerized tight-binding Hamiltonian, in Qiskit using the FermionicOperator. They are seeking advice on how to properly index the one-body integral in this context, which involves understanding and using the features of the Qiskit tool.", Tooling,,,,Tooling,
13992.0,Custom Mixer for QAOA: Error 'Operator' object has no attribute 'primitive_strings',"<p>I like to use as custom Mixer Hamiltonian for solving the TSP using QAOA.
The mixer and cost hamiltonians are described here: <a href=""https://arxiv.org/pdf/1709.03489.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1709.03489.pdf</a> - Chapter 5.1.</p>
<p>Therefore I need to write the custom mixer hamiltonian from equations 54 -58.</p>
<p>Here is the code:</p>
<pre><code>import numpy as np
from qiskit import Aer
from qiskit.aqua import QuantumInstance
from qiskit.quantum_info.operators import Operator, Pauli
from qiskit.aqua.operators.list_ops import SummedOp
from qiskit.aqua.algorithms import QAOA
from qiskit.aqua.components.optimizers import SPSA
from qiskit.optimization.applications.ising importtsp


def pauli(pos, num_qubits, label):
    label = 'I'*(pos) + label + 'I'*(num_qubits-pos-1)
    assert(len(label) == num_qubits)
    return Operator(Pauli(label=label))

def s_plus(number_of_nodes, city, time):
    num_qubits = number_of_nodes**2
    qubit = time * number_of_nodes + city
    return pauli(qubit, num_qubits, &quot;X&quot;) + pauli(qubit, num_qubits, &quot;Y&quot;)

def s_minus(number_of_nodes, city, time):
    num_qubits = number_of_nodes**2
    qubit = time * number_of_nodes + city
    return pauli(qubit, num_qubits, &quot;X&quot;) - pauli(qubit, num_qubits, &quot;Y&quot;)

def create_mixer_operators(n):
    &quot;&quot;&quot;
    Creates mixer operators for the QAOA.
    It's based on equations 54 - 58 from https://arxiv.org/pdf/1709.03489.pdf
    Indexing here comes directly from section 4.1.2 from paper 1709.03489, equations 54 - 58.
    &quot;&quot;&quot;
    mixer_operators = []
    for t in range(n - 1):
        for city_1 in range(n):
            for city_2 in range(n):
                i = t
                u = city_1
                v = city_2
                first_part = 1
                first_part *= s_plus(n, u, i)
                first_part *= s_plus(n, v, i+1)
                first_part *= s_minus(n, u, i+1)
                first_part *= s_minus(n, v, i)

                second_part = 1
                second_part *= s_minus(n, u, i)
                second_part *= s_minus(n, v, i+1)
                second_part *= s_plus(n, u, i+1)
                second_part *= s_plus(n, v, i)
                mixer_operators.append(first_part + second_part)
    return mixer_operators

seed = 10598
n = 3
p = 2
num_qubits = n ** 2

# Generate random tsp
ins = tsp.random_tsp(n, seed=seed)

qubitOp, offset = tsp.get_operator(ins)

# Running in quantum simulation
aqua_globals.random_seed = np.random.default_rng(seed)
backend = Aer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed)
mixer = create_mixer_operators(n)
mixer_op = SummedOp(mixer)

spsa = SPSA(maxiter=300)
qaoa = QAOA(operator=qubitOp, mixer=mixer_op, p=p, optimizer=spsa, quantum_instance=quantum_instance)

circuits = qaoa.construct_circuit([0]*(2*p))
</code></pre>
<p>When runnning it I get:</p>
<pre><code>    ---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-113-bd68aaa30bfc&gt; in &lt;module&gt;
----&gt; 1 circuits = qaoa.construct_circuit([0]*(2*p))

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in construct_circuit(self, parameter)
    358             A list of the circuits used to compute the expectation value.
    359         &quot;&quot;&quot;
--&gt; 360         expect_op = self.construct_expectation(parameter).to_circuit_op()
    361 
    362         circuits = []

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in construct_expectation(self, parameter)
    331             wave_function = self.var_form.assign_parameters(param_dict)
    332         else:
--&gt; 333             wave_function = self.var_form.construct_circuit(parameter)
    334 
    335         # Expectation was never created, try to create one

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/qaoa/var_form.py in construct_circuit(self, parameters, q)
     96 
     97         evolution = EvolutionFactory.build(self._cost_operator)
---&gt; 98         circuit = evolution.convert(circuit)
     99         return circuit.to_circuit()
    100 

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in convert(self, operator)
    100         #     # Sort into commuting groups
    101         #     operator = self._grouper.convert(operator).reduce()
--&gt; 102         return self._recursive_convert(operator)
    103 
    104     def _recursive_convert(self, operator: OperatorBase) -&gt; OperatorBase:

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in _recursive_convert(self, operator)
    127                 return operator.primitive.__class__(converted_ops, coeff=operator.coeff)
    128         elif isinstance(operator, ListOp):
--&gt; 129             return operator.traverse(self.convert).reduce()
    130 
    131         return operator

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in traverse(self, convert_fn, coeff)
    161             return ListOp([convert_fn(op) for op in self.oplist],  # type: ignore
    162                           combo_fn=self.combo_fn, coeff=coeff, abelian=self.abelian)
--&gt; 163         return self.__class__([convert_fn(op) for op in self.oplist],  # type: ignore
    164                               coeff=coeff, abelian=self.abelian)
    165 

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in &lt;listcomp&gt;(.0)
    161             return ListOp([convert_fn(op) for op in self.oplist],  # type: ignore
    162                           combo_fn=self.combo_fn, coeff=coeff, abelian=self.abelian)
--&gt; 163         return self.__class__([convert_fn(op) for op in self.oplist],  # type: ignore
    164                               coeff=coeff, abelian=self.abelian)
    165 

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in convert(self, operator)
    100         #     # Sort into commuting groups
    101         #     operator = self._grouper.convert(operator).reduce()
--&gt; 102         return self._recursive_convert(operator)
    103 
    104     def _recursive_convert(self, operator: OperatorBase) -&gt; OperatorBase:

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in _recursive_convert(self, operator)
    104     def _recursive_convert(self, operator: OperatorBase) -&gt; OperatorBase:
    105         if isinstance(operator, EvolvedOp):
--&gt; 106             if not {'Pauli'} == operator.primitive_strings():
    107                 logger.warning('Evolved Hamiltonian is not composed of only Paulis, converting to '
    108                                'Pauli representation, which can be expensive.')

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/evolved_op.py in primitive_strings(self)
     53 
     54     def primitive_strings(self) -&gt; Set[str]:
---&gt; 55         return self.primitive.primitive_strings()  # type: ignore
     56 
     57     @property

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in primitive_strings(self)
    126 
    127     def primitive_strings(self) -&gt; Set[str]:
--&gt; 128         return reduce(set.union, [op.primitive_strings() for op in self.oplist])
    129 
    130     @property

~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in &lt;listcomp&gt;(.0)
    126 
    127     def primitive_strings(self) -&gt; Set[str]:
--&gt; 128         return reduce(set.union, [op.primitive_strings() for op in self.oplist])
    129 
    130     @property

AttributeError: 'Operator' object has no attribute 'primitive_strings'
</code></pre>
<p>How do I resolve the error? This is my first project with qiskit and I am not sure where to start.</p>
",<qiskit><programming><qaoa>,10/02/2020 13:15,13993.0,13993.0,"<p><code>Operator</code> is part of Qiskit-Terra's module quantum-info. You should use <code>PrimitiveOp</code> from Qiskit-Aqua.</p>
<pre><code>from qiskit.aqua.operators import PrimitiveOp

def pauli(pos, num_qubits, label):
    label = 'I'*(pos) + label + 'I'*(num_qubits-pos-1)
    assert(len(label) == num_qubits)
    return PrimitiveOp(Pauli(label=label))
</code></pre>
<p>Note however that for composing an Operator in Aqua with another you should use <code>@</code> and <code>*</code> for multiplying with a scalar.</p>
<p><strong>Edit:</strong> Trying to explain the new error you are getting, i think the following is happening: At some point, the <code>QAOA</code> algorithm tries to build the parameterized circuit corresponding to your variatonal form as specified by the cost Hamiltonian and the mixer operator. However, the mixer is composite (defined with sums and compositions) and tries to reduce it. This causes the <code>coeff</code> (all Operators in Aqua have a coefficient) field to be a complex number. But then, since multiplication of a <code>Parameter</code> with a <code>complex</code> is not supported, an error is raising.</p>
<p>A simpler example may be helpful in order to see what's going wrong.
Let's say, we want to build a parameterized circuit corresponding to the evolution of <span class=""math-container"">$ X \otimes X $</span> operator (i.e <span class=""math-container"">$ e^{-i \beta (X \otimes X)} $</span>). We will try two different ways. The second one will fail.</p>
<pre><code>from qiskit.circuit import Parameter
from qiskit.aqua.operators import X, I, EvolutionFactory, EvolvedOp

def evolve(H):
    beta = Parameter('Î²')
    
    evolution = EvolutionFactory.build(operator=beta * H)
    eop = EvolvedOp(beta * H)
    
    return evolution.convert(eop)


H = X ^ X
print(H.coeff)
print(type(H.coeff))
evolve(H)
---
1.0
float
Works


H = (X ^ I) @ (I ^ X)
print(H.coeff)
print(type(H.coeff))
evolve(H)
---
1+0j
complex
TypeError: unsupported operand type(s) for *: 'complex' and 'Parameter'
</code></pre>
<p>Putting all this aside, as a workaround you could do the calculations on eq.58 (as already briefly explained on the orginal <a href=""https://arxiv.org/pdf/1709.03489.pdf"" rel=""nofollow noreferrer"">paper</a>) and after eliminating some terms you get:
<span class=""math-container"">\begin{align*} 
\frac{1}{2}H_{i, u, v} &amp;= X_{u, i} X_{v, i + 1} X_{u, i + 1} X_{v, i} \\
&amp; - X_{u, i} X_{v, i + 1} Y_{u, i + 1} Y_{v, i} \\
&amp; + X_{u, i} Y_{v, i + 1} X_{u, i + 1} Y_{v, i} \\
&amp; + X_{u, i} Y_{v, i + 1} Y_{u, i + 1} X_{v, i} \\
&amp; + Y_{u, i} X_{v, i + 1} X_{u, i + 1} Y_{v, i} \\
&amp; + Y_{u, i} X_{v, i + 1} Y_{u, i + 1} X_{v, i} \\
&amp; - Y_{u, i} Y_{v, i + 1} X_{u, i + 1} X_{v, i} \\
&amp; + Y_{u, i} Y_{v, i + 1} Y_{u, i + 1} Y_{v, i}
\end{align*}</span>
and implement this operator as your mixer (sum of 8 <code>PauliOp</code>s).</p>
<p>For convenience, here is my implementation.</p>
<pre><code>from itertools import combinations

def mixer_operators(n):
    
    mixer = []
    n_qubits = pow(n, 2)
    
    for i in range(n - 1):
        for u, v in combinations(range(n), 2):
                
                qu = i * n + u
                qv = i * n + v
                
                x = [0] * n_qubits
                x[qu] = x[qv] = x[qu + n] = x[qv + n] = 1
                
                Hi = 0
                
                # XXXX term
                z = [0] * n_qubits
                pauli = Pauli(z, x)
                pauli = PrimitiveOp(pauli)
                
                Hi += pauli
                
                
                # YYYY term
                z = [0] * n_qubits
                z[qu] = z[qv] = z[qu + n] = z[qv + n] = 1
                pauli = Pauli(z, x)
                pauli = PrimitiveOp(pauli)
                
                Hi += pauli
                
                
                # XXYY and similar terms (two Ys)
                for q0, q1 in combinations([qu, qv, qu + n, qv + n], 2):
                    z = [0] * n_qubits
                    z[q0] = z[q1] = 1
                    pauli = Pauli(z, x)
                    
                    coeff = 1
                    if (q0, q1) in [(qu, qv), (qu + n, qv + n)]:
                        coeff = -1                
                    pauli = PrimitiveOp(pauli, coeff)
                    
                    Hi += pauli
                
                
                mixer.append(2 * Hi)
                
    return SummedOp(mixer)
</code></pre>
",10/02/2020 13:48,Errors,"The user is encountering an error while implementing a custom mixer Hamiltonian in Qiskit for quantum computing. They are seeking help to resolve this error, making it fall under the ""Errors"" category.", Errors,,,,Errors,
14001.0,Best way to test the performance of a simulated quantum algorithm in Q#,"<p>for a student report about solving graph coloring with Grover's Algorithm, I have to talk about the performance of simulated Grover's Algorithm to solve graph coloring. I don't really know how to approach some of the points I have to talk about. I have many things to talk about :</p>
<ul>
<li>The execution time : this is hard to measure for &quot;big&quot; graphs like 7/8 node graphs, as the runtime can take more than half an hour and I cannot average running the same program many times. I can still do something less rigorous but do you have any tips ?</li>
<li>The resources used : this is something I really don't know how to take on. I can guess the complexity can be calculated using Big-O notation, but how do I get this on a simulated problem ?</li>
<li>Testing operations : this is something I don't know how to do, but I know there is a method for. I know my program works, but is there any rigorous testing for operations in Q# ?</li>
<li>Estimate for a quantum computer. I know there is the quantum trace simulator, however I cannot see how to provide measurement probabilities for the graph coloring problem.
This is pretty packed in big questions. This is new terrain for me so I hope someone can help. If you have more suggestions about how to test the program, I am open :).</li>
</ul>
",<q#><performance>,10/03/2020 21:30,14003.0,14003.0,"<ol>
<li>Validating your solution.</li>
</ol>
<p>Q# offers a variety of methods to test your code, depending on what exactly you want to test. In this case, the main part seems to be validating the oracle you implemented for graph coloring problem. In the <a href=""https://github.com/microsoft/QuantumKatas/blob/main/GraphColoring/"" rel=""nofollow noreferrer"">GraphColoring kata</a> and other oracle-focused katas we usually rely on comparison of the quantum computation result with the classically computed result for all possible basis vectors. (That's how the oracles are defined - implement them using reversible operations only so that they act properly on the basis vectors, and you're guaranteed that they'll act properly on linear combinations of those.)</p>
<p>More specifically, in the <a href=""https://github.com/microsoft/QuantumKatas/blob/a956b54d6f96b4506c43672c9bfbd0609da32d0c/GraphColoring/Tests.qs#L223"" rel=""nofollow noreferrer"">test that covers graph coloring oracle</a> we:</p>
<ul>
<li>iterate over all possible classical inputs,</li>
<li>encode each of them as a basis state on the input qubits,</li>
<li>apply the oracle to the qubits to perform the computation,</li>
<li>read out the result,</li>
<li>and compare it to the result of the same computation done classically (i.e., validating the graph coloring classically).</li>
<li>You can also verify that the oracle application doesn't modify the input states by measuring the input qubits and verifying that their state is the same state you've encoded in the input, like we do in the <a href=""https://github.com/microsoft/QuantumKatas/blob/a956b54d6f96b4506c43672c9bfbd0609da32d0c/RippleCarryAdder/Tests.qs#L122"" rel=""nofollow noreferrer"">RippleCarryAdder kata</a>.</li>
</ul>
<p>This doesn't guarantee that you haven't done something odd like introduce a phase or use a gate other than X and controlled-X; if you want to check for that as well, you can use <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/machines/toffoli-simulator"" rel=""nofollow noreferrer"">Toffoli simulator</a> instead of the typical full-state simulator: it will limit the pool of gates you can use, and give you an extra benefit of speeding up the oracle simulation.</p>
<hr />
<ol start=""2"">
<li>Resource estimation.</li>
</ol>
<p>The other three questions are all tied to resource estimation of a quantum algorithm, so I'll bundle them together.</p>
<p>You probably don't really care about the actual runtime of a simulation on a classical computer that much, since it's not an indication of the runtime of the algorithm on a quantum computer. Small tweaks to the order in which you allocate qubits, for example, can reduce your simulation time quite dramatically without having impact on the quantum runtime, as I explored in <a href=""https://github.com/tcNickolas/MiscQSharp/tree/master/DecoratingTheTree2019-Optimize#decorating-the-christmas-tree-using-grovers-search"" rel=""nofollow noreferrer"">this blog post</a>. If you find a tweak like this, you'll probably want to report it, since it highlights interesting differences between simulation and actual quantum runtime, but otherwise I wouldn't aim for a very precise simulation runtime estimate - saying &quot;around 35 minutes&quot; would be fine.</p>
<p><a href=""https://docs.microsoft.com/en-us/quantum/user-guide/machines/resources-estimator"" rel=""nofollow noreferrer"">Resource estimation</a> is the best way to estimate the resources used without counting the gates manually. A neat way to work around the need to provide probabilities is to implement an operation that performs Grover's search loop alone (without the measurements) and to resource-estimate it, since the measurements will not add extra qubits or gates to the algorithm. Then you'll get values like the circuit depth in terms of 2-qubit gates, which will allow you to estimate the algorithm runtime on a quantum computer, once you make some assumptions about single gate speed.</p>
",10/04/2020 00:15,Learning,"The user is seeking guidance and information on various aspects related to solving graph coloring problems with Grover's Algorithm. They are looking for tips, insights, and suggestions on how to approach and address these points, making it a learning-oriented inquiry.",Learning,,,,Learning,
14017.0,How do I visualize the action of Pauli $X$ and $Y$ gates on $|0\rangle$?,"<p>I visualize Pauli Gates making rotations by Ï radians about the x, y, and z axes on the Bloch sphere.</p>
<p>If this is the case, then how Pauli-X and Pauli-Y gates applied to <span class=""math-container"">$|0\rangle$</span> differ? As both should rotate the <span class=""math-container"">$|0\rangle$</span> state to same location.</p>
",<quantum-gate><programming><pauli-gates>,10/05/2020 04:32,14021.0,14021.0,"<p>Applying X gate to the <span class=""math-container"">$|0\rangle$</span> state gives you <span class=""math-container"">$|1\rangle$</span>, and applying Y gate to the <span class=""math-container"">$|0\rangle$</span> state gives you <span class=""math-container"">$i|1\rangle$</span>. These states differ only by a global phase (the <span class=""math-container"">$i$</span> scalar multiplier in the second case), so they are not physically distinguishable (you cannot set up an experiment to observe the difference between them). Bloch sphere represents all states that differ by a global phase as one point on it, so you won't be able to see the difference using it.</p>
<p>X and Y gates differ in their effect on most other states, though (except <span class=""math-container"">$|1\rangle$</span>, which will give you the same issue).</p>
",10/05/2020 05:22,Theoretical ,The user is asking about the theoretical concept of how Pauli-X and Pauli-Y gates operate on the |0? state in quantum computing. They are seeking to understand the difference in the resulting states due to the different axes of rotation,Theoretical,,,,Theoretical ,
14029.0,Return outputs with zero counts,"<p>I am running a simple 3 qubit circuit which produces the following results:</p>
<pre><code>{'000': 5, '001': 3, '010': 10, '100': 5, '101': 7, '110': 7, '111': 4}
</code></pre>
<p>There are no counts of 011. Is there a simple way within qiskit to also return the result '011': 0? So the final results would be</p>
<pre><code>{'000': 5, '001': 3, '010': 10,'011': 0, '100': 5, '101': 7, '110': 7, '111': 4}
</code></pre>
<p>Currently when I run this circuit I get an error as I am trying to call res['011'], where res is the list of results. I cannot just increase the number of shots unfortunately I am constrained to this number of qubits.</p>
",<qiskit><programming><experiment>,10/05/2020 21:21,14030.0,14030.0,"<p>You can use <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Counts.get.html#qiskit.result.Counts.get"" rel=""nofollow noreferrer"">.get()</a> and return zero as the default value.</p>
<p><code>res.get('011', 0)</code></p>
",10/05/2020 21:55, Tooling,"The user is seeking a solution to a specific issue related to the behavior of their quantum circuit results in Qiskit. They want to know how to include results with zero counts, which is a tooling-related question in quantum programming.",Tooling,,,, Tooling,
14044.0,How can I run a job as offline on real hardware?,"<p>Can I run circuits on real hardware as offline? I mean that a job with 100 circuits may take a long time and I want to shot down my laptop in running time. In the meantime, can the real hardware run all of the circuits in the job, and in another time I can obtain my results? Or is it necessary my laptop to be turned on till I receive the last result? If I need any code for this issue, I would be very grateful anyone can provide it.</p>
",<programming><ibm-q-experience>,10/07/2020 19:34,14045.0,14045.0,"<p>All jobs sent to IBMQ backends are asynchronous. You just need to save the job ID and use the ID retrieve it later. For example:</p>
<pre><code>provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_vigo')
job = execute(circuits, backend)
print(job.job_id())
</code></pre>
<p>Once the job is submitted, you can turn off your laptop. Then when you're ready to get the results, do</p>
<pre><code>result = backend.retrieve_job(job_id).result()
</code></pre>
<p>If you forget to write down the job ID, you can always find it on the IQX dashboard or use <code>backend.jobs()</code> to query for it.</p>
",10/07/2020 20:46,Tooling,The user is asking about how to run quantum circuits on real hardware in an offline mode using Qiskit. This involves understanding and using the features of the Qiskit tool.,Tooling,,,,Tooling,
14056.0,What is the Clifford gates selection probability distribution used in the generation of randomized benchmarking circuits?,"<p>I've read that in standard randomized benchmarking implementations the random quantum circuits are generated through random gate selection from a uniformly distributed Clifford set of either 1 or 2-qubit gates i.e. {H, X, Y, Z, S, T} and {iSWAP, CZ}, however the circuits generated using <a href=""https://qiskit.org/documentation/stubs/qiskit.ignis.verification.randomized_benchmarking_seq.html"" rel=""nofollow noreferrer""><code>randomized_benchmarking_seq</code></a> do not seem to follow this for the following reasons:</p>
<ol>
<li>Random circuits do <strong>NOT</strong> contain T, iSWAP and CZ gates</li>
<li>Random circuits do contain CX gates</li>
<li>There does not appear to be a uniform distribution in gate selection, for example gates H and S gates appear more frequently than X, Y, Z and CX gates</li>
</ol>
<p>Is this observation correct? and if so what is the actual distribution for <code>randomized_benchmarking_seq</code>? and how can uniformly distributed random circuits be generated?</p>
",<qiskit><programming><random-quantum-circuit><randomised-benchmarking>,10/08/2020 13:22,14057.0,14057.0,"<p>Random Clifford elements are generated using the following function:</p>
<p><a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.random_clifford.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.random_clifford.html</a></p>
<p>Then they are synthesized into basic gates (CX, S, Sdg, H, Paulis) using the following function:</p>
<p><a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Clifford.to_circuit.html#qiskit.quantum_info.Clifford.to_circuit"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.Clifford.to_circuit.html#qiskit.quantum_info.Clifford.to_circuit</a></p>
<p>This is based on the following paper:</p>
<p>S. Bravyi and D. Maslov, Hadamard-free circuits expose the structure of the Clifford group. <a href=""https://arxiv.org/abs/2003.09412"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2003.09412</a></p>
<p>For a simpler explanation on the structure of the 1-qubit and 2-qubit Clifford groups see the following tutorial:</p>
<p><a href=""https://github.com/qiskit-community/qiskit-community-tutorials/blob/master/terra/qis_adv/Clifford_Group.ipynb"" rel=""nofollow noreferrer"">https://github.com/qiskit-community/qiskit-community-tutorials/blob/master/terra/qis_adv/Clifford_Group.ipynb</a></p>
",10/08/2020 13:49,Tooling,The user is asking about the specific implementation of the randomized_benchmarking_seq function in Qiskit. They are seeking to understand the distribution of gates used by this function and how to generate random circuits with a uniform distribution of gates.,Tooling,,,,Tooling,
14058.0,Qiskit transpile with different set of basis gates,"<p>I want to use the Qiskit transpile function to decompose an arbitrary unitary matrix/ quantum circuit into a special kind of basis gates.
(<code>from qiskit.compiler import transpile</code>)</p>
<p>But for me it seems the only accepted basis gates are 'u1', 'u2', 'u3' and 'cx'.
Is there a way to use for example 'rx', 'ry' and 'cx' as basis gates instead of 'u1', 'u2', 'u3' and 'cx'?</p>
<p>The following error</p>
<p><strong>Exception has occurred: QiskitError
&quot;Cannot unroll the circuit to the given basis, ['id', 'ry', 'rx', 'cx']. No rule to expand instruction h.&quot;</strong></p>
<p>for example is obtained from the code:</p>
<pre><code>from qiskit.quantum_info import Operator
from qiskit.compiler import transpile
import matplotlib.pyplot as plt
from qiskit.compiler.transpile import CouplingMap

coupling_string = [[0, 1], [0,2], [1,2]]

CM = CouplingMap(coupling_string)

qc = QuantumCircuit(3)

qc.h(0)
qc.h(1)
qc.h(2)

result = transpile(qc, coupling_map=CM, basis_gates=['id', 'ry', 'rx', 'cx'], optimization_level=1, seed_transpiler=1) 
result.draw(output='mpl')
plt.show()
</code></pre>
",<qiskit><programming>,10/08/2020 15:48,14060.0,14060.0,"<p>Which version of Qiskit are you running? Support for arbitrary basis translation was added very recently in Qiskit 0.20.0/Qiskit-Terra 0.15.0. <a href=""https://i.stack.imgur.com/wprAp.png"" rel=""nofollow noreferrer"">1</a> If you're running an older version of Qiskit then the transpiler will fail like this because the unroller didn't know how to use that basis set. However, when using the latest Qiskit release it will output display a circuit image like:</p>
<p><a href=""https://i.stack.imgur.com/wprAp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wprAp.png"" alt=""enter image description here"" /></a></p>
<p>It's worth noting that the transpilation isn't great because the 1 qubit optimization pass doesn't understand arbitrary basis sets yet and still only works for u1, u2, u3, which is why that output is so large. There is work pending on fixing this <a href=""https://github.com/Qiskit/qiskit-terra/pull/3658"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/pull/3658</a></p>
<p><a href=""https://i.stack.imgur.com/wprAp.png"" rel=""nofollow noreferrer"">1</a> <a href=""https://qiskit.org/documentation/release_notes.html#qiskit-0-20-0"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/release_notes.html#qiskit-0-20-0</a></p>
",10/08/2020 16:05,Tooling,The user is asking about how to use the transpile function in Qiskit to decompose a quantum circuit into a specific set of basis gates. This involves understanding and using the features of the Qiskit tool.,Tooling,,,,Tooling,
14073.0,How to get circuit run time in Q#,"<p>What is the best way to get the circuit run time in Q# ?</p>
<p>More precisely, I run a circuit using dotnet -run command and I would like to know how many time it took for running my circuit. Actually I compute the delay between the moment I start the command and the return, but I suppose it includes building time, I really just need the circuit running time.</p>
<p>Thank you.</p>
<p>Best regards.</p>
",<q#>,10/09/2020 12:12,14079.0,14079.0,"<p>Here is what I did when I was exploring optimizing the code to run as fast as possible in simulation (here is the <a href=""https://github.com/tcNickolas/MiscQSharp/tree/master/DecoratingTheTree2019-Optimize#decorating-the-christmas-tree-using-grovers-search"" rel=""nofollow noreferrer"">blog post describing the things I looked into</a>).</p>
<ol>
<li>Add a classical driver to your project that calls your Q# code.<br />
I used C# (you can also use Python if you prefer it) and the code you'll use is going to be something like this:</li>
</ol>
<pre><code>using QuantumSimulator qsim = new QuantumSimulator();
bool[] result = GroversSearch.Run(qsim).Result.ToArray();
</code></pre>
<ol start=""2"">
<li>In this classical driver, wrap the call to quantum operation's <code>Run</code> in classical code that tracks the start and the end time. Here is C# code for it:</li>
</ol>
<pre><code>Stopwatch stopWatch = new Stopwatch();
stopWatch.Start();
// ... call quantum operation here ...
stopWatch.Stop();
TimeSpan ts = stopWatch.Elapsed;
string elapsedTime = String.Format(&quot;{0:00}:{1:00}:{2:00}.{3:00}&quot;,
    ts.Hours, ts.Minutes, ts.Seconds,
    ts.Milliseconds / 10);
Console.WriteLine(&quot;RunTime &quot; + elapsedTime);
</code></pre>
<p>You can do any pre-processing before the call to quantum code and any post-processing afterwards, and they won't count towards the execution time.</p>
<p>You can see the full example <a href=""https://github.com/tcNickolas/MiscQSharp/blob/master/DecoratingTheTree2019-Optimize/Driver.cs#L52"" rel=""nofollow noreferrer"">here</a>.</p>
",10/09/2020 20:42,Tooling,The user is asking about how to measure the runtime of a quantum circuit in Q#. This involves understanding and using the features of the Q# tool, Tooling,,,,Tooling,
14096.0,Using the qiskit_textbook Package,"<p>I've installed the qiskit_textbook package in Anaconda on Windows 10 using</p>
<pre><code>pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src
</code></pre>
<p>based on the instructions at <a href=""https://qiskit.org/textbook/ch-prerequisites/setting-the-environment.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-prerequisites/setting-the-environment.html</a> .</p>
<p>But I don't see any jupyter notebooks to open. How do you begin working with the qiskit tutorial notebooks? Thanks for any guidance.</p>
",<qiskit><programming>,10/11/2020 15:33,14123.0,14123.0,"<p>I would recommend trying the other way that they suggest, which is</p>
<pre><code>git clone https://github.com/qiskit-community/qiskit-textbook.git
cd qiskit-textbook
pip install ./qiskit-textbook-src
</code></pre>
<p>You can find the juptyer notebooks with the content of the qiskit textbook in <code>qiskit-textbook/content</code>. There, you will find many different folders, each corresponding to a given chapter in the qiskit textbook.</p>
<p>If you would rather have access to the qiskit tutorials, you can access them on qiskit.org/documentation under the tab Tutorials, or download them locally with the command</p>
<pre><code>git clone https://github.com/Qiskit/qiskit-tutorials.git
</code></pre>
<p>and in the <code>tutorials</code> folder you will find a folder corresponding to each category of tutorials.</p>
",10/12/2020 20:30,Tooling," The user is asking for guidance on how to work with Qiskit tutorial notebooks after installing the qiskit_textbook package, which falls under the category of tool and software usage in quantum programming.",Tooling,,,,Tooling,
14098.0,"QUBO, Ising Hamiltonians and VQA","<p>I understand that usually the combinatorial optimisation problems are turned into QUBO, which has a very simple mapping to Ising Hamiltonians. Ising Hamiltonians in turn have the desired properties of being diagonal in computational basis and the ground state is one of the computational basis vectors. It is thus easy to measure the state in the computational basis and obtain the bit string solution.</p>
<p>The problem is that Ising Hamiltonian and QUBO are quadratic in its terms and allows at most 2 body interactions. I recently came across a paper about integer factoring expressed as optimization problem (<a href=""https://arxiv.org/pdf/1411.6758.pdf"" rel=""nofollow noreferrer"">Quantum factorization of 56153 with only 4 qubits</a>), where the cost function is a third degree polynomial. I was able to reduce this to 2 body interactions and thus make the problem QUBO, map it to Ising Hamiltonian and solve it on IBM machines using QAOA. However, this conversion between polynomial of degree 3 to degree 2 costs me extra qubits.</p>
<p>What is then the general approach when you have 3/4 body interactions, for example as in this paper I linked? The authors of this, as well as the authors of previous works they cite, are not concerned with the fact that this is not QUBO. Are there alternatives to Ising Hamiltonians and QUBOs in such cases? Is it correct that we could use any form of Hamiltonian (not necessarily Ising) for QAOA/VQE as long as it is decomposable into tensor products of Pauli Z operators (which makes it diagonal in computational basis)?</p>
",<programming><vqe><optimization><qaoa>,10/11/2020 17:36,14114.0,14114.0,"<p>In the definition from this paper [<a href=""https://arxiv.org/abs/1706.02998"" rel=""nofollow noreferrer"">1</a>] the cost Hamiltonian is not restricted to the Ising Hamiltonian case. The paper also has an answer for the mentioned &quot;general approach for <span class=""math-container"">$3/4$</span> (<span class=""math-container"">$n$</span>) body interactions&quot;.</p>
<p><strong>A direct quote from [<a href=""https://arxiv.org/abs/1706.02998"" rel=""nofollow noreferrer"">1</a>]:</strong></p>
<blockquote>
<p>From a classical cost function that is a polynomial in binary variables <span class=""math-container"">$x_1 , . . . , x_n $</span>, we can construct a Hamiltonian <span class=""math-container"">$H_C$</span> on <span class=""math-container"">$n$</span> qubits by first rewriting the cost function in terms of variables <span class=""math-container"">$z_i \in \{â1, 1 \}$</span>, where <span class=""math-container"">$x_i = (1 â z_i )/2$</span> to obtain a polynomial <span class=""math-container"">$f (z) = \sum_{C \subset \{1,...n\}} \alpha_C \prod_{j \in C} z_j$</span> and then replacing each occurrence of <span class=""math-container"">$z_i$</span> with the Pauli operator <span class=""math-container"">$\sigma_i^z$</span> . Thus, <span class=""math-container"">$H_C$</span> is diagonal in the <span class=""math-container"">$\sigma_z$</span>-basis and takes the form</p>
<p><span class=""math-container"">$$H_C = \sum_{C \subset \{1,...,n\}} \alpha_C \bigotimes_{j \in C} \sigma_i^z \tag{2}$$</span></p>
<p>where <span class=""math-container"">$C$</span> is a subset of all qubits, and <span class=""math-container"">$\alpha_C$</span> is a real coefficient for the many-body coupling between qubits in the subset <span class=""math-container"">$C$</span>.</p>
</blockquote>
<p><strong>This means</strong> that if we have a classical cost function <span class=""math-container"">$f(x) = 4 x_1 +6x_1 x_2 - 2x_2 x_3 x_4$</span>, we should replace <span class=""math-container"">$x$</span>s with <span class=""math-container"">$z$</span>s and obtain:</p>
<p><span class=""math-container"">$$f(z) =  2(1 - z_1) + 3 (1 - z_1) (1 - z_2) - (1 - z_2) (1 - z_3) (1 - z_4)$$</span></p>
<p>After simplifying replace <span class=""math-container"">$z$</span>s with <span class=""math-container"">$\sigma_z$</span>s:</p>
<p><span class=""math-container"">$$H_C = 4 I - 5 \sigma_1^z - 2 \sigma_2^z + \sigma_3^z + \sigma_4^z + 3 \sigma_1^z \sigma_2^z -\sigma_2^z \sigma_3^z -\sigma_3^z \sigma_4^z -\sigma_2^z \sigma_4^z + \sigma_2^z \sigma_3^z \sigma_4^z$$</span></p>
<p>and done. Note that this procedure will work also for QUBO<span class=""math-container"">$\rightarrow$</span>Ising Hamiltonian (see this <a href=""https://quantumcomputing.stackexchange.com/a/11665/9459"">answer</a>). This way we will be able to construct the cost Hamiltonian with the desired (in QAOA) property:</p>
<p><span class=""math-container"">$$H_C |x\rangle = f(x)|x\rangle$$</span></p>
<p>where <span class=""math-container"">$x = x_1 x_2 x_3 x_4$</span> is a bitstring.</p>
<p><strong>An example</strong> of the cost Hamiltonian with <span class=""math-container"">$3$</span>-body coupling between qubits can be found in this paper [<a href=""https://arxiv.org/abs/1412.6062"" rel=""nofollow noreferrer"">2</a>] for the E3LIN2 problem ([<a href=""https://arxiv.org/abs/1412.6062"" rel=""nofollow noreferrer"">2</a>] Eq. <span class=""math-container"">$6$</span> with slightly changed notations):</p>
<p><span class=""math-container"">$$ H_C = \frac{1}{2} \sum_{a &lt; b &lt; c} d_{abc} \sigma_a^z \sigma_b^z \sigma_c^z \tag{6}$$</span></p>
<p>where <span class=""math-container"">$d_{abc}$</span> is <span class=""math-container"">$0$</span> or <span class=""math-container"">$+1$</span> or <span class=""math-container"">$-1$</span>, <span class=""math-container"">$a$</span>, <span class=""math-container"">$b$</span> and <span class=""math-container"">$c$</span> are qubit indexes.</p>
<hr />
<p>[<a href=""https://arxiv.org/abs/1706.02998"" rel=""nofollow noreferrer"">1</a>] <a href=""https://arxiv.org/abs/1706.02998"" rel=""nofollow noreferrer"">Z. Wang, S. Hadfield, Z. Jiang, E. G. Rieffel, &quot;The Quantum Approximation Optimization Algorithm for MaxCut: A Fermionic View&quot;</a></p>
<p>[<a href=""https://arxiv.org/abs/1412.6062"" rel=""nofollow noreferrer"">2</a>] <a href=""https://arxiv.org/abs/1412.6062"" rel=""nofollow noreferrer"">E. Farhi, J. Goldstone, S. Gutmann, &quot;A Quantum Approximate Optimization Algorithm Applied to a Bounded Occurrence Constraint Problem&quot;</a></p>
",10/12/2020 11:44,Theoretical,"The user is inquiring about the theoretical approach to solving optimization problems with higher-degree polynomial cost functions in quantum computing, which falls under the category of theoretical concepts and principles in quantum computing.",Theoretical,,,,Theoretical,
14115.0,I don't get anything when calling circuit.draw(),"<p>I'm following the YouTube tutorials for Programming on Quantum Computers and I've completed everything until I reach <code>circuit.draw()</code> since I don't get <span class=""math-container"">$|0\rangle$</span> or 0 next to <code>q</code> or <code>c</code>. Here's my code:</p>
<pre><code>from qiskit import *

qr = QuantumRegister(2)
cr = ClassicalRegister(2)
circuit = QuantumCircuit(qr, cr)

%matplotlib inline

circuit.draw()

[
q0_0:
q0_1:
c0: 2/
]
</code></pre>
<p>and so when I attempt an H gate, I receive the error  <code>'QuantumRegister' object is not callable</code>:</p>
<pre><code>circuit.h(qr(0))
</code></pre>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-55-c8b4318b743b&gt; in &lt;module&gt;
----&gt; 1 circuit.h(qr(0))

TypeError: 'QuantumRegister' object is not callable
</code></pre>
",<qiskit><programming>,10/12/2020 12:55,14116.0,14116.0,"<p>There is probably a change on the default arguments of <code>draw()</code> function. To reproduce the same visualization as on the youtube video, try:</p>
<pre><code>circuit.draw(initial_state=True, 
             cregbundle=False)
</code></pre>
<p>and add a Hadamard gate like:</p>
<pre><code>circuit.h(qr[0])
</code></pre>
",10/12/2020 13:07, Errors,"The user is encountering errors in their quantum circuit code, specifically with the use of QuantumRegister and applying gates, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,, Errors,
14117.0,Error when running HHL algorithm in Qiskit,"<p>I tried to solve a simple system of two simultaneous linear equations in with HHL algorithm in Qiskit. In particular the system is <span class=""math-container"">$Ax=b$</span>, where
<span class=""math-container"">$$
A = \begin{pmatrix}
1.5 &amp; 0.5 \\
0.5 &amp; 1.5
\end{pmatrix}
$$</span>
and
<span class=""math-container"">$$
b = \begin{pmatrix}
0.9010 \\
-0.4339 
\end{pmatrix}
$$</span>
The matrix <span class=""math-container"">$A$</span> is Hermitian, so HHL should cope with it without any problems.</p>
<p>I wrote following code</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries and configuring account
from qiskit import QuantumCircuit, execute, Aer, IBMQ
import numpy as np
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
#HHL in Qiskit
from qiskit.aqua.algorithms import HHL

matrix_A = np.array([[1.5, 0.5],[0.5, 1.5]])
vector_b = [0.9010, -0.4339]
#x = [0.8184, -0.5747] #expected result

backend = Aer.get_backend('statevector_simulator')
#num_q â Number of qubits required for the matrix Operator instance
#num_a â Number of ancillary qubits for Eigenvalues instance

hhlObject = HHL(matrix = matrix_A, vector = vector_b, quantum_instance = backend, num_q = 2, num_a = 1)

res = hhlObject.run(quantum_instance = backend)
print(res)
</code></pre>
<p>However, this error occured</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-4-071684a21c97&gt; in &lt;module&gt;
      9 hhlObject = HHL(matrix = matrix_A, vector = vector_b, quantum_instance = backend, num_q = 2, num_a = 1)
     10 
---&gt; 11 res = hhlObject.run(quantum_instance = backend)
     12 print(res)

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/quantum_algorithm.py in run(self, quantum_instance, **kwargs)
     68                 self.quantum_instance = quantum_instance
     69 
---&gt; 70         return self._run()
     71 
     72     @abstractmethod

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/hhl.py in _run(self)
    399     def _run(self):
    400         if self._quantum_instance.is_statevector:
--&gt; 401             self.construct_circuit(measurement=False)
    402             self._statevector_simulation()
    403         else:

/opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/hhl.py in construct_circuit(self, measurement)
    204 
    205         # InitialState
--&gt; 206         qc += self._init_state.construct_circuit(&quot;circuit&quot;, q)
    207 
    208         # EigenvalueEstimation (QPE)

AttributeError: 'NoneType' object has no attribute 'construct_circuit'
</code></pre>
<p>I also tried to run <code>construct_circuit</code> method before <code>run</code> method, however, same error was returned.</p>
<p><strong>Could you please tell me how to set parameters of HHL algorithm to run it correctly?</strong></p>
",<qiskit><programming><ibm-q-experience><hhl-algorithm>,10/12/2020 13:39,14271.0,14271.0,"<p>Based on <em>tsgeorgios</em> information about Qiskit manual and the manual content, I created the code below which works as expected.</p>
<pre><code>#BASED ON: https://qiskit.org/textbook/ch-applications/hhl_tutorial.html#4.-Qiskit-Implementation
%matplotlib inline
# Importing standard Qiskit libraries and configuring account
from qiskit import Aer
from qiskit.circuit.library import QFT
from qiskit.aqua.components.eigs import EigsQPE
from qiskit.aqua.components.reciprocals import LookupRotation
from qiskit.aqua.operators import MatrixOperator
from qiskit.aqua.components.initial_states import Custom
import numpy as np
#Linear equations solvers
from qiskit.aqua.algorithms import HHL, NumPyLSsolver #HHL - quantum, NumPyLSolver - classical

def create_eigs(matrix, num_ancillae, num_time_slices, negative_evals):
    ne_qfts = [None, None]
    if negative_evals:
        num_ancillae += 1
        ne_qfts = [QFT(num_ancillae - 1), QFT(num_ancillae - 1).inverse()]
    
    #Construct the eigenvalues estimation using the PhaseEstimationCircuit
    return EigsQPE(MatrixOperator(matrix=matrix),
                   QFT(num_ancillae).inverse(),
                   num_time_slices=num_time_slices,
                   num_ancillae=num_ancillae,
                   expansion_mode='suzuki',
                   expansion_order=2,
                   evo_time=None,
                   negative_evals=negative_evals,
                   ne_qfts=ne_qfts)

def HHLsolver(matrix, vector, backend, no_ancillas, no_time_slices):
    orig_size = len(vector_b)
    #adapt the matrix to have dimension 2^k
    matrix, vector, truncate_powerdim, truncate_hermitian = HHL.matrix_resize(matrix_A, vector_b)

    #find eigenvalues of the matrix wih phase estimation (i.e. calc. exponential of A, apply 
    #phase estimation) to get exp(lamba) and then inverse QFT to get lambdas themselves
    eigs = create_eigs(matrix, no_ancillas, no_time_slices, False)
    #num_q â Number of qubits required for the matrix Operator instance
    #num_a â Number of ancillary qubits for Eigenvalues instance
    num_q, num_a = eigs.get_register_sizes()

    #construct circuit for finding reciprocals of eigenvalues
    reci = LookupRotation(negative_evals=eigs._negative_evals, evo_time=eigs._evo_time)

    #preparing init state for HHL, i.e. the state containing vector b
    init_state = Custom(num_q, state_vector=vector)

    #construct circuit for HHL based on matrix A, vector B and reciprocals of eigenvalues
    algo = HHL(matrix, vector, truncate_powerdim, truncate_hermitian, eigs,
               init_state, reci, num_q, num_a, orig_size)
    
    #solution on quantum computer
    result = algo.run(quantum_instance = backend)
    print(&quot;Solution:\t\t&quot;, np.round(result['solution'], 5))
    print(&quot;Probability:\t\t %f&quot; % result['probability_result'])

    #refence solution - NumPyLSsolver = Numpy LinearSystem algorithm (classical).
    result_ref = NumPyLSsolver(matrix, vector).run()
    print(&quot;Classical Solution:\t&quot;, np.round(result_ref['solution'], 5))

matrix_A = np.array([[1.5, 0.5],[0.5, 1.5]])
vector_b = [0.9010, -0.4339]
#x = A^(-1)b = [0.78420, -0.55066] #expected result

processor = Aer.get_backend('statevector_simulator')

no_ancillas = 3 #number of ancilla qubits
no_time_slices = 50 #number of timeslices in exponential of matrix A (exp(i*A*t))

HHLsolver(matrix_A, vector_b, processor, no_ancillas, no_time_slices)
</code></pre>
<p><strong>Acknowledgement:</strong> The code is based on <a href=""https://qiskit.org/textbook/ch-applications/hhl_tutorial.html#4.-Qiskit-Implementation"" rel=""nofollow noreferrer"">Qiskit manual on HHL</a>.</p>
",10/20/2020 13:34, Errors,"The user is encountering an error when attempting to run the HHL algorithm in Qiskit, specifically related to the construct_circuit method, which falls under the category of seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,, Errors,
14141.0,Output a Cirq gate as a Numpy array?,"<p>How do I output a Cirq gate as a Numpy array? For example, I would like to print a Pauli X gate <code>cirq.X</code> as</p>
<pre><code>numpy.array([[0,1],[1,0]])
</code></pre>
<p>Thank you.</p>
",<programming><cirq>,10/14/2020 6:52,14145.0,14145.0,"<p>This can be done by calling <code>cirq.unitary</code>.</p>
<pre><code>&gt;&gt;&gt; import cirq
&gt;&gt;&gt; cirq.unitary(cirq.X)
array([[0.+0.j, 1.+0.j],
       [1.+0.j, 0.+0.j]])
</code></pre>
",10/14/2020 14:28,API Usage," The user is asking about how to use the Cirq API to convert a Cirq gate into a NumPy array, which falls under the category of discussions related to using APIs in quantum programming.",API Usage,,,,API Usage,
14146.0,Choi matrix in QETLAB,"<p>I am using <a href=""http://www.qetlab.com/Main_Page"" rel=""nofollow noreferrer"">QETLAB</a>, a package for working with quantum information theory in Matlab and I have some doubts. I am trying to calculate diamond norms using such for some quantum channels. However, when doing so, it is said that a superoperator must be the input to the function. I know the Kraus representation of the channels I am testing, so I am not sure how to get the superoperator form of such. In the example they put in their wiki for their diamond norm they use a function called ChoiMatrix that calculates the Choi matrix of a supeorperator, but I am not sure if inputing the Kraus operators there will give me what I need.</p>
<p>An insight about the usage of the functions would be helpful, so as the relationship between superoperators, Kraus operators and Choi matrices.</p>
",<programming><quantum-operation><kraus-representation><diamond-norm><qetlab>,10/14/2020 14:58,14153.0,14153.0,"<p>QETLAB usually deals with channels as Choi operators. You can convert your Kraus operators to the Choi matrix by providing the Kraus operators as a cell array. Example with the amplitude damping channel below.</p>
<pre><code>&gt;&gt; damp = 0.3;
&gt;&gt; K = { diag([1,sqrt(1-damp)]); [0,sqrt(damp);0,0] };
&gt;&gt; ChoiMatrix(K)

ans =

    1.0000         0         0    0.8367
         0         0         0         0
         0         0    0.3000         0
    0.8367         0         0    0.7000

</code></pre>
",10/14/2020 19:30,Conceptual,"The user is seeking an explanation and insight into the concepts of superoperators, Kraus operators, and Choi matrices in quantum information theory, which falls under the category of discussions about the background and underlying concepts of quantum programming.",Conceptual,,,,Conceptual,
14147.0,Odd behavior with Qiskit Pauli operators,"<p>I was creating a simple implementation of the Hadamard test when I came across the following, what seems like, strange behavior.</p>
<p>Consider the following snippet, which is part of the computating the expected value of the Pauli-<span class=""math-container"">$X$</span> operator with respect to the state <span class=""math-container"">$|\psi\rangle = \frac{1}{2}|0\rangle + \frac{\sqrt{3}}{2}|1\rangle$</span>. After measuring the ancillary, we compute <span class=""math-container"">$Prob(|0\rangle) - Prob(|1\rangle) = Re(\langle \psi |X|\psi\rangle)$</span> (see <a href=""https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)</a>)</p>
<p>Circuit 1:</p>
<pre><code>reg = QuantumRegister(2)
classical = ClassicalRegister(1)
qc = QuantumCircuit(reg, classical)

def op():
    r = QuantumRegister(1)
    gate = QuantumCircuit(r)
    gate.append(Operator(Pauli(label='X')), [*r])
    return gate.to_gate()

qc.initialize([1/2, np.sqrt(3)/2], [reg[1]])
qc.barrier()
qc.h(reg[0])
qc.append(op().control(),[*reg])
qc.h(reg[0])
qc.barrier()
qc.measure(reg[0], classical)
job = execute(qc, Aer.get_backend('qasm_simulator'), shots=1024)
print(job.result().get_counts())
</code></pre>
<p>The result from QASM is <span class=""math-container"">$\{'0': 499, '1': 525\}$</span>, which is not correct. I verified with Qiskit's snapshot expectation that expected value  is <span class=""math-container"">$\frac{\sqrt{3}}{2}$</span>. This was also verified through density matrix computation with numpy.</p>
<p>However, if I replace this with the <span class=""math-container"">$CX$</span> as opposed to the Pauli-<span class=""math-container"">$X$</span> from the quantum info package of qiskit.</p>
<p>Circuit 2</p>
<pre><code>reg = QuantumRegister(2)
classical = ClassicalRegister(1)
qc = QuantumCircuit(reg, classical)

qc.initialize([1/2, np.sqrt(3)/2], [reg[1]])
qc.barrier()
qc.h(reg[0])
qc.cx(reg[0], reg[1])
qc.h(reg[0])
qc.barrier()
qc.measure(reg[0], classical)
job = execute(qc, Aer.get_backend('qasm_simulator'), shots=1024)
print(job.result().get_counts())
</code></pre>
<p>I got the following: <span class=""math-container"">$\{'0': 962, '1': 62\}$</span>, which taking <span class=""math-container"">$(962-62)/1024$</span> produces an approximation to the correct result.</p>
<p>Next I printed out the transpilation of <code>Circui1</code></p>
<pre><code>t = transpile(qc, Aer.get_backend('qasm_simulator'), basis_gates=['u1','u2','u3','cx'])
t.draw(output='mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/m8dbf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m8dbf.png"" alt=""enter image description here"" /></a></p>
<p>I verified that this circuit does in fact produce the same result as Circuit 1. However, I then did a density matrix computation using numpy, which also produced the same result. However, this revealed that there is an incorrect <strong>phase difference, not a global phase difference</strong>.
If we view the bipartite system as <span class=""math-container"">$reg[0] \otimes reg[1]$</span>  where <span class=""math-container"">$reg[0]$</span> is the ancillary control bit, we get a unitary matrix for the gates in between the second set of barriers above (not including the Hadamards) like the following:
<span class=""math-container"">$\begin{bmatrix}
-1 &amp; 0 &amp;0 &amp; 0 \\
 0 &amp; -1 &amp;0 &amp; 0 \\
 0 &amp; 0 &amp;0 &amp; -i \\
 0 &amp; 0 &amp;-i &amp; 0 \\
\end{bmatrix}$</span></p>
<p>I verified that my computation in numpy was correct through multiple test; as a sanity check I compared my the matrices in the numpy simulation against those printed out by qiskit in the transpilation.
So this circuit is not the same as <span class=""math-container"">$CX$</span>.</p>
<p>Any ideas as to why I am seeing this?</p>
<p>I thought this might be a Qiskit issue, but I posted it here in case I am missing something, which most likely the case.</p>
",<qiskit><programming><circuit-construction><qasm>,10/14/2020 16:41,14157.0,14157.0,"<p>It is an issue. Adding <code>control()</code> to the gate introduces a phase difference.
You can verify that:</p>
<pre><code>from qiskit.quantum_info import Operator, Pauli

gate = QuantumCircuit(1)
gate.append(Operator(Pauli(label='X')), [0])
gate = gate.control() 

print(Operator(gate).data)

----
Output:

[[ 1   0   0   0]
 [ 0   0   0  1j]
 [ 0   0   1   0]
 [ 0  1j   0   0]]
</code></pre>
<p>So circuit 1 actually computes <span class=""math-container"">$ \text{Re}\big(\text{i} \cdot\langle \psi| X |\psi \rangle \big) = 0 $</span></p>
",10/14/2020 20:38,Errors,The user is encountering unexpected behavior in their quantum circuit implementation and is seeking an explanation for the observed differences between two circuit versions. They suspect an issue in their code or a misunderstanding of quantum gates.,Errors,,,,Errors,
14164.0,Can I run Cirq on IBMQ?,"<p>Google's quantum computer is not yet available for the public. Is it possible to run Cirq on IBM's quantum computers, instead of Qiskit? And if so, how can I do it?</p>
<p>Thank you!</p>
",<qiskit><programming><ibm-q-experience><cirq>,10/15/2020 5:21,14205.0,14205.0,"<p>This task can be accomplished via <a href=""https://cirq.readthedocs.io/en/stable/generated/cirq.QasmOutput.html"" rel=""nofollow noreferrer"">cirq.QasmOutput</a>. I've attached an example of how to use the aforementioned functionality to run Cirq circuits on Qiskit's backends.</p>
<pre><code>import cirq 
from typing import Tuple
from qiskit import QuantumCircuit, execute, Aer

def main():
    q0 = cirq.LineQubit(1)  
    cirq_circuit = cirq.Circuit(
        cirq.H(q0),  
        cirq.measure(q0)
    )
    results, qasm_circuit = run_cirq_circuit_on_qiskit(cirq_circuit, (q0,), 'qasm_simulator')
    
    # Returns counts
    counts = results.get_counts(qasm_circuit)
    print(&quot;Total count for 00 and 11 are:&quot;, counts)
    
def run_cirq_circuit_on_qiskit(circuit: 'cirq.Circuit', qubits: Tuple['cirq.Qid', ...], backend: str):
    qasm_output = cirq.QasmOutput((circuit.all_operations()), qubits)
    qasm_circuit = QuantumCircuit().from_qasm_str(str(qasm_output))
    # Execute the circuit qiskit backend
    job = execute(qasm_circuit, Aer.get_backend(backend), shots=1000)
    # Grab results from the job
    return job.result(), qasm_circuit

if __name__ == '__main__':
    main()
</code></pre>
",10/16/2020 18:24,Tooling,The question is asking about how to use a specific tool (Cirq) on a specific platform (IBM's quantum computers,Tooling,,,,Tooling,
14165.0,QPE example on Qiskit,"<p>I am learning to do QPE on qiskit. I wanted to choose a simple example to learn, and hence began with the state <span class=""math-container"">$|+\rangle$</span> and operator <span class=""math-container"">$X$</span>.</p>
<p>I initialized <span class=""math-container"">$|+\rangle$</span> this way:</p>
<pre><code>circ = QuantumCircuit(1)

circ.h(0)

a = Custom(num_qubits=1, state='zero', state_vector=None, circuit=circ) 

blah = a.construct_circuit(mode='circuit', register=None) 

statevec = Statevector.from_instruction(circ).data 
</code></pre>
<p>I then defined <span class=""math-container"">$X$</span> this way:</p>
<pre><code>b = MatrixOperator(np.array([[0,1],[1,0]]), basis=None, 
                   z2_symmetries=None, atol=1e-12, name=None) 
</code></pre>
<p>Finally, I gave the QPE commands:</p>
<pre><code>backend = Aer.get_backend('statevector_simulator')

qpe = QPE(operator=b, state_in=statevec, iqft=None, 
          num_time_slices=1, num_ancillae=1, 
          expansion_mode='trotter', expansion_order=1, 
          shallow_circuit_concat=False)

quantum_instance = QuantumInstance(backend=backend)

results = qpe.run(quantum_instance)
</code></pre>
<p>However, when I try running QPE, I run into this error:</p>
<pre><code>AttributeError: 'numpy.ndarray' object has no attribute 'construct_circuit'
</code></pre>
<p>If I define my operator instead this way:</p>
<pre><code>b = Operator([[0,1],[1,0]])
</code></pre>
<p>I get the error:</p>
<pre><code>AquaError: &quot;Unsupported type to convert to WeightedPauliOperator: &lt;class 'qiskit.quantum_info.operators.operator.Operator'&gt;&quot;
</code></pre>
<p>I also tried:</p>
<pre><code>b = Pauli.x
</code></pre>
<p>but ran into:</p>
<pre><code>AttributeError: 'property' object has no attribute 'copy'
</code></pre>
<p>Can someone help me with defining the state and operator correctly?</p>
",<qiskit><programming>,10/15/2020 6:27,14166.0,14166.0,"<p>You should try to insert your code so that it is more readable. Take the code in your notebook, and entered it in with the Preformatted text option. This way it is easier to produce the errors you get and make it easier for people to help you to find a solution</p>
<hr />
<p>In regard to your issue of defining the operator, as I mentioned in another answer sometime earlier, you can define the operator as:</p>
<pre><code>
from qiskit.aqua.operators import WeightedPauliOperator

dict = {

    'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0.00, &quot;real&quot;: 1 }, &quot;label&quot;: &quot;X&quot; }}]
}

b = WeightedPauliOperator.from_dict(dict)

</code></pre>
<p>Now you can try to pass <code>b</code> in the <code>QPE(operator = b, , â¦) </code></p>
<hr />
<p><strong>UPDATE:</strong></p>
<p>Try to run this:</p>
<pre><code>import qiskit 
from qiskit import __qiskit_version__
from qiskit.aqua.algorithms import QPE
from qiskit.aqua.operators import WeightedPauliOperator
from qiskit.aqua.components.initial_states import Custom
from qiskit import IBMQ, BasicAer, Aer
from qiskit import QuantumCircuit
from qiskit.aqua import QuantumInstance
from qiskit.circuit.library import QFT

print(qiskit.__qiskit_version__)

a = Custom(1,state = 'uniform')  #Initial state as you wanted. 
dict = {
    'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0.00, &quot;real&quot;: 1 }, &quot;label&quot;: &quot;X&quot; }]
}

b = WeightedPauliOperator.from_dict(dict) #Operator for input into QPE 

#-------- Setting up Backend --------#
provider = IBMQ.load_account()
quantum_instance = QuantumInstance(backend=Aer.get_backend(&quot;statevector_simulator&quot;), shots=1)
#------------------------------------#

n_ancillae = 3
iqft = QFT(n_ancillae).inverse()
qpe = QPE(b, a, iqft, num_time_slices=1, num_ancillae=n_ancillae,
          expansion_mode='trotter', expansion_order=1, shallow_circuit_concat=False)
qpe_result = qpe.run(quantum_instance)

qc = qpe.construct_circuit(measurement = True)
qc.draw( ) 
</code></pre>
<hr />
<p>Running the above code I get the following:</p>
<p><a href=""https://i.stack.imgur.com/Dhmc9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Dhmc9.png"" alt=""enter image description here"" /></a></p>
",10/15/2020 7:20,Errors,The user is encountering errors when attempting to define the state and operator for the Quantum Phase Estimation (QPE) algorithm in Qiskit. They are seeking assistance in resolving these errors.,Errors,,,,Errors,
14170.0,Intuition behind the construction of an ansatz circuit,"<p>I'm learning about the VQE algorithm. When I looked at the declaration in Qiskit I saw you need to pass an ansatz which prepares the state. I looked at some commonly used ansatz functions, e.g. <code>EfficientSU2</code> of Qiskit, and I saw many of them use <span class=""math-container"">$R_y$</span> and <span class=""math-container"">$X$</span> gates.</p>
<p>I was wondering why exactly was this structure chosen? What's the physical logic behind it that makes it so convenient to use for many different Hamiltonians? How can the structure of the Hamiltonian affect the construction of the ansatz?</p>
<p>Thank you</p>
",<qiskit><programming><hamiltonian-simulation><vqe>,10/15/2020 11:04,14171.0,14171.0,"<p>Interesting question!</p>
<p>An ansatz circuit is a parameterized circuit, say <span class=""math-container"">$V(\theta)$</span> where <span class=""math-container"">$\theta$</span> are a set of parameters, used to prepare a trial state for your problem:
<span class=""math-container"">$$
|\Psi(\theta)\rangle = V(\theta)|0\rangle
$$</span>
In a variational algorithm, such as VQE, the trial state encodes your solution and is iteratively updated until some termination criterion is met.
<span class=""math-container"">$$
|\Psi(\theta_0)\rangle \rightarrow |\Psi(\theta_1)\rangle \rightarrow \dots \rightarrow |\Psi(\theta_n)\rangle
$$</span>
Therefore the first question you must ask when looking for an ansatz is: Can the trial state prepared by my ansatz circuit encode my solution?
For example: Does your solution contain complex amplitudes? If yes, you need a circuit that contains complex amplitudes (such as <code>EfficientSU2</code>). If no, you could use one that has only real amplitudes (such as <code>RealAmplitudes</code>).</p>
<p>Apart from that, I think we can distinguish in two different categories of ansatz circuits: physically motivated ones and heuristic ones.</p>
<p><em>Physically motivated</em> ansatz circuits are based on some knowledge of the problem we want to solve. For example the UCCSD ansatz prepares a state where tuning the parameters turns excitations on and off. A potential drawback here is that the circuits can get massive! Go ahead and check out the size of a UCCSD ansatz. For the order of 10 parameters your circuit can already have 1000s of gates. That's not in reach of today's hardware and cannot be run meaningfully on an actual quantum computer.</p>
<p><em>Heuristically motivated</em> ansatz circuits, are essentially circuit that we tested and they turned out to work well. An interesting class are <em>hardware efficient</em> circuits (which usually are circuits with 1- and 2-qubit gates) which we can implement efficiently on hardware. <code>EfficientSU2</code> also falls into this category.</p>
<p>Then there are mixtures between these circuits. For instance, Qiskit's <code>ExcitationPreserving</code> circuit prepares a trial wave function, that preserves the particle numbers of you solve a molecular ground state calculation and used a Jordan-Wigner mapping to get the qubit operator.</p>
<p><a href=""https://github.com/Cryoris/notebooks/blob/master/Circuits%20in%20Quantum%20Algorithms.ipynb"" rel=""noreferrer"">This notebook</a>, among other things, discusses this topic.</p>
",10/15/2020 11:26,Theoretical,"The user is inquiring about the theoretical underpinnings and reasoning behind the choice of ansatz functions, particularly the use of specific gates like R_y and X gates, in the Variational Quantum Eigensolver (VQE) algorithm. They are also interested in understanding how the structure of the Hamiltonian can influence the construction of the ansatz.",Theoretical,,,,Theoretical,
14183.0,Papers on classical optimization in QAOA,"<p>Are there any papers on the classical optimization part of QAOA?
What is the most efficient method now?</p>
<p>And how is the classical optimization classified?</p>
",<resource-request><classical-computing><qaoa>,10/15/2020 19:56,14184.0,14184.0,"<p>These papers might help:</p>
<ol>
<li><p><a href=""https://arxiv.org/abs/2004.03004"" rel=""nofollow noreferrer"">Classical Optimizers for Noisy Intermediate-Scale Quantum Devices</a></p>
</li>
<li><p><a href=""https://arxiv.org/abs/1910.14030"" rel=""nofollow noreferrer"">Collective optimization for variational quantum eigensolvers</a></p>
</li>
</ol>
<p>Also look at these <a href=""https://pennylane.readthedocs.io/en/stable/introduction/optimizers.html"" rel=""nofollow noreferrer"">optimizers from Pennylane</a>.</p>
",10/15/2020 20:03,Theoretical,"The question is asking about the theoretical aspects of the classical optimization part of QAOA, including the most efficient method and how it is classified.",Theoretical,,,,Theoretical,
14185.0,Superposition of quantum circuits,"<p>Given a quantum circuit <span class=""math-container"">$C_1$</span> that generates a state <span class=""math-container"">$\vert\psi\rangle$</span> and another circuit <span class=""math-container"">$C_2$</span> that generates <span class=""math-container"">$\vert\phi\rangle$</span>, is there a way to construct a circuit that outputs</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{2}}(\vert \psi\rangle +\vert\phi\rangle)$$</span></p>
<p>using <span class=""math-container"">$C_1$</span> and <span class=""math-container"">$C_2$</span> as black boxes?</p>
",<quantum-gate><programming><superposition><quantum-circuit>,10/15/2020 20:14,14197.0,14197.0,"<p>Here's one way to do it. Let's start with some assumptions: here, I'm assuming your circuits <span class=""math-container"">$C_1$</span> and <span class=""math-container"">$C_2$</span> use the same number of qubits. In the drawing, I have used four qubits to illustrate the concept, but that doesn't matter. The answer below does not care about the number of qubits (which I call <span class=""math-container"">$n$</span>), just that the two circuits have the same number of qubits.</p>
<p>I also assume that since we have these two circuits <span class=""math-container"">$C_1$</span> and <span class=""math-container"">$C_2$</span>, we can create controlled versions of them. This is not hard to do. [edit after @DaftWullie's comment: <em>the question above starts, &quot;Given a quantum circuit...&quot; so I am assuming here that I know what the circuits are. In the general case of completely unknown circuits, this may not be as easy.</em>]</p>
<p>In addition to the number of qubits needed for your circuits, I also need one more qubit to do this work. It's called ctrl<span class=""math-container"">$_0$</span> in the figure.</p>
<p><a href=""https://i.stack.imgur.com/cWLL9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cWLL9.png"" alt=""quantum circuit for generating the superposition state psi1 + psi2 probabilistically"" /></a></p>
<p>Start with all the qubits reset to the state <span class=""math-container"">$\vert0\rangle$</span>. Then, apply a Hadamard gate to ctrl<span class=""math-container"">$_0$</span>, and you have the combined state</p>
<p><span class=""math-container"">$$
\frac{1}{\sqrt{2}}\left(\vert0\rangle + \vert1\rangle\right)\otimes \vert0\rangle_n
$$</span>
where the ordering is apparent from above.</p>
<p>Next, apply the controlled-<span class=""math-container"">$U_1$</span> box, which really just contains the circuit <span class=""math-container"">$C_1$</span> that you have given me. The combined state is now</p>
<p><span class=""math-container"">$$
\frac{1}{\sqrt{2}}\left(\vert0\rangle\vert0\rangle_n + \vert1\rangle\right\vert\psi_1\rangle_n)
$$</span></p>
<p>After applying the <span class=""math-container"">$X$</span> gate, we have</p>
<p><span class=""math-container"">$$
\frac{1}{\sqrt{2}}\left(\vert1\rangle\vert0\rangle_n + \vert0\rangle\right\vert\psi_1\rangle_n)
$$</span></p>
<p>And so, after applying the controlled-<span class=""math-container"">$U_2$</span> box, which really just contains the circuit <span class=""math-container"">$C_2$</span> that you have given me</p>
<p><span class=""math-container"">$$
\frac{1}{\sqrt{2}}\left(\vert1\rangle\vert\psi_2\rangle_n + \vert0\rangle\right\vert\psi_1\rangle_n)
$$</span></p>
<p>After applying the Hadamard gate again on ctrl<span class=""math-container"">$_0$</span>, this becomes</p>
<p><span class=""math-container"">$$
\left[\frac{1}{\sqrt{2}}\vert0\rangle\otimes\frac{1}{\sqrt{2}}\left(\vert\psi_1\rangle_n + \vert\psi_2\rangle_n\right)\right] + 
\left[\frac{1}{\sqrt{2}}\vert1\rangle\otimes\frac{1}{\sqrt{2}}\left(\vert\psi_1\rangle_n - \vert\psi_2\rangle_n\right)\right]
$$</span></p>
<p>Now, if you measured the qubit ctrl<span class=""math-container"">$_0$</span>, you will either get 0 or 1. If you measured 0, then you know that the <span class=""math-container"">$n$</span> qubits are now in the state</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(\vert\psi_1\rangle_n + \vert\psi_2\rangle_n\right)$$</span></p>
<p>If you measured 1, then you know that the <span class=""math-container"">$n$</span> qubits are now in the state</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(\vert\psi_1\rangle_n - \vert\psi_2\rangle_n\right)$$</span></p>
<p>Each of these two outcomes has a probability of 1/2. That means if you really only want the state</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(\vert\psi_1\rangle_n + \vert\psi_2\rangle_n\right)$$</span></p>
<p>then this circuit will give it to you half the time. The other half the time, you know (because you measured 1) that you need to restart the circuit in hopes of getting the outcome that you'd like. Since the probability is 1/2, sooner or later this ought to happen.</p>
<p>This method is probabilistic, of course, but has the nice benefit of giving you a measurement outcome (0 or 1) that tells you if you've done what you wanted or not.</p>
",10/16/2020 13:56,Theoretical,"The question is asking about the theoretical possibility of constructing a circuit to output a specific state, given two black-box circuits that generate other states. This is a challenging problem, as it requires a good understanding of the underlying principles of quantum computing.",Theoretical,,,,Theoretical,
14226.0,Suppress Warnings,"<p>I wish to know how to suppress the following warning obtained on qiskit when I try to add two different types of noise to a qubit</p>
<pre><code>WARNING: quantum error already exists for instruction &quot;u2&quot; on qubits [0] , appending additional error.
</code></pre>
<p>I know that some warnings can be suppressed with</p>
<pre><code>import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)
</code></pre>
<p>but I do not know what category my warning is contained in. I would also like to know if I can access somewhere all the different warning categories. Additionally trying</p>
<pre><code>import warnings
warnings.filterwarnings('ignore')
</code></pre>
<p>to suppress all warnings does not help.</p>
",<qiskit><programming><ibm-q-experience>,10/18/2020 6:47,14243.0,14243.0,"<p>Qiskit's <code>NoiseModel</code> class processes warnings through a logger from the <code>logging</code> package, not through the <code>warnings</code> package, so suppressing warnings as in other answers won't help.</p>
<p>However, each method in <code>NoiseModel</code>  provides a <code>warnings</code> parameter; it defaults to <code>True</code> but you can set it to <code>False</code> to prevent the warnings from being logged.</p>
<p>Example: <code>myNoiseModel.add_quantum_error(..., warnings=False)</code></p>
",10/19/2020 1:52, Errors, The user is seeking to suppress a specific warning message related to quantum error addition in Qiskit. This falls under the category of addressing errors and warnings in quantum programming., Errors,,,, Errors,
14229.0,Qiskit BasicAer simulator options,"<p>I usually use Qiskit &quot;Aer&quot; to simulate quantum circuit with several methods such as <code>statevector</code>, <code>density_matrix</code>, <code>stabilizer</code>, <code>extended_stabilizer</code>, and <code>matrix_product_state</code>. Recenlty I came across another simulator called &quot;BasicAer&quot; and I wonder if the qiskit BasicAer supports above methods.</p>
",<qiskit><programming><simulation>,10/18/2020 7:59,14234.0,14234.0,"<p>For any provider, you can check the backends with <code>backends()</code>:</p>
<pre><code>from qiskit import BasicAer
BasicAer.backends()
</code></pre>
<pre><code>[&lt;QasmSimulatorPy('qasm_simulator') from BasicAer()&gt;,
 &lt;StatevectorSimulatorPy('statevector_simulator') from BasicAer()&gt;,
 &lt;UnitarySimulatorPy('unitary_simulator') from BasicAer()&gt;]
</code></pre>
<p>Check the doc for each of them:</p>
<pre><code>for backend in BasicAer.backends():
    print(&quot;%s: %s&quot; % (backend.name(), backend.__doc__))
</code></pre>
<pre><code>qasm_simulator: Python implementation of a qasm simulator.
statevector_simulator: Python statevector simulator.
unitary_simulator: Python implementation of a unitary simulator.
</code></pre>
",10/18/2020 13:45,Tooling,"The user is inquiring about the capabilities of the ""BasicAer"" simulator in Qiskit, specifically whether it supports certain simulation methods. This question falls under the category of tools and software usage in quantum programming.",Tooling,,,,Tooling,
14233.0,How to set overwrite to true with IBMQ?,"<p>I'm trying to get setup with <a href=""https://qiskit.org"" rel=""nofollow noreferrer"">https://qiskit.org</a>, but I'm having a problem.</p>
<p>I have dug around the internet for a bit and haven't been able to find anything.</p>
<p>When I try to run <code>IBMQ.save_account('api_token')</code> it says that I already have credentials present, and to set overwrite to true in order to overwrite the current ones.</p>
<p>How do I do with that?</p>
",<qiskit><programming><ibm-q-experience>,10/18/2020 13:44,14235.0,14235.0,"<p>It is in the method documentation, <code>overwrite: Overwrite existing credentials.</code>:</p>
<pre><code>IBMQ.save_account('api_token', overwrite=True)
</code></pre>
",10/18/2020 13:57,Tooling,The question is asking about how to use a specific quantum computing tool (Qiskit IBMQ provider) to save an account.,Tooling,,,,Tooling,
14241.0,Producing $|ghz\rangle\langle ghz|$ State in Cirq,"<p>I could manage to produce 3 qubit ghz state in Cirq. But I don't know how I can produce <span class=""math-container"">$|GHZ\rangle\langle GHZ|$</span>  in Cirq
Here is my code for 3 qubit ghz state
Can you help me please for improving my code from <span class=""math-container"">$|GHZ\rangle$</span> to <span class=""math-container"">$|GHZ\rangle\langle GHZ|$</span>:</p>
<pre><code>n = 3
qubits = cirq.LineQubit.range ( n )

def circuit ():
  circuit = cirq.Circuit ()
  circuit.append (cirq.H(qubits[0]))
  for i in range (n-1):
    circuit.append ( cirq.CNOT ( qubits [i] , qubits [i+1]) )
  circuit.append (cirq.measure (* qubits , key ='x') )
  print (circuit)
  return circuit

def simulation (circuit):
  simulator = cirq.Simulator()
  results = simulator.run ( circuit , repetitions = 200)
  counts = cirq.plot_state_histogram (results)

def main():
  simulation (circuit())
if __name__ == &quot;__main__ &quot;:
   main ()
</code></pre>
",<programming><quantum-state><cirq><ghz-state>,10/18/2020 18:33,14529.0,14529.0,"<p>Since you can produce the GHZ state, I will skip the corresponding code and just use that QuantumCircuit object to build a density matrix <span class=""math-container"">$|GHZ&gt;&lt;GHZ|$</span>.</p>
<pre><code>from qiskit.quantum_info import DensityMatrix
DM=DensityMatrix.from_instruction(circuit)
# here circuit denotes the circuit that contains your GHZ state.
</code></pre>
<p>Or there is another way to do so(not recommended, just for reference).</p>
<pre><code>from qiskit.aqua.operators import StateFn
psi=StateFn(circuit)# produce the state vector
DM=(psi@~psi).eval()# state ket tensor state bra =density matrix
# When calling StateFn function, the quantum circuit must not contain classical register
</code></pre>
<p>But note that the density matrix produced by the latter method is not admitted by qiskit, because the DensityMatrix object in qiskit has two attributes(the matrix itself and its dimension).</p>
",11/08/2020 12:06,Tooling,The question is asking about how to use a specific quantum computing tool (Cirq) to produce a specific quantum state.,Tooling,,,,Tooling,
14266.0,Cirq: Creating an arbitrary gate for an arbitrary number of qubits,"<p>How do I create an arbitrary unitary gate for an arbitrary number of qubits in Cirq?</p>
<p>Note: A solution for creating a single qubit gate is answered by Thomas W from this post.
<a href=""https://quantumcomputing.stackexchange.com/questions/4521/how-do-i-create-my-own-unitary-matrices-that-i-can-apply-to-a-circuit-in-cirq"">How do I create my own unitary matrices that I can apply to a circuit in Cirq?</a></p>
",<programming><cirq>,10/20/2020 10:00,14267.0,14267.0,"<p>You have 2 options depending on what your needs are:</p>
<ol>
<li><strong>Use <code>cirq.MatrixGate</code></strong>.</li>
</ol>
<ul>
<li>Pros: you can easily instantiate the gate based on a unitary matrix.</li>
<li>Cons: you can't customize it that easily.</li>
</ul>
<ol start=""2"">
<li><strong>Create your own Gate class</strong>.</li>
</ol>
<ul>
<li>Pros: full flexibility, you can customize the features, diagram info, etc.</li>
<li>Cons: it's a bit more involved.</li>
</ul>
<h2>Using <code>cirq.MatrixGate</code></h2>
<p><code>cirq.MatrixGate</code> lets you create a gate based on an arbitrary unitary. Nothing else is required. In the example below a 2 qubit QFT gate is created.</p>
<pre><code>    QFT2 = np.array([[1, 1, 1, 1],
                     [1, 1j, -1, -1j],
                     [1, -1, 1, -1],
                     [1, -1j, -1, 1j]]) * 0.5
    my_qft2 = cirq.MatrixGate(QFT2)
    print(cirq.Circuit(my_qft2(q[0],q[1])))
</code></pre>
<p>Resulting in:</p>
<pre><code>      â                                       â
      â 0.5+0.j   0.5+0.j   0.5+0.j   0.5+0.j â
0: ââââ 0.5+0.j   0. +0.5j -0.5+0.j   0. -0.5jââââ
      â 0.5+0.j  -0.5+0.j   0.5+0.j  -0.5+0.j â
      â 0.5+0.j   0. -0.5j -0.5+0.j   0. +0.5jâ
      â                                       â
      â
1: âââ#2ââââââââââââââââââââââââââââââââââââââââââ
</code></pre>
<h2>Creating your own gate class</h2>
<p>You will have to create a subclass of <code>cirq.Gate</code> and implement one of the following methods mandatorily: <code>_num_qubits_</code>, <code>_qid_shape</code> or <code>num_qubits</code>.</p>
<p>Then you can create magic methods to enrich your class with cirq protocols, like <code>cirq.SupportsUnitary</code> (implement the <code>_unitary_</code> method) or <code>cirq.SupportsCircuitDiagramInfo</code> (implement the <code>_circuit_diagram_info_</code> method).</p>
<p>An example implementing X gates applied to arbitrary number of qubits:</p>
<pre><code>    from typing import Union, Iterable
    
    import numpy as np
    
    import cirq
    from cirq.type_workarounds import NotImplementedType
    
    
    class MultiXGate(cirq.Gate):
        def __init__(self, num_qubits):
            if num_qubits &lt;= 0:
                raise ValueError(&quot;num_qubits should be &gt; 0&quot;)
            self.num_qubits = num_qubits
    
        # this is mandatory (or alternatively, _qid_shape_ or num_qubits)
        def _num_qubits_(self) -&gt; int:
            return self.num_qubits
    
        ## These are not mandatory but pretty important
    
        def _circuit_diagram_info_(self, _) -&gt; Union[str, Iterable[str],
                                                     cirq.CircuitDiagramInfo]:
            return [&quot;multi-X&quot;] * self.num_qubits
    
        def _unitary_(self) -&gt; Union[np.ndarray, NotImplementedType]:
            x = cirq.unitary(cirq.X)
            return cirq.kron(*([x] * self.num_qubits))
    
    
    if __name__ == '__main__':
        q = cirq.LineQubit.range(4)
        circuit = cirq.Circuit(MultiXGate(len(q))(*q))
        print(circuit)
        c2 = cirq.Circuit([cirq.X(qubit) for qubit in q])
        assert np.allclose(circuit.unitary(), c2.unitary())
</code></pre>
<p>This will print the following:</p>
<pre><code>0: âââmulti-Xâââ
      â
1: âââmulti-Xâââ
      â
2: âââmulti-Xâââ
      â
3: âââmulti-Xâââ
</code></pre>
",10/20/2020 11:47,Tooling,The question is asking about how to use a specific quantum computing tool (Cirq) to create an arbitrary unitary gate for an arbitrary number of qubits.,Tooling,,,,Tooling,
14280.0,How can I obtain transformation matrix of a quantum circuit in the Qiskit?,"<p>I need to draw a quantum circuit in Clifford+T library and obtain automatically its transformation matrix. Is there any feature on Qiskit in this case?</p>
",<qiskit><programming><ibm-q-experience><circuit-construction>,10/21/2020 12:36,14282.0,14282.0,"<p>The other answer is great.</p>
<p>But here is a link that walk you through the process step-by-step: <a href=""https://medium.com/mdr-inc/checking-the-unitary-matrix-of-the-quantum-circuit-on-qiskit-5968c6019a45"" rel=""nofollow noreferrer"">https://medium.com/mdr-inc/checking-the-unitary-matrix-of-the-quantum-circuit-on-qiskit-5968c6019a45</a></p>
",10/21/2020 15:40,Tooling,The question is asking about how to use a specific quantum computing tool (Qiskit Clifford+T library) to draw a quantum circuit and obtain its transformation matrix automatically.,Tooling,,,,Tooling,
14286.0,Multiple Bipartite Entangled State in Cirq,"<p>I am trying to create this state:
rho =  = q . rho_{1,2} + r . rho_{2,3} + s . rho{1,3} + (1-q-r-s) . rho_separable</p>
<p>And I wrote this code:</p>
<pre><code>   import random
import numpy as np
import cirq

circuit, circuit2, circuit3   = cirq.Circuit()
p = 0.2
q = 0.1
r = 0.3
alice, bob, charlie = cirq.LineQubit.range(1, 4)
rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) 
#circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) 
rho_23 = circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) 
rho_13 = circuit.append([cirq.H(alice), cirq.CNOT(alice, charlie)]) 
circuit = rho_12 + rho_23 + rho_13
print(circuit)
</code></pre>
<p>In here I have 2 problem:</p>
<p>1)This line is not working: <code>circuit = rho_12 + rho_23 + rho_13</code></p>
<p>2)I cannot multiply the state with p or q or r. What I mean is that I can't write this line:</p>
<pre><code>rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) * q 
</code></pre>
<p>Could you please show me how I can write this state?</p>
",<programming><quantum-state><entanglement><cirq>,10/21/2020 20:38,14287.0,14287.0,"<p>You seem to think <code>append</code> is returning a circuit, instead of modifying the circuit you called it on. <code>circuit.append(op)</code> doesn't return anything, it adds an operation to <code>circuit</code>.</p>
<pre><code>alice, bob, charlie = cirq.LineQubit.range(1, 4)
circuit = cirq.Circuit()
circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)])
circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) 
...
</code></pre>
<p>Alternatively, you can make a new circuit for each of the pieces and then add them together:</p>
<pre><code>rho_12 = cirq.Circuit(
    cirq.H(alice),
    cirq.CNOT(alice, bob),
)
...
circuit = rho_12 + rho_23 + rho_13
</code></pre>
",10/21/2020 21:28,Errors ,The question is asking about errors in Qiskit code.,Errors,,,,Errors ,
14288.0,"Bit Flip, Separable state and Several Question about Cirq","<p>1)I want to use noise model for my state and bit_flip is not defined on cirq.</p>
<pre><code>    rho_13 = cirq.Circuit(
    cirq.H(alice),
    cirq.CNOT(alice, charlie),
    #cirq.bit_flip([r]),
    cirq.measure(alice,charlie),
) 
</code></pre>
<p>When I wrote this code, I had the error: &quot; bit_flip is not defined&quot; (I used import cirq)</p>
<p>2)For ghz state I wrote this part but I didn't understand I have a syntax error which is very weird maybe I am doing something wrong regarding cirq but I get this error. Can you look at it?</p>
<pre><code>    ghz = cirq.Circuit(  
   cirq.H(qubits[0]),
   for i in range (n-1):
       cirq.CNOT ( qubits [i] , qubits [i+1]),
   cirq.final_density_matrix(circuit),
   cirq.measure (* qubits , key ='x'),. 
)
</code></pre>
<p>The syntax error is just after the &quot;for&quot; and &quot;Invalid syntax&quot;</p>
<p>3)My original state is |GHZ&gt;&lt;GHZ|+P*rho. Should I use cirq.final_density_matrix(circuit), in the part of ghz only, or should I use cirq.final_density_matrix(circuit), after defining my all state(I will first define |GHZ&gt;&lt;GHZ and then (1-P)rho, and then I will write circuit =|GHZ&gt;&lt;GHZ|+(1-P)rho after that cirq.final_density_matrix(circuit)) or should I use cirq.final_density_matrix(circuit) both part for all circuit and |GHZ&gt;&lt;GHZ too</p>
<ol start=""4"">
<li>I can create entangled state with hadamard and cnot gate but I want to create seperable state. How can I create seperable state with cirq</li>
</ol>
<p>5)For measurement, Should I measure each part seperately or should I first appending all circuit and then measured together? What I mean is that first I will measure |GHZ&gt;&lt;GHZ| and then I will measure P*rho and after that I will add my circuit like circuit =|GHZ&gt;&lt;GHZ|+(1-P)rho and simulate or Should I directly add and after that measure the all circuit?</p>
<p>Many thanks from now</p>
",<programming><entanglement><measurement><noise><cirq>,10/21/2020 23:24,14289.0,14289.0,"<ol>
<li>You are running into basic python issues: trying to call a function with a list <code>[r]</code> instead of a float parameter. Also, the bit_flip channel then needs to be applied on a qubit. A potential fix is here:</li>
</ol>
<pre><code>import cirq

alice, bob, charlie = cirq.LineQubit.range(3)
rho_13 = cirq.Circuit(
    cirq.H(alice),
    cirq.CNOT(alice, charlie),
    # you need a probability to have the channel defined
    # then you'll need to apply the channel to a qubit
    cirq.bit_flip(p=0.6)(charlie),
    cirq.
measure(alice,charlie),
) 
</code></pre>
<ol start=""2"">
<li><p>This is also fraught with Python issues. You are trying to create a circuit - but then passing in a for loop as an argument? <code>cirq.final_density_matrix</code> should not be part of the Circuit construction arguments for sure. Measurement can be part of the circuit but let's deal with that later as you have a question about that too.</p>
</li>
<li><p>Summing states together only makes sense in the density matrix representation. From your three last questions (<a href=""https://quantumcomputing.stackexchange.com/questions/14241/producing-ghzghz-state-in-cirq"">Producing |GHZ&gt;&lt;GHZ| State in Cirq</a>, <a href=""https://quantumcomputing.stackexchange.com/questions/14286/multiple-bipartite-entangled-state-in-cirq"">Multiple Bipartite Entangled State in Cirq</a> and this one) I'm gathering that you would like to put together a state that represents a mixture between the GHZ state and 4 states. So we'll have to</p>
<ol>
<li>create the density matrix for each of them,</li>
<li>multiply them with the required probabilities</li>
<li>sum them together.</li>
</ol>
</li>
<li><p>You need to tell us more about what kind of separable state you would like. |000&gt;&lt;000| is one of the simplest separable ones - as it is <span class=""math-container"">$|0\rangle\langle0| \otimes|0\rangle\langle0|\otimes|0\rangle\langle0|$</span> - I'm going to assume that that's good enough. But any state that is the result of only local operations (i.e. one qubit operations) should be good enough.</p>
</li>
<li><p>Measurement is not required for your state preparation. If you want to measure your final state, I would add that at the end. Let's cover that as well.</p>
</li>
</ol>
<p>There are two major ways that I can think of to solve this:</p>
<ol>
<li>using density matrices directly</li>
<li>using mixtures of unitaries</li>
</ol>
<p>Here is an example for both - at the end the final density matrix is exactly the same.</p>
<pre><code>
from typing import Union, Sequence, Tuple, Any

import cirq
import numpy as np

from cirq.type_workarounds import NotImplementedType


# ======== Density matrix based method ============

a, b, c = cirq.LineQubit.range(3)
GHZ_circuit = cirq.Circuit(cirq.H(a),
                           cirq.CNOT(a, b),
                           cirq.CNOT(b, c))

GHZ = cirq.final_density_matrix(GHZ_circuit)


def density_matrix_bipartite_entangled(i, j, qs):
    circuit = biparty_entangle_circuit(i, j, qs)
    return cirq.final_density_matrix(circuit, qubit_order=qs)


def biparty_entangle_circuit(i, j, qs):
    return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j]))


qs = [a, b, c]

rho01 = density_matrix_bipartite_entangled(0, 1, qs)
rho02 = density_matrix_bipartite_entangled(0, 2, qs)
rho12 = density_matrix_bipartite_entangled(1, 2, qs)

# creates the |+&gt; â |1&gt; â |0&gt; state
circuit_separable = cirq.Circuit(cirq.H(a), cirq.X(b))
rho_separable = cirq.final_density_matrix(circuit_separable, qubit_order=qs)

p, q, r, s = 0.5, 0.3, 0.2, 0.1
assert 0 &lt;= q + r + s &lt;= 1
assert 0 &lt;= p &lt;= 1

rho = q * rho01 + r * rho02 + s * rho12 + (1 - q - r - s) * rho_separable
state = p * GHZ + (1 - p) * rho

print(f&quot;final state: \n {state}&quot;)

print(cirq.sample_density_matrix(state, indices=[0, 1, 2], repetitions=10))


# ======== Mixture based method ============

class MixtureGate(cirq.Gate):
    def __init__(self, p, q, r, s):
        self.p = p
        self.q = q
        self.r = r
        self.s = s

    def _num_qubits_(self) -&gt; int:
        return 3

    def _mixture_(self) -&gt; Union[Sequence[Tuple[float, Any]],
                                 NotImplementedType]:
        p, q, r, s = self.p, self.q, self.r, self.s
        rho01_gate = biparty_entangle_circuit(0, 1, qs).unitary(
            qubits_that_should_be_present=qs)
        rho02_gate = biparty_entangle_circuit(0, 2, qs).unitary(
            qubits_that_should_be_present=qs)
        rho12_gate = biparty_entangle_circuit(1, 2, qs).unitary(
            qubits_that_should_be_present=qs)
        separable_gate = circuit_separable.unitary(
            qubits_that_should_be_present=qs)

        return [
            (p, GHZ_circuit.unitary()),
            ((1 - p) * q, rho01_gate),
            ((1 - p) * r, rho02_gate),
            ((1 - p) * s, rho12_gate),
            ((1 - p) * (1 - q - r - s), separable_gate),
        ]


final_circuit = cirq.Circuit(
    MixtureGate(p, q, r, s)(a, b, c)
)
circuit_based_state = cirq.final_density_matrix(final_circuit)

print(circuit_based_state)

# we can do measurements here as well

final_circuit.append(cirq.measure(a, b, c))

r = cirq.DensityMatrixSimulator().run(program=final_circuit, repetitions=10)
print(&quot;Measurement results: &quot;, r)

## They are the same, yay!
assert np.allclose(circuit_based_state, state)


</code></pre>
",10/22/2020 1:29,Errors,"The user are encountering syntax errors and undefined functions in their quantum programming code using the Cirq library, and youre seeking solutions to these problems.",Errors,,,,Errors,
14301.0,State Vector Output for T$|1\rangle$ in Qiskit differs from manual calculation. Why is this so?,"<p>The T Gate is defined as <span class=""math-container"">$\begin{bmatrix} 1&amp;0 \\ 0&amp;e^{i\pi/4} \end{bmatrix} = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$</span></p>
<p>So <span class=""math-container"">$\begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \vert 1 \rangle = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ \frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$</span></p>
<p>But the following code for the T Gate gives a slightly different output:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute
from qiskit_textbook.tools import array_to_latex

qc = QuantumCircuit(1)
qc.initialize([0,1],0)  # initialize to |1&gt;
qc.t(0)
display(qc.draw('mpl'))
backend = Aer.get_backend('statevector_simulator')  # simulate the circuit
state = execute(qc,backend).result().get_statevector()  # get final state
array_to_latex(state, pretext=&quot;\\text{Output} = &quot;)  # show final state vector
</code></pre>
<p>which is <span class=""math-container"">$\begin{bmatrix} 0 \\ \frac{1}{\sqrt{2}}(1+i) \end{bmatrix}.$</span></p>
<p>Why do these two results differ? Thanks for any insights.</p>
",<qiskit><programming><quantum-state>,10/22/2020 21:51,14302.0,14302.0,"<p><span class=""math-container"">$\frac{\sqrt{2}}{2}(1+i) $</span> = <span class=""math-container"">$\frac{1}{\sqrt{2}}(1+i)$</span>. To see how this is the case, multiply the numerator and denominator of <span class=""math-container"">$\frac{1}{\sqrt{2}}$</span> by  <span class=""math-container"">$\frac{\sqrt{2}}{\sqrt{2}}$</span> = <span class=""math-container"">$1$</span>. <span class=""math-container"">$\frac {\sqrt{2}}{\sqrt{2}} \frac{1}{\sqrt{2}} = \frac{\sqrt{2}}{{2}}$</span> .</p>
<p>The result doesn't differ; only how it's displayed in comparison to your manual calculation does.</p>
",10/22/2020 22:07,Theoretical,"The user are asking about the theoretical concepts and principles in quantum computing, specifically about the output of the T Gate operation in Qiskit.",Errors,"The user is encountering an unexpected result when implementing a T Gate in a quantum circuit using Qiskit. They have provided the theoretical calculation and the code they used, and are seeking an explanation for the discrepancy. This falls under the Errors category as it involves troubleshooting unexpected results in quantum programming.",No,97.0,Errors,"The user is encountering an unexpected result when implementing a T Gate in a quantum circuit using Qiskit. They have provided the theoretical calculation and the code they used, and are seeking an explanation for the discrepancy, making it an issue of unexpected behavior in quantum programming."
14326.0,Composing teleportation circuit in Qiskit Circuit Composer,"<p>I'm trying to create the teleportation circuit in IBM Qiskit Circuit Composer.</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[3];
creg a[3];   // should be crz
creg b[4];   // should be crx

h q[1];
cx q[1],q[2];
barrier q; //[0];

cx q[0],q[1];
h q[0];
barrier q;

measure q[0] -&gt; a[0];
measure q[1] -&gt; b[0];
barrier q;

</code></pre>
<p>This gives me the following circuit till the 3rd measurement barrier. How do I add <code>CRX</code> and <code>CRZ</code> gates - to obtain the circuit as shown in the picture? Also, how to change the names of the classical registers from <code>a3</code>, <code>b4</code> to <code>crz</code> and <code>crx</code>?</p>
<p><a href=""https://i.stack.imgur.com/TIZmN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TIZmN.png"" alt=""Teleportation Circuit"" /></a></p>
",<qiskit><programming><circuit-construction><ibm-q-experience><teleportation>,10/25/2020 4:44,14328.0,14328.0,"<p><code>crx</code> and <code>crz</code> are classical register. The gates <code>CRX</code> or <code>CRZ</code> mean that you apply the <code>X</code> gate on qubit 2 if the measurement on the classical register <code>crx</code> is a 1, that is if qubit 1 (<code>q1</code>) is in the <span class=""math-container"">$|1\rangle$</span> state; and you will apply the <code>Z</code> gate on qubit 2 if the classical register <code>crz</code> is 1.</p>
<p>This can be done in qiskit with <code>c_if</code> operation. You can see example of the teleportation code in Qiskit here: <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/teleportation.html</a></p>
<br> 
<hr />
<p>Anyway, if you want to use OPENQASM, then you can do it as follow:</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[3];
creg crzz[3];   // since crz is already taken I use crzz instead
creg crxx[4];   // Again I use crxx instead of crx

h q[1];
cx q[1],q[2];
barrier q; //[0];

cx q[0],q[1];
h q[0];
barrier q;

measure q[0] -&gt; crzz[0];
measure q[1] -&gt; crxx[0];
barrier q;

if(crzz==1) z q[2];
if(crxx==1) x q[2]; 
</code></pre>
<p>Here is the image of the circuit when using Circuit_Composer option within IBMQ Experience environment.</p>
<p><a href=""https://i.stack.imgur.com/fqkoE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fqkoE.png"" alt=""enter image description here"" /></a></p>
",10/25/2020 6:28,Tooling,The question is asking about how to use the IBM Qiskit Circuit Composer to create a teleportation circuit with CRX and CRZ gates.,Tooling,,,,Tooling,
14329.0,How to verify teleportation was successful in this circuit?,"<p>In this circuit (<a href=""https://quantum-computing.ibm.com/composer/new-experiment?initial=N4IgdghgtgpiBcICOEDOUC0AXGAbGGAxgE4BepGAjCADTJpQIgDyACgKIByAigIIDKAWQAEAJgB0ABgDcAHTABLMIVwBXACYxhs5HgUAjSuKWEdcsPKTEYAc2FIA2gGYAuuZK3hEBwFY38jzsScmd-ZWsg4gAPKIcAFjD5AAt7B0owwijU9JpHUTD9CGJiBRhie3MArMdJF1y0sJSagqKSsor5eVg0VWtU2uEMAD5hYNIHWvNu1F6tR3TBkZIYiZbi0vKkSsUAM2EACmWogF5jygBKYWqHfPMFPcOyUlOL4VJU2-lC9fatzrBprMPi5Fl4GtJaCBNKgSAoAA5YBQAezATBAAF8gA"" rel=""nofollow noreferrer"">link</a>), <code>q0</code> is Alice's qubit and <code>q1</code>, <code>q2</code> are entangled qubits given to Alice and Bob respectively. After measuring <code>q2</code> in this circuit, how can it be verified that the state of <code>q0</code> and <code>q2</code> are the same?</p>
<p>By default, <code>q0</code> is in ground state, I assume. So, shouldn't <code>q2</code> be also in the ground state if the state was teleported.</p>
<p><a href=""https://i.stack.imgur.com/zWsqs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zWsqs.png"" alt=""teleportation"" /></a></p>
",<qiskit><programming><quantum-state><ibm-q-experience><teleportation>,10/25/2020 9:34,14333.0,14333.0,"<p>First, note that the circuit construction using classical condition like you have is not executable on IBM hardware at the moment. Devices like Honewywell Trapped ion allows you to do such thing (I think). However, thanks to principle of deferred measurement, we can push the measurement all the way back to the end of the circuit. <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html#real_qc"" rel=""nofollow noreferrer"">See here.</a></p>
<p>Essentially, your circuit becomes</p>
<p><a href=""https://i.stack.imgur.com/3oKq7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3oKq7.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>The state of <span class=""math-container"">$q2$</span> will depends on the state of <span class=""math-container"">$q0$</span>. If <span class=""math-container"">$q0$</span> starts in the state <span class=""math-container"">$|0\rangle$</span> then measurement in <span class=""math-container"">$q2$</span> will always (assume no noise) be 0. If instead I add the <span class=""math-container"">$X$</span> operation on <span class=""math-container"">$q0$</span> to turn it into the state <span class=""math-container"">$|1\rangle$</span> then measurement on <span class=""math-container"">$q2$</span> will registered a 1.</p>
<p>For example: if I initialize <span class=""math-container"">$q0$</span> to the state <span class=""math-container"">$|0\rangle$</span> then I will have</p>
<p><a href=""https://i.stack.imgur.com/wBbNz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wBbNz.png"" alt=""enter image description here"" /></a></p>
<br> 
<hr />
<br> 
<p>but <strong>if I initialize <span class=""math-container"">$q0$</span> to the state <span class=""math-container"">$|1\rangle$</span> then I will have</strong></p>
<p><a href=""https://i.stack.imgur.com/Sfonr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Sfonr.png"" alt=""enter image description here"" /></a></p>
",10/25/2020 18:07,Conceptual,"The question pertains to the concept of quantum teleportation and understanding the state of qubits after the teleportation process. It involves discussing the underlying principles and concepts of quantum teleportation, making it a conceptual question.",Conceptual,,,,Conceptual,
14345.0,Creating a custom gate (given by a matrix) more efficiently,"<p>I have the following gate (as represented by its matrix) on <span class=""math-container"">$4$</span> qubits which I hope to use in an error-detection code</p>
<p><span class=""math-container"">$$M=\left(
\begin{array}{cccccccccccccccc}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{array}
\right)$$</span></p>
<p>Naively, it is possible to make this gate using the following configuration of generalized toffoli gates and <span class=""math-container"">$X$</span> gates:</p>
<p><a href=""https://i.stack.imgur.com/GEeA7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GEeA7.png"" alt=""Naive way"" /></a></p>
<p>However, this is already past what is feasible to do on current machines. My question is: Is there a better way to implement <span class=""math-container"">$M$</span> or has previous research been done to create gates whose matrix representations consist solely of <span class=""math-container"">$0$</span>s and <span class=""math-container"">$1$</span>s. This is not the only gate that I could implement that would serve my purposes (in fact, there are <span class=""math-container"">$(4!)^4=24^4=331176$</span> matrices that would work), but this is the 'simplest' one (simplest as in it presents the most symmetry).</p>
",<qiskit><programming><circuit-construction><matrix-representation>,10/26/2020 21:27,14346.0,14346.0,"<p>If you look carefully, the circuit just flips the least significant qubit if the parity of the two most significant qubits is one. So, using qiskit:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator

qc = QuantumCircuit(4)

qc.cx(2, 0)
qc.cx(3, 0)

print(qc)
U = Operator(qc).data
print(U.real)
---
Output:
     ââââââââââ
q_0: â¤ X ââ¤ X â
     âââ¬âââââ¬ââ
q_1: âââ¼âââââ¼ââ
       â    â  
q_2: âââ âââââ¼ââ
            â  
q_3: ââââââââ ââ
               
array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]])
</code></pre>
",10/26/2020 22:19,Theoretical,"The question is inquiring about a specific gate represented by its matrix and is seeking a more efficient way to implement it. This falls under the theoretical category as it involves discussions about the mathematical representation of quantum gates and their implementation, which is a fundamental theoretical aspect of quantum computing.", Theoretical,,,,Theoretical,
14375.0,How to intentionally add noise to a Qiskit circuit?,"<p>I am attempting to intentionally add noise to my qiskit circuit by applying n-pairs of CNOT gates. The effect of this should be to yield the same result of my baseline (no pairs of CNOT gates applied) circuit with the addition of some noise. However, the result of my &quot;noisy&quot; circuit looks the same as my baseline even for large n. My best guess is that qiskit automatically removes unnecessary operations (like a pair of CNOTs) in an effort to reduce the number of gates. If this is true, then how can I add a series of gates which will keep the baseline circuit the same but will add gate noise?</p>
",<qiskit><programming><circuit-construction><noise>,10/28/2020 21:12,14377.0,14377.0,"<p>Yes, Qiskit's transpiler will optimize the circuit and remove redundant gates automatically. For normal operation this is desired behavior. However for cases like this where you don't want to transpiler to optimize the circuit for you and you want to send the circuit to the backend in a raw form (it will still fit it to the backend based on its constraints) you can use <code>optimization_level=0</code> kwarg for <code>transpile()</code> and <code>execute()</code>. This disables all the optimization passes and will just run the transforms necessary to run on the device (basis gate transformation, layout, routing) For example, when using <code>execute()</code> it would be: <code>qiskit.execute(circuit, backend, optimization_level=0)</code></p>
<p>If you want to experiment with the transpiler you can just call <code>qiskit.transpile(circuit, backend)</code> which will return a circuit that has been transformed so it is optimized and will be able to run on the backend. This gets internally called by <code>execute()</code> prior to sending a job to the backend so you can see what transforms are happening and tune things for your use case.</p>
<p>The documentation on transpiler covers how the transpiler works pretty well: <a href=""https://qiskit.org/documentation/apidoc/transpiler.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/apidoc/transpiler.html</a> and the tutorial <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/4_transpiler_passes_and_passmanager.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/4_transpiler_passes_and_passmanager.html</a> has examples on how you can work with it.</p>
",10/28/2020 21:58,Conceptual,"This question addresses the concept of adding noise intentionally to a quantum circuit and discusses the potential automatic optimization of gates by the Qiskit framework. It seeks a conceptual understanding of how to achieve the desired noisy effect without automatic gate removal, making it a conceptual inquiry about the behavior of quantum circuit frameworks like Qiskit.",Conceptual,,,,Conceptual,
14382.0,Cirq-Measuring a State with Rotation Matrix,"<p>I have this state:
<span class=""math-container"">$$p |\text{GHZ}\rangle \langle \text{GHZ}| + (1-p)\rho$$</span>
And after creating this state I have this code lines:</p>
<pre><code>state = p * GHZ+(1-p)* rho
state = p * GHZ + (1 - p) * rho
print(f&quot;final state: \n {state}&quot;)
print(cirq.sample_density_matrix(state, indices=[0, 1, 2], repetitions=10))
</code></pre>
<p>Now I want to measure this state. I know we have <code>cirq.measure</code> in Cirq But I don't know which kind of measurement is used by this function (and the last line is also doing measurement if I am not wrong??)</p>
<pre><code>cirq.measure(a, b, c)
</code></pre>
<p>I have 3 questions</p>
<ol>
<li><p>I want to use rotation matrix and measure my state. Do we have rotation matrix in Cirq. Can you please show me how can I measure my state with rotation matrix in Cirq?</p>
</li>
<li><p>I want to choose x and Y randomly and I want to do measurement</p>
</li>
<li><p>Which kind of measurement is used by Cirq.measure() and (cirq.sample_density_matrix(state, indices=[0, 1, 2], repetitions=10))</p>
<p>cirq.measure(a, b, c)
(cirq.sample_density_matrix(state, indices=[0, 1, 2], repetitions=10))</p>
</li>
</ol>
<p>Best and thanks</p>
",<programming><quantum-state><entanglement><measurement><cirq>,10/29/2020 0:16,14384.0,14384.0,"<ol>
<li><p><code>cirq.rx</code> <code>ry</code>, <code>rz</code> exist for rotation around X, Y and Z axes on the Bloch sphere</p>
</li>
<li><p>If you have to measure in non-computational bases, you will have to do the rotations yourself. In my answer to <a href=""https://quantumcomputing.stackexchange.com/questions/14288/bit-flip-seperable-state-and-several-question-about-cirq"">previous your question</a> I wrote two versions: one with density matrices the other one with <code>cirq.Circuit</code>.</p>
<ul>
<li><p>In case of the circuit model you can use <code>circuit.append(cirq.rx(np.pi/3)(a))</code> for example before the measurement, where <code>a</code> is the first qubit.</p>
</li>
<li><p>in case of the density matrix you'll have to calculate the tensored unitaries with <code>cirq.kron</code> and <code>cirq.unitary</code> and then multiply the density as usual: <code>unitary @ density_matrix @ unitary.conj().T</code>. For example:</p>
</li>
</ul>
<pre><code>  # this is rx(pi/3) â I â I - the first qubit gets rotated, the other
  # two remains the same
  u = cirq.kron(cirq.unitary(cirq.rx(np.pi/3)), np.eye(2), np.eye(2))
  # this applies the unitary evolution on the state density matrix 
  rotated_state = u @ state @ u.conj().T

</code></pre>
</li>
<li><p><code>cirq.measure</code> measures in the computational basis. <code>cirq.sample_density_matrix</code> samples in the computational basis repeatedly see <a href=""https://cirq.readthedocs.io/en/stable/generated/cirq.sample_density_matrix.html"" rel=""nofollow noreferrer"">reference docs</a> - it simulates &quot;preparing the state and measuring it&quot; multiple times. If you want the state after the measurement then probably <code>cirq.measure_density_matrix</code> is better suited.</p>
</li>
</ol>
",10/29/2020 1:23,API Usage,"This question falls into the API Usage category because it involves specific inquiries about how to use the Cirq framework for performing quantum measurements, including the use of rotation matrices and understanding the types of measurements used by the ""cirq.measure"" and ""cirq.sample_density_matrix ""functions.",API Usage,,,,API Usage,
14396.0,How many shots should one take to get a reliable estimate in a quantum program?,"<p>When testing my quantum programs, I wonder how many shots I must take to get a specific accuracy.</p>
<p>Are there any papers that you can recommend that analyze this?</p>
",<programming>,10/30/2020 0:04,14398.0,14398.0,"<p>This is depends on what algorithm you are executing.</p>
<p>For example, if you look at the <a href=""https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html"" rel=""noreferrer"">Bernstein-Vazirani algorithm</a> then theoretically the number of shot you need is 1 if you have a perfect quantum computer. This is because the end result that you are looking for collapsed onto a single eigenstate. However, because of noise, we would like to do more. In term of how many more, this is depends on the device. Not all device have the same noise level. You can, actually, look at the gate fidelity on the machines (at least you can do that for IBM's machines) and work out the probability that your circuit will fail, then from there determine the number of shots you might want to use. However, without doing that analysis, then you can just be on the safe side by using the maximum number of shots giving to you. For IBM's machines this works out to be 8192 shots. However, you can run multiple jobs to collect the statistics if you think you need more shots than this. Now, of course, if your quantum circuit is too long, the errors will built up so much that your circuit will &quot;essentially&quot; guarantee to fails, then additional shots will not help.</p>
<p>The above discussion is for quantum algorithms that only need <span class=""math-container"">$O(1)$</span> shots/samples. This is not true for algorithm like VQE. For VQE, we need to do <span class=""math-container"">$O(1/\epsilon^2)$</span> shots to achieve error of <span class=""math-container"">$\epsilon$</span>. For chemical accuracy, which is for <span class=""math-container"">$\epsilon = 10^{-3}$</span>, you would need to do ~<span class=""math-container"">$10^6$</span> shots at each iteration... which is insane!</p>
<p>Now if you just create a random circuit, which output a state that could be in super-position of <span class=""math-container"">$2^n$</span> eigenbasis then you will need <span class=""math-container"">$O(2^n)$</span> shots to able to able to extract the output probabilities. This why, designing a quantum algorithm is like an art. Therefore, You can't just do some operations on a quantum computers, and claim that because you did it on a quantum computer, it must be faster than doing it classically. You do not have access to the state of the qubits! This is also the reason why you can't just perform Quantum Fourier Transform ( essentially doing Discrete Fourier Transform on a quantum computer) and claim that you have a speed-up. Although, QFT does give you an exponential speed-up over DFT or even FFT (Fast Fourier Transform), doing it randomly will output a generic quantum state that in superposition of <span class=""math-container"">$2^n$</span> eigenbasis... Extracting out this state would take exponential amount of samples which then defeat the entire purpose.</p>
",10/30/2020 3:03,Learning,This question falls into the Learning category because the user is seeking recommendations for research papers that analyze the relationship between the number of shots in quantum measurements and the desired accuracy. They are looking to learn more about this topic from existing research.,Learning,,,,Learning,
14397.0,"Qiskit ""statevector_gpu"" method not available","<p>I am trying to use the <code>statevector_gpu</code> simulation method in Qiskit Aer (see <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.StatevectorSimulator.html"" rel=""nofollow noreferrer"">this</a> page). I installed <code>qiskit-aer-gpu</code> according to the instructions on <a href=""https://github.com/Qiskit/qiskit-aer"" rel=""nofollow noreferrer"">this</a> page. It was working last week and then stopped working. I'm not sure what changed. (It's a shared computer.) I get the error message <code>qiskit.providers.aer.aererror.AerError: &quot;Invalid simulation method statevector_gpu. Available methods are: ['automatic', 'statevector']&quot;</code>.</p>
<p>Thanks in advance for the help!</p>
<p>Here is the relevant system information:</p>
<ul>
<li>It is a shared computer running <code>Ubuntu 18.04.4 LTS</code>.</li>
<li>I have <code>qiskit 0.23.0</code>, <code>qiskit-aer 0.7.0</code>, <code>qiskit-aer-gpu 0.7.0</code> installed in an environment in <code>conda 4.8.5</code> with <code>python 3.8.5</code>.</li>
<li><code>nvcc --version</code> gives <code>Cuda compilation tools, release 10.0, V10.0.130</code></li>
<li><code>nvidia-smi</code> shows 4 GPUs available and indicates <code>CUDA Version: 10.2</code>.</li>
</ul>
",<qiskit><programming><simulation>,10/30/2020 0:50,14409.0,14409.0,"<p>The <code>qiskit-aer</code> and <code>qiskit-aer-gpu</code> are mutually exclusive packages. They contain the same code except that the <code>qiskit-aer-gpu</code> package built with CUDA support enabled. If you install both packages at the same time the contents of the 2 packages will interfere with each other. I would recommend creating a new conda environment and installing <code>qiskit-terra</code> and <code>qiskit-aer-gpu</code> manually with <code>pip install -U qiskit-terra qiskit-aer-gpu</code> (and add <code>qiskit-ignis</code>, <code>qiskit-aqua</code>, and <code>qiskit-ibmq-provider</code> if they're needed). If you still have issues with only qiskit-aer-gpu installed in the environment please file an issue at <a href=""https://github.com/Qiskit/qiskit-aer/issues"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aer/issues</a> and we can work on debugging it there.</p>
",10/30/2020 10:57,Errors," This question belongs to the Errors category because the user is encountering an error message (""Invalid simulation method statevector_gpu"") when trying to use a specific simulation method in Qiskit Aer. They are seeking assistance in troubleshooting and resolving this issue, which falls under the Errors category as it pertains to resolving errors and exceptions in quantum program development.",Errors,,,,Errors,
14417.0,Unknown error code [5204] when running job on IBM's qasm_simulator,"<p>I am submitting a job to ibmq_qasm_simulator and after the validation I repeatedly get the error &quot;<strong>Error running job on a simulator. [5204]</strong>&quot; The site with error descriptions <a href=""https://quantum-computing.ibm.com/docs/manage/errors"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/docs/manage/errors</a> <strong>does not have an entry</strong> for the error code 5204, so it is impossible to know what causes the error and how to fix it. Can anybody help with this?</p>
",<qiskit><programming>,10/31/2020 6:04,14479.0,14479.0,"<p>Thank you all for your help tracking this down. For future reference, the culprit was the usage of the function <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html"" rel=""nofollow noreferrer"">QuantumCircuit.initialize(params, qubits)</a>, which triggered an error out of some reason. Not sure why it fails in this case but not in others. The solution was to implement what the initialize function was supposed to do with basis gates.</p>
",11/04/2020 10:35,Errors,The User is encountering a specific error code ([5204]) while trying to run a job on the ibmq_qasm_simulator in IBMs Qiskit and is seeking help to understand and resolve this issue.,Errors ,,,,Errors,
14436.0,Cirq - Measure Density Matrix Function Getting First Element,"<p>Hello I am using measure density matrix function like that:</p>
<pre><code>for i in range (10):
    measurement_result = cirq.measure_density_matrix(state,indices=[0, 1, 2])
    print(&quot;measurement&quot;,measurement_result)
</code></pre>
<p>And my results are like that:</p>
<p><a href=""https://i.stack.imgur.com/cboKU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cboKU.png"" alt=""enter image description here"" /></a></p>
<p>As you can see, I have <code>([0, 0, 0], array([[0.36107099-0.36107099j, 0.        +0.j        ,</code>  and I want to extract first part <code>[0, 0, 0]</code> (the qubit part) and then I will count how many <code>[0, 0, 0]</code> , <code>[0, 0, 1]</code> <code>[0, 1, 0]</code> â¦ But I could not extract the first part of array. How can I get the first part <code>[0, 0, 0]</code> ?
Thanks ...</p>
",<programming><quantum-state><measurement><cirq>,11/01/2020 11:31,14440.0,14440.0,"<p>This is more of a basic python usage question. You want</p>
<p><code>first_part = measurement_result[0]</code> or <code>first_part, second_part = measurement_result</code>.</p>
",11/01/2020 17:57, API Usage,"This question falls under the API Usage category because it involves a specific inquiry about how to extract and manipulate data from the results obtained using the cirq.measure_density_matrix function. The user is seeking assistance in extracting the qubit part from the measurement results, which is related to the usage of the Cirq API for data manipulation.",API Usage,,,, API Usage,
14472.0,"Two circuits with Toffoli, Hadamard and Rx gates","<p>Can anyone explain me the behaviour of these two circuits? They contain Hadmard and rotation gates before the Toffoli gate.</p>
<p><a href=""https://i.stack.imgur.com/jfQPq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jfQPq.png"" alt=""enter image description here"" /></a></p>
<p>Results of simulation:
<a href=""https://i.stack.imgur.com/GdKhw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GdKhw.png"" alt=""enter image description here"" /></a></p>
",<quantum-gate><qiskit><programming>,11/03/2020 20:49,14473.0,14473.0,"<p><strong>In the first circuit</strong> after Hadamard gates (I suppose that initial state is <span class=""math-container"">$|000\rangle$</span> and I will use Qiskit's convention for labeling the qubits <span class=""math-container"">$|q_2 q_1 q_0 \rangle$</span>):</p>
<p><span class=""math-container"">$$|000\rangle \xrightarrow[]{\text{Hadamards}} \frac{1}{2}|0\rangle(|00\rangle + |01\rangle+|10\rangle + |11\rangle)$$</span></p>
<p>The <span class=""math-container"">$R_x(0) = I$</span>, so it does noting. Then comes Toffoli gate (apply <span class=""math-container"">$X$</span> gate on the <span class=""math-container"">$q_2$</span> qubit if the other two (control qubits) are in <span class=""math-container"">$|1\rangle$</span> state):</p>
<p><span class=""math-container"">$$\xrightarrow[]{\text{Toffoli}} \frac{1}{2}|0\rangle(|00\rangle + |01\rangle+|10\rangle) + \frac{1}{2}|111\rangle$$</span></p>
<p><strong>In the second circuit</strong> <span class=""math-container"">$R_x(\pi) = -iX$</span> (we can neglect <span class=""math-container"">$-i $</span> term because it is a global phase here) and the combained action of Hadamards plus <span class=""math-container"">$R_x(\pi)$</span></p>
<p><span class=""math-container"">$$|000\rangle \xrightarrow[]{\text{Hadamards + }R_x(\pi)} \frac{1}{2}|1\rangle(|00\rangle + |01\rangle+|10\rangle + |11\rangle)$$</span></p>
<p>Then Toffoli:</p>
<p><span class=""math-container"">$$\xrightarrow[]{\text{Toffoli}} \frac{1}{2} |1\rangle (|00\rangle + |01\rangle+|10\rangle) + \frac{1}{2}|011\rangle$$</span></p>
",11/03/2020 21:17,Theoretical,This question falls into the Theoretical category as the user is seeking an explanation of the behavior of two quantum circuits that contain Hadamard and rotation gates before a Toffoli gate. The question is focused on understanding the theoretical aspects of quantum circuit behavior and the impact of specific gates on quantum states.,Conceptual,The user is asking for an explanation of the behavior of two quantum circuits that include Hadamard and rotation gates before a Toffoli gate. This falls under the Conceptual category as it involves understanding the underlying concepts and principles of quantum programming.,No,98.0,Theoretical, The user is seeking an explanation of the behavior of two quantum circuits that contain Hadamard and rotation gates before a Toffoli gate. This question is focused on understanding the theoretical aspects of quantum circuit behavior and the impact of specific gates on quantum states.
14483.0,How do I fix the UnboundLocalError?,"<p>I have read about the global and nonlocal variable and I know they may solve the problem, but as I'm still naive at this I couldn't figure out how to implement them to solve the UnboundLocalError. Sorry for the long program I put here:</p>
<pre><code> # initialization

import numpy as np

# import Qiskit

from qiskit import IBMQ, BasicAer
from qiskit.providers.ibmq import least_busy
from qiskit import QuantumCircuit, execute
from qiskit.tools.jupyter import *
#provider= IBMQ.load.account()
 provider= IBMQ.load_account()

#import basic plot tools
from qiskit.visualization import plot_histogram
</code></pre>
<p>Here is the Dj function</p>
<pre><code> def dj_oracle(case, n):
#We need to make a QuantumCircuit object to return
#This circuit has n+1 qubits: the size of the input,
#plus one output qubit
oracle_qc=QuantumCircuit(n+1)

#First, let's deal with the case in which oracle is balanced

if case == &quot;balanced&quot;:
    # We apply controlled-NOT gates for each qubit, using the
    #output qubit as target
    
    for qubit in range(n):
        oracle_qc.cx(qubit, n)
        
 # case in oracle is constant
if case == &quot;constant&quot;:

# First decide what the fixed output of the oracle will be
# (either always 0 or always 1)
 
    output = np.random.randint(2)
    
if output == 1:
    
    oracle_qc.x(n)
    
oracle_gate = oracle_qc.to_gate()
oracle_gate.name =&quot;Oracle&quot;
return oracle_gate
</code></pre>
<p>and Here is the dj_algorithm</p>
<pre><code>  def dj_algorithm(n, case='random'):
dj_circuit=QuantumCircuit(n+1, n)
# Set up the input register:
for qubit in range(n):
    dj_circuit.h(qubit)
#And set up the output qubit:
dj_circuit.x(n)
dj_circuit.h(n)
#Let's append the oracle gate to our circuit:

if case == 'random':
    random = np.random.randint(2)
    if random == 0:
        case = 'constant'
else: 
    case = 'balanced'
    oracle = dj_oracle(case, n)
    dj_circuit.append(oracle, range(n+1))
 # Finally, perform the H-gates again and measure:
for i in range(n):
        dj_circuit.h(i)
        dj_circuit.measure(i,i)
return dj_circuit
</code></pre>
<p>Now when I want to use the local simulator to get the results, I face the UnboundLocalError, Can anybody help me to solve it?</p>
<p>This is the error I get:</p>
<hr />
<pre><code>  UnboundLocalError                         Traceback (most recent call last)
  &lt;ipython-input-112-f0c5e2ae7e9a&gt; in &lt;module&gt;
  2 backend = BasicAer.get_backend('qasm_simulator')
  3 shots = 1024
  ----&gt; 4 dj_circuit = dj_algorithm(n,'constant')
  5 results = execute(dj_circuit, backend=backend, shots=shots).result()
  6 answer = results.get_counts()

 &lt;ipython-input-89-6104e1173619&gt; in dj_algorithm(n, case)
 15     else:
 16         case = 'balanced'
 ---&gt; 17         oracle = dj_oracle(case, n)
 18         dj_circuit.append(oracle, range(n+1))
 19      # Finally, perform the H-gates again and measure:

 &lt;ipython-input-110-75bb51aa8b15&gt; in dj_oracle(case, n)
 22         output = np.random.randint(2)
 23 
 ---&gt; 24     if output == 1:
 25 
 26         oracle_qc.x(n)

 UnboundLocalError: local variable 'output' referenced before assignment
</code></pre>
",<programming><non-locality>,11/04/2020 16:55,14513.0,14513.0,"<p>This is a Python related question. I think it should be asked in <a href=""https://stackoverflow.com/"">stackoverflow</a></p>
<p><br>This error happens because you try to check the value of the variable <code>output</code> before assigning a value to it.
<br>As you may know, Python is space sensitive. Hence, the line where you check if <code>output</code> equals 1 will be executed regardless of <code>case</code> value. On the other hand,
the variable <code>output</code> will be initialized only if <code>case</code> equals <code>&quot;constant&quot;</code>.
<br>This means this error will happen whenever <code>case</code> equals <code>&quot;balanced&quot;</code></p>
",11/06/2020 17:58,Errors,"This question falls into the Errors category because the user is encountering an ""UnboundLocalError"" in their code and is seeking help to resolve it. The error is related to a local variable issue within the code, and the user is looking for assistance in understanding and rectifying this error, which is a common type of issue encountered during programming.",Errors,,,,Errors,
14484.0,Applying conditional X-gate in Qiskit,"<p>I have problem with implementation of the circuit below. How can I write down the conditional X-gate in the following circuit?</p>
<p><a href=""https://i.stack.imgur.com/QjGfv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QjGfv.png"" alt=""enter image description here"" /></a></p>
",<qiskit><programming>,11/04/2020 18:48,14485.0,14485.0,"<p>This can be done in qiskit with <code>c_if</code> operation.</p>
<p>To construct the circuit that you are interested in in OPENQASM, you can do it as follow:</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[2];
creg cw[1];
creg cw2[1];


z q[0];
h q[1];
h q[0];
h q[1];
z q[0];
barrier q[0],q[1];
measure q[0] -&gt; cw[0];
barrier q[0],q[1];
if (cw==1) x q[1];
barrier q[0],q[1];
measure q[1] -&gt; cw2[0];
</code></pre>
<p>The result circuit is:</p>
<p><a href=""https://i.stack.imgur.com/wgt4b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wgt4b.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>Also look at this question and answer: <a href=""https://quantumcomputing.stackexchange.com/questions/14326/composing-teleportation-circuit-in-qiskit-circuit-composer/14328#14328"">Composing teleportation circuit in Qiskit Circuit Composer</a></p>
<hr />
<p><strong>Update:</strong> You can also run this with Qiskit as:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

qreg_q = QuantumRegister(2, 'q')
creg_cw = ClassicalRegister(1, 'cw')
creg_cw2 = ClassicalRegister(1, 'cw2')
circuit = QuantumCircuit(qreg_q, creg_cw, creg_cw2)

circuit.z(qreg_q[0])
circuit.h(qreg_q[1])
circuit.h(qreg_q[0])
circuit.h(qreg_q[1])
circuit.z(qreg_q[0])
circuit.barrier(qreg_q[0], qreg_q[1])
circuit.measure(qreg_q[0], creg_cw[0])
circuit.barrier(qreg_q[0], qreg_q[1])
circuit.x(qreg_q[1]).c_if(creg_cw, 1)
circuit.barrier(qreg_q[0], qreg_q[1])
circuit.measure(qreg_q[1], creg_cw2[0])

circuit.draw('mpl', style={'name': 'iqx'})
</code></pre>
<p>It should be noted that if you compose your circuit in OPENQASM, there is an option that would allow you to convert it to Qiskit code. Look for this tab in circuit composer:</p>
<p><a href=""https://i.stack.imgur.com/zIhjv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zIhjv.png"" alt=""enter image description here"" /></a></p>
",11/04/2020 18:52,Conceptual,This question belongs to the Conceptual category as the user is seeking an explanation of how to implement a conditional X-gate in a quantum circuit. They are looking for a conceptual understanding of the circuit element and its implementation within the given context., Conceptual,,,,Conceptual,
14491.0,Traveling salesman problem in Qiskit: cannot find a solution on simulator,"<p>I am trying to solve Traveling Salesman Problem (TSP) in Qiskit based on Qiskit Tutorial.</p>
<p>I used TSP for four cities described by this distance matrix:</p>
<p><span class=""math-container"">$$
D = 
\begin{pmatrix}
0 &amp; 207 &amp; 92 &amp; 131 \\
207 &amp; 0 &amp; 300 &amp; 350 \\
92 &amp; 300 &amp; 0 &amp; 82\\
131 &amp; 350 &amp; 82&amp; 0 \\
\end{pmatrix}
$$</span></p>
<p>With brute force I found two optimal solutions:</p>
<ol>
<li><span class=""math-container"">$0 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 0$</span></li>
<li><span class=""math-container"">$0 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow 0$</span></li>
</ol>
<p>A total distance is 720 for both solutions.</p>
<p>However, when I run the problem on <code>qasm_simulator</code> with <code>TSP</code> algorithm in <code>qiskit.optimization.applications.ising</code> library, the returned solution is <span class=""math-container"">$0 \rightarrow 2 \rightarrow 3 \rightarrow 1 \rightarrow 0$</span> with distance 873. But according to matrix <span class=""math-container"">$D$</span>, the total distance should be 731.</p>
<p>I can understand that the quantum solver cannot reach the optimal solution but I am rather confused by miscalculated total distance for the solution which was found.</p>
<p><strong>So my questions is what wrong in my code?</strong> Just note that solution for example in Qiskit Tutorial was found correctly.</p>
<p><em>My second question is how to set TSP solver to reach an optimal solution?</em> I would expect that since I use a simulator, there is no noise and in the end I would reach the optimal solution.</p>
<p><strong>EDIT:</strong>
It seems that if the code is rerun, the results are different. I reached the distance 731, user <em>Egretta Thua</em> even the optimal 720. However, the first city in solution should be the city no. 0 which was not the case both in my or <em>Egretta</em> code rerun.</p>
<hr />
<p><em>Here is my code:</em></p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries and configuring account
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
#visualization tools
import matplotlib.pyplot as plt
import matplotlib.axes as axes
#other tool
import numpy as np
import networkx as nx
from itertools import permutations
#quadratic program
from qiskit.optimization import QuadraticProgram
#TSP libraries
from qiskit.optimization.applications.ising import tsp
from qiskit.optimization.applications.ising.common import sample_most_likely
#quantum computing optimization
from qiskit.optimization.converters import IsingToQuadraticProgram
from qiskit.aqua.algorithms import VQE, QAOA, NumPyMinimumEigensolver
from qiskit.optimization.algorithms import MinimumEigenOptimizer

#function for solving the TSP with brute force, i.e. generate all permutations and calc distances
def brute_force_tsp(w):
    N = len(w)
    #generate tuples with all permutation of numbers 1,2...N-1
    #first index is zero but we want to start our travel in the first city (i.e. with index 0)
    a = list(permutations(range(1,N)))
    
    best_dist = 1e10 #distance at begining
    
    for i in a: #for all permutations
        distance = 0
        pre_j = 0 #starting in city 0
        for j in i: #for each element of a permutation
            distance = distance + w[pre_j,j] #going from one city to another
            pre_j = j #save previous city
        distance = distance + w[pre_j,0] #going back to city 0
        order = (0,) + i #route description (i is permutation, 0 at the begining - the first city)
        print('Order: ', order, ' Distance: ', distance) #show solutions
        if distance &lt; best_dist:
            best_dist = distance
            best_order = order           
        
    print('Route length: ', best_dist)
    print('Route: ', best_order)    
    
    return best_dist, best_order

#showing resulting route in graph
def show_tsp_graph(route):
    n = len(route)
    #showing the route in graph
    G = nx.Graph() #graph
    G.add_nodes_from(range(0,n)) #add nodes
    #adding edges based on solution    
    for i in range(0,n-1):
        G.add_edge(route[i], route[i+1])
    G.add_edge(route[n-1], 0)
    nx.draw_networkx(G) #show graph

#decoding binary output of QAOA to actual solution
def decodeQAOAresults(res):
    n = int(len(res)**0.5)
    results = np.zeros(n)
    k = 0
    for i in range(0,n): #each n elements refers to one time point i
        for j in range(0,n): #in each time points there are all cities
            #when x = 1 then the city j is visited in ith time point
            if res[k] == 1: results[i] = j
            k = k + 1
    return results

def tspQuantumSolver(distances, backendName):
    citiesNumber = len(distances)
    coordinates = np.zeros([citiesNumber, 2])
    for i in range(0, citiesNumber): coordinates[i][0] = i + 1
    
    tspTask = tsp.TspData(name = 'TSP', dim = citiesNumber, w = distances, coord = coordinates)
    
    isingHamiltonian, offset = tsp.get_operator(tspTask)
    
    tspQubo = QuadraticProgram()
    tspQubo.from_ising(isingHamiltonian, offset)
    
    quantumProcessor = Aer.backends(name = backendName)[0]
    qaoa = MinimumEigenOptimizer(QAOA(quantum_instance = quantumProcessor))
    results = qaoa.solve(tspQubo)
    print('Route length: ', results.fval)
    route = decodeQAOAresults(results.x)
    print('Route: ', route)
    
    return results.fval, route

distMatrix = np.array([[0,207,92,131],
                       [207,0,300,350],
                       [92,300,0,82],
                       [131,350,82,0]
                       ])

#brute force solution
lengthBrute, routeBrute = brute_force_tsp(distMatrix)
show_tsp_graph(routeBrute)

#quantum solution
lengthQuantum, routeQuantum = tspQuantumSolver(distMatrix, 'qasm_simulator')
show_tsp_graph(routeQuantum)

</code></pre>
",<qiskit><programming><ibm-q-experience><quantum-computing-for-finance>,11/05/2020 07:57,14520.0,14520.0,"<p>Qiskit has a <a href=""https://qiskit.org/documentation/tutorials/optimization/6_examples_max_cut_and_tsp.html"" rel=""nofollow noreferrer"">tutorial documentation</a> about TSP, you can find more detail at that site.
As for the problem of your code, I suggest you use the qiskit-built function</p>
<pre><code>tsp.random_tsp(3,seed=123) # 3 for three cities
</code></pre>
<p>to generate the route, instead of a single distance matrix you have written. Because <code>tsp.random_tsp(3,seed=123)</code> generates the coordinates and distance matrix correspondingly, while your coordinates are simply a <span class=""math-container"">$i$</span> iteration.</p>
<p>To see the difference between the two methods,
<a href=""https://i.stack.imgur.com/5QyHV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5QyHV.png"" alt=""tsp right coordinate"" /></a></p>
<p>you can use the coordinates to calculate your density matrix, while your own method will be problematic at this phase.</p>
<p>(A list of coordinates <code>[[1,0],[2,0],[3,0],[4,0]]</code> cannot generate a distance matrix <code>[[0,207,92,131],[207,0,300,350],[92,300,0,82],[131,350,82,0]]</code> unless your tsp space is highly inhomogeneous.)</p>
<p>Here ends my investigation, I have not tested further. Discussions are welcomed.</p>
",11/07/2020 09:59,Errors,This question belongs to the Errors category because the user is encountering issues with their code related to solving the Traveling Salesman Problem (TSP) using Qiskit. They are facing problems with the calculated distances and are seeking help to understand what is wrong with their code.,Errors,,,,Errors,
14537.0,TypeError: 'NumPyMinimumEigensolver' object is not subscriptable,"<p>I'm trying to implement the same Jupyter notebook Jin-Sung Kim gave in his YouTube video <a href=""http://The%20Variational%20Quantum%20Eigensolver%20%E2%80%94%20Programming%20on%20Quantum%20Computers%20%E2%80%94%20Coding%20with%20Qiskit%20S2E4"" rel=""nofollow noreferrer"">The Variational Quantum Eigensolver â Programming on Quantum Computers â Coding with Qiskit S2E4</a>; however, I'm facing the error as below:</p>
<p><strong>Error:</strong></p>
<pre><code>step 0
/Users/bambrozi/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py:91: DeprecationWarning: The ChemistryOperator is deprecated as of Qiskit Aqua 0.8.0 and will be removed no earlier than 3 months after the release date. Instead, the FermionicTransformation can be used to transform QMolecules and construct ground state result objects.
  super().__init__()
/Users/bambrozi/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py:415: DeprecationWarning: Processing a dictionary result is deprecated, pass a (minimum) eigensolver result now.
  warnings.warn('Processing a dictionary result is deprecated,'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-3-66becf9098c9&gt; in &lt;module&gt;
     13     # exact classical result
     14     exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)
---&gt; 15     exact_result = operator.process_algorithm_result(exact_result)
     16 
     17     # VQE

~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/chemistry_operator.py in process_algorithm_result(self, algo_result)
     88             return self._process_algorithm_result(algo_result)
     89         else:
---&gt; 90             lines, result = self._process_algorithm_result(algo_result)
     91             result['algorithm_retvals'] = algo_result
     92             return lines, result

~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py in _process_algorithm_result(self, algo_result)
    374             # TODO return self._process_algorithm_result_excited_states(algo_result)
    375         else:
--&gt; 376             return self._process_algorithm_result_deprecated(algo_result)
    377 
    378     def _process_algorithm_result_ground_state(self, algo_result: MinimumEigensolverResult) \

~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py in _process_algorithm_result_deprecated(self, algo_result)
    419 
    420         # Ground state energy
--&gt; 421         egse = algo_result['energy'] + self._energy_shift + self._ph_energy_shift
    422         result['energy'] = egse
    423         lines = ['=== GROUND STATE ENERGY ===']

TypeError: 'NumPyMinimumEigensolver' object is not subscriptable
</code></pre>
<p><strong>Source-code:</strong></p>
<pre><code># %%
import numpy as np 
import pylab 
import copy
from qiskit import BasicAer 
from qiskit.aqua import aqua_globals, QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE 
from qiskit.aqua.components.optimizers import SLSQP 
from qiskit.chemistry.components.initial_states import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver 
from qiskit.chemistry.core import Hamiltonian, QubitMappingType
# %%
molecule = 'H .0 .0 -{0}; Li .0 .0 {0}'
distances = np.arange(0.5, 4.25, 0.25)
vqe_energies = []
hf_energies = []
exact_energies = []
# %%
for i, d in enumerate(distances):
    print('step', i)

    # set up experiment:
    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')
    qmolecule = driver.run()
    operator = Hamiltonian(qubit_mapping=QubitMappingType.PARITY,
                           two_qubit_reduction=True, 
                           freeze_core=True,
                           orbital_reduction=[-3, -2])
    qubit_op, aux_ops = operator.run(qmolecule)

    # exact classical result
    exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)
    exact_result = operator.process_algorithm_result(exact_result)

    # VQE
    optimzer = SLSQP(maxiter=1000)
    initial_state = HartreeFock(operator.molecule_info['num_orbitals'],
                                 operator.molecule_info['num_particles'],
                                 qubit_mapping=operator._qubit_mapping,
                                 two_qubit_reduction=operator._two_qubit_reduction)
    var_form = UCCSD(num_orbitals=operator.molecule_info['num_orbitals'],
                     num_particles=operator.molecule_info['num_particles'],
                     initial_state=initial_state,
                     qubit_mapping=operator._qubit_mapping,
                     two_qubit_reduction=operator._two_qubit_reduction)
    algo = VQE(qubit_op, var_form, optimzer, aux_operators=aux_ops)

    vqe_result = algo.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))
    vqe_result = operator.process_algorithm_result(vqe_result)

    exact_energies.append(exact_result.energy)
    vqe_energies.append(vqe_result.energy)
    hf_energies.append(vqe_result.hartree_fock_energy)
</code></pre>
<p>Thanks for the help!</p>
",<qiskit><programming><vqe>,11/08/2020 22:23,14540.0,14540.0,"<p>The line:</p>
<p><code>exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)</code></p>
<p>should be</p>
<p><code>exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops).run()</code></p>
<hr />
<p>Here is the full code that I ran and its output:</p>
<pre><code># %%
import numpy as np 
import pylab 
import copy
from qiskit import BasicAer 
from qiskit.aqua import aqua_globals, QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE 
from qiskit.aqua.components.optimizers import SLSQP 
from qiskit.chemistry.components.initial_states import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver 
from qiskit.chemistry.core import Hamiltonian, QubitMappingType
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = 'svg' # Makes the images look nice


molecule = 'H .0 .0 -{0}; Li .0 .0 {0}'
distances = np.arange(0.5, 4.25, 0.25)
vqe_energies = []
hf_energies = []
exact_energies = []
# %%
for i, d in enumerate(distances):
    print('step', i)

    # set up experiment:
    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')
    qmolecule = driver.run()
    operator = Hamiltonian(qubit_mapping=QubitMappingType.PARITY,
                           two_qubit_reduction=True, 
                           freeze_core=True,
                           orbital_reduction=[-3, -2])
    qubit_op, aux_ops = operator.run(qmolecule)

    # exact classical result
    exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops).run()
    exact_result = operator.process_algorithm_result(exact_result)

    # VQE
    optimzer = SLSQP(maxiter=1000)
    initial_state = HartreeFock(operator.molecule_info['num_orbitals'],
                                 operator.molecule_info['num_particles'],
                                 qubit_mapping=operator._qubit_mapping,
                                 two_qubit_reduction=operator._two_qubit_reduction)
    var_form = UCCSD(num_orbitals=operator.molecule_info['num_orbitals'],
                     num_particles=operator.molecule_info['num_particles'],
                     initial_state=initial_state,
                     qubit_mapping=operator._qubit_mapping,
                     two_qubit_reduction=operator._two_qubit_reduction)
    algo = VQE(qubit_op, var_form, optimzer, aux_operators=aux_ops)

    vqe_result = algo.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))
    vqe_result = operator.process_algorithm_result(vqe_result)

    exact_energies.append(exact_result.energy)
    vqe_energies.append(vqe_result.energy)
    hf_energies.append(vqe_result.hartree_fock_energy)
    
fig = plt.figure()
plt.plot(distances,vqe_energies, label ='Mean Values')
plt.show()
</code></pre>
<p><a href=""https://i.stack.imgur.com/8oBXj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8oBXj.png"" alt=""enter image description here"" /></a></p>
",11/08/2020 22:56,Errors,"This question falls under the Errors category because the user is encountering an error while trying to implement code from a Jupyter notebook for the Variational Quantum Eigensolver (VQE). They have provided the error message and the source code, seeking assistance in resolving the error.",Errors,,,,Errors,
14541.0,Comparing QSVM & Classic SVM on BigData. Quantum Supremacy,"<p>I work on comparing QSVM and Classic SVM (SKlearnSVM) with using Qiskit. I have to show
quantum supremacy at 400000-500000 samples but I don't get good results. I have problem with long time training and using big RAM when I use big training samples (In both cases). If I use big training samples in quantum algorithm, I can't get results of tests in short time (such as 1-4 days is acceptable). For example, I try do a test with 1000000 samples when I train quantum kernel on 20 samples and I got a bug in running state for some work (It was already above 10000 works; The work hanged). The reason of bug is unknown. For tests I use 2 quants (maybe it is little?) and last version libraries. Dataset is my generate (with perceptible differents). I try normalize dataset but I got a code mistake of numpy library (can't reshape array ant e.t.c).
For begining I used example from github tutorial, next I used other methods of class (that I find in qiskit - .train(),.test()) but I don't see differents here (if I use .run() and .predict() with rebooting of kernel).</p>
<p>And I have question - So can I to show this comparing generally with using Qiskit? So how? Maybe can I show quantum supremacy on other size of samples? Or can I use Qiskit library wrong?</p>
",<programming><ibm-q-experience><quantum-advantage><quantum-enhanced-machine-learning>,11/09/2020 09:53,14549.0,14549.0,"<p>There is a difference between <strong>Quantum Supremacy</strong> and <strong>Quantum Advantage</strong>.</p>
<p>Quantum Supremacy has been shown on a quantum computer, first by Google in 2019 through their paper <a href=""https://www.nature.com/articles/s41586-019-1666-5"" rel=""nofollow noreferrer"">Quantum supremacy using a programmable superconducting processor</a>. Roughly speaking, quantum supremacy test is about generating random states that is not at all efficient classical simulatable.</p>
<p>Quantum advantage is about solving practical problems with speed-up over classical computer even against the world's best supercomputer. This is <strong>no where</strong> near being achievable. For instance, to run Shor's algorithm on a 2000 bit number into its primes would require millions of physical qubits (because you need to use additional qubits for error corrections) while require each physical qubits to be under certain error threshold. If you look at what we have now then you can see this is pretty far off!</p>
<p><a href=""https://i.stack.imgur.com/6hqTF.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6hqTF.jpg"" alt=""enter image description here"" /></a></p>
<p>lately, there have been a lot of interest in using quantum computers for chemistry related problems. In particular, the electronic structure problem. So maybe it is interesting to when there will be quantum advantage in that topic...  A recent paper, <a href=""https://arxiv.org/abs/2009.12472"" rel=""nofollow noreferrer"">How will quantum computers provide an industrially relevant computational advantage in quantum chemistry?</a>  shows that we are still a long time a way as well from seeing quantum advantage in this arena. I should note that there are <a href=""https://arxiv.org/abs/2011.03494"" rel=""nofollow noreferrer"">new proposed techniques</a> that can shorten the computational time for the quantum computers on these problems but the quantum resource (number of qubits) is very high.</p>
<hr />
<p>So if you are looking for quantum advantage on your problem with current devices, then I don't you will find it.</p>
",11/09/2020 16:17,Tooling,"This question primarily pertains to the tools and software usage in quantum programming, specifically related to issues with training times, large training samples, and code errors when using Qiskit for comparing Quantum Support Vector Machines (QSVM) and Classical Support Vector Machines (SVM).",Tooling,,,,Tooling,
14647.0,How does Qiskit Aqua commutator work?,"<p>Commutation operation is essential in quantum mechanics, but when I was trying to use the commutator of IBM qiskit I find something confusing.</p>
<p>Here comes the problematic code.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix
from qiskit.aqua.operators.legacy import commutator

qr0=QuantumCircuit(1)
qr1=QuantumCircuit(1)
circ0.x(0)
dm0=DensityMatrix.from_instruction(circ0)
circ1.z(0)
dm1=DensityMatrix.from_instruction(circ1)
</code></pre>
<p>The upper codes generates two Density Matrices, and since they are matrices, mathematically we can compute their commutator, but then after you run <code>commutator(dm0,dm1)</code> you'll find that it's not working. Even if you try some other types like input two Operators or input the detailed matrices(<code>dm.data</code>) but it is just raised an error. E.g. in the lower code when the detailed matrices case returns an error.</p>
<pre><code>dm0=Operator(dm0)
dm1=Operator(dm1)
commutator(dm0.data,dm1.data)
</code></pre>
<p>The errors that qiskit reports are nearly identical so I just put one of them as an example.</p>
<p><a href=""https://i.stack.imgur.com/q1ai0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q1ai0.png"" alt=""enter image description here"" /></a></p>
<p>I know numpy or scipy can help me in circumventing the trouble, but I still want to ask: have anyone meet this before? Do you know how to fix this? Thanks!</p>
",<qiskit><programming>,11/15/2020 12:58,14648.0,14648.0,"<p>According with <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.legacy.commutator.html"" rel=""nofollow noreferrer"">the <code>commutator</code> documentation</a>, it works on <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.legacy.WeightedPauliOperator.html"" rel=""nofollow noreferrer""><code>WeightedPauliOperator</code></a>, not on numpy arrays.</p>
<pre><code>from qiskit.aqua.operators.legacy import commutator
from qiskit.aqua.operators import WeightedPauliOperator
from qiskit.quantum_info import Pauli

pauli_a = 'X'
pauli_b = 'Z'
coeff_a = 0.5
coeff_b = 0.5
pauli_term_a = [coeff_a, Pauli.from_label(pauli_a)]
pauli_term_b = [coeff_b, Pauli.from_label(pauli_b)]
op_a = WeightedPauliOperator(paulis=[pauli_term_a])
op_b = WeightedPauliOperator(paulis=[pauli_term_b])

print(commutator(op_a, op_b))
</code></pre>
<pre><code>Representation: paulis, qubits: 1, size: 1
</code></pre>
",11/15/2020 13:19, Errors,The question is asking for help fixing an error raised by the commutator() function in Qiskit.,Errors,,,, Errors,
14659.0,Simulator-dependent implementations in Q#,"<p>I have a Q# operation:</p>
<pre><code>    operation init_and(a: Qubit, b: Qubit, target: Qubit) : Unit is Adj {
        // Uncomment this when using Toffoli simulator.
        // CCNOT(a, b, target);

        // Uncomment this when doing resource estimates.
        body(...) {
            CCNOT(a, b, target);
        }
        adjoint(...) {
            H(target);
            if (M(target) == One) {
                CZ(a, b);
            }
        }
    }
</code></pre>
<p>As you can see from the comments, I have to choose between being able to simulate the operation (when testing the correctness of constructions using it) and being able to correctly cost the operation (because uncomputing it should cost zero T gates).</p>
<p>Is there some way to get the best of both worlds? For example, some way to say &quot;when testing correctness use this, when doing cost estimates use this&quot;? Some way to query &quot;Is the Hadamard available?&quot;?</p>
",<programming><q#>,11/16/2020 3:38,20694.0,20694.0,"<p>For the sake of completeness: June release of Q# now offers AutoSubstitution rewrite step, which allows to substitute an implementation of an operation with a different one when running on a specific simulator. <a href=""https://devblogs.microsoft.com/qsharp/the-autosubstitution-rewrite-step/"" rel=""nofollow noreferrer"">This blog post</a> offers more details on how to use it.</p>
<p>The example from the question will look like this:</p>
<pre><code>namespace Scratch {
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Targeting;

    @SubstitutableOnTarget(&quot;Scratch.InitAndToffoli&quot;, &quot;ToffoliSimulator&quot;)
    operation InitAnd(a: Qubit, b: Qubit, target: Qubit) : Unit is Adj {
        // This implementation will be called on any simulator except Toffoli
        body(...) {
            Message(&quot;InitAnd body&quot;);
            CCNOT(a, b, target);
        }
        adjoint(...) {
            Message(&quot;Adjoint InitAnd body&quot;);
            H(target);
            if (M(target) == One) {
                CZ(a, b);
            }
        }
    }


    operation InitAndToffoli(a: Qubit, b: Qubit, target: Qubit) : Unit is Adj {
        // This implementation will be called only on Toffoli simulator
        Message(&quot;InitAndToffoli&quot;);
        CCNOT(a, b, target);
    }


    // Make the sample complete as a standalone executable
    @EntryPoint()
    operation RunIt() : Unit {
        use (a, b, target) = (Qubit(), Qubit(), Qubit());
        InitAnd(a, b, target);
        // The required workaround to make sure substitute operation
        // is available to the runtime - will be removed soon.
        let _ = InitAndToffoli;
    }
}
</code></pre>
<p>Now, if you run it from command line:</p>
<ul>
<li><code>dotnet run</code> will use default full state simulator, and print &quot;InitAnd body&quot;</li>
<li><code>dotnet run -s ToffoliSimulator</code> will use Toffoli with the substitution, and print &quot;InitAndToffoli&quot;</li>
<li><code>dotnet run -s ResourcesEstimator</code> will use resources estimator without substitution, print &quot;InitAnd body&quot; and the resources count.</li>
</ul>
<p>The accompanying .csproj file looks like this (note the package reference which provides <code>Microsoft.Quantum.Targeting</code> namespace):</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.Quantum.Sdk/0.18.2107153439&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Microsoft.Quantum.AutoSubstitution&quot; 
      Version=&quot;0.18.2107153439&quot; IsQscReference=&quot;true&quot; /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
",08/02/2021 22:46,API Usage,"The User is asking about how to use specific features in the Q# quantum programming language, specifically how to choose between different implementations of an operation for different purposes (testing correctness vs. cost estimation).",API Usage,,,,API Usage,
14681.0,IBM Q - Individual Run Results,"<p>In Qiskit, is there a way to get the individual results from each shot on the IBM quantum device (instead of simply the summary statistics)? The result JSON file provides the count of all the 1024 shots.</p>
",<qiskit><programming><ibm-q-experience>,11/16/2020 18:01,14682.0,14682.0,"<p>You can set <code>memory=True</code> in <code>assemble()</code> or <code>execute()</code>. Then use <code>result.get_memory()</code> to get the per-shot measurement.</p>
<p>For example:</p>
<pre><code>job = execute(circs, memory=True, shots=4)
result = job.result()
print(result.get_counts(0))  # prints {'00': 3, '11': 1}
print(result.get_memory(0))  # prints ['00', '00', '11', '00']  
</code></pre>
",11/16/2020 19:28, API Usage,"The User is asking about how to use a specific feature in the Qiskit library, specifically how to get individual results from each shot on the IBM quantum device.",API Usage,,,, API Usage,
14698.0,$S^{\dagger}$ gate in Q#,"<p>I would like to implement <span class=""math-container"">$S^{\dagger}$</span> gate in Q# and I would like the best way to do it, is it correct to say that <span class=""math-container"">$S^{\dagger}$</span> is equivalent to <code>R1( -Pi()/2 , q)</code> ? Is it also correct to say that <span class=""math-container"">$S^{\dagger}$</span> is equivalent to <code>Rz( -Pi()/2 , q)</code> but with a global phase ?</p>
<p>Thank you.</p>
",<q#>,11/17/2020 13:31,14699.0,14699.0,"<p>It is correct. Since you have <span class=""math-container"">$R_1(\theta) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; e^{i\theta}\end{bmatrix}$</span> and <span class=""math-container"">$R_z(\theta) = \begin{bmatrix}e^{-i\theta/2} &amp; 0\\ 0 &amp; e^{i\theta/2}\end{bmatrix}$</span> just using the value of <span class=""math-container"">$\theta = -\pi/2$</span> gives you <span class=""math-container"">$R_1(-\pi/2) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix} = S^{\dagger}$</span> and <span class=""math-container"">$R_z(-\pi/2) = e^{i\pi/4}\begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix}$</span> which works exactly the same as <span class=""math-container"">$S^{\dagger}$</span> but with a global phase of <span class=""math-container"">$e^{i\pi/4}$</span>.</p>
",11/17/2020 13:56, Conceptual,"This question pertains to the conceptual understanding of quantum gates and their representations in Q# programming. The user is seeking clarification on whether the S gate can be implemented as R1(-Pi()/2, q) or Rz(-Pi()/2, q) and is inquiring about the equivalence and global phase associated with these implementations.",Conceptual,,,, Conceptual,
14715.0,How does the CX gate work?,"<p>I have a silly question as I am an absolute beginner! So as described in Qiskit:</p>
<blockquote>
<p>It performs the NOT operation (equivalent to applying an X gate) on the second qubit only when the first qubit is <span class=""math-container"">$|1\rangle$</span> and otherwise leaves it unchanged.</p>
</blockquote>
<p>in the piece of the related program we have :</p>
<pre><code># Let's do an CX-gate on |00&gt;
q = QuantumRegister(2)
qc = QuantumCircuit(q)
qc.cx(q[0],q[1])
qc.draw(output='mpl')
</code></pre>
<p>In my mind I need 2 inputs for a CX gate A &amp; B as (<code>q[0]</code> and <code>q[1]</code>) so that it can control B and NOT A, and also a third qubit as an output. But here we have <code>q[0]</code> as an input and <code>q[1]</code> as an output apparently. Can anybody help me please to understand the logic?</p>
",<quantum-gate><programming>,11/19/2020 0:41,14717.0,14717.0,"<p>When you apply the CNOT gate on the state <span class=""math-container"">$|00\rangle$</span> what you will get out is the state <span class=""math-container"">$|00\rangle$</span>, as the CNOT gate logically do the following:</p>
<p><span class=""math-container"">$CNOT|00\rangle = |00\rangle, \ \ \ CNOT|01\rangle = |01\rangle, \ \ \  CNOT|10\rangle = |11\rangle, \ \ \ CNOT|11\rangle = |10\rangle$</span></p>
<p>where <span class=""math-container"">$\bigg\{|0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix} , |1\rangle\ = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \bigg\}$</span> represents the computational basis. Here we are taking the first qubit as the controlled qubit, and the second qubit as the target qubit. That is, if the first (Controlled) qubit is in the state <span class=""math-container"">$|1\rangle$</span> then you apply the <span class=""math-container"">$X$</span> (NOT) gate to the second (Target)  qubit, otherwise you do nothing.  Thus, in this setting the CNOT gate has matrix representation (in the computational basis) as:</p>
<p><span class=""math-container"">\begin{equation}\label{CNOT matrix}
     CNOT = \begin{pmatrix} 
    1 &amp; 0 &amp; 0 &amp; 0\\  
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    \end{pmatrix}
\end{equation}</span></p>
<p>so that is what you implement when you run the circuit:</p>
<p><a href=""https://i.stack.imgur.com/CWF4E.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/CWF4E.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
qreg_q = QuantumRegister(2, 'q')
creg_c = ClassicalRegister(2, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)
circuit.cx(qreg_q[0], qreg_q[1])
circuit.draw( 'mpl',style={'name': 'bw'}, plot_barriers= False, scale = 1)
</code></pre>
<p>as always, all state in quantum computer starts at the state <span class=""math-container"">$|00\cdots 0\rangle$</span>. Hence, this means that for our  circuit above <span class=""math-container"">$q_0 = |0\rangle$</span> and <span class=""math-container"">$q_1 = |0\rangle$</span>, so the starting state is <span class=""math-container"">$|00\rangle = |0\rangle \otimes |0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \otimes \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 1 \\ 0 \\0 \\0 \end{pmatrix} $</span>. Notice that</p>
<p><span class=""math-container"">$$ CNOT|00\rangle = \begin{pmatrix} 
    1 &amp; 0 &amp; 0 &amp; 0\\  
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\0 \\0 \end{pmatrix} = \begin{pmatrix} 1 \\ 0 \\0 \\0 \end{pmatrix} = |00\rangle $$</span></p>
<p>The input is the state of <span class=""math-container"">$|00\rangle$</span> and the output is also <span class=""math-container"">$|00\rangle$</span>.</p>
<p>Note that: <code>circuit.cx(qreg_q[0], qreg_q[1])</code> indicates that the controlled qubit is in the quantum register <code>qreg_q[0]</code> and it will act on the target qubit which is in the quantum register <code>qreg_q[1]</code>. And this can be changed. That is, you can make the qubit in the quantum register <code>qreg_q[1]</code> as your controlled qubit and the qubit in the quantum register <code>qreg_q[0]</code> as your target qubit by simply switch the 5th line of the code to: <code>circuit.cx(qreg_q[1], qreg_q[0])</code>.  The circuit will look like:</p>
<p><a href=""https://i.stack.imgur.com/XUjJb.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/XUjJb.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>If you instead input a different state, says <span class=""math-container"">$|10\rangle$</span> then the result would be different, it would be <span class=""math-container"">$|11\rangle$</span> in this case. That is, if you execute the circuit:</p>
<p><a href=""https://i.stack.imgur.com/3UnjC.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3UnjC.png"" alt=""enter image description here"" /></a></p>
<p>Note that the <span class=""math-container"">$X$</span> gate here is to put the qubit <span class=""math-container"">$q_0$</span> from the state <span class=""math-container"">$|0\rangle$</span> to <span class=""math-container"">$|1\rangle$</span>. That is, we are making the input state <span class=""math-container"">$|10\rangle$</span>. The output state now would be <span class=""math-container"">$|11\rangle$</span> as the controlled qubit is now in the state <span class=""math-container"">$|1\rangle$</span> so it will act on the target qubit by applying the <span class=""math-container"">$X$</span> (NOT) gate. If you run this on the simulator, you will see something like:</p>
<p><a href=""https://i.stack.imgur.com/j3U6z.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/j3U6z.png"" alt=""enter image description here"" /></a></p>
<p>Here is the code to generate the following circuit and plot in Qiskit:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, BasicAer, execute
from qiskit.visualization import plot_histogram
%matplotlib inline
qreg_q = QuantumRegister(2, 'q')
creg_c = ClassicalRegister(2, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)
circuit.x(qreg_q[0])
circuit.cx(qreg_q[0], qreg_q[1])
circuit.measure(qreg_q[0], creg_c[0])
circuit.measure(qreg_q[1], creg_c[1])
circuit.draw( 'mpl',style={'name': 'bw'}, plot_barriers= False, scale = 1)
backend = BasicAer.get_backend('statevector_simulator')
job = execute(circuit, backend, shots = 1)
plot_histogram(job.result().get_counts(), color='black', title=&quot;Result&quot;)
</code></pre>
<p>And you can work this out explicitly in matrix algebra as well:</p>
<p><span class=""math-container"">$$ CNOT|10\rangle = \begin{pmatrix} 
    1 &amp; 0 &amp; 0 &amp; 0\\  
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    \end{pmatrix} \begin{pmatrix} 0 \\ 0 \\1 \\0 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\0 \\1 \end{pmatrix} = |11\rangle $$</span></p>
",11/19/2020 1:26,Conceptual,"This question falls under the conceptual category as it seeks an explanation and clarification regarding the logic behind the control-X (CX) gate in quantum circuits, particularly with respect to the placement of qubits as inputs and outputs in the code snippet provided.",Conceptual,,,,Conceptual,
14718.0,How do I check what is wrong in my full-adder code?,"<p>I am trying to solve the first question on the qiskit test which is writing a code for a full adder.</p>
<p>So based on my research if I have <span class=""math-container"">$A$</span> <code>q[0]</code>, <span class=""math-container"">$B$</span> <code>q[1]</code> and <span class=""math-container"">$C$</span> in <code>q[2]</code> as input and <code>Sum</code> and <code>Cout</code> as output, I should be able to produce the correct outputs by the following gates:</p>
<pre><code>q[0] XOR1 q[1] ---&gt; q[4]

q[0] AND1 q[1] ---&gt; q[3]

q[2] XOR2 q[4] ---&gt; q[5] (SUM)

q[2] AND2 q[4] ---&gt; q[6]

q[3] OR q[6] ---&gt; q[7] (COUT)

</code></pre>
<p>Writing the following program I get that my answer is producing wrong results :</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit import IBMQ, Aer, execute

##### build your quantum circuit here

#Define registers and a quantum circuit
q = QuantumRegister(8) 
c = ClassicalRegister(2)
qc = QuantumCircuit(q,c)

# Preparing inputs
qc.x(q[0])  # Comment this line to make Qbit0 = |0&gt;
qc.x(q[1])  # Comment this line to make Qbit1 = |0&gt;
qc.x(q[2])  # Comment this line to make Qbit2 = |0&gt; ( carry-in bit )
qc.barrier()

# AND gate1 implementation
qc.ccx(q[0],q[1],q[3])
qc.barrier()

# XOR gate1 implementation
qc.cx(q[0],q[4])
qc.cx(q[1],q[4])
qc.barrier()

# XOR gate2 implementation
qc.cx(q[2],q[5])
qc.cx(q[4],q[5])
qc.barrier()

# AND gate2 implementation
qc.ccx(q[2],q[4],q[6])
qc.barrier()

#OR gate implementation
qc.cx(q[3],q[7])
qc.cx(q[6],q[7])
qc.ccx(q[3],q[6],q[7])
qc.barrier()

# Measuring and put result to classical bit
# ( sum )
qc.measure(q[5],c[0])
# ( carry-out )
qc.measure(q[7],c[1])

# execute the circuit by qasm_simulator
backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend, shots=1000)
result = job.result()
count = result.get_counts()
print(count)
qc.draw(output='mpl')
</code></pre>
<p>Grading tells me that my results are not matching, but I cannot figure out what is wrong with my code.
Thank you so much for help.</p>
",<quantum-gate><programming><circuit-construction>,11/19/2020 7:20,14722.0,14722.0,"<p>If I am correct, I suppose you are talking about the Qiskit Challenge 2020. A possible reason why your circuit is being graded wrong is because the question asks you to construct the circuit for full adder and give it the input <span class=""math-container"">$A=1$</span>, <span class=""math-container"">$B=0$</span> and <span class=""math-container"">$X=1$</span>. However, I think as per your code, you are preparing the qubits to be <span class=""math-container"">$|ABX\rangle = |111\rangle$</span> instead of <span class=""math-container"">$|101\rangle$</span>. Baring that, your circuit works perfectly fine from what I could analyze.</p>
",11/19/2020 9:28,Errors,"The user is facing an issue where the results from their quantum circuit for a full adder are not matching the expected results, indicating a problem with their code. They are seeking help to identify and fix the issue, making it fall under the ""Errors"" category.",Errors,,,,Errors,
14719.0,Import Qiskit fails,"<p>I have successfully installed the Qiskit in Anaconda by using <code>pip install qiskit</code>.</p>
<p>But I can't import Qiskit and get the following error.</p>
<pre><code>    ---------------------------------------------------------------------------
OSError                                   Traceback (most recent call last)
&lt;ipython-input-5-578b7f7e9727&gt; in &lt;module&gt;
----&gt; 1 import qiskit

~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\__init__.py in &lt;module&gt;
     29 
     30 # The main qiskit operators
---&gt; 31 from qiskit.circuit import ClassicalRegister
     32 from qiskit.circuit import QuantumRegister
     33 from qiskit.circuit import AncillaRegister

~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\__init__.py in &lt;module&gt;
    212    random.random_circuit
    213 &quot;&quot;&quot;
--&gt; 214 from .quantumcircuit import QuantumCircuit
    215 from .classicalregister import ClassicalRegister, Clbit
    216 from .quantumregister import QuantumRegister, Qubit, AncillaRegister, AncillaQubit

~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\quantumcircuit.py in &lt;module&gt;
     23 from collections import OrderedDict, defaultdict
     24 from typing import Union
---&gt; 25 import numpy as np
     26 from qiskit.exceptions import QiskitError
     27 from qiskit.util import is_main_process

~\AppData\Roaming\Python\Python38\site-packages\numpy\__init__.py in &lt;module&gt;
    138 
    139     # Allow distributors to run custom init code
--&gt; 140     from . import _distributor_init
    141 
    142     from . import core

~\AppData\Roaming\Python\Python38\site-packages\numpy\_distributor_init.py in &lt;module&gt;
     24                 # NOTE: would it change behavior to load ALL
     25                 # DLLs at this path vs. the name restriction?
---&gt; 26                 WinDLL(os.path.abspath(filename))
     27                 DLL_filenames.append(filename)
     28     if len(DLL_filenames) &gt; 1:

~\anaconda3\envs\quantum_computing\lib\ctypes\__init__.py in __init__(self, name, mode, handle, use_errno, use_last_error, winmode)
    379 
    380         if handle is None:
--&gt; 381             self._handle = _dlopen(self._name, mode)
    382         else:
    383             self._handle = handle

OSError: [WinError 193] %1 is not a valid Win32 application
</code></pre>
<p>So what should I do to solve this problem?</p>
",<qiskit><programming>,11/19/2020 8:37,14760.0,14760.0,"<p>Reinstalling numpy didn't work for me.</p>
<p>I delete the <code>C:\Users\USERNAME\AppData\Roaming\Python\Python38\*</code> folder because that was left behind by a previous Python which I had uninstalled.</p>
<p>And this work for me.</p>
<p>Thanks to everyone who all answered my questions and I appreciate it.</p>
",11/21/2020 10:13,Errors," The user is encountering an error when trying to import Qiskit in their Anaconda environment, and they are seeking a solution to this issue. This falls under the ""Errors"" category as it involves resolving a problem or error in the Qiskit installation.",Errors,,,,Errors,
14745.0,Measurement of 1 qubit in a two qubit system,"<p><a href=""https://i.stack.imgur.com/9vzeq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9vzeq.png"" alt=""enter image description here"" /></a></p>
<p>I created two qubits in IBM quantum experience and measured the second qubit without applying any gate.
The result I got had a computational basis of 00 and 10. How does the measurement of the second qubit change the basis to 00 and 10? I have just started to learn quantum computing, so the question may sound silly.</p>
",<programming><quantum-state><ibm-q-experience>,11/20/2020 16:13,14747.0,14747.0,"<p>If you had run this on the <code>statevector_simulator</code> then you will only see <span class=""math-container"">$|00\rangle$</span>. However, due to hardware noise, which in this case coming out from the measurement error, you will have some <span class=""math-container"">$|1\rangle$</span> in your measurement on <span class=""math-container"">$q_1$</span>. Depends on the hardware noise level, you might see 'more' or 'less' of <span class=""math-container"">$|1\rangle$</span> appearing in your result. If you want to improve your output probabilities result, just add more shots.</p>
<p><strong>Update:</strong> Why would we would we only see the state <span class=""math-container"">$|00\rangle$</span> in the ideal world, like if we have used the <code>statevector_simulator</code> instead of the hardware?</p>
<p>The reason is because the starting/initial state on a quantum computer always start in the state <span class=""math-container"">$|000\cdots 0\rangle$</span>.  That is, every qubit initialize with <span class=""math-container"">$|0\rangle$</span>. And this state can be prepared with very high fidelity. In your case, you have two qubit, so your system is initialize at the state <span class=""math-container"">$|00\rangle$</span>. That is <span class=""math-container"">$|q_0\rangle = |0\rangle$</span> and <span class=""math-container"">$|q_1 \rangle = |0 \rangle$</span>. So now without doing any operation on this qubit, you ask the quantum computer, what state is the second qubit, <span class=""math-container"">$q_1$</span> in? The answer should be  <span class=""math-container"">$|0\rangle$</span> if you have a measurement process with no noise! Because the state the qubit <span class=""math-container"">$q_1$</span>, <span class=""math-container"">$|q_1\rangle = |0\rangle$</span>. There is no other answer it can give you. However, if there is noise presence, it might change this answer from a <span class=""math-container"">$|0\rangle$</span> to a <span class=""math-container"">$|1\rangle$</span> every so often, depending on the noise level of course. Say you ask 100 times, 95 of the time you will get the correct answer of <span class=""math-container"">$|0\rangle$</span> and 5 time it will return a <span class=""math-container"">$|1\rangle$</span> due to error. Think of this as like when you are driving in car through a scenic mountain area, then your friend call and ask if you want to come over to hangout. Because of where you are, the signal is not very clear, so eventhough you say &quot;YUP&quot;, he/she might hear as a &quot;NOPE&quot; instead.... so if you have say&quot;YUP&quot;, &quot;YUP&quot;,.... &quot;YUP&quot; 100 times, he/she might pick up a &quot;NOPE&quot; 5 time out of the 100 time. This is what you see in your histogram plot... sometime the measurement process pick-up a <span class=""math-container"">$|1\rangle$</span> because of the noise in the measurement process as your friend has picked up a &quot;NOPE&quot; from bad signal.</p>
<p>Note that this should not be confusing with the state <span class=""math-container"">$|q_1 \rangle = \dfrac{|0\rangle + |1 \rangle}{\sqrt{2}}$</span>... In this case, when you ask the quantum computer, &quot;Hey QC, what state is <span class=""math-container"">$|q_1\rangle$</span> in? It will return you with a <span class=""math-container"">$|0\rangle$</span> or a <span class=""math-container"">$|1\rangle$</span> with <span class=""math-container"">$1/2$</span> probability. This is <strong>not</strong> because of the noise in your system. If you run this experiment <span class=""math-container"">$100,000$</span> time, you might get <span class=""math-container"">$49820$</span> time it will returns a <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$50,180$</span> time it will returns a <span class=""math-container"">$|1\rangle$</span>. This is because your state <span class=""math-container"">$|q_1\rangle$</span> is in superposition of both <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span>, so when making a measurement, it will collapse onto either one of these state. And in this case, where <span class=""math-container"">$|q_1 \rangle = \dfrac{|0\rangle + |1 \rangle}{\sqrt{2}}$</span>, the probability of collapsing onto the state <span class=""math-container"">$|0\rangle$</span> is 50% probability and the state <span class=""math-container"">$|1\rangle$</span> is also 50%. This is similar to <strong>tossing a coin</strong> if you think about it...</p>
",11/20/2020 16:19,Conceptual,"The user is asking about the underlying concepts of quantum computing, specifically about the change in computational basis after measuring a qubit. This falls under the Conceptual category as it pertains to understanding the principles and ideas behind quantum programming", Conceptual,,,,Conceptual,
14785.0,How to apply a operator to qubit system on the basis of current state of system?,"<p>Suppose I have three different operators <span class=""math-container"">$U_1, U_2,U_3$</span>. Now, these three operators will be applied if my current state of the system is <span class=""math-container"">$|\psi_0\rangle,|\psi_1\rangle $</span> and <span class=""math-container"">$|\psi_2\rangle$</span> respectively.</p>
<p>Now suppose I started with some initial state <span class=""math-container"">$|\psi_{initial}\rangle$</span> and after applying two unitary operations it will be converted to one of the states above and on the basis of that the respective unitary operator needs to applied.</p>
<p>I know we can't measure the state as it will collapse the system. So, what method can be applied here?</p>
",<quantum-gate><programming><quantum-state><unitarity>,11/22/2020 16:06,15080.0,15080.0,"<p>I assume that you have a qubit register <span class=""math-container"">$q$</span> and given that the state of <span class=""math-container"">$q$</span> is <span class=""math-container"">$|\psi_i\rangle$</span> you want to apply <span class=""math-container"">$U_i$</span> to <span class=""math-container"">$q$</span> for <span class=""math-container"">$i=0,1,2$</span>. If this is what you wish to do, then unfortunately if the states <span class=""math-container"">$|\psi_i\rangle$</span>'s are not orthogonal to each other, then this kind of operations are not possible in a quantum setting in for any general <span class=""math-container"">$U_i$</span>'s. This is not possible because such an operator is not unitary. For instance take the simple case of <span class=""math-container"">$q$</span> being in either the state <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|+\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}$</span> and I wish to apply <span class=""math-container"">$I$</span> on <span class=""math-container"">$q$</span> if it is in the state <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$H$</span> gate on <span class=""math-container"">$q$</span> if the state of <span class=""math-container"">$q$</span> is <span class=""math-container"">$|+\rangle$</span>. This mathematically would mean that I need an operator <span class=""math-container"">$U$</span> that works as follows: <span class=""math-container"">$$U|0\rangle=|0\rangle \text{ and } U|+\rangle = \frac{1}{\sqrt{2}}(U|0\rangle + U|1\rangle) =|0\rangle.$$</span> It is quite obvious that <span class=""math-container"">$U$</span> is not reversible and hence is not a unitary. So such a quantum operation does not exist.</p>
<p>However, if the states <span class=""math-container"">$|\psi_i\rangle$</span>'s are orthogonal to each other and the state in <span class=""math-container"">$q$</span> is one of these states and is not any superposition of these states, then certainly you can measure and then conditioned on the measured result you can apply the <span class=""math-container"">$U_i$</span> of your choice.</p>
",12/10/2020 09:26,Theoretical,"The user is asking about a theoretical concept in quantum computing, specifically about applying operators based on the current state of the system. This falls under the Theoretical category as it involves understanding and explaining theoretical concepts and principles in quantum computing.",Theoretical,,,,Theoretical,
14820.0,Cirq.simulate expectation value of a Hamiltonian,"<p>I want to simulate the final state of an ansatz in cirq using simulate.
Now I want to calculate the expectation value of a Hamiltonian.</p>
<p>How do I do this? I can only find simulator.run examples in cirq. But I want to access the wavefunction and therefore would need simulator.simulate.</p>
<p>Is there a function in cirq I can use or how could I do this?</p>
",<programming><hamiltonian-simulation><cirq>,11/24/2020 22:40,14823.0,14823.0,"<p>You can get the wavefunction from <code>cirq.final_state_vector(circuit)</code>. Then you can define your observable as an instance of <code>cirq.PauliSum</code>, on which you will be able to use the <code>expectation_from_state_vector()</code> method to get the expectation value.</p>
",11/25/2020 0:32,API Usage," The user is inquiring about the correct way to use Cirq's simulator to access the wavefunction and calculate the expectation value of a Hamiltonian, which falls under the category of API Usage as it pertains to utilizing Cirq's functionality correctly.", API Usage,,,,API Usage,
14835.0,How do quantum computers implement a random unitary gate?,"<p>If I <code>from qiskit.quantum_info import random_unitary</code> and then <code>random_unitary(2**number_of_qubits)</code> What returns is a unitary matrix with dimension <span class=""math-container"">$(2^{number\_of\_qubits},2^{number\_of\_qubits})$</span>, and if I stimulating the unitary operation on a classical computer it is matrix computation.</p>
<p>Here comes my question: what quantum computers do to implement this random unitary?</p>
<p>From the universality of quantum gate set, we know that an arbitrary single-qubit operation can be decomposed into the set of <span class=""math-container"">$\{H, S, T\}$</span> or <span class=""math-container"">$\hat U=\hat\Phi(\delta)\hat R_z(\alpha)\hat R_y(\theta)\hat R_z(\beta)$</span> where <span class=""math-container"">$\hat \Phi(\delta)=\begin{pmatrix}e^{i\delta}&amp;0\\0&amp;e^{i\delta}\end{pmatrix}$</span>, <span class=""math-container"">$\hat R_z(\alpha)=\begin{pmatrix}e^{i\alpha/2}&amp;0\\0&amp;e^{-i\alpha/2}\end{pmatrix}$</span> and <span class=""math-container"">$\hat R_y(\theta)=\begin{pmatrix}cos\frac{\theta}{2}&amp;sin\frac{\theta}{2}\\-sin\frac{\theta}{2}&amp;cos\frac{\theta}{2}\end{pmatrix}$</span>.</p>
<p>But when considering <strong>physical realizations</strong>, we need to consider the problem of finite precision and so on. Then, which method will the quantum computers adopt? And more generally, what if we introduce <code>CNOT</code> here to form the universal quantum gate set for an arbitrary number of qubits?</p>
<p>Even a great reference paper or detailed qiskit documentation can be helpful (in fact to make my work rigorous this is essential). I appreciate you in advance.</p>
",<quantum-gate><programming><physical-realization>,11/25/2020 14:17,14841.0,14841.0,"<p>In terms of decomposing an arbitrary unitary matrix on n-qubit system, this paper <a href=""https://arxiv.org/pdf/1501.06911.pdf"" rel=""nofollow noreferrer"">&quot;Quantum Circuits for Isometries&quot;</a> might be a helpful guide. As well as this paper: <a href=""https://arxiv.org/pdf/1904.01072.pdf"" rel=""nofollow noreferrer"">&quot;Introduction to UniversalQCompiler&quot;</a> which is implemented in the <a href=""https://www-users.york.ac.uk/%7Erc973/UniversalQCompiler.html"" rel=""nofollow noreferrer"">UniversalQCompiler package for Mathematica</a>.</p>
<p>And how to implement single qubit and CNOT gates on hardware, i guess a good place to look at is the <a href=""https://arxiv.org/pdf/2004.06755.pdf"" rel=""nofollow noreferrer"">Qiskit documentation on Openpulse</a>.</p>
",11/25/2020 20:08,Theoretical,"The question pertains to the theoretical aspects of quantum computing, specifically how quantum computers implement random unitary operations and the considerations related to finite precision and physical realizations. It also touches upon the universality of quantum gate sets, making it a theoretical inquir",Theoretical,,,,Theoretical,
14856.0,Creating a resource count unit test in Q#,"<p>I want to create a unit test in Q# that runs an operation and asserts that it used at most 10 Toffoli operations. How do I do this?</p>
<p>For example, what changes do I have to make to the code below?</p>
<pre><code>namespace Tests {
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Intrinsic;

    operation op() : Unit {
        using (qs = Qubit[3]) {
            for (k in 0..10) {
                CCNOT(qs[0], qs[1], qs[2]);
            }
        }
    }

    @Test(&quot;ResourcesEstimator&quot;)
    operation test_op_toffoli_count_at_most_10() : Unit {
        ...?
        op();
        ...?
        if (tof_count &gt; 10) {
            fail &quot;Too many Toffolis&quot;;
        }
    }
}
<span class=""math-container"">```</span>
</code></pre>
",<programming><q#>,11/27/2020 0:08,14872.0,14872.0,"<p>There are multiple ways to do this, depending on what exactly you want to check.</p>
<ol>
<li>Using AllowAtMostNCallsCA library operation.</li>
</ol>
<p>The easiest way (with the code short enough to be included) is applicable if you know that you only use CCNOT gates when you want a Toffoli gate, and you never use Controlled X gates. In this case you can <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.diagnostics.allowatmostncallsca"" rel=""nofollow noreferrer"">AllowAtMostNCallsCA</a> operation that enforces exactly that:</p>
<pre><code>namespace Tests {
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Intrinsic;

    operation op() : Unit {
        using (qs = Qubit[3]) {
            for (k in 0..10) {
                CCNOT(qs[0], qs[1], qs[2]);
            }
        }
    }

    @Test(&quot;ResourcesEstimator&quot;)
    operation test_op_toffoli_count_at_most_10() : Unit {
        within {
            AllowAtMostNCallsCA(10, CCNOT, &quot;Too many Toffolis&quot;);
        } apply {
            op();
        }
    }
}
</code></pre>
<p>This test will fail right away, and that's how you can notice that the loop actually uses 11 CCNOTs. However, if you replace the CCNOTs in the loop body with <code>Controlled X([qs[0], qs[1]], qs[2]);</code> (which is exactly the same gate), the test will happily pass irrespective of how many times you use the gate.</p>
<ol start=""2"">
<li>Using resource estimator.</li>
</ol>
<p>You can write a test (it will have to be in a different language, though) that will invoke ResourcesEstimator, run an operation using it, extract the statistics and analyze them. I don't have a ready example on hand; the closest thing is <a href=""https://docs.microsoft.com/en-us/quantum/user-guide/machines/resources-estimator#programmatically-retrieving-the-estimated-data"" rel=""nofollow noreferrer"">this documentation</a>. This approach has the advantage of matching the resource estimates done by ResourcesEstimator exactly, rather than tracking specific gates.</p>
<ol start=""3"">
<li>Using custom simulator.</li>
</ol>
<p>If you want to do some sophisticated checks, for example, count all gates that act on exactly 3 qubits and limit their number, you can write your own simulator that would extend the simulator you like by doing some extra counting whenever an operation is called. This simulator could expose access to those statistics to your Q# code, so you could write custom assertions using this data. I'm not including the full code here, since it's pretty lengthy (and you indicated that you don't want to use a second language); you can find a complete example <a href=""https://github.com/microsoft/QuantumKatas/blob/main/utilities/Common/CounterSimulator.cs"" rel=""nofollow noreferrer"">here</a> (some tasks in the Quantum Katas use tests like &quot;prohibit all multi-qubit operations except Measure&quot;, so this simulator comes handy).</p>
",11/27/2020 20:24,API Usage,The question is about how to use the Q# API to create a unit test that checks the Toffoli operation count in a quantum program. It specifically involves using the Q# test framework to achieve this.,API Usage,,,,API Usage,
14870.0,"IBMQ: ""Credentials are already in use""","<p>Executing the following:</p>
<pre><code>import numpy as np
from qiskit import IBMQ, QuantumCircuit, Aer, execute
from qiskit.quantum_info import Operator
from qiskit.providers.ibmq import least_busy
from qiskit.visualization import plot_histogram
from qiskit.tools.jupyter import *
provider = IBMQ.load_account() 
</code></pre>
<p>I get the following error which I do not know what to do about, does anybosy know what I can do?</p>
<pre><code>ibmqfactory.load_account:WARNING:2020-11-27 
13:08:45,170: Credentials are already in use. The 
existing account in the session will be replaced.
</code></pre>
",<programming><qiskit><ibm-q-experience>,11/27/2020 19:15,14871.0,14871.0,"<p>This is <strong>NOT</strong> an error.</p>
<p>It just means that you have loaded your account previously, maybe from the previous run. It will just replace your previous credential... and shouldn't cause any issue.</p>
",11/27/2020 19:25,Errors,"The question is about resolving a warning message related to IBM Quantum Experience (IBMQ) account credentials, which falls under the ""Errors"" category as it involves addressing an issue or error message in quantum computing setup.",Errors,,,,Errors,
14874.0,Why do I get the error name operator is not defined?,"<p>I checked this code multiple times, I am trying to reproduce the same code using Grover's algorithm from qiskit summerschool:</p>
<pre><code> import numpy as np
 from qiskit import IBMQ, QuantumCircuit, Aer, execute
 from qiskit.quantum_info import Operator
 from qiskit.providers.ibmq import least_busy
 from qiskit.visualization import plot_histogram
 from qiskit.tools.jupyter import *
 provider = IBMQ.load_account()

def phase_oracle(n, indices_to_mark, name='Oracle'):
qc = QuantumCircuit(n, name=name)
oracle_matrix = np.identity(2**n)
for index_to_mark in indices_to_mark:
    oracle_matrix[index_to_mark, index_to_mark]= -1
qc.unitary(operator(oracle_matrix), range(n))
return qc

def diffuser(n):
qc=QuantumCircuit(n,name='Diff - &quot;V&quot;')
qc.h(range(n))
qc.append(phase_oracle(n,[0]),range(n))
qc.h(range(n))
return qc

def Grover(n, marked):
qc=QuantumCircuit(n,n)
r = int(np.round(np.pi/
(4*np.arcsin(np.sqrt(len(marked)/2**n)))-1/2))
print(f'{n} qubits, basis state {marked} marked, {r} 
rounds')
qc.h(range(n))
for _ in range(r):
    qc.append(phase_oracle(n,marked),range(n))
    qc.append(diffuser(n),range(n))
qc.measure(range(n),range(n))
return qc

n = 5
x = np.random.randint(2**n)
marked = [x]
qc = Grover(n, marked)

qc.draw()
</code></pre>
<p>I get the name operator error which I cannot figure out the reason:</p>
<pre><code> NameError                                 Traceback 
(most recent call last)
 &lt;ipython-input-22-96635782dc30&gt; in &lt;module&gt;
  2 x = np.random.randint(2**n)
  3 marked = [x]
  ----&gt; 4 qc = Grover(n, marked)
  5 
  6 qc.draw()

 &lt;ipython-input-20-f14e47e0af5d&gt; in Grover(n, marked)
 20     qc.h(range(n))
 21     for _ in range(r):
  ---&gt; 22         
 qc.append(phase_oracle(n,marked),range(n))
 23         qc.append(diffuser(n),range(n))
 24     qc.measure(range(n),range(n))

  &lt;ipython-input-20-f14e47e0af5d&gt; in phase_oracle(n, 
  indices_to_mark, name)
  4     for index_to_mark in indices_to_mark:
  5         oracle_matrix[index_to_mark, 
  index_to_mark]= -1
   ----&gt; 6     qc.unitary(operator(oracle_matrix), 
   range(n))
  7     return qc
  8 
</code></pre>
<p>NameError: name 'operator' is not defined. Can anybody help me woth this?</p>
",<programming>,11/27/2020 22:54,14877.0,14877.0,"<p>That is because on <code>line 14</code> of your program, you wrote:</p>
<p><code>qc.unitary(operator(oracle_matrix), range(n))</code></p>
<p>when it should be:</p>
<p><code> qc.unitary(Operator(oracle_matrix), range(n))</code></p>
<p>You should have capitalized the <code>O</code> in operator.  Changing that, I get the following output when executed your code:</p>
<pre><code>5 qubits, basis state [15] marked, 4 rounds
     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
q_0: â¤ H ââ¤0        ââ¤0            ââ¤0        ââ¤0            ââ¤0        âÂ»
     âââââ¤â         ââ             ââ         ââ             ââ         âÂ»
q_1: â¤ H ââ¤1        ââ¤1            ââ¤1        ââ¤1            ââ¤1        âÂ»
     âââââ¤â         ââ             ââ         ââ             ââ         âÂ»
q_2: â¤ H ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle âÂ»
     âââââ¤â         ââ             ââ         ââ             ââ         âÂ»
q_3: â¤ H ââ¤3        ââ¤3            ââ¤3        ââ¤3            ââ¤3        âÂ»
     âââââ¤â         ââ             ââ         ââ             ââ         âÂ»
q_4: â¤ H ââ¤4        ââ¤4            ââ¤4        ââ¤4            ââ¤4        âÂ»
     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
c: 5/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
                                                                         Â»
Â«     ââââââââââââââââââââââââââââââââââââââââââââ            
Â«q_0: â¤0            ââ¤0        ââ¤0            ââ¤Mâââââââââââââ
Â«     â             ââ         ââ             âââ¥ââââ         
Â«q_1: â¤1            ââ¤1        ââ¤1            âââ«ââ¤Mââââââââââ
Â«     â             ââ         ââ             â â ââ¥ââââ      
Â«q_2: â¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; âââ«âââ«ââ¤Mâââââââ
Â«     â             ââ         ââ             â â  â ââ¥ââââ   
Â«q_3: â¤3            ââ¤3        ââ¤3            âââ«âââ«âââ«ââ¤Mââââ
Â«     â             ââ         ââ             â â  â  â ââ¥ââââ
Â«q_4: â¤4            ââ¤4        ââ¤4            âââ«âââ«âââ«âââ«ââ¤Mâ
Â«     âââââââââââââââââââââââââââââââââââââââââ â  â  â  â ââ¥â
Â«c: 5/âââââââââââââââââââââââââââââââââââââââââââ©âââ©âââ©âââ©âââ©â
Â«                                               0  1  2  3  4 
</code></pre>
",11/28/2020 1:18,Errors," The question is about resolving a NameError in the provided code, specifically the name 'operator' is not defined, which falls under the ""Errors"" category as it involves addressing an issue or error message in quantum computing code.",Errors,,,,Errors,
14887.0,Does 1 qubit correspond to 2 bits?,"<p>In a lot of presentation I always see people say that <span class=""math-container"">$n$</span> qbit are approximately <span class=""math-container"">$2^n$</span> classical bit.
Those talks where oriented for a broad audience, so they left out a lot of things.
Deep down I felt that this couldn't be possible, but I didn't know anythings about qc so maybe this was the problem.</p>
<p>Now I've started learning qc (as a computer engineer) and I'm studying the concept of super dense coding, that it the base of the association <span class=""math-container"">$n$</span> qbit equal <span class=""math-container"">$2^n$</span> classical bits.(If it's not this let me know)</p>
<p>I've understood what the topic is about, but I still think that the association <span class=""math-container"">$n$</span> qbit equal <span class=""math-container"">$2^n$</span> classical bits is <strong>wrong</strong> or at least misleading.</p>
<p>Sending 2 bit to Bob, will require Alice to have 1 qbit and 1 entangled qbit where the other part of the eqbit is owned by Bob.
Just by reading this is clear that <strong>2 bit actually correspond to 1 qbit + 1eqbit</strong>, but reading online one common approach to say that 1qbit=2bit is by introducing a third part that is responsible to send and eqbit to Alice and Bob.
Isn't this a flawed way to think? When someone say <span class=""math-container"">$n$</span> qbit equal <span class=""math-container"">$2^n$</span> bit, they are implicitly stating that there is a way to encode the information of <span class=""math-container"">$2^n$</span> bits in <span class=""math-container"">$n$</span> qbit, but if you actually study the theory is not like this.</p>
<p>Also saying that <strong>1qbit +1eqbit =2 bit</strong>, is not too much different than saying <strong>1qbit+1qbit=2qbit=2bit</strong>, because at the end of the day 1eqbit is just a qbit in a particular state. I know that differentiating between them is important since they are two different things, but physically we can see them as two object (two photons for example) that are in a different position, still they 'occupy the space of two object'.
I also know that approximating 1 eqbit  with 1 qbit is a strong affirmation, but stating that 1qbit = 2bit is stronger imo.</p>
<p><strong>Is my way of thinking flawed? Why and where?</strong></p>
<p>Also there is another thing that I couldn't understand on my own.
In the textbook that I'm using (Quantum Computation and Quantum Information) one thing that they say is:</p>
<blockquote>
<p>Suppose Alice and Bob initially share a pair of qubits in the entangled
state..</p>
</blockquote>
<p>Since the sharing of the eqbit and the sending of the qbit seems to happen in two different temporal window, they are able to store qbit?
In essence I don't understand the temporal window of the algorithm. I understand how it works, but not when. <strong>Can you clarify this?</strong></p>
<p>Note that this second question is related to the first, because I kind of understand the point of super dense coding, if you can send qbit at two different time and exploit quantum mechanics to send less qbit when needed, but if everything happen at the same time (the sending of the eqbit and the sending of the qbit) then I don't know the point of super dense coding.</p>
",<classical-computing><superdense-coding>,11/28/2020 15:48,14896.0,14896.0,"<p>Lets start with notion that <span class=""math-container"">$n$</span> qubits are equivalent to <span class=""math-container"">$2^n$</span> classical bits. This is wrong. However, it is true that to describe a quantum state composed of <span class=""math-container"">$n$</span> qubits we need <span class=""math-container"">$2^n$</span> complex numbers since <span class=""math-container"">$n$</span> qubits state is superposition containing all combination of <span class=""math-container"">$n$</span> classical qubits (<span class=""math-container"">$2^n$</span>). Writen by formula, <span class=""math-container"">$n$</span> qubits state is
<span class=""math-container"">$$
|q_0q_1...q_{n-1}\rangle = \sum_{i=0}^{2^n}a_{i}|i\rangle,
$$</span>
where <span class=""math-container"">$i$</span> represent basis states (e.g. <span class=""math-container"">$|0...00\rangle$</span>, <span class=""math-container"">$|0...01\rangle$</span>, <span class=""math-container"">$|0...10\rangle$</span>, <span class=""math-container"">$|0...11\rangle$</span> etc. until <span class=""math-container"">$|1...11\rangle$</span>) and <span class=""math-container"">$a_{i} \in \mathbb{C}$</span>.</p>
<p>Concerning information contained in qubits. Any qubit can be described as
<span class=""math-container"">$$
|q\rangle = \alpha|0\rangle + \beta|1\rangle,
$$</span>
where <span class=""math-container"">$\alpha, \beta \in \mathbb{C}$</span>. Since paraeters <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> are complex numbers, theoretically a qubit can contain infinite amount of information because you need infinite amout of bits to represent complex number exactly. This is of course impossible in reality since computers have finite memory. Moreover and what is the most important, when you measure a qubit, it collapeses to either 0 or 1. So, in the end you have either 0 or 1, i.e. one classical bit. Therefore, one qubit contains one bit of information.</p>
<p>Regarding superdense coding. It is often said that in superdense coding you send only one qubit but in the end you have two classical bits. It is true that you send only one qubit but to have superdense coding, you need to have two entangled qubits before. So, effectively two qubits are needed for transmiting two classical bits.</p>
",11/29/2020 8:00, Conceptual,"The question addresses fundamental conceptual aspects of quantum computing, including the relationship between qubits and classical bits, as well as the temporal aspects of quantum protocols like superdense coding. It seeks to clarify and discuss these concepts, making it fit for the ""Conceptual"" category.", Conceptual,,,, Conceptual,
14899.0,Can I teleport a string of 0s and 1s?,"<p>I have recently started with quantum computing and created a quantum teleportation circuit to transmit a qubit state from <code>q_0</code> to <code>q_2</code> using Qiskit.</p>
<p>I understand that I can transmit any state information from <code>q_0</code> to <code>q_2</code>. Is it then fair to expect that I can also transmit a morse code like string of 0s and 1s (say 1001)?
This is the circuit I built after watching/reading Qiskit tutorials.<a href=""https://i.stack.imgur.com/JLGGx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JLGGx.png"" alt=""enter image description here"" /></a></p>
",<qiskit><programming><circuit-construction><teleportation>,11/29/2020 14:33,14901.0,14901.0,"<p>As you noticed, the first thing you do is to put the <span class=""math-container"">$q_0$</span> to the state you want to teleport to <span class=""math-container"">$q_2$</span>. For instance, if you want to transport <span class=""math-container"">$|1\rangle$</span> to <span class=""math-container"">$q_2$</span> then you would first apply the <span class=""math-container"">$X$</span> gate to flip <span class=""math-container"">$q_0$</span> to the state <span class=""math-container"">$|1\rangle$</span>.</p>
<p><a href=""https://i.stack.imgur.com/njndB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/njndB.png"" alt=""enter image description here"" /></a></p>
<p>This is because the initial state of a quantum computer is usually starts in the state <span class=""math-container"">$|000\cdots0\rangle$</span>. Thus, if you want to teleport <span class=""math-container"">$1$</span> then apply <span class=""math-container"">$X$</span> gate to <span class=""math-container"">$q_0$</span> in the beginning, if you want to  teleport <span class=""math-container"">$0$</span> then do nothing.</p>
<hr />
<p>So  if you insist to design a program in Qiskit to generate a quantum circuit to teleport a morse code of some sort, you can do it as follow:</p>
<pre><code>%matplotlib inline
from qiskit import QuantumCircuit, execute, BasicAer, IBMQ
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

def teleported_circuit(code):
    qreg_q = QuantumRegister(3, 'q')
    creg_c = ClassicalRegister(1, 'c')
    circuit = QuantumCircuit(qreg_q, creg_c)
    if code == 1:
        circuit.x(qreg_q[0])
    circuit.barrier(range(3))
    circuit.h(qreg_q[1])
    circuit.cx(qreg_q[1], qreg_q[2])
    circuit.cx(qreg_q[0], qreg_q[1])
    circuit.h(qreg_q[0])
    circuit.barrier(range(3))
    circuit.cx(qreg_q[1], qreg_q[2])
    circuit.cz(qreg_q[0], qreg_q[2])
    circuit.measure(qreg_q[2], creg_c[0])
    backend = BasicAer.get_backend('statevector_simulator')
    job = execute(circuit, backend, shots = 1)
    return job.result().get_counts()

#### Example #### 
code_string = [1,0,0,1,1,1]
teleported_code = [ teleported_circuit(code_string[i]) for i in range(len(code_string)) ]
print('Here is your telported code:', teleported_code)
</code></pre>
<p>The output would be:</p>
<pre><code>Here is your telported code: [{'1': 1}, {'0': 1}, {'0': 1}, {'1': 1}, {'1': 1}, {'1': 1}]
</code></pre>
",11/29/2020 18:42,Conceptual,"The question pertains to the conceptual understanding of quantum teleportation and its limitations, specifically regarding whether it can be used to transmit a Morse code-like string of 0s and 1s. It involves a discussion about the capabilities and constraints of quantum teleportation, making it suitable for the ""Conceptual"" category.", Conceptual,,,,Conceptual,
14903.0,"Question about a circuit from ""Quantum Computing for Computer Scientists""","<p>I am trying to implement a basic quantum computing emulator. In the chapter on Grover's algorithm, we're shown the following circuit:</p>
<p><a href=""https://i.stack.imgur.com/CuN4s.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CuN4s.png"" alt=""enter image description here"" /></a></p>
<p>They demonstrate Grover's algorithm with a function <span class=""math-container"">$f$</span> that picks out <span class=""math-container"">$101$</span>, i.e. <span class=""math-container"">$f(101)=1$</span> and <span class=""math-container"">$0$</span> otherwise. They start with <span class=""math-container"">$\psi_{1}=[1, 0, 0, 0, 0, 0, 0, 0]^{T}$</span>. The Hadamard gate (specifically H tensored with itself <span class=""math-container"">$n$</span> times) gives <span class=""math-container"">$\psi_{2}=1/\sqrt8 [1, 1, 1, 1, 1, 1, 1, 1]^{T}$</span>. This is as far as I've come. They don't show explicitly how to get to <span class=""math-container"">$\psi_{3}$</span>, which should be <span class=""math-container"">$1/\sqrt8 [1, 1, 1, 1, 1, -1, 1, 1]^{T}$</span>. I am not sure how to interpret the circuit.</p>
<p>My best guess was to take the tensor product of <span class=""math-container"">$|0 \rangle=|000 \rangle$</span> and <span class=""math-container"">$|1 \rangle = [0, 1]^{T}$</span>, then apply <span class=""math-container"">$I_{2^{n}} \otimes H$</span>, then <span class=""math-container"">$U_{f}$</span>. However, I have two problems:</p>
<p>The book says that, at that stage in the calculation, <span class=""math-container"">$\psi_{3} = 1/\sqrt8 [1, 1, 1, 1, 1, -1, 1, 1]^{T}$</span>, which has length <span class=""math-container"">$8$</span>, instead of <span class=""math-container"">$16$</span>. I don't know how to &quot;extract&quot; the &quot;top&quot; qubits. Furthermore, my answer is <span class=""math-container"">$1/4[1, 1..., 1]^{T}$</span>, which doesn't suggest the correct answer (especially given the fact that every entry is <span class=""math-container"">$1/4$</span>).</p>
<p>Am I misinterpreting this circuit? What is the correct way to go from <span class=""math-container"">$\psi_{2}$</span> to <span class=""math-container"">$\psi_{3}$</span>, from a programmatic point of view?</p>
",<quantum-gate><programming><grovers-algorithm><quantum-circuit>,11/29/2020 21:38,14904.0,14904.0,"<p>Have you <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Amps3%22%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Amps3%22%5D%2C%5B%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C%22%E2%80%A2%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Amps3%22%5D%5D%2C%22init%22%3A%5B0%2C0%2C0%2C1%5D%7D"" rel=""nofollow noreferrer"">tried Quirk</a>? It can handle things like extracting the tensor factor of intermediate states for you, so you get a sense of what you should be getting as the answer.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Amps3%22%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Amps3%22%5D%2C%5B%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C%22%E2%80%A2%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Amps3%22%5D%5D%2C%22init%22%3A%5B0%2C0%2C0%2C1%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/13R3h.png"" alt=""grover circuit"" /></a></p>
<p>In general, the tensor factor may not exist because the extra qubit could be entangled with the part you're trying to extract. But if it's not entangled, which in this case it's not, then you just look at the subset of the state vector where the extra qubit is 0 and that's your answer (after normalizing) (or, if the part of the state vector where the extra qubit is 0 is all amplitudes zero, look at the subset where the extra qubit is 1).</p>
<p>To be more specific, what you do is group the state vector into parts keyed by the state of qubits you're not including. You then pick the part with the largest 2 norm as your reference part. This is the result you will return, normalized to have 2-norm of 1, if the state is not entangled. The state is not entangled if all the parts are parallel to each other. To verify lack of entanglement in a numerically stable way, you sum up the dot products of the reference part with all the parts (including itself). If the sum of dot products has a magnitude of 1, the state is not entangled. The sum's magnitude will get smaller as entanglement increases, though it won't necessarily get to zero.</p>
",11/30/2020 1:31, Conceptual,"The user is seeking a conceptual understanding of how to interpret and progress from a given quantum circuit, specifically in the context of Grover's algorithm. The question involves a discussion about the steps and operations involved in the circuit and does not involve actual programming but focuses on understanding the quantum computation process, making it suitable for the ""Conceptual"" category.", Conceptual,,,, Conceptual,
14919.0,IBMQ: Can I implement a quantum measurement in the middle of a quantum circuit?,"<p>I am executing a quantum circuit on an IBM quantum device. The circuit is simple:</p>
<p>A single qubit (start from <span class=""math-container"">$|0\rangle$</span>),</p>
<ol>
<li>Rx(<span class=""math-container"">$\pi/2$</span>)</li>
<li>Measure (in z)
3 .Rx(<span class=""math-container"">$-\pi/2$</span>)</li>
<li>Measure (in z)</li>
</ol>
<p>The final measurement probabilities should be
Prob:1/2, result:0; Prob:1/2, result:1.</p>
<p>But the simulation results are always Prob:1, result:0. It is as if the simulator is ignoring the first measurement. So my question is how to implement a quantum measurement in the middle of a quantum circuit on IBMQ?</p>
",<programming><ibm-q-experience>,12/01/2020 12:08,14922.0,14922.0,"<p>If you start with <span class=""math-container"">$|\psi\rangle$</span> in the state <span class=""math-container"">$|0\rangle$</span> and apply <span class=""math-container"">$Rx(\pi/2)$</span> gate to it, which is the following circuit,</p>
<p><a href=""https://i.stack.imgur.com/HwDgZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HwDgZ.png"" alt=""enter image description here"" /></a></p>
<p>Your qubit is now in the state <span class=""math-container"">$|\psi \rangle = \dfrac{|0\rangle - i|1\rangle}{\sqrt{2}}$</span>. If you are making a measurement at this step,</p>
<p><a href=""https://i.stack.imgur.com/mI0yg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mI0yg.png"" alt=""enter image description here"" /></a></p>
<p>then you qubit state <span class=""math-container"">$|\psi\rangle$</span> will collapsed onto one of the eigenstate <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span>. In this case, it will have <span class=""math-container"">$\dfrac{1}{2}$</span> probability of collapsing into either <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> since <span class=""math-container"">$\bigg| \dfrac{1}{\sqrt{2} } \bigg|^2 = \dfrac{1}{2} $</span> and <span class=""math-container"">$\bigg| \dfrac{-i}{\sqrt{2} } \bigg|^2 = \dfrac{1}{2} $</span>.</p>
<p>So after the measurement, you have two possible results:</p>
<ol>
<li><p><span class=""math-container"">$|\psi \rangle = |0\rangle$</span></p>
</li>
<li><p><span class=""math-container"">$|\psi \rangle = |1\rangle$</span></p>
</li>
</ol>
<p>In either case, if you are making another measurement here, then you will guarantee to collapsed into that particular state with <span class=""math-container"">$100\%$</span> probability. That is, if you your qubit collapsed to the state <span class=""math-container"">$|0\rangle$</span> after the first measurement, then the second measurement will reads out the state <span class=""math-container"">$|0\rangle$</span> with <span class=""math-container"">$100\%$</span> probability (assuming that there is no noise of course). And if you your qubit collapsed to the state <span class=""math-container"">$|1\rangle$</span> after the first measurement, then the second measurement will reads out the state <span class=""math-container"">$|1 \rangle$</span> with <span class=""math-container"">$100\%$</span> probability.</p>
<p>Now if you are running this experiments many times, then you will see that the probabilistic result on the first measurement will of course effect the readout of the second measurement. That is if you run the following circuit:</p>
<p><a href=""https://i.stack.imgur.com/jygWo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jygWo.png"" alt=""enter image description here"" /></a></p>
<p><span class=""math-container"">$10,000$</span> times then you expect <span class=""math-container"">$5000$</span> times it will be in the state <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$5000$</span> times is in the state <span class=""math-container"">$|1\rangle$</span>, if there is no noise... but because of noise we will deviate from these numbers a bit. We can test this with the <code>qasm_simulator</code> from Qiskit on the circuit above:</p>
<p><a href=""https://i.stack.imgur.com/XhXiK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XhXiK.png"" alt=""enter image description here"" /></a></p>
<p>Here is the code:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi
from qiskit import QuantumCircuit, BasicAer, execute
from qiskit.visualization import plot_histogram
%matplotlib inline

qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.rx(pi/2, qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])
circuit.measure(qreg_q[0], creg_c[0])

backend = BasicAer.get_backend('qasm_simulator')
job = execute(circuit, backend, shots = 10000)
print('Counts of experiment:', job.result().get_counts())
plot_histogram(job.result().get_counts(), color='black', title=&quot;Result&quot;)
</code></pre>
<hr />
<p>If you want to reset your qubit, that is you want to put it back to a particular state, then you can first use the <code>reset</code> function in Qiskit to first put the qubit to the state <span class=""math-container"">$|0\rangle$</span> then do some operation in follow to get the qubit to that particular state.</p>
<p>For instance, if you have some 1 qubit quantum circuit, and we want to reset it back to the state <span class=""math-container"">$|1\rangle$</span>, then we can do the following:</p>
<p><a href=""https://i.stack.imgur.com/dEySb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dEySb.png"" alt=""enter image description here"" /></a></p>
<p>The operation <code>reset</code> is indicated by the <span class=""math-container"">$|0\rangle$</span> symbol on the circuit. This put your qubit back to the state <span class=""math-container"">$|0\rangle$</span>. Then by applying the <span class=""math-container"">$X$</span> gate (denoted as <span class=""math-container"">$U_3(\pi, 0 , \pi)$</span> on the circuit) to it, you put your qubit back to the state <span class=""math-container"">$|1\rangle$</span>. So now, if you are making a measurement here, you will get a readout of the state <span class=""math-container"">$|1\rangle$</span> with <span class=""math-container"">$100 \%$</span> probability.</p>
<p>Here is the code to generate the circuit:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.rx(pi/2, qreg_q[0])
circuit.t(qreg_q[0])
circuit.s(qreg_q[0])
circuit.reset(qreg_q[0])
circuit.x(qreg_q[0])
circuit.decompose().draw( 'mpl',style={'name': 'bw'}, plot_barriers= False, initial_state = True, scale = 1)
</code></pre>
<hr />
<p><strong>Update after comment:</strong> To implement a <span class=""math-container"">$R_x(\pi/4)$</span> if the first measurement outcome is <span class=""math-container"">$|0\rangle$</span>, and a <span class=""math-container"">$R_x(\pi/8)$</span> if the first outcome is <span class=""math-container"">$|1\rangle$</span> we can use <code>c_if</code> operation. The circuit is the following:</p>
<p><a href=""https://i.stack.imgur.com/ud4yj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ud4yj.png"" alt=""enter image description here"" /></a></p>
<p>However, I don't think this is implementable on hardware yet. Below is the code:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi
from qiskit import QuantumCircuit, BasicAer, execute
from qiskit.visualization import plot_histogram
%matplotlib inline

qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.rx(pi/2, qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])
circuit.rx(pi/4, qreg_q[0]).c_if(creg_c, 0)
circuit.rx(pi/8, qreg_q[0]).c_if(creg_c, 1)
circuit.measure(qreg_q[0], creg_c[0])

backend = BasicAer.get_backend('qasm_simulator')
job = execute(circuit, backend, shots = 1)
print('Counts of experiment:', job.result().get_counts())
plot_histogram(job.result().get_counts(), color='black', title=&quot;Result&quot;)
</code></pre>
",12/01/2020 16:08,Tooling, The user is asking about how to implement a specific feature (quantum measurement in the middle of a quantum circuit) on a specific quantum computing platform (IBMQ). This falls under tool usage in quantum programming,Tooling,,,,Tooling,
14934.0,Using Qiskit VQE for solving an eigenvalue problem,"<p>I am a new user of Qiskit and I believe there is a simple answer to my question but I have had a very hard time finding a straightforward answer. I am trying to transform a given <span class=""math-container"">$3 \times 3$</span> (Hermitian) Hamiltonian matrix into a qubit operator and then use the built-in VQE solver for evaluating the minimum eigenvalue for said matrix.</p>
<p>I have been successful in doing something similar using the <code>qiskit.chemistry.FermionicOperator</code> built-in class (see example below) but for this example the Hamiltonian is mapped to a Fermionic one-body qubit Hamiltonian which has <span class=""math-container"">$2^n$</span> eigenvalues instead of <span class=""math-container"">$n$</span> eigenvalues (where <span class=""math-container"">$n=3$</span> for this case). I am hoping there is a simple way to directly map a matrix to a qubit operator. My vague understanding is I need to write the matrix as a sum of weighted Pauli operators but I would expect there would exist some predefined function for doing this? (I have looked at the source code for the <code>FermionicOperator</code> class but it did not help me much).</p>
<pre><code>import numpy as np
import scipy
import h5py

from qiskit.aqua.algorithms import VQE, NumPyEigensolver
from qiskit.chemistry import FermionicOperator
from qiskit import Aer

backend = Aer.get_backend(&quot;qasm_simulator&quot;)

c1=1
c2=2
c3=3

ff=np.zeros((3,3))
ff[1,1]=2
ff[2,2]=1

n=3

Hamil=np.zeros((n,n))
Hamil[1,1]=c2
Hamil[2,2]=-c3/2+c2
Hamil[0,2]=np.sqrt(2)*c1
Hamil[1,2]=np.sqrt(2)*c1
Hamil[2,0]=np.sqrt(2)*c1
Hamil[2,1]=np.sqrt(2)*c1

vals,vecs=np.linalg.eig(Hamil)

print(&quot;Standard Eigenvalues: &quot;)
print(vals)

Hamil_op = FermionicOperator(h1=Hamil)
Hamil_ops = Hamil_op.mapping(map_type='parity', threshold=1e-12)
result = NumPyEigensolver(Hamil_ops,k=int(2**n)).run()

print(&quot;Quibit Eigenvalues=&quot;)
print(result['eigenvalues'])

vqe = VQE(operator=Hamil_ops)
vqe_result = np.real(vqe.run(backend)['eigenvalue'])
print(&quot;VQE Eigenvalue&quot;)
print(vqe_result)
</code></pre>
<p>With result:</p>
<pre><code>Standard Eigenvalues:
[-1.45426242  0.90078898  3.05347344]
Quibit Eigenvalues=
[-1.45426242+0.j -0.55347344+0.j  0.        +0.j  0.90078898+0.j
  1.59921102+0.j  2.5       +0.j  3.05347344+0.j  3.95426242+0.j]
VQE Eigenvalue
0.18608074335373637
</code></pre>
",<qiskit><programming><vqe><eigenvalues-and-eigenvectors>,12/02/2020 20:00,14999.0,14999.0,"<p>I believe to have answered my own question through further attempts. Per the comment from KAJ226, it is true that a <span class=""math-container"">$(3 \times 3)$</span> matrix cannot be represented as a string of Paulis so I have nested the <span class=""math-container"">$(3 \times 3)$</span> matrix into a <span class=""math-container"">$(4 \times 4)$</span> matrix where the final row and column are all zeros. From this I can omit the useless eigenvalue/eigenvector and just retain the relevant results for the <span class=""math-container"">$(3 \times 3)$</span> matrix.</p>
<p>My solution mostly came from using the <code>WeightedPauliOperator</code>, <code>MatrixOperator</code>, and <code>op_converter</code> classes. Below is a sample of my code with corresponding outputs. Thanks to those who gave suggestions to help me out!</p>
<pre><code>import numpy as np
import scipy
import h5py

from qiskit.aqua.algorithms import VQE, NumPyEigensolver
from qiskit.aqua.operators import WeightedPauliOperator, MatrixOperator, op_converter
from qiskit import Aer

backend = Aer.get_backend(&quot;qasm_simulator&quot;)

c1=-0.5
c2=.75
c3=2

n1=3
Hamil=np.zeros((n1,n1))
Hamil[1,1]=c2
Hamil[2,2]=-c3/2+c2
Hamil[0,2]=c1
Hamil[1,2]=c1
Hamil[2,0]=c1
Hamil[2,1]=c1

print(&quot;(3x3) Hamiltonian&quot;)
print(Hamil)

vals,vecs=np.linalg.eig(Hamil)

print(&quot;Standard Eigenvalues: &quot;)
print(vals)

n2=4
Hamil=np.zeros((n2,n2))
Hamil[1,1]=c2
Hamil[2,2]=-c3/2+c2
Hamil[0,2]=c1
Hamil[1,2]=c1
Hamil[2,0]=c1
Hamil[2,1]=c1

print(&quot;(4x4) Hamiltonian&quot;)
print(Hamil)

Hamil_Mat=MatrixOperator(Hamil)
Hamil_Qop = op_converter.to_weighted_pauli_operator(Hamil_Mat)

q_vals = NumPyEigensolver(Hamil_Qop,k=4).run()

print(&quot;Qubit Op Eigenvalues: &quot;)
print(q_vals['eigenvalues'])

vqe=VQE(Hamil_Qop)
vqe_result=vqe.run(backend)

print(&quot;VQE Eigenvalue: &quot;)
print(vqe_result['eigenvalue'])
</code></pre>
<p>With result:</p>
<pre><code>(3x3) Hamiltonian
[[ 0.    0.   -0.5 ]
 [ 0.    0.75 -0.5 ]
 [-0.5  -0.5  -0.25]]
Standard Eigenvalues:
[-0.75  0.25  1.  ]
(4x4) Hamiltonian
[[ 0.    0.   -0.5   0.  ]
 [ 0.    0.75 -0.5   0.  ]
 [-0.5  -0.5  -0.25  0.  ]
 [ 0.    0.    0.    0.  ]]
Qubit Op Eigenvalues:
[-0.75+0.j  0.  +0.j  0.25+0.j  1.  +0.j]
VQE Eigenvalue:
(-0.705078125+0j)
</code></pre>
",12/05/2020 20:23,Tooling,"The user is asking about how to use Qiskit, a specific quantum computing software, to transform a Hamiltonian matrix into a qubit operator and then use the built-in VQE solver. This falls under tool usage in quantum programming.",Tooling,,,,Tooling,
14945.0,Why is the Measurement Result Always 1? (expected to find uniformly random measurement),"<p>I created a <span class=""math-container"">$|0\rangle$</span> state then applied <span class=""math-container"">$H$</span> gate to get <span class=""math-container"">$\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)$</span> and then I meausred my state. But I always found 1.
I expected to find 0 and 1 uniformly random like the case of beam splitter.</p>
<p>Here is my code:</p>
<pre><code>qubit = cirq.NamedQubit(&quot;myqubit&quot;)
circuit = cirq.Circuit(cirq.H(qubit))
for i in range(10):
    result2 = cirq.measure(qubit, key='myqubit')
    print(result2)
print(circuit)
# run simulation
result = cirq.Simulator().simulate(circuit)
print(&quot;result:&quot;)
print(result)
print(result2)
</code></pre>
<p>How can I find uniformly random result ?</p>
",<programming><quantum-state><measurement><cirq><random-quantum-circuit>,12/03/2020 14:40,14949.0,14949.0,"<p>You are not measuring your qubit. Look at what your <code>print(circuit)</code> is returning</p>
<pre><code>myqubit: âââHâââ
</code></pre>
<p>You need to add the measurement gate to the circuit like so:</p>
<pre><code>circuit = cirq.Circuit(cirq.H(qubit), cirq.measure(qubit, key='myqubit'))
</code></pre>
<p>Printing this circuit returns <code>myqubit: âââHâââMâââ</code></p>
<p>In your case, with the loop; you can append the gates:</p>
<pre><code>for i in range(10):
    circuit.append(cirq.measure(qubit, key='myqubit'))
</code></pre>
<p>Printing this one returns <code>myqubit: âââHâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââ</code></p>
<p>Both programs will get you the expected uniform random measurements.</p>
",12/03/2020 16:32, Tooling,"The user is asking about how to use Cirq, a specific quantum computing software, to get uniformly random results when measuring a quantum state. This falls under tool usage in quantum programming.",Errors,"The user is experiencing an issue with the quantum circuit not providing the expected measurement results. They are looking for a solution to ensure that measurements produce uniformly random results, indicating an error or misunderstanding in the quantum simulation setup.",No,99.0,Errors,The user is experiencing unexpected measurement results in their quantum circuit and seeks to understand why they always find the measurement result as 1 instead of getting uniformly random outcomes. This falls under the Errors category as it involves troubleshooting unexpected behavior in quantum simulations.
14947.0,Coping values based on indicator qubit in Qiskit,"<p>Give the following input:
<span class=""math-container"">$$
A: 1110 \\
B: 0111 \\
\text{indicator}: 0 \text{ or } 1
$$</span>
How do I copy the value of A or B to target qubits if indicator is 0 or 1 respectively?</p>
<p>In the image below, the <code>indicator=0</code> so the value of the <code>copy_of_a_or_b</code> qubits should resemble <code>a_input</code> qubits:</p>
<p><a href=""https://i.stack.imgur.com/besC9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/besC9.png"" alt=""enter image description here"" /></a></p>
<p>How can I do this in Qiskit?</p>
",<quantum-gate><programming><qiskit>,12/03/2020 15:26,14948.0,14948.0,"<p>It seems you are looking for a classical operation called <em>multiplexer</em>. It is possible to build such operation with Qiskit's uniformly controlled gates (<code>UCGate</code>). More info in <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.uc"" rel=""nofollow noreferrer"">here</a>.</p>
<p>However, this way might not be the easier way. After reading Cryoris' answer, here is my version of your example (which piggyback on <a href=""https://quantumcomputing.stackexchange.com/a/14950/1859"">Cryoris' great answer</a>):</p>
<p>Let's set your current circuit:</p>
<pre><code>from qiskit import *

a_input = QuantumRegister(4, name='a')
b_input = QuantumRegister(4, name='b')

inputs = QuantumCircuit(a_input, b_input)

inputs.initialize('1110', a_input)
inputs.initialize('0111', b_input)

inputs.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/izoPi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/izoPi.png"" alt=""enter image description here"" /></a></p>
<p>(side note, if your run <code>inputs.decompose().draw('mpl')</code> you will notice that the order of the <span class=""math-container"">$X$</span> gates are going to be &quot;in reverse&quot;. That's because <a href=""https://quantumcomputing.stackexchange.com/questions/8244/big-endian-vs-little-endian-in-qiskit"">Qiskit endianness</a>.)</p>
<p>Now, time to create the multiplexer. This scales up the <a href=""https://quantumcomputing.stackexchange.com/a/14950/1859"">Cryoris' answer</a>:</p>
<pre><code>from qiskit.circuit.library import CXGate

indicator = QuantumRegister(1, name='indicator')
a_or_b = QuantumRegister(4, name='aORb')

multiplexer = QuantumCircuit(a_input, b_input, indicator, a_or_b)
for i in range(4):
    # If indicator is 0, copy from A
    multiplexer.append(CXGate().control(1, ctrl_state='0'), [indicator, a_input[i], a_or_b[i]])
    
multiplexer.barrier(a_input, b_input)

for i in range(4):
    # If indicator is 1, copy from B
    multiplexer.append(CXGate().control(1, ctrl_state='1'), [indicator, b_input[i], a_or_b[i]])

multiplexer.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/FbNQ8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FbNQ8.png"" alt=""enter image description here"" /></a></p>
<p>The register <code>a_or_b</code> needs to be measured:</p>
<pre><code>output = ClassicalRegister(4, name='output')
measure = QuantumCircuit(a_or_b)
measure.measure_all(a_or_b)
</code></pre>
<p>The composed result:</p>
<pre><code>circuit = inputs + multiplexer + measure
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/aaLEc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aaLEc.png"" alt=""enter image description here"" /></a></p>
<p>Finally, we need to &quot;set&quot; the <code>indicator</code> qubit. Once circuit for each possibility:</p>
<pre><code>indicator0 = QuantumCircuit(indicator)
indicator0.initialize('0', indicator)

indicator1 = QuantumCircuit(indicator)
indicator1.initialize('1', indicator)
</code></pre>
<p>Time to test how it works:</p>
<pre><code>job = execute(indicator0 + circuit, backend=BasicAer.get_backend('qasm_simulator'))
job.result().get_counts().keys()
</code></pre>
<pre><code>dict_keys(['1110'])
</code></pre>
<pre><code>job = execute(indicator1 + circuit, backend=BasicAer.get_backend('qasm_simulator'))
job.result().get_counts().keys()
</code></pre>
<pre><code>dict_keys(['0111'])
</code></pre>
",12/03/2020 15:56,Tooling,"The user is asking about how to implement a specific feature (copying the value of A or B to target qubits based on an indicator) in Qiskit, a specific quantum computing software. This falls under tool usage in quantum programming.",Tooling,,,,Tooling,
14951.0,Device Repetition Rate on Melbourne,"<p>I've been receiving &quot;Circuit runtime is greater than the device repetition rate [8020]&quot; errors when running a relatively simple circuit on ibmq_16_Melbourne, but have had no issues whatsoever when running the same on the Aer backend simulator. The circuit size is 11 and depth is 6. Would anyone have any idea why this might be happening? Thank you!</p>
<p><strong><em>Clarification:</em></strong> I am attempting to implement Shor's algorithm using the circuit image below. I have heard mentioned that the three large controlled multiplication gates are not necessary, but I am admittedly not clear on this as my results are much different without them. Any advice is greatly appreciated.
<a href=""https://i.stack.imgur.com/nA1y7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nA1y7.png"" alt="""" /></a></p>
",<programming><qiskit><circuit-construction><ibm-q-experience><quantum-circuit>,12/03/2020 16:46,14953.0,14953.0,"<p>The error <code>Circuit runtime is greater than the device repetition rate [8020]</code> is associate with the fact that your circuit is too deep. The device can't handle that many quantum operations.</p>
<p>The depth of 6 might not seems a lot but it can when pretty large when you map it to the real hardware device. This is because not all the qubits are connected in a quantum processor. Hence a lot of overhead swapping needs to be done.</p>
<p>For example: Consider this depth 6 random circuit.</p>
<p><a href=""https://i.stack.imgur.com/3rXrS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3rXrS.png"" alt=""enter image description here"" /></a></p>
<p>You can create this random circuit with some fixed depth through Qiskit as follows:</p>
<pre><code>from qiskit.circuit.random import random_circuit
num_qubits = 11
circuit_depth = 5
max_operands = 3 #between 0 and 3
measurement_all_qubit = True
qc_random = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure=measurement_all_qubit)
print( 'original ircuit depth', qc_random.depth() )
qc_random.draw( 'mpl',style={'name': 'bw'},  scale = 1, filename = 'random depth 6', plot_barriers= False, initial_state = True)
</code></pre>
<br>
<p>The above doesn't take into account the hardware connectivity issues. But if we are going to map this onto real hardware, like the <code>ibmq_16_melbourne</code> then it would get larger. In fact, it would translate to a circuit of <strong>depth of 108</strong>. Below is the transpiled circuit being mapped to <code>ibmq_16_melbourne</code>.</p>
<p><a href=""https://i.stack.imgur.com/9BGKk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9BGKk.jpg"" alt=""enter image description here"" /></a></p>
<p>Here is the code for that transpilation process if you are interested:</p>
<pre><code>provider = IBMQ.load_account()
from qiskit.compiler import transpile
Circuit_Transpile = transpile(qc_random, provider.get_backend('ibmq_16_melbourne') , optimization_level=3)
print('Transpiled circuit depth', Circuit_Transpile.depth() )
Circuit_Transpile.draw( 'mpl',style={'name': 'bw'}, filename = 'random transpiled', plot_barriers= False, initial_state = True, scale = 1)
</code></pre>
",12/03/2020 17:10,Tooling,"The user is encountering a specific error while running a quantum circuit on a specific quantum computing platform, which falls under the usage of quantum programming tools.",Tooling,,,,Tooling,
14955.0,Why does the problem Hamiltonian of QAOA always consist of $Z$ and $I$ gates?,"<p>I noticed that in QAOA the problem hamiltonian always consists of <span class=""math-container"">$Z$</span> and <span class=""math-container"">$I$</span> gates. But isn't QAOA a form of Adiabatic Programming? Where the idea is just to go from one ground state to another?
Does that not mean that every Hamiltonian can be the problem Hamiltonian?</p>
<p>And the Mixer consists always just of <span class=""math-container"">$X$</span> gates. Why not <span class=""math-container"">$Y$</span> gates for example?</p>
",<programming><qaoa><adiabatic-model>,12/03/2020 18:57,14957.0,14957.0,"<p>QAOA was first introduced as a quantum algorithm to tackle combinatorial optimization problems. Hence, there is a direct translation of these to Hamiltonians with <span class=""math-container"">$I$</span> and <span class=""math-container"">$Z$</span> operators. And you always see the mixer as just <span class=""math-container"">$X$</span> operators because</p>
<ol>
<li>the equal-superposition state (obtained by Hadamard transform on <span class=""math-container"">$| 0\rangle^{\otimes N}$</span>) is a ground state of the mixer (which is a requirement in adiabatic computing)</li>
<li>the type of problems tackled do not include constraints.</li>
</ol>
<p>However, other mixers can be used depending what one wants to solve (see <a href=""https://arxiv.org/abs/1709.03489"" rel=""nofollow noreferrer"">this article on modifying the mixers for constrained combinatorial optimization problems</a>).</p>
",12/03/2020 19:33,Conceptual,"The question pertains to the conceptual understanding of QAOA (Quantum Approximate Optimization Algorithm) and its choice of Hamiltonians and mixers. It seeks an explanation for why QAOA typically uses specific types of gates in the problem Hamiltonian and mixer, which falls under the ""Conceptual"" category related to the underlying concepts and design choices in quantum algorithms.",Conceptual,,,,Conceptual,
14959.0,How to run a OpenQASM 3.0 file?,"<p>When uploading a QASM-file with <code>ÃPENQASM 3.0;</code> as first line, the code editor on quantum-computing.ibm.com will throw an error.</p>
<p>However the qiskit Python library doesn't support the new features (e.g. for-loops) of OPENQASM 3 either.</p>
<p>So where can I run an OPENQASM 3.0 file?</p>
",<programming><qiskit><ibm-q-experience><qasm>,12/03/2020 21:23,14960.0,14960.0,"<p>OpenQASM3 is in an early release stage for circulation for feedback in the quantum community. OpenQASM3 aims to be a standardized language proposal for near-term quantum computing hardware with real-time computing capabilities. We hope that it will lay the foundation for extracting tangible benefits from real quantum computers in the coming years by providing a straightforward interface for research in error-correction, classical/quantum algorithms, and control techniques. Information about the language can be found in the <a href=""https://qiskit.github.io/openqasm/"" rel=""noreferrer"">live specification</a>. It is expected that this will evolve quite rapidly in the coming months. We value all feedback and accept issues or pull requests being submitted on the <a href=""https://github.com/Qiskit/openqasm"" rel=""noreferrer"">language specification repository</a>.</p>
<p>A formal grammar and accompanying parser should be available shortly and will be found in the language repository. Work has begun to add support for the new functionality introduced in OpenQASM3 in Qiskit, simulators, and hardware backends. As support is rolled out it will be announced.</p>
",12/03/2020 22:10,Tooling,"The user is asking about how to run an OPENQASM 3.0 file, which is a specific task related to the usage of quantum computing software and tools.",Tooling,,,,Tooling,
14964.0,How to get subspace of quantum circuit?,"<p>How can I get a subspace of a quantum circuit? More precisely, I'm dealing with quantum circuit with data qubits ('q') and ancilla qubits ('anc'), such as <span class=""math-container"">$(q_0,q_1,...,q_n,anc_0,..anc_m)$</span>.</p>
<p>After some quantum operations, I'd like to get a unitary matrix representation of the data qubits. Is this possible?</p>
",<programming><qiskit><quantum-state><matrix-representation>,12/04/2020 05:37,14968.0,14968.0,"<p>What you are looking for is the partial trace of a density matrix, <span class=""math-container"">$|\psi\rangle\langle\psi|$</span>, where <span class=""math-container"">$|\psi\rangle=|q_0,q_1,...,ac_0,ac_1,...\rangle$</span>. This matrix is surely a unitary matrix, and it can be viewed as a tensor product of all the density matrices of each qubit.</p>
<p>To get a subspace of a quantum circuit, you have to partial trace over all the irrelevant qubits, in your case, <span class=""math-container"">$Tr_{ac}(|\psi\rangle\langle\psi|)$</span>.</p>
<p>If you are using <code>qiskit</code>, see the lower code as an example:</p>
<pre><code>from qiskit import QuantumCircuit,QuantumRegister
from qiskit.quantum_info import DensityMatrix,partial_trace
import numpy as np
qr=QuantumRegister(2)
circ=QuantumCircuit(qr)
circ.h(qr[0])
circ.cx(qr[0],qr[1])
DM=DensityMatrix.from_instruction(circ)
print(DM.data)
PT=partial_trace(DM,[0])
print(PT.data)
</code></pre>
<p>If you are not using the python package, and suppose you already got the density matrix of the entire quantum circuit, see the lower code(<code>qiskit</code> is again used to generate the density matrix, but I provide another function for partial trace in this place):</p>
<pre><code>def partial_trace(rho,qubit2keep):
    num_qubit=int(np.log2(rho.shape[0]))
    for i in range(len(qubit2keep)):
            qubit2keep[i]=num_qubit-1-qubit2keep[i]
    qubit_axis=[(i,num_qubit+i) for i in range(num_qubit)
                    if i not in qubit2keep]
    minus_factor=[(i,2*i) for i in range(len(qubit_axis))]
    minus_qubit_axis=[(q[0]-m[0],q[1]-m[1])
                        for q, m in zip(qubit_axis,minus_factor)]
    rho_res=np.reshape(rho,[2,2]*num_qubit)
    qubit_left=num_qubit-len(qubit_axis)
    for i,j in minus_qubit_axis:
        rho_res=np.trace(rho_res,axis1=i,axis2=j)
    if qubit_left&gt;1:
        rho_res=np.reshape(rho_res,[2**qubit_left]*2)
    return rho_res
from qiskit import QuantumCircuit,QuantumRegister
from qiskit.quantum_info import DensityMatrix
import numpy as np
qr=QuantumRegister(2)
circ=QuantumCircuit(qr)
circ.h(qr[0])
circ.cx(qr[0],qr[1])
DM=DensityMatrix.from_instruction(circ)
print(DM.data)
PT=partial_trace(DM.data,[0])
print(PT)
</code></pre>
<p>(Note that the <code>partial_trace</code> function is a rewritten of <a href=""https://gist.github.com/neversakura/d6a60b4bb2990d252e9e89e5629d5553"" rel=""noreferrer"">this one</a>, the default sequence in this code and mine are reversed.)</p>
<p>The two codes give identical results. In <code>PT=partial_trace(DM.data,[0])</code>, <code>[0]</code> denotes
the qubit to be traced out, maybe some test should be helpful for you to trace out the qubits that you don't need correctly.</p>
",12/04/2020 08:43,Tooling ,"The user is asking about how to get a subspace of a quantum circuit and obtain a unitary matrix representation of the data qubits, which involves the usage of quantum computing software and tools.",Tooling,,,,Tooling ,
14973.0,How to transpile a circuit using Qiskit as done in IBMQ experience,"<p>When I create a circuit using Qiskit and then transpile it using <code>transpiled_circuit = transpile(circuit, ibm_backend, optimization_level=1)</code> then I open my IBMQ account and go to circuit composer to draw the circuit and run it on the same backend, the transpiled circuit I got from the circuit composer is different from that from my qiskit code.</p>
<p><strong>For example,</strong> I have the following circuit :</p>
<p><a href=""https://i.stack.imgur.com/FcNoc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FcNoc.png"" alt=""Quantum circuit"" /></a></p>
<p>when I transpile it in my qiskit code
<code>transpiled_circuit = transpile(circuit, provider.get_backend('ibmq_athens'), optimization_level=1)</code> I got the following circuit :</p>
<p><a href=""https://i.stack.imgur.com/Bp6Xf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Bp6Xf.png"" alt=""qiskit_transpiled_circuit"" /></a>
Using the IBMQ experience circuit composer I got the following transpiled circuit when I run using <code>ibmq_athens</code></p>
<p><a href=""https://i.stack.imgur.com/UM0hs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UM0hs.png"" alt=""transpile_circuit_qasm"" /></a></p>
<p>I tried different optimization levels in qiskit and the transpiled circuit is also different.</p>
<p><strong>My question is how I can get a transpiled circuit in qiskit to be the same as the one returned from IBMQ experience circuit composer.</strong></p>
",<programming><qiskit><ibm-q-experience>,12/04/2020 16:56,14982.0,14982.0,"<p><code>transpiled_circuit = transpile(circuit, ibm_backend, seed_transpiler=13)</code> gave me the circuit returned from IBMQ. Also I discovered that even on IBMQ, transpilation is random in most of the backends, in other words, when you run the same circuit many times on the same backend, you get different transpiled circuits.</p>
",12/05/2020 00:45,Tooling,"The user is asking about how to use Qiskit, a specific quantum computing software, to get a transpiled circuit that matches the one returned from the IBMQ Experience Circuit Composer. This falls under tool usage in quantum programming.",Tooling,,,,Tooling,
15014.0,Does TensorFlow Quantum tfq.convert_to_tensor work on custom gates?,"<p>I'm trying to use <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a> with <a href=""https://www.tensorflow.org/quantum"" rel=""nofollow noreferrer"">TensorFlow Quantum</a> to simulate a variational quantum classifier. There's a <a href=""https://www.tensorflow.org/quantum/tutorials/mnist"" rel=""nofollow noreferrer"">tutorial</a> on the TFQ website on building a quantum neural network to classify a simplified version of MNIST, which I've been using for reference.</p>
<p>The classifier that I'm building requires building my own <a href=""https://quantumai.google/cirq/custom_gates"" rel=""nofollow noreferrer"">custom gates</a>.</p>
<p>After encoding the data as quantum circuits, the next step is to convert these Cirq circuits to tensors using <a href=""https://www.tensorflow.org/quantum/api_docs/python/tfq/convert_to_tensor"" rel=""nofollow noreferrer""><code>tfq.convert_to_tensor</code></a>.</p>
<p>I've found that this function works fine for any built-in Cirq gates, but when I pass my own custom gate as the argument, I get <code>ValueError: Cannot serialize op &lt;__main__.Custom_Gate object at...</code></p>
<p>Here's some watered down code that gives the gist of my attempts:</p>
<pre><code>def simple_func(x):
    return x*cirq.z

class Custom_Gate(cirq.Gate):
    def __init__(self, x, n):
        self.x = x
        self.n = n
    def _unitary_(self):
        return simple_func(self.x)
    def _num_qubits_(self):
        return self.n
    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'):
        return ['U']

x = 3
n = 1
U = Custom_Gate(x, n)
q0 = cirq.GridQubit(0, 0)
test_circuit = cirq.Circuit()
test_circuit.append(U.on(q0))
SVGCircuit(test_circuit)

tfq.convert_to_tensor([test_circuit])
</code></pre>
<p>Am I making a mistake somewhere? Or does <code>tfq.convert_to_tensor</code> just not work for custom gates?</p>
<p>Thank you.</p>
",<programming><cirq><quantum-enhanced-machine-learning><tfq><quantum-neural-network>,12/07/2020 04:32,15016.0,15016.0,"<p>I'm the engineer who looks after TensorFlow Quantum. Serializing custom gates is not supported. There is an active issue on the GitHub here: <a href=""https://github.com/tensorflow/quantum/issues/354"" rel=""noreferrer"">https://github.com/tensorflow/quantum/issues/354</a> . A quick workaround would be to try and determine the gate decomposition for your custom gate in terms of <code>tfq.util.get_supported_gates</code> gate instances. A good place to start might be the <a href=""https://cirq.readthedocs.io/en/stable/generated/cirq.kak_decomposition.html"" rel=""noreferrer"">cirq.kak_decomposition</a>.</p>
<p>Michael</p>
",12/07/2020 06:02, Tooling,"The user is asking about how to use TensorFlow Quantums tfq.convert_to_tensor function with custom gates in Cirq, which involves the usage of specific quantum computing software and tools.",Tooling,,,, Tooling,
15018.0,Is there a faster way to get 'a list of' result from 'a list of inputs'?,"<p>I had a question about <a href=""https://quantumcomputing.stackexchange.com/questions/13584/how-can-i-print-out-the-probability-of-a-certain-state-in-histogram"">obtaining the probability of a certain state from the histogram</a>, still using this example, suppose there's a variable in my quantum circuit, it's values are stored in an 'np.linspace' array. This is the result obtained from one of the elements in that array:
<a href=""https://i.stack.imgur.com/Yveyk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Yveyk.png"" alt=""enter image description here"" /></a>
If I'm only interested in the probability of the '0010' state (0.831 here), is there a faster way I can get a list (or array) of the probability of '0010' using each element in my original linspace? I tried to incorporate a few commands (like job_sim and result_sim) into a function, but that doesn't work.</p>
<p>ps: The structure of my function looks something like this:</p>
<pre><code>from qiskit import IBMQ
provider = IBMQ.load_account()
sim = provider.backends.ibmq_qasm_simulator
def qc(Variable):
    qcz = QuantumCircuit(qrz,crz)
    ......
    job_sim = execute(qcz, sim)
    result_sim = job_sim.result()
    counts = result_sim.get_counts()
    probs = counts['0010'] / sum(counts.values())
    return probs
</code></pre>
<p>After that I want to call the function using each of the elements in my linspace.</p>
<p>update:Sorry maybe I was a bit unclear in my original question, if my simulation result is determined by some variable X, for each value of X, I might obtain a different probability of the state '0010'. If there're N values of X, all of which are stored in an array and I want to run my circuit N times, is there a faster way I can do that instead of manually changing the variable and record the result? Thanks for the help:)</p>
",<programming><simulation><qasm>,12/07/2020 06:14,15019.0,15019.0,"<p>You can do something like this:</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, QuantumRegister,  IBMQ, ClassicalRegister
from qiskit.circuit import QuantumCircuit, ParameterVector
from qiskit.compiler import transpile, assemble
from qiskit.providers.ibmq.managed import IBMQJobManager
from qiskit.visualization import *
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_valencia')

def qc(Variable):
    var_form = QuantumCircuit(2,2)
    var_form.u1(Variable,0)
    var_form.cx(0,1) 
    var_form.measure([0,1],[0,1])
    return var_form

Variables = [1,2,3,4,5]
circuits = []
for i in range(len(Variables) ):
    circuit =  QuantumCircuit(2,2)
    circuit = qc(Variables[i])
    circuits.append( circuit   )

circuits = transpile(circuits, backend=backend) 
job_manager = IBMQJobManager()
MyExperiments = job_manager.run(circuits, backend=backend, name='MyExperiment')
results = MyExperiments.results()
</code></pre>
<p>Note that <code>qc(Variable)</code> is spitting out circuit output of the form:</p>
<p><a href=""https://i.stack.imgur.com/dxGtE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dxGtE.png"" alt=""enter image description here"" /></a></p>
<p>so the Ry gate is taking in the variable. You can modify the circuit to your choice.</p>
<p>Now when I run this, and look in the IBMQX <code>results</code> tabs I see the following:</p>
<p><a href=""https://i.stack.imgur.com/BfA8U.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BfA8U.png"" alt=""enter image description here"" /></a></p>
<p>Hope this helps.</p>
",12/07/2020 06:28,Tooling,"The user is seeking a more efficient way to obtain probabilities of a specific quantum state for various values of a variable in their quantum circuit. This question relates to the tooling aspect of quantum computing, specifically how to optimize and automate the process of running simulations with different variable values.",Tooling,,,,Tooling,
15029.0,qiskit: How to get an operator acting on a certain qubit?,"<p>I have a system of <span class=""math-container"">$N$</span> qubits and want to construct a quantum operator <span class=""math-container"">$Z_i Z_j + Z_k$</span>, where <span class=""math-container"">$Z_i$</span> denotes the Pauli-Z operator acting on the <span class=""math-container"">$i$</span>th qubit. Is there any direct way in qiskit, how I could implement this?</p>
<p>I know that I can construct an operator by e.g. saying <code>op = Z^Z</code>, if I have a system of 2 qubits and want the operator being the Pauli-Z on each qubit. But I would like to tell qiskit the indices of the qubits that <span class=""math-container"">$Z$</span> should act on (such that on all the other qubits Identity is applied).</p>
<p>My way so far consists of constructing a Quantum Circuit and converting this to an operator by</p>
<pre><code>circZZ = QuantumCircuit(N)  # circuit for Z_i Z_j
circZ = QuantumCircuit(N)  # circuit for Z_k
circZZ.z(i)
circZZ.z(j)
circZ.z(k)
opZZ = CircuitOp(circZZ)  # convert circuit to operator
opZ = CircuitOp(circZ)  # convert circuit to operator
op = opZZ + opZ
</code></pre>
<p>But that means I have to create quantum circuits everytime I want to get this operator. Is there any shorter and more elegant way to create such an operator?</p>
",<programming><qiskit>,12/07/2020 12:26,15030.0,15030.0,"<p>The class <code>Operator</code> has a <code>from_label</code> method: <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Operator.html?highlight=operator%20from_label#qiskit.quantum_info.Operator.from_label"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.Operator.html?highlight=operator%20from_label#qiskit.quantum_info.Operator.from_label</a></p>
<p>That means you could do something like this:</p>
<pre><code>opZZ = Operator.from_label('ZZ')
opZ = Operator.from_label('Z')
</code></pre>
<p>It's possible to <em>add</em> <code>opZZ</code> and <code>opZ</code> into N-sized <code>op</code>. However, you have to call the <code>_add</code> by hand:</p>
<pre><code>op = 0 * Operator.from_label('I' * N)  # Set the initial operator to zero
op = op._add(opZZ, qargs=[i,j])
op = op._add(opZ, qargs=[k])
</code></pre>
",12/07/2020 12:45,Tooling,"The user is inquiring about a more efficient and direct way to create a specific quantum operator in Qiskit. This question pertains to the tooling aspect of quantum computing, specifically how to construct operators with desired properties in a more concise manner.",Tooling,,,,Tooling,
15045.0,Qubit Connectivity of IBM Quantum Computer,"<p>When simulating a quantum circuit using the <code>qiskit</code> <code>qasm_simulator</code>, the qubits that you assign to the quantum circuit may be connected to all other qubits. In other words, if there are <span class=""math-container"">$n$</span> qubits in the quantum circuit, a single qubit can interact with all other <span class=""math-container"">$n-1$</span> qubits.</p>
<p>This is quite an unpractical hypothesis for real quantum computation. <strong>k-locality</strong> is a common criterion for a quantum computer and the only quantum computer I know of that has full qubit-connectivity is <a href=""https://www.nature.com/articles/s41467-019-13534-2"" rel=""nofollow noreferrer"">this one</a>(I omitted the trivial cases of single- or two-qubit quantum computer). In the case of quantum devices that IBM provides via cloud access, e.g., 5-qubit ibmq_santiago, 5-qubit ibmq_5_yorktown, and 15-qubit ibmq_16_melbourne, all provide limited qubit connectivity.</p>
<p>So here arises my question: when designing a quantum circuit we have to take qubit connectivity into consideration, but how does <code>qiskit</code> handle this? Does it assign the job automatically (such that the quantum circuit can still work), or should I pre-assign my logical qubits to the real qubits of the IBM quantum computer by hand? And if so, how do I do that?</p>
",<programming><qiskit><physical-qubit>,12/08/2020 07:47,15046.0,15046.0,"<p>You can pass the parameter <code>coupling_map</code> to <code>execute</code> or <code>transpile</code>. This allows simulating a specific connectivity scheme as a list of edges.</p>
<p>The transpiling process (implicit during the execution process) takes care of adapting your circuit to the specific limitations of the backend or to the given limitations such as the <code>coupling_map</code> parameter. You can also control parts of that adaptation with parameters like <code>initial_layout</code> (you can define to which physical qubits you want to allocate your circuit).</p>
<p>Consider the following example:</p>
<pre><code>from qiskit import *

circuit = QuantumCircuit(3)
circuit.cx(0, 1)
circuit.cx(1, 2)
circuit.cx(2, 0)
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/ZIDvw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZIDvw.png"" alt=""enter image description here"" /></a></p>
<p>This circuit requires a directed circular connectivity map. By default, transpiling this circuit takes a fully connected map, so it has no changes:</p>
<pre><code>transpiled = transpile(circuit)
transpiled.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/CiU1f.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CiU1f.png"" alt=""enter image description here"" /></a></p>
<p>If you want to add the restriction of a particular connectivity map, you can do so with the argument <code>coupling_map</code>. In this case, it is a directed linear connectivity <span class=""math-container"">$ 0 \rightarrow 1 \rightarrow 2$</span>:</p>
<pre><code>transpiled = transpile(circuit, coupling_map=[[0,1], [1,2]])
transpiled.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/ACyA1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ACyA1.png"" alt=""enter image description here"" /></a></p>
<p>Notice that a <em>SWAP</em> gate was added and the direction of <em>CNOT</em> was corrected. Also, the qubit allocation is showed on the left-hand side (e.g. logical qubit <span class=""math-container"">$q_0$</span> was allocated to physical qubit <span class=""math-container"">$2$</span>.</p>
<p>You can control the qubit allocation with the parameter <code>initial_layout</code>. In the following example, logical <span class=""math-container"">$q_0$</span> is forced to be allocated to physical qubit 0 and so on:</p>
<pre><code>transpiled = transpile(circuit, coupling_map=[[0,1], [1,2]], initial_layout=[0, 1, 2])
transpiled.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/ZROqU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZROqU.png"" alt=""enter image description here"" /></a></p>
",12/08/2020 08:32,Tooling,"The user is seeking information about how Qiskit handles qubit connectivity and whether they need to manually assign logical qubits to physical qubits when designing a quantum circuit for real quantum devices. This question pertains to the tooling aspect of quantum computing, specifically how to work with the constraints of qubit connectivity in quantum circuit design using Qiskit.",Tooling,,,,Tooling,
15048.0,Conjugate transpose of a U-gate,"<p>I want to be able to create the circuit depicted below, but running the code below results in an empty circuit when viewing the job afterwards.</p>
<p><a href=""https://i.stack.imgur.com/okXsw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/okXsw.png"" alt=""enter image description here"" /></a></p>
<pre><code>backend = provider.backends.ibmq_armonk


qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.u(pi/2, pi/2, pi/2, qreg_q[0])
circuit.x(qreg_q[0])
circuit.y(qreg_q[0])
circuit.x(qreg_q[0])
circuit.y(qreg_q[0])
circuit.u(pi/2, pi/2, pi/2, qreg_q[0]).inverse()

circuit.measure(qreg_q[0], creg_c[0])


qobj = assemble(transpile(circuit, backend=backend), backend=backend)
job = backend.run(qobj)
retrieved_job = backend.retrieve_job(job.job_id())
</code></pre>
",<programming><qiskit><circuit-construction>,12/08/2020 10:16,15049.0,15049.0,"<p>Indeed, your circuit can be reduced to an identity circuit as @KAJ226 nicely explains <a href=""https://quantumcomputing.stackexchange.com/a/15056/1859"">here</a>. The transpilation process notices that and reduces your gates to idle during circuit depth optimization:</p>
<pre><code>qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')

circuit = QuantumCircuit(qreg_q, creg_c)
circuit.u(pi/2, pi/2, pi/2, qreg_q[0])
circuit.x(qreg_q[0])
circuit.y(qreg_q[0])
circuit.x(qreg_q[0])
circuit.y(qreg_q[0])
circuit.u(pi/2, pi/2, pi/2, qreg_q[0]).inverse()

circuit.measure(qreg_q[0], creg_c[0])

transpile(circuit, backend=backend).draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/k96rK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/k96rK.png"" alt=""enter image description here"" /></a></p>
<p>You can avoid the optimization by reducing the optimization level to <span class=""math-container"">$0$</span>:</p>
<pre><code>transpile(circuit, backend=backend, optimization_level=0).draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/QouBl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QouBl.png"" alt=""enter image description here"" /></a></p>
<p>In your example, you need to modify the <code>transpile</code> call like this:</p>
<pre><code>qobj = assemble(transpile(circuit, backend=backend, optimization_level=0), backend=backend)
</code></pre>
",12/08/2020 10:49,Errors,"The user is experiencing an issue where the code results in an empty circuit when viewing the job afterward. They are seeking help to identify and rectify this error, making it fall under the ""Errors"" category.",Errors,,,,Errors,
15058.0,How to project a composite system down into a smaller subspace in Python?,"<p>If we have a composite system over five qubits (<span class=""math-container"">$|\psi\rangle = |a\rangle|b\rangle|c\rangle|d\rangle|e\rangle$</span>), and I want to project into a specific subspace of the first three systems, I can build a projector of the form <span class=""math-container"">$|011\rangle\langle011| \otimes I_{de}$</span> (for example). Before projecting, state <span class=""math-container"">$|\psi\rangle$</span> can be thought of as an array with length <span class=""math-container"">$2^5 = 32$</span>. My goal is to do the projection <em>and</em> reduce the size of my vector appropriately (so now I only have an array over the final two qubits). I'm doing this in Qiskit (after I get the statevector and am done evolving). My projectors will always have the form above, just perhaps with a different bitstring (in my example, I had &quot;011&quot;). This is what I've done so far:</p>
<ol>
<li><p>Since the projectors are diagonal, I convert the string &quot;011&quot; into an integer. In this case, it's 3. The corresponding matrix will look like:
<span class=""math-container"">$$ \begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{pmatrix} .$$</span></p>
</li>
<li><p>Because the subspace is like this, the identity matrix <span class=""math-container"">$I_{de}$</span> will just be a matrix of size <span class=""math-container"">$2^2\times2^2$</span> and when we take the tensor product, we will get a matrix similar to the one above, but now the size of the matrix will be bigger, and the <span class=""math-container"">$1$</span> that's above will be the only place where the identity shows up (since everywhere else will be zero). I won't write down the matrix because it has size <span class=""math-container"">$32\times32$</span>.</p>
</li>
<li><p>If I have my state <span class=""math-container"">$|\psi\rangle$</span> and I want to project down, I figured I just had to find the components of my 32-element array which correspond to this subspace.</p>
</li>
<li><p>If the position of the 1 in my matrix above is given by <span class=""math-container"">$p$</span> and my state is an array called <code>psi</code>, then I want to say that the projection is given by simply slicing my array as such:
<code>projected = psi[(2**2)p:(2**2)*(p+1)]</code></p>
</li>
</ol>
<p>My question is: Am I doing the right slicing in step 4? I think I am, but it's easy to get tripped up with these subspaces. I know that this won't work in general since the projection operator could be more involved, but in the case where it's diagonal like the above matrix and is only one element, do I have the steps involved correct?</p>
",<programming><projection-operator>,12/08/2020 21:34,15069.0,15069.0,"<p>Your slicing is correct, and gives the right answer in your example. Here is a generalization of your slicing, for the case where you may have a different string of bits.</p>
<pre><code>import numpy as np

def return_indices(subspace):
    n_qubits = len(subspace)
    indices = np.array(range(32)).reshape((2,)*n_qubits)
    output_indices = indices[subspace].reshape(-1)
    return output_indices

# building a test psi to see if the code works well
psi = np.zeros(32, dtype=np.complex)
psi[12:16] = list(range(1,5))

# representing the subspace that we would like to project on
subspace = (0,1,1,slice(0,2),slice(0,2))

output_indices = return_indices(subspace) #returns array([12, 13, 14, 15])

psi[output_indices] #returns array([1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j])

</code></pre>
<p>I also ran another test, by taking</p>
<pre><code>subspace2 = (1,0,slice(0,2),1,slice(0,2))
output_indices2 = return_indices(subspace2)
</code></pre>
<p>Then output_indices2 is <code>array([18, 19, 22, 23])</code>, as it should.</p>
<p>Edit: In case you are interested in projecting on the subspace where the first qubit is <span class=""math-container"">$0$</span>, the second qubit is <span class=""math-container"">$1$</span> and the third quibit is <span class=""math-container"">$+$</span>, then you can simply use linear superposition. Indeed, this is <span class=""math-container"">$1/\sqrt{2}$</span> times the projection of the state on the <span class=""math-container"">$|010::\rangle$</span> subspace plus <span class=""math-container"">$1/\sqrt{2}$</span> times the projection of the state on the <span class=""math-container"">$|011::\rangle$</span> subspace. I am using a colon, just as in Python, to indicate that the corresponding index is free. So you can adapt the code to handle a case where you have a <span class=""math-container"">$+$</span> state. However, the code is written assuming you are mostly interested in <span class=""math-container"">$0$</span> and <span class=""math-container"">$1$</span> states.</p>
",12/09/2020 15:22,Conceptual,"The user is seeking clarification on the conceptual aspect of projecting a quantum state onto a subspace and how to correctly slice the quantum state's components to obtain the projected result. This question pertains to the underlying concepts of quantum state manipulation, making it suitable for the ""Conceptual"" category.",Conceptual,,,,Conceptual,
15063.0,Does Cirq support GPU acceleration?,"<p>I'm wondering if Cirq does (or plans to) support GPU acceleration of matrix operations, including density matrix simulations. I would like to speed up training and evaluations of variational circuits under different noise conditions when GPUs are available.</p>
",<programming><cirq>,12/09/2020 03:38,15072.0,15072.0,"<p><a href=""https://github.com/quantumlib/Cirq"" rel=""nofollow noreferrer"">Cirq</a>'s mainline doesn't have this but you can use <a href=""https://github.com/qulacs/cirq-qulacs"" rel=""nofollow noreferrer"">cirq-qulacs</a>; which has a Variational Quantum Circuit Simulator and supports CUDA for high performance simulation.</p>
",12/09/2020 21:24,Tooling,"The user is asking about the functionality of a specific quantum computing tool, Cirq, and its support for GPU acceleration. This falls under the category of questions related to tools and software usage in quantum programming.",Tooling,,,,Tooling,
15076.0,Trying to understand this measurement of a simple quantum circuit,"<p>It's a newbie question, I know. But I was just wondering if someone could help me understand why this simple circuit results with the measurement shown. I've just didn't get the last step. It's not supposed that the last Hadamard gate would cancel the first one on q[0]? Why I still got results like 011 or 111?</p>
<p><a href=""https://i.stack.imgur.com/JsNE7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JsNE7.png"" alt=""Simple quantum circuit"" /></a></p>
",<quantum-gate><programming><circuit-construction><measurement><simulation>,12/10/2020 01:53,15077.0,15077.0,"<p>You can think of the circuit operation as follows. Remembering that for Hadamard matrix: <span class=""math-container"">$H \times H = \mathbb{I}$</span>, your circuit looks like the following:
<span class=""math-container"">$$
H \otimes \mathbb{I} \otimes \mathbb{I}(CCNOT(H|0\rangle \otimes H|0\rangle \otimes |0\rangle ))
$$</span>
Let's focus on the inner-most part first:
<span class=""math-container"">$$
H|0\rangle \otimes H|0\rangle \otimes |0\rangle \\
=\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes |0\rangle \\
= \frac{1}{2}(|000\rangle + |010\rangle + |100\rangle + |110\rangle).
$$</span>
Now, the action of <span class=""math-container"">$CCNOT$</span> gate is that, if the first two qubits are <span class=""math-container"">$1$</span>, then the third qubit would be flipped. But notice that in the above state, only the last term has two <span class=""math-container"">$1$</span>'s in it, i.e. the <span class=""math-container"">$|110\rangle$</span> term. So, the action of <span class=""math-container"">$CCNOT$</span> on the above state would be:
<span class=""math-container"">$$
CCNOT(\frac{1}{2}(|000\rangle + |010\rangle + |100\rangle + |110\rangle)) \\
= \frac{1}{2}(|000\rangle + |010\rangle + |100\rangle + |111\rangle). 
$$</span>
Now we apply the Hadamard matrix on the first qubit only:
<span class=""math-container"">$$
H \otimes \mathbb{I} \otimes \mathbb{I}(\frac{1}{2}(|000\rangle + |010\rangle + |100\rangle + |111\rangle)) \\
= \frac{1}{2}(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)|00\rangle + \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)|10\rangle + \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)|00\rangle + \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)|11\rangle)).
$$</span>
Simplify it! Would be a good exercise if nothing else. :) You would see that the resulting state has the terms that you have shown in the second picture.</p>
",12/10/2020 03:06, Conceptual,"The user is seeking an understanding of a quantum circuit's behavior, particularly why the last Hadamard gate does not cancel out the first one on q[0]. This question pertains to the conceptual aspects of quantum computing and circuit behavior.",Conceptual,,,, Conceptual,
15087.0,How can I resolve this get_count issue from running multiple circuits?,"<p>I'm running a couple of circuits at the same time using an array of variables. However, I met an issue regarding accessing the counts. Here's part of the code I have:</p>
<pre><code>probsu = []
circuits = []

for i in range(len(Variable)):
    circuit =  QuantumCircuit(qrz,crz)
    circuit =  qc(Variable[i])
    circuits.append(circuit)
    prob = counts['1001'] / sum(counts.values()) **Issue here**
    probsu.append(prob)                          **Issue here**

circuits = transpile(circuits, backend=backend) 
job_manager = IBMQJobManager()
MyExperiments = job_manager. run(circuits, backend=backend, name='MyExperiment')
results = MyExperiments.results()
counts = results.get_counts(circuit)
</code></pre>
<p>I'm not able to get the counts since the line is referenced before the definition in the last line. However, there will be similar issues pop up if I remove the bottom lines before the for loop. How can I resolve this issue? Thanks:)</p>
",<programming><qiskit><experiment>,12/10/2020 17:13,15088.0,15088.0,"<p>You <em>mean</em> something like this?</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, QuantumRegister,  IBMQ, ClassicalRegister
from qiskit.circuit import QuantumCircuit, ParameterVector
from qiskit.compiler import transpile, assemble
from qiskit.providers.ibmq.managed import IBMQJobManager
from qiskit.visualization import *
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_qasm_simulator')

def qc(Variable):
    var_form = QuantumCircuit(2,2)
    var_form.ry(Variable,0)
    var_form.cx(0,1) 
    var_form.h(1)
    var_form.measure([0,1],[0,1])
    return var_form

Variables = [1,2,3,4,5]
circuits = []
for i in range(len(Variables) ):
    circuit =  QuantumCircuit(2,2)
    circuit = qc(Variables[i])
    circuits.append( circuit   )


circuits = transpile(circuits, backend=backend) 
job_manager = IBMQJobManager()
MyExperiments = job_manager.run(circuits, backend=backend, shots =1000, name='MyExperiment')
results = MyExperiments.results()

probsu = []
for i in range(len(Variables) ):
    prob = results.get_counts(i)['11']/sum( results.get_counts(i).values() ) 
    probsu.append(prob) 
print('probability of getting |11&gt; at each circuit:', probsu)
</code></pre>
<p>which generate the output:</p>
<pre><code>probability of getting |11&gt; at each circuit: [0.121, 0.33, 0.458, 0.417, 0.178]
</code></pre>
<p>the output above corresponds to the probabilities of reading out <span class=""math-container"">$|11\rangle$</span> on each of the 5 circuits... You can modify this circuit to your purpose... as this is only an example.</p>
",12/10/2020 17:45,Errors,The user is encountering an issue with their code where they are trying to access a variable before it is defined. This falls under the Errors category.,Errors,,,,Errors,
15095.0,Design a circuit implementing the unitary matrix,"<p>Is it possible to design a circuit implementing the unitary matrix</p>

<p><span class=""math-container"">$$U-\begin{bmatrix}
R_{\Theta_1} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; R_{\Theta_2} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; R_{\Theta_3} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; R_{\Theta_4} \\
\end{bmatrix}$$</span></p>
<p>for given four angles <span class=""math-container"">$\Theta_1,...,\Theta_4$</span> , where 0 is 2Ã2-dimensional zero matrix and <span class=""math-container"">$R_{\Theta}$</span> is the rotation matrix with angle <span class=""math-container"">$\Theta$</span>?</p>
<p>If so, can we implement it on the available quantum programming platforms such as Qiskit, CirQ, PyQuil, or ProjectQ?</p>
",<programming>,12/11/2020 00:08,15100.0,15100.0,"<p>At worst, you could perform the construction
<a href=""https://i.stack.imgur.com/LaOZf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LaOZf.png"" alt=""enter image description here"" /></a>
but depending on your different rotations, you may be able to make some efficiency savings. For example, one improvement that you can always make is you could start by applying <span class=""math-container"">$R_1$</span> on the first qubit without controlling it off anything, and then applying <span class=""math-container"">$R_iR_1^\dagger$</span> for the other three controlled-controlled operations.</p>
",12/11/2020 07:46,Theoretical ,The user is inquiring about the theoretical possibility of designing a quantum circuit to implement a specific unitary matrix based on given angles. They are also asking if this can be implemented using various quantum programming platforms. This question falls under the theoretical aspects of quantum computing.,Theoretical ,,,,Theoretical ,
15096.0,Classically controlled quantum operators,"<p>Does CirQ support classically controlled quantum operators where the classical values obtained by the measurement?</p>
",<programming>,12/11/2020 00:48,15097.0,15097.0,"<p>Currently, there is no mechanism for performing classical feedback in cirq. It is on the roadmap. It will probably look something like <code>cirq.X(q)**measurement_result(key)</code> in the end, but for now it doesn't exist.</p>
",12/11/2020 05:37,API Usage,"The user is asking about the specific functionality of the Cirq library, which falls under the discussion of how to correctly and effectively use APIs in quantum programming",API Usage,,,,API Usage,
15109.0,ProjectQ - Error messages,"<p>How can we get rid of runtime next error:</p>
<pre><code>Traceback (most recent call last):
  File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\types\_qubit.py&quot;, line 135, in __del__
    self.engine.deallocate_qubit(weak_copy)
  File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_basics.py&quot;, line 153, in deallocate_qubit
    tags=[DirtyQubitTag()] if is_dirty else [])])
  File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_main.py&quot;, line 288, in send
    raise compact_exception  # use verbose=True for more info
RuntimeError: Qubit has not been measured / uncomputed. Cannot access its classical value and/or deallocate a qubit in superposition!
 raised in:
'  File &quot;C:\\Users\\Marija\\Anaconda3\\lib\\site-packages\\projectq\\backends\\_sim\\_pysim.py&quot;, line 139, in get_classical_value'
'    raise RuntimeError(&quot;Qubit has not been measured / &quot;'```

 
</code></pre>
",<programming>,12/11/2020 10:49,15490.0,15490.0,"<p>By measuring all the qubits at the end of the code, I avoided the above-mentioned error message.</p>
",01/12/2021 01:06, Errors,"The user is encountering a runtime error in their code related to qubit measurement and deallocation. They are seeking a solution to resolve this error, making it fall under the ""Errors"" category.",Errors,,,, Errors,
15110.0,Get state vector of a single qubit in a circuit in Qiskit,"<p>I have two quantum circuits, and I would like to compare state vector of the first qubit and check if equals, what is the best way to do that in qiskit ?</p>
<p>Let's say I have :</p>
<pre><code>psi = QuantumCircuit(5)
psi.ry(np.pi/4.,0)
psi.x(0)
psi.x(1)
    
psi2 = QuantumCircuit(5)
psi2.ry(np.pi/4.,0)
psi2.x(0)
</code></pre>
<p>I'm looking for a function which returns True when qubit 0 has the same state vector in both circuits.</p>
<p>I tried to get the information from Statevector.from_instruction(psi).data, but I don't know how to extract information independently of other qubits.</p>
<p>Edit:
I get the right result with this function :</p>
<pre><code>def QuantumCircuits_Statevectors_AreEquals(QuantumCircuit1, QuantumCircuit2, QubitIndex):

        statevector1_arr = np.empty([1,2]).astype(complex)
        statevector2_arr = np.empty([1,2]).astype(complex)

        QuantumCircuit1.snapshot(&quot;qbsnap&quot;, qubits=[QubitIndex])
        QuantumCircuit2.snapshot(&quot;qbsnap&quot;, qubits=[QubitIndex])

        backend = Aer.get_backend('statevector_simulator')

        snapshot1 = execute(QuantumCircuit1, backend).result().data()['snapshots']['statevector']['qbsnap']
        snapshot2 = execute(QuantumCircuit2, backend).result().data()['snapshots']['statevector']['qbsnap']

        statevector1_arr[0][0] = snapshot1[0][0]
        statevector1_arr[0][1] = snapshot1[0][1]

        statevector2_arr[0][0] = snapshot2[0][0]
        statevector2_arr[0][1] = snapshot2[0][1]

        return np.array_equal(statevector1_arr, statevector2_arr)
</code></pre>
<p>But maybe a cleaner solution is possible?</p>
",<programming><qiskit><quantum-state>,12/11/2020 11:28,15318.0,15318.0,"<p>For a boolean-valued result, your code works.</p>
<p>If you are looking for a &quot;more quantum mechanical&quot; approach, then the <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.87.167902"" rel=""nofollow noreferrer"">swap trick</a> best suits you.</p>
<p>The quantum circuit of the swap trick is as follows:</p>
<p><a href=""https://i.stack.imgur.com/ivfXQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ivfXQ.png"" alt=""enter image description here"" /></a></p>
<p>(figure comes from the cited paper.) In this circuit, <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle$</span> are the two states that you want to compare, then the probability that measuring the uppermost qubit(the control qubit) returns a &quot;0&quot; is <span class=""math-container"">$\frac{1}{2}+\frac{1}{2}F(|\psi\rangle,|\phi\rangle)$</span>, where is the fidelity I mentioned in the comment.</p>
<p>Since you know how to get the state vector from qiskit directly, it is more efficient and accurate to calculate the fidelity(or the trace distance) of the two state vectors.</p>
",12/29/2020 13:22, Tooling," The user is asking about how to compare the state vectors of specific qubits in two different quantum circuits using Qiskit, which falls under the usage of tools and software in quantum programming",Tooling,,,, Tooling,
15179.0,Computing the CDF with QAE in Qiskit,"<p>I want to load a lognormal distribution and then use an IntegerComparator to flip a qubit (<span class=""math-container"">$|0\rangle$</span> to <span class=""math-container"">$|1\rangle$</span>) if its value is less than a threshold. Then I want to use an Quantum Amplitude Estimation algorithm to calculate the probability of measuring <span class=""math-container"">$|1\rangle$</span>.</p>
<p>My code so far is:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np

from qiskit import Aer, QuantumCircuit, QuantumRegister, execute
from qiskit.aqua.algorithms import IterativeAmplitudeEstimation
from qiskit.circuit.library import LogNormalDistribution, IntegerComparator



num_uncertainty_qubits = 3

S = 100
vol = 0.4
r = 0.04
T = 3*(30/365)


mu = np.log(S) + (r-0.5*vol**2)*T
sigma = vol*np.sqrt(T)

mean = np.exp(mu - 0.5*sigma**2)
variance = (np.exp(sigma**2)-1)*np.exp(2*mu + sigma**2)
stddev = np.sqrt(variance)

low = np.maximum(0, mean-3*stddev)
high = mean + 3*stddev

uncertainty_model = LogNormalDistribution(num_uncertainty_qubits, mu=mu, sigma=sigma**2, bounds=(low, high))

# 3 qubit LogNormalDistribution model
uncertainty_model = LogNormalDistribution(3, mu=mu, sigma=sigma, bounds=(low, high))

# function to create the quantum circuit of the IntegerComparator and the uncertainty model
# x_eval is the threshold below which the qubit should be flipped
def get_cdf_circuit(x_eval):
    qr_state = QuantumRegister(uncertainty_model.num_qubits, 'state')
    qr_obj = QuantumRegister(1, 'obj')
    qr_comp = QuantumRegister(2, 'compare')
    state_preparation = QuantumCircuit(qr_state, qr_obj, qr_comp)
    
    state_preparation.append(uncertainty_model, qr_state)
    comparator = IntegerComparator(uncertainty_model.num_qubits, x_eval, geq=False)
    
    state_preparation.append(comparator, qr_state[:]+qr_obj[:]+qr_comp[:])
    
    return state_preparation

# Function to implement the Amplitude Estimation algorithm

def run_ae_for_cdf(x_eval, epsilon=0.01, alpha=0.05, simulator='qasm_simulator'):

    state_preparation = get_cdf_circuit(x_eval)

    ae_var = IterativeAmplitudeEstimation(state_preparation=state_preparation,
                                          epsilon=epsilon, alpha=alpha,
                                          objective_qubits=[len(qr_state)]) 
    result_var = ae_var.run(quantum_instance=Aer.get_backend(simulator), shots=100)
    
    return result_var['estimation']
</code></pre>
<p>Broadly speaking, I want to flip the objective qubit to <span class=""math-container"">$|1\rangle$</span> if the state is less than or equal to x_eval.</p>
<p>On running this, I'm getting the same amplitude estimation every time, even when I use different threshold values.</p>
<p>I'm missing something. Please help me out.</p>
<p>PS: <a href=""https://i.stack.imgur.com/tHyDM.jpg"" rel=""nofollow noreferrer"">https://i.stack.imgur.com/tHyDM.jpg</a> This is the link to the QuantumCircuit. P(X) is the LogNormalDistribution and Cmp is the comparator.</p>
<p>PPS: Using LinearAmplitudeFunction to compare floating numbers:</p>
<pre><code>def get_comparator(threshold, num_qubits, low, high):
    breakpoints = [low, threshold]
    offsets = [0,0]
    slopes = [0,0]
    f_min = 1
    f_max = 0
    objective = LinearAmplitudeFunction(
        num_qubits,
        slopes,
        offsets,
        domain=(low, high),
        image=(f_min, f_max),
        breakpoints=breakpoints
    )
    return objective
</code></pre>
",<programming><qiskit><amplitude-amplification><quantum-computing-for-finance><quantum-circuit>,12/17/2020 12:16,15182.0,15182.0,"<p>I think it would be also useful to see your Quantum Circuit using <code>%matplotlib inline</code><br />
and <code>qc.draw('mpl')</code> to see whether all gates are correctly connected. I had a similar problem with QAE and figured out by using this method that the order of qubits I tried to append the <code>IntegerComparator</code> onto was wrong. Cheers</p>
",12/17/2020 20:12,Errors,The user is encountering an issue with their quantum computing code where the amplitude estimation is the same for different threshold values. This falls under the Errors category .,Errors,,,,Errors,
15187.0,Access and set_state during quantum computation simulation in cirq,"<p>The <a href=""https://quantumai.google/cirq/simulation#stepping_through_a_circuit"" rel=""nofollow noreferrer"">documentation</a> for Cirq mentions the possibility to step through a circuit's moments, and access the exact wavefunction via <code>step.state_vector()</code>, and edit set it via <code>step.set_state()</code>. In the API documentation, neither function is documented. While the former seems to work anyway, the latter (setting the state) gives an AttributeError. I am using Cirq 0.9.1.</p>
<p>How can I change the wavefunction used for the next moment simulation?</p>
",<programming><cirq>,12/18/2020 10:31,15228.0,15228.0,"<p>You found a bug in the docs, the method is <code>set_state_vector()</code> - I opened <a href=""https://github.com/quantumlib/Cirq/issues/3623"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/issues/3623</a>.</p>
<p>The methods are only available on the <code>SparseSimulatorStep</code> which is the default simulator in Cirq.</p>
<p>They are available in the API docs though set_state_vector has no docstring:</p>
<ul>
<li><p><a href=""https://quantumai.google/reference/python/cirq/sim/SparseSimulatorStep?hl=en#state_vector"" rel=""nofollow noreferrer"">state_vector()</a></p>
</li>
<li><p><a href=""https://quantumai.google/reference/python/cirq/sim/SparseSimulatorStep?hl=en#set_state_vector"" rel=""nofollow noreferrer"">set_state_vector()</a></p>
</li>
</ul>
",12/21/2020 19:38,Errors,"The user is encountering an AttributeError when trying to use the set_state() function in Cirq, indicating an issue with their code or a potential bug in the library. This falls under the Errors category ",Errors,,,,Errors,
15189.0,XY Hamiltonian in a 1D Heisenberg Chain,"<p>I've been trying to implement the 1D Heisenberg chain (i.e. the XXZ model) on Qiskit but have been having trouble. To recap, the Heisenberg hamiltonian is as follows:
<span class=""math-container"">$$H_{XXZ} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1} + \Delta S^{z}_{i}S^{z}_{i+1})] $$</span>
and we can take the XY hamiltonian to be
<span class=""math-container"">$$H_{XY} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1})]$$</span>
as I understand. I know that the matrix representation of this hamiltonian's time evolution takes the form
<span class=""math-container"">$$XY(\theta) = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos[{\theta}/2] &amp; i\sin[{\theta}/2] &amp; 0\\
0 &amp; i\sin[{\theta}/2] &amp; \cos[{\theta}/2] &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}$$</span>
however, I'm not exactly sure how to implement it on Qiskit with the available Quantum logic gates. I do know that a special case to this problem is the iSwapGate, where it is equal to <span class=""math-container"">$XY(\theta = \pi)$</span>, but is there a way to implement <span class=""math-container"">$XY(\theta)$</span> for arbitrary angles?</p>
",<quantum-gate><programming><qiskit><hamiltonian-simulation><matrix-representation>,12/18/2020 18:17,15191.0,15191.0,"<p>Here is an implementation</p>
<pre><code>from qiskit.circuit import QuantumCircuit, Parameter

theta = Parameter('Î¸')

qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.crx(-1 * theta, 1, 0)
qc.cx(0, 1)

print(qc)
---
          ââââââââââ     
q_0: âââ âââ¤ RX(-Î¸) ââââ ââ
     âââ´âââââââ¬ââââââââ´ââ
q_1: â¤ X ââââââ ââââââ¤ X â
     âââââ          âââââ
</code></pre>
<p>and to evaluate that it works:</p>
<pre><code>from qiskit.quantum_info import Operator

def XY(theta):
    c = np.cos(theta / 2)
    s = 1j * np.sin(theta / 2)
    
    return np.array([[1, 0, 0, 0], 
                     [0, c, s, 0], 
                     [0, s, c, 0], 
                     [0, 0, 0, 1]])

val = pi / 14
circ = qc.bind_parameters({theta: val})
np.allclose(Operator(circ).data, 
            XY(val))
---
True
</code></pre>
",12/18/2020 19:51,Tooling,"The user is asking about how to implement the 1D Heisenberg chain (XXZ model) using Qiskit, a quantum computing framework. This falls under the category ",Conceptual,"The user is seeking an understanding of how to implement the XY interaction term of the Heisenberg model (XXZ model) using Quantum logic gates in Qiskit, which falls under the ""Conceptual"" category as it pertains to the underlying concepts of quantum programming.",No,100.0,Conceptual,"The user is seeking an understanding of how to implement the XY interaction term of the Heisenberg model using Quantum logic gates in Qiskit. This falls under the ""Conceptual"" category as it pertains to the underlying concepts of quantum programming, specifically the implementation of quantum gates to represent the desired Hamiltonian."
15199.0,Grover's algorithm for finding 6/8 states,"<p>I'm trying to apply the diffusion operator to this state (normalization factors excluded):
<span class=""math-container"">$|000\rangle + |001\rangle - |010\rangle - |011\rangle - |100\rangle - |101\rangle - |110\rangle  -|111\rangle$</span></p>
<p>However, I get the resulting state:
<span class=""math-container"">$|001\rangle+|001\rangle$</span></p>
<p>This is the opposite of what I want. Is there a solution? I know that my oracle is correct since I can view the phases of <span class=""math-container"">$\pi$</span>:</p>
<p><a href=""https://i.stack.imgur.com/RiMoy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RiMoy.png"" alt=""phases"" /></a>.</p>
<p>And my implementation of the diffusion operator is the same one as for all 3 qubit states - yet I still get a resulting state of:</p>
<p><a href=""https://i.stack.imgur.com/Nz4po.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Nz4po.png"" alt=""result"" /></a></p>
",<programming><quantum-state><grovers-algorithm><oracles>,12/19/2020 20:18,15267.0,15267.0,"<p>This is a well known behavior of Grover's algorithm.
It is described in &quot;Quantum Computation and Quantum Information&quot; book under section 6.1.4</p>
<blockquote>
<p>[...] the number of iterations needed by the search algorithm
increases with <span class=""math-container"">$M$</span>, for <span class=""math-container"">$M â¥ N/2$</span>. Intuitively, this is a silly property
for a search algorithm to have: we expect that it should become easier
to find a solution to the problem as the number of solutions
increases.</p>
</blockquote>
<p>You will find also a workaround for this issue:</p>
<blockquote>
<p>[...] by adding a single qubit <span class=""math-container"">$|q\rangle$</span> to the search index, doubling the number
of items to be searched to <span class=""math-container"">$2N$</span>. A new augmented oracle <span class=""math-container"">$O'$</span> is
constructed which marks an item only if it is a solution to the search
problem and the extra bit is set to zero.</p>
</blockquote>
",12/24/2020 20:18,Errors,"The user is encountering an issue where the quantum circuit does not produce the expected result when applying the diffusion operator. They are seeking help to identify and resolve this error, making it fall under the ""Errors"" category.",Errors,,,,Errors,
15203.0,How do you represent one-qubit rotations in two registers as a $4\times 4$ unitary matrix?,"<p>Let's say you have a circuit that performs a Z-rotation in the first register, and a Y-rotation in second register. How can we express this &quot;moment&quot; in terms of a 4x4 matrix, i.e. a two-qubit gate? My end goal is to express the circuit below in terms of only <code>tfq.util.get_supported_gates</code> :</p>
<pre><code>{cirq.X: 1,
 cirq.XX: 2,
 cirq.Y: 1,
 cirq.YY: 2,
 cirq.Z: 1,
 cirq.ZZ: 2,
 cirq.H: 1,
 cirq.CZ: 2,
 cirq.CNOT: 2,
 cirq.SWAP: 2,
 cirq.ISWAP: 2,
 cirq.FSimGate(theta=0.123, phi=0.456): 2,
 cirq.I: 1,
 cirq.PhasedXPowGate(phase_exponent=0.123): 1,
 cirq.PhasedISwapPowGate(phase_exponent=0.123): 2}
</code></pre>
<p>But I would like to start by understanding how I would represent just the first stacked Y- and Z-rotation in terms of a 4x4 matrix. For each moment, after I have the matrix representation, I plan to use <code>cirq.two_qubit_matrix_to_operations</code> to decompose this quasi-two-qubit operation into Z/XY/CZ gates.</p>
<p><a href=""https://i.stack.imgur.com/tSqwz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tSqwz.png"" alt=""short-depth circuit"" /></a></p>
<p>Are either of these the correct representation for <span class=""math-container"">$Rz(\gamma)$</span> and <span class=""math-container"">$Ry(\theta)$</span> rotations in registers one and two respectively?</p>
<p>1.
<span class=""math-container"">$$ \begin{pmatrix} \cos{\theta} &amp; -\sin{\theta} &amp; 0 &amp; 0 \\ \sin{\theta} &amp; \cos{\theta} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; e^{-i\gamma/2} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; e^{i\gamma/2} \end{pmatrix} $$</span></p>
<p>2.
<span class=""math-container"">$$ \begin{pmatrix} e^{-i\gamma/2}\cos{\theta} &amp; 0 &amp; -e^{-i\gamma/2}\sin{\theta} &amp; 0 \\ 0 &amp; e^{i\gamma/2}\cos{\theta} &amp; 0 &amp; -e^{i\gamma/2}\sin{\theta} \\ e^{-i\gamma/2}\sin{\theta} &amp; 0 &amp; e^{-i\gamma/2}\cos{\theta} &amp; 0 \\ 0 &amp; e^{i\gamma/2}\sin{\theta} &amp; 0 &amp; e^{i\gamma/2}\cos{\theta} \end{pmatrix} $$</span></p>
",<programming><circuit-construction><matrix-representation><cirq><tfq>,12/20/2020 0:36,15204.0,15204.0,"<p>Note 100% sure if this is what you are asking but when you have a circuit like:</p>
<p><a href=""https://i.stack.imgur.com/adLb1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/adLb1.png"" alt=""enter image description here"" /></a></p>
<p>and you want to write it as a <span class=""math-container"">$4 \times 4$</span> Unitary matrix <span class=""math-container"">$U$</span> then you can do it as:</p>
<p><span class=""math-container"">$ U = R_y(a[0]) \otimes  R_z(a[1]) $</span></p>
<p>This can be generalized to any size as well. So if you have</p>
<p><a href=""https://i.stack.imgur.com/8kvM1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8kvM1.png"" alt=""enter image description here"" /></a></p>
<p>then it can be written as an <span class=""math-container"">$8 \times 8$</span> matrix <span class=""math-container"">$U$</span> as <span class=""math-container"">$U = R_y(a[0]) \otimes  R_z(a[1]) \otimes H $</span>.</p>
<hr />
<p>Note that if <span class=""math-container"">$ A = \begin{pmatrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{pmatrix}$</span> and <span class=""math-container"">$ B = \begin{pmatrix} b_1 &amp; b_2 \\ b_3 &amp; b_4 \end{pmatrix}$</span> then
<span class=""math-container"">$A \otimes B = \begin{pmatrix} a_1 \cdot B &amp; a_2 \cdot B\\ a_3 \cdot B &amp; a_4 \cdot B \end{pmatrix}  $</span></p>
<p><strong>Update:</strong> So to be explicit, we can see that:</p>
<p><span class=""math-container"">\begin{align}
 R_y(2\theta_1) \otimes  R_z(2 \theta_2) &amp;= \begin{pmatrix} \cos\theta_1 &amp; -\sin\theta_1 \\ \sin\theta_1 &amp; \cos\theta_1 \end{pmatrix} \otimes \begin{pmatrix} e^{-i \theta_2} &amp; 0 \\ 0 &amp; e^{i \theta_2} \end{pmatrix}\\
&amp;= \begin{pmatrix} \cos\theta_1 \begin{pmatrix} e^{-i \theta_2} &amp; 0 \\ 0 &amp; e^{i \theta_2} \end{pmatrix} &amp; -\sin \theta_1 \begin{pmatrix} e^{-i \theta_2} &amp; 0 \\ 0 &amp; e^{i \theta_2} \end{pmatrix} \\ \sin \theta_1 \begin{pmatrix} e^{-i \theta_2} &amp; 0 \\ 0 &amp; e^{i \theta_2} \end{pmatrix} &amp; \cos \theta_1 \begin{pmatrix} e^{-i \theta_2} &amp; 0 \\ 0 &amp; e^{i \theta_2} \end{pmatrix} \end{pmatrix}\\
&amp;= \begin{pmatrix} \cos\theta_1 e^{-i \theta_2} &amp; 0 &amp; -\sin \theta_1 e^{-i \theta_2} &amp; 0\\ 
0 &amp; \cos \theta_1 e^{i \theta_2} &amp; 0 &amp; -\sin\theta_1 e^{i\theta_2}\\
\sin\theta_1 e^{-i \theta_2} &amp; 0 &amp; \cos \theta_1 e^{-i \theta_2} &amp; 0\\ 
0 &amp; \sin \theta_1 e^{i \theta_2} &amp; 0 &amp; \cos\theta_1 e^{i\theta_2}\\
 \end{pmatrix}
\end{align}</span></p>
<p>And if you don't want to do this by hand in the future, then you can do this operation pretty fast in python:</p>
<pre><code>import numpy as np 
import sympy as sym

x1 = sym.Symbol('x1')
x2 = sym.Symbol('x2')
i = sym.Symbol('i')

Ry = [[sym.cos(x1), -sym.sin(x1)], [sym.sin(x1),sym.cos(x1)]] 
Rz = [[sym.exp(-i*x2),0], [0,sym.exp(i*x2)]]
U = np.kron(Ry,Rz)
print(U) 
</code></pre>
",12/20/2020 1:15,Theoretical,The user is seeking an understanding of the matrix representations of specific quantum gates (Rz and Ry rotations) and how to express a circuit with these gates in terms of a 4x4 matrix. This involves a theoretical understanding of quantum gates and matrix representations.,Theoretical,,,,Theoretical,
15230.0,Kernel stopping when solving water molecule ground state,"<p>I'm new to QISKIT Aqua and I'm trying to follow the Ground State tutorial to solve the Water molecule ground state, but when I execute the calculations the kernel stops.
I'm using IBM Q Experience jupyter notebooks and the only thing I changed from the original tutorial is the molecule. I Changed it by excluding the previous molecule and adding this to the code:</p>
<pre><code>import numpy as np

angle = np.deg2rad(104.45/2)
dist = 0.9584
molecule = Molecule(geometry=[['O', [0., 0., 0.]],
                              ['H', [dist*np.sin(angle), -dist*np.cos(angle), 0.]],
                              ['H', [-dist*np.sin(angle), -dist*np.sin(angle), 0.]]],
                     charge=0, multiplicity=1)
</code></pre>
",<programming><qiskit><ibm-q-experience><ibm>,12/21/2020 20:57,15231.0,15231.0,"<p>Here is the working code. Because of the symmetry in water molecule, I used the <strong><a href=""https://en.wikipedia.org/wiki/Z-matrix_(chemistry)"" rel=""nofollow noreferrer"">Z Matrix</a></strong> representation instead of the usual XYZ format.  You can and should be able to execute this within the IBM Quantum Experience.</p>
<pre><code>import os
os.environ['QISKIT_SETTINGS']=''
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = 'svg' # Makes the images look nice
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE, NumPyEigensolver
from qiskit.aqua.components.optimizers import COBYLA
from qiskit.aqua.components.initial_states import Custom
from qiskit import IBMQ, BasicAer, Aer
from qiskit.chemistry.qmolecule import QMolecule
from qiskit.chemistry.drivers import PySCFDriver, UnitsType
from qiskit.chemistry import FermionicOperator
from qiskit.chemistry.core import Hamiltonian, TransformationType, QubitMappingType
from qiskit.circuit.library import TwoLocal
import warnings
warnings.filterwarnings(&quot;ignore&quot;,category=DeprecationWarning)

provider = IBMQ.load_account()
simulator_backend = Aer.get_backend(&quot;qasm_simulator&quot;)
hardware_backend = provider.get_backend('ibmq_valencia')
quantum_instance = QuantumInstance(backend = simulator_backend, shots= 1, optimization_level= 3)

atom_structure = &quot;H; O 1 0.958; H 2 0.958 1 104.47&quot;  
orbital_reduction=[ ] 
[unit, charge, spin, basis]= [UnitsType.ANGSTROM, 0, 0, 'sto6g'] 
driver = PySCFDriver(atom= atom_structure, unit=unit,charge=charge, spin=spin, basis=basis)
qmolecule = driver.run()
ferOp = Hamiltonian(transformation = TransformationType.FULL , 
                    qubit_mapping = QubitMappingType.PARITY,
                    two_qubit_reduction = True,
                    freeze_core = True, 
                    orbital_reduction = [ ], 
                    z2symmetry_reduction = 'auto')
qubitOp, aux_ops = ferOp.run(qmolecule)

energy_shift = ferOp._energy_shift
nuclear_repulsion_energy = ferOp._nuclear_repulsion_energy 
total_shift = energy_shift + nuclear_repulsion_energy 

print('HF Energy is:' , ferOp._hf_energy )
print('\n *********************************Exact Eigensolver*************************************** \n')
exact_result = NumPyMinimumEigensolver(qubitOp).run() 
ee_result = ferOp.process_algorithm_result(exact_result)
print(ee_result)

    
#----------------------- VQE PROCESSED ---------------------------# 
var_form= TwoLocal(qubitOp.num_qubits, ['ry'], ['cx'], entanglement= 'linear',
                    reps= 2,skip_unentangled_qubits=True, skip_final_rotation_layer = False, insert_barriers=True,
                    initial_state = None) 


optimizer = COBYLA(maxiter= 50,tol=0.000000001)   
vqe = VQE(qubitOp, var_form, optimizer, initial_point = None, 
          include_custom = True, aux_operators=aux_ops)
vqe_result = vqe.run(quantum_instance)
vqe_processed_result = ferOp.process_algorithm_result(vqe_result)
vqe_energy = vqe_result['eigenvalue'] + total_shift
total_ang_moment = vqe_processed_result['total_angular_momentum'] 
print('Optimal VQE energy at this step is:', vqe_energy)
print('The corresponding Total Angular Momentum is', total_ang_moment)
vqe.get_optimal_circuit().draw('mpl', style = {'name': 'bw'}, scale = 0.75, plot_barriers = False) 
</code></pre>
<p>Ran this gave me the output:</p>
<pre><code>HF Energy is: -75.6787913259016

 *********************************Exact Eigensolver*************************************** 

=== GROUND STATE ENERGY ===
 
* Electronic ground state energy (Hartree): -84.916233233599
  - computed part:      -23.633272241623
  - frozen energy part: -61.282960991976
  - particle hole part: 0.0
~ Nuclear repulsion energy (Hartree): 9.187404411009
&gt; Total ground state energy (Hartree): -75.72882882259
Optimal VQE energy at this step is: (-72.69078459811197+0j)
The corresponding Total Angular Momentum is 1.2057181036792375
</code></pre>
<p>and the optimal circuit:
<a href=""https://i.stack.imgur.com/CGHf9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CGHf9.png"" alt=""enter image description here"" /></a></p>
<p>As you can see this var_form is too long to be executed with good result for the hardware so maybe you can modify it. Changing the entangle_map might help. So instead of using <code>entanglement= 'linear'</code> you can set it to be something else. Note that you can also specify how the CNOT gates are connected. That is if you specify:</p>
<pre><code>var_form= TwoLocal(qubitOp.num_qubits, ['ry'], ['cx'], entanglement= [ [0,1],[2,3],[4,5],[6,7] ],
                    reps= 1,skip_unentangled_qubits=True, skip_final_rotation_layer = False, insert_barriers=True,
                    initial_state = None) 
</code></pre>
<p>Then you would get something like:</p>
<pre><code>     ââââââââââââ â       â  ââââââââââââ
q_0: â¤ RY(Î¸[0]) âââââââ âââââââ¤ RY(Î¸[8]) â
     ââââââââââââ¤ â âââ´ââ â  ââââââââââââ¤
q_1: â¤ RY(Î¸[1]) âââââ¤ X ââââââ¤ RY(Î¸[9]) â
     ââââââââââââ¤ â âââââ â ââ´âââââââââââ¤
q_2: â¤ RY(Î¸[2]) âââââââ ââââââ¤ RY(Î¸[10]) â
     ââââââââââââ¤ â âââ´ââ â âââââââââââââ¤
q_3: â¤ RY(Î¸[3]) âââââ¤ X âââââ¤ RY(Î¸[11]) â
     ââââââââââââ¤ â âââââ â âââââââââââââ¤
q_4: â¤ RY(Î¸[4]) âââââââ ââââââ¤ RY(Î¸[12]) â
     ââââââââââââ¤ â âââ´ââ â âââââââââââââ¤
q_5: â¤ RY(Î¸[5]) âââââ¤ X âââââ¤ RY(Î¸[13]) â
     ââââââââââââ¤ â âââââ â âââââââââââââ¤
q_6: â¤ RY(Î¸[6]) âââââââ ââââââ¤ RY(Î¸[14]) â
     ââââââââââââ¤ â âââ´ââ â âââââââââââââ¤
q_7: â¤ RY(Î¸[7]) âââââ¤ X âââââ¤ RY(Î¸[15]) â
     ââââââââââââ â âââââ â âââââââââââââ
</code></pre>
",12/21/2020 21:26,Errors," The user is experiencing a problem where the Jupyter notebook kernel stops when executing Qiskit Aqua calculations after modifying the molecule in a tutorial. This falls under the ""Errors"" category as they are seeking help to identify and rectify the issue, which might be related to the code or environment setup.",Errors,,,,Errors,
15233.0,Increase maximum shots on IBM Hardware when running Quantum Variational Algorithms,"<p>I am interested to know whether there is a quick and elegant way of increasing the number of shots (more than 8192 shots) on IBM hardware when running variational algorithms like VQE or QAOA.</p>
<p>I know that within Qiskit, I can specify:
<code>backend._configuration.max_shots= shots </code> to change the number of max_shots but this only works for simulator. I <strong>can't</strong> increase the <code>shots</code> parameter to go over <strong>8192 shots</strong> when I set my backend as one of the real hardware. That is, if I specify the following:</p>
<pre><code>hardware_backend = provider.get_backend('ibmq_valencia ')
maxshots = 20000
hardware_backend._configuration.max_shots= maxshots
quantum_instance = QuantumInstance(hardware_backend, shots = maxshots, initial_layout = None,
                                   optimization_level = 3)  
</code></pre>
<p>then upon executing the circuit, I will have an error message:</p>
<pre><code>Error is : The number of shots in the Qobj (20000) is higher than the number of shots supported by the device (8192). 
</code></pre>
<hr />
<p><strong>Is there a quick and elegant way to overcome this issue within Qiskit?</strong> Thank you!</p>
",<programming><qiskit><ibm-q-experience><vqe>,12/22/2020 19:20,15238.0,15238.0,"<p>According to my knowledge, 8192 is a maximum of shots. I think that the reason is fair timesharing as nowadays there are many users of IBM Q.</p>
<p>To get <em>better</em> results from VQE, I can only recommend to run your task several times and then pick up the best solution, i.e. the one wiht the lowest (highest) value of the optimized function.</p>
",12/23/2020 7:34,Errors,"The user is asking for help with a specific error they are encountering when running variational algorithms on IBM hardware with more than 8192 shots. The user has provided detailed information about the error they are receiving and the code they are using, which suggests that they are knowledgeable about Qiskit and are trying to debug a specific problem.",Tooling,"The user is asking about how to increase the number of shots in Qiskit when running on IBM hardware, which is a tool-related inquiry in the context of quantum programming.",No,101.0, Errors,"The user is asking for help with a specific error they are encountering when running variational algorithms on IBM hardware with more than 8192 shots. They have provided detailed information about the error they are receiving and the code they are using, indicating that they are seeking assistance to debug the issue."
15274.0,Shor's implementation problem on qiskit,"<ol>
<li><p>If <code>q4-7</code> are all supposed to be eigenstates of the operation, why is it just that <code>q7</code> is in <span class=""math-container"">$|1\rangle$</span>? Shouldn't all qubits 4 to 7 be in the <span class=""math-container"">$|1\rangle$</span> state to kick back phases from the <span class=""math-container"">$Rz$</span> gates applied?
<a href=""https://i.stack.imgur.com/uPbd9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uPbd9.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>I'm trying to see what's inside each of those controlled operations, and as observed below it's a bunch of swap gates. How do swap gates do any meaningful computation? How do they kickback an important phase? I was expecting same quantum gates applied on the eigenstate such that an important phase gets kicked up, so I don't see the point in swap gates.
<a href=""https://i.stack.imgur.com/Et6VV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Et6VV.png"" alt=""enter image description here"" /></a></p>
</li>
</ol>
",<programming><qiskit><shors-algorithm>,12/26/2020 4:33,15277.0,15277.0,"<p><strong>First question</strong></p>
<p>There are two implementation of Shor algorithm. The first one is depicted in this picture:</p>
<p><a href=""https://i.stack.imgur.com/nvKLX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nvKLX.png"" alt=""Shor 1"" /></a></p>
<p>In this case, a function <span class=""math-container"">$a^x \mod N$</span> is implemented in <span class=""math-container"">$U_f$</span> gate and you are trying to find period in such function.</p>
<p>Another implementation (yours one) uses phase estimation for finding the period. See thsis implementation on <a href=""https://en.wikipedia.org/wiki/Shor%27s_algorithm#Quantum_part:_period-finding_subroutine"" rel=""nofollow noreferrer"">Wiki</a> for example.</p>
<p>In the first case, all qubits are initialized to <span class=""math-container"">$|0\rangle$</span>. In second case as you can see in Wiki link, qubits used as input to an &quot;operator which phase is estimated&quot; are initialized at <span class=""math-container"">$|1\rangle$</span>. It seems that part of <span class=""math-container"">$X$</span> gates are included into controlled operators (<em>sorry I have not enought time to reconstruct the opeators</em>).</p>
<p><strong>Second question</strong></p>
<p>As the operators are <strong>controlled</strong> ones, <em>bottom</em> qubits are entangled with <em>top</em> qubits which allow phase kick-back. As a result, you are able to measure the phase on <em>top</em> qubits.</p>
<p>Concerning swap gate, even such gates are able to perform calculation. You can see <a href=""https://quantum-computing.ibm.com/docs/iqx/guide/shors-algorithm#quantum-circuits-for-modular-multiplication"" rel=""nofollow noreferrer"">here</a> how swap gates implement modular multiplication used in the Shor algorithm.</p>
",12/26/2020 9:04,Conceptual,"The user is asking about the conceptual understanding of quantum operations, specifically why certain qubits are in a specific state and the role of swap gates in quantum computation. This falls under the category of questions related to the conceptual understanding of quantum computing.",Conceptual,,,,Conceptual,
15275.0,How can I fix this parametrization error in Qiskit?,"<p>I'm trying to use the parametrized circuits to run a single model of quantum circuit with different values. Here's part of my code:</p>
<pre><code>from qiskit import IBMQ
provider = IBMQ.load_account()
sim = provider.backends.ibmq_qasm_simulator
backend = provider.get_backend('ibmq_qasm_simulator')

probsu = []
for i in range(L):

    circuit = circuit.assign_parameters({Ei: EWi[i]})
    circuit = qc(Ei) 
    
    job_manager = IBMQJobManager()
    **MExperiment = job_manager.run(circuit, backend=backend, name='MExperiment')**
    result = MExperiment.result()

    Ta = '1'*N
    counts = result.get_counts(circuit)
    if Ta in counts:
        prob = counts[Ta]/sum(counts.values())
    else:
        prob = 0
    probsu.append(prob) 
</code></pre>
<p>Where qc(Ei) is a function of the quantum circuit model. EWi is an array of possible parameters that will be used. An error occurred at the line marked with **. Here's what qiskit shows me:</p>
<pre><code>CircuitError: &quot;Cannot bind parameters (['Ei']) not present in the circuit.&quot;
</code></pre>
<p>I'm not exactly sureï¼ but it looks like parameterization requires the label 'Ei' to appear in the circuit. However, my circuit function takes the argument to accept some input like Ei. Is there a way I can fix this error? Thanks a lot for your help:)</p>
",<qiskit><programming><quantum-circuit>,12/26/2020 5:44,15276.0,15276.0,"<p>If you want to create a parametrized quantum circuit in Qiskit, you can do it as follow:</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from iqx import *
from qiskit.circuit import  ParameterVector
# Loading your IBM Q account(s)
provider = IBMQ.load_account()

param_circuit = QuantumCircuit(4)
params = ParameterVector('a', 4)
for i in range(4):
    param_circuit.ry(params[i], i)
param_circuit.cx(0,1)
param_circuit.cx(2,3)
param_circuit.cx(1,2)
param_circuit.cx(0,1)
param_circuit.cx(2,3)
param_circuit.draw('mpl',style={'name': 'bw'},  scale = 1)
</code></pre>
<p><a href=""https://i.stack.imgur.com/wDJsQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wDJsQ.png"" alt=""enter image description here"" /></a></p>
<p>You can pass the parameters in this circuit and update them through a classical optimizer etc.</p>
",12/26/2020 7:28,Errors,"The user is encountering a specific error in their code related to parameter binding in Qiskit. They are seeking help to resolve this error, which falls under the ""Errors"" category as they are looking for solutions and explanations related to an issue they are facing in their quantum programming code.",Errors ,,,,Errors,
15284.0,"How can I run a set of circuits, each of which has 100 shots?","<p>I'm running simulations of my quantum circuit, which includes both parametrized variables and random numbers. The question I'm trying to solve is that for each parameterized variable, I will generate a set of quantum circuits, each element of which contains different random numbers. I'm hoping to run each quantum circuit in the set with 100 shots, then carry out some analyses on the counts. I'm not exactly sure how I can do that, here's part of the code I have:</p>
<pre><code>from qiskit import IBMQ
provider = IBMQ.load_account()
sim = provider.backends.ibmq_qasm_simulator
backend = provider.get_backend('ibmq_qasm_simulator')

E = np.linspace(-5,5,10)                # Parameters
circuits = []
nuni = 10.                              # Number of the circuits in each set. 

for i in range(10):
    circuitsi = []
    for j in range (nuni):
        circuit =  QuantumCircuit(qrz,crz)
        circuit =  qc(E[i])             # qc is a function with both parameters and random numbers.
        circuitsi.append(circuit)
    circuits.append(circuitsi)

for i in range (len(circuits)):
    for j in range (nuni):
        circuits[i][j] = transpile(circuits[i][j],backend=backend)


for i in range (10):
    job_manager = IBMQJobManager()
    MExperiments = job_manager.run(circuits[i], backend=backend, shots = nshot)
    results = MExperiments.results()

    for j in range (nuni):
        
        counts = results.get_counts(circuits[i][j])
</code></pre>
<p>My current code doesn't quite work, I'm wondering am I on the right track? How can I fix my code? Thanks a lot for your help:)</p>
<p><strong>Update: My code works, but it takes a really long time to run. I'm still wondering if there's a simpler way to carry out the experiment? Thanks!</strong></p>
",<qiskit><programming>,12/26/2020 21:36,15297.0,15297.0,"<p>In your code, <code>circuits</code> is an array of array of quantum circuits and each element of <code>circuits</code> is an array of quantum circuits. In the code, you are using a for loop to run each element of the <code>circuits</code> array individually using the for loop. This runs each of the 10 array of circuits one after the other. However, you can run all the quantum circuits of all the arrays all at once. All you have to do is to construct an array say <code>all_circuits</code> and append all the quantum circuits of each of the <code>circuitsi</code>. Then you can run the simulation using this array of circuits. Once the results are out, you can then post process it to get an array of array of results. So the code after creating all the circuits will be more like the below:</p>
<pre><code>all_circuits = []
for i in range(10):
    all_circuits += circuits[i][:]

from qiskit.tools.monitor import job_monitor
qjob = execute(all_circuits,shots=shots,backend=backend)
job_monitor(qjob)
result = qjob.result()

counts = []
for i in range(10):
    count_i = []
    for j in range(nuni):
        count_i.append(result.get_counts(all_circuits[(nuni*i)+j]))
    counts.append(count_i)
</code></pre>
<p>Since you execute all the circuits at one, this would reduce the time of execution quite a lot.
Also, if you are using <code>execute</code>, you could also skip <code>transpile</code> since <code>transpile</code> will also be performed as a part of <code>execute</code>. This might not decrease the run time but might help in writing the code simpler. I hope this helps.</p>
",12/27/2020 10:45,Tooling ,"The question is asking how to implement a specific quantum computing experiment using Qiskit, a quantum computing framework",Tooling ,,,,Tooling ,
15285.0,How do Hadamard and CNOT gates work on Qiskit SDK? Why is the output reversed?,"<p>Here is the code that I have been using on IBM Q Experience (should be the latest version of Qiskit). From my understanding it seems like the outputs of Hadamard and CNOT gates are reversed in a 2-qubit system in Qiskit: A Hadamard gate operating on state 0 actually acts on state 1 and vice versa, similarly with a CNOT gate. Is there something wrong with my understanding? The comments in my code summarize the output results I find surprising.</p>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from iqx import *

from qiskit.quantum_info import Statevector

sv01 = Statevector.from_label('01')
print(sv01)
plot_state_qsphere(sv01.data)

h0circuit = QuantumCircuit(2)
h0circuit.h(0)
h0circuit.draw(&quot;mpl&quot;)

final01 = sv01.evolve(h0circuit)
print(final01)
plot_state_qsphere(final01.data)
#Shouldn't the output be state 1/sqrt(2) (|01&gt; + |11&gt;)  ???? 
#And why is the phase on the state |00&gt; pi? 
#Shouldn't the phase be pi for |01&gt; instead on the qsphere (ambiguous, probably doesn't matter)?

h1circuit = QuantumCircuit(2)
h1circuit.h(1)
h1circuit.draw(&quot;mpl&quot;)

final01 = sv01.evolve(h1circuit)
print(final01)
plot_state_qsphere(final01.data)
#Shouldn't the output be state 1/sqrt(2) (|00&gt; - |01&gt;)  ???? 

#Conclusion of the above. An H gate on qubit 0 seems to apply to qubit 1. An H gate on qubit 1 seems to apply to qubit 0.

sv01 = Statevector.from_label('01')
print(sv01)
plot_state_qsphere(sv01.data)

c0xCircuit = QuantumCircuit(2)
c0xCircuit.cx(0,1)
c0xCircuit.draw('mpl')

final01 = sv01.evolve(c0xCircuit)
print(final01)
plot_state_qsphere(final01.data)
#Shouldn't this result be  |01&gt; ?

c1xCircuit = QuantumCircuit(2)
c1xCircuit.cx(1,0)
c1xCircuit.draw('mpl')

final01 = sv01.evolve(c1xCircuit)
print(final01)
plot_state_qsphere(final01.data)
#Shouldn't this result be  |11&gt; ?

#Conclusion of the above. The cnot (0,1) gate actually acts as a cnot (1,0) gate. The cnot (1,0) gate actually 
#acts as a cnot (0,1) gate. The states 0 and 1 are flipped somehow.
<span class=""math-container"">```</span>
</code></pre>
",<quantum-gate><programming><qiskit>,12/26/2020 22:13,15287.0,15287.0,"<p>This has to do with Qiskit uses  little-endian for  ordering. In Qiskitâs convention, higher qubit indices are more significant (little endian convention).</p>
<p>Thus the CNOT (CX)  gate matrix representation in Qiskit is actually:</p>
<p><span class=""math-container"">$$
        CX\ q_0, q_1 =
            I \otimes |0\rangle\langle0| + X \otimes |1\rangle\langle1| =
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 1 \\
                0 &amp; 0 &amp; 1 &amp; 0 \\
                0 &amp; 1 &amp; 0 &amp; 0
            \end{pmatrix}
$$</span></p>
<p>Here is the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.CXGate.html#qiskit.circuit.library.CXGate"" rel=""nofollow noreferrer"">link to the Qiskit's documentation.</a></p>
",12/27/2020 0:30,Errors,The user is encountering an issue with their Qiskit code where the outputs of Hadamard and CNOT gates are reversed in a 2-qubit system. This falls under the Errors category,Errors,,,,Errors,
15323.0,Qiskit PauliWeightedOperator in the matrix representation?,"<p>Suppose we have a <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.legacy.WeightedPauliOperator.html#qiskit.aqua.operators.legacy.WeightedPauliOperator"" rel=""nofollow noreferrer"">PauliWeightedOperator</a> object from Qiskit. Is there any built-in method to convert it to the matrix representation in the computational basis? My search in the docs was not successful.</p>
",<programming><qiskit><quantum-operation><matrix-representation><pauli-gates>,12/29/2020 21:10,15373.0,15373.0,"<p>I think this is what you are looking for:</p>
<pre><code>from qiskit.aqua.operators import WeightedPauliOperator
import numpy as np

pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: -1.0, &quot;real&quot;: 1.0 }, &quot;label&quot;: &quot;XX&quot;}
                         ]}
operator = WeightedPauliOperator.from_dict(pauli_dict)

Op = operator.to_opflow()
MatrixOp = Op.to_matrix()
MatrixRepresentation = np.real(MatrixOp)
print(MatrixRepresentation)
</code></pre>
<p>The output would be:</p>
<pre><code>array([[0., 0., 0., 1.],
       [0., 0., 1., 0.],
       [0., 1., 0., 0.],
       [1., 0., 0., 0.]])
</code></pre>
",01/02/2021 04:38, API Usage,The user is inquiring about whether there is a built-in method in Qiskit to convert a PauliWeightedOperator object to its matrix representation in the computational basis. This falls under the category of discussing the usage of APIs and functions within Qiskit., API Usage,,,, API Usage,
15364.0,Qiskit Controlled S and Controlled T Gates,"<p>I was implementing controlled S and T gates in qiskit and was wondering if there is any difference between using the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.CU1Gate.html"" rel=""nofollow noreferrer""><code>cu1</code></a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.CRZGate.html"" rel=""nofollow noreferrer""><code>crz</code></a> gates for this purpose. Qiskit doesn't seem to include explicit versions of these two gates.</p>
<pre><code>circuit = qiskit.QuantumCircuit(2)
# a)
circuit.crz(theta=math.pi/2, control_qubit=0, target_qubit=1)
# b)
circuit.cu1(theta=math.pi/2, control_qubit=0, target_qubit=1)
</code></pre>
<p>In terms of the unitary the <code>cu1</code> gate seems closer to what one would want, I would assume. Are there any other consequences I should be aware of?</p>
",<quantum-gate><programming><qiskit>,01/01/2021 16:00,15365.0,15365.0,"<p>In Qiskit you can get the controlled version of any gate with the method <code>control</code>.
For S and T, here is the example:</p>
<pre><code>from qiskit.circuit.library.standard_gates import SGate, TGate

csgate = SGate().control(1) # the parameter is the amount of control points you want
ctgate = TGate().control(1)

circuit = QuantumCircuit(2)
circuit.append(csgate, [0, 1])
circuit.append(ctgate, [0, 1])
print(circuit)
</code></pre>
<pre><code>q_0: âââ âââââ ââ
     âââ´âââââ´ââ
q_1: â¤ S ââ¤ T â
     ââââââââââ
</code></pre>
<p>If you want to compare these gates with <code>cu1</code> or <code>crz</code>, you can use the <code>Operator</code> class:</p>
<pre><code>from qiskit.circuit.library.standard_gates import CRZGate, CU1Gate
from math import pi

from qiskit.quantum_info import Operator
print(Operator(CU1Gate(pi/2)) == Operator(csgate))
print(Operator(CRZGate(pi/4)) == Operator(ctgate))
</code></pre>
<pre><code>True
False
</code></pre>
",01/01/2021 18:11,API Usage,"The user is asking about the difference between using specific gates (cu1 and crz) for controlled S and T gates in Qiskit, which relates to the usage of these API components in quantum circuit construction.",API Usage,,,,API Usage,
15434.0,Issue with Speed of Qiskit Arbitrary Initialization,"<p>I've been using a circuit that needs a specific initialization in the beginning, and to do so I've been using qc.initialize() as mentioned in previously asked similar questions (<a href=""https://quantumcomputing.stackexchange.com/questions/13529/how-can-i-create-an-arbitrary-superposition-state-of-two-qubits-in-qiskit"">How can I create an arbitrary superposition state of two qubits in Qiskit?</a>).</p>
<p>However, I've noticed that even when using qc.initialize() to initialize some very simple states (|000&gt;, etc.) it takes roughtly 3-4 seconds to just execute the circuit (something that would only take ~0.2 sec if I just start the circuit at |000&gt; without qc.initialize()). The time for me is important because I need to execute the circuit many times (different than shots, each time I execute, the circuit is modified slightly). Regardless, the extra 3-4 seconds seems abnormal, because even when I use qc.initialize() on even just one qubit in the circuit, it still takes the extra 3 seconds to execute.</p>
<p>One property about the initialization I need for the circuit is that its kind of &quot;sparse&quot;. With n qubits, my initial state is only built with a linear combination of ~2n basis vectors (as opposed to <span class=""math-container"">$2^n$</span>).</p>
<p>Given this is there some known algorithm or workaround to make an arbitrary initialization that avoids qc.initialize()? Perhaps is there some way other way through Qiskit I can use?</p>
",<programming><qiskit><algorithm>,01/06/2021 21:27,15435.0,15435.0,"<p>I noticed something about Qiskit initialize functionality, it doesn't always find the best possible circuit to prepare the state. For instance, if I want to put the state into uniform superposition state, <span class=""math-container"">$|\psi \rangle = \dfrac{|00\rangle + |01\rangle + |10\rangle + |11\rangle }{4}$</span> by specifying the following:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute
provider = IBMQ.load_account()
qc = QuantumCircuit(2,2)
vector = [0.5, 0.5, 0.5, 0.5]
qc.initialize(vector, [0,1])
qc.x(0)
qc.measure(range(2), range(2))
qc.draw('mpl', style = {'name': 'bw'}, scale = 0.75, initial_state = False,plot_barriers = True) 
</code></pre>
<p>The output is something like:</p>
<pre><code>     ââââââââââââââââââââââââââââââââââââââââ
q_0: â¤0                             ââ¤ X ââ¤Mâ
     â  initialize(0.5,0.5,0.5,0.5) âââ¬ââ¬âââ¥â
q_1: â¤1                             âââ¤Mââââ«â
     ââââââââââââââââââââââââââââââââ ââ¥â  â 
c: 2/âââââââââââââââââââââââââââââââââââ©ââââ©â
                                       1   0 
</code></pre>
<p>Now if you this on one of the machine, and look at the circuit being submitted then you can see that it does it not in a very efficient way. For instance, I submitted the above circuit to a hardware, and the circuit below is what being submitted:</p>
<p><a href=""https://i.stack.imgur.com/bFNXh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bFNXh.png"" alt=""enter image description here"" /></a></p>
<p>So instead of preparing the initial state <strong>by simply apply two Hadamard gate to each qubit individually</strong>,
<a href=""https://i.stack.imgur.com/JZ0TU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JZ0TU.png"" alt=""enter image description here"" /></a></p>
<p>it actually doing something else that is equivalent but less efficient. This might be the reason you see longer experiment time as well.</p>
<hr />
<p>If you tried this for 3 qubits, that is, if you want to create a uniform superposition state for 3 qubits, then you will get something even worst... That is if you tried to submit this circuit:</p>
<pre><code>Â«     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«q_0: â¤0                                                                             âÂ»
Â«     â                                                                              âÂ»
Â«q_1: â¤1 initialize(0.35355,0.35355,0.35355,0.35355,0.35355,0.35355,0.35355,0.35355) âÂ»
Â«     â                                                                              âÂ»
Â«q_2: â¤2                                                                             âÂ»
Â«     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«c: 3/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«                                                                                     Â»
Â«     âââââ   âââ
Â«q_0: â¤ X âââââ¤Mâ
Â«     ââ¬ââ¬â   ââ¥â
Â«q_1: ââ¤Mâââââââ«â
Â«      ââ¥â âââ â 
Â«q_2: âââ«âââ¤Mâââ«â
Â«       â  ââ¥â â 
Â«c: 3/âââ©ââââ©âââ©â
Â«       1   2  0
</code></pre>
<p>which is can simply being done as:
<a href=""https://i.stack.imgur.com/IUxwf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IUxwf.png"" alt=""enter image description here"" /></a></p>
<p>But instead what being submitted to the hardware is:</p>
<p><a href=""https://i.stack.imgur.com/staQG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/staQG.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>This is probably just because the stochastic part of the transpiler within Qiskit. So it might be better than you design a function that make the circuit more efficient yourself. This issue is the same if one tried to use the <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.components.initial_states.Custom.html"" rel=""nofollow noreferrer""><code>Custom</code> function</a>... If you tried to specified a custom vector here, like what we did above, it will also prepare that initial state in a very convoluted way that is not always efficient.</p>
<p>I think Qiskit uses technique from this paper: <a href=""https://arxiv.org/pdf/1501.06911.pdf"" rel=""nofollow noreferrer"">Quantum Circuits for Isometries</a> to create the circuit for an arbitrary state that you gave it.</p>
<hr />
<h1><strong>Update:</strong></h1>
<p>For the two qubit case, funny enough, I just check Qiskit and they actually have recently changed their <strong>native gates</strong> on their device! So that, it used to be <span class=""math-container"">$U_1, U_2, U_3, CNOT$</span>, but now it is <span class=""math-container"">$CNOT, ID, RZ, SX, X$</span> and so what you saw on the circuit <span class=""math-container"">$RZ(\pi/2) \ S_X \ RZ(\pi/2)$</span> is actually the native level implementation of the Hadamard gate now!</p>
",01/06/2021 23:28,Tooling ,"The users question is about the performance of a specific function (qc.initialize()) in Qiskit and is seeking an alternative method for initializing quantum circuits, which falls under the usage of tools in quantum programming.",Tooling,,,,Tooling ,
15436.0,How to decompose/unroll a Qiskit Arbitrary initialization,"<p>I'm aware that to randomly initialize a quantum circuit with Qiskit, we can simply write qc.initialize(rand_state, q[0]...). However, when drawing the circuit, I see that the &quot;initialize&quot; function is treated as one big gate that takes in an input and outputs the initialized state.</p>
<p><a href=""https://i.stack.imgur.com/DkFiF.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/DkFiF.png"" alt=""enter image description here"" /></a></p>
<p>Is there a way to decompose this &quot;initialization gate&quot; through python/Qiskit and run a circuit that is composed of the individual smaller gates that actually make up this large gate?</p>
",<programming><qiskit><algorithm>,01/07/2021 02:11,15439.0,15439.0,"<p>In your example you can do</p>
<pre><code>qc.decompose().draw()
</code></pre>
<p>The method <code>decompose</code> decomposes every gate in the circuit. This will do a single level. If you want to do another level of decomposition, call the method again.</p>
<pre><code>qc.decompose().decompose().draw()
</code></pre>
",01/07/2021 06:41, Conceptual,"The user is inquiring about the decomposition of the quantum circuit generated by the initialize function in Qiskit. They want to understand if it's possible to decompose this gate into smaller gates, which pertains to the conceptual understanding of quantum circuit initialization and decomposition in Qiskit.", Conceptual,,,, Conceptual,
15462.0,Quantum PRGN against Hard disk Forensics,"<p>We can make use of the Qbit to make a random string of bytes then as I have an office laptop and I can do some espionage by copying the files to my local disk from the network share and upload it to some online board.</p>
<p>It Leaves a shadow file if I choose to delete it and or encrypt the file. If forensics is performed then that file can be retrieved in its entirity( best case), partially(most cases), encrypted entirety( rarely), or a sign that the file was attempted to be shredded and implementation may vary from OS to OS and File system to file system.</p>
<p>My proposal is that we expose an online service where we input the remaining size of our harddisk, let's suppose I have a disk size of 2TB and 1.5TB is remaining so I shall download a file with Quantum random numbers of size 1.5TB hence overriding all the memory cell even if the disk firmware is ware balanced it will not be able to preserve the fragments of the previously deleted files as we are filling all the leftover disk space with random quantum numbers.</p>
",<programming><random-quantum-circuit>,01/10/2021 04:12,15482.0,15482.0,"<p>To erase a HDD with a random numbers generated by quantum computer is in theory possible. Lets imagine you want to generate bit strings of length <span class=""math-container"">$n$</span>, then you can simply put Hadamard gates on <span class=""math-container"">$n$</span> qubits. Such simple circuit prepares equal superposition of all <span class=""math-container"">$n$</span> bit long strings. When you put measurement after the Hadamard gates and run the circuit on a quantum computer you will get a random bit string coming from uniform distribution.</p>
<p>However, nowadays there are two main obstacles:</p>
<ol>
<li><p>A small number of qubits in current quantum processors (as far as I know, IBM offers 63 qubit processor). But this can be easily overcame but producing higher number of shorter bitstrings.</p>
</li>
<li><p>Most importantly, you would need to run your circuit many times to produce 1.5 TB of random bits. Since 1.5 TB = 12 Tb and suppose that you are able to produce at 63 bits long stings (on the IBM computer I mentioned above), this will take 190 million of runs. This is possible, however, I do not think that IBM would allow such load of their systems now.</p>
</li>
</ol>
<p><strong>To conclude, yes it is possible but because of small capacity of current quantum computer it is difficult to do so.</strong></p>
<p><em>Just suggestion: try to use some physical generator of random numbers. They are based on measuring thermal noise. Produced random numbers are really random as in case of quantum computer. No algorithms like linear congruential generator is used.</em></p>
",01/11/2021 08:32,Tooling ,"The user is discussing the use of a quantum computing tool (Qbit) to generate a random string of bytes for a specific application, which aligns with the Tooling category",Tooling ,,,,Tooling ,
15464.0,Job fails when using PulseSimulator: Job Status: job incurred error,"<p>I'm trying to simulate a basic circuit using the <code>PulseSimulator</code> in Qiskit. The following Qiskit Pulse code works when I run it on the real device, but not when using the <code>PulseSimulator</code>.  The job monitor tells me <code>Job Status: job incurred error</code> and nothing else.</p>
<p>Trying to run any gates native to the device causes an issue. If I remove <code>schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi)</code> then it runs fine, but I can't figure out what I'm doing wrong. I'd deeply appreciate any support. I'm using <code>qiskit 0.23.2</code></p>
<pre><code>#Essential Imports 
import numpy as np
# Qiskit Imports
from qiskit.providers.aer import PulseSimulator
from qiskit import IBMQ, assemble
from qiskit.tools.monitor import job_monitor
import qiskit.pulse as pulse

# Connect to an IBMQ Account and Backend
API_TOKEN = ''
IBMQ.save_account(API_TOKEN, overwrite=True)
IBMQ.load_account()
provider = IBMQ.get_provider()
backend = provider.get_backend(&quot;ibmq_armonk&quot;)
backend_pulse_simulator = PulseSimulator.from_backend(backend) #backend

# Get information about the backend
qubit = 0
backend_defaults = backend.defaults()
backend_properties = backend.properties()
qubit_frequency_updated = backend_properties.qubit_property(qubit, 'frequency')[0]
inst_sched_map = backend_defaults.instruction_schedule_map
measure_schedule = inst_sched_map.get('measure', qubits=[qubit])

# Assemble a job - circuit with a single qubit-&gt; u2 gate -&gt; measurement
num_shots_per_point = 1024
drive_chan = pulse.DriveChannel(qubit)
schedule = pulse.Schedule()
schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi) # Removing this solves the issue - why?
schedule += measure_schedule &lt;&lt; schedule.duration               
pulse_program = assemble(schedule, 
                        backend=backend_pulse_simulator, 
                        meas_level=2, meas_return=&quot;single&quot;,
                        shots=num_shots_per_point,
                        schedule_los=[{drive_chan: qubit_frequency_updated}])

# Run the job
job = backend_pulse_simulator.run(pulse_program)
job_monitor(job)
</code></pre>
",<programming><qiskit><simulation><openpulse>,01/10/2021 05:04,15487.0,15487.0,"<p>The <code>Job Status: job incurred error</code> with pulse can be the result of a timing problem in the execution of different pulses, but in your code the <code>PulseSimulator()</code> class must get backends provided by Terra such as <code>FakeArmonk()</code>, <code>FakeParis()</code>..etc. For example:</p>
<pre><code>from qiskit.test.mock import FakeArmonk
backend=FakeArmonk()
backend_pulse_simulator = PulseSimulator.from_backend(backend) # using FakeArmonk() backend
print(type(backend_pulse_simulator))
</code></pre>
<p>The <code>FakeBackends()</code> have the properties of the IBM Quantum devices data and are stored in  Qiskit Terra.</p>
<p>Another way is to specify a <code>PulseSystemModel()</code> from a real backend and pass the system model to the execution method. Below is an example with <code>ibmq_armonk</code>.</p>
<pre><code>from qiskit.providers.aer.pulse import PulseSystemModel
from qiskit.providers.aer import PulseSimulator

armonk_backend= provider.get_backend(&quot;ibmq_armonk&quot;)
armonk_model = PulseSystemModel.from_backend(armonk_backend)
backend_pulse_simulator=PulseSimulator()
job = backend_pulse_simulator.run(pulse_program, armonk_model)
</code></pre>
<p>hope this helps</p>
<p>Patrick</p>
",01/11/2021 14:55,Errors,"The user is encountering an issue where their Qiskit Pulse code works on a real device but not when using the PulseSimulator. They are seeking solutions and explanations for this error, which falls under the ""Errors"" category in quantum program development.",Errors,,,,Errors,
15465.0,Source code for graphsim,"<p>The source code for the graph state simulator from <a href=""https://arxiv.org/abs/quant-ph/0504117"" rel=""nofollow noreferrer"">&quot;Fast simulation of stabilizer circuits using a graph state representation&quot;</a> is supposed to be at <a href=""http://homepage.uibk.ac.at/homepage/c705/c705213/work/graphsim.html"" rel=""nofollow noreferrer"">http://homepage.uibk.ac.at/homepage/c705/c705213/work/graphsim.html</a> but the link is dead and the WayBack machine did not archive it.</p>
<p>Does anyone know where another copy can be found?</p>
",<programming><resource-request>,01/10/2021 09:26,15466.0,15466.0,"<p>There appears to be a copy on GitHub at <a href=""https://github.com/marcusps/GraphSim"" rel=""nofollow noreferrer"">https://github.com/marcusps/GraphSim</a></p>
",01/10/2021 09:29, Learning,"The user is seeking access to the source code for a specific quantum simulator mentioned in a research paper. They are looking for resources or copies of the code, which falls under the ""Learning"" category", Learning,,,, Learning,
15475.0,A problem with application of multi controlled rotation gates,"<p>This message pops up when I run an mcrx gate</p>
<p><code>The mcrx gate needs a single qubit as target.</code></p>
<p>Here is a part of code I run:</p>
<pre><code>QC.mcrx(np.pi,[0,1,2],3)
   QC.draw('mpl')
</code></pre>
<p>'<a href=""https://i.stack.imgur.com/FleZX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FleZX.png"" alt=""code with error"" /></a></p>
",<quantum-gate><programming><qiskit>,01/11/2021 07:21,15478.0,15478.0,"<p>Here is a way to implement multi-controlled RX gate if you interested:</p>
<pre><code>from qiskit import QuantumCircuit,QuantumRegister
from qiskit.circuit.library.standard_gates import RXGate
from qiskit.circuit import Parameter
import matplotlib.pyplot as plt
qr=QuantumRegister(4)
circ=QuantumCircuit(qr)
a=Parameter('a') # You can replace a with pi here 
CCCRX=RXGate(a).control(3)
circ.append(CCCRX,qr)
print(circ)
</code></pre>
<p>Which output:</p>
<pre><code>                
q0: âââââ ââââ
        â    
q1: âââââ ââââ
        â    
q2: âââââ ââââ
    âââââ´ââââ
q3: â¤ RX(a) â
    âââââââââ
</code></pre>
<p>You can decompose this circuit to looks what is being implement underneath by executing the line of code: <code>circ.decompose().draw() </code> which will output:</p>
<p><a href=""https://i.stack.imgur.com/AHKc5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AHKc5.png"" alt=""enter image description here"" /></a></p>
<br> 
<hr />
<p>If you absolutely want to use <strong><code>mcrx</code> method</strong> then this should do it:</p>
<pre><code>from qiskit.circuit.library.standard_gates import mcrx
import numpy as np
qr= QuantumRegister(4)
circ=QuantumCircuit(qr)
circ.mcrx(np.pi,[ qr[0], qr[1], qr[2] ],qr[3])
</code></pre>
<p>note that if I decompose this circuit (like we did earlier), I will get the exact same circuit as the decomposed circuit on top (by replacing 'a' with <code>pi</code> to the top circuit):</p>
<p><a href=""https://i.stack.imgur.com/a8ewv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a8ewv.png"" alt=""enter image description here"" /></a></p>
",01/11/2021 07:45,Errors,"The user is encountering an error message when trying to run a quantum computing program using the mcrx gate, and is seeking help to resolve it. ",Errors,,,,Errors,
15489.0,How to deal with job submission error in IBM?,"<p>I keep on getting this error no matter how many circuits I run in the backend 'ibmq_athens'. It says 'Max retries exceeded with URL'. Can someone explain why I am getting this error message.</p>
<p>The main error message is as follows:</p>
<p>IBMQBackendApiError: 'Error submitting job: 'HTTPSConnectionPool(host=\'s3.us-east.cloud-object-storage.appdomain.cloud\', port=443): Max retries exceeded with url: /us-east-quantum-computing-user-jobs-prod/qObject-5ffc48c0c3d09157546c8092.json?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=21ce861c64cc417e9a95f95263ecf8f7%2F20210111%2Fus-east%2Fs3%2Faws4_request&amp;X-Amz-Date=20210111T124657Z&amp;X-Amz-Expires=604800&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=6715779f30e144ac7e6e1f8ae316960473e57b251c6360b02d881fb8e9a47333 (Caused by SSLError(SSLError(&quot;bad handshake: SysCallError(60, \'ETIMEDOUT\')&quot;)))''</p>
",<programming><qiskit><circuit-construction><ibm-q-experience><ibm>,01/11/2021 23:15,15493.0,15493.0,"<p>This is duplicate of <a href=""https://quantumcomputing.stackexchange.com/questions/14824/error-while-trying-to-execute-the-quantum-circuits-in-ibmq"">Error while trying to execute the Quantum Circuits in IBMQ</a> . It's caused by your ISP blocking IBM Cloud object storage URL (used by IBM Q).</p>
<p>My answer from the other post:</p>
<p>This is caused by <code>safebrowse.io</code> blocking the url and sending back a http response (which the client interpreted as a TLS version it didn't understand). Unfortunately safebrowse.io doesn't allow whitelisting a single url, so you'll need to disable it entirely. Hereâs a link on how to do it: <a href=""https://howtoremove.guide/safebrowse-io-virus/#:%7E:text=What%20is%20Safebrowse.io%3F,compromise%20their%20system%20and%20privacy"" rel=""nofollow noreferrer"">https://howtoremove.guide/safebrowse-io-virus/#:~:text=What%20is%20Safebrowse.io%3F,compromise%20their%20system%20and%20privacy</a></p>
",01/12/2021 13:37,Errors,"The user is encountering an error message related to exceeding maximum retries when trying to run quantum circuits on the ibmq_athens backend, and is seeking help to understand and resolve this issue.",Errors,,,,Errors,
15491.0,Qubit ordering in qiskit,"<p>I am confused about the qubit ordering in circuit diagrams and endianness used in qiskit. As far as I understand, qiskit uses little endian (least significant qubit is rightmost) and while drawing circuits, qiskit plots least siginificant qubit at the top. So, we have the following table:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>qubits</th>
<th>decimal representaion</th>
<th>ckt</th>
<th>statevector</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$|00\rangle$</span></td>
<td><span class=""math-container"">$|0\rangle$</span></td>
<td><a href=""https://i.stack.imgur.com/kUwaA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kUwaA.png"" alt=""00_code"" /></a></td>
<td>[1 0 0 0]</td>
</tr>
<tr>
<td><span class=""math-container"">$|01\rangle$</span></td>
<td><span class=""math-container"">$|1\rangle$</span></td>
<td><a href=""https://i.stack.imgur.com/VMEKJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VMEKJ.png"" alt=""01_code"" /></a></td>
<td>[0 1 0 0]</td>
</tr>
<tr>
<td><span class=""math-container"">$|10\rangle$</span></td>
<td><span class=""math-container"">$|2\rangle$</span></td>
<td><a href=""https://i.stack.imgur.com/KnnE5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KnnE5.png"" alt=""10_code"" /></a></td>
<td>[0 0 1 0]</td>
</tr>
<tr>
<td><span class=""math-container"">$|11\rangle$</span></td>
<td><span class=""math-container"">$|3\rangle$</span></td>
<td><a href=""https://i.stack.imgur.com/tIjpu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tIjpu.png"" alt=""11_code"" /></a></td>
<td>[0 0 0 1]</td>
</tr>
</tbody>
</table>
</div>
<p>But, when I use QFT on the 2 qubit state <span class=""math-container"">$|10\rangle(i.e.|2\rangle)$</span>, the result I expect is <span class=""math-container"">$\frac{1}{2}\Sigma_{y=0}^{3}exp(\frac{2\pi j*2y}{4})|y\rangle = \frac{1}{2}(|0\rangle - |1\rangle + |2\rangle - |3\rangle)$</span> i.e. statevector [0.5,-0.5,0.5,-0.5], however the following code:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import QFT
from qiskit import Aer,execute

qc2 = QuantumCircuit(2)
qc2.x(1)
# prepare the state |10&gt;

two_qbit_QFT_ckt = QFT(2)
qft_ckt_2 = qc2+two_qbit_QFT_ckt
# apply QFT on the state |10&gt;

state_backend = Aer.get_backend('statevector_simulator')
qft_res_2 = execute(qft_ckt_2,state_backend).result().get_statevector()
print(qft_res_2)
</code></pre>
<p>outputs [0.5,-0.5,0.5j,-0.5j]. I believe there is some qubit ordering problem that I am not getting right, but I can't figure out what it is. I have also seen the following two questions, but they didn't help much.<br />
Q1: <a href=""https://quantumcomputing.stackexchange.com/q/8244/12465"">Big Endian vs. Little Endian in Qiskit</a><br />
Q2: <a href=""https://quantumcomputing.stackexchange.com/q/10174/12465"">qiskit: IQFT acting on subsystem of reversed-ordered qubits state</a></p>
<p>Can you please help me find the problem?</p>
",<programming><qiskit><quantum-fourier-transform>,01/12/2021 10:59,15503.0,15503.0,"<p>I looked at what you pointed out and I think I figured it out. So if you look at the general form of the circuit for the QFT you have this (from <a href=""http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf"" rel=""nofollow noreferrer"">this book</a> )
<a href=""https://i.stack.imgur.com/fRi6p.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fRi6p.png"" alt="""" /></a>and if you compare with the circuit from the QFT class in Qiskit, you notice they are the same. However, if you look at the implementation they do <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html#8.-Qiskit-Implementation"" rel=""nofollow noreferrer"">here</a>, notice they say Â«Â Note: Remember that Qiskit's least significant bit has the lowest index (0), thus the circuit will be mirrored through the horizontal in relation to the image in section 5.Â Â» and then they build the mirror of what we have in the first picture.</p>
<p>This seems to be a known issue since it has been pointed out <a href=""https://github.com/Qiskit/qiskit-terra/pull/4849"" rel=""nofollow noreferrer"">here</a>, but in the meantime I found two workarounds. The first one is to use the implementation they create in the Qiskit textbook, just take their functions and you have the QFT working with the little endian. The second one is to still use the QFT class but with some tricks. For example with the code you put:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import QFT
from qiskit import Aer,execute

qc2 = QuantumCircuit(2)
qc2.x(1)
# prepare the state |10&gt;

two_qbit_QFT_ckt = QFT(2,do_swaps=False,inverse=True) #here are the changes
qft_ckt_2 = qc2+two_qbit_QFT_ckt
rev_qft_ckt_2 = qft_ckt_2.reverse_bits() #same as putting swaps in the end of the circuit
# apply QFT on the state |10&gt;

state_backend = Aer.get_backend('statevector_simulator')
qft_res_2 = execute(rev_qft_ckt_2,state_backend).result().get_statevector()
print(qft_res_2)
</code></pre>
<p>You take the inverse QFT without the swaps, giving actually the right QFT with the Qiskit notations, then add yourself the swaps in the end by reversing the qubits, and it gives you the result you want :</p>
<pre><code>[ 0.5-6.123234e-17j -0.5+6.123234e-17j  0.5-6.123234e-17j
 -0.5+6.123234e-17j]
</code></pre>
<p>I hope this will help you, if you need anything else feel free to ask! :)</p>
",1/13/2021 9:48,Errors ,The user is encountering an unexpected output when running a quantum circuit using Qiskits QFT function and is seeking help to understand and resolve this issue.,Errors ,,,,Errors ,
15505.0,how to plot probability histogram and/or bloch sphere of single qubit in multi-qubit quantum circuit in Qiskit?,"<p>How can I get statevector and/or blochsphere representation of qubits of my choice. For example I have 3 qubits with different gates being applied on each qubit. the qiskit state_vector simulator gives bloch sphere representation of states for all qubits in the circuit and qasm simulator also plots histogram of probability for all qubits in the circuit. How can I get the single, for instance, second qubit's probability histogram and/or bloch sphere representation?</p>
<p>Secondly, can we use 15 qubits for simulation and plot probability histogram and/or bloch sphere or two qubits only, because qiskit is giving memory error since it takes the whole circuit for plotting.
Thanks</p>
",<programming><qiskit><bloch-sphere><quantum-circuit>,1/13/2021 10:46,15514.0,15514.0,"<p>For the statevector, I do not think there is an official way to print out only the statevector of a single or multiple qubits in a circuit. You can probably do it by parsing through the statevector that is returned for the whole circuit, and doing some math based on the statevector returned and the state the qubit(s) is in for each state in the statevector.</p>
<p>For the probability though, it is much easier to do this.</p>
<h3>Plotting probability of specific qubits</h3>
<p>If you only care about the probability of certain qubits, and will not need the probability for the others, you can set up the circuit to only measure the qubits you care about:</p>
<pre><code>qc = QuantumCircuit(15, 2)
qc.x(0)

# This will only measure qubit 0 and qubit 5
qc.measure([0, 5], [0, 1])

state_sim = Aer.get_backend(&quot;qasm_simulator&quot;)
job = execute(qc, sim)
counts = job.result().get_counts(qc)

print(counts)
'''
Output:
{'01': 1024}
Right qubit is qubit 0, left qubit is qubit 5. 
You can then call plot_histogram on counts.
'''
</code></pre>
<p>If you want to measure the whole circuit but then want to view the probability of only a single qubit, you can parse through the <code>counts</code> dictionary to retrieve the data for only the qubit you care about:</p>
<pre><code>qc = QuantumCircuit(3, 3)
qc.h(range(3))
qc.measure(range(3), range(3))

state_sim = Aer.get_backend(&quot;qasm_simulator&quot;)
job = execute(qc, sim)
counts = job.result().get_counts(qc)

print(counts)

'''
Output
{
'000': 127, '001': 127, '010': 133, '011': 108, 
'100': 115, '101': 146, '110': 132, '111': 136
}
'''

# New dictionary to store out results in.
new_counts = {'0': 0,
              '1': 0}

# The qubit we want the probability for
show_qubit = 1

# Loop through the counts dictionary, adding the value to the 
#  respective key in new_counts based on what state the show_qubit is in
for count in counts:
    count_idx = (len(count) - 1) - show_qubit
    new_counts[count[count_idx]] = new_counts[count[count_idx]] + counts[count]

print(new_counts)
plot_histogram(new_counts)

'''
Output:
{'0': 515, '1': 509}
~Histogram picture below~
'''
</code></pre>
<p><a href=""https://i.stack.imgur.com/zp0TP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zp0TP.png"" alt=""enter image description here"" /></a></p>
<p>If you want to view the probability of multiple qubits in this way, it is possible, but you will need to edit the loop and new_dictionary a bit to allow for multiple qubits.</p>
<h3></h3>
",1/13/2021 18:30, Tooling,"The user is inquiring about how to obtain specific information (statevector and Bloch sphere representation) for individual qubits in a quantum circuit using Qiskit. Additionally, the user is seeking guidance on handling memory errors when simulating circuits with a large number of qubits. This falls under the ""Tooling"" category as it relates to the usage of tools and software (Qiskit) for quantum programming.", Tooling,,,, Tooling,
15519.0,An issue in plotting the quantum circuit using latex,"<p>Here's the code I'm working on:</p>
<pre><code>!pip install pylatexenc
!pip install pillow

qc = QuantumCircuit(2)
qc.x(0)
qc.cz(0,1)
qc.x(0)
qc.draw('latex')
</code></pre>
<p>However there's an error:</p>
<pre><code>FileNotFoundError: [Errno 2] No such file or directory: 'pdflatex': 'pdflatex'
</code></pre>
<p>What should I do to make it work? Thanks!!</p>
",<programming><qiskit><quantum-circuit>,1/14/2021 4:10,15521.0,15521.0,"<p>It seems like you forgot to install a <span class=""math-container"">$\LaTeX$</span> processor.</p>
<p>To solve the issue, install any <span class=""math-container"">$\LaTeX$</span> distribution. Below are the two main ones that can be installed both on Windows and Linux:</p>
<ul>
<li><a href=""https://www.tug.org/texlive/"" rel=""nofollow noreferrer"">https://www.tug.org/texlive/</a></li>
<li><a href=""https://miktex.org/"" rel=""nofollow noreferrer"">https://miktex.org/</a></li>
</ul>
",1/14/2021 10:23,Errors ,The user is encountering a FileNotFoundError when trying to run a quantum circuit using Qiskit and is seeking help to resolve this issue. This falls under the Errors category ,Errors ,,,,Errors ,
15536.0,Can I access device specifications of IBMQ paying devices?,"<p>I need to perform some tests for my thesis in real quantum computers, however, I only have access to IBM's free quantum devices (the maximum number of qubits I can use is 15, in <code>ibmq_16_melbourne</code>). I mainly have two problems:</p>
<ol>
<li><p>To factor N=15 using Shor's algorithm using the <code>Shor</code> class provided by Qiskit, I'd need 18 qubits.</p>
</li>
<li><p>Using <a href=""https://github.com/ttlion/ShorAlgQiskit/blob/master/Shor_Sequential_QFT.py"" rel=""nofollow noreferrer"">this version of the algorithm</a>, I only need 11 qubits, but when I try to execute it in <code>ibmq_16_melbourne</code>, I get the following error message:</p>
</li>
</ol>
<blockquote>
<p>Circuit runtime is greater than the device repetition rate. Error code: 8020.</p>
</blockquote>
<p>Which basically means I'm using too many gates.</p>
<p>I know that I can see data about the circuit by writing</p>
<pre><code>shor_compiled = transpile(result['circuit'], backend=server, optimization_level=3)
print('gates = ', shor_compiled.count_ops())
print('depth = ', shor_compiled.depth())
</code></pre>
<p>However, if I want to know about the depth and gate number of a circuit in another computer, first I need to have access to it. <strong>Is there any way I could at least find device specifications for the more powerful, paying devices?</strong> I might get access to them in the near future through the company that's financing my PhD, but I've been asked to analyze whether Shor's algorithm might be tested in those devices.</p>
",<programming><qiskit><ibm-q-experience><shors-algorithm><ibm>,1/15/2021 11:10,15537.0,15537.0,"<p>The first thing that comes to my mind with your problem is the <strong>fake devices</strong> available in Qiskit. <a href=""https://qiskit.org/documentation/tutorials/simulators/2_device_noise_simulation.html#"" rel=""noreferrer"">Here</a> is how to use it, the main idea is that Qiskit stored device properties in Terra and with it, you create simulators that will mimic exactly what the devices would do.<br />
Basically, you can call them the same way you would a real device in <code>qiskit.test.mock</code>, for example <code>from qiskit.test.mock import FakeVigo</code> and then you havee your fake device just with <code>fake_vigo = FakeVigo()</code>.</p>
<p>Here is <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/test/mock/fake_provider.py"" rel=""noreferrer"">a list</a> of every fake provider available in Qiskit. If you need more explanation, you can also check this <a href=""https://www.youtube.com/watch?v=8xJiUoPYDaY"" rel=""noreferrer"">Qiskit video</a>.</p>
<p>Hope this helps, feel free to ask if you need anything else ;)</p>
",1/15/2021 11:24,Learning,"The users primary objective is to gain knowledge and guidance regarding the use of more powerful, paid quantum devices for their thesis work. They are interested in understanding device specifications and the feasibility of testing Shor's algorithm on these devices, which aligns with the Learning category as it involves acquiring information for academic research.", Learning,,,,Learning,
15567.0,"In Simon's algorithm, is there a general method to define an oracle given a certain periodicity?","<p>I have to implement Simon's algorithm in Cirq. I have problems determining the oracle <span class=""math-container"">$f(x)$</span> defined such that <span class=""math-container"">$f(x)=f(x\oplus a)$</span> from a certain value of <span class=""math-container"">$a$</span>.</p>
<p>Given a random <span class=""math-container"">$a$</span>, is there a general way to define the oracle <span class=""math-container"">$f$</span>? Or at least, how can I determine the oracle from a certain <span class=""math-container"">$a$</span>?</p>
<p>I think the following code (from <a href=""https://github.com/quantumlib/Cirq/blob/master/examples/simon_algorithm.py"" rel=""nofollow noreferrer"">Cirq Github repo</a>) answers my question but I cannot understand it.</p>
<pre><code>def make_oracle(input_qubits, output_qubits, secret_string):
&quot;&quot;&quot;Gates implementing the function f(a) = f(b) iff a â¨ b = s&quot;&quot;&quot;
# Copy contents to output qubits:
for control_qubit, target_qubit in zip(input_qubits, output_qubits):
    yield cirq.CNOT(control_qubit, target_qubit)

# Create mapping:
if sum(secret_string):  # check if the secret string is non-zero
    # Find significant bit of secret string (first non-zero bit)
    significant = list(secret_string).index(1)

    # Add secret string to input according to the significant bit:
    for j in range(len(secret_string)):
        if secret_string[j] &gt; 0:
            yield cirq.CNOT(input_qubits[significant], output_qubits[j])
# Apply a random permutation:
pos = [
    0,
    len(secret_string) - 1,
]  # Swap some qubits to define oracle. We choose first and last:
yield cirq.SWAP(output_qubits[pos[0]], output_qubits[pos[1]])
</code></pre>
",<programming><algorithm><cirq><oracles><simons-algorithm>,1/18/2021 10:09,15568.0,15568.0,"<p>Assuming <span class=""math-container"">$x$</span> is <span class=""math-container"">$n$</span> bits, here's a simple procedure: take <span class=""math-container"">$n$</span> ancilla qubits, all prepared in <span class=""math-container"">$|0\rangle$</span>. Do a transversal controlled-not (i.e. bit by bit controlled-not) from the register with <span class=""math-container"">$|x\rangle$</span> to the ancilla register. THis means that if you started wuth
<span class=""math-container"">$$
\sum_xa_x|x\rangle,
$$</span>
you now have
<span class=""math-container"">$$
\sum_xa_x|x\rangle|x\rangle.
$$</span></p>
<p>Next, find a bit of <span class=""math-container"">$a$</span> which is 1. Let's say this is bit <span class=""math-container"">$b$</span>. Do a controlled-not from qubit b of the original register, targeting all the qubits <span class=""math-container"">$q$</span> of the second register for which <span class=""math-container"">$a_q=1$</span>. This means that for all <span class=""math-container"">$x$</span> such that <span class=""math-container"">$x_b=0$</span>, the second register is still <span class=""math-container"">$x$</span>, while if <span class=""math-container"">$x_b=1$</span>, the second register has become <span class=""math-container"">$x\oplus a$</span>. In particular, the <span class=""math-container"">$b^{th}$</span> qubit of the ancilla register must be 0, and that qubit can be dropped.</p>
",1/18/2021 10:35,Tooling," The user is asking for help with using a specific Qiskit tool, the make_oracle() function, to define the oracle for Simon's algorithm. This is a tooling question, as it is related to the use of a specific Qiskit feature.",Tooling,,,,Tooling,
15578.0,"Why did ""job_manager"" submit the same job twice and how to fix it?","<p>In order to avoid the problem posted in <a href=""https://quantumcomputing.stackexchange.com/questions/15558/why-job-manager-did-not-submit-some-of-the-jobs/15559?noredirect=1#comment21565_15559"">Why &quot;job_manager&quot; did not submit some of the jobs?</a>, (the current issue is related but quite different, so I think it is more appropriate to ask separately), I divide the job to batches, with each batch having 75*5=375 circuits. Then I use (&quot;item&quot; below contains a list of 375 circuits)</p>
<pre><code>job_set = job_manager.run(item, backend=backend, name='L_5_vqe_qc' , shots = 8192 )
</code></pre>
<p>with the hope that &quot;job_mamager&quot; will submit the 5 jobs, each with 75 circuits. However, it turns out that the same job was submitted twice. See the screenshot below, where &quot;L_5_vqe_qc_2&quot; was submitted twice. Is this normal?</p>
<p><a href=""https://i.stack.imgur.com/Fu16h.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Fu16h.png"" alt=""enter image description here"" /></a></p>
",<programming><qiskit>,1/18/2021 19:13,15597.0,15597.0,"<p>Job Manager submits the same job twice because there was a partial failure in the first submit. The latest Qiskit (0.23.2) has a fix that will cancel these phantom jobs earlier so they do not consume the job limit.</p>
<p>Details:</p>
<p>Submitting a job is actually a 2-step process:</p>
<ol>
<li>inform the server a job is to be submitted</li>
<li>actually upload the data</li>
</ol>
<p>If Job Manager receives an error at step 1 (i.e. due to networking issues), it'd retry the step. However, sometimes the original request would actually make it to the server even though it gave an error. In such case you will see the same job twice in the dashboard, but the first instance will be stuck in <code>CREATING</code> and never processed (since step 2 was not performed). The server will eventually cancel the phantom job.</p>
",1/19/2021 13:50,Errors,"The user is experiencing a problem where jobs submitted to a quantum backend using a job manager are being duplicated, and they are seeking an explanation for this issue. This falls under the Errors category as it involves troubleshooting an unexpected behavior in quantum job submission.",Errors,,,,Errors,
15580.0,Q# Callable Not Accessible from Open Namespace,"<p>I am trying to to call <code>ApplyMultiplyControlledAnd()</code>, and I'm receiving an error saying &quot;The callable ApplyMultiplyControlledAnd exists in an open namespace, but is not accessible from here.&quot; I have opened Microsoft.Quantum.Canon already, but I'm still getting the error. Any advice as to why this is happening would be greatly appreciated!</p>
<p>Thank you!</p>
",<programming><q#>,1/18/2021 21:17,15585.0,15585.0,"<p>Looking at the <a href=""https://github.com/microsoft/QuantumLibraries/blob/c4f69418a55f3c93f1725a7b090523af28d08885/Standard/src/Canon/And.qs"" rel=""nofollow noreferrer"">source code of ApplyMultiplyControlledAnd</a>,  it is defined as <code>internal</code>, so it's only available to the libraries code, not to the user code.</p>
<p>The non-internal version of this operation seems to be controlled variant of <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applyand"" rel=""nofollow noreferrer"">ApplyAnd</a> or <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applylowdepthand"" rel=""nofollow noreferrer"">ApplyLowDepthAnd</a>.</p>
",1/18/2021 23:17,Errors,"The user is encountering an error related to accessing and using a specific function, ApplyMultiplyControlledAnd(), in a quantum programming context, and they are seeking advice to resolve this issue. This falls under the Errors category as it involves troubleshooting a problem in their quantum code.", Errors,,,,Errors,
15605.0,Error When Importing from qiskit.aqua,"<p>Qiskit Aqua raises the following exception:</p>
<pre><code>ImportError: dlopen: cannot load any more object with static TLS
</code></pre>
<p>I don't understand what might be causing this. I currently have a Ubuntu 14.04 Linux distribution and am using Anaconda Navigator, which I have downloaded with Conda. See code and full error log below.</p>
<hr />
<p>Code:</p>
<pre><code>from qiskit import *
from numpy import *
import qiskit as q
from math import pi
import numpy as np
from numpy.fft import fft
import scipy.fftpack
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt1
import matplotlib.pyplot as plt2
import matplotlib.pyplot as circuit
from qiskit.quantum_info import Statevector
from qiskit.quantum_info import DensityMatrix
from qiskit.visualization import plot_bloch_multivector, plot_histogram
from qiskit.visualization import plot_state_city
from typing import List, Union
from qiskit.quantum_info import Pauli
import time
from itertools import combinations
from qiskit.compiler import assemble
from qiskit.test.mock import FakeVigo
from qiskit.circuit import Parameter
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit.tools.visualization import circuit_drawer
from matplotlib import style 
from qiskit import execute, BasicAer
from qiskit.compiler import transpile
from qiskit.quantum_info.operators import Operator, Pauli
from qiskit.quantum_info import process_fidelity
from qiskit.extensions import RXGate, XGate, CXGate
from qiskit import QuantumCircuit
from qiskit.circuit import ParameterExpression
from typing import Union, Set, List
import numpy as np

from qiskit.circuit import ParameterExpression
from qiskit.aqua.operators import PrimitiveOp



%matplotlib inline
#%matplotlib tk


#style.use(&quot;classic&quot;)
COLOR = 'white'
COLOR1 = 'black'
plt.rcParams['text.color'] = COLOR1
plt.rcParams['axes.labelcolor'] = COLOR
plt.rcParams['xtick.color'] = COLOR
plt.rcParams['ytick.color'] = COLOR

plt1.rcParams['text.color'] = COLOR1
plt1.rcParams['axes.labelcolor'] = COLOR
plt1.rcParams['xtick.color'] = COLOR
plt1.rcParams['ytick.color'] = COLOR

plt2.rcParams['text.color'] = COLOR1
plt2.rcParams['axes.labelcolor'] = COLOR
plt2.rcParams['xtick.color'] = COLOR
plt2.rcParams['ytick.color'] = COLOR


#style.use(&quot;seaborn-whitegrid&quot;)



plt.rc('legend',fontsize=20) # using a size in points
plt1.rc('legend',fontsize=20) # using a size in points
plt2.rc('legend',fontsize=20) # using a size in points

#Rotation Parameters:
#N = .5
</code></pre>
<p>Error:</p>
<pre><code>---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
&lt;ipython-input-4-f30f52024441&gt; in &lt;module&gt;
     35 
     36 from qiskit.circuit import ParameterExpression
---&gt; 37 from qiskit.aqua.operators import PrimitiveOp
     38 
     39 

~/anaconda3/lib/python3.8/site-packages/qiskit/aqua/__init__.py in &lt;module&gt;
     74 from .missing_optional_library_error import MissingOptionalLibraryError
     75 from .aqua_globals import aqua_globals
---&gt; 76 from .quantum_instance import QuantumInstance
     77 from .algorithms import QuantumAlgorithm
     78 from ._logging import (QiskitLogDomains,

~/anaconda3/lib/python3.8/site-packages/qiskit/aqua/quantum_instance.py in &lt;module&gt;
     32 
     33 from .aqua_error import AquaError
---&gt; 34 from .utils.backend_utils import (is_ibmq_provider,
     35                                   is_statevector_backend,
     36                                   is_simulator_backend,

~/anaconda3/lib/python3.8/site-packages/qiskit/aqua/utils/__init__.py in &lt;module&gt;
     58 from .subsystem import get_subsystem_density_matrix, get_subsystems_counts
     59 from .entangler_map import get_entangler_map, validate_entangler_map
---&gt; 60 from .dataset_helper import (get_feature_dimension, get_num_classes,
     61                              split_dataset_to_data_and_labels,
     62                              map_label_to_class_name, reduce_dim_to_via_pca)

~/anaconda3/lib/python3.8/site-packages/qiskit/aqua/utils/dataset_helper.py in &lt;module&gt;
     16 from copy import deepcopy
     17 import numpy as np
---&gt; 18 from sklearn.decomposition import PCA
     19 
     20 

~/anaconda3/lib/python3.8/site-packages/sklearn/__init__.py in &lt;module&gt;
     79     from . import __check_build  # noqa: F401
     80     from .base import clone
---&gt; 81     from .utils._show_versions import show_versions
     82 
     83     __all__ = ['calibration', 'cluster', 'covariance', 'cross_decomposition',

~/anaconda3/lib/python3.8/site-packages/sklearn/utils/_show_versions.py in &lt;module&gt;
     10 import importlib
     11 
---&gt; 12 from ._openmp_helpers import _openmp_parallelism_enabled
     13 
     14 

ImportError: dlopen: cannot load any more object with static TLS
</code></pre>
",<programming><qiskit>,1/20/2021 4:25,15635.0,15635.0,"<p><a href=""https://quantumcomputing.stackexchange.com/a/15610/1386"">@Adam Zalcman answer</a> explains well why the issue happens.</p>
<p>According to <a href=""https://github.com/tensorforce/tensorforce/issues/303"" rel=""nofollow noreferrer"">tensorforce/issues/303</a>:</p>
<blockquote>
<p>Linux has a static limit on the number of shared libraries with TLS (Thread-Local Storage, to support C++'s __thread storage class) that can be loaded into a process. Gym itself doesn't use shared libraries, but OpenGL and Tensorflow both have several libraries. The limit is small, like 14 or 32 depending on OS version (it's the version of glibc that matters).</p>
</blockquote>
<p>The issue was solved by upgrading from Ubuntu 14 to Ubuntu 16.</p>
<p>This could potentially solve the issue as upgrading the OS will likely also upgrade the <code>glibc</code> shipped with the OS. It seems like the version of <code>glibc</code> shipped with Ubuntu 16 increased the &quot;static limit on the number of shared libraries with TLS&quot;.</p>
",1/22/2021 9:12,Errors,"The user is encountering an ImportError when trying to use Qiskit Aqua, and they are seeking help to resolve this issue. This falls under the Errors category as it involves troubleshooting a problem related to importing and using a specific library in their quantum code.",Errors,,,,Errors,
15614.0,What are the available compilers for Trapped-Ion Quantum Computing Architecture?,"<p>I am looking for a compiler to compile a high-level quantum circuit for the Trapped-Ion Quantum Computing architecture, i.e. a compiler that can translate a high-level circuit to native gates of the TI hardware (single-qubit rotations and 2-qubit MS gate) in an optimized manner.</p>
",<programming><trapped-ion><compiling>,1/20/2021 22:32,15615.0,15615.0,"<p>You can compile gates to native trapped ion gates via <a href=""https://quantumai.google/reference/python/cirq/ion/ConvertToIonGates"" rel=""nofollow noreferrer"">cirq.ion.ConvertToIonGates</a>. For example:</p>
<pre><code>import cirq

q0, q1 = cirq.LineQubit.range(2)

circuit = cirq.Circuit(
    cirq.H(q0),
    cirq.CNOT(q0, q1),
    cirq.measure(q0, key='m')
)

print(&quot;Circuit:&quot;)
print(circuit)
# Prints
# Circuit:
# 0: âââHâââ@âââM('m')âââ
#           â
# 1: âââââââXââââââââââââ

ion_circuit = cirq.ion.ConvertToIonGates().convert_circuit(circuit)
print(&quot;Ion Circuit:&quot;)
print(ion_circuit)
# Prints
# Ion Circuit:
# 0: âââPhX(1)âââââââââââMS(0.25Ï)âââPhX(-0.5)^0.5âââS^-1âââM('m')âââ
#                        â
# 1: ââââââââââââââââââââMS(0.25Ï)âââPhX(1)^0.5ââââââââââââââââââââââ

</code></pre>
",1/20/2021 22:52,Tooling,"The user is looking for a specific tool or compiler that can perform a task related to quantum computing, which is compiling high-level quantum circuits for the Trapped-Ion Quantum Computing architecture. This falls under the Tooling category", Tooling,,,,Tooling,
15623.0,How to use Initial States in Qiskits QAOA?,"<p>The class QAOA from qiskit:
<a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.QAOA.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.QAOA.html</a><br />
has the parameter initial_state from the type InitialState.
<a href=""https://qiskit.org/documentation/apidoc/qiskit.aqua.components.initial_states.html#module-qiskit.aqua.components.initial_states"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/apidoc/qiskit.aqua.components.initial_states.html#module-qiskit.aqua.components.initial_states</a></p>
<pre><code>class QAOA(operator=None, optimizer=None, p=1, initial_state=None, mixer=None, initial_point=None, gradient=None, expectation=None, include_custom=False, max_evals_grouped=1, aux_operators=None, callback=None, quantum_instance=None) 
</code></pre>
<p>But this doesnt work.</p>
<pre><code>qaoa_mes = QAOA(H, p=p, optimizer=optimizer, initial_state = Zero, quantum_instance=Aer.get_backend(&quot;qasm_simulator&quot;))
results = qaoa_mes.run()  
</code></pre>
<p>Any Ideas?</p>
",<programming><qiskit><qaoa>,1/21/2021 9:08,15624.0,15624.0,"<p>You need to add the number of qubits for the initial state, this worked for me :</p>
<pre><code>n_qubits = 2 #or whatever you want for your example 
qaoa_mes = QAOA(H, p=p, optimizer=optimizer, initial_state = Zero(n_qubits), quantum_instance=Aer.get_backend(&quot;qasm_simulator&quot;))
</code></pre>
<p>You can also pass a list for the initial point, for example :</p>
<pre><code>qaoa_mes = QAOA(H, p=p, optimizer=optimizer, initial_state = [0.,0.], quantum_instance=Aer.get_backend(&quot;qasm_simulator&quot;))
</code></pre>
<p>You can even pass a circuit for the initial point, there :</p>
<pre><code>n_qubits = 2
initial = QuantumCircuit(n_qubits)
#add any gate you want in the circuit, for example :
initial.h(0)
initial.cx(0,1)

qaoa_mes = QAOA(H, p=p, optimizer=optimizer, initial_state = initial, quantum_instance=Aer.get_backend(&quot;qasm_simulator&quot;))
</code></pre>
<p>If you need something else feel free to ask ! :)</p>
",1/21/2021 9:17,Errors, The user is encountering an error when trying to set the initial_state parameter in Qiskits QAOA class. ,Errors,,,,Errors,
15649.0,"Cirq: Result of rotating qubit measurements never come [0 1] or [1 0 ], always come as [0,0] or [1,1]","<p>I am creating a 2 qubit entangled state:</p>
<pre><code>    def density_matrix_chsh(i, j, qs):
        circuit = chsh_circuit(i, j, qs)
        return cirq.final_density_matrix(circuit, qubit_order=qs)


    def chsh_circuit(i, j, qs):
        return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j]))


    qs = [a, b]

    state = density_matrix_chsh(0, 1, qs)
</code></pre>
<p>Then I am applying rotation for maximum violation:</p>
<pre><code>th = np.pi/(-2)
th1 = np.pi/(4)
th2 = 0 
random_angles = []
newlist = []
b_big = cirq.kron(cirq.unitary(cirq.ry(th)),cirq.unitary(cirq.ry(th)))
results = []
for choosen in itertools.product([th2, th1], repeat=2): 
        random_angles.append(choosen)
for i in range (1000):
    choosen_combination = random.choice(random_angles)
    a_big = cirq.kron(cirq.unitary(cirq.rz(choosen_combination[0])),cirq.unitary(cirq.rz(choosen_combination[1])))    
    rotated_state = b_big @ a_big @ state @ b_big.conj().T
    measurement_rotated = cirq.measure_density_matrix(rotated_state,indices=[0, 1])
    print(&quot;measuring qubits &quot;,measurement_rotated)
    qubit_result = measurement_rotated[0]
    results.append(qubit_result)
</code></pre>
<p>For instance here I tried 1000 times and both qubits are either 0 or 1 at the sma time but I could never see one of them 1 and the other one is 0 after measurement. Probably I am doing something wrong and I can't see
Thanks for helps</p>
",<programming><measurement><cirq>,1/23/2021 11:31,15662.0,15662.0,"<p>As Craig said, you applied b_big and a_big differently. The adjoint a_big is missing from your product. Try <code>rotated_state = b_big @ a_big @ state @ a_big.conj().T @ b_big.conj().T</code>. But Craig's right. Using Circuits would be much simpler:</p>
<pre><code>import itertools
import random
import cirq
import numpy as np

def chsh_circuit(i, j, qs):
    return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j]))

qs = cirq.NamedQubit(&quot;a&quot;), cirq.NamedQubit(&quot;b&quot;)

th = np.pi/(-2)
th1 = np.pi/(4)
th2 = 0
random_angles = []
newlist = []
b_big = cirq.Circuit(cirq.ry(th)(qs[0]), cirq.ry(th)(qs[1]))
results = []
for choosen in itertools.product([th2, th1], repeat=2):
        random_angles.append(choosen)

print(random_angles)
for i in range (1000):
    choosen_combination = random.choice(random_angles)
    a_big = cirq.Circuit(cirq.rz(choosen_combination[0])(qs[0]),
                         cirq.rz(choosen_combination[1])(qs[1]))
    rotated_state = cirq.Circuit(chsh_circuit(0,1, qs), a_big, b_big, cirq.measure(*qs))
    res = cirq.Simulator().run(program=rotated_state, repetitions=1)
    print(&quot;measuring qubits &quot;,res.measurements)
</code></pre>
",1/24/2021 7:04, Errors,"The user is encountering an unexpected behavior when trying to measure a two-qubit entangled state after applying rotations in Cirq, a quantum computing software.This falls under the Errors category",Errors,,,, Errors,
15651.0,How to read the unitary matrix of a quantum circuit in ProjectQ?,"<p>I would like to read the unitary matrix of a quantum circuit in ProjectQ.
Is there any way to do it?</p>
",<programming><projectq>,1/23/2021 18:49,15993.0,15993.0,"<p>Most quantum circuit building softwares, including ProjectQ, do not have any convenience features that explicitly serve this purpose due to the potential overhead of calculating and storing the unitary as the number of qubits increases. The best solution is to create your own function that recovers the unitary. The general idea (software non-specific) is to:</p>
<ol>
<li>Create your quantum function</li>
<li>Iterate through each operation and obtain the matrix representation</li>
<li>Multiply each unitary to get the final unitary representation of the circuit</li>
</ol>
",02/11/2021 15:57,Tooling ,"The user is asking for help with using a specific feature of ProjectQ, a quantum computing software, to read the unitary matrix of a quantum circuit. This falls under the Tooling category ",Tooling,,,,Tooling ,
15667.0,Qiskit: getting QAOA expectation,"<p>Suppose I run the Qiskit's QAOA algorithm.</p>
<pre><code>qaoa = QAOA(operator=qubit_operator, p=p, optimizer=optimizer)
result = qaoa.run(quantum_instance)
</code></pre>
<p>There is a built-in method that gets me the most likely binary solution for this problem. <code>sample_most_likely(result['eigenstate'])</code> But how do I get the whole probability distribution of binary solutions? Ultimately, I would like to calculate the expected value for my problem, not the value based solely on the most likely string.</p>
",<programming><qiskit><vqe><qaoa>,1/24/2021 10:53,15671.0,15671.0,"<p>You should be able to use: <code>result['eigenstate']</code></p>
<p>That should spit out something like (if you are using 4 qubits):</p>
<pre><code>{'0001': 27,
 '0010': 20,
 '0011': 1821,
 '0100': 25,
 '0101': 591,
 '0110': 46,
 '0111': 5347,
 '1001': 18,
 '1010': 2,
 '1011': 226,
 '1101': 11,
 '1111': 58}
</code></pre>
",1/24/2021 17:46,Tooling,The user is asking for help with using a specific feature of Qiskits QAOA algorithm to get the whole probability distribution of binary solutions. This falls under the Tooling category a, Tooling,,,,Tooling,
15673.0,No. of bits in 160 qubits computer,"<p>I read in a book that (<a href=""https://hub.packtpub.com/quantum-expert-robert-sutor-explains-the-basics-of-quantum-computing/"" rel=""nofollow noreferrer"">https://hub.packtpub.com/quantum-expert-robert-sutor-explains-the-basics-of-quantum-computing/</a>)</p>
<blockquote>
<p>160 qubits (quantum bits) could hold <span class=""math-container"">$2^{160} \approx1.46\times 10^{48}$</span> bits while the qubits were involved in computation.&quot;</p>
</blockquote>
<p>How does this calculation come about?</p>
<p>The context of the statement is that a caffine molecule would require <span class=""math-container"">$10^{48}$</span> bits to be represented by a classical computer. However a quantum computer would require 160 qubits and is thus well suited for such representation.</p>
<p>If I look at this question on Quora, a 512 bit computer (which I suppose are real) would give a largest 155 digit number (<a href=""https://www.quora.com/How-many-digits-are-in-a-512-bit-number"" rel=""nofollow noreferrer"">https://www.quora.com/How-many-digits-are-in-a-512-bit-number</a>). Isn't that big enough to represent atoms, molecules etc.?</p>
",<quantum-state><simulation><classical-computing><chemistry>,1/24/2021 20:38,15677.0,15677.0,"<p>If you have <span class=""math-container"">$n$</span> bits you can combine them in <span class=""math-container"">$2^n$</span> different bit string (this come from combinatorics). Now take <span class=""math-container"">$n$</span> qubits. As any qubit can in superposition of two state, i.e. 0 and 1, <span class=""math-container"">$n$</span> qubits can be in superposition representing all <span class=""math-container"">$2^n$</span> possible bit strings.</p>
<p>The notion that <span class=""math-container"">$n$</span> qubits can hold <span class=""math-container"">$2^n$</span> classical bits is unfortunately misleading because when you measure the qubits, they will collapse to one particular state. This means that information content of <span class=""math-container"">$n$</span> qubits is <span class=""math-container"">$n$</span> classical bits.</p>
",1/25/2021 10:52,Learning,"The user is seeking to understand the calculation and representation of qubits in quantum computing, particularly in the context of representing a caffeine molecule. This falls under the Learning category ",Conceptual,"The question is asking about the fundamental concepts of quantum computing, such as the relationship between qubits and bits, and the potential of quantum computers to simulate molecules and other complex systems.",No,102.0,Conceptual,"The question delves into fundamental concepts of quantum computing, such as the relationship between qubits and bits, and the potential of quantum computers to simulate molecules. It seeks understanding rather than practical application."
15678.0,"If quantum computing always return random measurement (or uncertain measurement), why do we still need it?","<p>I am very new to quantum computing and currently studying quantum computing on my own through various resources (Youtube Qiskit, Qiskit website, book).</p>
<p>As my mindset is still &quot;locked&quot; with classical computation, where input and output are very certain, I can confirm my output given a certain input. There are some confusion for me to understand quantum computing properly.</p>
<p>Then many described what are state vector, superposition, measurement, etc. I understand what they meant (or maybe not fully). State vector is probability of being 0 or 1. Superposition is linear combination between two basis (<span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span> or <span class=""math-container"">$|+\rangle$</span>, <span class=""math-container"">$|-\rangle$</span> or any orthogonal basis). Measurement, to get the outcome of a qubit given the probability of the qubit.</p>
<p>However what doesn't make me feel satisfy or &quot;ahha&quot; is that I don't understand, since quantum computing always give an uncertain outcome after measurement (e.g. <a href=""https://www.youtube.com/watch?v=a1NZC5rqQD8&amp;ab_channel=Qiskit"" rel=""noreferrer"">this video</a> about 2:40 the pong game shows when Hadamard gate is applied, then the probability of plane 000 and 001 are half-half and causing the loss because the ball didn't hit the plane), why we still want to use the uncertain outcome?</p>
<p>I understand (or maybe partially understand) that quantum computing is very fast, we can compute many things at once (since we have superposition or something), and we can simulate an experiment many times to get the result. However I don't think this solved my confusion.</p>
<p>So my question is, why do we still need quantum computing since it always gives uncertain measurement?</p>
",<qiskit><measurement><classical-computing><information-theory>,1/25/2021 15:35,15680.0,15680.0,"<h3><strong>Short answer:</strong></h3>
<p>Assuming you are measuring in the computational basis (Z basis), <span class=""math-container"">$\{|0\rangle, |1\rangle \}$</span>, there is no randomness upon measurement in the following quantum circuit (you will always get back the state <span class=""math-container"">$|1\rangle$</span>):</p>
<p><a href=""https://i.stack.imgur.com/hBY8G.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/hBY8G.png"" alt=""enter image description here"" /></a></p>
<p>Thus, measurement needs not be random. However, if you try this following circuit, you will have 50% to see a <span class=""math-container"">$|0\rangle$</span> and 50% to see <span class=""math-container"">$|1\rangle$</span>:</p>
<p><a href=""https://i.stack.imgur.com/CelMX.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/CelMX.png"" alt=""enter image description here"" /></a></p>
<p>So your answer is not so deterministic here... when designing a quantum algorithm, we want somehow create interference within the system and so upon measurement, we have something like the first circuit. Where the result is deterministic.</p>
<hr />
<h3><strong>Long answer:</strong></h3>
<p>A <strong>state vector</strong> is a vector describing the state of the system. In quantum computing, your system is a qubit, hence a two-level quantum system. Thus, it can be described by a complex Euclidian space <span class=""math-container"">$\mathbb{C}^2$</span>. Thus, the state of a qubit, <span class=""math-container"">$|\psi \rangle$</span> can be written as
<span class=""math-container"">$$ |\psi \rangle = \alpha|0\rangle + \beta|1\rangle \hspace{1 cm} \alpha, \beta \in \mathbb{C}, \hspace{0.5 cm} |0\rangle = \begin{pmatrix} 1 \\ 0\end{pmatrix}, \hspace{0.25 cm} |1\rangle = \begin{pmatrix} 0 \\ 1\end{pmatrix}  \hspace{1cm} |\alpha|^2 +|\beta|^2 = 1$$</span>
And if you have an <span class=""math-container"">$n$</span> qubit state then it can be written as a normalized vector in <span class=""math-container"">$\mathbb{C}^{2 ^{\otimes n}}$</span>.</p>
<p>So suppose you have the state <span class=""math-container"">$|\psi \rangle = \begin{pmatrix} 1/\sqrt{2} \\ 1/\sqrt{2}  \end{pmatrix} $</span> then you can see that <span class=""math-container"">$|\psi\rangle$</span> can be written as a <strong>superposition</strong> (in a linear combination) of the states <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> as
<span class=""math-container"">$$ |\psi \rangle = \dfrac{1}{\sqrt{2}}|0\rangle + \dfrac{1}{\sqrt{2}}|1\rangle $$</span>
Now, it is a <strong>postulate of quantum mechanics</strong> that any device that <strong>measures</strong> a two-state quantum system (a qubit) must have two preferred states <span class=""math-container"">$\{|e_1\rangle, |e_2\rangle \}$</span> that form an orthonormal basis for the associated vector space (here would be <span class=""math-container"">$\mathbb{C}^2$</span>). A measurement on the state <span class=""math-container"">$|\psi\rangle$</span> transforms <span class=""math-container"">$|\psi\rangle$</span> into one of the these basis vectors <span class=""math-container"">$|e_1 \rangle$</span> or <span class=""math-container"">$|e_2\rangle$</span>. The probability that the state <span class=""math-container"">$|\psi\rangle$</span> is measured as <span class=""math-container"">$|e_1\rangle$</span> or <span class=""math-container"">$|e_2\rangle$</span> is the square of the magnitude of the amplitude of the component of the state in the direction of the basis vector  <span class=""math-container"">$|e_1\rangle$</span> or <span class=""math-container"">$|e_2\rangle$</span>.</p>
<p>So if we picked <span class=""math-container"">$|e_1\rangle = 0 $</span> and <span class=""math-container"">$|e_2 \rangle = |1\rangle$</span> then upon measuring the state <span class=""math-container"">$|\psi \rangle = \dfrac{1}{\sqrt{2}}|0\rangle + \dfrac{1}{\sqrt{2}}|1\rangle$</span>, you will have 50% observing the state <span class=""math-container"">$|0\rangle$</span> and 50% observing the state <span class=""math-container"">$|1\rangle$</span>. In this case, <strong>a single measurement</strong> doesn't tell you anything... you need many, many measurements to build up a statistical distribution.</p>
<p>But the <em>uncertainty</em> described above is only because we have picked <span class=""math-container"">$|e_1\rangle$</span> and <span class=""math-container"">$e_2\rangle$</span> the way we did. If we have picked, <span class=""math-container"">$|e_1\rangle = |+\rangle =  \begin{pmatrix} 1/\sqrt{2} \\ 1/\sqrt{2} \end{pmatrix}$</span> and <span class=""math-container"">$|e_2\rangle = |-\rangle =  \begin{pmatrix} 1/\sqrt{2} \\ -1/\sqrt{2} \end{pmatrix}$</span> then upon measuring, we will observe the state <span class=""math-container"">$|+\rangle$</span> with a 100% probability (assuming no noise). There is no randomness here. This is because <span class=""math-container"">$|\psi \rangle$</span> is NOT in a superposition in the <span class=""math-container"">$\{|+\rangle, |-\rangle \}$</span> basis.</p>
<p>Therefore, the notion of <em>superposition</em> is <strong>basis-dependent</strong>. All states are superposition with respect to some bases but not with respect to others. That is, a state <span class=""math-container"">$|\psi \rangle = \alpha |0\rangle + \beta |1\rangle$</span> is only a superposition with respect to the  computational basis <span class=""math-container"">$\{|0\rangle, |1\rangle \}$</span> but not a superposition with respect to the bases <span class=""math-container"">$\{ \alpha |0\rangle + \beta |1\rangle, \beta^* |0\rangle - \alpha^* |1\rangle \}$</span>.</p>
<p>Since measuring a superposition state <span class=""math-container"">$|\psi \rangle =  \alpha |0\rangle + \beta |1\rangle$</span> is probabilisitc, it is tempted to say that the state <span class=""math-container"">$|\psi \rangle$</span> is a probabilistic mixture of <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> and we just don't know which, when in fact, <span class=""math-container"">$|\psi \rangle$</span> is actually a definite state. That is, if we measure <span class=""math-container"">$|\psi\rangle$</span> in certain bases, we will get a deterministic result.</p>
<p>Thus, when designing a quantum algorithm, we want the final state which contains the answer we are looking for be in a single eigenstate and not in superposition with respect to the computational basis (Z basis). For instance, the following circuit will create a state that is NOT in superposition in the computational basis...</p>
<p><a href=""https://i.stack.imgur.com/fF955.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/fF955.png"" alt=""enter image description here"" /></a></p>
<p>so if you run the above circuit on a quantum computer, you will only need to measure it <em>ONCE</em> to obtain your result... This circuit is constructed to solve the problem of &quot;secret bitstring&quot;. In fact, the state upon measurement is the state <span class=""math-container"">$|111\rangle$</span>, which tells you that the secret bitstring is <code>11</code>... This is known as the <a href=""https://en.wikipedia.org/wiki/Bernstein%E2%80%93Vazirani_algorithm"" rel=""noreferrer"">BernsteinâVazirani algorithm</a>. I would recommend you to read up on it as it will help you to understand where the advantage of quantum computation come about.</p>
",1/25/2021 16:48,Conceptual ,The user is seeking a conceptual understanding of quantum computing and is grappling with the concept of uncertain outcomes in quantum measurements. This falls under the Conceptual category,Conceptual ,,,,Conceptual ,
15686.0,Q# Simulation Behavior,"<p>I am attempting to run a series of tests on a Q# program I'm running on the local simulator, but I'm not seeing any way to use &gt;1 shot and collect the results of those shots at once, as in essentially every other quantum language/system I've seen. Is this not a feature at all in the Q#/Azure Quantum system? Thank you!</p>
",<programming><simulation><q#>,1/25/2021 22:52,15687.0,15687.0,"<p>Thanks for your question! If you're interested in running multiple shots of a quantum operation, Q# allow for doing that with conventional programming techniques such as a <code>for</code> loop:</p>
<pre><code>open Microsoft.Quantum.Arrays;
open Microsoft.Quantum.Measurement;

operation SampleRandomBit() : Result {
    using (q = Qubit()) {
        return MResetX(q);
    }
}

operation SampleManyRandomBits(nBits : Int) : Result[] {
    mutable results = EmptyArray&lt;Result&gt;();
    for (_ in 1..nBits) {
        set results += [SampleRandomBit()];
    }
    return results;
}
</code></pre>
<p>The Q# standard library also provides some convenience operations for repeating operations in this way, such as <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.arrays.drawmany"" rel=""noreferrer""><code>DrawMany</code></a> or <code>EstimateFrequency</code>:</p>
<pre><code>open Microsoft.Quantum.Characterization;

operation SampleManyRandomBits(nBits : Int) : Result[] {
    return DrawMany(SampleRandomBit, nBits, ());
}

operation EstimateHeadsProbability(nShots : Int) : Double {
    return EstimateFrequency(ApplyToEach(H, _), Measure([PauliZ], _), 1, nShots);
}
</code></pre>
",1/25/2021 23:14,Tooling,"The question is asking about how to run a series of tests on a Q# program on the local simulator using multiple shots, which is a feature that is available in most other quantum languages and systems.",Tooling,,,,Tooling,
15696.0,Aren't qubits just ternary?,"<p>Qubits have 3 states: 1, 0, and 1 and 0 at the same time. If a qubit can have 3 states, then how come they are seen as different from ternary computing, which also has 3 states?</p>
<p>Is it that the 3 states are represented in different ways, or what?</p>
",<quantum-state><classical-computing>,1/26/2021 19:30,15698.0,15698.0,"<p>Qubits have more than three distinct states. Here are six examples of such states:</p>
<p><span class=""math-container"">\begin{align}
|0\rangle\tag{1}\\
|1\rangle\tag{2}\\
|+\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}\tag{3} \\
|-\rangle = \frac{|0\rangle - |1\rangle}{\sqrt{2}} \tag{4}\\
|{+i}\rangle = \frac{|0\rangle +i |1\rangle}{\sqrt{2}} \tag{5}\\
|{-i}\rangle = \frac{|0\rangle -i |1\rangle}{\sqrt{2}}\tag{6}.
\end{align}</span></p>
<p>In fact, a qubit has an infinite number of distinct states. For every <span class=""math-container"">$\theta \in [0, \pi)$</span> and <span class=""math-container"">$\phi \in [0, 2\pi)$</span></p>
<p><span class=""math-container"">$$\tag{7}
\cos\frac{\theta}{2} |0\rangle + e^{i\phi}\sin\frac{\theta}{2} |1\rangle
$$</span></p>
<p>is a distinct <a href=""https://en.wikipedia.org/wiki/Quantum_state#Pure_states"" rel=""nofollow noreferrer"">pure state</a> of a qubit.</p>
",1/26/2021 20:10,Conceptual, This question belongs to the Conceptual category because it seeks to understand the conceptual difference between the quantum states (superposition) and the notion of multiple states in ternary computing. It's about grasping the fundamental concepts of quantum computing and how they differ from classical or ternary computing.,Conceptual,,,,Conceptual,
15711.0,Cirq: n-qubit GHZ state,"<p>I am trying to write <span class=""math-container"">$n$</span> party GHZ state but at the end of the day, it seems like bi partite state. I am missing a detail. Here is my code</p>
<pre><code>number =6
qubits = cirq.LineQubit.range(number) 
def n_party_GHZ_circuit(qubits)
      GHZ_circuit = cirq.Circuit(cirq.H(qubits[i]),
                           cirq.CNOT(qubits[i], qubits[j]))

GHZ = cirq.final_density_matrix(n_party_GHZ_circuit)
</code></pre>
<p>I can write it by hand with indexes but suppose that we have 10 qubits and in that case I do not want to write it by hand for all combinations. So I am trying to write a function but I couldn't.</p>
",<programming><entanglement><circuit-construction><cirq><ghz-state>,1/27/2021 20:01,15712.0,15712.0,"<p>How about:</p>
<pre><code>import cirq
number = 6
qubits = cirq.LineQubit.range(number) 
GHZ_circuit = cirq.Circuit(cirq.H(qubits[0]))
for i in range(number-1):
    C = cirq.Circuit(cirq.CX(qubits[i], qubits[i+1] ) )
    GHZ_circuit = GHZ_circuit + C                     

print(GHZ_circuit)
</code></pre>
<p>which outputs:</p>
<pre><code>0: âââHâââ@âââââââââââââââââââ
          â
1: âââââââXâââ@âââââââââââââââ
              â
2: âââââââââââXâââ@âââââââââââ
                  â
3: âââââââââââââââXâââ@âââââââ
                      â
4: âââââââââââââââââââXâââ@âââ
                          â
5: âââââââââââââââââââââââXâââ
</code></pre>
<p>This will produce the state:</p>
<p><a href=""https://i.stack.imgur.com/aOZLd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aOZLd.png"" alt=""enter image description here"" /></a></p>
<p>which is what 6 qubit GHZ state you want.</p>
",1/27/2021 20:23, Errors ,"The user is experiencing an issue with their code for creating a GHZ state in quantum computing, which is resulting in an unexpected output. This falls under the Errors", Errors ,,,, Errors ,
15748.0,Visualizing nice circuits in Qiskit,"<p>This is what drawing a circuit looks like in the Qiskit textbook:</p>
<p><a href=""https://i.stack.imgur.com/fIVoY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fIVoY.png"" alt=""enter image description here"" /></a></p>
<p>and this is the ugly version I am stuck with in my own notebooks:</p>
<p><a href=""https://i.stack.imgur.com/TGFwE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TGFwE.png"" alt=""enter image description here"" /></a></p>
<p>On their <a href=""https://qiskit.org/textbook/ch-prerequisites/setting-the-environment.html"" rel=""nofollow noreferrer"">Prerequisites</a> page they write:</p>
<p><a href=""https://i.stack.imgur.com/mHkou.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mHkou.png"" alt=""enter image description here"" /></a></p>
<p>However, there is no .qiskit file in my home directory, and I can't locate it anywhere else. I installed it simply with the usual pip install command, without setting up any virtual environment, so that may be the issue. I am not a Linux expert so perhaps there is something simple I am missing.</p>
<p>How can I set up this configuration file? Creating a .qiskit directory manually doesn't do the job.</p>
",<programming><qiskit>,1/29/2021 22:23,15749.0,15749.0,"<p>As James noted in the comment. You can use the <code>.draw( output = 'mpl', ... )</code>  or  to help you to get a nicer figure. That is, suppose I have the following circuit:</p>
<pre><code>q_0: â¤ X ââ¤Mââââââââââ
     âââââ¤ââ¥ââââ      
q_1: â¤ X âââ«ââ¤Mâââââââ
     âââââ¤ â ââ¥ââââ   
q_2: â¤ H âââ«âââ«ââ¤Mââââ
     âââââ¤ â  â ââ¥ââââ
q_3: â¤ H âââ«âââ«âââ«ââ¤Mâ
     âââââ â  â  â ââ¥â
c: 4/âââââââ©âââ©âââ©âââ©â
           0  1  2  3 
</code></pre>
<p>which can be created by running the code:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

qreg_q = QuantumRegister(4, 'q')
creg_c = ClassicalRegister(4, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.x(qreg_q[0])
circuit.x(qreg_q[1])
circuit.h(qreg_q[2])
circuit.h(qreg_q[3])
circuit.measure(qreg_q[0], creg_c[0])
circuit.measure(qreg_q[1], creg_c[1])
circuit.measure(qreg_q[2], creg_c[2])
circuit.measure(qreg_q[3], creg_c[3])
</code></pre>
<p>then by specifying:</p>
<pre><code>circuit.draw( output = 'mpl', style={'name': 'bw'}, plot_barriers= True, initial_state = True, scale = 1)
</code></pre>
<p>I will get the figure:</p>
<p><a href=""https://i.stack.imgur.com/o1s5T.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/o1s5T.png"" alt=""enter image description here"" /></a></p>
<p>and if i specify:</p>
<pre><code>circuit.draw( output = 'latex',style={'name': 'bw'}, plot_barriers= True, initial_state = True, scale = 1)
</code></pre>
<p>I will get the figure:</p>
<p><a href=""https://i.stack.imgur.com/BUC9t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BUC9t.png"" alt=""enter image description here"" /></a></p>
<p>and if you want to <strong>save the image file</strong>, then include the file name in the option. That is, something like:</p>
<pre><code>circuit.draw( 'mpl',style={'name': 'bw'},filename= 'MyCircuit', plot_barriers= True, initial_state = True, scale = 1)
</code></pre>
",1/29/2021 23:17,Tooling ,"The question is asking about how to set up the Qiskit configuration file, which is a tool for configuring Qiskit.",Tooling ,,,,Tooling ,
15750.0,Computing expectation value of product of observables in PennyLane,"<p>In PennyLane, the following circuit returns the expectation value of the <code>PauliZ</code> observable on qubit (wire) 1:</p>
<pre><code>def my_quantum_function(x, y):
    qml.RZ(x, wires=0)
    qml.CNOT(wires=[0, 1])
    qml.RY(y, wires=1)
    return qml.expval(qml.PauliZ(1))
</code></pre>
<p>What if I instead wanted to return the expectation value of an operator <span class=""math-container"">$H = Z_1Z_2$</span> that acts on the first and the second qubit? How might I do that?</p>
<p>It is my understanding that qubits 1 and 2 are &quot;correlated&quot; because of the CNOT, so <span class=""math-container"">$\left\langle Z_1 Z_2 \right\rangle \neq \left\langle Z_1 \right\rangle \left\langle Z_2 \right\rangle$</span>. Does this mean I have to define a custom operator? Or does <code>[qml.expval(qml.PauliZ(i)) for i in range(2)]</code> achieve what I want? Thanks for any help.</p>
<p><em>Note</em>: The above example function was taken from the <a href=""https://pennylane.readthedocs.io/en/stable/introduction/measurements.html"" rel=""noreferrer"">PennyLane measurements documentation</a>.</p>
",<programming><measurement><quantum-enhanced-machine-learning><pennylane><quantum-neural-network>,1/30/2021 4:13,15753.0,15753.0,"<p>PennyLane supports measurements of tensor products of observable via the <code>@</code> operator, like so:</p>
<pre><code>@qml.qnode(dev)
def my_quantum_function(x, y):
    qml.RZ(x, wires=0)
    qml.CNOT(wires=[0, 1])
    qml.RY(y, wires=1)
    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))
</code></pre>
<p>This should return the same result as the solution by <a href=""https://quantumcomputing.stackexchange.com/a/15751/371"">KAJ226</a> above, but will be slightly more efficient as it is avoiding creating a potentially large dense matrix.</p>
<p>There are some examples on <a href=""https://pennylane.readthedocs.io/en/stable/introduction/measurements.html#tensor-observables"" rel=""noreferrer"">tensor observables</a> in the PennyLane documentation.</p>
",1/30/2021 9:32,API Usage,The user is asking how to use the PennyLane API to return the expectation value of a specific operator. This falls under the API Usage category,API Usage,,,,API Usage,
15759.0,noisy circuit by openfermion,"<p>I am working on designing quantum error mitigation algorithms for simulating chemical systems. Therefore, a necessary component is to add noisy to the ideal circuit when using a quantum simulator. But I notice there is no such features in the official documentation of openfermion.
Is there a way to add noise to the circuit in openfermion?</p>
",<programming><simulation><noise><openfermion>,1/30/2021 15:15,15760.0,15760.0,"<p>Note that OpenFermion interoperates with cirq to provide many features that are not specific to quantum chemistry. You can add noise to your circuits like this</p>
<pre><code>noisy = ideal.with_noise(cirq.depolarize(p=0.01))
</code></pre>
<p>where <code>ideal</code> and <code>noisy</code> are instances of <code>cirq.Circuit</code>. Alternatively, you can use a simulator such as <a href=""https://github.com/quantumlib/Cirq/blob/master/cirq/sim/density_matrix_simulator.py"" rel=""nofollow noreferrer""><code>cirq.DensityMatrixSimulator</code></a> which allows you to add noise to the simulation, e.g.</p>
<pre><code>noise = cirq.ConstantQubitNoiseModel(cirq.depolarize(0.01))
noisy_simulator = cirq.DensityMatrixSimulator(noise=noise)
</code></pre>
<p>See <a href=""https://github.com/quantumlib/Cirq/blob/master/docs/noise.ipynb"" rel=""nofollow noreferrer"">this notebook</a> for more details and code examples for both approaches.</p>
",1/30/2021 16:38,Tooling,The user is asking about a specific feature (adding noise to the circuit) in a quantum computing software tool (OpenFermion). This falls under the Tooling category ,Tooling,,,,Tooling,
15777.0,error when running VQE in Qiskit,"<p>I am running the code, which gets the ground state energy with different atomic distances of LiH. However, I encountered this error. The code is as follow</p>
<pre><code>import numpy as np import pylab import copy
from qiskit import BasicAer
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE
from qiskit.aqua.components.optimizers import SLSQP
from qiskit.chemistry.components.initial_states import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver
from qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory
from qiskit.chemistry.transformations import (FermionicTransformation,
                                              FermionicTransformationType,
                                              FermionicQubitMappingType)
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory

molecule = 'H .0 .0 -{0}; Li .0 .0 {0}'
distances = np.arange(0.5,4.25,0.25)
vqe_energies = []
hf_energies = []
exact_energies = []
for i,d in enumerate(distances):
    print('step', i)
    #set up the experiment
    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')
    fermionic_transformation = FermionicTransformation(
            transformation=FermionicTransformationType.FULL,
            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,
            two_qubit_reduction=False,
            freeze_core=False)
    qubit_op, aux_ops = fermionic_transformation.transform(driver)
    #VQE
    optimizer = SLSQP(maxiter=1000)
    initial_state = HartreeFock(fermionic_transformation.molecule_info['num_orbitals'],
                                        fermionic_transformation.molecule_info['num_particles'],
                                        qubit_mapping=fermionic_transformation.qubit_mapping,
                                        two_qubit_reduction=fermionic_transformation._two_qubit_reduction)
    #VQE
    vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator')),
                                 optimizer,
                                 initial_state)
    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)
    res = calc.solve(driver)
    print(res)
</code></pre>
<p>The traceback is here</p>
<pre><code>  File &quot;/home/ironmanaudi/research/VQE/VQE_tutorial/LiH_VQE.py&quot;, line 76, in &lt;module&gt;
    res = calc.solve(driver)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 102, in solve
    raw_mes_result = solver.compute_minimum_eigenvalue(operator, aux_operators)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py&quot;, line 494, in compute_minimum_eigenvalue
    return self._run()
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py&quot;, line 429, in _run
    vqresult = self.find_minimum(initial_point=self.initial_point,
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/vq_algorithm.py&quot;, line 172, in find_minimum
    if initial_point is not None and len(initial_point) != nparms:
TypeError: object of type 'HartreeFock' has no len()
</code></pre>
<p>When change the syntax of getting the result to</p>
<pre><code>res = calc.solve(driver, aux_ops)
</code></pre>
<p>the error becomes</p>
<pre><code>File &quot;/home/ironmanaudi/research/VQE/VQE_tutorial/LiH_VQE.py&quot;, line 70, in &lt;module&gt;
    res = calc.solve(driver, aux_ops)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 90, in solve
    operator, aux_operators = self.transformation.transform(driver, aux_operators)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py&quot;, line 152, in transform
    ops, aux_ops = self._do_transform(q_molecule, aux_operators)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py&quot;, line 358, in _do_transform
    _add_aux_op(aux_op, name)
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py&quot;, line 289, in _add_aux_op
    aux_qop = FermionicTransformation._map_fermionic_operator_to_qubit(
  File &quot;/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py&quot;, line 645, in _map_fermionic_operator_to_qubit
    qubit_op = fer_op.mapping(map_type=qubit_mapping, threshold=0.00000001)
AttributeError: 'SummedOp' object has no attribute 'mapping'
</code></pre>
<p>Can anybody tell me how to work this out?</p>
",<programming><qiskit><vqe>,02/01/2021 03:09,15783.0,15783.0,"<p>Again here you are mixing some things. The <code>initial_state</code> in the <code>VQE</code> (that again you assign in the <code>initial_points</code>) is the starting values of the variational parameters. You have already specified the initial_state in the var_form. Then you should provide a solver in the calc and not run the solver manually. The code that works is here:</p>
<pre><code>import numpy as np
import pylab
import copy
from qiskit import BasicAer
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE
from qiskit.aqua.components.optimizers import SLSQP
from qiskit.chemistry.components.initial_states import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule
from qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory
from qiskit.chemistry.transformations import (FermionicTransformation,
                                              FermionicTransformationType,
                                              FermionicQubitMappingType)
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory


distances = np.arange(0.5,4.25,0.25)
vqe_energies = []
hf_energies = []
exact_energies = []


for i,d in enumerate(distances):
    print('step', i)
    
    #set up the experiment
    molecule = Molecule(geometry=[['H', [0., 0., -1*(d/2)]],
                              ['H', [0., 0., (d/2)]]],
                     charge=0, multiplicity=1)
    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')
    fermionic_transformation = FermionicTransformation(
            transformation=FermionicTransformationType.FULL,
            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,
            two_qubit_reduction=False,
            freeze_core=False)
    
    qubit_op, aux_ops = fermionic_transformation.transform(driver)

    #VQE
    optimizer = SLSQP(maxiter=1)
    initial_state = HartreeFock(fermionic_transformation.molecule_info['num_orbitals'],
                                        fermionic_transformation.molecule_info['num_particles'],
                                        qubit_mapping=fermionic_transformation.qubit_mapping,
                                        two_qubit_reduction=fermionic_transformation._two_qubit_reduction)
    var_form = UCCSD(num_orbitals=fermionic_transformation.molecule_info['num_orbitals'],
                              num_particles=fermionic_transformation.molecule_info['num_particles'],
                              initial_state=initial_state,
                              qubit_mapping=fermionic_transformation.qubit_mapping,
                              two_qubit_reduction=fermionic_transformation._two_qubit_reduction)
    
    vqe_solver = VQE(qubit_op,var_form,optimizer, quantum_instance=QuantumInstance(BasicAer.get_backend('statevector_simulator')))
    
    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)
    
    res = calc.solve(driver)
    
    vqe_energies.append(res.computed_energies[0])
</code></pre>
<p>I also removed the double definition of the driver. Maybe consider the tutorials here: <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/chemistry/03_ground_state_solvers.ipynb"" rel=""nofollow noreferrer"">Ground_state_solver</a></p>
",02/01/2021 11:56,Errors,"The user is encountering errors while running code for calculating the ground state energy of LiH molecules using VQE in Qiskit's chemistry module. The errors are related to issues in the code, specifically with the use of HartreeFock and aux_ops, and are causing it to break. ",Errors,,,,Errors,
15836.0,what matrix operations have better known time complexity on a quantum computer?,"<p>I'm exploring quantum computers for a semester project. I'm mainly interested in making faster matrix calculations than a regular computer.</p>
<p>I was wondering what arithmetic operations (irrespective of how simple or complex they are) are faster on a quantum computer? Also, by what factor does the time complexity improve?</p>
<p>Note - I'm a newbie to quantum computers. So, apologies if this question is too vague than the usual questions here.</p>
",<algorithm><mathematics><classical-computing>,02/04/2021 10:48,15845.0,15845.0,"<p><strong>ANSWER MADE CW</strong></p>
<p>Arguably the one thing that a quantum computer can do quickly, as long as the matrix is defined in the appropriate manner, is the quantum Fourier transform (QFT).  Much as the classical fast Fourier transform (FFT) is the workhouse of many classical matrix algorithms, the QFT is the basis for many such quantum matrix algorithms.</p>
<ul>
<li><p>For example, a standard answer about quantum algorithms for matrices is the quantum algorithm for linear systems - the <a href=""https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations"" rel=""nofollow noreferrer"">HHL algorithm</a> of Harrow, Hassidm, and Lloyd.  This algorithm allows one to <em>invert</em> a matrix.</p>
</li>
<li><p>Another interesting matrix algorithm is that of <a href=""https://www.researchgate.net/publication/220295493_A_Simple_PromiseBQP-complete_Matrix_Problem"" rel=""nofollow noreferrer"">Janzing and Wocjan</a> on determining the elements of a power of a matrix.</p>
</li>
<li><p>One algorithm that I haven't studied in detail but nonetheless seems interesting is Wang's <a href=""https://arxiv.org/abs/1311.1851"" rel=""nofollow noreferrer"">method</a> of determining the effective resistance between two nodes in a graph - if the network were considered to be an adjacency matrix of resistors.</p>
</li>
</ul>
<p>Without knowing more about the OP's background, at least hearing of the importance of the QFT and its embodiment for quantum phase estimation (QPE) is critical to understand how quantum computers can be useful for matrix algorithms.</p>
",02/04/2021 21:10,Learning ,"The user is asking about the performance of quantum computers for matrix calculations, which is a topic that is still under active research. The user is also new to quantum computers, so the question is appropriate for the Learning category.",Learning ,,,,Learning ,
15842.0,How can I adjust calibration figure size?,"<p>I'm hoping to obtain a larger picture of the calibration figure. The original command is</p>
<pre><code>meas_fitter.plot_calibration()
</code></pre>
<p>I tried to use</p>
<pre><code>meas_fitter.plot_calibration(figsize=(10,10))
</code></pre>
<p>but that doesn't work. How can I make it bigger? Thanks!</p>
",<programming><qiskit>,02/04/2021 18:08,15847.0,15847.0,"<p>It seems you tried to recreate the plot of the calibration matrix <a href=""https://qiskit.org/documentation/tutorials/noise/3_measurement_error_mitigation.html"" rel=""nofollow noreferrer"">from this tutorial</a>. Which output a plot like something like below when you execute <code>meas_fitter.plot_calibration()</code>.</p>
<p><a href=""https://i.stack.imgur.com/OcSwk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OcSwk.png"" alt=""enter image description here"" /></a></p>
<p>But you want the image above to be larger. If that is the case, then you can change the image size as follows:</p>
<pre><code>import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 10))
meas_fitter.plot_calibration(ax)
</code></pre>
",02/04/2021 22:53,Tooling, The user is asking about how to make the calibration figure bigger when using the meas_fitter.plot_calibration() function in Qiskit.,Tooling,,,,Tooling,
15851.0,Numpy DeprecationWarning flooding in IBM Quantum Lab,"<p>I'm coding using the Jupyter Notebook in the IBM Quantum Lab. However, I don't know why I see the following repeated message every time when I execute a quantum circuit: <a href=""https://i.stack.imgur.com/uCloG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uCloG.png"" alt=""enter image description here"" /></a></p>
<p>This message shows thousands of times and occupied a significant amount of memory. However, it shows that the job I submitted could be successfully executed, but I'm not able to access the result.
<a href=""https://i.stack.imgur.com/3pV2x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3pV2x.png"" alt=""enter image description here"" /></a></p>
<p>Does anyone know what happened? What can I do to fix this issue? Thanks a lot!</p>
",<programming><qiskit><ibm-q-experience>,02/05/2021 05:44,15852.0,15852.0,"<p>NumPy 1.20 is deprecating part of their API. You have three options:</p>
<ul>
<li>Wait for the next Qiskit release (0.24). It should be around the corner (the <a href=""https://github.com/Qiskit/qiskit-terra/pull/5758"" rel=""nofollow noreferrer"">PR fixing this</a> was merged already).</li>
<li>Downgrade NumPy running <code>!pip install numpy==0.19</code> in the notebook and restart it.</li>
<li>Ignore warnings:</li>
</ul>
<pre><code>import warnings
warnings.filterwarnings('ignore')
</code></pre>
",02/05/2021 06:31,Errors, The user is encountering an error message that repeatedly appears and consumes memory when executing quantum circuits in the IBM Quantum Lab's Jupyter Notebook environment. This falls under the Errors category as it involves troubleshooting and resolving a technical issue related to the execution of quantum circuits.,Errors,,,,Errors,
15853.0,Can I only use a 'subset' of calibration matrix to reduce measurement errors?,"<p>Suppose I have the following calibration matrix generated using 4 qubits:</p>
<pre><code>from qiskit.ignis.mitigation.measurement import (complete_meas_cal, CompleteMeasFitter)
cal_circuits, state_labels = complete_meas_cal(qr = qc.qregs[0],circlabel = 'measerrormitigationcal')
cal_job = execute(cal_circuits, 
                 backend = device,
                 shots = 1024,
                  optimization_level = 0
                 )
print(cal_job.job_id())
job_monitor(cal_job)
cal_results = cal_job.result()
meas_fitter = CompleteMeasFitter(cal_results, state_labels)
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 10))
meas_fitter.plot_calibration(ax)
</code></pre>
<p><a href=""https://i.stack.imgur.com/ol2Bd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ol2Bd.png"" alt=""enter image description here"" /></a></p>
<p><em><strong>Is there a way I can use this filter to reduce another quantum circuit with 3 qubits? (i.e. A subset with 8 elements)</strong></em> (I was wondering if I could add a <code>'0'</code> after the keys but it seems like this won't work since the additional qubit might 'flip'. )</p>
<p>Thanks!!</p>
",<programming><qiskit><error-mitigation>,02/05/2021 06:44,15857.0,15857.0,"<p>Yes, I think this can be done through redefine a new meas_fitter that is a subset of the original one.</p>
<pre><code>fig, ax = plt.subplots(figsize=(10, 10))
subset_meas_fitter = meas_fitter.subset_fitter([0,1,2]) #defining new meas_fitter for a set of qubits
subset_meas_fitter.plot_calibration(ax)
subset_meas_fitter.plot_calibration(ax)
</code></pre>
<p>Which should give you something like:</p>
<p><a href=""https://i.stack.imgur.com/Hiz0J.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Hiz0J.png"" alt=""enter image description here"" /></a></p>
",02/05/2021 09:02,Tooling,The user is asking how to use a specific feature (calibration matrix) in a quantum computing library (Qiskit) for a different quantum circuit with fewer qubits. This falls under the Tooling category ,Tooling,,,,Tooling,
15876.0,CERTIFICATE_VERIFY_FAILED after updating Python when trying to access results in IBM QE,"<p>I had a question earlier about the Numpy DeprecationWarning flooding issue. I just updated the Python in my regular jupyter notebook and have trouble running the following cell:</p>
<pre><code>cal_job = execute(cal_circuits, 
                 backend = backend,
                 shots = 1024,
                  optimization_level = 0
                 )
***cal_results = cal_job.result()***
meas_fitter = CompleteMeasFitter(cal_results, state_labels)
fig, ax = plt.subplots(figsize=(10, 10))
meas_fitter.plot_calibration(ax)
</code></pre>
<p>My code worked fine before upgrading but now it shows the following error message (The line with the error is marked with***):</p>
<pre><code>SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate 
</code></pre>
<p>On the IBMQ Experience page it shows my job has been successfully executed, but I cannot obtain any result from the notebook. What should I do? Thanks so much for the help!</p>
",<programming><qiskit><ibm-q-experience>,02/06/2021 03:14,15882.0,15882.0,"<p>If running on MacOS, did you try to <code>Install Certificates</code>? You can execute the following line in a terminal, replacing <code>&lt;version&gt;</code> with your Python version.</p>
<pre><code>/Applications/Python\ &lt;version&gt;/Install\ Certificates.command
</code></pre>
",02/06/2021 14:26,Errors,The user is encountering an SSL certificate verification error while trying to execute a quantum circuit using the Qiskit library in Jupyter Notebook,Errors,,,,Errors,
15877.0,How to simulate the density matrix in Qiskit when using the qasm simulator?,"<p>When simulating a circuit using qasm simulator, if there is a depolarizing channel in the noise model, then the results could be mixed states. How can I calculate the density matrix of the mixed states?</p>
",<programming><qiskit>,02/06/2021 08:14,15892.0,15892.0,"<p>The easiest way to do this would be to probably use the density matrix snapshot instruction: <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.extensions.SnapshotDensityMatrix.html#qiskit.providers.aer.extensions.SnapshotDensityMatrix"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.providers.aer.extensions.SnapshotDensityMatrix.html#qiskit.providers.aer.extensions.SnapshotDensityMatrix</a> basically just add <code>circuit.snapshot_density_matrix('density_matrix')</code> to your circuit where you want to get the density matrix. That will store the density matrix in the output results. Here is an example script:</p>
<pre><code>from qiskit.test.mock import FakeVigo
from qiskit import QuantumCircuit
from qiskit.providers.aer import extensions  # import aer snapshot instructions
from qiskit import execute


qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.snapshot_density_matrix('density_matrix')
result = execute(qc, FakeVigo()).result()
# Extract density matrix snapshot from result object:
density_matrix = result.data()['snapshots']['density_matrix']['density_matrix'][0]['value']
print(density_matrix)
</code></pre>
<p>In that script <code>FakeVigo</code> is just running Aer under the covers with a noise model taken from a snapshot of the backend properties from the IBMQ vigo device.</p>
",02/06/2021 21:34,Tooling,The user is seeking guidance on how to calculate the density matrix of mixed states when simulating a quantum circuit using a qasm simulator with a depolarizing channel in the noise model. This falls under the Tooling category,Tooling,,,,Tooling,
15895.0,Filtering a set of results obtained from job manager,"<p>I've already generated a filter for readout error mitigation:</p>
<pre><code>cal_results = cal_job.result()
meas_fitter = CompleteMeasFitter(cal_results, state_labels)  
fig, ax = plt.subplots(figsize=(10, 10))
meas_fitter.plot_calibration(ax)
meas_filter = meas_fitter.filter
</code></pre>
<p><a href=""https://i.stack.imgur.com/qJ00B.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qJ00B.png"" alt=""enter image description here"" /></a></p>
<p>I have a set of circuits executed using the IBM job manager, the list is called <code>all_circuits</code>. After transpling the list, I tried:</p>
<pre><code>MExperiments = job_manager.run(all_circuits, backend=backend, shots = nshots)
results = MExperiments.results() 
**mitigated_results = meas_filter.apply(results)**
</code></pre>
<p>I'm hoping to use the filter to mitigate the errors for each circuit in the list, but the last line doesn't quite work. It shows me</p>
<pre><code>QiskitError: 'Unrecognized type for raw_data.'
</code></pre>
<p>How can I fix this issue? Thanks:)</p>
<p><span class=""math-container"">$\rule{4cm}{0.4pt}$</span></p>
<p><strong>PS:</strong>
From the <a href=""https://qiskit.org/documentation/tutorials/noise/3_measurement_error_mitigation.html"" rel=""nofollow noreferrer"">tutorial</a>, there're 4 types of raw data that match the requirement:</p>
<p>Form1: A counts dictionary from results.get_counts,</p>
<p>Form2: A list of counts of length=len(state_labels),</p>
<p>Form3: A list of counts of length=M*len(state_labels) where M is an integer (e.g. for use with the tomography data),</p>
<p>Form4: A qiskit Result.</p>
<p>I'm not pretty sure why the <code>results</code> in my code doesn't fit any one of them.</p>
",<programming><qiskit><error-mitigation>,02/07/2021 00:00,15914.0,15914.0,"<p>As mentioned above, there're 4 types of data that match the requirement. The <code>results</code> in this case obtained from the job manager is not the same as the results shown in the tutorial since it contains a set of results from different quantum circuits. (I'm still confused why this is not considered as a qiskit result, i.e Form 4 above.)</p>
<p>As I tried to print the type, it shows me<code>qiskit.providers.ibmq.managed.managedresults.ManagedResults</code> . Then I searched more information from <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.ManagedResults.html#qiskit.providers.ibmq.managed.ManagedResults"" rel=""nofollow noreferrer"">here</a>. There's a method called <code>combine_results()</code> that allows us to combine results from all jobs into a single Result, which is the same result in the tutorial's example. So I just did:</p>
<pre><code>MExperiments = job_manager.run(all_circuits, backend=backend, shots = nshots)
results = MExperiments.results() 
cresults = results.combine_results()
mitigated_results = meas_filter.apply(cresults)
</code></pre>
",02/08/2021 00:17, Errors,The user is encountering an error while trying to apply a filter for error mitigation to the results of their quantum circuits using the Qiskit library. This falls under the Errors,Errors,,,, Errors,
15907.0,Pennylane: creating QNodes for large numbers of circuits that only differ by number of wires,"<p>Take the following simple quantum function:</p>
<pre><code>def my_quantum_function(params, wires=None):

    for i in range(wires):
        random_rot = params[i]
        qml.RY(random_rot, wires=i)
        
    qml.broadcast(qml.CZ, wires=range(wires), pattern=&quot;chain&quot;)
     
    return qml.expval(qml.PauliZ(0))
</code></pre>
<p>Let's say I want to make QNode objects using this function for wires=2 and wires=3. My understanding is that I can either leave the function as it is and write,</p>
<pre><code>params = [np.random.uniform(0, 2*np.pi) for _ in range(wires)]

dev1 = qml.device(&quot;default.qubit&quot;, wires=2)
circuit1 = qml.QNode(my_quantum_function, dev1)
result1 = circuit1(params, wires=2)

dev2 = qml.device(&quot;default.qubit&quot;, wires=3)
circuit2 = qml.QNode(my_quantum_function, dev2)
result2 = circuit2(params, wires=3)
</code></pre>
<p>or, I can make two copies of the function and use the QNode decorator:</p>
<pre><code>dev1 = qml.device(&quot;default.qubit&quot;, wires=2)
dev2 = qml.device(&quot;default.qubit&quot;, wires=2)

@qml.qnode(dev1)
def circuit1(params):

    wires = 2
    for i in range(wires):
        random_rot = params[i]
        qml.RY(random_rot, wires=i)
        
    qml.broadcast(qml.CZ, wires=range(wires), pattern=&quot;chain&quot;)
     
    return qml.expval(qml.PauliZ(0))

@qml.qnode(dev2)
def circuit2(params):

    wires = 3
    for i in range(wires):
        random_rot = params[i]
        qml.RY(random_rot, wires=i)
        
    qml.broadcast(qml.CZ, wires=range(wires), pattern=&quot;chain&quot;)
     
    return qml.expval(qml.PauliZ(0))

params = [np.random.uniform(0, 2*np.pi) for _ in range(wires)]
result1 = circuit1(params)
result2 = circuit2(params)
</code></pre>
<p>Fair enough. But let's say I wanted to create QNode objects using this function for wires=2,3,4,...,20. What is the most idiomatic way to do this? I know QNodes collections is a way to define families of QNodes, but this still requires explicitly defining all $N$ devices you need, which doesn't end up saving any time, as it appears. Right now what I'm doing is using the top function I gave and a for-loop, defining a new device/QNode on each iteration:</p>
<pre><code>n_wires = [i+2 for i in range(19)]
for n in n_wires:
    params = [np.random.uniform(0, 2*np.pi) for _ in range(n)]
    dev = qml.device(&quot;default.qubit&quot;, wires=n)
    circuit = qml.QNode(my_quantum_function, dev)
    result = circuit(thetas, wires=n)
    ...
    # Do some computations
    ...
</code></pre>
<p>Using the QNode decorator is the recommended approach, and QNodes can be set to mutable, but I can't find an example in the documentation where you can adjust the number of wires on the fly. Maybe there isn't a more elegant way to do this, but I thought I would ask. Sorry for the long-winded question.</p>
",<programming><quantum-circuit><pennylane>,02/07/2021 17:20,15935.0,15935.0,"<p>I received a great answer to my question <a href=""https://discuss.pennylane.ai/t/creating-qnodes-for-large-numbers-of-circuits-that-only-differ-by-number-of-wires/831?u=ryanhill1"" rel=""nofollow noreferrer"">here</a>, through the Xanadu Discussion Forum:</p>
<blockquote>
<p>Iâd say that your approach of having a quantum function that depends
on the number of wires, creating separate QNodes and devices is a good
one. PennyLane doesnât have any further conveniences for such a use
case, other than creating a <code>QNodeCollection</code> which youâve mentioned.</p>
<p>When considering the exact use case, each of these quantum functions
would actually be equivalent to running a quantum circuit of size <span class=""math-container"">$N=2..20$</span>
on a quantum device that is capable of simulating exactly <span class=""math-container"">$N$</span> qubits.</p>
<p>The implied alternative to this would have to involve creating a
single quantum device with 20 qubits, running the quantum circuits one
by one on that device and resetting the device in between circuit runs
(can be achieved by calling <code>dev.reset()</code>). Both for simulators and
for hardware devices it can be costly to have unused ancillae
subsystems. One simulator that could be interesting is <a href=""https://pennylane-forest.readthedocs.io/en/latest/devices/wavefunction.html"" rel=""nofollow noreferrer"">The
Wavefunction device</a> from the PennyLane-Forest plugin, which only
keeps track of the active subsystems in memory.</p>
<p>It could be interesting to see in which cases a tradeoff could be made
between the two approaches.</p>
</blockquote>
<p>Credit to <a href=""https://discuss.pennylane.ai/u/antalszava/summary"" rel=""nofollow noreferrer"">@antalszava</a>!</p>
",02/08/2021 22:13,Tooling ,The user is asking for the most idiomatic way to create QNode objects for a range of wires using the PennyLane library. This falls under the Tooling category,Tooling,,,,Tooling ,
15915.0,Is there a 'retry' logic in job manager?,"<p>This is a follow-up question to my <a href=""https://quantumcomputing.stackexchange.com/a/15914/12334"">earlier post</a>. I'm trying to filter a set of results obtained from job manager, and the following code works when my circuit list doesn't contain too many elements:</p>
<pre><code>MExperiments = job_manager.run(all_circuits, backend=backend, shots = nshots)
results = MExperiments.results() 
cresults = results.combine_results()
mitigated_results = meas_filter.apply(cresults)
</code></pre>
<p>The <code>combine_results()</code> method is used to help us combine a set of results so that the final single result matches the requirements of <code>apply</code>. The prerequisite is that all jobs need to succeed. However, when my list <code>all_circuits</code> gets large, it shows me this error message:</p>
<pre><code>IBMQManagedResultDataNotAvailable: 'Results cannot be combined since some of the jobs failed.'
</code></pre>
<p>I checked my job status in IBMQ and it shows all the circuits have been successfully executed. How can I fix this issue? Is there a way I can make the job monitor retry the jobs that failed? Thanks!!</p>
",<programming><qiskit><ibm-q-experience>,02/08/2021 01:27,15923.0,15923.0,"<p>When you do <code>results = MExperiments.results()</code>, it should issue a warning message telling you which job result could not be retrieved. The message is only issued for the first <code>.result()</code> though, since subsequent calls just use cached data. You can do <code>results = MExperiments.results(refresh=True)</code> to force it to re-fetch results from the server (and hence re-issue warning messages). It is possible that the job completed but fetching of the result failed (e.g. due to networking error). <code>.result(refresh=True)</code> also serves as a retry mechanism.</p>
<p>Another possibility is that the job submit failed. In which case the job won't show up in IBMQ dashboard. You can use <code>print(MExperiments.report())</code> to see which set of circuits doesn't have a successful job.</p>
<p>To answer your last question, job manager today doesn't retry failed jobs (there is an <a href=""https://github.com/Qiskit/qiskit-ibmq-provider/issues/636"" rel=""nofollow noreferrer"">issue</a> open for that though). You can, however, do it manually by</p>
<ol>
<li>use <code>print(MExperiments.report())</code> to find out which job failed</li>
<li>use <code>qobj = job.qobj()</code> to get the qobj and then re-submit it with <code>new_job = backend.run(qobj)</code></li>
<li>combine the results yourself and replace the failed job result with the new job result. The report from step 1 tells you the indexes of the experiments that belong to the failed job. Then you can do <code>result.results[failed_start_index:failed_end_index+1] = new_job.result().results</code></li>
</ol>
",02/08/2021 14:30,Errors,The user is encountering an error message while trying to combine results from a job manager in the IBM Quantum Experience. This falls under the Errors category,Errors,,,,Errors,
15916.0,What's the default value for a quantum register?,"<p>I've just started to learn Quantum computing with Qiskit: I'm reading the <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a> documentation and the book &quot;<a href=""https://www.packtpub.com/product/quantum-computing-in-practice-with-qiskit-and-ibm-quantum-experience/9781838828448"" rel=""nofollow noreferrer"">Quantum Computing in Practice with QiskitÂ® and IBM Quantum ExperienceÂ®</a>&quot;.</p>
<p>In this book, on page 79 we can read: &quot;<em>..., as we set up our qubit to start as 0, ...</em>&quot;</p>
<p>Can we set up the start value for a quantum register?</p>
<p>Because I think I have read that they have its default value to 0, and we only can set it to one using the NOT gate.</p>
<p>I have tried to set it to 0 in Quantum Experience and I haven't found how to do it, and also with Python and I haven't found it.</p>
",<programming><qiskit><physical-qubit>,02/08/2021 06:49,15917.0,15917.0,"<p>One of the seven <a href=""https://en.wikipedia.org/wiki/DiVincenzo%27s_criteria"" rel=""nofollow noreferrer"">DiVincenzo's criteria</a> is the  ability to initialize the state of the qubits to a simple fiducial state. In most quantum hardware, this is taken to be the state <span class=""math-container"">$|0\rangle^{\otimes n} = \overbrace{|0\rangle \otimes |0\rangle \otimes \cdots \otimes |0\rangle}^{n \ times} = |0 0 \cdots 0\rangle$</span>.</p>
<p>If you create a quantum circuit on IBM hardware and pretty much all other hardware platforms, then the initial state is taken exactly to be this <span class=""math-container"">$|0\rangle^{\otimes n} $</span> state. For example, a 3 qubit circuit will starts out like this:</p>
<p><a href=""https://i.stack.imgur.com/LdhBq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LdhBq.png"" alt=""enter image description here"" /></a></p>
<p>Then you can operate on this initial state by applying different quantum gates. For example:</p>
<p><a href=""https://i.stack.imgur.com/Ix6pv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ix6pv.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>Note that the basis in quantum computing is taken to be <span class=""math-container"">$|0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix}$</span> and <span class=""math-container"">$|1\rangle = \begin{pmatrix} 0 \\ 1 \end{pmatrix} $</span>. This is known as the computational basis.</p>
",02/08/2021 07:17,Learning,The user is learning quantum computing with Qiskit and has a question about setting the initial value of a quantum register. This falls under the Learning category,Learning,,,,Learning,
15925.0,Q-Sphere representation of Bell States,"<p>I'm currently going through Lab1 of the <a href=""https://qiskit.org/learn/intro-qc-qh?learnLevel=All%20resources"" rel=""nofollow noreferrer"">Qiskit Quantum Computing Course</a>, where one task is to create the Bell State
<span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(\vert01\rangle + \vert10\rangle\right)$$</span>
Technically it should be achived by applying a Hadamard, followed by a CNOT gate on the initial state <span class=""math-container"">$\vert01\rangle$</span>, if I understand it correctly. My Qiskit implementation is the following:</p>
<pre><code>sv = Statevector.from_label('01')
mycircuit = QuantumCircuit(2)
mycircuit.h(0)
mycircuit.cx(0,1)
new_sv = sv.evolve(mycircuit)
plot_state_qsphere(new_sv.data)
</code></pre>
<p>I'm only confused about the resulting Q-Sphere image:</p>
<p><a href=""https://i.stack.imgur.com/Ewed3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ewed3.png"" alt=""enter image description here"" /></a></p>
<p>The way I understood the Q-Sphere, this image should correspond to the state
<span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(\vert11\rangle - \vert00\rangle\right)$$</span> and not to the requested one. Was my creation of the asked Bell State wrong, or my interpretation of the Q-Sphere? Thanks for any help!</p>
",<programming><qiskit><bell-basis>,02/08/2021 15:48,15927.0,15927.0,"<p>If you want to create <span class=""math-container"">$\frac{|01\rangle + |01\rangle }{\sqrt{2}} $</span>, you actually need to start from the state <span class=""math-container"">$|10\rangle$</span>, not  <span class=""math-container"">$|01\rangle$</span>. Quickly written, the calculation is:</p>
<p><span class=""math-container"">$$ |10\rangle \xrightarrow{I\otimes H} \frac{1}{\sqrt{2}}|1\rangle (|0\rangle + |1\rangle) \xrightarrow{CX} \frac{1}{\sqrt{2}}(|10\rangle + |01\rangle) $$</span></p>
<p>and</p>
<p><span class=""math-container"">$$ |01\rangle \xrightarrow{I\otimes H} \frac{1}{\sqrt{2}}|0\rangle (|0\rangle - |1\rangle) \xrightarrow{CX} \frac{1}{\sqrt{2}}(|00\rangle - |11\rangle) $$</span></p>
<p>So change this</p>
<pre><code>sv = Statevector.from_label('10')
</code></pre>
<p>should be enough to solve your issue, I tried and it worked! ;)</p>
<p>I hope this is clear enough, please tell me if not :)</p>
",02/08/2021 16:28,Learning,The user is seeking clarification regarding their implementation of a Bell State in Qiskit and their interpretation of the resulting Q-Sphere image. They are trying to understand whether they have correctly created the Bell State and whether their interpretation of the Q-Sphere is accurate. This falls under the Learning,Learning,,,,Learning,
15939.0,Multiply-Controlled X Gate/MCT Gate Implementation,"<p>I am currently trying to implement a multi-controlled Toffoli/multi-controlled X gate in Braket, but I am confused as to the general concept of cascaded X gates and other implementations. I've read Barenco, Shors, et al's work <a href=""https://arxiv.org/abs/quant-ph/9503016"" rel=""nofollow noreferrer"">&quot;Elementary Gates for Quantum Computation&quot;</a>, which touches on this, but it's not really illuminating the concept for me. I am partial to the V-gate method used in Barenco, as no ancillary qubits are required, but I'm open to the cascaded-X method as well. Any additional sources or ideas would be greatly appreciated.</p>
",<programming><quantum-gate><quantum-state><grovers-algorithm>,02/09/2021 05:28,15940.0,15940.0,"<p>Section 4.3 &quot;Controlled Operations&quot; from <a href=""http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf"" rel=""nofollow noreferrer"">Quantum Computation and Quantum Information</a> (linked to pdf version of the text) by Mike and Ike may provide some good additional details.</p>
<p>In particular, page 183 and 184 goes into details on how to implement a general implementation of <span class=""math-container"">$C^nX$</span> or <span class=""math-container"">$C^nU$</span> gate.</p>
",02/09/2021 05:46,Learning,The user is learning about the implementation of a multi-controlled Toffoli/multi-controlled X gate in Braket and is seeking additional resources and ideas to understand the concept of cascaded X gates and other implementations. This falls under the Learning category,Learning,,,,Learning,
15942.0,Take every second element of the array in Q#,"<p>Very quick question, I am trying to implement SAT solving in Q# using Grover's Algorithm. I want to take every second element from an array starting at the second element, represented with a range element : <code>1..2..Length(array)</code>. I am not very experienced and I am trying to find a nice and clean way to do so, without too much unnecessary for loop. Could someone help ?</p>
",<programming><q#>,02/09/2021 11:20,15946.0,15946.0,"<p>You can create an array with every second element starting from the second one using the expression <code>array[1..2...]</code>.</p>
",02/09/2021 15:14,Tooling,The user is asking for help with a specific task in Q# related to implementing SAT solving using Grovers Algorithm. This falls under the Tooling category,Tooling,,,,Tooling,
15945.0,Implementing Grover's oracle with multiple solutions in Qiskit,"<p>I want to turn a state</p>
<p><span class=""math-container"">$$
|\Psi_1â© = \frac{1}{\sqrt{8}}(|000â©+|001â©+|010â©+|011â©+|100â©+|101â©+|110â©+|111â©)
$$</span></p>
<p>into</p>
<p><span class=""math-container"">$$
|\Psi_2â© = \frac{1}{\sqrt{8}}(|000â©+|001â©+|010â©+|011â©+|100â©-|101â©-|110â©+|111â©)
$$</span></p>
<p>using a phase oracle before applying Grover's amplification.</p>
<p>One example from <a href=""https://qiskit.org/textbook/ch-algorithms/grover.html"" rel=""nofollow noreferrer"">Qiskit's official page for Grover's Algorithm</a> does this by manually building a circuit with Controlled-Z gates, but <a href=""https://qiskit.org/documentation/tutorials/algorithms/07_grover.html"" rel=""nofollow noreferrer"">another Qiskit document</a> simply uses a class <em>Statevector.from_label</em> to mark the target state <span class=""math-container"">$|11â©$</span> without constructing a circuit, which I assume can only assign single state.</p>
<p>Having the desired states in a form of Python list, i.e. <code>[101, 110]</code>, can I directly convert this into a phase oracle that does the intended job in Qiskit?</p>
",<programming><qiskit><grovers-algorithm><oracles>,02/09/2021 14:17,15947.0,15947.0,"<p>There are different ways to achieve that, my favorite is probably this one: The oracle you describe above is just a classical function (&quot;True if my bitstring is 101 or 110&quot;) converted to a quantum phase flip. So essentially you only have to build a circuit that implements that classical logic plus some gates to do the phase flip.</p>
<h2>Option A: Via classical logic</h2>
<p>Step 1: Create the classical logic circuit in Qiskit:</p>
<pre><code>from qiskit.circuit import classical_function, Int1

# define a classical function that can be turned into a circuit
@classical_function
def oracle(x1: Int1, x2: Int1, x3: Int1) -&gt; Int1:
    return (x1 and not x2 and x3) or (x1 and x2 and not x3)

bitcircuit = oracle.synth()  # turn it into a circuit
</code></pre>
<p>Now you have something looking like this:</p>
<pre><code>q_0: âââ âââââ ââ
       â    â
q_1: âââ âââââ¼ââ
       â    â
q_2: âââ¼âââââ ââ
     âââ´âââââ´ââ
q_3: â¤ X ââ¤ X â
     ââââââââââ
</code></pre>
<p>It flips the output bit (the one at the bottom) if the qubits are in state <span class=""math-container"">$|101\rangle$</span> or <span class=""math-container"">$|110\rangle$</span>.</p>
<p>Step 2: To change this into a phaseflip oracle you can sandwich the bottom qubit in between X and H gates:</p>
<pre><code>from qiskit.circuit import QuantumCircuit

phaseoracle = QuantumCircuit(4)
phaseoracle.x(3)
phaseoracle.h(3)
phaseoracle.compose(bitoracle, inplace=True)
phaseoracle.h(3)
phaseoracle.x(3)
</code></pre>
<p>to get this circuit, which implements your oracle:</p>
<pre><code>q_0: âââââââââââââ âââââ ââââââââââââ
                 â    â
q_1: âââââââââââââ âââââ¼ââââââââââââ
                 â    â
q_2: âââââââââââââ¼âââââ ââââââââââââ
     âââââââââââââ´âââââ´ââââââââââââ
q_3: â¤ X ââ¤ H ââ¤ X ââ¤ X ââ¤ H ââ¤ X â
     ââââââââââââââââââââââââââââââ
</code></pre>
<p>So all together:</p>
<pre><code>from qiskit.circuit import classical_function, Int1, QuantumCircuit

# define a classical function that can be turned into a circuit
@classical_function
def oracle(x1: Int1, x2: Int1, x3: Int1) -&gt; Int1:
    return (x1 and not x2 and x3) or (x1 and x2 and not x3)

bitcircuit = oracle.synth()  # turn it into a circuit


phaseoracle = QuantumCircuit(4)
phaseoracle.x(3)
phaseoracle.h(3)
phaseoracle.compose(bitoracle, inplace=True)
phaseoracle.h(3)
phaseoracle.x(3)
</code></pre>
<h2>Option B: Via looking hard</h2>
<p>You could see that the oracle is implemented by two controlled Z gates:</p>
<pre><code>from qiskit.circuit import QuantumCircuit

phaseoracle = QuantumCircuit(3)
phaseoracle.cz(0, 2)
phaseoracle.cz(0, 1)
</code></pre>
",02/09/2021 16:26,Theoretical,"The users question pertains to a concept in quantum computing, specifically, the creation of a phase oracle for Grover's algorithm.",Conceptual,"The user is seeking conceptual guidance on how to convert one quantum state into another using a phase oracle in the context of Grover's algorithm. This involves understanding the concept of a phase oracle and its practical implementation, which falls under the conceptual category of quantum computing.",No,103.0,Conceptual,"The user seeks conceptual guidance on converting quantum states using a phase oracle in Grover's algorithm. It involves understanding the practical implementation of phase oracles, fitting the conceptual nature of the question."
15966.0,"Was the Quantum Circuit Attribute ""iden"" renamed?","<p>I'm going through some older tutorials for my employer and everything seems to be working fine except the &quot;iden&quot; attribute. The error is listed below. I assume the name was changed but I don't know what it was changed to, and I don't know how to find out.</p>
<pre><code>AttributeError                            Traceback (most recent call last)
&lt;ipython-input-10-fff169415f56&gt; in &lt;module&gt;
      4 hello_qubit = QuantumCircuit(q)
      5 
----&gt; 6 hello_qubit.iden(q[0])
      7 
      8 job = execute(hello_qubit, S_simulator)

AttributeError: 'QuantumCircuit' object has no attribute 'iden' '''
</code></pre>
",<programming><qiskit>,02/10/2021 14:54,15968.0,15968.0,"<p>Now it is called <code>id</code>:</p>
<pre><code>from qiskit import *

circuit = QuantumCircuit(1)
circuit.id(0)
print(circuit)
</code></pre>
<pre><code>     âââââ
q_0: â¤ I â
     âââââ
</code></pre>
<p>If you want to implement a delay consider using <code>delay</code>.</p>
",02/10/2021 15:07,Errors,"The user is encountering an error message while running a quantum computing program. The error message indicates that the QuantumCircuit object has no attribute iden, suggesting that there might be a change in the method name or the method might have been deprecated.",Errors,,,,Errors,
15987.0,Generic CNOT gate in qiskit from tensor product,"<p>I would like to use qiskit to verify for generalized CNOT gates that, e.g. for 4 qubits
<span class=""math-container"">\begin{equation}
\text{cu(0,3)} = |0\rangle\langle 0|\otimes1\!\!1\otimes1\!\!1\otimes1\!\!1 + |1\rangle\langle 1|\otimes1\!\!1\otimes1\!\!1\otimes\sigma_x 
\end{equation}</span>
with control on qubit 0 and target on qubit 3, and in particular showing that the matrix representation is the same. While I know that a way to do that in a qiskit circuit is</p>
<pre><code>test_cu = QuantumCircuit(n*2, n)

test_cu.cx(0,3)

backend_un = Aer.get_backend('unitary_simulator')
unitary = execute(test_cu, backend_un).result().get_unitary()
array_to_latex(unitary, pretext=&quot;\\text{Circuit = } &quot;)

test_cu.draw()
</code></pre>
<p>I don't have any idea on how to make the same from basic operators and using tensor product. I've read that <code>Aqua</code> provides methods for this purpose, but I have nit found anything satisfying on the topic, neither in the official documentation (section tutorial). Thanks in advance.</p>
",<programming><quantum-gate><qiskit>,02/11/2021 10:42,15989.0,15989.0,"<p>I believe you are looking for <a href=""https://qiskit.org/documentation/apidoc/qiskit.aqua.operators.html?highlight=operators#operators"" rel=""nofollow noreferrer"">this Operator class in Aqua</a>.<br />
For example, in order to create the Operator <code>cu03</code> from your question, you can use the Pauli gates from the <code>operator_globals</code> part of Qiskit, and <code>^</code> is used as the tensor product between the gates</p>
<pre><code>from qiskit.aqua.operators.operator_globals import Zero, One, I, X, Z
from sympy import Matrix 

op_00 = (0.5*(I+Z)) #the |0x0| state in Pauli representation
op_11 = (0.5*(I-Z)) #the |1x1| state in Pauli representation

cu_03 = (op_00^I^I^I)+(op_11^I^I^X)
Matrix(cu_03.to_matrix()) #prints nicely the matrix
</code></pre>
<p>Is this what you are looking for? If not please tell me :)</p>
",02/11/2021 13:27,Theoretical,"The user is seeking guidance on how to verify the matrix representation of a generalized CNOT gate using basic quantum operators and tensor products in Qiskit, which falls under the Theoretical category as it involves a theoretical understanding of quantum gates and operations.",Theoretical,,,,Theoretical,
16003.0,Can I adjust the quantum circuit after transpiling it?,"<p>I have a list of quantum circuits called <code>all_circuits</code>. I tried to run those circuits on a quantum computer by submitting the jobs to the IBM job manager:</p>
<pre><code>from qiskit.compiler import transpile, assemble
from qiskit.providers.ibmq.managed import IBMQJobManager

for i in range(len(all_circuits)):    # Submit a single job, and transpile everything just once. 
    all_circuits[i] = transpile(all_circuits[i],backend=backend)
</code></pre>
<p>I'm wondering after transpiling the whole list of circuit, is it still possible for me to modify  an element in the transpiled list, like adding a gate <em><strong>at a particular place</strong></em>?</p>
<p>For instance, if each circuit in my list have the following elements (I'm not so sure if this is a good example haha):</p>
<pre><code>qc = QuantumCircuit(3,3)
qc.H(0)
qc.crx(a,2,1) # Suppose a is some random parameter
***Here!***
qc.barrier()
qc.H([1,2])
qc.cx(1,3)
qc.measure(...)
</code></pre>
<p>I don't think that transpiling a circuit will mix the gates on the two sides of the barrier (the barrier will also be kept), so can I transpile all circuits first, then add a <code>CNOT</code> gate <code>qc.cx(0,2)</code> right before the barrier (marked as 'Here!') to <em><strong>each transpiled circuit, not original one</strong></em> ? Thanks!!</p>
",<programming><qiskit>,02/12/2021 01:09,16004.0,16004.0,"<p>Yes. You can just add gates as usual.</p>
<p>For example: Suppose that we have the following random circuit</p>
<pre><code>from qiskit.circuit.random import random_circuit
num_qubits = 2
circuit_depth = 3
max_operands = 1 #between 0 and 3
measurement_all_qubit = True
qc_random = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None)
print(qc_random)

             ââââââââââââââ       ââââââââââââââââââââââââââââ
q_0: âââââââââ¤ RZ(5.6174) âââââââââ¤ U1(5.5484) ââ¤ RX(6.0937) â
     âââââââââ´âââââââââââââ´âââââââââââââââââââââ¤ââââââââââââââ¤
q_1: â¤ U3(0.96086,4.3412,1.4989) ââ¤ RZ(4.7727) ââ¤ U1(3.1479) â
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
</code></pre>
<p>We can transpiled it to <code>ibmq_athens</code> to get:</p>
<pre><code>from qiskit.compiler import transpile
provider = IBMQ.load_account()
Circuit_Transpile = transpile(qc_random, provider.get_backend('ibmq_athens') , optimization_level=3)
print(Circuit_Transpile)
               ââââââââââââââââââââââââââââââââââ                    
      q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) âââââââââââââââââââââ
               ââââââââââââââ¤ââââââ¤ââââââââââââââ¤ââââââââââââââââââââ
      q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) â
               ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
</code></pre>
<p>Now, we can just add additional gates on top of this transpiled circuit called &quot;Circuit_Transpile&quot; as you would normally do before. For example:</p>
<pre><code>for i in range(5):
    Circuit_Transpile.h(i)
print(Circuit_Transpile)

               âââââââââââââââââââââââââââââââââââââââ                    
      q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) ââ¤ H âââââââââââââââââââââ
               ââââââââââââââ¤ââââââ¤ââââââââââââââ¤âââââ´ââââââââââââââââââââ
      q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) ââ¤ H â
               âââââ¬ââââ¬ââââââââââââââââââââââââââââââââââââââââââââââââââ
ancilla_0 -&gt; 2 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ
                   âââââ¤                                                  
ancilla_1 -&gt; 3 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ
                   âââââ¤                                                  
ancilla_2 -&gt; 4 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ
                   âââââ                                                  
</code></pre>
<p>Hopefully this helps.</p>
<hr />
<p><strong>Update:</strong></p>
<p>It seems like your circuit have two parts that is being divided by the circuit barrier, and you want to add gate into the middle of the circuit (after the barrier) after the transpilation process. If that is the case, then what you can do is to split the two parts of the circuit into two different circuits then compose them together after the transpilation process. For instance:</p>
<pre><code>from qiskit.circuit.random import random_circuit
num_qubits = 2
circuit_depth = 3
max_operands = 1 #between 0 and 3
measurement_all_qubit = True
qc_random1 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None)
qc_random1.barrier(range(2))
qc_random2 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None)
qc_random2.barrier(range(2))
print(qc_random1)
print(qc_random2)

     âââââ ââââââââââââââ    âââââ      â 
q_0: â¤ X âââ¤ U1(2.7235) ââââââ¤ X âââââââââ
     âââââ¤ââ´âââââââââââââ¤âââââ´ââââ´âââââ â 
q_1: â¤ Z ââ¤ RX(0.94815) ââ¤ RX(2.0345) ââââ
     ââââââââââââââââââââââââââââââââââ â 
     ââââââââââââââââââââââ    âââââ     ââââââââââââââ â 
q_0: â¤ U2(0.28027,1.7582) ââââââ¤ X âââââââ¤ RZ(4.5689) ââââ
     âââââââââââââââââââââ¬ââââââ´ââââ´ââââââââââ¬ââââ¬âââââ â 
q_1: â¤ U2(1.6123,1.6426) âââ¤ RZ(6.1746) ââââââ¤ S âââââââââ
     âââââââââââââââââââââ ââââââââââââââ    âââââ      â 
</code></pre>
<p>Now, do the transpilation as you would have normally do:</p>
<pre><code>from qiskit.compiler import transpile
provider = IBMQ.load_account()
Circuit_Transpile1 = transpile(qc_random1, provider.get_backend('ibmq_athens') , optimization_level=3)
Circuit_Transpile2 = transpile(qc_random2, provider.get_backend('ibmq_athens') , optimization_level=3)
print(Circuit_Transpile1)
print(Circuit_Transpile2)

               ââââââââââââââ                                      â 
      q_0 -&gt; 0 â¤ RZ(3.5597) âââââââââââââââââââââââââââââââââââââââââ
               ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â 
      q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) ââââ
                ââââââââââââ âââââââââââââââââââââââââââââââââââââ â 
ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                     
global phase: 0.29049
                âââââââââââââ  ââââââââââââââââââââ â 
      q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ
               ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â 
      q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ
               ââââââââââââââââââââââââââââââââââââ â 
ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ
                                                      
ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ
                                                      
ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ
</code></pre>
<p><strong>Now</strong>, add gates that you wanted to add to the first circuit:</p>
<pre><code>for i in range(2):
    Circuit_Transpile1.h(i)
print(Circuit_Transpile1)

               ââââââââââââââ                                      â âââââ
      q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H â
               ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤
      q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H â
                ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââ
ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                          
ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
                                                                          
ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
</code></pre>
<p>Then <strong>compose</strong> them together to formed a full circuit:</p>
<pre><code>Circuit_Transpile1.compose(Circuit_Transpile2, inplace = True)
print(Circuit_Transpile1)

               ââââââââââââââ                                      â âââââÂ»
      q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H âÂ»
               ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤Â»
      q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H âÂ»
                ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââÂ»
ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
                                                                          Â»
ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
                                                                          Â»
ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
                                                                          Â»
Â«                âââââââââââââ  ââââââââââââââââââââ â 
Â«      q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ
Â«               ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â 
Â«      q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ
Â«               ââââââââââââââââââââââââââââââââââââ â 
Â«ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ
Â«                                                      
Â«ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ
Â«                                                      
Â«ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ
Â«                                                      
<span class=""math-container"">```</span>
</code></pre>
",02/12/2021 01:43,Tooling,"The user is inquiring about the ability to modify elements in a list of transpiled quantum circuits in Qiskit, specifically adding a gate to each transpiled circuit after the transpilation process. This falls under the Tooling category",Tooling,,,,Tooling,
16006.0,How can I find a Clifford+T approximation of an arbitrary one qubit gate in Qiskit?,"<p>I know the Solovay-Kitaev algorithm can achieve this. Is there an implementation of this or any other algorithm for the same task in Qiskit? Or perhaps some other library that interfaces well with Qiskit?</p>
",<programming><qiskit><circuit-construction><solovay-kitaev-algorithm>,02/12/2021 07:15,16007.0,16007.0,"<p>On the Qiskit front, a Solovay-Kitaev algorithm implementation is on its way <a href=""https://github.com/Qiskit/qiskit-terra/pull/5657"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/pull/5657</a>.</p>
<p>If you want to use or have a look to this <code>LNoorl:feature/sk-pass</code> branch (remember is a WIP), you can install it like this:</p>
<pre><code>pip install git+https://github.com/LNoorl/qiskit-terra.git@feature/sk-pass
</code></pre>
<p>Here is a usage example:</p>
<pre><code>from qiskit.circuit import QuantumCircuit
from qiskit.circuit.library import TGate, HGate, TdgGate
from qiskit.transpiler.passes import SolovayKitaevDecomposition

circuit = QuantumCircuit(1)
circuit.rx(0.7, 0)

print('Orginal circuit:')
print(circuit)

basis_gates = [TGate(), TdgGate(), HGate()]
skd = SolovayKitaevDecomposition(recursion_degree=2, basis_gates=basis_gates, depth=5)

discretized = skd(circuit)

print('Discretized circuit:')
print(discretized)
</code></pre>
<pre><code>Orginal circuit:
     âââââââââââ
q_0: â¤ RX(0.7) â
     âââââââââââ
Discretized circuit:
global phase: -Ï/8
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
q_0: â¤ H ââ¤ T ââ¤ H ââ¤ TDG ââ¤ H ââ¤ T ââ¤ H ââ¤ T ââ¤ H ââ¤ TDG ââ¤ H ââ¤ T ââ¤ H âÂ»
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«q_0: â¤ TDG ââ¤ H ââ¤ TDG ââ¤ TDG ââ¤ H ââ¤ T ââ¤ H ââ¤ T ââ¤ T ââ¤ H ââ¤ T ââ¤ H ââ¤ TDG âÂ»
Â«     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«q_0: â¤ TDG ââ¤ H ââ¤ TDG ââ¤ H ââ¤ T ââ¤ H ââ¤ T ââ¤ H ââ¤ T ââ¤ H ââ¤ TDG ââ¤ H ââ¤ TDG âÂ»
Â«     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
Â«q_0: â¤ TDG ââ¤ H ââ¤ TDG ââ¤ H ââ¤ T ââ¤ T ââ¤ H ââ¤ T ââ¤ H ââ¤ TDG â
Â«     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
<span class=""math-container"">```</span>
</code></pre>
",02/12/2021 08:24,Tooling,The user is inquiring about the availability of an implementation of the Solovay-Kitaev algorithm or similar algorithms for quantum error correction in Qiskit or other libraries that can be used in conjunction with Qiskit. This falls under the Tooling category,Tooling,,,,Tooling,
16015.0,Accessing tuple data in Q#,"<p>I am continuing my work on the SAT katas, but I thing I am missing something on the way the tuple data type works. In this example code, I am trying to access the data in a tuple type :</p>
<pre><code>let clause = [(0, false), (1, true)];
using (testRegister = qubit[2]) {
    for i in clause {
        if i[1] == false {
            X(testRegister[i[0]]);
        }
    }
}
</code></pre>
<p>Executing this code will return the error : <code>error QS5004: The type (Int, Bool) does not provide item access. Items can only be accessed for values of array type.</code> I have trouble understanding this error as it states that the tuple's different values cannot be accessed, or am I not doing it the correct way ? I am definitely not trying to modify these !</p>
",<programming><q#>,02/12/2021 19:06,16016.0,16016.0,"<p>The subscripting operator (<code>[]</code>) in Q# only works on values of array types, such as <code>Int[]</code>, <code>Qubit[]</code> or <code>Double[][]</code>. To unpack a tuple, you can <em>deconstruct</em> when you assign the tuple in a <code>let</code> statement or <code>for</code> loop:</p>
<pre><code>let clauses = [(0, false), (1, true)];
using (testRegister = qubit[2]) {
    for (idx, value) in clauses {
        if not value {
            X(testRegister[idx]);
        }
    }
}

// Alternatively:
let clauses = [(0, false), (1, true)];
using (testRegister = qubit[2]) {
    for clause in clauses {
        let (idx, value) = clause;
        if not value {
            X(testRegister[idx]);
        }
    }
}
</code></pre>
<p>The Q# standard library also provides two convenience functions, <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.canon.fst"" rel=""nofollow noreferrer""><code>Fst</code></a> and <a href=""https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.canon.snd"" rel=""nofollow noreferrer""><code>Snd</code></a> for working with pairs (that is, tuples of two elements):</p>
<pre><code>let clauses = [(0, false), (1, true)];
using (testRegister = qubit[2]) {
    for clause in clauses {
        if Snd(clause) {
            X(testRegister[Fst(idx)]);
        }
    }
}
</code></pre>
<hr />
<p>To see why this is needed, Q# arrays are always <em>homogeneous</em> in type. For example, if <code>arr</code> has type <code>'T[]</code>, then <code>arr[idx]</code> is always of type <code>'T</code>, as long as <code>idx</code> is within the range of valid indices for <code>arr</code>. By contrast, tuples can be heterogeneous in type; in your example, <code>clauses</code> has type <code>(Int, Bool)[]</code>, such that the first and second parts of <code>clauses[0]</code> have different types. If the subscripting operator were supported for tuples, <code>clauses[0][0]</code> would thus have a different type from <code>clauses[0][1]</code>; in particular, the type of an expression like <code>clauses[0][idx]</code> could not be inferred at compile type, since the expression would have a different type depending on whether <code>idx</code> is 0 or 1.</p>
<p>This is a large part of why, to help make quantum programs that work reliably and predictably while allowing the flexiblity and power of tuples, Q# offers destructuring and functions like <code>Fst</code> and <code>Snd</code> to help work with tuples.</p>
",02/12/2021 19:58,Errors,The user is encountering an error in their code while trying to access elements of a tuple in Q# and is seeking an explanation and solution for the error. This falls under the Errors category ,Errors ,,,,Errors,
16038.0,Can I 'shuffle' the qubits in my circuit?,"<p>If I have such a quantum circuit:</p>
<pre><code>quanc = QuantumCircuit(5)
quanc.crz(np.pi,1,0)
quanc.cx(1,[i for i in range(2,5)])
</code></pre>
<p><a href=""https://i.stack.imgur.com/0MNQa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0MNQa.png"" alt=""enter image description here"" /></a></p>
<p>Can I 'shuffle' the quantum circuit, such that the qubits <code>[0,1,2,3,4]</code> are mapped to <code>[4,2,3,0,1]</code>? I know in principle I could directly define my circuit in that order, but I'm still wondering if I could first define it like the original code and then 'shuffle' the qubits with those mapping rules? Thanks a lot:)</p>
",<programming><qiskit>,2/15/2021 1:23,16039.0,16039.0,"<p>On a simulator it doesn't matter since you would assume that all the qubits are connected. So I assuming you thinking of mapping this onto actual qubit on the hardware. If that is the case, then you can do it through the <code>transpile</code> function. For example:</p>
<pre><code>quanc = QuantumCircuit(5)
print(quanc)

q_0: 
     
q_1: 
     
q_2: 
     
q_3: 
     
q_4: 
     
</code></pre>
<p>Now, I can remap the qubit when I do my transpilation onto the qubit layout of Athens as follows:</p>
<pre><code>qc_transpiled= transpile(quanc, backend = provider.get_backend('ibmq_athens') ,
                         optimization_level = 3, initial_layout = [4,2,3,0,1] )
qc_transpiled.draw( 'mpl',style={'name': 'bw'}, scale = 0.5)
</code></pre>
<p><a href=""https://i.stack.imgur.com/BvaqW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BvaqW.png"" alt=""enter image description here"" /></a></p>
<p>Hopefully this is what you were thinking of...</p>
",2/15/2021 2:49,Conceptual,The user is seeking conceptual guidance on reordering qubits in a quantum circuit and is not encountering a specific error or technical issue. This question falls under the Conceptual, Conceptual,,,,Conceptual,
16044.0,What are the differences between IBMQJobManager and Qiskit aqua QuantumInstance?,"<p>I have been using the Qiskit aqua QuantumInstance for a while, and have recently discovered the IBMQJobManager class and the two seem to be quite similar. Are there differences between them? Will they be consolidated together in the future?</p>
",<programming><qiskit>,2/15/2021 9:11,16047.0,16047.0,"<p>By looking at the documentation for the two, it actually seems the two have quite different objectives, here is a brief summary: the quantum instance is mostly used to control the transpilation and execution of a circuit via many different parameters, such as the backend, for simulation the noise model, basis gates, coupling map, etc., and is quite useful when wanting to run an Aqua algorithm on the particular instance.</p>
<p>As for the IBMQJobManager, as said in the documentation, the main objective is to handle jobs and pulse schedules in order to be able to run them on backend and then rebuild them as fitted.</p>
<p>See the documentation for both, maybe this will help you better understand their differences : <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.QuantumInstance.html#qiskit.aqua.QuantumInstance"" rel=""nofollow noreferrer"">quantum instance</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.html#qiskit.providers.ibmq.managed.IBMQJobManager"" rel=""nofollow noreferrer"">the job manager</a>.</p>
<p>Do you need a specific detail more explained? If so please tell me and I'll try to detail it more :)</p>
",2/15/2021 11:46,Conceptual,"The user is seeking conceptual clarification regarding the differences between the Qiskit Aqua QuantumInstance and the IBMQJobManager and whether there are plans to consolidate them in the future. This question is about understanding the concepts and differences between these components in Qiskit, making it suitable for the Conceptual category.",Conceptual,,,,Conceptual,
16069.0,Qiskit: Taking a QUBO matrix into `qubit_op',"<p>I'm trying to solve the maximum independent set problem using Qiskit and the QAOA.</p>
<p>I've a nice QUBO Matrix for this simple path graph:</p>
<p><a href=""https://i.stack.imgur.com/IRxeL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IRxeL.png"" alt=""Nice Graph"" /></a></p>
<p>as so:</p>
<p><a href=""https://i.stack.imgur.com/3oiiU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3oiiU.png"" alt=""enter image description here"" /></a></p>
<p>My question is, how do I convert this into a general DOCPLEX method which can be put into the <code>QuadracticProgram</code> method of Qiskit? How can this be done for a general QUBO matrix?</p>
<p>I realise that for this particular problem I've found the matrix <span class=""math-container"">$Q$</span> as described in this [guide].(<a href=""https://arxiv.org/ftp/arxiv/papers/1811/1811.11538.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/ftp/arxiv/papers/1811/1811.11538.pdf</a>)</p>
<p>So by doing the matrix multiplication:</p>
<p><span class=""math-container"">$$y=x^{t} Q x$$</span></p>
<p>where <span class=""math-container"">$$ x = \begin{pmatrix} x_{0} \\  x_{1} \\  x_{2} \end{pmatrix} $$</span></p>
<p>gives the expression:</p>
<p><span class=""math-container"">$$ y = -x_{0}^{2} -x_{1}^{2}  -x_{2}^{2}  + 2x_{0}x_{1} + 2x_{1}x_{2} $$</span></p>
<p>which I want to minimise (EDIT: Changed from maximise - whoops !). As the nodes are either in the maximum set or not,  the variables are binary and so <span class=""math-container"">$  x_{0}= x_{0}^{2}$</span> (NB am I correct in thinking for solving the Maximum weighted independent set problem, say where <span class=""math-container"">$ x_{0} $</span> was twice as important, the weight would manifest as a different constant for the quadractic term?)</p>
<p>Is a function that can take a general matrix into DOCPLEX form qiskit can recognise and operate on?</p>
<p>EDIT 2:</p>
<p>I don't think the <code>stable_set.get_operator()</code> method works at all.
For the simplest example</p>
<pre><code>path = nx.to_numpy_array(nx.path_graph(3))


qubitOp, offset = stable_set.get_operator(path)
print('Offset:', offset)
print('Ising Hamiltonian:')
print(qubitOp.print_details())

</code></pre>
<p>gives:</p>
<p><a href=""https://i.stack.imgur.com/EEfCy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EEfCy.png"" alt=""enter image description here"" /></a></p>
<p>which is not the correct function - the weights of the different nodes are not equal -  and so has no hope of finding the right result.</p>
<p>EDIT 3: After a little bug hunt, the problem is nearly solved !
<a href=""https://github.com/Qiskit/qiskit-aqua/issues/1553"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/issues/1553</a></p>
",<programming><qiskit><qaoa>,2/16/2021 14:08,16187.0,16187.0,"<p>Lena's answer doesn't work as we've noted in the comments underneath: the <code>stable_set.get_operator()</code> takes in a numpy adjacency matrix which is not what I'm inputting.</p>
<p>Instead I've written a function which takes the <code>qubo_array</code> I've got and creates a QuadracticProgram exactly.</p>
<p>To do the particular program I was after manually is done as so:</p>
<pre><code>


mdl = Model('docplex model')

x_0 = mdl.binary_var('x_0')
x_1 = mdl.binary_var('x_1')
x_2= mdl.binary_var('x_2')

mdl.minimize( -x_0 - x_1  - x_2 + 2*x_0*x_1 + 2*x_2*x_1)


print(mdl.export_as_lp_string())

</code></pre>
<p>The way I figured to do this for larger matrices automatically was the use of this function.</p>
<pre><code>def the_auto_doco_mod(qubo_array,model_name,constant):

    &quot;&quot;&quot;

    Function that takes the   QUBO array created for a graphing problem and converts it to a docplex model
    ready for qiskit

    Directly consrtructs the quadractic program with reference to this page
    &quot;&quot;&quot;
    number_of_variables = len(qubo_array[1]) # gets the number of variables from the length of the square qubo matrix
    #mdl = Model('model_name')
    mod = QuadraticProgram()

    for variable in range(0,number_of_variables): # creates the binary variables from the size of the matrix 
        var_name = &quot;x_&quot; +str(variable)
        mod.binary_var(name =var_name)

    mod.minimize(constant = 2,quadratic =qubo_array)  # can put in all constraints as quadractic as the binary variables mean that x_0 ^ 2 = x_0 in both cases 
                                                    #Â  not sure of the impact of this on performance however 

    print(mod.export_as_lp_string())

</code></pre>
<p>Does anyone know whether constructing the QuadracticProgram this way will mean that the ising model taken in by qiskit will evaluate slower or  be affected in any other way?</p>
",2/23/2021 16:06,Errors,"The user is encountering issues and challenges while trying to formulate and solve the maximum independent set problem using Qiskit and QAOA. They are facing problems related to converting a QUBO matrix into a form that can be recognized and operated on by Qiskit. Additionally, they mention a bug they encountered in the stable_set.get_operator() method",Errors,,,,Errors,
16100.0,Can I keep composing a series of quantum circuits into a large quantum circuit?,"<p>Suppose I have a series of quantum circuits, each of them has 2 qubits:</p>
<pre><code>qc = QuantumCircuit(2)
qc.h(0)
qc.crz(np.pi/2,0,1)
circ_list = [...say this is a list with 10 elements, each of them has the same structure above...]
</code></pre>
<p>If I also have a larger quantum circuit:</p>
<pre><code>qcl = QuantumCircuit(8,8)
</code></pre>
<p>I want to compose each of the 10 'small circuits' onto the large circuit, I think a standard method would be:</p>
<pre><code>qcom = qcl.compose(circ_list[i],[2,3]) # [2,3] is a random choice
</code></pre>
<p>However, if I want to simultaneously compose 10 circuits, it looks like I need to repeat the argument 10 times. I'm wondering is there a simpler way I can do that? An analogy I can think of is the <code>reduce</code> function:</p>
<pre><code>n = [4,3,2,1]
a = reduce(lambda x,y: x*y, n)
</code></pre>
<p>Can I do something similar to the reduce function to compose everything at once? Thanks!!</p>
",<programming><qiskit>,2/19/2021 7:02,16101.0,16101.0,"<p>Sure, you can do this with reduce but your list needs to also have the information about which registers you are composing onto.</p>
<p>So if your circ_list was a list of tuples where the first component was the circuit object and the second component was a list indicating which registers this circuit will be composed onto like [2,3]</p>
<p>Then you should be able to use reduce as:</p>
<pre><code>reduce(lambda x,y: x.compose(y[0],y[1]),circ_list, qcl)
</code></pre>
<p>See the docs on reduce for more description: <a href=""https://docs.python.org/3/library/functools.html#functools.reduce"" rel=""nofollow noreferrer"">https://docs.python.org/3/library/functools.html#functools.reduce</a></p>
",2/19/2021 7:26,API Usage," The user is asking about how to use the Qiskit API to compose multiple quantum circuits at once, which is a specific usage of the Qiskit API.",Errors,"The user is seeking solutions and explanations for a perceived error or misunderstanding in quantum program development, specifically regarding the composition of multiple quantum circuits in Qiskit.",No,104.0,API Usage,"The user is inquiring about a specific usage of the Qiskit API to compose multiple quantum circuits at once, fitting the criteria for API usage."
16113.0,From QUBO matrix to Ising model in Qiskit,"<p>Given a general QUBO matrix <span class=""math-container"">$Q$</span> for a quadratic minimization problem, is there a Qiskit way to obtain the Pauli gate list or the Ising model for it? A related question is <a href=""https://quantumcomputing.stackexchange.com/questions/16069/qiskit-taking-a-qubo-matrix-into-qubit-op"">Qiskit: Taking a QUBO matrix into `qubit_op&#39;</a>, but it seems to be about a graph related model. The solution given there is also for a particular graph metric for the <code>stable_set</code>.</p>
",<programming><qiskit><hamiltonian-simulation><optimization>,2/20/2021 16:16,16122.0,16122.0,"<p>I prepared this code based on Qiskit tutorial. Firstly, lets prepare a QUBO task.</p>
<pre><code># Importing standard Qiskit libraries and configuring account
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
#quadratic optimization
from qiskit.optimization import QuadraticProgram
from qiskit.optimization.converters import QuadraticProgramToQubo

# Prepare QUBO task

#prepare quadratic binary optimization task
task = QuadraticProgram(name = 'QUBO on QC')
task.binary_var(name = 'x')
task.binary_var(name = 'y')
task.binary_var(name = 'z')
task.minimize(linear = [1,-2,3], quadratic = [[0,0.5,-0.5],[0.5,0,1],[-0.5,1,0]])
qubo = QuadraticProgramToQubo().convert(task) #convert to QUBO
print(qubo.export_as_lp_string())
</code></pre>
<p>Now, we have a QUBO task and you can convert it to Ising Hamiltonian with this code:</p>
<pre><code>#converting QUBO task to Ising Hamiltonian for simulation on quantum computer
operator, offset = qubo.to_ising()

#operator - unitary operator representing the simulated Hamiltonian
#offset - used after solution on QC to convert objective function value to the proper one

print(operator)

</code></pre>
<p>This code converts Ising Hamiltonian to QUBO:</p>
<pre><code>#conversion of Ising Hamiltonian to QUBO
qp = QuadraticProgram()
qp.from_ising(operator, offset, linear = True) #linear=True =&gt; x^2 is shown as x since x^2=x for x in {0,1}
print(qp.export_as_lp_string())
</code></pre>
",2/21/2021 6:54,Tooling,This question pertains to how to use Qiskit to obtain Pauli gate lists or Ising models from a general QUBO matrix for a quadratic minimization problem. It relates to tools and software usage in quantum programming.,Tooling,,,,Tooling,
16128.0,"IBMQ.load_account() fails with ""403 Client Error""","<p>I alredy save an account but when I want to laod it I get a error like this
how can I fix it ?</p>
<pre><code>HTTPError                                 Traceback (most recent call last)
~\anaconda3\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
    273             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 274             response.raise_for_status()
    275         except RequestException as ex:

~\anaconda3\lib\site-packages\requests\models.py in raise_for_status(self)
    940         if http_error_msg:
--&gt; 941             raise HTTPError(http_error_msg, response=self)
    942 

HTTPError: 403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/version

The above exception was the direct cause of the following exception:

RequestsApiError                          Traceback (most recent call last)
&lt;ipython-input-61-beb09c0bf764&gt; in &lt;module&gt;
----&gt; 1 IBMQ.load_account()

~\anaconda3\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
    182         # Explicitly check via a server call, to allow environment auth URLs
    183         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 184         version_info = self._check_api_version(credentials)
    185 
    186         # Check the URL is a valid authentication URL.

~\anaconda3\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
    453         version_finder = VersionClient(credentials.base_url,
    454                                        **credentials.connection_parameters())
--&gt; 455         return version_finder.version()
    456 
    457     def _initialize_providers(self, credentials: Credentials) -&gt; None:

~\anaconda3\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
     49                 * ``api-*`` (str): The versions of each individual API component
     50         &quot;&quot;&quot;
---&gt; 51         return self.client_version_finder.version()

~\anaconda3\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
    102         &quot;&quot;&quot;
    103         url = self.get_url('version')
--&gt; 104         response = self.session.get(url)
    105 
    106         try:

~\anaconda3\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
    541 
    542         kwargs.setdefault('allow_redirects', True)
--&gt; 543         return self.request('GET', url, **kwargs)
    544 
    545     def options(self, url, **kwargs):

~\anaconda3\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
    294                 self._modify_chained_exception_messages(ex)
    295 
--&gt; 296             raise RequestsApiError(message, status_code) from ex
    297 
    298         return response

RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/version. &lt;!DOCTYPE html&gt;\n&lt;!--[if lt IE 7]&gt; &lt;html class=&quot;no-js ie6 oldie&quot; lang=&quot;en-US&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 7]&gt;    &lt;html class=&quot;no-js ie7 oldie&quot; lang=&quot;en-US&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if IE 8]&gt;    &lt;html class=&quot;no-js ie8 oldie&quot; lang=&quot;en-US&quot;&gt; &lt;![endif]--&gt;\n&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;html class=&quot;no-js&quot; lang=&quot;en-US&quot;&gt; &lt;!--&lt;![endif]--&gt;\n&lt;head&gt;\n&lt;title&gt;Access denied | auth.quantum-computing.ibm.com used Cloudflare to restrict access&lt;/title&gt;\n&lt;meta charset=&quot;UTF-8&quot; /&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot; /&gt;\n&lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot; /&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;\n&lt;link rel=&quot;stylesheet&quot; id=&quot;cf_styles-css&quot; href=&quot;/cdn-cgi/styles/main.css&quot; type=&quot;text/css&quot; media=&quot;screen,projection&quot; /&gt;\n\n\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;cf-wrapper&quot;&gt;\n    &lt;div class=&quot;cf-alert cf-alert-error cf-cookie-error hidden&quot; id=&quot;cookie-alert&quot; data-translate=&quot;enable_cookies&quot;&gt;Please enable cookies.&lt;/div&gt;\n    &lt;div id=&quot;cf-error-details&quot; class=&quot;p-0&quot;&gt;\n      &lt;header class=&quot;mx-auto pt-10 lg:pt-6 lg:px-8 w-240 lg:w-full mb-15 antialiased&quot;&gt;\n         &lt;h1 class=&quot;inline-block md:block mr-2 md:mb-2 font-light text-60 md:text-3xl text-black-dark leading-tight&quot;&gt;\n           &lt;span data-translate=&quot;error&quot;&gt;Error&lt;/span&gt;\n           &lt;span&gt;1009&lt;/span&gt;\n         &lt;/h1&gt;\n         &lt;span class=&quot;inline-block md:block heading-ray-id font-mono text-15 lg:text-sm lg:leading-relaxed&quot;&gt;Ray ID: 6250695e3c814e6d &amp;bull;&lt;/span&gt;\n         &lt;span class=&quot;inline-block md:block heading-ray-id font-mono text-15 lg:text-sm lg:leading-relaxed&quot;&gt;2021-02-21 12:18:43 UTC&lt;/span&gt;\n        &lt;h2 class=&quot;text-gray-600 leading-1.3 text-3xl lg:text-2xl font-light&quot;&gt;Access denied&lt;/h2&gt;\n      &lt;/header&gt;\n\n      &lt;section class=&quot;w-240 lg:w-full mx-auto mb-8 lg:px-8&quot;&gt;\n          &lt;div id=&quot;what-happened-section&quot; class=&quot;w-1/2 md:w-full&quot;&gt;\n            &lt;h2 class=&quot;text-3xl leading-tight font-normal mb-4 text-black-dark antialiased&quot; data-translate=&quot;what_happened&quot;&gt;What happened?&lt;/h2&gt;\n            &lt;p&gt;The owner of this website (auth.quantum-computing.ibm.com) has banned the country or region your IP address is in (IR) from accessing this website.&lt;/p&gt;\n            \n          &lt;/div&gt;\n\n          \n      &lt;/section&gt;\n\n      &lt;div class=&quot;cf-error-footer cf-wrapper w-240 lg:w-full py-10 sm:py-4 sm:px-8 mx-auto text-center sm:text-left border-solid border-0 border-t border-gray-300&quot;&gt;\n  &lt;p class=&quot;text-13&quot;&gt;\n    &lt;span class=&quot;cf-footer-item sm:block sm:mb-1&quot;&gt;Cloudflare Ray ID: &lt;strong class=&quot;font-semibold&quot;&gt;6250695e3c814e6d&lt;/strong&gt;&lt;/span&gt;\n    &lt;span class=&quot;cf-footer-separator sm:hidden&quot;&gt;&amp;bull;&lt;/span&gt;\n    &lt;span class=&quot;cf-footer-item sm:block sm:mb-1&quot;&gt;&lt;span&gt;Your IP&lt;/span&gt;: 2.183.208.51&lt;/span&gt;\n    &lt;span class=&quot;cf-footer-separator sm:hidden&quot;&gt;&amp;bull;&lt;/span&gt;\n    &lt;span class=&quot;cf-footer-item sm:block sm:mb-1&quot;&gt;&lt;span&gt;Performance &amp;amp; security by&lt;/span&gt; &lt;a rel=&quot;noopener noreferrer&quot; href=&quot;https://www.cloudflare.com/5xx-error-landing&quot; id=&quot;brand_link&quot; target=&quot;_blank&quot;&gt;Cloudflare&lt;/a&gt;&lt;/span&gt;\n    \n  &lt;/p&gt;\n&lt;/div&gt;&lt;!-- /.error-footer --&gt;\n\n\n    &lt;/div&gt;&lt;!-- /#cf-error-details --&gt;\n  &lt;/div&gt;&lt;!-- /#cf-wrapper --&gt;\n\n  &lt;script type=&quot;text/javascript&quot;&gt;\n  window._cf_translation = {};\n  \n  \n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n'<span class=""math-container"">```</span>  
</code></pre>
",<programming><qiskit>,2/21/2021 12:24,16132.0,16132.0,"<p>The explanation is in the body of the message (after some scrolling):</p>
<pre><code>The owner of this website (auth.quantum-computing.ibm.com)
has banned the country or region your IP address is in (IR)
from accessing this website.
</code></pre>
",2/21/2021 14:37, Errors,The user is encountering an error when trying to load their IBM Quantum Experience account using IBMQ.load_account() in Qiskit. This question falls under the Errors category as it involves troubleshooting and resolving an issue related to accessing the IBM Quantum Experience platform.,Errors,,,, Errors,
16176.0,Multiple Providers on IBMQ,"<p>I am attempting to run parallel computations on two different backends from within the same Jupyter notebook, though it appears these two jobs are running sequentially. I understand the jobs will be asynchronous, but is there any way to submit two jobs to differing backends at the same time? I'm not seeing anything allowing for providing multiple backends. Thank you!</p>
",<programming><qiskit><ibm-q-experience><ibm>,2/23/2021 3:46,16184.0,16184.0,"<p>There is a (much simpler in my opinion) solution that does not require <code>multiprocessing</code> at all: use <code>qiskit</code> API.</p>
<p>A code sample is worth a thousand words:</p>
<pre><code># Load the packages
from qiskit import IBMQ, QuantumCircuit, execute

# Log in to your IBMQ account
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')
# Get the backends you are interested in
backends = [provider.get_backend(b) for b in [&quot;ibmq_athens&quot;, &quot;ibmq_quito&quot;]]
# Build the quantum circuit
qc = QuantumCircuit(5)
qc.h(list(range(5)))
qc.cx(0, 1)
qc.cx(1, 2)
qc.cx(3, 4)
qc.cx(5, 2)
qc.measure_all()
# Asynchronously submit the circuit on all the backends.
# This will only submit the circuits, not wait for their completion.
jobs = [execute(qc, backend) for backend in backends]

# Do some work...

# When you need your job results:
# You can also query the results individually if needed.
# The call to &quot;result()&quot; blocks until the job is finished.
results = [j.result() for j in jobs]

# Now you can use the results, for example to recover the counts
# This is a non-blocking operation as the counts are already in
# the results obtained in the previous step
counts = [result.get_counts() for result in results]
</code></pre>
",2/23/2021 11:44,API Usage,"The user is asking about how to use the Qiskit API to run parallel computations on two different backends at the same time, which is a specific usage of the Qiskit API",API Usage,,,,API Usage,
16208.0,How can we construct a control-control y-rotation (CCRy) gate in Qiskit?,"<p>Qiskit has a CRy gate, however I couldn't find a CCRy (double control Ry) gate implementation. How can we construct the CCRy circuit given below in Qiskit without any ancillary qubits?</p>
<p><a href=""https://i.stack.imgur.com/nUDH2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nUDH2.png"" alt=""enter image description here"" /></a></p>
<p><strong>Edit:</strong>
A quick note on <a href=""https://quantumcomputing.stackexchange.com/a/15478/13901"">another solution</a>, when using the mcry gate to perform control-control y-rotation. I had been initializing quantum circuits via:</p>
<pre><code>from qiskit.circuit import QuantumCircuit

circ = QuantumCircuit(4, 4)
circ.mcry(q_controls=[0, 1], q_target=2, q_ancillae=None) # Gives error saying q_target needs to be a qubit
</code></pre>
<p>As shown in the linked solution, one needs to define quantum registers and pass those objects as parameters to the quantum circuit to avoid this issue. In general, this makes me wonder if the latter is a better practice than what I had been doing previously (shown above).</p>
",<programming><quantum-gate><qiskit>,2/25/2021 2:22,16209.0,16209.0,"<p>There is no CCRy gate in the library but there is the multi-controlled multi-target gate (MCMT) class that you can use. Or, you could also do it as follow:</p>
<pre><code>from qiskit import QuantumCircuit,QuantumRegister
from qiskit.circuit.library.standard_gates import RYGate
from qiskit.circuit import Parameter
import matplotlib.pyplot as plt
qr=QuantumRegister(3)
circ=QuantumCircuit(qr)
a=Parameter('a') # You can replace a with your choice of angle here
CCRY=RYGate(a).control(2)
circ.append(CCRY,qr)
print(circ)

               
q0:   âââââ ââââ
          â    
q1:   âââââ ââââ
      âââââ´ââââ
q2:   â¤ RY(a) â
      âââââââââ

</code></pre>
",2/25/2021 2:40,API Usage,"The user is asking about how to use the Qiskit API to construct a CCRy (double control Ry) gate without any ancillary qubits, which is a specific usage of the Qiskit API", API Usage,,,,API Usage,
16275.0,Statevector Simulation of QAOA always finds exact solution,"<p>My question is simple: does applying QAOA with a statevector simulation always result in a perfect solution?</p>
<p>I'm trying to calculate the best <span class=""math-container"">$\gamma$</span> &amp; <span class=""math-container"">$\beta$</span> that solve certain problems but my statevector simulation of problem always finds the exact solution with a single stage (<span class=""math-container"">$p=1$</span>) of QAOA.</p>
<p>I know that in a in a real quantum device, the entire statevector isn't calculated (the whole point of quantum computing!) but rather multiple 'shots' are processed to build up a statistical picture.</p>
<p>Using these inputs, a typical solver like COBYLA won't work as well as they assume each function value they get is true. As such, getting the best possible <span class=""math-container"">$\gamma$</span> &amp; <span class=""math-container"">$\beta$</span> values is harder than when using the statevector simulation, which can get arbitarily close as <a href=""https://youtu.be/E0Sos_lR-kI?t=1212"" rel=""nofollow noreferrer"">this guide says</a>. Is this where the need for multiple stages of the QAOA comes from? We cannot get as high quality angles with shot based simulators and so we need more stages ?</p>
<p>I first noticed this when trying to solve the MIS problem using the statevector simulator in qiskit and was getting perfect results each time up to <span class=""math-container"">$N=14$</span> nodes, which seemed a little crazy. At first, I thought this was perhaps due to the QAOA being 'good' at this sort of problem and thought I would have to simulate at higher <span class=""math-container"">$N$</span>'s before more stages were needed. I then tried the same setup on a MAXCUT (<span class=""math-container"">$N=12$</span>) problem and got the same outcome: QAOA always finding an optimum solution with just one stage. I know from <a href=""https://arxiv.org/abs/1812.01041"" rel=""nofollow noreferrer"">this paper</a> that multiple stages were needed for MAXCUT at the same region of N's (and graph complexity) and so this is what leads me to think QAOA evaluates perfectly when the entire statevector is calculated. Am I correct ?</p>
<p>EDIT: I've included the Qiskit Code I've used to generate this.</p>
<p>For completion I've included all my code but the <em>relevant bit is outside of all the functions</em>. Here is what these functions do:</p>
<p><code>weighted_erdos_graph</code> generates an Erdos-Renyi graph using the standard networkx implementation with randomly weighted nodes. <code>own_maximum_weighted_independent_set_qubo</code> Is taken from D-Wave, and generates the QUBO for a given graph. This is in the form of a dictionary which <code>convert_to_array</code> converts to a numpy array for ease of manipulation.  <code>the_auto_doco_mod</code> (I had Wallace and Gromit on the mind...) takes this numpy array and converts this to a <code>QuadracticProgram</code>, with the binary variables interpretted as quadractics (I know this is a bit hacky, but it works).</p>
<pre><code>from qiskit import IBMQ, Aer, QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit.aqua import aqua_globals, QuantumInstance
from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver
from qiskit.optimization.algorithms import MinimumEigenOptimizer, RecursiveMinimumEigenOptimizer
from qiskit.optimization import QuadraticProgram
from qiskit.optimization.applications.ising.docplex import get_operator
import numpy as np
from docplex.mp.model import Model
from docplex.cp.expression import binary_var_list

#########Â Functions ####################

def own_maximum_weighted_independent_set_qubo(G, weight=None, lagrange=2.0):
    &quot;&quot;&quot;Return the QUBO with ground states corresponding to a maximum weighted independent set.

    Parameters
    ----------
    G : NetworkX graph

    weight : string, optional (default None)
        If None, every node has equal weight. If a string, use this node
        attribute as the node weight. A node without this attribute is
        assumed to have max weight.

    lagrange : optional (default 2)
        Lagrange parameter to weight constraints (no edges within set)
        versus objective (largest set possible).

    Returns
    -------
    QUBO : dict
       The QUBO with ground states corresponding to a maximum weighted independent set.

    Examples
    --------

    &gt;&gt;&gt; from dwave_networkx.algorithms.independent_set import maximum_weighted_independent_set_qubo
    ...
    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; Q = maximum_weighted_independent_set_qubo(G, weight='weight', lagrange=2.0)
    &gt;&gt;&gt; Q[(0, 0)]
    -1.0
    &gt;&gt;&gt; Q[(1, 1)]
    -1.0
    &gt;&gt;&gt; Q[(0, 1)]
    2.0

    &quot;&quot;&quot;

    # empty QUBO for an empty graph
    if not G:
        return {}

    # We assume that the sampler can handle an unstructured QUBO problem, so let's set one up.
    # Let us define the largest independent set to be S.
    # For each node n in the graph, we assign a boolean variable v_n, where v_n = 1 when n
    # is in S and v_n = 0 otherwise.
    # We call the matrix defining our QUBO problem Q.
    # On the diagnonal, we assign the linear bias for each node to be the negative of its weight.
    # This means that each node is biased towards being in S. Weights are scaled to a maximum of 1.
    # Negative weights are considered 0.
    # On the off diagnonal, we assign the off-diagonal terms of Q to be 2. Thus, if both
    # nodes are in S, the overall energy is increased by 2.
    cost = dict(G.nodes(data='node_weight', default=1))
    scale = max(cost.values())
    Q = {(node, node): min(-cost[node] / scale, 0.0) for node in G}
    Q.update({edge: lagrange for edge in G.edges})

    return Q

def weighted_erdos_graph(nodes, prob, seed =None):
    &quot;&quot;&quot;Generates an erdos graph with weighted nodes
    https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model
    Node weights randomly assigned with the same seed as the erdos graph
    &quot;&quot;&quot;
    graph = nx.erdos_renyi_graph(n=nodes, p =prob, seed=seed, directed=False)
    np.random.seed(seed)
    graph_weights = np.random.randint(10,size = nodes)

    for i in range(0,nodes):
        graph.nodes[i][&quot;node_weight&quot;] = graph_weights[i]
    #print(list(graph.nodes(data=True)))
    return graph


def the_auto_doco_mod(qubo_array,model_name,constant):

    &quot;&quot;&quot;

    Function that takes the   QUBO array created for a graphing problem and converts it to a docplex model
    ready for qiskit

    Directly constructs the quadractic program with reference to this page
    &quot;&quot;&quot;
    number_of_variables = len(qubo_array[1]) # gets the number of variables from the length of the square qubo matrix
    #mdl = Model('model_name')
    mod = QuadraticProgram()

    for variable in range(0,number_of_variables): # creates the binary variables from the size of the matrix
        var_name = &quot;x_&quot; +str(variable)
        mod.binary_var(name =var_name)

    mod.minimize(quadratic =qubo_array)  # can put in all constraints as quadractic as the binary variables mean that x_0 ^ 2 = x_0 in both cases
                                                    #Â  not sure of the impact of this on performance however

    print(mod.export_as_lp_string())

    return mod
def convert_to_array(dictionary):
    &quot;&quot;&quot;

    Function to convert qubo dictionary from dwave into a numpy array 

    &quot;&quot;&quot;


   ####### Generate the matrix ##########
    key_list = dictionary.keys()
    matrix_size= np.max([element[0] for element in key_list])  # gets the matrix size by taking the biggest number from the list of keys: a bit hacky but hey, it's 3 am
    qubo = np.zeros((matrix_size +1, matrix_size +1))

    ###### Adds diagonal values ######

    for item in dictionary.items():

        position = item[0]
        value = item[1]


        qubo[position] = value

    return qubo

################## Graph Generation, QUBO &amp; QuadracticProgram Formulation #######
erdos_14_7_456 = gp.weighted_erdos_graph(12,0.7,456)
erdos_14_array=  convert_to_array(own_maximum_weighted_independent_set_qubo(erdos_14_7_456))
qp = the_auto_doco_mod(erdos_14_array,'Erdos 14',2)


######### Setting up the Statevector Simulator #######

aqua_globals.random_seed = np.random.default_rng(123)
seed = 1456
backend = Aer.get_backend('statevector_simulator')


###### Generating the Circuit #####
quantum_instance = QuantumInstance(backend,seed_simulator=seed, seed_transpiler=seed)

######## Algorithms ########
qaoa = QAOA(quantum_instance=quantum_instance, p = 1)
exact_mes = NumPyMinimumEigensolver()

######### Applying the solvers ########
qaoa_optimizer = MinimumEigenOptimizer(qaoa)
exact = MinimumEigenOptimizer(exact_mes)

##########Â Results ########
qaoa_result = qaoa_optimizer.solve(qp)
print(&quot;Qaoa\n&quot;,qaoa_result)


np_result = exact.solve(qp)
print(&quot;Numpy\n&quot;,np_result)

</code></pre>
<p>This gives the output:</p>
<pre><code>
Qaoa
 optimal function value: -2.2222222222222223
optimal value: [0. 0. 0. 1. 1. 0. 1. 0. 0. 0. 0. 0.]
status: SUCCESS
Numpy
 optimal function value: -2.2222222222222223
optimal value: [0. 0. 0. 1. 1. 0. 1. 0. 0. 0. 0. 0.]
status: SUCCESS

<span class=""math-container"">```</span>
</code></pre>
",<programming><qiskit><simulation><qaoa>,2/28/2021 15:10,16736.0,16736.0,"<p>It turns it out it sure doesn't. I was using the QAOA qiskit method and I think this function takes out the solution bitstring that gives the lowest objective value. As I was trying only for small <span class=""math-container"">$ N $</span>, there would be a decent probability attached to the solution even without the algorithm !</p>
",3/28/2021 17:54,Conceptual,"The user is asking a question about the behavior of the QAOA algorithm, specifically whether it is always able to find the optimal solution when using a statevector simulator. This is a conceptual question because it requires an understanding of the fundamental principles of QAOA and how it works.",Conceptual,,,,Conceptual,
16313.0,"Generally speaking, are quantum speedups always due to parallelization of a given problem?","<p>We know that quantum computers use the wave-like nature of quantum mechanics to perform interference. Sometimes we can use this interference to perform specific algorithms that will cause enough interference to have speedup relative to a classical computer.</p>
<p>But, generally speaking, are quantum speedups always due to parallelization of a given problem?</p>
<p>The converse statement might be more clear: Is there an example of quantum speedup for an algorithm in which the classical equivalent is not parallelizable?</p>
<p>EDIT:
To try to make this even more clear, imagine that I have a classical problem that I will apply some <em>specific classical code</em> to solve (such as searching for a certain element in a list by looping through each element and checking if it matches the described element).</p>
<p>Practically speaking: If I were to optimize this code with a GPU, I would identify what parts of my code can be parallelized. (and I probably wouldn't be thinking of things like P=NP). For GPUs, I don't think I need to solve some general proof about P=NP or  NP = CP in order to get an intuitive sense that GPUs speed up code when things can be parallelized.</p>
<p>Are quantum computers the same? Generally speaking (in the same way I am thinking about GPU speedup), are speedups always do to parallelization?</p>
",<classical-computing><speedup><quantum-advantage>,03/02/2021 21:03,16319.0,16319.0,"<p>I can see what you mean. For the Deutsch problem, we can formulate it (or think of it) in such a way that the goal is to evaluate <span class=""math-container"">$f(0)+f(1)$</span> in base 2. Classically we have to evaluate <span class=""math-container"">$f(0)$</span> and <span class=""math-container"">$f(1)$</span> to get this sum, so we need to do two evaluations of the function to get the answer. A quantum computer only needs to input the superposition state <span class=""math-container"">$\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$</span> <em><strong>once</strong></em> and it gets enough information about what the black box function does to <span class=""math-container"">$|0\rangle$</span> and to <span class=""math-container"">$|1\rangle$</span> individually, in order to be able to evaluate the sum modulo two successfully.</p>
<p><strong>But a classical computer can parallelize the evaluation of <span class=""math-container"">$f(0)$</span> and <span class=""math-container"">$f(1)$</span>.</strong></p>
<p>Are there quantum algorithms that provide a speed-up without this type of parallel evaluation of a function for all possible binary-string inputs?</p>
<p>Well there's an entirely different type of quantum computing called &quot;adiabatic quantum computing&quot; or AQC which does not involve gates or circuits. There's a mathematical proof that it is <a href=""https://arxiv.org/abs/quant-ph/0405098"" rel=""nofollow noreferrer"">equivalent to circuit-based quantum computing</a> in terms of computational power, from the perspective that AQC devices can simulate all circuit-based quantum computing algorithms with an overhead which is only polynomial scaling with respect to the size of the problem.</p>
<p>In AQC, you are solving a problem by efficiently finding the ground state of a Hamiltonian which is <span class=""math-container"">$2^n \times 2^n$</span> in size if there's <span class=""math-container"">$n$</span> qubits. In the case where the Hamiltonian is diagonal in the computational basis, this problem can be parallelized by just checking each possible state in the computational basis, in parallel. However when the Hamiltonian is not diagonal, the only way to solve the problem (in general) on a classical computer is to find the eigenstate with the smallest eigenvalue, which means solving an eigenvalue problem. The solving of an eigenvalue problem <strong>can be parallelized</strong> but not in the way that I think your question is considering. It is not the type of parallelization where we are checking <span class=""math-container"">$2^n$</span> things at the same time, and the speed-up due to parallelization is nowhere near the quantum speed-up. Then since circuit-based quantum computers can also simulate adiabatic quantum computers with overhead that only scales polynomially with respect to the input size, we can argue that circuit-based quantum computers can also solve problems that can't be parallelized (in the sense discussed earlier) on a classical computer: in fact we've had circuit-based algorithms for Hamiltonian simulation since before we knew about the proof that AQC and CBQC were equivalent from a computational complexity perspective.</p>
<p>Essentially, if you want to find the ground state of a molecule's Hamiltonian, or the ground state of some model condensed matter Hamiltonian (for example) like a  Hubbard Hamiltonian, quantum computers (or quantum &quot;simulators&quot;) can do the job more efficiently (from a computational complexity perspective) compared to classical computers, and while classical computers can attempt to solve the problem in parallel, that parallelization is only whatever small amount of parallelization is possible when solving eigenvalue problems.</p>
<p>I don't know if there's any classical computation worth doing on a quantum computer that <em><strong>cannot at all benefit from parallelization</strong></em> because even the multiplication of two scalar numbers like 13.254621 and 17.169920 is parallelized at some level (for example multiple logic gates in hardware are working in parallel), but if we can interpret your question as parallelization in the Deutsch problem sense, then I would say that the answer is yes.</p>
",03/02/2021 23:40,Conceptual," The user is asking a question about the nature of quantum speedup, specifically whether it is always due to parallelization. This is a conceptual question because it requires an understanding of the fundamental principles of quantum computing and how it differs from classical computing.",Conceptual,,,,Conceptual,
16321.0,Should I learn a low-level QC programming language?,"<p>I've referred to some programming language recommendation questions on here, so I thought I'd post a follow-up question here. I'm a total beginner to the field but want to seriously learn it. Is there a low-level, QC-equivalent of assembly language, and is it worth it to learn that at this stage? Do existing QC programming languages provide that low-level functionality?</p>
<p>And a minor second clarification - if I commit to learning any particular framework like Qiskit or Q#/QDK - is there a risk of that framework going obsolete depending on which company wins out in this QC race in the future?</p>
",<programming>,03/03/2021 02:30,16326.0,16326.0,"<p>I will provide answer for IBM Q. There is a language callled QASM. As you can see from the name of the language, it is similar to assembly language known from classical computer.</p>
<p>The language statements are very simple - they involve an operation (i.e. quantum gate) and affected qubits. For example to apply <span class=""math-container"">$X$</span> gate on qubit no. 0, you have to put in <code>x q[0]</code>, for CNOT gate with control qubit no. 0 and target qubit 1, the statement is <code>cnot q[0], q[1]</code> etc. Also special stataments are used for measurement, setting number of qubits in qubit register and bits in classical register. You can also define subroutines which are called <em>custom gates</em>. This all means that you operates on qubit and gate level although logical ones. It is also possible to write a program in QASM using only basic gates which are <span class=""math-container"">$U3$</span> and CNOT on IBM Q (although <span class=""math-container"">$U3$</span> is still not physical gate).</p>
<p>IBM Q also enables you to program a quantum processor with microwave pulses directly (only processor Armonk offers this capability now) which is really physical level, something like programming classical computer by switching particular transistors.</p>
<p>Concerning the possibility of a something going to be obsolete. There is always such risk in any segment of industry, particularly in IT which evolves rapidly.</p>
<p>As I see it, it think to learn QASM/Qiskit is useful as it allows you to get insight how quantum computers work. Then, it would be easy to switch to another language.</p>
",03/03/2021 07:54,Learning,"The user is seeking guidance on the learning path for quantum computing, particularly whether there is a low-level equivalent to assembly language in quantum computing and the potential risks of choosing a particular quantum computing framework. This question falls under the Learning category as it pertains to learning resources and strategies for quantum computing",Learning,,,,Learning,
16409.0,Is there a way to present conjugate transpose of a Y Pauli rotation as a Cirq Operator?,"<p>Given:
Ry(theta) acting on one qubit</p>
<p>I'm trying to use existing Cirq Operators to build the conjugate transpose of the above gate. I need the operator to produce the exact unitary of the given gate for the given theta.</p>
<p>I'v already used cirq.optimizers.single_qubit_matrix_to_gates. It gives YPowGates but the global phase changes with theta. I need either the exact unitary of the gate or another conversion that its global phase does not change with theta.</p>
",<programming><cirq><pauli-gates>,03/08/2021 21:11,16410.0,16410.0,"<p><code>cirq.inverse(operation)</code> will return the conjugate transpose of an operation.</p>
<p>Equivalently, you can use <code>operation**-1</code> (this is the first thing that <code>cirq.inverse</code> tries).</p>
<p>For the specific case of <span class=""math-container"">$R_y$</span>, you can just negate the angle i.e. use <code>cirq.ry(-theta)</code>.</p>
",03/08/2021 21:22,API Usage,The user is asking about how to use the Cirq API to build the conjugate transpose of the Ry(theta) gate and produce the exact unitary of the given gate for the given theta. This involves a specific usage of the Cirq API.,Errors,,,,API Usage,
16413.0,Trying to simulate Weak Value Amplification using QuTiP,"<p>Weak Value Amplification is a procedure in which one consider a bipartite Hamiltonian of the form <span class=""math-container"">$H = g A \otimes B$</span>, where <span class=""math-container"">$A$</span> is called system, <span class=""math-container"">$B$</span> is called meter and <span class=""math-container"">$g$</span> is the extremely small parameter we are interested to measure by amplification.  The procedure goes as follows:</p>
<p>(1) The system and meter is initialized by some initial state <span class=""math-container"">$\vert\Psi\rangle=\vert\psi_{i}\rangle \otimes \vert \phi\rangle$</span>.  The evolution of the system <span class=""math-container"">$U = \exp(-igA \otimes B)$</span> is approximated to <span class=""math-container"">$1_{A}\otimes 1_{B}-ig A\otimes B$</span>, since <span class=""math-container"">$g$</span> is extremely small. we get</p>
<p><span class=""math-container"">$$U\vert\Psi_{i}\rangle\approx(1_{A}\otimes 1_{B}-ig A\otimes B)\vert\psi_{i}\rangle \otimes \vert \phi\rangle,$$</span>
<span class=""math-container"">$$(1_{A}\vert\psi_{i}\rangle\otimes 1_{B}\vert \phi\rangle-ig A\vert\psi_{i}\rangle\otimes B\vert\phi\rangle).$$</span></p>
<p>(2) After the evolution, the system is post selected onto some final state <span class=""math-container"">$\vert\psi_{f}\rangle$</span> (which is nearly orthogonal to the initial state)</p>
<p><span class=""math-container"">$$\langle\psi_{f}\vert U\vert\Psi_{i}\rangle\approx P_{s}(1_{B}\vert\phi\rangle - ig A_{w}B\vert\phi\rangle)$$</span>.</p>
<p>Where <span class=""math-container"">$P_s = \langle\psi_{f}\vert\psi_{i}\rangle$</span> is the post-selection probability and <span class=""math-container"">$A_{w} = \langle\psi_{f}\vert A\vert\psi_{i}\rangle/P_{s}$</span> is called the weak value.</p>
<p>(3)  If i re-exponentiate the above term, we get</p>
<p><span class=""math-container"">$$\frac{\langle\psi_{f}\vert U\vert\Psi_{i}\rangle}{P_{s}}=\exp(-igA_{w}B)\vert\phi\rangle$$</span></p>
<p>where the exponential on the RHS is the Kraus operator acting on the meter intial state, using which one can estimate the small parameter <span class=""math-container"">$g$</span>.</p>
<p>My attempt at solving:</p>
<p>(step 1) I prepare the initial state say <code>psi1</code> and evolved the state according the Hamiltonian using <code>mesolve</code> for a short time <code>t = np.linspace(0, 0.01, 50)</code></p>
<p><code>result = mesolve(H, psi1, t, c_ops = [], e_ops =[])</code></p>
<p>(step 2) The evolved state is <code>result.states[49]</code>, but the problem I am facing is how do I make post-measurement on this with the final state?</p>
<p>One such dumb attempt, I did was taking the final state <code>psif</code> and sandwiched directly with <code>result.states[49]</code> as</p>
<p><code> eta = psif.dag()*result.states[49]</code></p>
<p>But my objective was to do the post-selection at a specific time, like say I weakly evolve the system for a short time say 0 to 0.1 seconds and do post-selection exactly at 0.05th second.  I am really lost what to do from my (step 1).  Is there a way to do post-selection in QuTiP at a specific time?</p>
",<programming><qutip>,03/09/2021 04:34,17681.0,17681.0,"<p>The state evolved at all of the time points in <code>t[i]</code> are stored in <code>results.states[i]</code>. You can use this to find the exact post-selected state and the exact post-selection probability by looking directly at the &quot;sandwiches&quot; <code>psif.dag()*result.states[i]</code> that you mention.</p>
<p>But QuTiP gives an error about incompatible object sizes if you do this operation, which seems mathematically fine! That is because it prefers that you operate on states in the composite Hilbert space with things defined on the composite Hilbert space. Thus, instead of the shorthand definition of <span class=""math-container"">$\langle\psi_f|U|\Psi_i\rangle$</span>, we are really using <span class=""math-container"">$$\left(\langle\psi_f|\otimes \mathbb{I}\right)U|\Psi_i\rangle.$$</span> If we define my <code>psif</code> as your <code>psif</code> tensored with the identity on the second Hilbert space, everything will work nicely.</p>
<p>So: the unnormalized post-selected state at time point <code>t[i]</code> can be found through
<code>tensor(psif,qeye(N)).dag()*result.states[i]</code>, where <code>N</code> is the dimension of the Hilbert space on of the meter. You can verify that this gives <code>psi1</code> when you <span class=""math-container"">$i=0$</span>.</p>
",5/27/2021 19:35,Errors,"The user is seeking solutions and explanations for a perceived error or misunderstanding in their quantum program development, specifically regarding the implementation of post-selection in QuTiP at a specific time",Errors,,,,Errors,
16419.0,Memory Requirements for Qiskit Aer Simulator,"<p>I'm trying to work out how much memory is used for simulations of different sizes using the Aer simulator.</p>
<p>Here are my calculations:</p>
<p><span class=""math-container"">$$ \text{Number of Qubits} = n $$</span>
<span class=""math-container"">$$ \text{Number of Amplitudes} = 2^{n} $$</span>
<span class=""math-container"">$$ \text{Array Size } = {2^n}^2 = 2^{2n} $$</span>
<span class=""math-container"">$$ \text{ Memory in Bytes needed for double precision complex number } = 16 $$</span>
<span class=""math-container"">$$ \text{ Memory needed (Bytes)} = 16 *2^{2n}  $$</span></p>
<p><a href=""https://i.stack.imgur.com/76LWx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/76LWx.png"" alt=""Workbook"" /></a></p>
<p>(I'm a bit confused at the exact definition of a GB of ram whether it's in powers of ten or two)</p>
<p>From this, simulations of circuits with over 18 qubits are rather difficult.</p>
<p>My questions are these:</p>
<ol>
<li>Are these calculations correct ?</li>
<li>Does this stand true for both the shot based 'qasm-simulator' and 'statevector' simulator?</li>
<li>AER is well coded: does it have simplifications like those described in the solution to this answer (<a href=""https://quantumcomputing.stackexchange.com/questions/50/how-much-memory-is-required-to-simulate-a-48-qubit-circuit"">How much memory is required to simulate a 48-qubit circuit?</a>)?</li>
</ol>
<p>I realise that my calculations are the worse case scenario. I think the statevector matrix would be upper triangular and so at least half of the amplitudes would be 0, meaning there would be at least some memory gained through sparse matrices !
Thank-You !</p>
",<programming><qiskit><ibm-q-experience><simulation>,03/09/2021 12:02,16425.0,16425.0,"<ol>
<li>Your calculations section looks correct but I think your spreadsheet is incorrect. For example if you do 16 bytes * (2^21) that's 33554432 bytes or.0336 GB or 33.6 MB. Things go quickly though for a 32 qubit simulation 16 bytes * (2^32) is 68.72 GB. You can also look at the aer source code it's using this calculation for the required memory for a statevector: <a href=""https://github.com/Qiskit/qiskit-aer/blob/1a6d5df89a2e016afbb33a2d7088e6100348a7c4/src/simulators/statevector/qubitvector.hpp#L813-L819"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aer/blob/1a6d5df89a2e016afbb33a2d7088e6100348a7c4/src/simulators/statevector/qubitvector.hpp#L813-L819</a></li>
<li>The difference between the <code>qasm-simulator</code> and <code>statevector-simulator</code> are primarily in return type. The statevector simulator and the qasm simulator (when using the statevector simulation method) work in the same way the only difference is that the statevector simulator returns the statevector instead of computing the measurement counts. However, the qasm simulator offers multiple simulation methods  (see: <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.QasmSimulator.html#qiskit.providers.aer.QasmSimulator"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.providers.aer.QasmSimulator.html#qiskit.providers.aer.QasmSimulator</a> for a list) which will have different memory and resource requirements. For example, if your circuit is made up of cliffords you can use the stabilizer simulation method and the memory requirements are much lower.</li>
<li>That specific method is not implemented in qiskit aer to my knowledge (since it's very application specific)</li>
</ol>
",03/09/2021 14:59,Conceptual,"The user is seeking clarification and insight into the memory usage calculations and whether there are optimizations or simplifications in the Aer simulator, making it suitable for a conceptual discussion about the topic.So falls under the ""Conceptual"" category.",Theoretical,"The user is asking about theoretical concepts related to quantum computing, specifically the memory usage for simulations of different sizes using the Aer simulator",No,105.0,Conceptual,"The user seeks clarification on memory usage calculations and potential optimizations in the Aer simulator, aligning with the conceptual understanding of quantum simulation memory requirements."
16421.0,Classical algorithm with complexity similar to Shor's discovered: Are there more efficient quantum algorithms than Shor's?,"<p>In the article <a href=""https://eprint.iacr.org/2021/232.pdf"" rel=""nofollow noreferrer"">Fast Factoring Integers by SVP Algorithms</a> the author claims that he discovered <strong>classical</strong> algorithm for factoring integers in polynomial time. The Quantum Report mentioned <a href=""https://quantumcomputingreport.com/german-researcher-claims-to-have-found-a-fast-classical-algorithm-for-factoring-large-integers/"" rel=""nofollow noreferrer"">here</a> that it has similar performance to Shor algorithm which is often considered to ignite interest in quantum computers.</p>
<p>Of course, the new classical algorithm has to be examined closely before it is confirmed that it is really so fast as claimed.</p>
<p>However, I would like to know if there are other quantum algorithms besides Shor and quantum binary optimization based.</p>
<p>Has it been proven that Shor algorithm is optimal or could there be another even faster quantum algorithms for integers factoring?</p>
",<algorithm><complexity-theory><classical-computing><shors-algorithm>,03/09/2021 13:59,16433.0,16433.0,"<p>Shor's algorithm is often quoted as having a cost of  <span class=""math-container"">$\mathcal{O}(\log^3 n)$</span> quantum operations, though it's actually a bit smaller than that: <span class=""math-container"">$\mathcal{O}\left((\log n)^{2} (\log \log n) (\log \log \log n) \right)$</span>, but since <span class=""math-container"">$\log \log n &lt; \log n$</span> we know that the &quot;verbose&quot; cost is less than the often quoted cost of <span class=""math-container"">$\mathcal{O}(\log^3 n)$</span>.</p>
<p>There's no proof that  <span class=""math-container"">$\mathcal{O}\left((\log n)^{2} (\log \log n) (\log \log \log n) \right)$</span> is optimal, and I wouldn't be surprised if someone came up with a version that costs only <span class=""math-container"">$\mathcal{O}\left((\log n)^{2} (\log \log n) (\log \log \log n \log n) \right)$</span> (there's one extra <span class=""math-container"">$\log n$</span>).</p>
<p>However I find myself reminded right now of <a href=""https://cs.uwaterloo.ca/about/people/shalevb"" rel=""noreferrer"">Shalev Ben-David</a>'s talk at the Aspen conference for which I was the session chair, in 2016 when he was still a PhD student of Scott Aaronson. He had a slide that said &quot;<em>real</em> computer scientists only care about exponential speed-ups&quot; (with emphasis on &quot;real&quot; in the original version too). That might be a bit of an exaggeration, but a slightly less strong version of that statement will lead you to my main point here, which is that no one has yet been able to reduce the power from  <span class=""math-container"">$\mathcal{O}(\log^3 n)$</span> to <span class=""math-container"">$\mathcal{O}(\log^{\color{red}{2}} n)$</span>. In that sense, Shor's algorithm is still the most &quot;efficient&quot; in terms of the power of <span class=""math-container"">$\log n$</span> appearing in the number of quantum gates required.</p>
<p>There's plenty of work that's been done on reducing the <em><strong>exact</strong></em> number of gates (here the constant under the &quot;Big Oh&quot; now matters), and also plenty of work done on reducing the number of total qubits needed.</p>
<p>One somewhat recent paper title that comes to my mind is Craig Gidney's &quot;<a href=""https://arxiv.org/abs/1706.07884"" rel=""noreferrer"">Factoring with <span class=""math-container"">$n+2$</span> clean qubits and <span class=""math-container"">$n-1$</span> dirty qubits</a>&quot; and &quot;<a href=""https://arxiv.org/abs/1905.09749"" rel=""noreferrer"">How to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubits</a>&quot; (also by <a href=""https://quantumcomputing.stackexchange.com/users/119/craig-gidney"">Craig Gidney</a>).</p>
",03/09/2021 23:52,Theoretical,"The user is asking about the theoretical aspects of quantum computing, specifically whether there are quantum algorithms for integer factoring that are faster or more efficient than Shors algorithm. This involves understanding the principles and limitations of quantum algorithms.",Theoretical,,,,Theoretical,
16447.0,Quantum implementation of arcsin,"<p>I am looking to implement a quantum version of the arcsinus function. Such a problem is motivated by the HHL algorithm where <span class=""math-container"">$x\mapsto 1/x$</span> and <span class=""math-container"">$\arcsin$</span> can be used to get <span class=""math-container"">$1/x$</span> from the computational basis state into the amplitude.</p>
<p>My questions are based on the paper Optimizing Quantum Circuits for Arithmetic (arxiv link :<a href=""https://arxiv.org/abs/1805.12445"" rel=""noreferrer"">https://arxiv.org/abs/1805.12445</a>).
Their idea is to use a polynomial approximation of the function <span class=""math-container"">$f$</span> and to partition the domain <span class=""math-container"">$\Omega$</span> of study of <span class=""math-container"">$f$</span> :
<span class=""math-container"">$$ 
\Omega = \bigcup_{i=1}^M \Omega_i \quad \Omega_i\cap \Omega_j = \emptyset \, \forall i \neq j
$$</span>
and then perform a case distinction for each input, evaluating a different polynomial for <span class=""math-container"">$x\in \Omega_i$</span> and <span class=""math-container"">$y\in \Omega_j$</span>, <span class=""math-container"">$i\neq j$</span>. <span class=""math-container"">$M$</span> is chosen in order to achieve a certain precision and the degree of the polynomials are all bounded by a constant <span class=""math-container"">$d$</span>.</p>
<p>Evaluating a single polynomial <span class=""math-container"">$P(x) = \sum_{i=0}^d a_ix^i$</span> can be done using the Horner scheme, where one iteratively performs a multiplication by <span class=""math-container"">$x$</span> and an addition by <span class=""math-container"">$a_i$</span> for <span class=""math-container"">$i\in \{d, d-1, \cdots 0\}$</span> :</p>
<p><span class=""math-container"">$$ a_d \mapsto a_dx+a_{d-1} \mapsto a_dx^2+a_{d-1}x + a_{d-2} \mapsto \cdots \mapsto P(x)$$</span></p>
<p>At iteration <span class=""math-container"">$i$</span>, the last iterate is added by <span class=""math-container"">${a_i}$</span>, while this does not represent any difficulty in classical computing, a register has to hold the set of coefficients <span class=""math-container"">${a_i}$</span>, and has to be changed at each iteration. In their paper, the authors assume that <span class=""math-container"">$\mathrm{NEXT}_a$</span> implements such an operation.</p>
<p><a href=""https://i.stack.imgur.com/BE0P8.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/BE0P8.jpg"" alt=""enter image description here"" /></a></p>
<p><strong>My question</strong> : How can one implement efficiently the function <span class=""math-container"">$\mathrm{NEXT}_a$</span> ?</p>
",<programming><quantum-gate><qiskit><algorithm><hhl-algorithm>,03/10/2021 15:56,18231.0,18231.0,"<blockquote>
<p>How can one implement efficiently the function <span class=""math-container"">$\text{NEXT}_a$</span>?</p>
</blockquote>
<p>According to the paper, <span class=""math-container"">$\text{NEXT}_a$</span> is just switching between loaded data that is indexed by the <span class=""math-container"">$\ell$</span> register:</p>
<blockquote>
<p><span class=""math-container"">$\text{NEXT}_a$</span> changes the register to hold the next set of coefficients <span class=""math-container"">$\sum \ell |\ell \rangle |a_\ell,iâ1\rangle â \sum \ell |\ell \rangle |a_\ell,iâ1\rangle$</span></p>
</blockquote>
<p>In other words, there is some classical data that is indexed by a quantum register <span class=""math-container"">$\ell$</span> and a classical index <span class=""math-container"">$i$</span>. We're unloading the data for index <span class=""math-container"">$i-1$</span> and loading the data for index <span class=""math-container"">$i$</span>. (Alternatively, the difference between them is being xored into register.) Loading/unloading/xoring classical data indexed by a quantum register is done using what are called &quot;QROM circuits&quot;.</p>
<p>There's a simple space efficient QROM defined in <a href=""https://arxiv.org/abs/1805.03662"" rel=""nofollow noreferrer"">&quot;Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity&quot;</a></p>
<p><a href=""https://i.stack.imgur.com/UU6EE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UU6EE.png"" alt=""enter image description here"" /></a></p>
<p>I have a <a href=""https://github.com/Strilanc/windowed-quantum-arithmetic/blob/master/anc/qsharp/WindowedArithmetic/Lookup.qs"" rel=""nofollow noreferrer"">tested implementation of this QROM in Q-sharp on github</a>.</p>
<p>If you have additional space available (including borrowed dirty qubits) you can use techniques from <a href=""https://arxiv.org/abs/1812.00954"" rel=""nofollow noreferrer"">&quot;Trading T-gates for dirty qubits in state preparation and unitary synthesis&quot;</a> to get the T count down from O(num_addresses) to O(sqrt(num_addresses * output_size)), assuming that's smaller.</p>
<p><a href=""https://i.stack.imgur.com/EW2uY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EW2uY.png"" alt=""enter image description here"" /></a></p>
<p>It looks like <a href=""https://github.com/qsharp-community/qram/blob/master/src/SelectSwapQrom.qs"" rel=""nofollow noreferrer"">there's also qsharp code for this one on github</a>.</p>
",07/01/2021 09:39,Theoretical,"The user is asking about theoretical concepts related to quantum computing, specifically the efficient implementation of the NEXT_a function.",Theoretical,,,,Theoretical,
16490.0,Is there a way to use titles on circuit drawing?,"<p>As you may know, one can use barriers in Qiskit to seperate gates on a circuit in a proper way. So, I was wondering is there a way to give a title to these &quot;sections&quot; seperated by barriers?</p>
<p>I provide an example in Figure below. Titles does not need to be exactly same with the ones in the Figure. It is just an example.</p>
<p><a href=""https://i.stack.imgur.com/K97uM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/K97uM.png"" alt=""enter image description here"" /></a></p>
",<programming><qiskit><quantum-circuit>,3/13/2021 14:42,16493.0,16493.0,"<p>The short answer is that the circuit drawer does not have a way to label &quot;sections&quot;.</p>
<p>However, you can pass an arbitrary <code>matplotlib.axes.Axes</code> to the Matplotlib circuit drawer (only to that circuit drawer) where you can set and position your labels by hand. For your particular case, it looks something like this:</p>
<pre><code>from matplotlib.pyplot import figure

fig = figure()
ax = fig.add_subplot()
height = 0.8
ax.text(-0.9, height, 'entanglement', size=14)
ax.text(2.5, height, 'init', size=14)
ax.text(4.5, height, 'transfer of\namplitudes', size=14)
ax.text(7, height, 'measurement', size=14)

circuit.draw('mpl', ax=ax)
</code></pre>
<p><a href=""https://i.stack.imgur.com/HR7IG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HR7IG.png"" alt=""enter image description here"" /></a></p>
<p>You might have to adapt the <code>x</code> and <code>y</code> numbers (the first two parameters for <code>text</code>) to readjust their position.</p>
",3/13/2021 19:16,API Usage,"The user is inquiring about whether there is a way to give titles to sections separated by barriers in Qiskit circuits, which is related to the usage of the Qiskit API for circuit visualization and organization.",API Usage,,,,API Usage,
16501.0,How to initialize a qubit with a custom state in Qiskit Composer,"<p>I'm trying to initialize a qubit with a custom state in IBM's Qiskit Composer. I wrote the code in the Qiskit Lab and obtained the QASM code as shown below</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q0[1];
creg c[1];

initialize(0.5,0.8660254) q0[0];
</code></pre>
<p>This is giving error stating <code>initialize</code> is not defined. What's the way to initialize a qubit with a custom value in Qiskit Composer?</p>
",<programming><qiskit><quantum-state><ibm-q-experience>,3/14/2021 6:18,16503.0,16503.0,"<p>What you can do is use qiskit to decompose the circuit with the initialize instruction to elementary gate, then print out the QASM code that you can paste into the Composer.</p>
<p>For example: Using the vector you want to initialize, I can do</p>
<pre><code>from qiskit import QuantumCircuit, IBMQ
import numpy as np
num_qubits = 1
vector = [0.5,0.8660254]
initial_state = vector/np.linalg.norm(vector)
circuit = QuantumCircuit(num_qubits,num_qubits)
circuit.initialize(initial_state, 0)  
print(circuit)
qasm_circuit = circuit.decompose().decompose().decompose() 
print(qasm_circuit)

     âââââââââââââââââââââââââââ
q_0: â¤ initialize(0.5,0.86603) â
     âââââââââââââââââââââââââââ
c: 1/âââââââââââââââââââââââââââ
                                
          ââââââââââââ
q_0: â|0&gt;ââ¤ RY(2Ï/3) â
          ââââââââââââ
c: 1/âââââââââââââââââ
</code></pre>
<p>Then now, if I do:</p>
<pre><code>print(qasm_circuit.qasm())
</code></pre>
<p>then I will get</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
qreg q[1];
creg c[1];
reset q[0];
ry(2*pi/3) q[0];

</code></pre>
<p>You can now paste the QASM code to the Composer and continue on with your circuit construction.</p>
",3/14/2021 7:07,API Usage,"The user is asking about how to use a specific feature in Qiskit, specifically how to initialize a qubit with a custom state in IBMs Qiskit Composer. ",API Usage,,,,API Usage,
16509.0,What all parameters can we take into account when comparing different quantum programming languages,"<p>I am planning to write a paper which compares Qiskit and Q# in the following circuits/algorithms</p>
<ul>
<li><p>Bell circuits</p>
</li>
<li><p>Controlled swap to test similarity of two registers</p>
</li>
<li><p>Phase kickback between two qubits</p>
</li>
<li><p>Deutsch-Jozsa algorithm</p>
</li>
<li><p>Grovers algorithm</p>
</li>
<li><p>Simons algorithm</p>
</li>
<li><p>Shors algorithm (slightly advanced for me)</p>
</li>
</ul>
<p>What all parameters apart from time and space complexity can I take to compare these languages</p>
",<programming><qiskit><algorithm><q#>,3/14/2021 19:38,16513.0,16513.0,"<p>Just as with classical computing, we don't expect that in quantum computing the choice of a programming language will have a direct effect on the time and space complexity of most algorithms. That is, while C, Python, Rust, and Swift are all very different programming languages, quicksort is a <span class=""math-container"">$O(n \ln n)$</span> algorithm in all of them. Rather, classical languages tend to be compared on the basis of whether they are low-level or high-level, how easy they are to work with, what safety they provide the programmer (e.g.: it's more difficult to segfault in Python or Rust than in C), and so forth.</p>
<hr />
<p>If you're interested in more resources comparing quantum languages, you may find <a href=""https://www.nature.com/articles/s42254-020-00245-7"" rel=""noreferrer"">https://www.nature.com/articles/s42254-020-00245-7</a> helpful. I also have a look together with Sarah Kaiser on Q# coming out soon that you may find interesting as well: <a href=""https://bit.ly/qsharp-book"" rel=""noreferrer"">https://bit.ly/qsharp-book</a></p>
",3/15/2021 0:00,Theoretical,"The user is asking about theoretical concepts related to quantum computing, specifically the parameters that can be used to compare Qiskit and Q# in various quantum circuits and algorithms.",Theoretical,,,,Theoretical,
16518.0,"Best way to compute $\langle a|B|a \rangle$ in Cirq, where a is a state obtained running circuit A. And B is a different Quantum Circuit","<p>I am implementing RQAOA in Cirq.
After running regular QAOA to find an optimal state <code>a</code> (This I have done successfully).</p>
<p>I need to calculate <span class=""math-container"">$\langle a|Z_iZ_j|a\rangle$</span> for all <span class=""math-container"">$i,j$</span> in <code>MyGraph.edges()</code>.</p>
<p>How should I go about using state a found with the QAOA circuit, to calculate the expectation value of a different circuit with that state?</p>
",<programming><cirq><qaoa>,3/15/2021 10:21,16520.0,16520.0,"<p>If you've already simulated the final state <span class=""math-container"">$|a\rangle$</span>, something like the following should work:</p>
<pre><code>qubits = cirq.LineQubit.range(nqubits)

# qubit order in the observables must match the qubit order in the circuit used to generate |a&gt;
qubit_map = dict(zip(qubits, range(nqubits))) 

for (i, j) in MyGraph.edges():
  # make the Z_i*Z_j observable
  ZiZj = cirq.Z(qubits[i]) * cirq.Z(qubits[j]) 
  # compute desired expectation
  expectation_ZiZj = ZiZj.expectation_from_state_vector(a, qubit_map=qubit_map)
</code></pre>
<p>Also in the expression <span class=""math-container"">$\langle a | B | a \rangle$</span>, <span class=""math-container"">$B$</span> is generally <em>not</em> a quantum circuit, it needs to be an &quot;observable&quot; (Hermitian operator).</p>
",3/15/2021 18:49,API Usage,"The user is asking how to use an existing quantum state (a) obtained from a QAOA circuit to calculate the expectation value of a different circuit (Z_iZ_j) in Cirq. This question relates to the usage of the Cirq API and performing quantum operations, making it suitable for the API Usage category.",API Usage,,,,API Usage,
16521.0,"In Cirq, how do you display circuit diagrams that are ""prettier"" than the ones displayed by default?","<p>This is a duplicate of a question that was asked on the <a href=""https://github.com/quantumlib/Cirq/issues/3885"" rel=""nofollow noreferrer"">Cirq issues page</a>. I'm duplicating this question to increase it's visibility.</p>
",<programming><cirq>,3/16/2021 2:49,33577.0,33577.0,"<p>The standard way to print circuits in Cirq is by calling <code>print(circuit)</code>: which prints the text diagram representation of the circuit. A &quot;prettier&quot; representation can be displayed with <code>SVGCircuit</code>. In a Jupyter notebook,</p>
<pre class=""lang-python prettyprint-override""><code>import cirq
from cirq.contrib.svg import SVGCircuit

a, b = cirq.LineQubit.range(2)
SVGCircuit(cirq.Circuit(cirq.X(a), cirq.CNOT(a,b)))
</code></pre>
<p>outputs:
<a href=""https://i.stack.imgur.com/Kzsu1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Kzsu1.png"" alt=""enter image description here"" /></a></p>
<p><code>SVGCircuit</code> is a work-in-progress. Please add comments explaining what problems you run into on the <a href=""https://github.com/quantumlib/Cirq/issues/2313"" rel=""nofollow noreferrer"">Circuit.<em>repr_svg</em> with nice diagrams for ipython</a> issue.</p>
",7/26/2023 8:10, Errors,"This question relates to the duplication of a question asked on the Cirq issues page, which typically involves seeking a resolution or clarification for an error or issue related to the use of the Cirq framework.", Errors,,,, Errors,
16544.0,Can I simultaneously plot 2 vectors on a single Bloch sphere and rotate the angle of visualization?,"<p>I'm trying to plot 2 vectors on the same Bloch sphere. From the qiskit documentation <a href=""https://qiskit.org/documentation/stubs/qiskit.visualization.plot_bloch_vector.html"" rel=""noreferrer"">here</a>, we can find <code>plot_bloch_vector(bloch, title='', ax=None, figsize=None, coord_type='cartesian')</code>. So I'm not quite sure if we could plot 2 vectors (say <code>[0,0,1]</code> and <code>[0,1,0]</code>) on the same Bloch sphere.</p>
<p>Also, from the default visualization angle, some vectors might look like they're overlapping with the x-axis (e.g the figure below). Can I switch to another angle to visualize the sphere?</p>
<p><a href=""https://i.stack.imgur.com/z8Xz3.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/z8Xz3.png"" alt=""enter image description here"" /></a></p>
<p>Thanks for the help:)</p>
",<programming><qiskit><bloch-sphere>,3/17/2021 16:19,16548.0,16548.0,"<p>If you are on a Jupyter notebook, you can use kaleidoscope for that. It has a <code>block_sphere</code> function that does exactly that. See <a href=""https://qiskit.org/documentation/stubs/qiskit.visualization.plot_bloch_vector.html"" rel=""noreferrer"">the documentation for more info</a>. To install it <code>pip install kaleidoscope</code>.</p>
<p>You can set several vectors in the sphere that can be rotated with the mouse.</p>
<pre><code>from kaleidoscope import bloch_sphere

bloch_sphere([[0,1,0], [0,0,1]])
</code></pre>
<p><a href=""https://i.stack.imgur.com/qCp4O.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/qCp4O.png"" alt=""enter image description here"" /></a></p>
",3/17/2021 16:54,Tooling,"The question pertains to the usage of a specific function in Qiskit, specifically the plot_bloch_vector function, and seeks guidance on plotting multiple vectors on a Bloch sphere using this tool, making it related to tooling and software usage in quantum programming.",Tooling,,,,Tooling,
16595.0,How to use QFT operation in Q#?,"<p>I see the <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.qft"" rel=""nofollow noreferrer"">QFT operation</a> in the document given by Microsoft, but I don't know how to call it.</p>
<pre><code>operation QFT (qs : Microsoft.Quantum.Arithmetic.BigEndian) : Unit is Adj + Ctl
</code></pre>
<p>Does this method need to be rewritten? How to set the parameters here? Can I have a brief example?</p>
",<programming><q#><quantum-fourier-transform>,3/20/2021 7:35,16601.0,16601.0,"<p><a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arithmetic.bigendian"" rel=""nofollow noreferrer"">BigEndian</a> is a data type that is effectively just a wrapper for an array of qubits. If you want to apply QFT to a qubit array <code>register</code>, you need to convert it to <code>BigEndian</code> first:</p>
<pre><code>QFT(BigEndian(register));
</code></pre>
",3/20/2021 18:34,API Usage,"The user is asking about how to use a specific function from the Microsoft Quantum library, which falls under the usage of APIs in quantum programming. ",API Usage,,,,API Usage,
16599.0,"IBM Quantum Experience complains ""Circuit needs at least one measure."" But, the circuit does have one!","<p>I want to run this simple test on the IBM quantum computer <em>ibmq_lima</em>, but it complains about the measurement. As you can see, there is one &quot;measure&quot;. The weird part is that it works if I change the &quot;U&quot; gate to &quot;u3&quot; gate. But, the &quot;U&quot; is a valid gate according to the OpenQASM 2.0 spec!</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[1];
creg c[1];

h q[0];
U(1,2,3) q[0];
measure q[0] -&gt; c[0];
</code></pre>
",<programming><ibm-q-experience>,3/20/2021 16:45,16623.0,16623.0,"<p><strong>TL;DR</strong> There is a bug in the composer (already reported to the composer developers) that do no aliases <code>U</code> and <code>u</code> (neither <code>CX</code> and <code>cx</code>). You can use Qiskit, either locally or in the <em>IBM Quantum Lab</em> to read this totally valid QASM.</p>
<pre><code>qasm = &quot;&quot;&quot;
OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[1];
creg c[1];

h q[0];
u(1,2,3) q[0];
measure q[0] -&gt; c[0]; 
&quot;&quot;&quot;

circuit = QuantumCircuit.from_qasm_str(qasm)
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/McYnz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/McYnz.png"" alt=""enter image description here"" /></a></p>
<p>Qiskit does have the aliasing <code>U</code>/<code>u</code>  and <code>CX</code>/<code>cx</code>. For example, you can transpile and works as expected:</p>
<pre><code>transpile(circuit, basis_gates=['u', 'h'], optimization_level=0).draw()
</code></pre>
<p><a href=""https://i.stack.imgur.com/wGUA5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wGUA5.png"" alt=""enter image description here"" /></a></p>
<hr />
<h2>Some background</h2>
<p>The <code>U</code> gate is defined in the <a href=""https://arxiv.org/abs/1707.03429"" rel=""nofollow noreferrer"">OpenQASM 2.0 specification</a>, together with <code>CX</code>, as an <em>abstract gate</em>. <code>U</code> and <code>CX</code> are a universal basis and all the other gates can be defined as a combination of them.</p>
<p>However, they are not meant to be used directly and the composer does not list them as available gates:</p>
<p><a href=""https://i.stack.imgur.com/QMYRG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QMYRG.png"" alt=""available gates"" /></a></p>
<p>&quot;<em>But if it is right there! the last one is a clear <code>U</code></em>&quot; you are probably saying. And you are not wrong. As <a href=""https://quantumcomputing.stackexchange.com/a/16600/1859"">explained by @KAJ226</a>, gates are usually detonated with capital letters and non-abstract QASM gates use small-case. As a consequence, the confusion.</p>
",3/22/2021 9:53,API Usage,"The user is asking about how to use a specific feature in IBMs quantum computer ibmq_lima, specifically why the U gate is not working as expected according to the OpenQASM 2.0 specification.",API Usage,,,,API Usage,
16603.0,"Uploading 20,000 lines of code to IBM Quantum Composer stalls","<p>It is a simple 5 bit circuit, but it has 20,000 lines of QASM code. I try to put it in the composer, but the &quot;Saving...&quot; beside the file name will stay there for hours. I never saw its completion.</p>
<p>&quot;Saving...&quot; usually transition to &quot;Saved&quot; in a few seconds if the file has 100 lines of code.</p>
<p>Has anybody succeeded in running a large file? How long do you have to wait to see the &quot;Saved&quot;?</p>
",<programming><ibm-q-experience>,3/20/2021 21:31,16617.0,16617.0,"<p>Indeed, the composer does not support such a deep circuit. While, the error is counterintuitive (I reported that to the the composer developers already) it kind of makes sense that you are unable to load a circuit with ~20K gates. The composer is useful for toy examples and to simulate the circuit &quot;live&quot; in the browser. <a href=""https://quantumcomputing.stackexchange.com/questions/16603/uploading-20-000-lines-of-code-to-ibm-quantum-composer-stalls?noredirect=1#comment23304_16603"">As you noticed</a>, simulating the situation you are describing is impractical.</p>
<p>More generally, the situation you are describing is not practical on real hardware neither. <a href=""https://quantumcomputing.stackexchange.com/questions/16603/uploading-20-000-lines-of-code-to-ibm-quantum-composer-stalls?noredirect=1#comment23286_16603"">As explained</a>, 20K gates is a lot for the current state of the art of quantum hardware.</p>
<p>In any case, I suggest you to use <em>IBM Quantum Lab</em> for non-toy situations.</p>
<p>Here is how to load a QASM file and run it in real hardware using the IBM Quantum Lab:</p>
<ol>
<li><p>Go to <a href=""https://quantum-computing.ibm.com/lab/"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/lab/</a></p>
</li>
<li><p>Upload your QASM file (<code>long.qasm</code> in my case) to the environment:
<a href=""https://i.stack.imgur.com/Azker.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Azker.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>In the notebook (the default has many useful imports already), load the file:</p>
</li>
</ol>
<pre><code>circuit = QuantumCircuit.from_qasm_file('long.qasm')  # Creates a circuit from the QASM file
sum(circuit.count_ops().values())  # Total amount of gates to be sure that's your big circuit
</code></pre>
<ol start=""4"">
<li>Get the least busy device that is not a simulator and have enough qubits to execute your circuit (5 in this case)</li>
</ol>
<pre><code>from qiskit.providers.ibmq import least_busy
least_busy_device = least_busy(provider.backends(
    simulator=False, filters=lambda b: b.configuration().n_qubits &gt;= 5))
</code></pre>
<ol start=""5"">
<li>Execute the circuit in the device:</li>
</ol>
<pre><code>job = execute(circuit, least_busy_device)
</code></pre>
<ol start=""6"">
<li>Take a look to the results:</li>
</ol>
<pre><code>counts = job.result().get_counts()  # This might take some time, since your job will be in the queue.
plot_histogram(counts)
</code></pre>
<ol start=""7"">
<li>You will probably see a lot of noise, because of decoherence.</li>
</ol>
",3/21/2021 21:30,Tooling ,"The question is asking about how to use a specific tool, namely the quantum circuit composer, to save a large QASM file.",Tooling ,,,,Tooling ,
16618.0,Can I plot a bigger Bloch sphere using kaleidoscope?,"<p>I'm plotting a vector on the Bloch sphere using kaleidoscope:
<code>from kaleidoscope import bloch_sphere</code>
<a href=""https://i.stack.imgur.com/iOCnS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iOCnS.png"" alt=""enter image description here"" /></a>
Is there a way I can make the plot bigger? (Instead of zooming in) I tried <code>bloch_sphere([0,0,1],figsize=(10, 10))</code> but that doesn't work.</p>
<p>Thanks!!</p>
",<programming><bloch-sphere>,3/22/2021 0:16,16619.0,16619.0,"<p>As this <a href=""https://github.com/JanLahmann/kaleidoscope/blob/master/kaleidoscope/interactive/bloch/bloch3d.py"" rel=""nofollow noreferrer"">documentation shown</a></p>
<p><a href=""https://i.stack.imgur.com/Kj6JF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Kj6JF.png"" alt=""enter image description here"" /></a></p>
<p>by specifying something like <code>bloch_sphere([0,0,1],figsize=(700, 700))</code> will do it for you.</p>
",3/22/2021 3:10,Tooling,"The question pertains to the usage of a specific tool, kaleidoscope, for plotting vectors on the Bloch sphere. The user is seeking guidance on how to adjust the size of the plot, which falls under the category of tooling and software usage in quantum programming.",Tooling,,,,Tooling,
16622.0,From Qiskit QuadraticProgram to problem model accepted by d'wave ocean,"<p>Is there a way to convert <code>QuadraticProgram</code> (<code>qiskit.optimization.problems.QuadraticProgram</code>) to BQM used in D'wave ocean (e.g. <code>dimod.AdjVectorBQM</code>)?</p>
<p>I'd like to use Qiskit to model my programming problem and use converters to deal with integer variables, inequations, etc., then sample this problem on d'wave QPU with annealing schedules. I've noticed d'wave has implemented a plugin that allows Qiskit to access QPU by the <code>DWaveMinimumEigensolver</code>. It seems hardly deal with parameters as a native d'wave sampler.</p>
",<programming><qiskit><d-wave>,3/22/2021 9:22,17419.0,17419.0,"<h1>Direct conversion</h1>
<p>There is a way to convert a QuadraticProgram(QP) from Qiskit into a BinaryQuadraticModel(BQM).
First the QP has to be created with Qiskit. It can have linear constraints, integer variables and binary variables. The objective can have linear and quadratic terms. Quadratic constraints and float variables are not supported in the following workflow. The qiskit-optimization package has a special converter named <a href=""https://github.com/Qiskit/qiskit-optimization/blob/main/qiskit_optimization/converters/quadratic_program_to_qubo.py"" rel=""nofollow noreferrer"">QuadraticProgramToQubo</a>. This convenience converter wraps several conversions. By using the convert method one gets a QP back in QuadraticUnconstrainedBinaryOptimization (QUBO) problem form.
That is, constraints were transformed to be part of the objective function now. Integer variables are mapped to several binary variables.</p>
<p>Now, to transform this into Ocean framework, create a BQM instance with the objective function parts of the QUBO:</p>
<pre><code>bqm_binary = dimod.as_bqm(qubo.objective.linear.to_array(), qubo.objective.quadratic.to_array(), dimod.BINARY)
</code></pre>
<p>This BQM can be submitted to a D-Wave QPU sampler, e.g. <code>result = sampler.sample(bqm_binary, label=&quot;example_qp&quot;, num_reads=1024)</code></p>
<h1>D-Wave Qiskit Plugin</h1>
<p>By using the <a href=""https://github.com/dwavesystems/dwave-qiskit-plugin"" rel=""nofollow noreferrer"">Plugin</a> one can avoid the transformation and especially interpreting of results part.
The use is pretty straightforward. One should be aware, that the plugin was not updated to the new package structure in Qiskit (Aqua to optimization).</p>
<p>Imports:</p>
<pre><code>from qiskit.optimization import QuadraticProgram
from qiskit.optimization.algorithms import MinimumEigenOptimizer
from dwave.plugins.qiskit import DWaveMinimumEigensolver
</code></pre>
<p>Model the QP in Qiskit.</p>
<pre><code>model = QuadraticProgram(&quot;Binary Test&quot;)
</code></pre>
<p>Add variables, constraints and set objective function with linear and quadratic terms.
Use D-Wave QPU as a minimum eigen solver</p>
<pre><code>dwave_solver = DWaveMinimumEigensolver()
optimizer = MinimumEigenOptimizer(dwave_solver)
result = optimizer.solve(model)
</code></pre>
<p>The result is in agreement with the original QP problem. To view the native QPU results use</p>
<pre><code>result.min_eigen_solver_result.sampleset.to_pandas_dataframe()
</code></pre>
<p>For the parameter setting I have opened an issue on the plugins GitHub site, which has been solved: <a href=""https://github.com/dwavesystems/dwave-qiskit-plugin/issues/1"" rel=""nofollow noreferrer"">https://github.com/dwavesystems/dwave-qiskit-plugin/issues/1</a></p>
",05/10/2021 07:25,API Usage," The user is asking about how to convert a specific data structure (QuadraticProgram) from the Qiskit library to another data structure (AdjVectorBQM) used in Dwave ocean, which falls under the usage of APIs in quantum programming. ",API Usage,,,,API Usage,
16655.0,Function in Qiskit to get the quantum circuit,"<p>Is there any way to view the quantum circuit of pre implemented quantum algorithm in Qiskit?
In the Qiskit textbook, there is an <a href=""https://qiskit.org/textbook/ch-applications/hhl_tutorial.html"" rel=""nofollow noreferrer"">example</a> given for HHL algorithm. Is there any function in Qiskit which lets us see the quantum circuit that was used to compute the results(probabilities) for this example?</p>
<p>The code for HHL example is given below:</p>
<pre><code>from qiskit import Aer, transpile, assemble
from qiskit.circuit.library import QFT
from qiskit.aqua import QuantumInstance, aqua_globals
from qiskit.quantum_info import state_fidelity
from qiskit.aqua.algorithms import HHL, NumPyLSsolver
from qiskit.aqua.components.eigs import EigsQPE
from qiskit.aqua.components.reciprocals import LookupRotation
from qiskit.aqua.operators import MatrixOperator
from qiskit.aqua.components.initial_states import Custom
import numpy as np

def create_eigs(matrix, num_auxiliary, num_time_slices, negative_evals):
    ne_qfts = [None, None]
    if negative_evals:
        num_auxiliary += 1
        ne_qfts = [QFT(num_auxiliary - 1), QFT(num_auxiliary - 1).inverse()]

    return EigsQPE(MatrixOperator(matrix=matrix),
                   QFT(num_auxiliary).inverse(),
                   num_time_slices=num_time_slices,
                   num_ancillae=num_auxiliary,
                   expansion_mode='suzuki',
                   expansion_order=2,
                   evo_time=None,  # This is t, can set to: np.pi*3/4
                   negative_evals=negative_evals,
                   ne_qfts=ne_qfts)

def fidelity(hhl, ref):
    solution_hhl_normed = hhl / np.linalg.norm(hhl)
    solution_ref_normed = ref / np.linalg.norm(ref)
    fidelity = state_fidelity(solution_hhl_normed, solution_ref_normed)
    print(&quot;Fidelity:\t\t %f&quot; % fidelity)

matrix = [[1, -1/3], [-1/3, 1]]
vector = [1, 0]

orig_size = len(vector)
matrix, vector, truncate_powerdim, truncate_hermitian = HHL.matrix_resize(matrix, vector)

# Initialize eigenvalue finding module
eigs = create_eigs(matrix, 3, 50, False)
num_q, num_a = eigs.get_register_sizes()

# Initialize initial state module
init_state = Custom(num_q, state_vector=vector)

# Initialize reciprocal rotation module
reci = LookupRotation(negative_evals=eigs._negative_evals, evo_time=eigs._evo_time)

algo = HHL(matrix, vector, truncate_powerdim, truncate_hermitian, eigs,
           init_state, reci, num_q, num_a, orig_size)

result = algo.run(QuantumInstance(Aer.get_backend('statevector_simulator')))
print(&quot;Solution:\t\t&quot;, np.round(result['solution'], 5))

result_ref = NumPyLSsolver(matrix, vector).run()
print(&quot;Classical Solution:\t&quot;, np.round(result_ref['solution'], 5))

print(&quot;Probability:\t\t %f&quot; % result['probability_result'])
fidelity(result['solution'], result_ref['solution'])
</code></pre>
<p>The output is</p>
<pre><code>Solution:            [1.13586-0.j 0.40896-0.j]
Classical Solution:  [1.125 0.375]
Probability:         0.056291
Fidelity:            0.999432
</code></pre>
",<programming><qiskit><hhl-algorithm>,3/23/2021 15:19,16656.0,16656.0,"<p>What you can do to see your circuit here is to use <code>construct_circuit</code>, see <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.HHL.html?highlight=hhl#qiskit.aqua.algorithms.HHL.construct_circuit"" rel=""nofollow noreferrer"">the documentation</a>; notice it can take an optional parameter <strong><code>measurement</code></strong> (bool, indicate whether measurement on ancillary qubit should be performed).</p>
<p>To use it here, what you do is just this</p>
<pre><code>my_hhl_circuit=algo.construct_circuit() #to stock it somewhere if you want
my_hhl_circuit.draw() #draw it
</code></pre>
<p>Don't hesitate to tell me if you need something else!</p>
",3/23/2021 15:31,API Usage,The user is asking about how to use a specific function from the Qiskit library to view the quantum circuit of a pre-implemented quantum algorithm,API Usage,,,,API Usage,
16659.0,Finding Eigen Values from Quantum Phase Estimation - Using qiskit,"<p>I am trying to use the quantum phase estimation(EigsQPE) of qiskit to find the eigen values of a matrix.
As I am new to quantum computing so I am confused what to measure in the circuit to derive the eigen values of the input matrix.</p>
<p>I know how to identify phase and derive eigen value using phase derived from the most probable bit string for a single eigen value. But deriving multiple eigen values from QPE circuit is confusing. Any help will be much appreciated.</p>
<p>Code : <a href=""https://github.com/Anand-GitH/HLL-QauntumComputing/blob/main/Qiskit-QPEStandalone.ipynb"" rel=""nofollow noreferrer"">https://github.com/Anand-GitH/HLL-QauntumComputing/blob/main/Qiskit-QPEStandalone.ipynb</a></p>
",<programming><qiskit><phase-estimation><linear-algebra>,3/23/2021 17:30,16672.0,16672.0,"<p>Two things to note:</p>
<ol>
<li><p>EigsQPE needs the eigenvalues to be scaled onto the range (0,1]. You can use <code>evo_time</code> to set the scaling. If you don't pass this value, a scaling value will be set automatically. You can get this value using <code>eigs.get_scaling()</code>.</p>
</li>
<li><p>If the eigenvalue is <span class=""math-container"">$e^{2\pi i\theta}$</span>, then the register contents will be <span class=""math-container"">$2^n\theta$</span></p>
</li>
</ol>
<p>That means if the register contains the value <span class=""math-container"">$x$</span>, and <code>evo_time</code> equals <span class=""math-container"">$s$</span>, then your eigenvalue will be <span class=""math-container"">$2\pi x/(2^ns)$</span></p>
",3/24/2021 18:28,Theoretical,"The user is asking about the theoretical concept of Quantum Phase Estimation (QPE) and how to derive multiple eigenvalues from a QPE circuit. This falls under inquiries about theoretical concepts, algorithms, and principles in quantum computing",Learning,"The question is seeking guidance and understanding regarding quantum phase estimation (QPE) to find eigenvalues of a matrix. It's related to learning about quantum algorithms and concepts, specifically the QPE algorithm, and how to use it to derive eigenvalues.",No,106.0, Learning,"The user is seeking guidance and understanding regarding quantum phase estimation (QPE) to find eigenvalues of a matrix, indicating a desire to learn and understand quantum algorithms and concepts, particularly the QPE algorithm."
16664.0,How do I export the rightmost state of circuit wires (qbits and cbits) in a qiskit simulation,"<p><code>qiskit</code> has a <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html#simulating-qs"" rel=""nofollow noreferrer"">quantum teleportation tutorial</a> which winds up with this simulation code:</p>
<pre><code>qasm_sim = Aer.get_backend('qasm_simulator')
t_qc = transpile(qc, qasm_sim)
qobj = assemble(t_qc)
counts = qasm_sim.run(qobj).result().get_counts()
plot_histogram(counts)
</code></pre>
<p>The <code>counts</code> are for the 3 qbits in the circuit, which also has 2 cbits.  It would be most helpful to get the rightmost state of the wires in this picture for each shot:
<a href=""https://i.stack.imgur.com/Y67ak.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Y67ak.png"" alt=""qt circuit"" /></a></p>
<p>Is there a function in <code>qiskit</code> which will give me these wire (cbit and qbit) output states?  I looked everywhere on qiskit and with Google search and I didn't find anything.</p>
",<programming><qiskit><simulation>,3/23/2021 21:26,16665.0,16665.0,"<p>To extract the final state, <span class=""math-container"">$|\psi \rangle_{final}$</span>, before the measurement step, which can be represented by the circuit:</p>
<p><a href=""https://i.stack.imgur.com/icI47.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/icI47.png"" alt=""enter image description here"" /></a></p>
<p>You can do:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from qiskit import IBMQ, Aer, execute
import numpy as np

qreg_q = QuantumRegister(3, 'q')
circuit = QuantumCircuit(qreg_q)
vector = [0.603 + 0.625j,0.395 + 0.302j]
initial_state = vector/np.linalg.norm(vector)
circuit.initialize(initial_state, 0)  
circuit.barrier(range(3))
circuit.h(qreg_q[1])
circuit.cx(qreg_q[1], qreg_q[2])
circuit.barrier(range(3))
circuit.cx(qreg_q[0], qreg_q[1])
circuit.h(qreg_q[0])
circuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])
backend = Aer.get_backend(&quot;statevector_simulator&quot;)
result = execute(circuit, backend=backend, shots=1).result()
print('Final State Vector:\n', result.get_statevector() )
</code></pre>
<p>Which will output the final state <span class=""math-container"">$|\psi\rangle_{final}$</span> as:</p>
<pre><code>Final State Vector:
 [ 0.30127969+0.31227166j  0.30127969+0.31227166j  0.19735569+0.15088966j
 -0.19735569-0.15088966j  0.19735569+0.15088966j -0.19735569-0.15088966j
  0.30127969+0.31227166j  0.30127969+0.31227166j]
</code></pre>
<hr />
<p>Now, if you want to extract each individual counts result from an experiment, then you first need to add in the <code>measure</code> like you have on the circuit in your question, then change the <code>backend</code> option to <code>qasm_simulator</code> (shot based simulator instead of exact matrix manipulation). Then execute your circuit and extract the count <strong>at each shot</strong> through specifying the <code>memory</code> to be True.</p>
<pre><code>qreg_q = QuantumRegister(3, 'q')
creg_result1 = ClassicalRegister(1, 'crz')
creg_result2 = ClassicalRegister(1, 'crx')
circuit = QuantumCircuit(qreg_q, creg_result1, creg_result2)
vector = [0.603 + 0.625j,0.395 + 0.302j]
initial_state = vector/np.linalg.norm(vector)
circuit.initialize(initial_state, 0)  
circuit.barrier(range(3))

circuit.h(qreg_q[1])
circuit.cx(qreg_q[1], qreg_q[2])
circuit.barrier(range(3))
circuit.cx(qreg_q[0], qreg_q[1])
circuit.h(qreg_q[0])
circuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])
circuit.measure(qreg_q[0], creg_result1[0])
circuit.measure(qreg_q[1], creg_result2[0])
print(circuit)
</code></pre>
<p><a href=""https://i.stack.imgur.com/PuyaL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PuyaL.png"" alt=""enter image description here"" /></a></p>
<pre><code>backend = Aer.get_backend(&quot;qasm_simulator&quot;)
job = execute(circuit, backend=backend, shots=10, memory=True)
print('result for each shot:', job.result().get_memory() )
</code></pre>
<p>output is:</p>
<pre><code>result for each shot: ['1 0', '0 0', '1 0', '1 0', '0 1', '1 1', '1 1', '0 0', '0 1', '1 0']
</code></pre>
",3/23/2021 22:27, API Usage, The user is asking about how to use a specific function from the Qiskit library to get the output states of both qubits and classical bits in a quantum circuit. This falls under the usage of APIs in quantum programming, API Usage,,,, API Usage,
16673.0,Make a controlled gate from a QuantumCircuit that uses append in Qiskit,"<p>Here is a minimal example for what I want to do:</p>
<pre><code>from qiskit import QuantumCircuit

qc1 = QuantumCircuit(1, name='qc1') 
qc1.x(0)

qc2 = QuantumCircuit(1, name='qc2') 
qc2.h(0)
qc2.append(qc1, [0])
qc2.z(0)

c_qc2 = qc2.to_gate().control(1)
</code></pre>
<p>This gives the following error:</p>
<blockquote>
<p>qiskit.exceptions.QiskitError: 'One or more instructions cannot be converted to a gate. &quot;qc1&quot; is not a gate instruction'</p>
</blockquote>
<p>I'm aware that in this example I can get the desired controlled gate of <code>qc2</code> by manually adding a control qubit to each gate in <code>qc2</code>. However in practice <code>qc2</code> would be complex and doing so would be tiresome.</p>
<p>I also tried <code>qc2.append(qc1.to_instruction(), [0])</code> which didn't solve the problem. Any help is appreciated. Thanks!</p>
",<programming><qiskit>,3/24/2021 18:44,16674.0,16674.0,"<p><strong>Edit:</strong> Miss understood your question earlier. As commented by @Egrettal you can do the following.</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit

qc1 = QuantumCircuit(1, name='qc1') 
qc1.x(0)
print(qc1)


qc2 = QuantumCircuit(1, name='qc2') 
qc2.h(0)
qc2.append(qc1.to_gate(), [0])
qc2.z(0)
print(qc2)


xs_gate = qc2.to_gate()
cxs_gate = xs_gate.control()
circuit = QuantumCircuit(2)
circuit.append(cxs_gate, [0,1])
print('\n New circuit with controlled:\n',circuit)
print('\n Decomposed new circuit:\n', circuit.decompose())
</code></pre>
<p>Which will output:</p>
<pre><code>     âââââ
q_0: â¤ X â
     âââââ


     âââââââââââââââââ
q_0: â¤ H ââ¤ qc1 ââ¤ Z â
     âââââââââââââââââ



 New circuit with controlled:
             
q_0: ââââ âââ
     ââââ´âââ
q_1: â¤ qc2 â
     âââââââ

 Decomposed new circuit:
     ââââââââââ                                                     Â»
q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââââââââââââââââ ââÂ»
     ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââââââââââââââââ´ââÂ»
q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) ââ¤ RY(Ï/4) ââ¤ X âÂ»
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«                      ââââââââ                                       Â»
Â«q_0: âââââââââââââââ âââ¤ P(0) ââââ âââââââââââââââââ âââââââââââââââââ ââÂ»
Â«     âââââââââââââââ´ââââââââââ¤âââ´âââââââââââââââââ´âââââââââââââââââ´ââÂ»
Â«q_1: â¤ RY(-Ï/4) ââ¤ X ââ¤ P(0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X âÂ»
Â«     ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ»
Â«     ââââââââââ                                     
Â«q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââ
Â«     ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââ
Â«q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) â
Â«     âââââââââââââââââââââââââââââââââââââââââââââââ

</code></pre>
",3/24/2021 18:56,API Usage," The user is asking about how to use a specific feature in Qiskit, specifically how to convert a QuantumCircuit to a gate and then control it.",API Usage,,,,API Usage,
16676.0,"In the job tab, no histogram appears","<p>(Newbie here) Accessing IBM Q Experience on a Windows 7 operating system and using the Google Chorme browser. I can completely assemble my circuit, using the IBM Quantum Composer and when executing it goes to the area job, I hope to finish the whole process, but when I press to see the results, only what appears in the image appears, I can't go down the page for the histogram presentation, however when accessing the same Job tab via my cell phone, the histogram and the circuit that was shown appear.</p>
<p>[Screenshot from IBM Q Experience]
<a href=""https://i.stack.imgur.com/hHjs1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hHjs1.jpg"" alt=""enter image description here"" /></a></p>
",<programming><ibm-q-experience><experiment>,3/24/2021 23:11,16677.0,16677.0,"<p>Strange.</p>
<p>This offers a way for you to retrieve your histogram but not exactly the solution to your problem. So hopefully it will be useful somehow.</p>
<p>First, note that each job you submitted has a <code>job_ID</code>. You actually can see it on the top left of your screenshot. You can &quot;copy and paste&quot; this JobID into line 6 of the script below</p>
<pre><code>from qiskit import IBMQ
from qiskit.visualization import plot_histogram
%matplotlib inline
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_santiago')
job = backend.retrieve_job('ENTER JOB_ID HERE')
counts = job.result().get_counts()
plot_histogram(counts, color='black', title=&quot;Result&quot;)
</code></pre>
<p>Executing this script through the Jupyter Notebook provided in Quantum Lab will print out your Histogram. For instance, using a JobID for one of my old job, I printed out the following.</p>
<p><a href=""https://i.stack.imgur.com/hmU6w.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hmU6w.png"" alt=""enter image description here"" /></a></p>
<p>Again, not the exact solution to your question but at least this should provide you a way to retrieve your result, plot it, and not wasting your time having to rerun your experiment to get a new plot.</p>
",3/24/2021 23:35,Tooling,The user is experiencing issues with the IBM Quantum Composer tool on a specific operating system and browser. This falls under questions related to tools and software usage in quantum programming,Tooling,,,,Tooling,
16694.0,How the arguments of $U_3$ gate are converted when they're not lying in the expected range?,"<p>From the qiskit documentation (<a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Single-Qubit-Quantum-states"" rel=""nofollow noreferrer"">here</a>), a general form of a single qubit unitary is defined as
<span class=""math-container"">$$
U(\theta, \phi, \lambda) = 
\begin{pmatrix} 
\cos\left(\frac{\theta}{2}\right) &amp; -e^{i\lambda} \sin\left(\frac{\theta}{2}\right) \\
e^{i\phi} \sin\left(\frac{\theta}{2}\right) &amp; e^{i(\lambda + \phi)} \cos\left(\frac{\theta}{2}\right)
\end{pmatrix}.
$$</span>
Where <span class=""math-container"">$0â¤ðâ¤ð,  0â¤ð&lt;2ð, \text{and} \  0â¤ð&lt;2ð$</span>. However, when I tried to put some arguments out of the range, the gate still operates. For example, if I set <span class=""math-container"">$\theta = -1,\phi=8,\lambda=7$</span>,</p>
<pre><code>simulator = Aer.get_backend('statevector_simulator')
quancir = QuantumCircuit(1)  
quancir.u3(-1,8,7,0)
results = execute(quancir, simulator).result()
resvec = results.get_statevector(quancir)
bloch_sphere([conv(resvec)])
</code></pre>
<p>I can still visualize how the <span class=""math-container"">$U_3$</span> gate operates on the initial state <span class=""math-container"">$|0\rangle$</span>, and plot the final vector:
<a href=""https://i.stack.imgur.com/MP7V3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MP7V3.png"" alt=""enter image description here"" /></a></p>
<p>I'm wondering if my arguments aren't in the expected range, like in this case, what really happened to the <span class=""math-container"">$U_3$</span> gate? Am I still getting the vector I want, or do I need to convert the arguments myself to make sure the output vector is correct? Thanks:)</p>
<p>Update: I tried to take the mod of those parameters but it looks like the output vector is different (points toward the opposite direction):</p>
<pre><code>quancir = QuantumCircuit(1)  
T = float(-1%pi)
P = float(8%(2*pi))
L = float(7%(2*pi))
quancir.u3(T,P,L,0)
results = execute(quancir, simulator).result()
resvec = results.get_statevector(quancir)
bloch_sphere([conv(resvec)])
</code></pre>
<p><a href=""https://i.stack.imgur.com/Ontpa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ontpa.png"" alt=""enter image description here"" /></a></p>
",<programming><qiskit><mathematics><bloch-sphere>,3/25/2021 19:43,16695.0,16695.0,"<p>In this case all input parameters will be mod <span class=""math-container"">$4\pi$</span>, <span class=""math-container"">$2\pi$</span>, and <span class=""math-container"">$2\pi$</span> for <span class=""math-container"">$\theta$</span>, <span class=""math-container"">$\phi$</span>, and <span class=""math-container"">$\lambda$</span> respectively. You will obtain the same vector that you would have received if you took the mod of these parameters yourself.</p>
",3/25/2021 20:16,Errors,The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are trying to understand why the U3 gate operates even when the arguments are out of the expected range.,Errors,,,,Errors,
16702.0,Incorrect rendering of a circuit by draw method,"<p>Executing</p>
<pre><code>from qiskit import *
circuit = qiskit.QuantumCircuit(3, 3)
circuit.draw(output=&quot;mpl&quot;)
</code></pre>
<p>in ipython notebook gives the following image</p>
<p><a href=""https://i.stack.imgur.com/zeIER.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zeIER.png"" alt=""circuit render"" /></a></p>
<p>Which looks incomplete. It does not render two other classical registers and also appears to be incorrectly padded. Is my output image really incorrect? How can I fix that?</p>
",<programming><qiskit>,3/26/2021 13:17,16705.0,16705.0,"<p>This is a <a href=""https://github.com/Qiskit/qiskit-terra/issues/5393"" rel=""noreferrer"">known issue</a> which was <a href=""https://github.com/Qiskit/qiskit-terra/pull/5421"" rel=""noreferrer"">already fixed</a> and will be released in the coming qiskit-terra 0.17.</p>
<pre><code>from qiskit import *
circuit = qiskit.QuantumCircuit(3, 3)
circuit.draw(output=&quot;mpl&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/Ec3UX.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Ec3UX.png"" alt=""enter image description here"" /></a></p>
",3/26/2021 15:08,Tooling,"The question is related to the output rendering of a quantum circuit diagram using Qiskit's visualization tools, specifically the issue of missing classical registers and incorrect padding in the rendered image. This falls under the category of tooling",Tooling,,,,Tooling,
16710.0,"Please help interpret the IBM Quantum error code: ""Instruction bfunc is not supported [7001]""","<p>I have already run the circuit on the IBM Quantum simulators successfully. But, when I ran the same circuit on the real quantum device <em><strong>ibmq_16_melbourne</strong></em>, I got the error. The IBM website does have the <code>7001</code> code definition, but it is not specific enough to indicate what the <code>bfunc</code> means.</p>
<p>Could you please help interpret the code? More important, how can I avoid that to have a successful run?</p>
<p>Thanks.</p>
",<programming><ibm-q-experience>,3/26/2021 23:18,16713.0,16713.0,"<p>A <code>bfunc</code> is a <em>Boolean Function</em>, as defined in the <a href=""https://arxiv.org/abs/1809.03452"" rel=""nofollow noreferrer"">QObj Specification</a> (page 20) and the error <code>7001</code> <a href=""https://quantum-computing.ibm.com/docs/manage/errors#id5"" rel=""nofollow noreferrer"">refers to</a> <code>Instruction {} is not supported</code>.</p>
<p>In other words, <em>the backend <code>ibmq_16_melbourne</code> does not support boolean functions</em>.</p>
<p>Your circuit has, most likely, a classical conditional, something like <code>if (c==0) h q[0];</code> in QASM or a <code>circuit.h(qreg_q[0]).c_if(creg_c, 0)</code> in Qiskit. Conditional are not currently (March 2021) supported by any of the IBM quantum hardware. Although, they supported in many simulators.</p>
",3/27/2021 6:05,Errors,"The user is encountering an error (code 7001) when trying to run a quantum circuit on a real quantum device using IBM Quantum. They are seeking solutions and explanations for this issue, which falls under the category of seeking solutions for errors and exceptions in quantum program development.",Errors,,,,Errors,
16718.0,Measuring entanglement entropy using a stabilizer circuit simulator,"<p>I'm trying to simulate stabilizer circuits using the Clifford tableau formalism that lets you scale up to hundreds of qubits. What I want to do is find the entanglement entropy on by splitting my quantum state (defined as a line of <span class=""math-container"">$N$</span> qubits) at the end of my quantum circuit after applying gates and some measurements. From <a href=""https://arxiv.org/abs/1901.08092"" rel=""noreferrer"">this paper</a>, the authors calculate the entanglement entropy for a state defined by its stabilizers. In particular, I'm looking at Equations 10 (this is their &quot;clipped gauge&quot;), A16 and A17. If <span class=""math-container"">$\mathcal{S}$</span> is the set of stabilizers for the state, then the entropy is given by (Equation A16):</p>
<p><span class=""math-container"">$$S = |A| - \log_2 |\mathcal{S}_A|,$$</span></p>
<p>where <span class=""math-container"">$|A|$</span> is the size of the bipartition of the quantum state and <span class=""math-container"">$\mathcal{S}_A$</span> is the part of <span class=""math-container"">$\mathcal{S}$</span> which acts on <span class=""math-container"">$\bar{A}$</span> with the identity.</p>
<p>I want to simulate my quantum circuit and calculate the entanglement entropy like they do in their paper, but I'm not sure what's the easiest way to do so. A lot of the tools for simulating stabilizer circuits aren't the most transparent to use. In particular, I'm trying to understand how to go from the tableau representation a lot of simulators output and the set of generators I need to calculate the entropy.</p>
<p><strong>Is there a simple procedure to go from the tableau representation to the entropy?</strong> I'm trying to think of how to implement this in code.</p>
<p>For the actual simulator, I see there are a few options. I need measurements, so while Qiskit does offer <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Clifford.html?highlight=stabilizer#qiskit.quantum_info.Clifford.stabilizer"" rel=""noreferrer"">Clifford simulation</a>, I can't seem to do measurements with it. The others that offer a Python interface are:</p>
<ul>
<li><a href=""https://github.com/quantumlib/Stim"" rel=""noreferrer"">Stim</a>, by Craig Gidney.</li>
<li><a href=""https://github.com/Strilanc/python-chp-stabilizer-simulator"" rel=""noreferrer"">Python CHP Stabilizer Simulator</a>, also by Craig Gidney.</li>
<li><a href=""https://github.com/qsharp-community/chp-sim"" rel=""noreferrer"">CHP Sim</a>, by the community for Q#.</li>
</ul>
<p>If anyone has experience with these and can explain how to go from the tableau representation to the calculation of the entropy, that would be great, since these simulators usually seem to be for giving shots in the computational basis.</p>
",<simulation><q#><entropy><stabilizer-state><stim>,3/27/2021 14:08,16837.0,16837.0,"<p>With the help of Craig Gidney and some others, I was able to pin down the procedure to calculate the entropy. Here are the steps.</p>
<h1>Create your circuit with a stabilizer simulator</h1>
<p>This can be done with whatever simulator you want. As Craig mentioned in his answer, <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">Stim</a> is a great tool for the job. The rest of the answer in this section will assume you're using Stim, but it's not required.</p>
<p>Your code will look something like this:</p>
<pre><code>import stim

# Define your circuit here
circuit = stim.TableauSimulator()
...

# Create the tableau representation
tableau = circuit.current_inverse_tableau() ** -1
zs = [tableau.z_output(k) for k in range(len(tableau))]
zs = np.array(zs)
</code></pre>
<p>What you get with <code>tableau</code> is a set of <code>stim.PauliString</code> objects, which are essentially your &quot;stabilizers&quot; and &quot;destabilizers&quot;, to use the language of <a href=""https://arxiv.org/abs/quant-ph/0406196v5"" rel=""nofollow noreferrer"">Aaronson's paper</a> on page 4. For the purposes of the entropy, we only care about the stabilizers, which are given by the <code>zs</code> object that we define here.</p>
<p>Essentially, a quantum circuit starts in the product state <span class=""math-container"">$|0 \rangle^{\otimes N}$</span>, and then gates transform the state. The idea is that the stabilizer generators for this initial state is:</p>
<p><span class=""math-container"">\begin{equation}
g_1 = Z_1 \equiv Z \otimes \mathbb{1} \otimes \mathbb{1} \otimes \ldots \otimes \mathbb{1}, \\
g_2 = Z_2 \equiv \mathbb{1} \otimes Z \otimes \mathbb{1} \otimes \ldots \otimes \mathbb{1},
\end{equation}</span>
and so on until the end. If we have <span class=""math-container"">$N$</span> qubits, there will be exactly <span class=""math-container"">$8$</span> stabilizers. However, it's super important to note that these are <em>not</em> identified with certain qubits. For example, stabilizer <span class=""math-container"">$g_1$</span> is not identified with the first qubit (this tripped me up for a bit, so I wanted to note it).</p>
<p>The way Stim stores the stabilizers is the following: <span class=""math-container"">$0$</span> means an identity, <span class=""math-container"">$1$</span> means an <span class=""math-container"">$X$</span> operator, <span class=""math-container"">$2$</span> means a <span class=""math-container"">$Y$</span> operator, and <span class=""math-container"">$3$</span> means a <span class=""math-container"">$Z$</span> operator. This is because of the binary notation.</p>
<p>To get into the actual form of the tableau matrix, we need to make a <span class=""math-container"">$N \times 2N$</span> matrix, with the left <span class=""math-container"">$N \times N$</span> block being for the <span class=""math-container"">$X$</span> operators and the right block for the <span class=""math-container"">$Z$</span> operators.</p>
<p>So you can just write a little function like this:</p>
<pre><code>def binaryMatrix(zStabilizers):
    &quot;&quot;&quot;
        - Purpose: Construct the binary matrix representing the stabilizer states.
        - Inputs:
            - zStabilizers (array): The result of conjugating the Z generators on the initial state.
        Outputs:
            - binaryMatrix (array of size (N, 2N)): An array that describes the location of the stabilizers in the tableau representation.
    &quot;&quot;&quot;
    N = len(zStabilizers)
    binaryMatrix = np.zeros((N,2*N))
    r = 0 # Row number
    for row in zStabilizers:
        c = 0 # Column number
        for i in row:
            if i == 3: # Pauli Z
                binaryMatrix[r,N + c] = 1
            if i == 2: # Pauli Y
                binaryMatrix[r,N + c] = 1
                binaryMatrix[r,c] = 1
            if i == 1: # Pauli X
                binaryMatrix[r,c] = 1
            c += 1
        r += 1

    return binaryMatrix
</code></pre>
<p>Now, we're ready to calculate the entropy.</p>
<h1>Calculating the entropy of a cut</h1>
<p>Now that we have the matrix corresponding to the evolved quantum state through the circuit, we want to find the entanglement entropy. In <a href=""https://arxiv.org/abs/1901.08092"" rel=""nofollow noreferrer"">this paper</a>, the key equation is Equation A19, but the real helpful comment I found on this was on Footnote 11 of <a href=""https://arxiv.org/abs/1608.06950"" rel=""nofollow noreferrer"">this paper</a> (page 10), which says how to do this numerically. I also communicated with one of the authors (Xiao Chen) from the other paper here, and his comments were also quite helpful.</p>
<p>Our system involves <span class=""math-container"">$N$</span> qubits, and now we want to find the entanglement entropy between two subsystems, which we will label <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>. Equation A19 of the paper I referenced above tells us:</p>
<p><span class=""math-container"">\begin{equation}
\label{eq:Entropy}
S_A = \text{rank}\left( \text{projection}_A \mathcal{S} \right) - N_A. 
\end{equation}</span></p>
<p>In this equation, <span class=""math-container"">$N_A$</span> is the number of qubits in part <span class=""math-container"">$A$</span>, <span class=""math-container"">$\mathcal{S}$</span> is the set of stabilizers (our binary matrix we got above), and the projection operator means we want to &quot;truncate&quot; the matrix so that it's only describing the parts on <span class=""math-container"">$A$</span>.</p>
<p>To do this, remember that our matrix starts off as <span class=""math-container"">$N \times 2N$</span>. We now want to truncate it so that we don't care about the qubits in region <span class=""math-container"">$B$</span>. Mathematically, this is what the projection operator does. It pretends everything in region <span class=""math-container"">$B$</span> is the identity, which in our matrix means the entries become zero.</p>
<p>But a simpler way to deal with this is to just <em>delete</em> the columns needed to describe region <span class=""math-container"">$B$</span>, since they won't play a role anyway. Numerically, the following function does the trick:</p>
<pre><code>def getCutStabilizers(binaryMatrix, cut):
    &quot;&quot;&quot;
        - Purpose: Return only the part of the binary matrix that corresponds to the qubits we want to consider for a bipartition.
        - Inputs:
            - binaryMatrix (array of size (N, 2N)): The binary matrix for the stabilizer generators.
            - cut (integer): Location for the cut.
        - Outputs:
            - cutMatrix (array of size (N, 2cut)): The binary matrix for the cut on the left.
    &quot;&quot;&quot;
    N = len(binaryMatrix)
    cutMatrix = np.zeros((N,2*cut))

    cutMatrix[:,:cut] = binaryMatrix[:,:cut]
    cutMatrix[:,cut:] = binaryMatrix[:,N:N+cut]

    return cutMatrix
</code></pre>
<p>This truncates our original <span class=""math-container"">$N \times 2N$</span> matrix into a <span class=""math-container"">$N \times 2N_A$</span> matrix, with everything else deleted.</p>
<p>Now, the equation for the entropy simply requires us to compute the rank of this matrix, and subtract off the number of qubits in region <span class=""math-container"">$A$</span>. Numerically, you can do this using Gaussian elimination with Boolean variables (in others worlds, modulo 2 arithmetic), but you can also use just a plain old SVD over real variables to get the rank.</p>
<p><strong>Edit:</strong> I made a mistake in saying that a regular SVD calculation will work. For reference, I was using the <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_rank.html"" rel=""nofollow noreferrer"">matrix_rank</a> function from NumPy. After comparing it with another approach, it seems like it <em>mostly</em> works, but is sometimes off. As such, I'd recommend doing Gaussian elimination, with something like <a href=""https://stackoverflow.com/a/56858995/"">this</a>.</p>
<hr />
<p>After that, you should be good to go. The entropy is essentially a matrix rank computation. Also note that you can use whatever stabilizer circuit simulator you like, as long as in the end you get out the stabilizer generators which you can then build your binary matrix from.</p>
",04/03/2021 15:04,Tooling ,"The user is asking about how to use specific quantum circuit simulators (Stim, Python CHP Stabilizer Simulator, CHP Sim) to calculate the entanglement entropy from the tableau representation of a quantum state. This falls under the usage of tools and software in quantum programming",Tooling,,,,Tooling ,
16734.0,Bloch Sphere of Qiskit logo,"<p>Trying to plot the Bloch Sphere of the IBM Qiskit logo</p>
<pre><code>from qiskit import execute, Aer, IBMQ, QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere, plot_bloch_multivector
%matplotlib inline

# no. of qubits
n = 4

# create circuit
qc = QuantumCircuit(n)

# apply hadamard
qc.h(0)

# apply cnot
for i in range(n-1):
    qc.cx(0, i+1)

# apply not on q1
qc.x(1)

# get state vector
sv = Statevector.from_instruction(qc).data

# plots
plot_state_qsphere(sv)
plot_bloch_multivector(sv)
</code></pre>
<p><a href=""https://i.stack.imgur.com/Xixs2.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Xixs2.png"" alt=""enter image description here"" /></a></p>
<p>Why the Bloch Sphere does not have any state representations?</p>
<p>Circuit <a href=""https://quantum-computing.ibm.com/composer/files/new?initial=N4IgdghgtgpiBcICKBLAzgaxQFwPoBsB7Ac0JABoQBHCNKBEAeQAUBRAOSQEEBlAWQAEAJgB0ABgDcAHTAowAY3wBXACYwBU6jHwoARgEYRc%2BZulgZVAE4xiAqgG0AzAF0z867fn2hrmTIAWdvZivgoAHkEh5A76ofIRDlEOPmYJ9rESFCBqaO4oAA7YKIRgDCAAvkA"" rel=""noreferrer"">link</a></p>
",<programming><qiskit><quantum-state><ibm-q-experience><bloch-sphere>,3/28/2021 12:57,16739.0,16739.0,"<p><a href=""https://quantumcomputing.stackexchange.com/questions/16734/bloch-sphere-of-qiskit-logo/16739#comment24534_16734"">As @PaulNation explained</a>, the bloch spheres represent maximally entangled qubits as zero-length vectors. Hence, no arrows.</p>
<p>The Qiskit logo is a qsphere of a particular statevector. In particular, a 6-qubit state, <a href=""https://twitter.com/abe_asfaw/status/1252545138188079104"" rel=""nofollow noreferrer"">according to Abe</a>:</p>
<pre><code>from qiskit.visualization import plot_state_qsphere
state = [0]*2**6
state[2] = 1; state[61] = 1
plot_state_qsphere(state, show_state_labels=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/01vlD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/01vlD.png"" alt=""qiskit logo qsphere"" /></a></p>
<p>So... you are actually really really close. Just change <code>n = 6</code> I you will get it!</p>
<p>Here is your fixed code:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere

n = 6
qc = QuantumCircuit(n)
qc.h(0)
for i in range(n-1):
    qc.cx(0, i+1)
qc.x(1)

sv = Statevector.from_instruction(qc)
plot_state_qsphere(sv, show_state_labels=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/01vlD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/01vlD.png"" alt=""qiskit logo qsphere"" /></a></p>
<p>To increase the similarity, delete the legend and modify the elevation:</p>
<pre><code>fig = plot_state_qsphere(sv, show_state_labels=False)
fig.axes[0].view_init(elev=11, azim=275)
fig.axes[1].set_visible(False)
fig
</code></pre>
<p><a href=""https://i.stack.imgur.com/2TND7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2TND7.png"" alt=""enter image description here"" /></a></p>
",3/28/2021 20:17,Errors,The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are trying to understand why the Bloch Sphere does not have any state representations. ,Errors,,,,Errors,
16740.0,Quantum SVM with large feature set,"<p>I am trying to practice QSVM from the following tutorial</p>
<p><a href=""https://medium.com/@patrick.huembeli/introduction-into-quantum-support-vector-machines-727f3ccfa2b4"" rel=""nofollow noreferrer"">Introduction into Quantum Support Vector Machines</a></p>
<p>The author has used 2 feature_dimension with 2 component PCA</p>
<pre><code>feature_dimension =2
</code></pre>
<p>Now my question is, why?</p>
<p>Is it because of the limitation of the number of qubits?</p>
<p>When I tried to increase both to 3 the testing success ratio decreased to 0.45</p>
<p>How can I use more feature sets</p>
",<qiskit><programming><machine-learning><quantum-enhanced-machine-learning><kernel-methods>,3/28/2021 22:59,16747.0,16747.0,"<p>Practically, it can be (quite often) a limitation of number of qubits/hardware, but also it is a hyperparameter to play with. So it may be that using more qubits gives you better results or worse.</p>
<p>Also, in the QSVM, there is or may be a parameterized part you have to optimize over. So increasing the number of qubits results in more optimization (more parameters), that makes it harder. You may need to play on the depth of the variational part to improve results (so more parameters to optimize).</p>
<p>But if you are limited in the number of qubits, you can change the data encoding. For instance, <a href=""https://arxiv.org/abs/2101.09581"" rel=""nofollow noreferrer"">in this paper Fig.2</a>, they use a quantum circuit with <span class=""math-container"">$17$</span> qubits and loaded <span class=""math-container"">$67-$</span>dimensional data without dimensionality reduction. This results in a deeper circuit.</p>
",3/29/2021 9:22,Learning,"The user is seeking guidance on how to use more feature sets in Quantum Support Vector Machines (QSVM) and why the feature dimension is typically set to 2. This falls under requests for learning resources, tutorials, and references in quantum computing",Learning,,,,Learning,
16753.0,"Error ""too many subscripts in einsum"", UnitaryGate()","<p>I'd like to build a multi qubit controlled gate in the following way.<br>
The circuit has <span class=""math-container"">$n+1$</span> qubits, the first qubit is the control qubit, and the operation on the rest <span class=""math-container"">$n$</span> qubits is the tensor product of <span class=""math-container"">$n$</span> phase rotations <span class=""math-container"">$R^{\otimes n}$</span>.</p>
<pre><code>from qiskit import *
from qiskit.extensions import *
import qiskit.extensions.unitary
import cmath as cm
import numpy as np
import math as m
from qiskit.aqua.utils import tensorproduct


n=10
c = QuantumRegister(1, &quot;c&quot;)
q = QuantumRegister(n, &quot;q&quot;)
cl = ClassicalRegister(2, &quot;cl&quot;)
circ = QuantumCircuit( c, q, cl)


phase=cm.exp(cm.pi*complex(0,1)*(1/4))
matrixR=np.array([[phase,0],[0,1]])
matrixTe= matrixR
for _ in range(n-1):
    matrixTe=tensorproduct(matrixTe,matrixR)
matrixOp=matrixTe

gateCR=UnitaryGate(matrixOp).control(num_ctrl_qubits=1)

qubits=[m for m in reversed(q)]
circ.append(gateCR, qubits) 
</code></pre>
<p>For <span class=""math-container"">$n\geq10$</span>, I get the following error message:<br>
<a href=""https://i.stack.imgur.com/Qdte2.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Qdte2.jpg"" alt=""enter image description here"" /></a> <br> <a href=""https://i.stack.imgur.com/JKp6k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JKp6k.png"" alt=""enter image description here"" /></a></p>
<p>I understand the problem lies in the size of the matrix when it has phase in it. I tried to build a gate for <span class=""math-container"">$n=10$</span> when the operation has no phase, and it worked without any problem!</p>
<p>My question is, is there any workaround to fix this problem? What does the comment <code>hack to correct global phase; should fix to prevent need for correction here</code> in the source code mean?</p>
",<programming><qiskit>,3/30/2021 6:25,16775.0,16775.0,"<p>You can use Qiskit's <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.primitive_ops.MatrixOp.html"" rel=""nofollow noreferrer"">MatrixOp</a>, and <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.operators.list_ops.TensoredOp.html"" rel=""nofollow noreferrer"">TensoredOp</a> classes:</p>
<pre><code>_list = []
for _ in range(n):
    _list.append(MatrixOp(matrixR))

tensored_op = TensoredOp(_list)
gateCR=tensored_op.to_circuit().to_gate().control(num_ctrl_qubits = 1)
</code></pre>
",3/30/2021 20:40,Errors ,"The user is encountering an error when trying to build a multi qubit controlled gate in Qiskit. They are seeking solutions and explanations for this issue, which falls under the category of seeking solutions for errors and exceptions in quantum program development.",Errors,,,,Errors ,
16786.0,How to get_statevector() with defined gates in Qiskit?,"<p>I'm learning Qiskit for my QC lectures and I'm not able to run the following code:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, assemble, Aer

def cnotnot(gate_label = 'CNOTNOT'):
    gate_circuit = QuantumCircuit(3, name = gate_label)
    gate_circuit.cnot(0, 1)
    gate_circuit.cnot(0, 2)

    gate = gate_circuit.to_gate()

    gate.label = gate_label

    return gate

q = QuantumRegister(3, name = 'q')

circuit = QuantumCircuit(q)

# Define initial state
initial_state = [1. / np.sqrt(2.), 1. / np.sqrt(2.)]
circuit.initialize(initial_state, 0)

circuit.append(cnotnot(), [q[0], q[1], q[2]])

circuit.draw(plot_barriers = False)

# Let's simulate our circuit in order to get the final state vector!
svsim = Aer.get_backend('statevector_simulator')

# Create a Qobj from the circuit for the simulator to run
qobj = assemble(circuit)

# Do the simulation, return the result and get the state vector
result = svsim.run(qobj).result().get_statevector()

# Get the state vector for the first qubit
final_state = [result[0], result[1]]

print('a and b coefficients before simulation:', initial_state)
print('a and b coefficients after simulation:', final_state)
</code></pre>
<p>without getting errors. In particular:</p>
<pre><code>QiskitError: 'ERROR:  [Experiment 0] Circuit contains invalid instructions {&quot;gates&quot;: {CNOTNOT}} for &quot;statevector&quot; method.
</code></pre>
<p>I followed <a href=""https://quantumcomputing.stackexchange.com/questions/13289/defining-a-custom-parametric-gate-in-qiskit-in-terms-of-standard-gates"">this answer</a> to define a CNOTNOT gate and append it to my circuit, but I can't get the Statevector after the simulation. If I don't use a defined gate (just use two separated CNOT), the code runs without problems.</p>
<p>Thanks for your time!</p>
",<programming><qiskit><quantum-gate><entanglement>,3/31/2021 17:33,16803.0,16803.0,"<p>You are missing an important part of the preparation process of the circuit for it to run on the simulator (any backend, actually) : <a href=""https://qiskit.org/documentation/apidoc/transpiler.html?highlight=transpile#module-qiskit.transpiler"" rel=""noreferrer"">the transpilation</a>.</p>
<p>In order to create the qobj, you first have to transpile your circuit into gates your backend &quot;understands&quot;, kind of like a translator between your custom gates and the basis gates of the backend. First you do the transpile of the circuit to transform it into gates the backends knows, then you assemble it into a obj to be able to run it.</p>
<p>So for your code to run here, you would have to do something like this:</p>
<pre><code># Create a Qobj from the circuit for the simulator to run
test = transpile(circuit, svsim)
qobj = assemble(test)

# Do the simulation, return the result and get the state vector
result = svsim.run(qobj).result().get_statevector()
</code></pre>
<p>You can also use the <code>execute</code> function that does it for you:</p>
<pre><code>from qiskit import execute
# Do the simulation, return the result and get the state vector
result = execute(circuit, svsim).result().get_statevector()
</code></pre>
<p>Hope this is clear enough, if you have any questions about this please let me know in the comments :)</p>
",04/01/2021 07:59,Errors ,The user is encountering an error when trying to run a quantum circuit with a custom gate in Qiskit. They are seeking solutions and explanations for this issue,Errors ,,,,Errors ,
16804.0,How to upload our dataset using pytorch when it is not present in torchvision?,"<p>I am trying to upload my dataset(SWELL-KW) instead of MNIST in  &quot;Hybrid quantum-classical Neural Networks with PyTorch and Qiskit&quot; provided by IBM qiskit but it says <code>&quot;AttributeError: module 'torchvision.datasets' has no attribute 'SWELL'</code>. I could not find the dataset in torch vision. Is that the reason? If I try to give the path of dataset which is on my system, it indicates unicode error. Thank You.</p>
",<programming><quantum-state><ibm-q-experience><quantum-neural-network>,04/01/2021 10:23,16809.0,16809.0,"<p>Yes, since the dataset does not exist in torchvision, trying to load it through torchvision will produce this error. Instead, save your SWELL-KW dataset as a .csv file, read it in, and convert the train/test data vectors, and labels each as their own PyTorch tensor.</p>
<p>For example, let's say I have my own custom dataset that consists of coordinate pairs and associated labels. I save the data into a file <code>myData.csv</code> such that the first column contains the x-coordinates, the second column contains the y-coordinates and the third column contains the labels. First, we load data row by row,</p>
<pre><code>import csv
import torch
</code></pre>
<pre><code>Xs = []
Ys = []

with open('myData.csv', mode ='r') as data:
    csvFile = csv.reader(data)
    for row in csvFile:
        Xs.append([float(row[0]), float(row[1])])
        Ys.append(float(row[2]))
</code></pre>
<p>and then we convert each of our lists to PyTorch tensors,</p>
<pre><code>X_tensor = torch.FloatTensor(Xs)
Y_tensor = torch.FloatTensor(Ys)
</code></pre>
<p>Your data is now ready to use. For more complex datasets or specific use cases you may need to <a href=""https://pytorch.org/tutorials/beginner/data_loading_tutorial.html"" rel=""nofollow noreferrer"">create a custom dataset class</a>.</p>
",04/01/2021 14:41,Errors ,The user is encountering an error when trying to upload the SWELL-KW dataset in PyTorch and Qiskit. They are seeking solutions and explanations for this issue,Errors,,,,Errors ,
16805.0,Qiskit - Circuit drawing aesthetics - Can I force the measurements in my circuit to show at the end?,"<p>I'm studying an introduction course to quantum computation at my uni and we got homework to draw a certain circuit using qiskit. I managed to understand how to do what is asked from me, and this is the final answer:</p>
<p><a href=""https://i.stack.imgur.com/85fx2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/85fx2.png"" alt=""Is there a way to force measurements at the end of the circuit?"" /></a></p>
<p>Now I know that once the qubit is no longer used in a manipulation, you can measure it without affecting the results, however I find this circuit rather confusing and messy. Since we can always postpone our measurement to the end, I'd prefer a more organised drawing where all CNOT gates are performed, and only then the measurements - preferably from the top one to the bottom one.
<strong>Is it possible to force such a thing?</strong></p>
<p>To try and force the code doing that, I tried to first use a for loop to apply CNOTs on every qubit, then using a separate loop I performed the measurements on every qubit.</p>
<pre><code>circuit_three = QuantumCircuit(5, 5)
circuit_three.h(0)
for i in range(1, 5):
    circuit_three.cx(0, i)
for i in range(0, 5):
    circuit_three.measure(i, i)
circuit_three.draw(output='mpl', filename='3')
</code></pre>
<p>The desired result is this (done with paint):
<a href=""https://i.stack.imgur.com/0Bqvg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0Bqvg.png"" alt=""Desired Outcome of circuit drawing"" /></a></p>
",<programming><qiskit><measurement><quantum-circuit>,04/01/2021 10:40,16806.0,16806.0,"<p>You can add a <code>barrier</code> before the <code>measure</code>:</p>
<pre><code>from qiskit import *
circuit_three = QuantumCircuit(5, 5)
circuit_three.h(0)
for i in range(1, 5):
    circuit_three.cx(0, i)
circuit_three.barrier()  &lt;--- add this line
for i in range(0, 5):    &lt;--- side note: this can be replaced by circuit_three.measure_all()
    circuit_three.measure(i, i)
circuit_three.draw(output='mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/rSAlD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rSAlD.png"" alt=""enter image description here"" /></a></p>
<p>Then, with the argument <code>plot_barriers</code>, skip the plotting of the barrier:</p>
<pre><code>circuit_three.draw(output='mpl', plot_barriers=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/TdjmZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TdjmZ.png"" alt=""enter image description here"" /></a></p>
<p><strong>An important caveat</strong>: <a href=""https://quantumcomputing.stackexchange.com/questions/8369/what-is-a-barrier-in-qiskit-circuits"">the barrier has meaning for the transpiler</a>. If you are planning to execute that circuit, <strong>remember to remove the added barrier.</strong></p>
",04/01/2021 10:56,Tooling ,"The user is asking about how to organize the drawing of a quantum circuit in Qiskit, specifically how to force measurements to appear at the end of the circuit. ",Tooling ,,,,Tooling ,
16828.0,Writing the Jaynes-Cumming model in QuTip,"<p>I want to write the Jaynes-Cumming Hamiltonian in QuTip.</p>
<p><span class=""math-container"">$$H = \hbar \omega_{C} a^\dagger a + \frac12 \hbar \omega_{a} \sigma_{z} + \hbar \lambda (\sigma_{+} a + \sigma_{-} a^\dagger)$$</span></p>
<p>I assume <span class=""math-container"">$\hbar = 1$</span>, and we know <span class=""math-container"">$a, a^\dagger$</span> are the field (cavity) operators, and <span class=""math-container"">$\sigma_{z}, \sigma_{+}, \sigma_{-}$</span> are the atomic operators; and they commute. <span class=""math-container"">$\lambda$</span> is the coupling constant.</p>
<p>I assume that the # of Fock basis states that I choose is <code>N</code>. Now, to write the Hamiltonian using qutip I would use the following statements,</p>
<p><span class=""math-container"">$a$</span>: <code>a = tensor(qeye(2), destroy(N))</code> <br />
<span class=""math-container"">$a^\dagger$</span>: <code>a.dag()</code> <br />
<span class=""math-container"">$a^\dagger a$</span>: <code>a.dag() * a</code></p>
<p><span class=""math-container"">$\sigma_{z}$</span>: <code>sz = tensor(sigmaz(), qeye(N))</code></p>
<p><span class=""math-container"">$\sigma_{+} a$</span>: <code>sp = tensor(sigmap(), qeye(N)) * a</code> <br />
<span class=""math-container"">$\sigma_{-} a^\dagger$</span>: <code>sp.dag()</code> <br />
<span class=""math-container"">$\sigma_{+} a + \sigma_{-} a^\dagger$</span>: <code>sp + sp.dag()</code></p>
<p>But in the QuTip documentation the interaction term has been written as,</p>
<blockquote>
<p><code>sm = tensor(destroy(2), qeye(N)); Hint = a.dag() * sm + a * sm.dag()</code></p>
</blockquote>
<p><strong>Could someone explain why they use the previous statement but not the one I would have assumed?</strong></p>
",<programming><qutip>,04/02/2021 18:57,16830.0,16830.0,"<p>Usually we say <span class=""math-container"">$|0\rangle$</span> is the ground state and is at the north pole, but sometimes people choose the convention that since the north pole is ``higher&quot; than the south pole on the Bloch sphere, that <span class=""math-container"">$|0\rangle$</span> should be the excited state instead.  Thus, the qubit raising operator (with basis ordering <span class=""math-container"">$|0\rangle, |1\rangle$</span>) is
<span class=""math-container"">\begin{align}
\sigma_+ = \begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{bmatrix}
\end{align}</span>
which actually looks like the lowering operator in the first convention.  QuTiP is treating the qubit as a two-level oscillator (<span class=""math-container"">$|0\rangle$</span> is ground), and you are using <span class=""math-container"">$|0\rangle$</span> as excited.</p>
",04/02/2021 19:36,Learning,"The user is seeking clarification on how to write the Jaynes-Cumming Hamiltonian in QuTip, specifically why the interaction term in the QuTip documentation is written differently from what they assumed. This falls under requests for learning resources, tutorials, and references in quantum computing.", Learning,,,,Learning,
16838.0,How do I get the Unitary matrix of a circuit without using the 'unitary_simulator'?,"<p>I am using jupyter notebook and qiskit. I have a simple quantum circuit and I want to know how to get the unitary matrix of the circuit without using 'get_unitary' from the Aer unitary_simulator. i.e.:By just using matrix manipulation, how do I get the unitary matrix of the circuit below by just using numpy and normal matrix properties?</p>
<p><a href=""https://i.stack.imgur.com/7tYiE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7tYiE.png"" alt=""Circuit"" /></a></p>
<p>The result should equal this:</p>
<p>[[1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</p>
<p>[0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</p>
<p>[0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j]</p>
<p>[0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j]</p>
<p>[0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j]</p>
<p>[0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]</p>
<p>[0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</p>
<p>[0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]]</p>
<h1>I tried doing the following but it did not result in the correct Unitary matrix</h1>
<pre><code>swapcnot = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])

layer1 = np.kron( swapcnot,np.eye(2) ) 

layer2 = np.kron( np.eye(2),swapcnot ) 

print( np.matmul(layer2,layer1) )
</code></pre>
<h1>The result:</h1>
<p>[[1. 0. 0. 0. 0. 0. 0. 0.]</p>
<p>[0. 0. 0. 0. 0. 0. 0. 1.]</p>
<p>[0. 0. 0. 0. 0. 0. 1. 0.]</p>
<p>[0. 1. 0. 0. 0. 0. 0. 0.]</p>
<p>[0. 0. 0. 0. 1. 0. 0. 0.]</p>
<p>[0. 0. 0. 1. 0. 0. 0. 0.]</p>
<p>[0. 0. 1. 0. 0. 0. 0. 0.]</p>
<p>[0. 0. 0. 0. 0. 1. 0. 0.]]</p>
",<programming><qiskit><quantum-state><unitarity>,04/03/2021 15:31,16839.0,16839.0,"<p>For the first layer of your circuit, compute the tensor product between the unitary matrix of the (swapped) CNOT gate and the identity matrix (using numpy's kron()).
Do a similar operation for the second layer.
You will obtain two 8x8 matrices.
Then multiply them using numpy's matmul().</p>
<p>Here you have the working code:</p>
<pre><code>import numpy as np

swapcnot = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])

layer1 = np.kron(np.eye(2),swapcnot )

layer2 = np.kron( swapcnot, np.eye(2) )

print( np.matmul(layer2,layer1) )
</code></pre>
<p>Output:</p>
<pre><code>[[1. 0. 0. 0. 0. 0. 0. 0.]
[0. 0. 0. 1. 0. 0. 0. 0.]
[0. 0. 0. 0. 0. 0. 1. 0.]
[0. 0. 0. 0. 0. 1. 0. 0.]
[0. 0. 0. 0. 1. 0. 0. 0.]
[0. 0. 0. 0. 0. 0. 0. 1.]
[0. 0. 1. 0. 0. 0. 0. 0.]
[0. 1. 0. 0. 0. 0. 0. 0.]]
</code></pre>
",04/03/2021 16:18,Tooling,The user is trying to use numpy and normal matrix properties to get the unitary matrix of a quantum circuit without using get_unitary from the Aer unitary_simulator in Qiskit. This falls under the usage of tools and software in quantum programming.,Tooling,,,,Tooling,
16849.0,"Multiplying quantum circuits in cirq using * and computing ""expectation values""","<p>I am reading <a href=""https://quantumai.google/cirq/simulation#expectation_values"" rel=""nofollow noreferrer"">cirq guide about Simulation</a> and there is an example in &quot;Expectation values&quot; paragraph that I don't understand.</p>
<p>Everything boils down to the following snippet:</p>
<pre><code>import cirq

q0 = cirq.GridQubit(0, 0)
q1 = cirq.GridQubit(1, 0)

def basic_circuit():
    sqrt_x = cirq.X**0.5
    yield sqrt_x(q0), sqrt_x(q1)
    yield cirq.CZ(q0, q1)
    yield sqrt_x(q0), sqrt_x(q1)

circuit = cirq.Circuit(basic_circuit())

XX_obs = cirq.X(q0) * cirq.X(q1)
ZZ_obs = cirq.Z(q0) * cirq.Z(q1)

ev_list = cirq.Simulator().simulate_expectation_values(circuit, observables=[XX_obs])
print(ev_list)
# Output:
[(1+0j)]
</code></pre>
<p>First, I don't understand what <code>XX_obs</code> and <code>ZZ_obs</code> do. What does it mean to multiply two circuits by <code>*</code> operator. Is it the tensor product of the operations or something else?</p>
<p>Second, is simulating observable <code>XX_obs</code> the same as adding <code>XX_obs</code> at the end of circuit? If so, how to read the following printed output:</p>
<pre><code>circuit.append(XX_obs)
print(circuit)
# Output:
(0, 0): âââX^0.5âââ@âââX^0.5âââPauliString(+X)âââ
                   â           â
(1, 0): âââX^0.5âââ@âââX^0.5âââXâââââââââââââââââ
</code></pre>
<p>Third, if I simulate the above circuit without measurement I get the following output which does not resemble <code>[(1+0j)]</code> obtained previously:</p>
<pre><code>result = cirq.Simulator().simulate(circuit)
print(result)
# output:
measurements: (no measurements)
output vector: 0.5|00â© + 0.5j|01â© + 0.5j|10â© + 0.5|11â©
</code></pre>
<p>Why is it so?</p>
<hr />
<p>PS. It is my very first question on this site so be forgiving about tags I used or about some conventions that you use and I don't know.</p>
",<programming><circuit-construction><cirq>,04/04/2021 15:04,16850.0,16850.0,"<p><span class=""math-container"">$Z_{q0} Z_{q1}$</span> is an <em>observable</em>; a thing that you can measure.</p>
<p>If I tell you to measure <span class=""math-container"">$Z_{q0}$</span>, I am telling you to measure qubit <span class=""math-container"">$q0$</span> in the computational basis (i.e. in the usual way, i.e. whether the qubit is <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span>).</p>
<p>If I tell you to measure <span class=""math-container"">$X_{q0}$</span>, I am telling you to measure qubit <span class=""math-container"">$q0$</span> in the X basis (i.e. whether the qubit is <span class=""math-container"">$|+\rangle$</span> or <span class=""math-container"">$|-\rangle$</span>). Typically you would do this by applying a Hadamard operation to <span class=""math-container"">$q0$</span> before applying the usual measurement operation.</p>
<p>If I tell you to measure <span class=""math-container"">$Z_{q0} Z_{q1}$</span>, I am telling you to measure the <em>parity</em> of qubit <span class=""math-container"">$q0$</span> and qubit <span class=""math-container"">$q1$</span> in the computational basis (i.e. whether they are the same or different, i.e. whether you are in the <span class=""math-container"">$01$</span> and <span class=""math-container"">$10$</span> subspace or in the <span class=""math-container"">$00$</span> and <span class=""math-container"">$11$</span> subspace). Typically you would do this by applying a CNOT operation from <span class=""math-container"">$q0$</span> to an ancilla, and then from <span class=""math-container"">$q1$</span> to an ancilla, then measuring the ancilla. If you don't need to continue the circuit or measure other observables, you would instead just measure <span class=""math-container"">$Z_{q0}$</span> and also measure <span class=""math-container"">$Z_{q1}$</span> and check if they were the same using classical postprocessing.</p>
<p>If I tell you to measure <span class=""math-container"">$X_{q0} X_{q1}$</span>, I am telling you to measure the parity between qubit <span class=""math-container"">$q0$</span> and <span class=""math-container"">$q1$</span> in the X basis.</p>
<p>If I ask for the <em>expectation value</em> of an observable, then I want you to run the circuit many times, measuring that observable at the end of the circuit each time, and tell me the average of the results.</p>
<p>So passing <span class=""math-container"">$X_{q0} X_{q1}$</span> into the method you are talking about doesn't put <span class=""math-container"">$X$</span> operations at the end of the circuit... it actually puts Hadamard and measurement operations at the end of the circuit, runs the circuit many times, and reports how frequently those two measurements differ from each other.</p>
<p>The reason we refer to observables in this product-of-operations way is because one way to measure an observable is to perform those operations, but controlled on an ancilla in the <span class=""math-container"">$|+\rangle$</span> state. This flips the ancilla to the <span class=""math-container"">$|-\rangle$</span> state via phase kickback, if the system state is in the -1 eigenspace of the product-of-operations. There are also a lot of other nice things about thinking about measurements in this way, e.g. it is the basis of the stabilizer formalism which allows Clifford circuits to be simulated efficiently.</p>
",04/04/2021 15:39,Learning,"The user is seeking clarification and understanding of specific concepts related to quantum circuit simulation using Cirq. Their questions pertain to the understanding of observable operators, circuit simulation results, and the use of the '*' operator in the context of Cirq. This falls under the category of learning ",Learning,,,,Learning,
16852.0,Why is my unitary matrix using linear algebra not matching the 'get_unitary' simulation?,"<p>I am using jupyter notebook and qiskit. I have a simple quantum circuit and I want to know how to get the unitary matrix of the circuit without using 'get_unitary' from the Aer unitary_simulator.
i.e.: By just using matrix manipulation, how do I get the unitary matrix of the circuit below by just using numpy and normal matrix properties?</p>
<p><a href=""https://i.stack.imgur.com/yHHpj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yHHpj.png"" alt=""enter image description here"" /></a></p>
<h1>This is the code I am using:</h1>
<pre><code>import numpy as np

swapcnot = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])

cnot = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])

layer1 = np.kron(np.eye(2),swapcnot)

layer2 = np.kron(swapcnot, np.eye(2))

layer3 = np.kron(np.eye(2), cnot )

print(layer3@layer2@layer1)
</code></pre>
<h1>The result I should be getting:</h1>
<pre><code>[[1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]
 [0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]
 [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j]
 [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j]
 [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]
 [0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j]
 [0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]
 [0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]] 
</code></pre>
<h1>The actual result I am getting:</h1>
<pre><code>[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]]
</code></pre>
",<programming><qiskit><quantum-gate><unitarity>,04/04/2021 16:23,16855.0,16855.0,"<p>First, you need to realize that</p>
<p><a href=""https://i.stack.imgur.com/c8sxE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c8sxE.png"" alt=""enter image description here"" /></a></p>
<p>This is also known as the Bridge gate.  This means that</p>
<p><a href=""https://i.stack.imgur.com/j9Ow8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/j9Ow8.png"" alt=""enter image description here"" /></a></p>
<p>From here, you can now write down the following:</p>
<pre><code>swapcnot = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])

cnot = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])

layer1 = np.kron(np.eye(2),swapcnot)

layer2 = np.kron(swapcnot, np.eye(2))

### Bridge Gate part of the circuit ####

layer3 = np.kron(np.eye(2), cnot )

layer4 = np.kron(cnot, np.eye(2) )

layer5 = np.kron(np.eye(2), cnot )

layer6 = np.kron(cnot, np.eye(2) )

####################################

print(layer6@layer5@layer4@layer3@layer2@layer1)
</code></pre>
<p>This will output:</p>
<pre><code>[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]]
</code></pre>
<p>which is what you expected.</p>
",04/04/2021 17:02,Tooling,"The user is related to a specific task in quantum programming, which is how to compute the unitary matrix of a quantum circuit using numpy and normal matrix operations. It pertains to the tooling aspect of quantum programming, specifically how to manipulate matrices to obtain the unitary matrix. ",Tooling,,,,Tooling,
16868.0,How to get eigenvectors of Hamiltonian in OpenFermion,"<p>In OpenFermion you can create a Hamiltonian in terms of creation and annihilation pretty easily:
<code>ham = ((FermionOperator('1^ 1', .5)) + (FermionOperator('2^ 2', .25)))</code></p>
<p>And getting the eigenvalues of the Hamiltonian is pretty straightforward as well:
<code>vals = eigenspectrum(ham)</code></p>
<p>But I don't understand how to get the eigenvectors of the Hamiltonian. FermionOperator doesn't return a numpy object so I can't use usual linear algebra libraries. What am I missing?</p>
",<programming><hamiltonian-simulation><openfermion>,04/06/2021 04:24,16881.0,16881.0,"<p>The following works:</p>
<pre><code>sparse_mat = openfermion.get_sparse_operator(ham, n_qubits=n) # type: scipy.sparse.csr_matrix
mat = sparse_mat.toarray() # type: np.ndarray
w, v = numpy.linalg.eigh(mat)
</code></pre>
<p>Then <code>w</code> will contain the eigenvalues and the columns of <code>v</code> will contain the eigenvectors. Setting the <code>n_qubits=n</code> parameter will result in a matrix that gets padded up to <span class=""math-container"">$2^n \times 2^n$</span> which is important if you're going to do further matrix manipulations or algebra involving the matrix representing your Hamiltonian.</p>
<p>And of course, for efficiency reasons you may choose not to cast the sparse operator to a numpy array but then you will end up using sparse matrix functions from scipy, for example <code>scipy.sparse.linalg.eigsh</code> to find some subset of eigenvalues/eigenvectors of a sparse matrix.</p>
",04/06/2021 18:21,Tooling ,The user is asking about how to use a particular software or tool for quantum programming. They are trying to understand how to get the eigenvectors of the Hamiltonian in OpenFermion. ,Tooling ,,,,Tooling ,
16888.0,Quantum Katas - Tutorials - SingleQubitGates - Exercise 7 - Preparing an arbitrary state,"<p>Exercise 7 &quot;Preparing an arbitrary state&quot; from the Quantum Katas - Tutorials - SingleQubitGates asks to prepare a state <span class=""math-container"">$\alpha|0\rangle + e^{i\theta}\beta|1\rangle$</span>, using parameters <span class=""math-container"">$\alpha$</span>, <span class=""math-container"">$\beta$</span>, and <span class=""math-container"">$\theta$</span>.</p>
<p>In brief, <span class=""math-container"">$\theta$</span> is one of known-inputs, why we don't use <span class=""math-container"">$\theta$</span> for the Ry gate directly ? Something like this..</p>
<pre><code>Ry(theta, q);
R1(theta, q); 
</code></pre>
<p>But alas, I got error: <br></p>
<pre><code>Qubit in invalid state. Expecting: Zero 
    Expected:   0 
    Actual: 0.061208719054813704 
Try again!
</code></pre>
<p>Any ideas would be highly appreciated!!</p>
",<programming><q#>,04/07/2021 03:02,16889.0,16889.0,"<p>The angle to use for Ry gate is not necessarily the same one as the given angle <span class=""math-container"">$\theta$</span> to use for R1 gate. This means that you need to figure out the angle for Ry gate from the parameters <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span>. If you're using <span class=""math-container"">$\theta$</span> for both angles, you'll be preparing a state <span class=""math-container"">$\cos \frac{\theta}{2}|0\rangle + e^{i\theta}\sin \frac{\theta}{2}|1\rangle$</span>, not <span class=""math-container"">$\alpha|0\rangle + e^{i\theta}\beta|1\rangle$</span> the task asks for.</p>
<p>I recommend checking out the workbook for that tutorial - it has a very detailed explanation of the steps you need to take to solve this task.</p>
",04/07/2021 03:19, Learning,"The question is asking for clarification on a concept in the Quantum Katas tutorial, specifically how to prepare an arbitrary state using the Ry and R1 gates. The user is struggling to understand why they cannot simply use the theta angle for both gates.", Learning,,,, Learning,
16905.0,Getting the current variational parameters in Qiskit,"<p>I am right now using variational quantum eigensolver (VQE) to calculate the ground state of some molecules, like H2, by qiskit. The quesiton is that how to get the current parameters of the varaional ansatz, like UCCSD for the following code.</p>
<pre><code>import numpy as np
import pylab
import copy
from qiskit import BasicAer
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE
from qiskit.aqua.components.optimizers import SLSQP
from qiskit.chemistry.components.initial_states import HartreeFock
from qiskit.chemistry.components.variational_forms import UCCSD
from qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule
from qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory
from qiskit.chemistry.transformations import (FermionicTransformation,
                                              FermionicTransformationType,
                                              FermionicQubitMappingType)
from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory

molecule = Molecule(geometry=[['H', [0., 0., 0.]],
                              ['H', [0., 0., 0.735]]],
                     charge=0, multiplicity=1)
driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')
transformation = FermionicTransformation(qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER)


vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator')))

calc = GroundStateEigensolver(transformation, vqe_solver)
res = calc.solve(driver)

print(res)
</code></pre>
<p>Also, I need to simulate the model in the presence of noise, so I need to extract the variational parameters to calculate other properties of the system.</p>
",<programming><qiskit><vqe><chemistry>,04/08/2021 12:32,16907.0,16907.0,"<p>What I would do here is get back the raw results of your <code>res</code>, and there are stocked the parameters of the Ansatz you are looking for :</p>
<pre><code>my_res = res.raw_result
# The dict of each parameter and its associated value
my_param_dict = res.raw_result.optimal_parameters
# The array of all the values
my_param_list = res.raw_result.optimal_point
print(my_param_dict)
print(my_param_list)
</code></pre>
<p>And you get this :</p>
<pre><code>{ParameterVectorElement(Î¸[0]): 2.0215741373141244e-08, ParameterVectorElement(Î¸[1]): 2.0215741373141244e-08, ParameterVectorElement(Î¸[2]): -0.11176259664828359}

[ 2.02157414e-08  2.02157414e-08 -1.11762597e-01]
</code></pre>
<p>There is also an option with VQE that is to use a callback function storing all the intermediate parameters, see <a href=""https://quantumcomputing.stackexchange.com/questions/12066/vqe-restart-from-a-previous-computation/12524#12524"">the answer here</a> that explains it very well.</p>
",04/08/2021 13:08, API Usage,"The user is asking how to use the Qiskit API to extract variational parameters from a VQE ansatz, which falls under the category of understanding and using APIs in quantum programming", API Usage,,,, API Usage,
16911.0,Expectation value of an arbitrary observable. My own definition and `cirq` limitations,"<p>In <a href=""https://quantumcomputing.stackexchange.com/questions/16849/multiplying-quantum-circuits-in-cirq-using-and-computing-expectation-values"">my previous question</a> I was struggling with the definition of expectation value of an observable for a circuit. Here is what I have derived after some support (I simplify the definition to 2-qubit system (+3rd ancilla)):</p>
<p><strong>My Definition.</strong> Given a 2-qubit circuit <span class=""math-container"">$C$</span> and a 2-qubit observable <span class=""math-container"">$Ob$</span>, the expectation value of <span class=""math-container"">$Ob$</span> for <span class=""math-container"">$C$</span> is defined as <span class=""math-container"">$$EV(C, Ob):=\sqrt{\sum_{ij}|\alpha_{ij0}|^2} - \sqrt{\sum_{ij}|\alpha_{ij1}|^2},$$</span>
where <span class=""math-container"">$\alpha_{ijk}$</span> are such that <span class=""math-container"">$$(Ob_X\circ(C\otimes I))|000â©=\sum_{ijk}\alpha_{ijk}|ijkâ©,$$</span>
where <span class=""math-container"">$Ob_X$</span> denotes X-Axis control, i.e. <span class=""math-container"">$Ob_X=(I\otimes H)\circ Ob_C\circ(I\otimes H)$</span>, where <span class=""math-container"">$Ob_C$</span> denotes <span class=""math-container"">$Ob$</span> controlled by the ancilla qubit.</p>
<p>Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â 
<a href=""https://i.stack.imgur.com/t8Xpl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t8Xpl.png"" alt=""enter image description here"" /></a></p>
<p>My question is whether this definition is correct. If so, why does <code>cirq</code> constrain <code>simulate_expectation_values</code> method only for observables being Pauli Strings (tensor product of Pauli Gates)?</p>
<hr />
<p>After @Craig Gidney answer I thought it would be easy to write (just using <code>cirq</code> and <code>numpy</code>) a code that computes expectation value with regard to arbitrary observable and I derived the following snippet:</p>
<pre><code>import cirq
from copy import deepcopy
from cirq import X, CZ, H, Circuit, Simulator, GridQubit, InsertStrategy
import numpy as np

def example_circuit(q0, q1):
    sqrt_x = X ** 0.5
    yield sqrt_x(q0), sqrt_x(q1)
    yield CZ(q0, q1)
    yield sqrt_x(q0), sqrt_x(q1)

def extend_circ(C, Ob):
    circ = deepcopy(C)
    q2 = GridQubit(2, 0)
    ObC = Ob.controlled_by(q2)
    circ.append([H(q2), ObC, H(q2)], strategy=InsertStrategy.NEW_THEN_INLINE)
    return circ

def main():
    q0 = GridQubit(0, 0)
    q1 = GridQubit(1, 0)

    C = Circuit(example_circuit(q0, q1))
    Ob = cirq.X(q0) * cirq.X(q1)
    # Ob = cirq.X(q0)*cirq.X(q1) + 0.1 * cirq.Z(q0) * cirq.Z(q1)

    ext_circ = extend_circ(C, Ob)
    print(ext_circ)
    result = Simulator().simulate(ext_circ)
    print(result)
    p0 = np.sqrt(np.sum(np.abs(result.final_state_vector[::2])**2))
    p1 = np.sqrt(np.sum(np.abs(result.final_state_vector[1::2])**2))
    expectation_value = p0 - p1
    print('Expectation Value: {}'.format(expectation_value))


if __name__ == '__main__':
    main()
</code></pre>
<p>Which gives the following output obtained from prints:</p>
<pre><code>(0, 0): âââX^0.5âââ@âââX^0.5âââââââPauliString(+X)âââââââ
                   â               â
(1, 0): âââX^0.5âââ@âââX^0.5âââââââXâââââââââââââââââââââ
                                   â
(2, 0): âââââââââââââââââââââââHâââ@âââââââââââââââââHâââ
measurements: (no measurements)
output vector: 0.5|000â© + 0.5j|010â© + 0.5j|100â© + 0.5|110â©
Expectation Value: 0.9999999403953552
</code></pre>
<p>However, if I uncomment <code># Ob = cirq.X(q0)*cirq.X(q1) + 0.1 * cirq.Z(q0) * cirq.Z(q1)</code> I obtain the error <code>AttributeError: 'PauliSum' object has no attribute 'controlled_by'</code> which indicates that in order to apply my method an observable must be &quot;controlable&quot;.</p>
<p><strong>My naive question.</strong> Maybe it would be easier to make in <code>cirq</code> all observables controlable by definition (i.e. extend <code>controlled_by</code> method to all observables)?</p>
",<programming><algorithm><circuit-construction><cirq>,04/08/2021 16:15,16912.0,16912.0,"<blockquote>
<p>why does cirq constrain simulate_expectation_values method only for observables being Pauli Strings</p>
</blockquote>
<p>It's certainly not a <em>necessary</em> constraint. But a reason a library would do Pauli products <em>first</em> is that they are simple, pretty flexible, and widely used. For example, they're easy to measure on hardware (only single qubit operations needed) and they're the basis of the stabilizer formalism.</p>
<p>A good contribution to Cirq would be to generalize this method to work on <code>cirq.PauliSum</code> observables like <code>cirq.X(q1)*cirq.X(q2) + 0.1 * cirq.Z(q1) * cirq.Z(q2)</code>. Cirq doesn't really have a more general definition of observable than that at the moment IIRC.</p>
",04/08/2021 16:49, Learning,The user is seeking clarification and assistance in understanding the definition of expectation values of observables for quantum circuits. They are also trying to implement this in code using Cirq and encountering errors. This falls under the category,Theoretical,"The question is primarily focused on the theoretical definition of expectation values for quantum circuits and observables. They are discussing their derived definition and the implications for applying it in the Cirq framework, which involves the mathematical foundations of quantum computing and observables.",No,107.0,Learning,"The user is seeking clarification and assistance in understanding the definition of expectation values of observables for quantum circuits and trying to implement it in code using Cirq, indicating a desire to learn and apply the concept practically."
16914.0,"How can I compose the Ising XXPOW,YYPOW and ZZPOW gate in single qubit gates and CNOT,...?","<p>I am a bit stuck in decomposing these gates in single qubit gates, in the Cirq documentation it is written, for example that XX is for example the tensor product of Rx gates. But when I calculate these, I get terms with sin*cos where they write a 0.
Is there any trick/explanation for this?</p>
",<programming><cirq><pauli-gates>,04/08/2021 18:59,16920.0,16920.0,"<p>XXPow isn't a tensor product of Rx gates. It raises the matrix resulting from such a tensor product to a power, but the result is not expressible as a tensor product anymore.</p>
<p>If you want to decompose into CNOT gates, the key thing you need to know is that you can change the observable being exponentiated by conjugating it with Clifford operations. For example, if you conjugate XX with CNOTs, the result is a single X on the control. Meaning you can decompose <span class=""math-container"">$(X \otimes X)^t$</span> into this:</p>
<p><a href=""https://i.stack.imgur.com/hqvRk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hqvRk.png"" alt=""enter image description here"" /></a></p>
<p>You can decompose the other ones similarly. Cirq can perform this decomposition for you, although it outputs CZ gates instead of CNOTs, via <code>cirq.two_qubit_matrix_to_operations</code>.</p>
",04/08/2021 20:53,Theoretical,The question is about the theoretical concepts of quantum gate decomposition and the mathematical calculations involved in it,Theoretical,,,,Theoretical,
16916.0,Is there any way to assign a colour for a single gate in Qiskit?,"<p>I'm drawing with Qiskit a big circuit with some predefined and custom gates. I want to colour some of them in non-default colours for a better reading of it. Is it possible to do it for predefined gates? And for custom ones? Here is some code to play with:</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister

def cnotnot(gate_label = 'CNOTNOT'):

    gate_circuit = QuantumCircuit(3, name = gate_label)
    gate_circuit.cnot(0, 1)
    gate_circuit.cnot(0, 2)

    gate = gate_circuit.to_gate()

    return gate

q = QuantumRegister(3, name = 'q')

circuit = QuantumCircuit(q)

circuit.append(cnotnot(), [q[0], q[1], q[2]])
circuit.h(q[0])

circuit.draw()
</code></pre>
<p>Thanks in advance!</p>
",<programming><qiskit><circuit-construction>,04/08/2021 19:25,16921.0,16921.0,"<p>I think it is something Qiskit used to have but got lost in a refactoring. I'm adding it back here <a href=""https://github.com/Qiskit/qiskit-terra/pull/6184"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/pull/6184</a> (with a regression test so it does not happen again) and it will probably be released in the next qiskit-terra patch version (0.17.1).</p>
<p>Here is your example (including <code>displaytext</code>):</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister

def cnotnot(gate_label = 'CNOTNOT'):

    gate_circuit = QuantumCircuit(3, name = gate_label)
    gate_circuit.cnot(0, 1)
    gate_circuit.cnot(0, 2)

    gate = gate_circuit.to_gate()

    return gate

q = QuantumRegister(3, name = 'q')

circuit = QuantumCircuit(q)

circuit.append(cnotnot(), [q[0], q[1], q[2]])
circuit.append(cnotnot('CNOTNOT_PRIME'), [q[0], q[1], q[2]])
circuit.h(q[0])

circuit.draw('mpl',
             style={'displaycolor': {'CNOTNOT': ('#000000', '#FFFFFF'),
                                           'h': ('#A1A1A1', '#043812')},
                    'displaytext': {'CNOTNOT_PRIME': &quot;<span class=""math-container"">$\\mathrm{CNOTNOT}'$</span>&quot;}})
</code></pre>
<p><a href=""https://i.stack.imgur.com/NU15k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NU15k.png"" alt=""enter image description here"" /></a></p>
",04/09/2021 05:40,Tooling,"The question is about using the Qiskit tool for quantum programming, specifically about customizing the visual representation of quantum circuits.",Tooling,,,,Tooling,
16917.0,Re-initializing qubits in a circuit without losing superposition,"<p>So recently I was building some circuit made of subcircuits. My subcircuits happen to use auxiliary qubits, that are always initialized in the state <span class=""math-container"">$|0\rangle$</span> and are not used after the calculation. Hence, I wanted to use the same set of auxiliary qubits for all the subcircuits by reinitializing them between subcircuits. As I code on Qiskit, I used reset gates to do so.</p>
<p>But I have a problem : my circuit is correct on each possible input state that belongs to the basis <span class=""math-container"">$\{|0\rangle,|1\rangle\}^{\otimes n}$</span>, but the reset gates make it fail for any superposed state, henceforth losing all quantum advantage.</p>
<p>I'll explain the problem with a simplified example : let's say that I have two subcircuits, C and C', that operate on 1 main qubit (that I want to change) and use 1 auxiliary qubit. When C takes as input <span class=""math-container"">$|0\rangle$</span> for the main qubit, it outputs the main qubit in the state <span class=""math-container"">$|0\rangle$</span> and leaves the auxiliary qubits in the state <span class=""math-container"">$|0\rangle$</span>, and when it takes as input <span class=""math-container"">$|1\rangle$</span> for the main qubit, it outputs the main qubit in the state <span class=""math-container"">$|1\rangle$</span> and gets the auxiliary qubits in the state <span class=""math-container"">$|1\rangle$</span>. My full circuit resets the auxiliary gate between C and C' (with the Qiskit reset gate) and then C' is applied to get the wanted output on the main qubit. Now, if I input the state <span class=""math-container"">$\frac{|0\rangle+|1\rangle}{\sqrt{2}}$</span> on the main qubit, which is overall (taking into account the auxiliary qubit) the input state <span class=""math-container"">$\frac{|0\rangle+|1\rangle}{\sqrt{2}} \otimes |0\rangle$</span>, after C we get :
<span class=""math-container"">$$\frac{|00\rangle+|11\rangle}{\sqrt{2}}$$</span>
But then after the reset gate we don't get :
<span class=""math-container"">$$\frac{|00\rangle+|10\rangle}{\sqrt{2}}$$</span>
But <span class=""math-container"">$|00\rangle$</span> 50% of the time and <span class=""math-container"">$|10\rangle$</span> 50% of the time. As superposition is broken, the main circuit gets flawed.</p>
<p>This behavior can be reproduced with the following code:</p>
<pre><code>qc=QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.reset(1)
backend=Aer.get_backend('statevector_simulator')
plot_histogram(execute(qc,backend,shots=1024).result().get_counts())
</code></pre>
<p>And by the way, in my understanding, this is in disagreement with this <a href=""https://quantumcomputing.stackexchange.com/a/12823/14793"">answer</a> - which motivated me to ask my question, even if it may seem redundant at first sight.</p>
<p>Is there a way I could fix that ?</p>
<p>I am pessimistic, as in my previous example, the operation I'd like to apply isn't unitary. But I know that I can find on this site people that are amazing at quantum computing, so I have hope that a solution can be found.</p>
<p>Thanks a lot,</p>
<p>Thomas</p>
",<programming><qiskit>,04/08/2021 19:59,16926.0,16926.0,"<p>The important point to understand is that you lose the superposition and obtain a <em>classical mixture</em> of states <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> on the first qubit.
If you look at the circuit diagram below:</p>
<ul>
<li>Before applying the reset you're in a Bell state (green).</li>
<li>As you apply the reset, you effectively remove the qubit from the system, you can think of it as tracing it out. If you trace out system B in the Bell state you obtain a maximally mixed state (blue).</li>
<li>Finally, you add a new qubit in state <span class=""math-container"">$|0\rangle$</span> that has no correlation whatsoever with qubit A, so you end up in a product state of a mixed state and the zero state (red).</li>
</ul>
<p><a href=""https://i.stack.imgur.com/4CQj9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4CQj9.png"" alt=""enter image description here"" /></a></p>
<p>This means your final state is <strong>not</strong> a pure state where the first qubit is in state <span class=""math-container"">$\frac{|0\rangle + |1\rangle}{2}$</span> and the second one, reset, in state <span class=""math-container"">$|0\rangle$</span>. Instead, it is a mix of <strong>classical probabilities</strong>
<span class=""math-container"">$$
\rho_{AB} = (p_1 \rho_1 + p_2 \rho_2) \otimes |0\rangle\langle 0|
$$</span>
where <span class=""math-container"">$p_1 = p_2 = 1/2$</span> and
<span class=""math-container"">$$
\rho_1 = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{pmatrix}, 
\rho_2 = \begin{pmatrix} 0 &amp; 0 \\ 0 &amp; 1 \end{pmatrix}.
$$</span></p>
<p>If you now perform a statevector simulation of this circuit, you have a 50% probability of measuring state <span class=""math-container"">$|00\rangle$</span> and 50% of measuring <span class=""math-container"">$|10\rangle$</span>. Running this in Qiskit</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute

circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cx(0, 1)
circuit.reset(1)

print(circuit.draw())

backend = Aer.get_backend('statevector_simulator')
statevector = execute(circuit, backend).result().get_statevector()
print('Statevector')
print(statevector)
</code></pre>
<p>will print <code>[1, 0, 0, 0]</code> in half the cases and <code>[0, 1, 0, 0]</code> in the other half. It is a classical combination of quantum states, not a superposition like <code>[0.707, 0.707, 0, 0]</code>.</p>
<p>What's a bit confusing now is that counting shots gives the same histogram for the classical mix of quantum states as for superposition. That's because the probability to measure either <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> is the same for both.
In Qiskit code:</p>
<pre><code>circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cx(0, 1)
circuit.reset(1)
circuit.measure_all() 

backend = Aer.get_backend('qasm_simulator')
counts = execute(circuit, backend).result().get_counts()
print('Counts')
print(counts)
</code></pre>
<p>Will give on average <code>{'00': 512, '10': 512}</code>.
But the pure state $|\phi\rangle = \frac{|0\rangle + |1\rangle}{2} \otimes |0\rangle$ will give the same histogram:</p>
<pre><code>circuit = QuantumCircuit(2)
circuit.h(0)
circuit.measure_all() 
</code></pre>
<p>A reset is a very &quot;brutal&quot; non-unitary operation and will destroy the pure state you have.</p>
<hr />
<p>Note: you can derive the same result by computing the density matrices in the circuit from @Egretta.Thula, I just skipped it to make the diagram easier.</p>
",04/09/2021 09:45,Errors,"The user is encountering a problem in their quantum circuit implementation using Qiskit, where the use of reset gates is causing issues with superposition, leading to unexpected behavior. They are seeking help to resolve this error in their quantum circuit design.",Errors,,,,Errors,
16922.0,Unable to use iSWAP in Qiskit TwoLocal entangling_block,"<p>I would like to use a general entangler in the entanglement_block of the TwoLocal function. The function seems to work with 'cz', 'cx', 'swap' gates, but it fails for 'iswap' gate. Below is the error message. Any help would be appreciated</p>
<pre><code>from qiskit.circuit.library import TwoLocal
ansatz = TwoLocal(num_spin_orbitals, ['ry', 'rz'], entanglement_blocks = 'iswap', entanglement='linear')
</code></pre>
<p>Gives the following error</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;ipython-input-34-5d8e95fd9811&gt;&quot;, line 2, in &lt;module&gt;
    ansatz = TwoLocal(num_spin_orbitals, ['ry', 'rz'], entanglement_blocks = 'iswap', entanglement='linear')
  File &quot;/opt/conda/lib/python3.8/site-packages/qiskit/circuit/library/n_local/two_local.py&quot;, line 177, in __init__
    super().__init__(num_qubits=num_qubits,
  File &quot;/opt/conda/lib/python3.8/site-packages/qiskit/circuit/library/n_local/n_local.py&quot;, line 140, in __init__
    self.entanglement_blocks = entanglement_blocks
  File &quot;/opt/conda/lib/python3.8/site-packages/qiskit/circuit/library/n_local/n_local.py&quot;, line 248, in entanglement_blocks
    self._entanglement_blocks = [self._convert_to_block(block) for block in blocks]
  File &quot;/opt/conda/lib/python3.8/site-packages/qiskit/circuit/library/n_local/n_local.py&quot;, line 248, in &lt;listcomp&gt;
    self._entanglement_blocks = [self._convert_to_block(block) for block in blocks]
  File &quot;/opt/conda/lib/python3.8/site-packages/qiskit/circuit/library/n_local/two_local.py&quot;, line 248, in _convert_to_block
    raise ValueError(f'Unknown layer name `{layer}`.') from ex
ValueError: Unknown layer name `iswap`.
</code></pre>
",<programming><qiskit><vqe>,04/09/2021 05:45,16924.0,16924.0,"<p>Although the documentation says that the <code>entanglement_blocks</code> parameter can be specified via the name of a gate or the gate type itself, not all gates can be used this way.
You can <a href=""https://qiskit.org/documentation/_modules/qiskit/circuit/library/n_local/two_local.html#TwoLocal"" rel=""nofollow noreferrer"">check the code</a> to get the list of supported gate names.</p>
<p>Since &quot;pass by name&quot; is not supported for iSWAP, you can use the gate type:</p>
<pre><code>ansatz = TwoLocal(num_spin_orbitals, ['ry', 'rz'], entanglement_blocks = iSwapGate(), entanglement='linear')
</code></pre>
",04/09/2021 07:32,Errors,The user is encountering an error while trying to use the iswap gate in the TwoLocal function of Qiskit. They are seeking help to resolve this issue,Errors,,,,Errors,
16927.0,Symbolic computation with quantum circuits,"<p>What are my options for <em>computing symbolic results for quantum circuits</em>?</p>
<p>I have identified some possibilities:</p>
<ul>
<li><p><a href=""https://docs.sympy.org/latest/modules/physics/quantum/index.html"" rel=""nofollow noreferrer"">SymPy</a> (Python library, see also <a href=""https://quantumcomputing.stackexchange.com/questions/9984/symbolic-quantum-computing-using-sympy-how-to-use-arbitrary-gate"">this</a>), unfortunately, the software forces you to encode the matrix of each gate explicitly instead of working with circuits;</p>
</li>
<li><p><a href=""https://qiskit.org/documentation/tutorials/operators/01_operator_flow.html"" rel=""nofollow noreferrer"">IBM Qiskit v0.25 operator framework</a> (Python library), which claims</p>
<blockquote>
<p>Qiskit operators fully support parameterization</p>
</blockquote>
<p>even if it seems not completely true since the same error of <a href=""https://quantumcomputing.stackexchange.com/questions/14867/creating-a-parameterized-operator-in-qiskit"">this older question</a> holds and <a href=""https://github.com/Qiskit/qiskit-terra/issues/4751"" rel=""nofollow noreferrer"">this issue</a> is still open.</p>
</li>
</ul>
",<programming><qiskit>,04/09/2021 10:14,16960.0,16960.0,"<h2>No symbolic computation software with quantum circuits built in</h2>
<p>The asker has clarified <a href=""https://quantumcomputing.stackexchange.com/questions/16927/symbolic-computation-with-quantum-circuits?noredirect=1#comment24953_16927"">in this comment</a> that they want a symbolic computation software in which the user <em><strong>does not</strong></em> &quot;have to manually define circuits in terms of matrix multiplications&quot;, and the question says that the software cannot &quot;force you to encode the matrix of each gate explicitly&quot;. <strong>This unfortunately does not exist.</strong></p>
<p>In all symbolic computation software, one will have to encode the matrix of each gate (X,Y,Z,CNOT,H,etc.) and use tensor products (i.e. Kronecker products) and matrix multiplications to get the effect of the unitary operation of a quantum circuit; or find some add-on where someone else did exactly that and made it available to others. <strong>Luckily, it is not hard to define the gates manually, and to do matrix multiplications, in any symbolic computation software.</strong></p>
<h2>Quantum add-ons for popular symbolic computation software</h2>
<p>The most popular long-standing symbolic computation packages which are still actively being developed are:</p>
<ul>
<li>Mathematica,</li>
<li>Sage,</li>
<li>SymPy,</li>
<li>Maple,</li>
<li>MATLAB's Symbolic Computation Toolbox,</li>
<li>Maxima,</li>
<li>Magma, and</li>
<li>Scilab</li>
</ul>
<p>There's others too, which people are welcome to suggest I add, but seriously anything other than the first five are not really &quot;popular&quot; in the circles that I know.</p>
<p>Since none of the above symbolic computation software has quantum circuit functionality built in to the extent where the user does not have to define the gates or explicitly involve matrix multiplications commands *natively *without relying on a third-party add-on where someone else did exactly the same thing, the asker says again in the same comment as above:</p>
<blockquote>
<p>&quot;any software for symbolic computation having dedicated features/facilities for quantum computing is accepted.&quot;</p>
</blockquote>
<p>I will therefore point out that of that list of 8 major symbolic computation software packages, the one with the largest volume of quantum add-ons is Mathematica (also by far the most popular and highly developed package out of all of the above, <em>for symbolic computation</em>):</p>
<h3>Quantum add-ons for Mathematica</h3>
<ul>
<li><p><a href=""https://library.wolfram.com/infocenter/MathSource/7622/"" rel=""nofollow noreferrer"">Quantum Mathematica</a>: includes the ability to do quantum circuits in 2D and 3D, some Adiabatic Quantum Computing functionality, and the Quantum Fourier Transform. Unfortunately this has not been revised since 2010, according to that link, and since 2011 <a href=""http://homepage.cem.itesm.mx/lgomez/quantum/"" rel=""nofollow noreferrer"">according to this</a>, though the authors wrote <a href=""https://iopscience.iop.org/article/10.1088/1742-6596/698/1/012019"" rel=""nofollow noreferrer"">a paper about it</a> in 2015.</p>
</li>
<li><p><a href=""http://www.pitt.edu/%7Etabakin/QDENSITY/index.htm"" rel=""nofollow noreferrer"">QDENSITY</a>: Less well documented than Quantum Mathematica, but published more recently (August 2017).</p>
</li>
<li><p><a href=""https://arxiv.org/abs/1403.7050"" rel=""nofollow noreferrer"">Using Mathematica for Quantum Mechanics</a>: This is also published in a <a href=""https://www.springer.com/gp/book/9789811375873"" rel=""nofollow noreferrer"">book</a>, however it's more geared towards &quot;quantum mechanics&quot; than &quot;quantum computing&quot;.</p>
</li>
<li><p>There's also <a href=""https://demonstrations.wolfram.com/topic.html?topic=quantum%20mechanics&amp;start=161&amp;limit=20&amp;sortmethod=recent"" rel=""nofollow noreferrer"">378 quantum mechanics related Mathematica demonstrations</a> on the Wolfram Demonstrations Project, but most if not all of them are geared towards quantum mechanics and not so much quantum computing.</p>
</li>
</ul>
<p>Therefore &quot;Quantum Mathematica&quot; and &quot;QDENSITY&quot; are your best options with Mathematica, and unfortunately these will require a Mathematica license, which will be very expensive if you don't have a discount or free access through (for example) a university.</p>
<h3>Quantum add-ons for Maple</h3>
<p>Although Maple has declined in popularity in recent years, they also do support Dirac notation as seen <a href=""https://www.maplesoft.com/products/maple/new_features/maple2018/physics.aspx"" rel=""nofollow noreferrer"">here</a> and <a href=""https://www.mapleprimes.com/posts/208822-Quantum-Mechanics-Using-Maples-Physics-Package"" rel=""nofollow noreferrer"">here</a>, but there's nothing that can do entire quantum circuits as far as I know.</p>
<h3>My recommendation if you don't have access to Mathematica:</h3>
<p>Just use SymPy or Sage (both open-source and Python based) and define the gates (X,Y,Z,CNOT,H,etc.) manually and do the matrix multiplications, since this will just take a couple hours. <strong>You can also read the above papers on how it was done in Mathematica, to give you ideas on how to efficiently save time in doing it with SymPy or Sage</strong> (i.e. how to make it so that you don't have to repeat the identity matrix so many times, for example).</p>
",04/11/2021 21:27,Learning," The user is seeking information and resources for computing symbolic results for quantum circuits. They are exploring different libraries and tools, and looking for more options. ",Learning,,,,Learning,
16932.0,'Best practices' for making Stim run as fast as possible?,"<p>I'm currently testing out an error-correction surface code circuit in <a href=""https://github.com/quantumlib/Stim"" rel=""noreferrer"">Stim</a>.</p>
<p>I've tried a 19x19 surface code over 10k rounds of syndrome extraction sampled 256 times, and this takes about 165 seconds.  This comes out to roughly ~100s of nanoseconds per measurement, which is not as fast as I'd like.</p>
<p>I was wondering if there are 'best practices' for making circuits as fast as possible in Stim?</p>
",<programming><error-correction><simulation><stim>,04/09/2021 19:31,16933.0,16933.0,"<ol>
<li><p><strong>Output format</strong>: Use a bit packed output format that has 8 results per byte instead of 1. In the python bindings, this means calling <code>sample_bit_packed</code> instead of <code>sample</code>. From the command line, this means specifying <code>--out_format=b8</code>. You're paying ~5x performance if you're using a non-bit packed output.</p>
<p>From the command line, for detection events, you can also consider sparse output formats like <code>--out_format=r8</code> where each byte tells you the number of 0 results until the next 1 (except 0xFF used for long runs of zeros). For error rates below 0.1% this can easily be 10x less data output.</p>
</li>
<li><p><strong>Sample size</strong>: Take a number of samples that's a multiple of 256. Stim internally pads the number of samples up to a multiple of 256, because it operates simultaneously across batches using 256 bit wide AVX instructions. It does this even if you ask for 2 samples, and the other 254 are going to be discarded.</p>
</li>
<li><p><strong>Command Line Tool</strong>: Consider using the command line tool instead of the python bindings. The python bindings add overhead (extra data copying), and are currently less flexible than the command line tool. You're paying ~2x performance to use stim via python.</p>
<p>Note that when you print a <code>stim.Circuit</code> in python, the result is text that the command line tool can parse to get that exact same circuit, so it's quite easy to generate your circuit files from python by making the circuit as usual and printing it to a file.</p>
<p>An example where the command line tool is currently <em>necessary</em> is if your circuit is really big, with hundreds of billions of bits of data coming out. The command line tool will notice the size and automatically switch from buffering all results in memory to streaming results to disk. The python bindings are not currently capable of doing this, because they return the results as a numpy array; in memory. Speaking from personal experience, streaming the results from huge circuits can be the difference between things working and watching helplessly as your computer completely freezes due to madly swapping memory to and from disk.</p>
</li>
<li><p><strong>REPEAT block</strong>: Use the <code>REPEAT</code> block instead of explicitly repeating things. If you have a circuit with a hundred thousand rounds of the same operations, putting them inside a <code>REPEAT 100000 { ... }</code> block instead of actually repeating them a hundred thousand times will reduce memory usage and hugely reduce parsing time.</p>
<p>In the python bindings, you can create a repeat block by multiplying the circuit by an integer. So create a <code>stim.Circuit</code> containing the body of the loop, then do <code>full_circuit += loop_body * 100000</code>.</p>
</li>
<li><p><strong>Grouping operations</strong>: Have your measurements come in groups and your resets come in groups, without other operations or noise in between. For example, this:</p>
<pre><code> M 0
 M 1
 M 2
 X_ERROR(0.01) 0
 X_ERROR(0.01) 1
 X_ERROR(0.01) 2
</code></pre>
<p>happens to be faster than this:</p>
<pre><code> M 0
 X_ERROR(0.01) 0
 M 1
 X_ERROR(0.01) 1
 M 2
 X_ERROR(0.01) 2
</code></pre>
<p>This is because (currently) stim temporarily transposes the entire stabilizer tableau when performing a measurement, but avoids re-transposing for adjacent measurements.</p>
<p>It's certainly possible for stim to be made smarter here, to move measurements around so more can be fused or to partially transpose the tableau as required, but currently it's not that smart.</p>
<p>Grouping measurements isn't relevant if you're sampling detection events or specify <code>--frame0</code>, because those modes bypass the stabilizer tableau simulation step where the transposing occurs. But you never know when you'll later want raw measurements...</p>
<p>Another, more minor, benefit of grouping operations of the same type is that a noisy operation with many targets can have their &quot;did the error happen&quot; bits generated together in an efficient way. But if you're asking for hundreds or thousands of samples then you're already getting most of that benefit.</p>
</li>
</ol>
",04/09/2021 20:00,Tooling,"The user is seeking advice on how to optimize the performance of their quantum error-correction circuit in the Stim library, which falls under the category of tool usage.",Tooling,,,,Tooling,
16946.0,PyTorch and Qiskit example from the Qiskit textbook seems broken,"<p>After executing the proceeding code blocks, when I try to copy the same code from <a href=""https://qiskit.org/textbook/ch-machine-learning/machine-learning-qiskit-pytorch.html#3.-Let%27s-code!-"" rel=""nofollow noreferrer"">Qiskit textbook</a> on my jupyter notebook, I get the error as</p>
<p><code> QiskitError: 'Data for experiment &quot;circuit-109&quot; could not be found.'</code></p>
<pre><code>simulator = qiskit.Aer.get_backend('qasm_simulator')

circuit = QuantumCircuit(1, simulator, 100)
print('Expected value for rotation pi {}'.format(circuit.run([np.pi])[0]))
circuit._circuit.draw(
)

</code></pre>
<p>Please suggest:</p>
<pre><code>&lt;ipython-input-23-06b09ff4dd69&gt; in &lt;module&gt;
      2 
      3 circuit = QuantumCircuit(1, simulator, 100)
----&gt; 4 print('Expected value for rotation pi {}'.format(circuit.run([np.pi])[0]))
      5 circuit._circuit.draw()

&lt;ipython-input-22-e6eb9c91d6f9&gt; in run(self, thetas)
     28                         parameter_binds = [{self.theta: theta} for theta in thetas])
     29         job = self.backend.run(qobj)
---&gt; 30         result = job.result().get_counts(self._circuit)
     31 
     32         counts = np.array(list(result.values()))

~\anaconda3\lib\site-packages\qiskit\result\result.py in get_counts(self, experiment)
    261         dict_list = []
    262         for key in exp_keys:
--&gt; 263             exp = self._get_experiment(key)
    264             try:
    265                 header = exp.header.to_dict()

~\anaconda3\lib\site-packages\qiskit\result\result.py in _get_experiment(self, key)
    368 
    369             if len(exp) == 0:
--&gt; 370                 raise QiskitError('Data for experiment &quot;%s&quot; could not be found.' %
    371                                   key)
    372             if len(exp) == 1:

QiskitError: 'Data for experiment &quot;circuit-109&quot; could not be found.'```
</code></pre>
",<programming><qiskit><textbook-and-exercises>,04/11/2021 02:40,16948.0,16948.0,"<p>After checking, this issue was introduced in the last qiskit-terra release. The textbook should be fixed to adjust the <code>get_counts</code>, as already reported <a href=""https://github.com/qiskit-community/qiskit-textbook/issues/1038"" rel=""nofollow noreferrer"">here</a>.</p>
<p>In any case, the workaround for now is removing <code>self._circuit</code> from <code>result = job.result().get_counts(self._circuit)</code> (in <code>QuantumCircuit.run</code> method).</p>
<pre><code>class QuantumCircuit:
    ...

    def run(self, thetas):
        ...
        job = self.backend.run(qobj)
        result = job.result().get_counts()  # &lt;- here
        ...
</code></pre>
",04/11/2021 06:55,Errors,The user is encountering an error while executing a quantum circuit in Qiskit in their Jupyter notebook. They are seeking help to resolve this issue,Errors,,,,Errors,
17043.0,Implementing 3-Qubit Grover Algorithm in Qiskit,"<p><a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#3qubits"" rel=""nofollow noreferrer"">The Qiskit tutorial on Grover's Algorithm</a> shows an example of finding two marked solutions out of 8 items, produced by 3 qubits. Using the general diffuser code it provides, however, I realize that the algorithm fails to properly find the solution if the oracle is set to mark single item.</p>
<p>Specifically, the oracle in the example marks two items:</p>
<pre><code>qc = QuantumCircuit(3)
qc.cz(0, 2)
qc.cz(1, 2)
oracle_ex3 = qc.to_gate()
oracle_ex3.name = &quot;U$_\omega$&quot;
</code></pre>
<p>I've changed it to mark just one:</p>
<pre><code>qc = QuantumCircuit(3)
qc.cz(0, 2)
oracle_ex3 = qc.to_gate()
oracle_ex3.name = &quot;U$_\omega$&quot;
</code></pre>
<p>Now that there is only one solution and 8 possibilities, we should iterate the Grover oracle + diffuser twice, for which I did:</p>
<pre><code>n = 3
grover_circuit = QuantumCircuit(n)
grover_circuit = initialize_s(grover_circuit, [0,1,2])
grover_circuit.append(oracle_ex3, [0,1,2])
grover_circuit.append(diffuser(n), [0,1,2])
grover_circuit.append(oracle_ex3, [0,1,2])
grover_circuit.append(diffuser(n), [0,1,2])
grover_circuit.measure_all()
</code></pre>
<p>And here is the measurement outcome plot:
<a href=""https://i.stack.imgur.com/tDlR6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tDlR6.png"" alt="""" /></a></p>
<p>As far as I expect the plot should show the state <span class=""math-container"">$|101â©$</span> with nearly 100% probability. I tried iterating it 3 and 4 times, but the result is still messy. Is there something that I'm missing here?</p>
",<programming><qiskit><grovers-algorithm><oracles>,4/14/2021 13:12,17046.0,17046.0,"<p>Number of states marked isn't a strict correspondence with number of CZ gates: your new oracle still marks two states, but, rather than <span class=""math-container"">$\left|101\right&gt;$</span> and <span class=""math-container"">$\left|110\right&gt;$</span>, it marks <span class=""math-container"">$\left|101\right&gt;$</span> and <span class=""math-container"">$\left|111\right&gt;$</span>. To see this, remember a <span class=""math-container"">$Z$</span> gate flips the sign of a <span class=""math-container"">$\left|1\right&gt;$</span>: if the <span class=""math-container"">$Z$</span> gate is applied to a 1 and the control is a 1, the sign is flipped, so, in your new circuit the first and last qubit have to be 1 but the other could be 0 or 1 and still be flipped, so either situation ends up marked. The original circuit doesn't have <span class=""math-container"">$\left|111\right&gt;$</span> as an option since it makes both <span class=""math-container"">$Z$</span> gates flip the sign which cancels out, meaning that one but not both of the control qubits have to be 1. If you only apply the Grover Diffuser once in either the original circuit or your new one, it will be a superposition of the two marked states and will work correctly.</p>
<p>If you want to implement a marking of one state in an intuitively simple fashion, use a CCZ gate and flank each qubit that needs to be a 0 with <span class=""math-container"">$X$</span> gates. If you do this, it will get the answer with high probability after 2 Grover Diffusions as expected.</p>
",4/14/2021 14:10, Errors,"The user is encountering an issue with the implementation of Grovers Algorithm in Qiskit, where the algorithm fails to find the correct solution when the oracle marks a single item. They are seeking help to resolve this error.", Errors,,,, Errors,
17082.0,Recover backend information in working remotely with the IBM-QC,"<p>I'm reading the details of <code>qiskit</code> following <a href=""https://arxiv.org/pdf/1809.03452.pdf"" rel=""nofollow noreferrer"">this paper</a> (I know it's a little bit dated, but some things shown there should be in principle still accessible). For concreteness I'm trying to see the characteristics of the backend</p>
<pre><code>provider = IBMQ.get_provider(hub='ibm-q')
backend = provider.get_backend('ibmq_quito')
</code></pre>
<p>Now, according to the reference, the backend have to be equipped with the configuration files. However, if I do</p>
<pre><code>backend.configuration()
</code></pre>
<p>I only get</p>
<pre><code>&lt;qiskit.providers.models.backendconfiguration.QasmBackendConfiguration object at 0x7f5f567af760&gt;
</code></pre>
<p>How can I display the full information for this backend, e.g. backend_name, backend_version, etc. etc.?</p>
",<programming><ibm-q-experience>,4/15/2021 15:10,17083.0,17083.0,"<p>If you want, everything is detailed <a href=""https://quantum-computing.ibm.com/lab/docs/manage/systems/configuration#system-configuration"" rel=""nofollow noreferrer"">here</a> about the system configuration, it will explain everything you can find in the configuration.</p>
<p>Just a quick resume about how to see the info : personally, I sometimes use <code>backend.configuration().to_dict()</code>, with this all of the information will be printed in a <code>dict</code>, and it's pretty easy to use. Now, you can also do a &quot;pretty&quot; print of this by using the <a href=""https://qiskit.org/documentation/apidoc/tools_jupyter.html"" rel=""nofollow noreferrer"">Jupiter tools</a> (there's a lot of useful stuffs here other than printing backend config just in case), anyway by doing this :</p>
<pre><code>from qiskit import IBMQ
import qiskit.tools.jupyter
%matplotlib inline

IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
backend = provider.get_backend('ibmq_quito')
backend 
</code></pre>
<p>This will give you a pretty print of the backend configuration :)</p>
",4/15/2021 15:51,Tooling,The user is seeking help with using the Qiskit library to access and display the full configuration information for a specific quantum computing backend.,Tooling,,,,Tooling,
17166.0,Error when attempting to visualize controlled hadamard gate state matrix with qiskit,"<p>I'm trying to get used to the qiskit module and quantum circuits in general, before tackling a QML project. So I'm going through the tutorial on the documentation page regarding <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html"" rel=""nofollow noreferrer"">gates</a>. I've gotten as far as the controlled Hadamard gate. I can create the circuit and print it out, but once I try to run the job, I get an error:</p>
<pre><code>q0_0: âââ ââ
      âââ´ââ
q0_1: â¤ H â
      âââââ
Simulation failed and returned the following error message:
ERROR:  [Experiment 0] Circuit contains invalid instructions {&quot;gates&quot;: {ch}} for &quot;unitary&quot; method
</code></pre>
<p>I had to modify the sample code a little because it threw a few deprecation errors and I couldn't get it to display the circuit or the matrix as it stood.
The example code (gathered into 1 from the tutorial):</p>
<pre><code>import matplotlib.pyplot as plt
%matplotlib inline
import numpy as np
from math import pi

from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity
from qiskit import BasicAer

backend = BasicAer.get_backend('unitary_simulator')

q = QuantumRegister(2)
qc = QuantumCircuit(q)
qc.ch(q[0],q[1])
qc.draw()

job = execute(qc, backend)
job.result().get_unitary(qc, decimals=3)
</code></pre>
<p>The main change I had to make, was irt. the <code>.draw()</code> and <code>execute()</code> functions. I got some errors there when importing. Since I couldn't find a provider called <code>BasicAer</code> I went with the <code>Aer</code> provider. for all single-qubit states, this worked as well as for controlled X Y and Z gates.</p>
<pre><code>from qiskit import \
        QuantumCircuit,\
        QuantumRegister,\
        ClassicalRegister
from qiskit.providers.aer import UnitarySimulator

import numpy as np

backend = UnitarySimulator()
n = 2
q = QuantumRegister(n)

qc = QuantumCircuit(q)
qc.ch(q[0], q[1]) # LSB first
print(qc)
job = backend.run(qc)
</code></pre>
<p>I tried to google the error message, but I couldn't find any previous issues regarding this, nor any particular error message like it.</p>
<p>The error refers to a &quot;Unitary&quot; method. This could be the <code>unitary_simulator</code>/<code>UnitarySimulator</code> the tutorial used versus the one I imported. Testing it, the code seems to run, though I struggle to see the output. In addition, an error is then thrown at the <code>decimal</code> bit in the tutorial. It seems like I could make it work if I changed the import method, but I don't quite understand why. There were also some deprecation warnings for the tutorial in earlier parts, which my previous methods avoided, in particular regarding the Unitary operator and the decomposition into u3, u2 and u1.</p>
<p>Is the <code>BasicAer.get_backend('unitary_simulator')</code>method in the process of phasing out, or is it an either or situation? is there a particular reason for the difference in the functionality between the 2?</p>
<pre><code>&gt;&gt;&gt; qiskit.__qiskit_version__
{'qiskit-terra': '0.17.0', 'qiskit-aer': '0.8.0', 'qiskit-ignis': '0.6.0', 'qiskit-ibmq-provider': '0.12.2', 'qiskit-aqua': '0.9.0', 'qiskit': '0.25.0'}
</code></pre>
<p>Edit:
I got a tip from a TA regarding the use of <code>execute()</code> which does let the program run. From a quick look at the documentation, it seems like there are few differences between the <code>execute()</code> and <code>backend.run()</code>, though according to <a href=""https://quantumcomputing.stackexchange.com/questions/12757/what-is-the-difference-between-qiskit-execute-and-the-ibmqjobmanager"">this</a> it could be that the <code>execute()</code> transpiles the circuit first? but I don't quite see why that would allow for unitary operations.</p>
<p>Another thing, I have tested the same type of imports on singular bit gates such as the U gate, and on 2-qubit gates such as the CX gate, which both work with the unitary operator from what I understand. And there are no new function calls for the CH gate.
I guess part of it is that I don't see why it fails for the CH and not for H, U  or CX or others.</p>
",<programming><qiskit>,4/20/2021 13:03,17167.0,17167.0,"<p>As it is written in the error message, it is here because the CH gate is not in the basis gates of <code>UnitarySimulator</code>, therefore the backend doesn't understand it and can't do anything with it ; check this line of code :</p>
<pre><code>'ch' in UnitarySimulator().configuration().basis_gates
</code></pre>
<p>It returns <code>False</code>.</p>
<p>Now I believe it has the error with the <code>run</code> method and not the <code>execute</code> function because in the execute function, there is a step called the <a href=""https://qiskit.org/documentation/apidoc/transpiler.html?highlight=transpiler#module-qiskit.transpiler"" rel=""nofollow noreferrer""><em>transpiler</em></a> that does this translation step into gates the backend knows. It is a vital step when you are running on actual devices that have basis gates equal to <code>['x', 'sx', 'rz', 'id', 'cx']</code>. Nothing needs to change when you use the execute function, but with the run method you could do something like this :</p>
<pre><code>qc = QuantumCircuit(q)
qc.ch(q[0], q[1]) # LSB first
qc = transpile(qc, backend)
qobj = assemble(qc, backend)
print(qc)
job = backend.run(qobj)
</code></pre>
",4/20/2021 13:45, Errors,"The user is encountering an error when attempting to run a quantum circuit with a controlled Hadamard gate (CH gate) using Qiskit. They have made modifications to the tutorial code but are still experiencing issues, and they seek an explanation for why the CH gate is causing the error while other gates like H, U, and CX do not.",Errors,,,, Errors,
17175.0,Quantum Katas - Tutorials - Oracles - Task 3.3 (OR oracle of all bits except for a single bit),"<p>Let <span class=""math-container"">$x$</span> be an arbitrary state composed of <span class=""math-container"">$N$</span> qubits and <span class=""math-container"">$k$</span> be an integer such that <span class=""math-container"">$0\leq k \leq N.$</span></p>
<p>The task is to ignore the <span class=""math-container"">$k$</span>-th bit and to flip the sign of <span class=""math-container"">$x$</span> if any of the remaining bits are equal to 1. In other words, flipping the sign of <span class=""math-container"">$x$</span> is independent of the <span class=""math-container"">$k$</span>-th bit, but it is dependent on the existence of 1's lurking in <span class=""math-container"">$x$</span>.</p>
<p>The solution I came up with is the following, which, unfortunately, I cannot implement.</p>
<p>Regardless of what <span class=""math-container"">$x$</span> is we flip its sign. There are two cases we should correct for, namely, the binary representations of 0 and <span class=""math-container"">$2^k$</span>. Could not we take care of these two scenarios by using the ControlledOnInt function by setting <span class=""math-container"">$\textit{numberstate}$</span> to 0 (first we have the <span class=""math-container"">$X$</span> gate act on <span class=""math-container"">$x[k]$</span>, so that <span class=""math-container"">$Z$</span> flips <span class=""math-container"">$x$</span>) and <span class=""math-container"">$2^k$</span>, the <span class=""math-container"">$\textit{oracle}$</span> to <span class=""math-container"">$Z$</span>, the <span class=""math-container"">$\textit{control register}$</span> to <span class=""math-container"">$[x]$</span> and the <span class=""math-container"">$\textit{target register}$</span> to <span class=""math-container"">$x[k]$</span>? Also, why can't the control and target registers be the same?</p>
<p>How could we implement the above with an auxiliary qubit?</p>
<p>In the second case where <span class=""math-container"">$x$</span> is the binary representation of <span class=""math-container"">$2^k$</span>, we could use the task 3.2 from the same tutorial (flips the sign of <span class=""math-container"">$x$</span> if the <span class=""math-container"">$k$</span>-th qubit is 1), but I am also having trouble with that task. I have been able to implement the OR oracle (task 3.1 of the same tutorial), but it was done with a marking oracle, not a phase oracle.</p>
",<q#><oracles>,4/21/2021 2:20,17176.0,17176.0,"<p>There is a much simpler way to approach this task. It requires only two observations:</p>
<ol>
<li><p>You can always convert a marking oracle to a phase oracle using the phase kickback trick (discussed earlier in the tutorial). Some tasks in this tutorial prohibit using extra qubits for this purpose to push you towards a solution that doesn't rely on that, but this task doesn't have this restrictions, so you can allocate that extra qubit, implement a marking oracle and use them to get your phase oracle.</p>
</li>
<li><p>If you need to perform some computation on the whole register except one qubit, why not just define a qubit array that holds the rest of the qubits and use that array as the input for the marking oracle? (This is more of a programming trick than a quantum computing one, but it's a useful one!)</p>
</li>
</ol>
<p>With those two observations, the code is pretty straightforward:</p>
<pre><code>use minus = Qubit();
within {
    X(minus);
    H(minus);
} apply {
    Or_Oracle(x[...k-1] + x[k+1...], minus);
}
</code></pre>
<p><code>x[...k-1] + x[k+1...]</code> is a concatenation of two qubit arrays: all qubits before the <span class=""math-container"">$k$</span>-th one and all qubits after the <span class=""math-container"">$k$</span>-th one.</p>
<p>You can always check the file ReferenceImplementation.qs in the tutorial folder to see the author's solutions to the tasks.</p>
",4/21/2021 2:51,Learning,"The user is trying to understand how to implement a specific quantum operation using Qiskit, specifically how to flip the sign of a state based on certain conditions. They are seeking guidance on how to achieve this, which falls under the category of learning and understanding quantum computing concepts and techniques", Conceptual,The  question pertains to the conceptual understanding and implementation of a quantum operation that flips the sign of a quantum state based on certain conditions. They are discussing the theoretical aspects of this quantum operation and how to implement it using various quantum gates and techniques.,No,108.0, Learning,"The user is seeking guidance on understanding and implementing a specific quantum operation in Qiskit, indicating a desire to learn and apply quantum computing concepts practically."
17187.0,Calculating the ground states of an Ising Hamiltonian on a real quantum computer,"<p>I have followed <a href=""https://juliaphysics.github.io/PhysicsTutorials.jl/tutorials/general/quantum_ising/quantum_ising.html"" rel=""nofollow noreferrer"">this</a> tutorial and based on it, I've written the following function in qiskit, which can explicitly calculate the ground states of a transverse-field Ising Hamiltonian.</p>
<pre><code>from qiskit import *
import numpy as np

def Hamiltonian(n,h):
    pow_n=2**n
    qc = np.empty(2*n-1, dtype=object)
    #Creating the quantum circuits that are used in the calculation of the Hamiltonian based on the number of qubits
    for i in range(0, 2*n-1): #2n-1 is the number of factors on the n-site Hamiltonian
        qr = QuantumRegister(n) 
        qc[i] = QuantumCircuit(qr) #create quantum circuits for each factor of the Hamiltonian
        #print(i)
        if (i&lt;=n-2): #for the first sum of the Hamiltonian
            qc[i].z(i) #value of current spin
            qc[i].z(i+1) #and value of its neighboring spin
        else: #for the second sum of the Hamiltonian
            qc[i].x(2*n-2-i) #2*n-2 gives the proper index since counting starts at 0
    #Run each circuit in the simulator        
    simulator = Aer.get_backend('unitary_simulator')
    result = np.empty(2*n-1, dtype=object) 
    unitary = np.empty(2*n-1, dtype=object) 
    Hamiltonian_Matrix=0
    #Get the results for each circuit in unitary form
    for i in range(0, 2*n-1):
        result[i] = execute(qc[i], backend=simulator).result()
        unitary[i] = result[i].get_unitary()
        #print(unitary[i])
        #And calculate the Hamiltonian matrix according to the formula
        if (i&lt;=n-2):
            Hamiltonian_Matrix=np.add(Hamiltonian_Matrix,-unitary[i])
        else:
            Hamiltonian_Matrix=np.add(Hamiltonian_Matrix,-h*unitary[i])
    print(&quot;The&quot;,pow_n,&quot;x&quot;,pow_n, &quot;Hamiltonian Matrix is:&quot;)
    print(Hamiltonian_Matrix)
    #Now that we have the Hamiltonian
    
    #find the eigenvalues and eigenvectors
    w, v = np.linalg.eig(Hamiltonian_Matrix)
    print(&quot;Eigenvectors&quot;)
    print(v)
    print(&quot;Eigenvalues&quot;)
    print(w)
    minimum=w[0]
    min_spot=0
    for i in range(1, pow_n):
        if w[i]&lt;minimum:
            min_spot=i
            minimum=w[i]                   
    print(min_spot)
    groundstate = v[:,min_spot]
    #the probability to measure each basic state of n qubits
    probability = np.square(groundstate).real
    print(&quot;The probability for each of the&quot;,pow_n,&quot;base states is:&quot;)
    print(probability)
    print(&quot;The probabilities for each of the&quot;,pow_n,&quot;base states add up to:&quot;)
    print (&quot;%.2f&quot; % np.sum(probability))
</code></pre>
<p>My problem with this piece of code I've written is that it can only run on a unitary simulator. To my understanding (which may lack some of the underlying physics), the Hamiltonian itself is not a &quot;purely&quot; quantum calculation, since there are additions to be made which cannot be expressed with a quantum (unitary) gate, and this is why the resulting Hamiltonian matrix is also not unitary. For example, if you run Hamiltonian(3, 1), the Hamiltonian matrix is:</p>
<pre><code>[[-2.+0.j -1.+0.j -1.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [-1.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j]
 [-1.+0.j  0.+0.j  2.+0.j -1.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j]
 [ 0.+0.j -1.+0.j -1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j]
 [-1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j -1.+0.j  0.+0.j]
 [ 0.+0.j -1.+0.j  0.+0.j  0.+0.j -1.+0.j  2.+0.j  0.+0.j -1.+0.j]
 [ 0.+0.j  0.+0.j -1.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j -1.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j -1.+0.j -1.+0.j -2.+0.j]]
</code></pre>
<p>Does this mean that there is no way for this approach to run on a real quantum computer where all you can do is measurements on the qubits? I've seen different approaches online such as <a href=""https://quantumai.google/cirq/tutorials/educators/qaoa_ising#exercise_transverse_field_ising_model"" rel=""nofollow noreferrer"">QAOA</a> or <a href=""https://github.com/qiskit-community/qiskit-community-tutorials/blob/master/awards/teach_me_qiskit_2018/exact_ising_model_simulation/Ising_time_evolution.ipynb"" rel=""nofollow noreferrer"">the use of transformations</a>, but I thought if it's so easy to do it with unitaries and some additions, there should be a way to do it with measurements as well.</p>
",<programming><qiskit><hamiltonian-simulation><qaoa>,4/21/2021 14:27,17194.0,17194.0,"<p>You can definitely run this on a real quantum computer! In your snippet above you mixed circuits and operators. A circuit is only used for the ansatz of your ground state, not for representing the operators.</p>
<p>The website you provided talks about the Hamiltonian in terms of the Pauli X and Z matrices; <span class=""math-container"">$\hat\sigma^x$</span> and <span class=""math-container"">$\hat\sigma^z$</span>. If you want to compute the ground state of your Hamiltonian you need to use this Pauli representation and not convert them into a matrix.</p>
<p>Here's a short example you can generalize to your above case. Say we the transverse field Ising chain, but to simplify things, we assume only two sites. Then we can write the Hamiltonian as
<span class=""math-container"">$$
\hat H = -\hat\sigma^z_0 \otimes \hat\sigma^z_1 - h(\hat\sigma^x_0  + \hat\sigma^x_1).
$$</span>
Now we associate each site with a qubit and then we can write the above matrix in a one-to-one correspondence in Qiskit (I'm using Qiskit 0.25.0):</p>
<pre><code># opflow is Qiskit's module for creating operators like yours
from qiskit.opflow import Z, X, I  # Pauli Z, X matrices and identity

h = 0.25  # or whatever value you have for h
H = -(Z ^ Z) - h * ((X ^ I) + (I ^ X))
</code></pre>
<p>The <code>^</code> in Qiskit means we're using a tensor product. Also note that I've expanded the notation <span class=""math-container"">$\hat\sigma^x_0$</span> to <code>X ^ I</code> since we act on two qubits and by
<span class=""math-container"">$\hat\sigma^x_0$</span> implicitly mean that nothing happens to the second qubit.</p>
<p>Now you can go ahead and use this representation of the Hamiltonian to run on a real quantum computer. If you want to compute the ground state using Qiskit, you can use the <code>VQE</code> class. To run that you also need to select an ansatz and an optimizer, but that's very easy in Qiskit. For instance</p>
<pre><code>from qiskit.providers.aer import QasmSimulator  
from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import COBYLA 
from qiskit.circuit.library import EfficientSU2

# you can swap this for a real quantum device and keep the rest of the code the same!
backend = QasmSimulator() 

# COBYLA usually works well for small problems like this one
optimizer = COBYLA(maxiter=200)

# EfficientSU2 is a standard heuristic chemistry ansatz from Qiskit's circuit library
ansatz = EfficientSU2(2, reps=3)

# set the algorithm
vqe = VQE(ansatz, optimizer, quantum_instance=backend)

# run it with the Hamiltonian we defined above
result = vqe.compute_minimum_eigenvalue(H)  

# print the result (it contains lot's of information)
print(result) 
</code></pre>
<p>This will simulate the quantum computer but you can run exactly the same piece of code on real hardware by changing the <code>backend</code>.</p>
<p>On a real device, each of the Hamiltonian summands, <span class=""math-container"">$\sigma^z_0 \otimes \hat\sigma^z_1$</span>, <span class=""math-container"">$\hat\sigma^x_0$</span> and <span class=""math-container"">$\hat\sigma^x_1$</span>, will in general be measured individually. That is because we can only measure the expectation value of an operator, that is diagonal in the computational basis (in the Z-basis). Thus, we need to apply basis transformations to the terms that are not already diagonal (in this case the Pauli-X terms).</p>
<p>If you want to know more about this I would suggest you to have a look at the <a href=""https://qiskit.org/textbook/preface.html"" rel=""nofollow noreferrer"">Qiskit textbook</a> or <a href=""https://quantumcomputing.stackexchange.com/questions/16608/vqe-how-to-get-from-expectation-value-to-eigenvalue"">this stackoverflow question</a>.</p>
",4/21/2021 17:36,Learning,"The user is seeking clarification and guidance regarding implementing a quantum algorithm to calculate ground states of a transverse-field Ising Hamiltonian in Qiskit. They are specifically concerned about whether their approach, which relies on unitary simulators, can be adapted to run on real quantum hardware and are looking for alternative methods. This question falls under the category of learning and understanding quantum computing concepts and techniques.",Learning,,,,Learning,
17195.0,"In the HHL alghoritm, how can I transform my hermitian matrix into a unitary operator?","<p>I'm studying the HHL algorithm and I'm trying to do an his implementation but, there are some points that I don't understand how I can transform my hermitian Matrix into its unitary operator?</p>
<p>In Qiskit textbook I found <a href=""https://i.stack.imgur.com/Zm5LJ.png"" rel=""nofollow noreferrer"">this</a> explanation about HHL algorithm.
It says that after load the input data, we have to do QPE, but for QPE I need to transform my matrix A into <span class=""math-container"">$e^{iAt}$</span>, how can I do that? The textbook doesn't explain.</p>
<p>Re-edit:I start with the first question and I use an example.
I know that every hermitian matrix could be written as <span class=""math-container"">$e^{-iAt}$</span>, using Pauli Gates.
If I have the following matrix <span class=""math-container"">$ A=\begin{bmatrix} 1&amp;-\frac{1}{3}\\  -\frac{1}{3}&amp;1\\ \end{bmatrix}$</span>, I can write it as <span class=""math-container"">$A=-\frac{1}{3}X+\mathbb{1} $</span>, so the exponential matrix is  <span class=""math-container"">$e^{-iAt}=e^{-i(-\frac{1}{3}X+\mathbb{1})t}=e^{-i(-\frac{1}{3}X)t}e^{-i(\mathbb{1})t}$</span>, I can write the last equality because the two operator commute. I want to write this in terms of gates, following the instruciton of previous posts I can write  the term <span class=""math-container"">$e^{-i(\mathbb{1})t}$</span> as U1(-t) on control qubit. For <span class=""math-container"">$e^{-i(-\frac{1}{3}X)t}$</span>, I know that <span class=""math-container"">$e^{-i(X)t}$</span> is equal to <span class=""math-container"">$HR_z(2t)H$</span>,so, in my case, I can write <span class=""math-container"">$e^{-i(-\frac{1}{3}X)t}=HR_z(-2\frac{t}{3})H$</span></p>
<p>I tried to implement in qiskit the circuit, I find 100% of probability to have |11&gt;, but I expect to have 100% of probability to have |10&gt;, what am I doing wrong?</p>
<p>This is my code</p>
<pre><code>t=2*np.pi*3/8
qpe = QuantumCircuit(3, 2)
qpe.h(2) #inizializzo il vettore (1,1) con H gate
for qubit in range(2):
    qpe.h(qubit)     #applico H gate ai control bit
repetitions = 1
for counting_qubit in range(2):
    for i in range(repetitions):
        qpe.p(-t,counting_qubit)
        qpe.h(2)
        qpe.crz(-2/3*t,counting_qubit,2)
        qpe.h(2)
        repetitions *= 2
qpe.barrier();
qpe.draw()

def qft_dagger(qc, n):
    &quot;&quot;&quot;n-qubit QFTdagger the first n qubits in circ&quot;&quot;&quot;
    # Don't forget the Swaps!
    for qubit in range(n//2):
        qc.swap(qubit, n-qubit-1)
    for j in range(n):
        for m in range(j):
            qc.cp(-math.pi/float(2**(j-m)), m, j)
        qc.h(j)

# Apply inverse QFT
qft_dagger(qpe, 2)
#Measure
qpe.barrier()
for n in range(2):
    qpe.measure(n,n)
qpe.draw()
</code></pre>
<p>My circuit
<a href=""https://i.stack.imgur.com/mbWpJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mbWpJ.png"" alt=""enter image description here"" /></a></p>
<p>My result on simulator</p>
<p><a href=""https://i.stack.imgur.com/lKI0x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lKI0x.png"" alt=""enter image description here"" /></a></p>
<p>Re-edit: I noticed that if I remove the minus sign to the gates, the result is correct, but I don't understand why</p>
",<programming><qiskit><hhl-algorithm>,4/21/2021 18:43,17379.0,17379.0,"<p>i did the hamiltonian simulation with minus sign, but in QPE, I don't have to consider it</p>
",05/06/2021 23:28,Theoretical ,"The user is asking about the theoretical aspects of the HHL algorithm and quantum phase estimation, specifically about transforming a Hermitian matrix into its unitary operator",Theoretical ,,,,Theoretical ,
17219.0,How to use qiskit transpile with Clifford + T basis?,"<p>How can I transpile using universal <span class=""math-container"">$Clifford + T$</span> gates set? I have only seen examples using rotations + <span class=""math-container"">$CNOT$</span>.</p>
<p>This is what I have tried</p>
<pre><code>from qiskit import *
from qiskit.quantum_info import Operator
from qiskit.compiler import transpile
%matplotlib inline

u = Operator([[0, 0, 1, 0, 0, 0, 0, 0],
              [1, 0, 0, 0, 0, 0, 0, 0],
              [0, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 1, 0],
              [0, 0, 0, 0, 1, 0, 0, 0]])

qc = QuantumCircuit(3)
qc.unitary(u, [0,1,2], label='u')

result = transpile(qc, basis_gates=['u1', 'u2', 'u3', 'cx'], optimization_level=3)
result.draw(output='mpl')
</code></pre>
<p>And this example works fine. But when I was trying to set:</p>
<pre><code>basis_gates=['h', 's', 't', 'cx']
</code></pre>
<p>It doesn't work.
Could you help me, please?)</p>
<p>UPDATE:
After comments I've tried this:</p>
<pre><code>pip install git+https://github.com/LNoorl/qiskit-terra.git@feature/sk-pass
</code></pre>
<p>and then:</p>
<pre><code>from qiskit.circuit import QuantumCircuit
from qiskit.circuit.library import TGate, HGate, TdgGate, SGate
from qiskit.transpiler.passes import SolovayKitaevDecomposition
from qiskit import *
from qiskit.quantum_info import Operator
from qiskit.compiler import transpile
%matplotlib inline

u = Operator([[1, 0, 0, 0, 0, 0, 0, 0],
              [0, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, -1, 0, 0, 0, 0, 0],
              [0, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 1, 0, 0, 0],
              [0, 0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 1, 0],
              [0, 0, 0, 0, 0, 0, 0, 1]])

qc = QuantumCircuit(3)
qc.unitary(u, [0,1,2], label='u')

print('Orginal circuit:')
print(qc)

basis_gates = [TGate(), SGate(), HGate()]
skd = SolovayKitaevDecomposition(recursion_degree=2, basis_gates=basis_gates, depth=5)

discretized = skd(qc)

print('Discretized circuit:')
print(discretized)
</code></pre>
<p>But it outputs only this:</p>
<pre><code>Orginal circuit:
     ââââââ
q_0: â¤0   â
     â    â
q_1: â¤1 u â
     â    â
q_2: â¤2   â
     ââââââ
Discretized circuit:
     ââââââ
q_0: â¤0   â
     â    â
q_1: â¤1 u â
     â    â
q_2: â¤2   â
     ââââââ
</code></pre>
<p>Where is a problem?</p>
",<programming><qiskit><universal-gates>,4/23/2021 12:13,17226.0,17226.0,"<p>The reason for your second result is because unitary synthesis is not part of the <code>SolovayKitaevDecomposition</code> pass. Actually, you can combine your attempts to get the desired result.</p>
<p>This is the first stage (you first snippet), it will synthesise your circuit in terms of <code>u*</code> and <code>cx</code>:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
from qiskit.compiler import transpile

u = Operator([[0, 0, 1, 0, 0, 0, 0, 0],
              [1, 0, 0, 0, 0, 0, 0, 0],
              [0, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 1, 0],
              [0, 0, 0, 0, 1, 0, 0, 0]])

qc = QuantumCircuit(3)
qc.unitary(u, [0,1,2], label='u')

transpiled = transpile(qc, basis_gates=['u1', 'u2', 'u3', 'cx'], optimization_level=3)
</code></pre>
<p>Then you can transform it to Cliffort+T using <code>SolovayKitaevDecomposition</code>:</p>
<pre><code>from qiskit.circuit.library import TGate, HGate, SGate
from qiskit.transpiler.passes import SolovayKitaevDecomposition

basis_gates = [TGate(), SGate(), HGate()]
skd = SolovayKitaevDecomposition(recursion_degree=3, basis_gates=basis_gates, depth=5)
discretized = skd(transpiled)
print(discretized)
</code></pre>
<pre><code>global phase: -0.063526
     âââââââââââââââââââââââââââââââââââââââââââââ                           Â»
q_0: â¤ X ââ¤ T ââ¤ X ââ¤ S ââ¤ X ââ¤ X ââ¤ S ââ¤ S ââ¤ H ââââââââââââââââââââââââââââÂ»
     âââ¬ââââââââââ¬ââââââââââ¬âââââ¬âââââââ¤âââââ¤âââââ¤âââââââââââââââââââââââââââÂ»
q_1: âââ ââââââââââ¼ââââââââââ âââââ¼âââ¤ X ââ¤ S ââ¤ S ââ¤ S ââ¤ X ââ¤ S ââ¤ H ââ¤ TDG âÂ»
                 â              â  âââ¬ââââââââââââââââââââ¬âââââââ¤âââââ¤ââ¬ââââ¬âÂ»
q_2: âââââââââââââ âââââââââââââââ âââââ ââââââââââââââââââââ âââ¤ T ââ¤ S âââ¤ S ââÂ»
                                                            ââââââââââ âââââ Â»
</code></pre>
",4/23/2021 18:56, Tooling,"The user is asking for help with using the Qiskit library to transpile a quantum circuit using a specific set of gates, which falls under the category of tool usage in quantum programming",Tooling,,,, Tooling,
17259.0,Qiskit QFT matrix does not match with DFT matrix,"<p>The unitary matrix associated with the <code>QFT</code> circuit in Qiskit does not match the actual DFT matrix. In fact, all the imaginary components have their sign flipped (QFT and DFT matrices seems to be each other's complex conjugate). Is that the correct behavior?</p>
<p>Note that the <code>QFT</code> circuit already includes the swap gates at the end of the circuit.</p>
<pre><code>import numpy as np
from scipy.linalg import dft
from qiskit import *
from qiskit.circuit.library import QFT

n = 2
dft_matrix = (1/np.sqrt(2**n)) * dft(2**n)
qft_matrix = execute(QFT(n), Aer.get_backend('unitary_simulator')).result().get_unitary()

# remove components almost zero for enhanced visualization
eps = 0.00001
dft_matrix.real[np.abs(dft_matrix.real) &lt; eps] = 0
dft_matrix.imag[np.abs(dft_matrix.imag) &lt; eps] = 0
qft_matrix.real[np.abs(qft_matrix.real) &lt; eps] = 0
qft_matrix.imag[np.abs(qft_matrix.imag) &lt; eps] = 0

dft_matrix, qft_matrix
</code></pre>
<p>The matrices have values:</p>
<pre><code>dft_matrix=
array([[  0.5+0.j ,  0.5+0.j ,  0.5+0.j ,  0.5+0.j ],
        [ 0.5+0.j ,  0. -0.5j, -0.5+0.j ,  0. +0.5j],
        [ 0.5+0.j , -0.5+0.j ,  0.5+0.j , -0.5+0.j ],
        [ 0.5+0.j ,  0. +0.5j, -0.5+0.j ,  0. -0.5j]]),
qft_matrix=
array([[  0.5+0.j ,  0.5+0.j ,  0.5+0.j ,  0.5+0.j ],
        [ 0.5+0.j ,  0. +0.5j, -0.5+0.j ,  0. -0.5j],
        [ 0.5+0.j , -0.5+0.j ,  0.5+0.j , -0.5+0.j ],
        [ 0.5+0.j ,  0. -0.5j, -0.5+0.j ,  0. +0.5j]])
</code></pre>
",<programming><qiskit><quantum-fourier-transform>,4/26/2021 21:18,17266.0,17266.0,"<p>According to the docs of <a href=""https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.dft.html"" rel=""nofollow noreferrer"">scipy</a> and <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html"" rel=""nofollow noreferrer"">qiskit</a>, the first uses primitive root <span class=""math-container"">$\omega = e^{-\frac{2\pi i}{n}}$</span> and the second uses <span class=""math-container"">$\omega = e^{\frac{2\pi i}{n}}$</span>.</p>
<p>This implies that one matrix is complex conjugate of the other (which is the same as inverse).</p>
",4/27/2021 8:27,Theoretical ,"The user is comparing the unitary matrix associated with the Quantum Fourier Transform (QFT) circuit in Qiskit with the actual Discrete Fourier Transform (DFT) matrix, and is asking about the differences they observed. This falls under the category of theoretical concepts in quantum computing. ",Theoretical,,,,Theoretical ,
17281.0,Bernstein Vazirani Algorithm widget (bv_widget) in the Qiskit documentation,"<p>I'm new to quantum computing and Qiskit, so please be patient with me. I'm going through the info on Bernstein Vazirani. Here is the link to the section: <a href=""https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html</a>.
About midway down the page, at the end of the example section, is a widget: bv_widget. I have attempted to run the widget and apply the steps mentioned in the section. I apply the hadamards, then the oracle and then the hadamards again. But there seems to be no way of performing a measurement to determine the result. I tried placing bv_widget.measure(2,2) as the last line in the code sample, but that didn't work. Neither did just using the word measure(2,2).</p>
<p>What am I missing here? Is there a way to perform a measurement?</p>
<p>PS A similar piece of code is at the end of the chapter, and I'm running into the same problem with it.</p>
<p>Thanks for your help.</p>
<p>Doug</p>
",<programming><qiskit><bernstein-vazirani-algorithm>,4/28/2021 1:54,17282.0,17282.0,"<p>I think the widget is supposed to only show you the initialization and Oracle part of the circuit and not actually implement the measurement process into it. Thus, that is why you don't see the measurement step.</p>
<p>However, it is quite simple to write a function for perform the Bernstein-Vazirani algorithm. You can just use the script below:</p>
<pre><code>import numpy as np
from qiskit.circuit import QuantumCircuit
from qiskit import IBMQ, Aer, execute 
provider = IBMQ.load_account()

def BV_circuit(secret_bitstring): 
    num_qubits = len(secret_bitstring) + 1
    circuit = QuantumCircuit(num_qubits,num_qubits)
    for i in range(num_qubits):
        circuit.h(i)
    circuit.z(num_qubits-1)
    for i in range(num_qubits-1):
        if secret_bitstring[i] == '1':
            circuit.cx(i,num_qubits-1)
    circuit.barrier(range(num_qubits))
    for i in range(num_qubits):
        circuit.h(i)
    circuit.measure([i for i in range(num_qubits-1)], [i for i in range(num_qubits-1)])
    return circuit
</code></pre>
<p><strong>For example:</strong> If I pick a secret bitstring to be <code>1111</code> then I have the following:</p>
<pre><code>secret_bitstring = '1111'    
QC = BV_circuit(secret_bitstring)
QC.draw( 'mpl',style={'name': 'bw'}, plot_barriers= False, initial_state = True, scale = 1)
</code></pre>
<p><a href=""https://i.stack.imgur.com/Ms855.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ms855.png"" alt=""enter image description here"" /></a></p>
<p>You can check that this this will generate the same circuit as the one you have using the qiskit's Widget. And if you want to run it on hardware, just use the following script:</p>
<pre><code>backend = provider.backends.ibmq_16_melbourne
job = execute(QC, backend, shots=8192)
</code></pre>
",4/28/2021 4:24, Learning, The user is learning about the Bernstein Vazirani algorithm through the Qiskit textbook and is asking for help with understanding how to perform a measurement in the provided widget. This falls under the category of requests for learning resources and tutorials in quantum computing. ,Learning,,,, Learning,
17287.0,"Bloch sphere visualization using Cirq, ProjectQ, PyQuil","<p>Is there a way to visualize the Bloch sphere using Cirq, ProjectQ, and/or PyQuil, as it is possible using <code>plot_bloch_vector</code> in Qiskit?</p>
",<programming><cirq><pyquil><projectq>,4/28/2021 17:45,17290.0,17290.0,"<p>The answer <em>seems</em> to be &quot;no&quot; for all three. From what I can find, Cirq and PyQuil default to QuTiP for Bloch sphere visualization, and ProjectQ does not have any examples to go off of, nor can I find the functionality in their GitHub.</p>
<ul>
<li>TensorFlow Quantum, which primarily uses Cirq (since they are both owned by Google), used <code>qutip.Bloch</code> in <a href=""https://github.com/tensorflow/quantum/blob/research/binary_classifier/binary_classifier.ipynb"" rel=""noreferrer"">this binary classification tutorial</a> instead of any Cirq function, implying that Cirq does not have an equivalent.</li>
<li>Rigetti, which owns PyQuil, used <code>qutip.Bloch</code> in <a href=""https://github.com/markf94/rigetti_training_material/blob/master/session_2/tutorial_II_quantum_gates.ipynb"" rel=""noreferrer"">this training material</a> instead of any PyQuil function, and in <a href=""https://github.com/rigetti/pyquil/blob/v2.22.0/docs/source/intro.rst"" rel=""noreferrer"">this intro tutorial</a>, implying that PyQuil does not have an equivalent.</li>
<li>ProjectQ does not have any publicly visible Bloch sphere visualization tools in <a href=""https://github.com/ProjectQ-Framework/ProjectQ"" rel=""noreferrer"">their Github</a>, either. But their software already uses the IBM quantum experience, so I believe they would default to <code>qiskit.plot_bloch_vector</code>.</li>
</ul>
<p>These are my findings based on briefly poking around in each of these softwaresâ open-source. If there are any Cirq/ProjectQ/PyQuil contributors out there, please correct me if I am wrong.</p>
",4/28/2021 19:47,Tooling ,"The user is asking about the functionality of different quantum computing libraries (Cirq, ProjectQ, PyQuil) and how they compare to a specific feature (Bloch sphere visualization) in Qiskit. This falls under the category of tool usage in quantum programming.",Tooling ,,,,Tooling ,
17298.0,Why does applying a Hadamard gate three times to $|0\rangle$ result in a tiny imaginary component in the $|1\rangle$ amplitude?,"<p>I'm using <code>qiskit</code> with the online <a href=""https://quantum-computing.ibm.com"" rel=""nofollow noreferrer"">IBM Quantum Lab</a> and when I run the following code</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_bloch_multivector

qc = QuantumCircuit(1) 

qc.h(0)
qc.h(0)
qc.h(0)

out = execute(qc,Aer.get_backend('statevector_simulator')).result().get_statevector()
print(out)
plot_bloch_multivector(out)
</code></pre>
<p>... it results in the following state vector for the qubit:</p>
<p><code>[0.70710678+0.00000000e+00j 0.70710678+1.57009246e-16j]</code></p>
<p>As you can see there's a very small imaginary component in the |1&gt; amplitude.</p>
<p>These imaginary values pop up often with <code>qiskit</code>, such as:</p>
<pre><code>qc.x(0)
qc.h(0)
--&gt; [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j]
</code></pre>
<p>or even very small non-imaginary numbers, such as:</p>
<pre><code>qc.x(0)
qc.h(0)
qc.h(0)
--&gt; [6.123234e-17+0.00000000e+00j 1.000000e+00-2.22044605e-16j]
</code></pre>
<p>Is this something unique to quantum mechanics/computing that actually has practical consequences when doing computation, or perhaps simply a quirk of Python's scientific notation implementation.</p>
",<programming><qiskit><ibm-q-experience>,4/29/2021 17:16,17299.0,17299.0,"<p>This is just a quirk of how complex numbers are implemented in Python/Numpy, etc. At the end of the day, these are represented as floating-point numbers within the target simulator. These are then transformed via various mathematical operations to implement the simulation and this eventually leads to an accumulation of <a href=""https://en.wikipedia.org/wiki/Round-off_error"" rel=""noreferrer"">round off error</a>. For all intents and purposes, e-16 is zero, but a computer doesn't know that.</p>
",4/29/2021 17:31,Conceptual,The users question pertains to the nature of small imaginary and real components that appear in quantum state vectors when working with qiskit. This is a conceptual question related to the behavior of quantum state representations and not a specific error or API usage question.,Conceptual,,,,Conceptual,
17301.0,Qiskit: count the type of gates on the qubit with the largest number of gates in a multi-qubit circuit,"<p>I would like to know the number and type of all the gates on the wire/qubit with the largest operations in a quantum circuit with multiple qubits. Is there any inbuilt functionality, or what is the shortest way to do so?</p>
",<programming><qiskit>,4/29/2021 19:38,17304.0,17304.0,"<p>You can do this as follow:</p>
<ol>
<li>Specify your circuit then transpile it to the backend of interst.</li>
</ol>
<blockquote>
<p><code>transpile_circuit = transpile(circuit, backend)</code></p>
</blockquote>
<ol start=""2"">
<li>Convert this to DAG (Directed Acylic Graph)</li>
</ol>
<blockquote>
<p><code>dag_circuit = circuit_to_dag(transpile_circuit)</code></p>
</blockquote>
<ol start=""3"">
<li>count all the operation in the longest path:</li>
</ol>
<blockquote>
<p><code>dag_circuit.count_ops_longest_path()</code></p>
</blockquote>
<hr />
<p><em><strong>Explicit example:</strong></em></p>
<p>Says you have the circuit</p>
<pre><code>qc = QuantumCircuit(4,4)
for i in range(4):
    qc.h(i)
qc.cx(0,1)
qc.cx(2,3)
qc.ry(2,0)
qc.cx(1,0)
qc.measure([0,1,2,3],[0,1,2,3])
</code></pre>
<p><a href=""https://i.stack.imgur.com/poCw0.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/poCw0.png"" alt=""enter image description here"" /></a></p>
<p>you can transpile this onto <code>ibmq_16_melbourne</code> and to get:</p>
<pre><code>backend = provider.get_backend('ibmq_16_melbourne')
transpile_circuit = transpile(qc, backend)
</code></pre>
<p><a href=""https://i.stack.imgur.com/ll85g.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/ll85g.png"" alt=""enter image description here"" /></a></p>
<p>Now, convert to DAG and counts ops give you:</p>
<pre><code>dag_circuit = circuit_to_dag(transpile_circuit)
dag_circuit.count_ops_longest_path()
</code></pre>
<p>Output: <code>{'rz': 4, 'sx': 3, 'cx': 2, 'measure': 1} </code></p>
<hr />
<p>It seems to me you want to find out the runtime of the circuit by finding out the longest path, and the operations on that path, then using the device properties to calculate the theoretical runtime.</p>
<p>If that is the case, then you need to extract the gate duration time for all the gate in that longest path, and work out the calculation.</p>
<hr />
<p>Make sure to import:</p>
<pre><code>from qiskit.dagcircuit import DAGCircuit
from qiskit.converters import circuit_to_dag
from qiskit.compiler import transpile
</code></pre>
",4/29/2021 21:22,Tooling,"The user is seeking information on how to identify the number and types of gates applied to a specific qubit with the most operations in a quantum circuit, which relates to the usage of tools or functionality in quantum programming.",Tooling,,,,Tooling,
17320.0,What is the superop simulator in Qiskit for?,"<p>I'm trying to understand what the use case of a superop simulator would be. My understanding is that density matrix is generally more resource intensive than state vector, but it has additional capabilities to support noisy channels and such. And also my understanding is that every circuit <em>has</em> a corresponding superop that can be extracted from it via QIS, but I believe that can be obtained via calculation rather than simulation. So I don't understand what a superop <em>simulator</em> is for. I know it's even more resource intensive than density matrix, but what additional capabilities does it provide?</p>
",<programming><qiskit><quantum-state><simulation><density-matrix>,05/01/2021 15:51,17337.0,17337.0,"<p>If you have an <strong>ideal</strong> quantum circuit, you can easily get its superoperator representation using <code>qiskit.quantum_info.SuperOp</code> as follows,</p>
<pre><code>qc = QuantumCircuit(1)
qc.x(0)

super_op = SuperOp(qc)
array_to_latex(super_op)
</code></pre>
<p>The output will be
<span class=""math-container"">$$
\left[\begin{matrix}
0 &amp;  0  &amp; 0 &amp; 1\\
0 &amp;  0  &amp; 1 &amp; 0\\
0 &amp;  1  &amp; 0 &amp; 0\\
1 &amp;  0  &amp; 0 &amp; 0\\
\end{matrix}\right]
$$</span></p>
<p>And to see how a quantum state is evolved by applying this operator:</p>
<pre><code>rho1 = DensityMatrix.from_label('0')

rho2 = rho1.evolve(super_op)
rho2.draw('latex')
</code></pre>
<p>However, you can not use this method to get the superoperator representation of the circuit <strong>in the presence of errors</strong>. Instead, you can use superop simulator, which accepts a <code>NoiseModel</code> as a parameter</p>
<pre><code># Add save_superop instruction to save the simulator state to the returned results:
qc.save_superop()

# Get noise model:
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_16_melbourne')
noise_model = NoiseModel.from_backend(backend)

# Get the superoperator:
noisy_simulator = AerSimulator(method = 'superop', noise_model = noise_model)
result = noisy_simulator.run(qc).result()
super_op_array = result.data()['superop']
array_to_latex(super_op_array)
</code></pre>
<p>And in this case the output will be somthing like that:
<span class=""math-container"">$$
\left[\begin{matrix}
0.00094 &amp;  0  &amp; 0 &amp; 0.99979\\
0 &amp;  0  &amp; 0.99907 &amp; 0\\
0 &amp;  0.99907  &amp; 0 &amp; 0\\
0.99906 &amp;  0  &amp; 0 &amp; 0.00021\\
\end{matrix}\right]
$$</span></p>
",05/03/2021 23:23, Theoretical,"The user is asking about the theoretical aspects of quantum computing, specifically the use case of a superoperator simulator. They are trying to understand the additional capabilities it provides compared to density matrix and state vector simulations.", Conceptual,"The user is seeking an explanation for the practical use of a superoperator simulator in the context of quantum computing and how it differs from other simulation methods like density matrices. This falls under the ""Conceptual"" category",No,109.0,Conceptual,"The user is asking for an explanation of the practical use of a superoperator simulator, indicating a need to understand its application and differences from other simulation methods, which aligns with the conceptual understanding of quantum computing."
17336.0,Can I use Grover's algorithm on overlapping sets of qubits?,"<p>Let's say I have 3 qubits: <span class=""math-container"">$q_1,q_2,q_3$</span>.</p>
<p>I want to apply Grover's algorithm on q1,q2, such that q1,q2 <span class=""math-container"">$\neq$</span> 10 and do the same for q2,q3, so that q2,q3 <span class=""math-container"">$\neq$</span>  11. The final possible combinations of the qubits q1,q2,q3 should then be:<br />
000<br />
001<br />
010<br />
110</p>
<p>And they shouldn't be:<br />
011<br />
100<br />
101<br />
111</p>
<p>If this is possible then couldn't I solve 3sat in polynomial time with a quantum computer? Couldn't I just remove the possibility of each clause being unsatisfied from a set of qbits representing the variables in the 3sat problem and then collapse the qbits to see if the final result is satisfiable?</p>
<p><strong>Example of how I think a quantum computer would solve an instance of a 3sat problem in polynomial time:</strong></p>
<p>Note: each computation should be on a set of 3 qbits at a time which should take <span class=""math-container"">$2^{3/2}$</span> time with Grover's algorithm, or O(1) in big O notation)</p>
<p>Variables = <span class=""math-container"">${a,b,c,d,e}$</span></p>
<p>clauses = <span class=""math-container"">${(\neg a \vee b \vee \neg c),(b \vee c \vee d),(\neg b \vee \neg c \vee d),(c \vee \neg d \vee e),(c \vee \neg d \vee \neg e)}$</span></p>
<p>We have qubits <span class=""math-container"">$q_a, q_b, q_c, q_d, q_e$</span></p>
<p>for  <span class=""math-container"">$q_a, q_b, q_c$</span> we remove the possibility of 101 (since this would not satisfy the 1st clause)</p>
<p>for <span class=""math-container"">$q_b, q_c, q_d$</span> we remove the possibility of 000 and 110 (since those would not satisfy the 2nd and 3rd clause)</p>
<p>for <span class=""math-container"">$q_c, q_d, q_e$</span> we remove the possibility of 010 and 011 (since those would not satisfy the 4th and 5th clause)</p>
<p>Now the possible outputs of the qbits are:</p>
<p>00100<br />
00101<br />
00110<br />
00111<br />
01000<br />
01001<br />
01110<br />
01111<br />
11000<br />
11001<br />
11110<br />
11111</p>
<p>So if I collapse the qbits I should remain with one of these combinations which satisfies the problem. If there is no possible solution, the qbits will just collapse into something meaningless which will not satisfy the problem.</p>
<p>If anyone can show me the flaw in my logic, please let me know, I highly doubt I solved 3sat. I'm just trying to learn.</p>
",<programming><quantum-state><algorithm><grovers-algorithm><quantum-advantage>,05/03/2021 17:31,17353.0,17353.0,"<p>Grover's algorithm has two components, which alternate and repeat <span class=""math-container"">$O(\sqrt{N})$</span> times: a diffusion operator and an oracle operator. The diffusion operator will cause problems with your idea.</p>
<p>As I understand, what you want to do is start from a uniform superposition</p>
<p><span class=""math-container"">$$\vert \psi_0\rangle =\frac{1}{\sqrt{2^n}}\sum_{b_1,\dots,b_n\in\{0,1\}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$</span></p>
<p>and then solve for (e.g.) a clause <span class=""math-container"">$C_1$</span> in <span class=""math-container"">$b_1,b_2,b_3$</span>, to get something like:</p>
<p><span class=""math-container"">$$\vert\psi_1\rangle=\frac{1}{\sqrt{N}}\sum_{\substack{b_1,\dots,b_n\in\{0,1\}\\ C_1(b_1,b_2,b_3)=1}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$</span></p>
<p>where <span class=""math-container"">$N$</span> is the number of remaining solutions. From this superposition, you want to solve for another clause <span class=""math-container"">$C_2$</span> which involves (e.g.) <span class=""math-container"">$b_1, b_4, b_5$</span> (if no other clause involves <span class=""math-container"">$b_1,b_2,b_3$</span>, then it's easy to solve for these 3 variables first and then remove them from the problem).</p>
<p>But now you're searching over the first qubit, <span class=""math-container"">$b_1$</span>, but <span class=""math-container"">$\vert\psi_1\rangle$</span>, your superposition over <span class=""math-container"">$b_1$</span>, is non-trivial. Grover's algorithm requires a way to flip the phase of the starting superposition. Normally, the way to do this is to apply <span class=""math-container"">$H$</span> gates to every qubit and flip the all-zeros state, then apply <span class=""math-container"">$H$</span> again to return to the previous state, but after solving the first clause, the superposition <span class=""math-container"">$\vert\psi_1\rangle$</span> is <em>not</em> just <span class=""math-container"">$H^{\otimes n}\vert 0^n\rangle$</span>.</p>
<p>In fact, (as far as I am aware) the only way to construct a diffusion operator for the superposition <span class=""math-container"">$\vert\psi_1\rangle$</span> where <span class=""math-container"">$C_1$</span> is solved is to <em>undo</em> the solution for <span class=""math-container"">$C_1$</span>, then apply <span class=""math-container"">$H$</span> gates, then flip over <span class=""math-container"">$\vert 0^n\rangle$</span>, then <em>redo</em> those same operations.</p>
<p>If you do that, then you can run Grover's algorithm on a clause-by-clause basis and solve the 3-SAT problem. However, the cost is not polynomial: If there are <span class=""math-container"">$m$</span> clauses, for the last clause, the diffusion operator must solve and unsolve an <span class=""math-container"">$m-1$</span> clause 3-SAT problem. So if the cost of solving this problem is <span class=""math-container"">$c_{m-1}$</span>, the total cost will be <span class=""math-container"">$\approx\sqrt{2^3}c_{m-1}$</span>. But solving an <span class=""math-container"">$m-1$</span> clause 3-SAT problem will require a diffusion operator that solves an <span class=""math-container"">$m-2$</span> clause 3-SAT problem, so <span class=""math-container"">$c_{m-1}\approx \sqrt{2^3}c_{m-2}$</span> (and so on). You end up <em>multiplying</em> all of the factors of <span class=""math-container"">$\sqrt{2^3}$</span> each time you go through, and the total cost ends up as something like <span class=""math-container"">$O(\sqrt{2^{3m}})$</span> -- which is roughly the exponential cost you would expect from a naive Grover search.</p>
",05/05/2021 08:14,Theoretical,The user is discussing the theoretical aspects of Grovers algorithm and its application to the 3-SAT problem in quantum computing. They are trying to understand the logic behind the algorithm and its implications for problem-solving in polynomial time,Theoretical,,,,Theoretical,
17341.0,Why `cirq` needs `Qid` class instead of just `Qudit` class?,"<p>I am just wondering in what way <code>cirq.Qid</code> class generalizes qudits. From <code>cirq.Qid</code> documentation we read that it</p>
<blockquote>
<p>Identifies a quantum object such as a qubit, qudit, resonator, etc.</p>
</blockquote>
<p>I am not sure what this resonator means and if it is somehow connected to other qudits in the system.</p>
<p>Could anyone clarify it?</p>
",<programming><cirq><qudit>,05/04/2021 16:16,17345.0,17345.0,"<p>Well, originally the idea was that we didn't want to exclude things like continuous quantum systems, and ancillary systems being used as control surfaces, and concepts like &quot;a place where an ion might be&quot; as opposed to the ion itself. So we went with a very generic &quot;identifier for quantum-associated thing&quot; name (qid).</p>
<p>At some point Qid gained a <code>dimension</code> method that returns an integer telling you how many quantum levels there are... so it really basically is a qudit now.</p>
",05/04/2021 19:40,Conceptual,"The user is seeking clarification on the concept of cirq.Qid and its generalization of qudits and other quantum objects, indicating a conceptual understanding of the topic.",Conceptual,,,,Conceptual,
17344.0,Why does running my circuit on Quantum Hardware produce such unexpected results?,"<p>I am using Jupyter Notebook with Qiskit.</p>
<p>I have created a program that can add two 3-bit numbers together. When I simulate this program on a qasm_simulator it works as expected and I can add any two 3-bit numbers together such as:
<span class=""math-container"">$011 + 110 = 1000$</span></p>
<p>However, when I try to get the result on real quantum hardware (IBMQ) it gets very unexpected results as seen below.</p>
<p><a href=""https://i.stack.imgur.com/c4LIz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c4LIz.png"" alt=""enter image description here"" /></a></p>
<p>I know there will obviously be noise when using the quantum hardware but the results aren't even close to what they should be, does anyone know why?</p>
<h2>My code:</h2>
<pre><code>%matplotlib inline
# Importing standard Qiskit libraries
from qiskit import QuantumRegister
from qiskit import ClassicalRegister
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from ibm_quantum_widgets import *
from qiskit.tools.monitor import job_monitor
from qiskit.providers.ibmq import least_busy

# Loading IBM Q account(s)
provider = IBMQ.load_account()

## Create COUT sub-routine

q0 = QuantumRegister(1) # First number
q1 = QuantumRegister(1) # Second number, then sum
q2 = QuantumRegister(1) # Carry bit i
q3 = QuantumRegister(1) # Carry bits i+1

# Build a COUT sub-circuit
COUT_qr = QuantumRegister(4)
COUT = QuantumCircuit(q0,q1,q2,q3,name='COUT')

COUT.ccx(q1[0],q2[0],q3[0])
COUT.cx(q1[0],q2[0])
COUT.ccx(q0[0],q2[0],q3[0])

# convert to a gate
COUT_inst = COUT.to_instruction()


## reverse COUT sub-routine

q0 = QuantumRegister(1) # First number
q1 = QuantumRegister(1) # Second number, then sum
q2 = QuantumRegister(1) # Carry bit i
q3 = QuantumRegister(1) # Carry bits i+1

# Build a COUT sub-circuit
reverseCOUT = QuantumCircuit(q0,q1,q2,q3,name='reverseCOUT')

reverseCOUT.ccx(q0[0],q2[0],q3[0])
reverseCOUT.cx(q1[0],q2[0])
reverseCOUT.ccx(q1[0],q2[0],q3[0])

# convert to a gate
reverseCOUT_inst = reverseCOUT.to_instruction()


## Create SUM sub-routine

q0 = QuantumRegister(1) # First number
q1 = QuantumRegister(1) # Second number, then sum
q2 = QuantumRegister(1) # Carry bit i


# Build a COUT sub-circuit
SUM = QuantumCircuit(q0,q1,q2,name='SUM')

SUM.cx(q0[0],q2[0])
SUM.cx(q1[0],q2[0])


# convert to a gate
SUM_inst = SUM.to_instruction()


# n is the length of the qubits you are adding together
n = 3

a = QuantumRegister(n,'a') # First number
b = QuantumRegister(n+1,'b') # Second number, then sum
c = QuantumRegister(n,'c') # Carry bits
cl = ClassicalRegister(n+1) # Classical output

# Combining all of them into one quantum circuit
qc = QuantumCircuit(a, b, c, cl)

# initialise numbers:
qc.x(0)
qc.x(1) 
#qc.x(2)
qc.x(3)
#qc.x(4) 
qc.x(5)


## Create the circuit to add two 3-bit numbers
# COUT
qc.append(COUT,[c[0],a[0],b[0],c[1]])
qc.barrier()

# COUT
qc.append(COUT,[c[1],a[1],b[1],c[2]])
qc.barrier()

# COUT
qc.append(COUT,[c[2],a[2],b[2],b[3]])
qc.barrier()


qc.cx(c[2],b[2])
qc.barrier()


# reverse COUT
qc.append(reverseCOUT,[c[1],a[1],b[1],c[2]])
qc.barrier()


# SUM
qc.append(SUM,[c[1],a[1],b[1]])
qc.barrier()

# reverse COUT
qc.append(reverseCOUT,[c[0],a[0],b[0],c[1]])
qc.barrier()

# SUM
qc.append(SUM,[c[0],a[0],b[0]])
qc.barrier()


# Measure qubits and store results in classical register cl
for i in range(3+1):
    qc.measure(b[i], cl[i])


# Run the experimient 1024 times and get stats
counts = execute(qc,Aer.get_backend('qasm_simulator')).result().get_counts()
plot_histogram(counts)

# Run on Quantum Hardware
provider = IBMQ.get_provider(hub='ibm-q')
backend = least_busy(provider.backends(filters=lambda x: x.configuration().n_qubits &gt;= 10 
                                       and not x.configuration().simulator 
                                       and x.status().operational==True))
print(&quot;least busy backend: &quot;, backend)

# Run it
shots = 2048
transpiled_qc = transpile(qc, backend, optimization_level=3)
qobj = assemble(transpiled_qc, shots=shots)
job = backend.run(qobj)
job_monitor(job)

# Plot results
counts = job.result().get_counts()
plot_histogram(counts)
</code></pre>
",<programming><qiskit><ibm-q-experience><simulation><qasm>,05/04/2021 18:20,17352.0,17352.0,"<h3>I think you underestimated how long your circuit really is....</h3>
<p>When running your circuit on the hardware, it has to be transpile into the set of gates that is known to the hardware. For IBM machines, these are <span class=""math-container"">$\{ CX, ID, RZ, SX, X \}$</span> . Furthermore, there is a constraint on the qubit layout of the hardware as well. Not all qubits are connected. Thus there will be some overhead operation. At the end of it, your circuit is very long... and so <strong>all you read out is noise</strong>...</p>
<p><a href=""https://i.stack.imgur.com/vwAqE.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vwAqE.jpg"" alt=""enter image description here"" /></a></p>
",05/05/2021 01:54,Errors,"The user is getting unexpected results when running their quantum circuit on real quantum hardware, even though it works as expected on a simulator.", Errors,,,,Errors,
17363.0,Drawing the circuit in Qiskit - how to set same style as in Composer?,"<p>A quantum circuit can be visualized in Qiskit with <code>circuit.draw</code>. A drawing style can be set with parameter <code>output</code> which can have values <code>mpl</code>, <code>text</code> or <code>latex</code> (e.g <code>circuit.draw(output='mpl')</code>).</p>
<p><strong>I am wondering if there is a way to use the same symbols and colors as in IBM Quantum composer since none of the above allow me to do so.</strong></p>
",<programming><qiskit><ibm-q-experience>,05/06/2021 06:57,17366.0,17366.0,"<p>The <em>IBM circuit composer</em> used to be also known as <em>IBM Quantum Experience</em>, or IQX for short. For those historical reasons, the name of the style is <code>iqx</code>:</p>
<pre><code>from qiskit import *
circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cx(0, 1)
circuit.t(1)
circuit.draw('mpl', style='iqx')
</code></pre>
<p><a href=""https://i.stack.imgur.com/sv3fy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sv3fy.png"" alt=""draw output"" /></a></p>
<p>Compare with the composer look:</p>
<p><a href=""https://i.stack.imgur.com/Leh2x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Leh2x.png"" alt=""enter image description here"" /></a></p>
",05/06/2021 08:06,Tooling,"The user is inquiring about customizing the visualization of quantum circuits in Qiskit to match the symbols and colors used in the IBM Quantum composer, which relates to tools and software usage in quantum programming.",Tooling,,,,Tooling,
17371.0,"Is there a way to run ""in the background"" code sent to the IBM backends?","<p>I use different qiskit backends to run my code. Since the maximum number of shots is <span class=""math-container"">$2^{13}$</span>, sometimes I need to send the same code several times with a &quot;different ticket&quot;. I am wondering if there is an equivalent way to run in the background, similar to the command <code>nohup</code>, to run qiskit code so that it runs all the instances one would like (or waiting in the queue as they are sent!)</p>
",<programming><ibm-q-experience>,05/06/2021 10:57,17372.0,17372.0,"<p>All the jobs are sent in a non-blocking way. You can send all your jobs with <code>job = backend.run</code> and recover their results in a fully different session.</p>
<p>In order to fully recover your <code>Job</code> object from a backend, you need the job id (given you are running Qiskit 0.24 or later. See <a href=""https://quantumcomputing.stackexchange.com/questions/17371/is-there-a-way-to-run-in-the-backgound-code-sent-to-the-ibm-backends/17372?noredirect=1#comment25518_17372"">@jyu00's comment</a>)</p>
<p>You can save your job ids like this:</p>
<pre><code>jobs = []
for circuit in circuits:
  job = backend.run
  jobs.append(job.job_id())
</code></pre>
<p>Later, when the job is done, you can recover each <code>Job</code> object like this:</p>
<pre><code>provider = IBMQ.load_account()
job = provider.get_backend(backend_name).retrieve_job(job_id)
</code></pre>
",05/06/2021 11:21,Tooling,"The user is asking about running Qiskit code in the background, similar to the nohup command in Unix-like systems. This falls under the category of tool usage in quantum programming.",Tooling,,,,Tooling,
17375.0,Is there any way to obtain the number of qubits of a given backend in Qiskit?,"<p>I'm testing out a program in different IBMQ mock backends, and I want the program to use the maximum number of qubits in each case. Is there any function/method to extract the number of qubits of a given backend, so that I don't have to manually look it up every time?</p>
<p>Extra: Is there any way to automate the process of selecting each of these mock backends? My plan is to create an array</p>
<p><code>fake_servers = [FakeAlmaden(), FakeAthens(), FakeBelem(), FakeBoeblingen()]</code></p>
<p>etc, but if there's a more straightforward way, I'd like to know about it...</p>
",<programming><qiskit><ibm-q-experience><ibm>,05/06/2021 14:44,17376.0,17376.0,"<p>The number of qubits is part of the backend configuration:</p>
<pre><code>FakeManhattan().configuration().n_qubits
</code></pre>
<pre><code>65
</code></pre>
<p>If you need to filter the list of mocked backends based on the amount of qubits:</p>
<pre><code>from qiskit.test.mock import FakeProvider
provider = FakeProvider()
[ b.name() for b in provider.backends() if b.configuration().n_qubits &gt; 20]
</code></pre>
<pre><code>['fake_cambridge',
 'fake_cambridge',
 'fake_manhattan',
 'fake_montreal',
 'fake_mumbai',
 'fake_paris',
 'fake_rochester',
 'fake_sydney',
 'fake_toronto']
</code></pre>
",05/06/2021 14:59,Tooling," The user is seeking information on how to extract the number of qubits from different IBMQ mock backends and is also interested in automating the process of selecting these mock backends, both of which pertain to tools and software usage in quantum programming.",Tooling,,,,Tooling,
17402.0,Qiskit: Transpilation and the CircuitSampler,"<p>I am using Qiskit's <code>opflow</code> and its <code>CircuitSampler</code> to evaluate matrix elements / expectation values. Now, going beyond <code>statevector</code> and simple <code>qasm</code> simulations, I want to introduce noise of a real device, specify qubit-connectivity (<code>coupling_map</code>), and choose which physical qubits the logical qubits of my circuit are mapped to (<code>initial_layout</code>). This is all specified in a <code>QuantumInstance</code> which is then passed to the <code>CircuitSampler</code>,</p>
<pre><code>result = CircuitSampler(QuantumInstance).convert(operator).eval()
</code></pre>
<p>How do all these specifications for transpilation translate through the <code>CircuitSampler</code> and into the final output? I.e., does <code>CircuitSampler</code> transpile the circuits inside, e.g., <code>ListOp</code> before sampling? And how can I check which <em>physical qubits</em> the logical ones were mapped to during transpilation?</p>
<p>I am confused by <a href=""https://qiskit.org/documentation/stubs/qiskit.opflow.converters.CircuitSampler.html?highlight=circuitsampler#qiskit.opflow.converters.CircuitSampler"" rel=""nofollow noreferrer"">this sentence in the documentation</a>:</p>
<blockquote>
<p>The CircuitSampler aggressively caches transpiled circuits to handle re-parameterization of the same circuit efficiently.</p>
</blockquote>
<p>What does this mean?</p>
",<programming><qiskit><ibm-q-experience><transpile>,05/08/2021 14:15,17415.0,17415.0,"<p>This post contains a few questions,  so let's first recap the steps the circuit sampler goes through (you can also check out the <a href=""https://github.com/Qiskit/qiskit-terra/blob/77da2b5668637ad878d2773dadc79530f82b3459/qiskit/opflow/converters/circuit_sampler.py#L144"" rel=""noreferrer"">source code here</a>), before answering your questions.</p>
<h3>How the Circuit Sampler works</h3>
<p>Provided with a backend/quantum instance and an operator expression, the job of the circuit sampler is to execute all circuits in the operator expression and replace them by the circuit result. Imagine you have an operator expression consisting of an operator measurement composed with a circuit-state:</p>
<pre><code>circuit = QuantumCircuit(1)
circuit.h(0)

hamiltonian = X + Z

expr = StateFn(hamiltonian, is_measurement=True).compose(state)
print(expr)
# prints:
# ComposedOp([
#   OperatorMeasurement(1.0 * X
#   + 1.0 * Z),
#   CircuitStateFn(
#        âââââ
#   q_0: â¤ H â
#        âââââ
#   )
# ])
</code></pre>
<p>If you then apply the circuit sampler (e.g. with a statevector simulator as backend)</p>
<pre><code>backend = Aer.get_backend('statevector_simulator')
sampler = CircuitSampler(backend) 
sampled = sampler.convert(expr)
print(sampled)
# prints:
# ComposedOp([
#   OperatorMeasurement(1.0 * X
#   + 1.0 * Z),
#   VectorStateFn(Statevector([0.70710678+0.j, 0.70710678+0.j], dims=(2,)))
# ])
</code></pre>
<p>then <code>sampled</code> is the same as <code>expr</code> but the circuit-state has been replaced with a vector-state.</p>
<p>To do that, the circuit sampler goes through the following steps:</p>
<ol>
<li>Extract all circuits from the operator expression (and cache them)</li>
<li>Transpile all circuits (and cache them)</li>
<li>Execute all circuits with the provided quantum instance</li>
<li>Replace the original circuit-states with the results</li>
</ol>
<h3>Your questions</h3>
<p>So to answer your questions above:</p>
<blockquote>
<p>How do all these specifications for transpilation translate through the CircuitSampler and into the final output?</p>
</blockquote>
<p>Yes, the circuit sampler transpiles the circuits according to the specifications
in the quantum instance.</p>
<blockquote>
<p>And how can I check which physical qubits the logical ones were mapped to during transpilation?</p>
</blockquote>
<p>There is no nice way to check what the transpiled circuits look like. Ideally you would just transpile the circuits manually with the quantum instance since the circuit sampler's purpose is only the execution. However, you could access the cache (but that's not officially supported behavior):</p>
<pre><code>last_cache = list(sampler._cached_ops.values())[-1]
transpiled_circs = last_cache.transpiled_circ_cache
</code></pre>
<blockquote>
<p>I am confused by this sentence in the documentation:</p>
<blockquote>
<p>The CircuitSampler aggressively caches transpiled circuits to handle re-parameterization of the same circuit efficiently.</p>
</blockquote>
</blockquote>
<p>We often have the use case where we want to execute the same circuit many times but with different parameter values in the qubit gates. If we only change the parameter values, we can transpile a &quot;template&quot; and only assign the values afterwards. Since transpilation is expensive, this can save a lot of time.</p>
<p>As pointed out above in the circuit sampler steps, the circuits sampler caches circuits at different points and tries to re-use already transpiled circuits to avoid the expensive transpilation.</p>
",05/09/2021 19:53,Tooling,"The user is seeking information and clarification on how various specifications for transpilation, noise, qubit-connectivity, and qubit mapping translate through the CircuitSampler in Qiskit's opflow, which pertains to tools and software usage in quantum programming.",Tooling,,,,Tooling,
17416.0,How to decide bias in Hamiltonian Ising model?,"<p>I am trying to code finance portfolio optimisation problem into a quantum annealer, using the Hamiltonian Ising model. I am using the <a href=""https://sdk-docs.readthedocs.io/en/latest/docs_neal/reference/sampler.html"" rel=""nofollow noreferrer"">dwave</a> module</p>
<pre><code>neal.sampler.SimulatedAnnealingSampler.sample_ising
</code></pre>
<p><strong>I was wondering how one gets to decide what the bias is?</strong> I don't really get how that works. On the documentation of Dwave it says the following:</p>
<p><a href=""https://i.stack.imgur.com/nAEAm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nAEAm.png"" alt=""enter image description here"" /></a></p>
<p>There also was this example code:</p>
<pre><code>import neal
&gt;&gt;&gt; sampler = neal.SimulatedAnnealingSampler()
h = {'a': 0.0, 'b': 0.0, 'c': 0.0}
J = {('a', 'b'): 1.0, ('b', 'c'): 1.0, ('a', 'c'): 1.0}
sampleset = sampler.sample_ising(h, J, num_reads=10)
print(sampleset.first.energy)
</code></pre>
",<programming><d-wave><annealing><quantum-computing-for-finance>,05/09/2021 21:08,17417.0,17417.0,"<p>Problem solving in Ocean framework goes by modeling the problem into a <a href=""https://docs.ocean.dwavesys.com/en/stable/docs_dimod/intro/intro_bqm.html"" rel=""nofollow noreferrer"">BinaryQuadraticModel</a>. The pure quantum samplers natively only understand this model. For the hybrid samplers (Leap) one can model the problem into <a href=""https://docs.ocean.dwavesys.com/en/stable/concepts/dqm.html"" rel=""nofollow noreferrer"">DiscreteQuadraticModel</a>.</p>
<p>The <em>bias</em> are the linear terms in those models objective functions.  They are derived with respect to the problem after the transformation into a BQM or DQM was done. Finance is a topic in D-Waves <a href=""https://docs.dwavesys.com/docs/latest/handbook_problems.html#cb-probs-finance"" rel=""nofollow noreferrer"">problem solving handbook</a>. There are some papers listed.</p>
<p>So, to get the bias terms the problem first needs a formulation as a constrained optimization problem. Examples are given in the Ocean docs, e.g. for a map coloring problem. There are some tools to derive a BQM from constraint optimization problems (pyqubo or <a href=""https://docs.ocean.dwavesys.com/en/stable/docs_binarycsp/sdk_index.html"" rel=""nofollow noreferrer"">dwavebinarycsp</a> ).
This needs to get transformed into an Ising problem to be used for <code>neal.sampler.SimulatedAnnealingSampler.sample_ising</code>. The dimod package provides tools for this task.
The terms really depend on the problem structure.</p>
",05/10/2021 06:50, Conceptual,"The user is seeking an understanding of how to determine the bias in the context of coding a finance portfolio optimization problem into a quantum annealer using the Hamiltonian Ising model, which involves discussing the underlying concepts and principles of quantum annealing and Ising models.",Conceptual,,,, Conceptual,
17438.0,Performing a generic single-qubit Pauli error channel in stim,"<p>I have a Pauli channel with disjoint probabilities <span class=""math-container"">$P_I$</span>, <span class=""math-container"">$P_X$</span>, <span class=""math-container"">$P_Y$</span>, <span class=""math-container"">$P_Z$</span> (meaning <span class=""math-container"">$P_I + P_X + P_Y  + P_Z = 1$</span>) corresponding to Pauli errors I, X, Y, Z. Is there some way apply this Pauli channel in Stim?</p>
",<programming><stim>,05/11/2021 00:39,17439.0,17439.0,"<p><strong>Update</strong>: Since v1.4, stim supports custom pauli channels <code>PAULI_CHANNEL_1(px, py, pz)</code> and <code>PAULI_CHANNEL_2(pix, piy, ..., pzz)</code>.</p>
<hr />
<p><strong>Before v1.4</strong></p>
<p>If <span class=""math-container"">$P_x = P_y = P_z$</span> then <code>DEPOLARIZE1</code> is what you need. If <span class=""math-container"">$P_y = P_z = 0$</span> then <code>X_ERROR</code> is what you need (ditto <code>Y_ERROR</code>, <code>Z_ERROR</code>). Otherwise you can use <code>CORRELATED_ERROR</code> and <code>ELSE_CORRELATED_ERROR</code>.</p>
<p>For example, suppose <span class=""math-container"">$P_x = 0.1$</span>, <span class=""math-container"">$P_y = 0.2$</span>, <span class=""math-container"">$P_z = 0.3$</span> and your target is qubit <span class=""math-container"">$5$</span>. You can do this:</p>
<pre><code>CORRELATED_ERROR(0.1) X5
ELSE_CORRELATED_ERROR(0.22222222222) Y5  # note: P(Y|not X) = 20%/(100% - 10%)
ELSE_CORRELATED_ERROR(0.42857142857) Z5  # note: P(Z|not X and not Y) = 30%/(100% - 10% - 20%)
</code></pre>
<p>The else-case probabilities are conditioned on the earlier cases not happening, which is why they are larger than the original probabilities.</p>
<p>Here's the general case, implemented as python code:</p>
<pre><code>def append_generic_single_qubit_error_channel_to_circuit(
        circuit: stim.Circuit,
        target: int,
        px: float,
        py: float,
        pz: float):
    &quot;&quot;&quot;
    Args:
        circuit: The circuit to append the error channel to.
        target: The qubit to hit with the error channel.
        px: The disjoint probability of an X error.
        py: The disjoint probability of a Y error.
        pz: The disjoint probability of a Z error.

    Requires:
        0 &lt;= px &lt;= 1
        0 &lt;= py &lt;= 1
        0 &lt;= pz &lt;= 1
        px+py+pz &lt;= 1
    &quot;&quot;&quot;
    circuit.append_operation(&quot;CORRELATED_ERROR&quot;, [stim.target_x(target)], px)
    circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_y(target)], py / (1 - px))
    circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_z(target)], pz / (1 - px - py))
</code></pre>
<p>Note that it agrees with the example case:</p>
<pre><code>import stim
c = stim.Circuit()
append_generic_single_qubit_error_channel_to_circuit(
    circuit=c, target=5, px=0.1, py=0.2, pz=0.3)
print(c)
</code></pre>
<pre><code>E(0.1) X5
ELSE_CORRELATED_ERROR(0.222222) Y5
ELSE_CORRELATED_ERROR(0.428571) Z5
</code></pre>
<p>(<code>E</code> is an abbreviation for <code>CORRELATED_ERROR</code>)</p>
",05/11/2021 00:39,API Usage,"The question is about how to use a specific function (Pauli channel) in a quantum programming software (Stim), which falls under the usage of APIs in quantum programming",API Usage ,,,,API Usage,
17441.0,Is there a way I can reduce the code for generating simple circuits with the same structure?,"<p>here's the code I'm using to generate 3 quantum circuits with the same structure (They're only differed by the first U3 gate on the qubit):</p>
<pre><code>quancs = QuantumCircuit(1)  # Circ 1
quancs.u3(gamma,beta,delta,0)
        
quancs1 = QuantumCircuit(1) # Circ 2
quancs1.u3(2,3,2,0)         
quancs1.u3(gamma,beta,delta,0)
        
quancs2 = QuantumCircuit(1) # Circuit 3. 
quancs2.u3(-2.5,2,-2,0)
quancs2.u3(gamma,beta,delta,0)
        
results = execute(quancs, simulator).result()
results1 = execute(quancs1, simulator).result()
results2 = execute(quancs2, simulator).result()
</code></pre>
<p>I treated the circuits separately to obtain the results. I'm wondering is there a way I can simplify/shorten this code? Thanks for the help!</p>
",<programming><qiskit>,05/11/2021 03:17,17442.0,17442.0,"<p>How about something like this:</p>
<pre><code>from qiskit.circuit import QuantumCircuit
def my_circuit(initial_gate_params, params):
    circuit = QuantumCircuit(1)
    circuit.u3(initial_gate_params[0],initial_gate_params[1],initial_gate_params[2],0)         
    circuit.u3(params[0], params[1], params[2], 0)
    return circuit 


initial_gate_params = [ [0,0,0], [2,3,2], [-2.5,2,-2] ] #the params for your initial u3 gate
params = [gamma, beta, zeta] #your defined gamma, beta, zeta

circuits = [my_circuit(i, params) for i in initial_gate_params ]

from qiskit import Aer, execute
backend = Aer.get_backend('qasm_simulator')
results = execute(circuits, backend) 
</code></pre>
",05/11/2021 03:38,Tooling,"The user is asking for help to simplify and shorten their quantum programming code, which falls under the usage of tools and software in quantum programming",Tooling,,,,Tooling,
17464.0,Time result for my algorithm,"<p>I've used the function <code>result.time_taken</code> to know the amount of time used to execute a task on the real chip, but I don't understand if the result is in seconds or in milliseconds, because if I run my circuit with 1 shot my result is 7.8, if I run my circuit with 1024 shots my result is 8.4. How is this possible? Does the time include only time to execute the algorithm, or other times (for instance the initialization of my input...)?</p>
",<programming><qiskit><algorithm><ibm-q-experience>,05/12/2021 05:57,17467.0,17467.0,"<p>The device time consists of multiple step, such as loading the circuit to the device, then the actual processor time and finally the return of the results.</p>
<p>Only the processor time scales with the number of shots, the device loading time, and result return are constant overhead. Thus it makes sense to see the behavior you saw; you have some constant time and then on top the time that scales linearly in the number of shots. You could find the time for the overhead if you do a linear fit to the total execution time, then the offset equals the overhead.</p>
<p>As a more concrete example, on a recent job the device load and return result together took about 10s and the processor time for 1024 shots was ~4s, and for 8192 ~28s (so even a little bit faster than 8x the 1024 shots time). Of course these numbers depend on the device you're using!</p>
",05/12/2021 07:06,API Usage,"The user is asking about the functionality of a specific method (result.time_taken) in a quantum programming framework, which falls under the usage of APIs in quantum programming. }",API Usage,,,,API Usage,
17480.0,Replacement of FermionicOperator from qiskit.chemistry in qiskit_nature,"<p><code>qiskit.chemistry.FermionicOperator</code> <a href=""https://qiskit.org/documentation/stubs/qiskit.chemistry.FermionicOperator.html#qiskit.chemistry.FermionicOperator"" rel=""nofollow noreferrer"">here</a> is very useful for converting fermionic operators to qubits operators. <code>qiskit.chemistry</code> has been deprecated. I went through the migration guide they have but I can't seem to find the replacement of <code>FermiOpetator</code> in <code>qiskit_nature</code>. Anyone know this? Thanks a lot.</p>
",<programming><qiskit>,05/12/2021 19:09,17483.0,17483.0,"<p>This is now under <code>QubitConverter</code> within <code>qiskit_nature</code>.</p>
<p>This <a href=""https://github.com/Qiskit/qiskit-nature/tree/main/docs/tutorials"" rel=""nofollow noreferrer"">link here</a> might be helpful. You might have to look into how to define the fermionic operators in this new released version, but the example below, which is really just taking from the above linked, might provide some guidance.</p>
<pre><code>from qiskit import Aer
from qiskit_nature.drivers import PySCFDriver, UnitsType, Molecule
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import JordanWignerMapper

molecule = Molecule(geometry=[['H', [0., 0., 0.]],
                              ['H', [0., 0., 0.735]]],
                     charge=0, multiplicity=1)
driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')
</code></pre>
<p>The electronic Hamiltonian written in term of fermionic operators is:</p>
<pre><code>es_problem = ElectronicStructureProblem(driver)
second_q_op = es_problem.second_q_ops()
print(second_q_op[0])

+-+- * (0.18093119978423158+0j)
+ +--+ * (-0.18093119978423156+0j)
+ -++- * (-0.18093119978423156+0j)
+ -+-+ * (0.18093119978423156+0j)
+ IIIN * (-0.47189600728114073+0j)
+ IINI * (-1.2563390730032507+0j)
+ IINN * (0.48365053047106565+0j)
+ INII * (-0.47189600728114073+0j)
+ ININ * (0.6985737227320187+0j)
+ INNI * (0.6645817302552972+0j)
+ NIII * (-1.2563390730032507+0j)
+ NIIN * (0.6645817302552972+0j)
+ NINI * (0.675710154803517+0j)
+ NNII * (0.48365053047106565+0j)
</code></pre>
<p>Which can be converted to qubitOp as:</p>
<pre><code>qubit_converter = QubitConverter(JordanWignerMapper())
qubit_op = qubit_converter.convert(second_q_op[0])
print(qubit_op)

-0.8535040737275406 * IIII
- 0.03329093140262394 * ZIII
+ 0.09539931515219398 * IZII
+ 0.08254659792513139 * ZZII
- 0.03329093140262387 * IIZI
+ 0.1460749494329415 * ZIZI
+ 0.13998427822128043 * IZZI
+ 0.09539931515219396 * IIIZ
+ 0.13998427822128043 * ZIIZ
+ 0.1381506045026359 * IZIZ
+ 0.08254659792513139 * IIZZ
+ 0.05743768029614903 * XXXX
+ 0.05743768029614903 * YYXX
+ 0.05743768029614903 * XXYY
+ 0.05743768029614903 * YYYY
</code></pre>
",05/12/2021 22:01, API Usage,"The user is asking about the replacement of a specific method (FermionicOperator) in a quantum programming library (qiskit_nature), which falls under the usage of APIs in quantum programming.", API Usage,,,, API Usage,
17546.0,Sympy suddently does not work together with TFQ,"<p>I work with tensorflow-quantum and use <code>sympy</code> for parameter updating.</p>
<p>Suddenly, without (manually) updating or changing anything this error comes up:</p>
<pre><code>  File &quot;/home/eli/anaconda3/lib/python3.8/site-packages/tensorflow_quantum/core/serialize/serializer.py&quot;, line 93, in _symbol_extractor
    if isinstance(expr, sympy.mul.Mul):

AttributeError: module 'sympy' has no attribute 'mul'
</code></pre>
<p>Has anyone had this before? Do you have any suggestions for what I can try to fix this?</p>
<p>I am working on Ubuntu 20.04.2 LTS
TFQ version 0.4.0
Sympy version 1.8</p>
<p>the error occurs when I build my PQC layer:</p>
<pre><code>model = tf.keras.Sequential([tf.keras.layers.Input(shape=(), dtype=tf.string), 
                        tfq.layers.PQC(circuit, [cirq.Z(q) for q in builder.get_valid_outputs()]),
                        ], name = model_type)
</code></pre>
<p>and it worked like this a long time.</p>
",<programming><quantum-enhanced-machine-learning><tfq>,5/18/2021 10:19,17548.0,17548.0,"<p>Just to add a little more context to your answer: TensorFlow-Quantum 0.4.0 has an explicit version dependency on <code>sympy==1.5.0</code> in the <code>setup.py</code> module <a href=""https://github.com/tensorflow/quantum/blob/v0.4.0/release/setup.py#L53"" rel=""noreferrer"">here</a>, which should have been installed when you first installed TFQ. It's possible that other python pip packages may have overriden or upgraded the sympy version since then. Using something like <code>pip list | grep sympy</code> will show which version of sympy you have installed in case you see breakages like this going forward with sympy (or other packages + dependencies) .</p>
<p>Also one final note: TensorFlow Quantum 0.5.0 has been released and does also depend on sympy==1.5.0 which you can see <a href=""https://github.com/tensorflow/quantum/blob/master/release/setup.py#L54"" rel=""noreferrer"">here</a> .</p>
",5/18/2021 14:25,Errors,"The user is encountering an error (AttributeError: module 'sympy' has no attribute 'mul') while using a quantum programming library (tensorflow-quantum), which falls under seeking solutions for errors and exceptions in quantum program development",Errors,,,,Errors,
17573.0,Saving vectorized circuits in Qiskit,"<p>Is there a way to save vectorized images in Qiskit? I am using</p>
<pre><code>circuit.draw('latex', filename='./file.pdf')
</code></pre>
<p>They type of the image is a pdf, but it looks like a png exported as a pdf. For reference I attach here a figure of the differences I point out.</p>
<p><a href=""https://i.stack.imgur.com/cQIpA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cQIpA.png"" alt=""enter image description here"" /></a></p>
<p>Hopefully some differences can be noticed. The top subfigure was made with <code>Quantikz</code>, while the other directly with <code>Qiskit</code>. The difference that the top is vectorized and the other looks like it isn't.</p>
<p><strong>EDIT:</strong></p>
<p>The problem is solved using what luciano pointed out. I just want to add that the resulting pdf circuit may still need some cleaning. Apparently the figure is not &quot;tight framed&quot;, I attach an example of what I mean</p>
<p><a href=""https://i.stack.imgur.com/QucdY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QucdY.png"" alt=""enter image description here"" /></a></p>
<p>The letters that appear at the bottom are part of the figure caption. One can see that there's a huge space between the image and the caption, along with a border that frames the image.</p>
",<programming><qiskit>,5/20/2021 8:46,17574.0,17574.0,"<p>With <code>'latex_source'</code> you can save the LaTeX file and compile it later with pdflatex</p>
<p>In an interactive console (such a Jupyter notebook), you can run the following:</p>
<pre><code>circuit.draw('latex_source', filename='./file.tex')
!pdflatex file.tex
</code></pre>
<p>This will create a file.pdf in actual PDF format.</p>
<p>(I understand this is very unintuitive, <a href=""https://github.com/Qiskit/qiskit-terra/pull/6446"" rel=""nofollow noreferrer"">I submitted a fix to it</a>)</p>
",5/20/2021 8:56,Tooling,The user is inquiring about the capability of saving vectorized images in Qiskit and is seeking assistance in achieving this. This relates to the usage of tools and software in quantum programming.,Tooling,,,,Tooling,
17626.0,Qiskit Pulse Notebook,"<p><a href=""https://i.stack.imgur.com/nUvjc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nUvjc.png"" alt=""enter image description here"" /></a>When I downloaded the source code from Qiskit Notebook <a href=""https://qiskit.org/textbook/ch-quantum-hardware/accessing_higher_energy_states.html"" rel=""nofollow noreferrer"">Accessing Higher Energy States</a> and tried to execute it, the output and graph seem wrong in the step finding the frequency step which leads to the failure of other parts. I have tried to update the library &quot;Sample Pulse&quot; to the new library &quot;Waveform&quot;. However, the output is still incorrect. I think the data given for IBM-Armonk is out of date. Does anyone know what is the problem?</p>
<p>Basically, I can not find the correct output when executing the code to find Rabi Oscillations. Here the code</p>
<pre><code>num_rabi_points = 50 # number of experiments (ie amplitudes to sweep out)

    # Drive amplitude values to iterate over: 50 amplitudes evenly spaced from 0 to 0.75
drive_amp_min = 0
drive_amp_max = 0.75
drive_amps = np.linspace(drive_amp_min, drive_amp_max, num_rabi_points)
# Create schedule
rabi_01_schedules = []
# loop over all drive amplitudes
for ii, drive_amp in enumerate(drive_amps):
    # drive pulse
    rabi_01_pulse = pulse_lib.gaussian(duration=drive_samples, 
                                       amp=drive_amp, 
                                       sigma=drive_sigma, 
                                       name='rabi_01_pulse_%d' % ii)
    
    # add commands to schedule
    schedule = pulse.Schedule(name='Rabi Experiment at drive amp = %s' % drive_amp)
    schedule |= pulse.Play(rabi_01_pulse, drive_chan)
    schedule |= measure &lt;&lt; schedule.duration # shift measurement to after drive pulse
    rabi_01_schedules.append(schedule)
# Assemble the schedules into a program
# Note: We drive at the calibrated frequency.
rabi_01_expt_program = assemble(rabi_01_schedules,
                                backend=backend,
                                meas_level=1,
                                meas_return='avg',
                                shots=NUM_SHOTS,
                                schedule_los=[{drive_chan: cal_qubit_freq}]
                                               * num_rabi_points)
</code></pre>
",<programming><qiskit><ibm-q-experience><openpulse>,5/25/2021 6:18,17740.0,17740.0,"<p>I came across the same issue last week and hence made corrections and opened a PR on the same to change the default values on the textbook.<br />
<a href=""https://github.com/qiskit-community/qiskit-textbook/pull/1132"" rel=""nofollow noreferrer"">https://github.com/qiskit-community/qiskit-textbook/pull/1132</a></p>
<p>The key is to change the <code>drive_power</code> from 0.3 to 0.1</p>
<p>It's expected for such values to change, in fact, the pulses that represent circuit gates used by IBM are calibrated quite often</p>
<p><strong>drive power 0.3</strong></p>
<p><a href=""https://i.stack.imgur.com/ZIdUk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZIdUk.png"" alt=""drive power 0.3"" /></a></p>
<p><strong>drive power 0.1</strong></p>
<p><a href=""https://i.stack.imgur.com/hM8F3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hM8F3.png"" alt=""drive power 0.1"" /></a></p>
",5/31/2021 9:27,Errors,"The user is encountering an error while executing a quantum programming code from a Qiskit Notebook, which falls under seeking solutions for errors and exceptions in quantum program development.",Errors,,,,Errors,
17637.0,How to create the equivalent of the Qiskit rxx gate in Pennylane?,"<p>How can I create the Pennylane equivalent of:</p>
<pre><code>from qiskit import QuantumCircuit

circ = QuantumCircuit(2, 2)
circ.rxx(theta=0.3, qubit1=0, qubit2=1)
</code></pre>
",<programming><qiskit><quantum-gate><pennylane>,5/25/2021 15:44,17640.0,17640.0,"<p>Here's a simple example if you're looking for a quick hack:</p>
<pre><code>import pennylane as qml
import numpy as np

def RXX(theta):
    rxx = np.array([
        [np.cos(theta/2), 0, 0, -1j*np.sin(theta/2)],
        [0, np.cos(theta/2), -1j*np.sin(theta/2), 0],
        [0, -1j*np.sin(theta/2), np.cos(theta/2), 0],
        [-1j*np.sin(theta/2), 0, 0, np.cos(theta/2)]
    ])
    return rxx

dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(theta):
    qml.QubitUnitary(RXX(theta), wires=[0, 1])
    return qml.expval(qml.PauliZ(0))
</code></pre>
<p>Alternatively, you can create a new RXX class as they do in this <a href=""https://pennylane.ai/blog/2021/05/how-to-add-custom-gates-and-templates-to-pennylane/"" rel=""nofollow noreferrer"">custom gate tutorial</a>:</p>
<pre><code>import pennylane as qml
from pennylane.operation import Operation
from pennylane import numpy as np

class RXX(Operation):
    num_params = 1
    num_wires = 2
    par_domain = &quot;R&quot;

    grad_method = &quot;A&quot;
    grad_recipe = None # This is the default but we write it down explicitly here.

    generator = [(qml.PauliX(0) @ qml.PauliX(1)).matrix, -0.5]

    @staticmethod
    def decomposition(theta, wires):
        return [qml.PauliRot(theta, 'XX', wires=wires)]

    @staticmethod
    def _matrix(*params):
        theta = params[0]
        c = np.cos(0.5 * theta)
        s = np.sin(0.5 * theta)
        return np.array(
            [
                [c, 0, 0, -s],
                [0, c, -s, 0],
                [0, -s, c, 0],
                [-s, 0, 0, c]
            ]
        )

    def adjoint(self):
        return RXX(-self.data[0], wires=self.wires)
</code></pre>
",5/25/2021 16:20,API Usage ,The user is asking how to use the PennyLane API to create a quantum circuit that is equivalent to the Qiskit circuit provided.,API Usage,,,,API Usage ,
17651.0,Setting initial state in Qiskit unitary simulator,"<p>I'm getting started in IBM quantum lab for quantum computing. My task is to put quantum state <span class=""math-container"">$|0\rangle$</span> on the 1st qubit and state <span class=""math-container"">$|1\rangle$</span> on second one. I tried using this method to initialize it as:</p>
<pre><code>qc.initialize(0,0)
qc.initialize(1,1)
</code></pre>
<p>but when I run in the unitary simulator, I get the following error:</p>
<pre><code>Simulation failed and returned the following error message:
ERROR: Failed to load qobj: Invalid qobj &quot;initialize&quot; instruction (&quot;params&quot; is incorrect length).
</code></pre>
<p>I also tried using reset method but it displayed error as well</p>
<pre><code>qc.reset(0)
qc.reset(1)
qc.x(1)
</code></pre>
<p>If anyone knows how to set state to a specific qubit in Qiskit it would be great, thanks in advance</p>
<p>The full code:</p>
<pre><code>#Creating a quantum circuit with two qubits
qc=QuantumCircuit(2)

#Set the state of the first qubit to|0â© and set the state of the second qubit to|1â©.
qc.initialize(0,0)
qc.initialize(0,0)
#or
#qc.reset(0)
#qc.reset(1)
#qc.x(1)

#Applying Hadamard to both qubits
qc.h(0)
qc.h(1)


#Applying CNOT operator, where the controller qubit is the first qubit and the target qubit is the second qubit
qc.cx(0,1)

#Applying Hadamard to both qubits
qc.h(0)
qc.h(1)

display(qc.draw()) 
usim = Aer.get_backend('unitary_simulator')
qobj = assemble(qc)
unitary = usim.run(qobj).result().get_unitary()
array_to_latex(unitary, pretext=&quot;\\text{Circuit = }\n&quot;)
</code></pre>
",<programming><qiskit><quantum-state>,5/26/2021 12:55,17652.0,17652.0,"<p>If I understand correctly, your circuit looks like this:</p>
<pre><code>from qiskit import *
qc = QuantumCircuit(2)
qc.initialize(0,0)
qc.initialize(1,1)

qc.h(0)
qc.h(1)
qc.cx(0,1)
qc.h(0)
qc.h(1)

qc.draw('mpl') 
</code></pre>
<p><a href=""https://i.stack.imgur.com/pLRHc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pLRHc.png"" alt=""enter image description here"" /></a></p>
<p>And you want to run it in the Aer unitary simulator. However, the simulator does not support the instruction <code>initialize</code>. So you need to <em>transpile</em> your circuit to the instruction set of the selected backend.  You can do that with <code>transpile</code>:</p>
<pre><code>usim = Aer.get_backend('unitary_simulator')
transpiled = transpile(qc, backend=usim)
transpiled.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/qRF4G.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qRF4G.png"" alt=""enter image description here"" /></a></p>
<p>Once transpiled, you can run it in the backend:</p>
<pre><code>qobj = assemble(transpiled)
unitary = usim.run(qobj).result().get_unitary()
</code></pre>
<p>Here is the resulting unitary:</p>
<pre><code>from qiskit.visualization import array_to_latex
array_to_latex(unitary, prefix=&quot;\\text{Circuit = }\n&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/0S1sx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0S1sx.png"" alt=""enter image description here"" /></a></p>
",5/26/2021 13:17,API Usage,"The user is seeking assistance with using Qiskit's API to initialize specific qubits to desired states, which falls under the category of API usage for quantum programming.",Errors,The user is seeking solutions and explanations for an error they are encountering while using the initialize and reset methods in the Qiskit module for quantum program development,No,110.0,API Usage,"The user is specifically asking for guidance on how to initialize specific qubits to desired states using Qiskit's API, which aligns with the category of API usage for quantum programming."
17662.0,Does Qiskit Statevector has actual speed up for Grover Search?,"<p>From <a href=""https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.Grover.html?highlight=grover#qiskit.aqua.algorithms.Grover"" rel=""nofollow noreferrer"">Qiskit document</a>, the <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html?highlight=statevector#qiskit.quantum_info.Statevector"" rel=""nofollow noreferrer"">Statevector</a> can be used to specify the oracle of Grover Search. After seeing the <a href=""https://qiskit.org/documentation/_modules/qiskit/quantum_info/states/statevector.html#Statevector"" rel=""nofollow noreferrer"">source code</a> of the operators, it seems a statevector is converted to a rank-1 projector operator. In this case, the operator may not be unitary.</p>
<p>The code below can be run on a real IBMQ machine.</p>
<pre><code>from qiskit import *
from qiskit.quantum_info import Statevector
from qiskit.aqua.algorithms import Grover
from qiskit import QuantumCircuit

oracle = Statevector([0,0,0,0,0,1,1,0])
good_state = ['110','101']
grover = Grover(oracle=oracle, good_state=good_state)
# backend = provider.get_backend('ibmq_lima')
backend = BasicAer.get_backend('qasm_simulator')
result = grover.run(quantum_instance=backend)
print('Result type:', type(result))
print()
print('Success!' if result.oracle_evaluation else 'Failure!')
print('Top measurement:', result)
</code></pre>
<p>However, it does not make sense to me because the operator here is not unitary.
<a href=""https://i.stack.imgur.com/cmnNO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cmnNO.png"" alt=""enter image description here"" /></a></p>
<p>I am wondering if Statevector of Qiskit has actual speed up or it is just for illustration of Grover Search. Besides, how does it realize when the operator is not unitary?</p>
",<programming><qiskit><grovers-algorithm><quantum-circuit>,5/27/2021 4:40,17667.0,17667.0,"<p>The reason for this is that the actual oracle used in the algorithm is not obtained from <code>oracle.to_operator()</code>. If you look up <a href=""https://qiskit.org/documentation/_modules/qiskit/aqua/algorithms/amplitude_amplifiers/grover.html#Grover"" rel=""nofollow noreferrer"">the code</a> for Grover's algorithm, you can see the following:</p>
<pre><code>grover_operator = GroverOperator(oracle=oracle,
                                 state_preparation=state_preparation,
                                 reflection_qubits=reflection_qubits,
                                 mcx_mode=mct_mode)
</code></pre>
<p>Then, you can take a look at the <a href=""https://github.com/Qiskit/qiskit-terra/blob/master/qiskit/circuit/library/grover_operator.py#L183"" rel=""nofollow noreferrer""><code>GroverOperator</code> source code</a> to find the following:</p>
<pre><code>if isinstance(oracle, Statevector):
    from qiskit.circuit.library import Diagonal  # pylint: disable=cyclic-import
    oracle = Diagonal((-1) ** oracle.data)
</code></pre>
<p>What this does is explained in the documentation: it builds a diagonal matrix whose entries on the diagonal are all equal to <span class=""math-container"">$(-1)^{x_i}$</span>, where the <span class=""math-container"">$x_i$</span> are the entries of your <code>Statevector</code>. In your case, those entries on the diagonal will all be equal to <span class=""math-container"">$1$</span> except for the ones corresponding to the states <span class=""math-container"">$|101\rangle$</span> and <span class=""math-container"">$|110\rangle$</span> which will be equal to <span class=""math-container"">$-1$</span>. You can easily see that:</p>
<ol>
<li>This operator is unitary</li>
<li>This operator flips the good states as it is supposed to</li>
</ol>
<p>Since it is used for initialiazing the Grover's algorithm, I don't think it has any kind of speedup when compared to more &quot;traditional&quot; initialisation methods.</p>
",5/27/2021 8:06,Conceptual,"The user is asking about the conceptual understanding of how the Statevector in Qiskit is used to specify the oracle of Grovers Search, and how it works when the operator is not unitary. This falls under discussions about the background, limitations, and underlying concepts of quantum programming",Conceptual,,,,Conceptual,
17663.0,What explains my anomalously scaled up VQE?,"<p>I am trying to implement VQE from the Qiskit to obtain the ground state of a very specific Hamiltonian that has been generated via a <code>docplex</code> minimized quadratic model. The model has been converted to an Ising Hamiltonian using Qiskit's Optimization module. The resultant Hamiltonian denoted by <code>H</code> is as follows:</p>
<pre><code>from qiskit.providers.aer import AerSimulator, QasmSimulator
from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import COBYLA 
from qiskit.circuit.library import TwoLocal
from qiskit import *
from qiskit.opflow import OperatorBase
from qiskit.opflow import Z, X, I  # Pauli Z, X matrices and identity
import pylab
import matplotlib.pyplot as plt
import numpy as np

H =   504.0 * I^I^I^I^I^I^I^Z+1008.0 * I^I^I^I^I^I^Z^I+2016.0 * I^I^I^I^I^Z^I^I+504.0 * I^I^I^I^Z^I^I^I+1143.7999999999997 * I^I^I^Z^I^I^I^I+2287.6 * I^I^Z^I^I^I^I^I+4575.200000000001 * I^Z^I^I^I^I^I^I+1143.7999999999997 * Z^I^I^I^I^I^I^I+98.0 * I^I^I^I^I^I^Z^Z+196.0 * I^I^I^I^I^Z^I^Z+392.0 * I^I^I^I^I^Z^Z^I+49.0 * I^I^I^I^Z^I^I^Z+98.0 * I^I^I^I^Z^I^Z^I+196.0 * I^I^I^I^Z^Z^I^I+93.1 * I^I^Z^Z^I^I^I^I+186.2 * I^Z^I^Z^I^I^I^I+372.4 * I^Z^Z^I^I^I^I^I+46.55 * Z^I^I^Z^I^I^I^I+93.1 * Z^I^Z^I^I^I^I^I+186.2 * Z^Z^I^I^I^I^I^I

backend = QasmSimulator()
optimizer = COBYLA(maxiter=2000)
ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False)
# set the algorithm
vqe = VQE(ansatz, optimizer, quantum_instance=backend)

#run it with the Hamiltonian we defined above
result = vqe.compute_minimum_eigenvalue(H) 
</code></pre>
<p>This however yields the error:</p>
<pre><code>'Circuit execution failed: ERROR:  [Experiment 0] QasmSimulator: Insufficient memory for 141-qubit circuit using &quot;statevector&quot; method. You could try using the &quot;matrix_product_state&quot; or &quot;extended_stabilizer&quot; method instead.'
</code></pre>
<p>My questions are:</p>
<ol>
<li>How and why does my circuit yield <strong>141 qubits</strong> when there are only <strong>8 Pauli Operators</strong> in each term of my Hamiltonian? What am I missing conceptually?</li>
<li>How do we calculate the number of qubits required when solving this sort of problem?</li>
</ol>
",<programming><qiskit><vqe><optimization>,5/27/2021 5:12,17665.0,17665.0,"<h3>Easy Fix:</h3>
<p>It seems like it is because of the way you define <span class=""math-container"">$H$</span>. You <strong>need the parenthesis</strong> around each of the term!</p>
<p>So something like:</p>
<pre><code>H =    (504.0 * I^I^I^I^I^I^I^Z) + (1008.0 * I^I^I^I^I^I^Z^I) + ( 2016.0 *  I^I^I^I^I^Z^I^I)
</code></pre>
<p>Just replace this in your code then it will work!</p>
<hr />
<h3>Alternative (longer) way:</h3>
<p>Here I will offer another way to define the Hamiltonian in case you are curious. Instead of doing the above, if you replace it with something like:</p>
<pre><code>from qiskit.aqua.operators import *
pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ]
pauli_weights = [504.0, 1008.0, 2016.0]
pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \
                         for i in range(len(pauli_terms))]}
H = WeightedPauliOperator.from_dict(pauli_dict)
</code></pre>
<p>This should work. I just grabbed the first 3 entries of your Hamiltonian. Here is the full script for you to reproduce the result:</p>
<pre><code>import numpy as np
from qiskit.providers.aer import AerSimulator, QasmSimulator
from qiskit.algorithms.optimizers import COBYLA 
from qiskit.circuit.library import TwoLocal
from qiskit.aqua.operators import *
from qiskit.aqua import set_qiskit_aqua_logging, QuantumInstance
from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE, NumPyEigensolver
from qiskit.circuit import QuantumCircuit, ParameterVector

pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ]
pauli_weights = [504.0, 1008.0, 2016.0]
pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \
                         for i in range(len(pauli_terms))]}
Hamiltonian = WeightedPauliOperator.from_dict(pauli_dict)
ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False)
print(ansatz)
backend = QasmSimulator()
quantum_instance = QuantumInstance(backend,
                                   shots = 8192,
                                   initial_layout = None,
                                   optimization_level = 3)  

optimizer = COBYLA(maxiter= 100, tol=0.000000001)   
vqe = VQE(Hamiltonian, ansatz, optimizer, initial_point= None , include_custom = False)
print('We are using:', quantum_instance.backend)
vqe_result = vqe.run(quantum_instance)
vqe_result['eigenvalue']
</code></pre>
<p>output:</p>
<pre><code>     ââââââââââââ ââââââââââââ
q_0: â¤ RY(Î¸[0]) âââ¤ RY(Î¸[8]) â
     ââââââââââââ¤ ââââââââââââ¤
q_1: â¤ RY(Î¸[1]) âââ¤ RY(Î¸[9]) â
     ââââââââââââ¤ââ´âââââââââââ¤
q_2: â¤ RY(Î¸[2]) ââ¤ RY(Î¸[10]) â
     ââââââââââââ¤âââââââââââââ¤
q_3: â¤ RY(Î¸[3]) ââ¤ RY(Î¸[11]) â
     ââââââââââââ¤âââââââââââââ¤
q_4: â¤ RY(Î¸[4]) ââ¤ RY(Î¸[12]) â
     ââââââââââââ¤âââââââââââââ¤
q_5: â¤ RY(Î¸[5]) ââ¤ RY(Î¸[13]) â
     ââââââââââââ¤âââââââââââââ¤
q_6: â¤ RY(Î¸[6]) ââ¤ RY(Î¸[14]) â
     ââââââââââââ¤âââââââââââââ¤
q_7: â¤ RY(Î¸[7]) ââ¤ RY(Î¸[15]) â
     âââââââââââââââââââââââââ
We are using: qasm_simulator

(-3528+0j)
</code></pre>
<p>Although I am not sure why you would have two consecutive layers of <span class=""math-container"">$RY$</span> rotation though.</p>
",5/27/2021 6:27,Conceptual,"The user is seeking a conceptual understanding of why their quantum circuit is requiring more qubits than expected for a specific Hamiltonian and how to calculate the number of qubits needed for solving such problems, which falls under the category of conceptual understanding in quantum computing.",Conceptual,,,,Conceptual,
17704.0,Decomposition of gate $R_{y}$ into specific basis,"<p>How can I decompose gate <span class=""math-container"">$R_{y}(\theta)$</span> into gate <span class=""math-container"">$R_{x}(\alpha)$</span> and gate <span class=""math-container"">$R_{z}(\beta)$</span>. And how to perform it on Qiskit, is there any function to do it.</p>
",<programming><qiskit><quantum-gate>,5/29/2021 8:57,17706.0,17706.0,"<p>Qiskit supports translating to different continuous basis sets by specifying the <code>basis_gates</code> in the <code>transpile</code> method. So in your case you could just do</p>
<pre><code>&gt;&gt;&gt; from qiskit import QuantumCircuit, transpile
&gt;&gt;&gt; from qiskit.circuit import Parameter
&gt;&gt;&gt; circuit = QuantumCircuit(1)
&gt;&gt;&gt; circuit.ry(Parameter('theta'), 0)
&gt;&gt;&gt; rxrz_basis = transpile(circuit, basis_gates=['rx', 'rz'])
&gt;&gt;&gt; rxrz_basis.draw()
     âââââââââââââââââââââââââââââââââââââââââââââââââ
q_0: â¤ RX(Ï/2) ââ¤ RZ(theta + Ï) ââ¤ RX(Ï/2) ââ¤ RZ(3Ï) â
     âââââââââââââââââââââââââââââââââââââââââââââââââ

</code></pre>
<p>So you see that
<span class=""math-container"">$$
R_Y(\theta) = R_Z(\pi) R_X\left(\frac{\pi}{2}\right) R_Z(\theta + \pi) R_X\left(\frac{\pi}{2}\right) 
$$</span>
where I replaced the <span class=""math-container"">$3\pi$</span> by <span class=""math-container"">$\pi$</span> in the last RZ rotation since the operation is mod <span class=""math-container"">$2\pi$</span>.</p>
",5/29/2021 9:26,Theoretical," The user is asking about the theoretical concepts and principles of quantum computing, specifically how to decompose the Ry gate into Rx and Rz gates. ",Theoretical,,,,Theoretical,
17729.0,How to map an arbitrary Fermionic operator to Spins (Qubits)?,"<p>There are several Tutorials from Qiskit demonstrating the use of PySCF driver. Usually, it takes as input the geometric structure of the molecule -&gt; second quantised-operators -&gt; JW or Parity mapping -&gt; VQE.</p>
<p>However, I do not want to input a molecule but other Fermionic based operators, e.g. Fermi-Hubbard model. How do I do that?</p>
",<programming><qiskit>,5/30/2021 14:25,17732.0,17732.0,"<p>You can do this through <code>FermionicOperator</code>, it is Deprecated in the newer update of qiskit though so you will get warning about this issue.</p>
<p>Here is an example, I just made up some random second-quantized fermionic one-body operator (h1) to demonstrate how this works under the parity mapping:</p>
<pre><code>b = np.random.rand(2,2)
one_body_operator = (b + b.T)/2
ferOp = FermionicOperator(h1=one_body_operator )
qubitOp = ferOp.mapping(map_type='parity' , threshold=0.00000001)
print( qubitOp.print_details() )

</code></pre>
<p>which gives you the qubits representation:</p>
<pre><code>II  (0.4098900912867185+0j)
IZ  (-0.23235537601756617+0j)
ZX  (-0.12228344289218121+0j)
IX  (0.12228344289218121+0j)
ZZ  (-0.17753471526915232+0j)

</code></pre>
<p>If you want to use Jordan-Wigner, then specify <code>map_type = 'jordan_wigner' </code>. Similarly,   <code>map_type = 'bravyi_kitaev'  </code> for Bravyi Kitaev mapping.</p>
<p>Here is the <a href=""https://qiskit.org/documentation/_modules/qiskit/chemistry/fermionic_operator.html#FermionicOperator"" rel=""nofollow noreferrer"">link to Qiskit Ferminonic operator</a> for more details.</p>
",5/30/2021 15:52, Tooling ,"The user is asking about how to use a specific function (FermiHubbardModel) in a quantum programming library (Qiskit) to define other Fermionic based operators, which falls under the usage of tools and software in quantum programming",Tooling,,,, Tooling ,
17735.0,(solved(?)) Quantum circuit in a loop increasing qubit ids throughout despite attempts to reset,"<p>I have a parameterized circuit attempting to classify a set of features for various samples. I need to reencode the features per sample, but through the epochs, the computations slow down considerably and after some time, the code throws a mostly nonsensical error regarding the existance of a '1' state on the measured bit. I think the circuit is maintained between runs and that the qubits somehow keep getting added to the circuit. I'd like a clean circuit for each sample, but despite adding an explicit <code>del</code> statement to the circuit, the issue remains.</p>
<p>The code for creating the circle:</p>
<pre><code>def modelCircuit(self, printC=False):#, backend='qasm_simulator', shots=1000):
    &quot;&quot;&quot;
    Set up and run the model with the predefined encoders and ansatzes for the circuit. 
    &quot;&quot;&quot;

    self.quantum_register = qk.QuantumRegister(self.n_quantum)
    self.classical_register = qk.ClassicalRegister(self.n_classic)
    self.circuit = qk.QuantumCircuit(self.quantum_register, self.classical_register)


    self.model()

    job = qk.execute(self.circuit,
                    backend=qk.Aer.get_backend(self.backend),
                    shots=self.shots,
                    seed_simulator=self.seed
                    )
    results = job.result().get_counts(self.circuit)
    self.model_prediction = results['1'] / float(self.shots)

    if printC: 
        print(self.circuit)
    del(self.circuit)

    return self.model_prediction
</code></pre>
<p>where the <code>self.model()</code> is among a set of implemented models. the current one is:</p>
<pre><code>def basicModel(self):
    &quot;&quot;&quot;
    scaling with pi to avoid mapping 0 and 1 to the same rotation.
    &quot;&quot;&quot;
    for i, feature in enumerate(self.feature_vector):
        #self.circuit.ry(np.pi*feature, self.quantum_register[i])
        self.circuit.rx(np.pi*feature, self.quantum_register[i])
        self.circuit.ry(self.theta[i], self.quantum_register[i])

    for qubit in range(self.n_quantum - 1):
        self.circuit.cx(self.quantum_register[qubit], self.quantum_register[qubit + 1])

    self.circuit.ry(self.theta[-1], self.quantum_register[-1])
    self.circuit.measure(self.quantum_register[-1], self.classical_register)
</code></pre>
<p>The output of the printed circuits are as follows. Note the increasing id's on the qubits.</p>
<pre><code>      âââââââââââââââ ââââââââââââââ
q0_0: â¤ RX(0.93084) âââ¤ RY(3.8075) ââââ âââââââââââââââââââââââââââââ
      âââ¬âââââââââââ¬â ââââââââââââââ¤âââ´ââ
q0_1: âââ¤ RX(5Ï/8) ââââ¤ RY(4.6079) ââ¤ X ââââ ââââââââââââââââââââââââ
       ââ´âââââââââââ´âââ´âââââââââââââ¤ââââââââ´ââ
q0_2: ââ¤ RX(0.3065) ââ¤ RY(0.87303) âââââââ¤ X ââââ âââââââââââââââââââ
       ââ¬âââââââââââ¬âââ¬âââââââââââââ¤     ââââââââ´âââââââââââââââââââ
q0_3: âââ¤ RX(Ï/17) ââââ¤ RY(1.9646) ââââââââââââ¤ X ââ¤ RY(4.1605) ââ¤Mâ
        ââââââââââââ  ââââââââââââââ          âââââââââââââââââââââ¥â
c0: 1/âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
                                                                  0
  0%|                                                                                                                                             | 0/100 [00:00&lt;?, ?it/s]      âââââââââââââââ ââââââââââââââ
q7_0: â¤ RX(0.93084) âââ¤ RY(3.8075) ââââ âââââââââââââââââââââââââââââ
      âââ¬âââââââââââ¬â ââââââââââââââ¤âââ´ââ
q7_1: âââ¤ RX(5Ï/8) ââââ¤ RY(4.6079) ââ¤ X ââââ ââââââââââââââââââââââââ
       ââ´âââââââââââ´âââ´âââââââââââââ¤ââââââââ´ââ
q7_2: ââ¤ RX(0.3065) ââ¤ RY(0.87303) âââââââ¤ X ââââ âââââââââââââââââââ
       ââ¬âââââââââââ¬âââ¬âââââââââââââ¤     ââââââââ´âââââââââââââââââââ
q7_3: âââ¤ RX(Ï/17) ââââ¤ RY(1.9646) ââââââââââââ¤ X ââ¤ RY(4.1605) ââ¤Mâ
        ââââââââââââ  ââââââââââââââ          âââââââââââââââââââââ¥â
c1: 1/âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
                                                                  0
  1%|ââ                                                                                                                                   | 1/100 [00:00&lt;00:27,  3.58it/s]         ââââââââââââ  ââââââââââââââ
q140_0: ââ¤ RX(2Ï/9) ââââ¤ RY(3.8075) ââââ âââââââââââââââââââââââââââââ
        ââ´âââââââââââ¤  ââââââââââââââ¤âââ´ââ
q140_1: â¤ RX(5Ï/12) ââââ¤ RY(4.6079) ââ¤ X ââââ ââââââââââââââââââââââââ
        âââââââââââââ´âââ´âââââââââââââ¤ââââââââ´ââ
q140_2: â¤ RX(0.3065) ââ¤ RY(0.87303) âââââââ¤ X ââââ âââââââââââââââââââ
        ââ¬âââââââââââ¬âââ¬âââââââââââââ¤     ââââââââ´âââââââââââââââââââ
q140_3: ââ¤ RX(Ï/17) ââââ¤ RY(1.9646) ââââââââââââ¤ X ââ¤ RY(4.1605) ââ¤Mâ
         ââââââââââââ  ââââââââââââââ          âââââââââââââââââââââ¥â
 c20: 1/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
                                                                   0
  2%|âââ                                                                                                                                  | 2/100 [00:00&lt;00:27,  3.61it/s]        âââââââââââââââ ââââââââââââââ
q273_0: â¤ RX(0.46542) âââ¤ RY(3.8075) ââââ âââââââââââââââââââââââââââââ
        âââ¬ââââââââââ¬ââ ââââââââââââââ¤âââ´ââ
q273_1: âââ¤ RX(Ï/2) âââââ¤ RY(4.6079) ââ¤ X ââââ ââââââââââââââââââââââââ
        âââ´ââââââââââ´ââââ´âââââââââââââ¤ââââââââ´ââ
q273_2: â¤ RX(0.22987) ââ¤ RY(0.87303) âââââââ¤ X ââââ âââââââââââââââââââ
        âââ¬âââââââââââ¬âââ¬âââââââââââââ¤     ââââââââ´âââââââââââââââââââ
q273_3: âââ¤ RX(Ï/17) ââââ¤ RY(1.9646) ââââââââââââ¤ X ââ¤ RY(4.1605) ââ¤Mâ
          ââââââââââââ  ââââââââââââââ          âââââââââââââââââââââ¥â
 c39: 1/âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
                                                                    0
</code></pre>
<p>If anyone knows how I can just reset the circuit and keep the qubits to 4 through the simulations, I'd appreciate it.</p>
<p>Edit:
attempt at clarifying slow down. Some efforts to try and solve the issue as well as the error taking ~10 hrs to manifest makes finding the error difficult, but the rate of iterations starts at
<code>4.84it/s</code> at the first epoch, with abt. 100 iterations per epoch to
<code>2.89s/it</code> at the 20th. -&gt; roughly 20s on the 1st epoch to ~300 seconds at the 20th, with more slowdown the further you go</p>
<p>the error persists between instantiation of the class as well, something noticed when reducing the number of epochs to run from 100 to 20 in order to try to get some data to work on.</p>
<p>Edit2:
We were in talks with TA's regarding the issue, and they suggested naming the registers when initializing them. This sped up the process somewhat.
The error thrown was likely a result of the job section, where the output relied on the ratio of '1' outcomes. adding an if test for this solved the error, though not the increase in computation time.</p>
<p>About an hour or so after the conversation, a partner found the code working fine on their windows laptop. mine is still slow on linux. I'll probably try to work out the issue through the week.</p>
<p>Edit3:
I've revised the code on my end with removing the registers when creating the circuit. The code starts out quite a bit faster, but the performance deteriorates still. the new functions:</p>
<pre><code>    def encoder(self):
        &quot;&quot;&quot;
        mapping features scaled to 1 onto bloch sphere.
        scaling with pi to avoid mapping 0 and 1 to the same rotation.
        &quot;&quot;&quot;
        for i, feature in enumerate(self.feature_vector):
            self.circuit.rx(np.pi*feature, i)

        for qubit in range(self.n_quantum - 1):
            self.circuit.cx(qubit, qubit + 1)

    def ansatz(self, iteration=0):
        &quot;&quot;&quot;
        Rotating qubit states by parameters theta around bloch sphere
        to adjust model for prediction of encoded features
        &quot;&quot;&quot;
        for i in range(self.n_quantum):
            self.circuit.ry(self.theta[iteration*self.n_quantum +i], i)

        for qubit in range(self.n_quantum - 1):
            self.circuit.cx(qubit, qubit + 1)

    def measure(self):
        &quot;&quot;&quot;
        measuring the final qubit after applying the final model 
        parameter as a bias
        &quot;&quot;&quot;
        self.circuit.ry(self.theta[-1], -1)
        self.circuit.measure(-1, 0)


    def basicModel(self):
        self.encoder()
        self.ansatz()
        self.measure()
</code></pre>
<p>for creating the model. the <code>basicModel</code> function is set as <code>self.model</code> during the initialization. Next comes</p>
<pre><code>    def modelCircuit(self, printC=False):#, backend='qasm_simulator', shots=1000):
        &quot;&quot;&quot;
        Set up and run the model with the predefined encoders and ansatzes for the circuit.
        &quot;&quot;&quot;

        self.circuit = qk.QuantumCircuit(self.n_quantum, self.n_classic)

        self.model()

        job = qk.execute(self.circuit,
                        backend=qk.Aer.get_backend(self.backend),
                        shots=self.shots,
                        seed_simulator=self.seed
                        )

        results = job.result().get_counts(self.circuit)

        counts = 0
        for key, value in results.items():
            if key=='1':
                counts += value

        self.model_prediction = counts / float(self.shots)
        return self.model_prediction
</code></pre>
<p>the <code>modelCircuit</code> is called int the <code>train</code> function</p>
<pre><code>    def train(self, target, epochs=100, learning_rate=.1, debug=False):
        &quot;&quot;&quot;
        Uses the initial quess for an ansatz for the model to train and optimise the model ansatz for
        the given cost/loss function.
        &quot;&quot;&quot;
        from tqdm import tqdm

        mean_loss = np.zeros(epochs)
        accuracy = np.zeros_like(mean_loss)

        for epoch in range(epochs):

            #   setup of storage arrays
            thetaShift = np.zeros([self.n_samples,len(self.theta)])
            loss = np.ones(self.n_samples)
            lossDerivative = np.zeros_like(loss)
            acc = 0

            for sample in tqdm(range(self.n_samples)):

                #self.feature_vector = self.featureMatrix.iloc[sample]
                self.feature_vector = self.featureMatrix[sample, :]

                out = self.modelCircuit()
                acc += np.round(out)==target[sample]


                loss[sample] = self.lossFunction(out, target[sample])
                lossDerivative[sample] = self.lossDerivative(out, target[sample])

                theta_gradient = np.zeros_like(self.theta)

                for i in range(self.n_model_parameters):

                    self.theta[i] += np.pi / 2
                    out_1 = self.modelCircuit()

                    self.theta[i] -= np.pi
                    out_2 = self.modelCircuit()

                    self.theta[i] += np.pi / 2
                    theta_gradient[i] = (out_1 - out_2) / 2

                    if debug:
                        print(f'output 1: {out_1}')
                        print(f'output 2: {out_2}')

                    #thetaShift[sample, i] = - learning_rate * theta_gradient * np.mean(lossDerivative) # theta gradient for vairable shift.
                    thetaShift[sample, i] = theta_gradient[i]

            accuracy[epoch] = float(acc)/self.n_samples
            mean_loss[epoch] = np.mean(loss)

            self.theta -= learning_rate * np.mean((thetaShift *  lossDerivative.reshape(-1,1)), axis=0)

            print(&quot;mean loss per epoch: &quot;, mean_loss[epoch])
            print(&quot;accuracy per epoch: &quot;, accuracy[epoch])
        return self.theta, mean_loss, accuracy
</code></pre>
<p>printouts for the base model to terminal:</p>
<pre><code>     âââââââââââââââ     ââââââââââââââ
q_0: â¤ RX(0.93084) ââââ âââ¤ RY(2.3533) ââââââââââââââââââââââ ââââââââââââââââââââââââââââââââââ
     âââ¬âââââââââââ¬ââââ´ââââââââââââââââââââââââââââââ    âââ´ââ
q_1: âââ¤ RX(5Ï/8) âââ¤ X ââââââââ ââââââââ¤ RY(5.9735) ââââââ¤ X âââââââââ ââââââââââââââââââââââââ
      ââ´âââââââââââ´ââââââ    âââ´ââ     âââââââââââââââââââ´ââââ´ââââââââ´ââ
q_2: ââ¤ RX(0.3065) âââââââââââ¤ X âââââââââââââ ââââââââ¤ RY(4.5993) ââ¤ X ââââ âââââââââââââââââââ
      ââ¬âââââââââââ¬â         âââââ         âââ´ââ     ââââââââââââââ¤ââââââââ´âââââââââââââââââââ
q_3: âââ¤ RX(Ï/17) ââââââââââââââââââââââââââ¤ X âââââââ¤ RY(3.7615) âââââââ¤ X ââ¤ RY(3.7769) ââ¤Mâ
       ââââââââââââ                        âââââ     ââââââââââââââ     âââââââââââââââââââââ¥â
c: 1/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©â
                                                                                            0
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:13&lt;00:00,  7.28it/s]
mean loss per epoch:  0.6493203309690068
accuracy per epoch:  0.78
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:27&lt;00:00,  3.59it/s] 
mean loss per epoch:  0.6415613508592234
accuracy per epoch:  0.8
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:42&lt;00:00,  2.38it/s] 
mean loss per epoch:  0.6337758611894215
accuracy per epoch:  0.8
</code></pre>
<p>over a few epochs. more directly, the iterations per second are
<code>7.28it/s 3.59it/s 2.38it/s</code></p>
<p>Edit 4:
I tested yesterday with the results as above. Today I wanted to check for memory leaks with the suggested <code>tracemalloc</code>.</p>
<p>The program runs fine now. I don't know what happened, but I did do a system update and follow the recomendation bellow in regards to removing the registers. I made no further changes than those in the example above. The issue seems fixed, but I don't know why.</p>
",<programming><qiskit>,5/30/2021 22:51,17743.0,17743.0,"<p>I would have written the thing differently. Something like this:</p>
<pre><code>def modelCircuit(self, printC=False):#, backend='qasm_simulator', shots=1000):
    circuit = self.model()
    ....

def basicModel(self):
    circuit = qk.QuantumCircuit(self.n_quantum, self.n_classic)
    for i, feature in enumerate(self.feature_vector):
        circuit.rx(np.pi*feature, i)
        circuit.ry(self.theta[i], i)
    ...
</code></pre>
<p>In this way, the garbage collector will get rid of <code>circuit</code> when closing <code>modelCircuit</code> scope. It could be some memory leak.</p>
<p>If the problem persist, I would try to find the dangling pointer with <a href=""https://docs.python.org/3/library/tracemalloc.html"" rel=""nofollow noreferrer"">tracemalloc</a> or <a href=""https://github.com/zhuyifei1999/guppy3/"" rel=""nofollow noreferrer"">guppy3</a>.</p>
<p>Additionally, you seem like having a lot of code for dealing with registers that you don't need. Qiskit can <a href=""https://quantumcomputing.stackexchange.com/questions/16218/is-it-better-to-initialize-quantum-circuits-in-qiskit-by-passing-quantumregister"">handle registerless circuits</a>.</p>
",5/31/2021 13:49,Errors, The user was encountering an error related to quantum circuit execution and was seeking assistance in resolving it.,Errors ,,,,Errors,
17736.0,How can I specify the qubits on quantum computers that I want to use?,"<p>Suppose I have the following 2-qubit quantum circuit:</p>
<pre><code>qrz = QuantumRegister(2,'q')
crz = ClassicalRegister(3,'c')
qc = QuantumCircuit(qrz,crz)
qc.rx(np.pi/3,0)
qc.cry(np.pi/2,0,1)
</code></pre>
<p>I want to run this circuit on a real quantum computer, depending on the real-time error rate, I might want to use different qubits on the hardware. For example, suppose here's the calibration data of my <code>backend</code>:</p>
<p><a href=""https://i.stack.imgur.com/ZCgIy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZCgIy.png"" alt=""enter image description here"" /></a></p>
<p>Is there a way I can specify that I want to use qubit 4 and 5 on this quantum computer? I tried to generate a quantum circuit with 6 qubits and append my quantum circuit to qubit 4 and 5, then run the entire circuit on that quantum computer. Is there a simpler way I can do that without generating another large circuit? Thanks!</p>
",<programming><ibm-q-experience><simulation>,5/31/2021 1:53,17737.0,17737.0,"<p>Why not just use <code>initial_layout</code> method?</p>
<p>For instance,</p>
<pre><code>from qiskit import IBMQ, QuantumCircuit
from qiskit.aqua import QuantumInstance
circuit = QuantumCircuit(2,2)
circuit.h(0)
circuit.x(1)
quantum_instance = QuantumInstance(backend= provider.get_backend('ibmq_santiago'),
                                   shots = 8192,
                                   initial_layout = [3,4],
                                   optimization_level = 3)
results = quantum_instance.execute(circuit)
</code></pre>
<p>If you go and look at the circuit that being executed, you will see that it uses qubit 3 and 4 of the device:</p>
<p><a href=""https://i.stack.imgur.com/yyxEi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yyxEi.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>If you don't to use <code>quantum_instance</code> but instead you want to use <code>execute</code> class directly, then you can  just specify the <code>initial_layout</code> method in <code>execute</code>. For example:</p>
<pre><code>result = execute(circuit, backend=provider.get_backend('ibmq_santiago'),
 initial_layout = [3,4], shots= 1000)
</code></pre>
<p>This will also make sure qubit 3 and 4 of the hardware are use when you execute your circuit.</p>
",5/31/2021 2:46,Tooling ," The user is asking about how to specify the use of certain qubits on a quantum computer when running a quantum circuit using Qiskit, which falls under the usage of tools and software in quantum programming.",Tooling ,,,,Tooling ,
17751.0,Are circuits with more than 1000 gates common?,"<p>I have seen circuits with 30 qubits and around 500 gates. Also circuits with 32 qubits and 6000 gates. Are circuits with more than 1000 gates common in quantum computing? Are there many quantum algorithms that require more than 1000 gates? How common are they?</p>
",<quantum-gate><classical-computing>,5/31/2021 21:01,17752.0,17752.0,"<p>I'd say it's far more common for quantum algorithms to use billions of gates than thousands. And that's assuming you're ignoring Clifford gates as well as error correction overhead! If you want to count those, add in another factor of a million.</p>
<p>For example...</p>
<p>According to Table III of <a href=""https://arxiv.org/abs/2011.03494"" rel=""noreferrer"">https://arxiv.org/abs/2011.03494</a> , quantum chemistry algorithms looking at properties of the FeMoCo molecule use half a billion Toffoli gates.</p>
<p><a href=""https://i.stack.imgur.com/PZcMz.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/PZcMz.png"" alt=""enter image description here"" /></a></p>
<p>According to Table 1 of <a href=""https://arxiv.org/abs/1905.09749"" rel=""noreferrer"">https://arxiv.org/abs/1905.09749</a> , factoring 2048 bit numbers takes 3 billion Toffoli gates:</p>
<p><a href=""https://i.stack.imgur.com/qymty.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/qymty.png"" alt=""enter image description here"" /></a></p>
<p>According to Table 1 of <a href=""https://arxiv.org/abs/2001.09580"" rel=""noreferrer"">https://arxiv.org/abs/2001.09580</a> , 256 bit elliptic curve discrete logarithms take a few billion T gates:</p>
<p><a href=""https://i.stack.imgur.com/ZJwJC.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/ZJwJC.png"" alt=""enter image description here"" /></a></p>
",5/31/2021 21:14, Conceptual,"The user is seeking conceptual information about the prevalence of quantum circuits with a high number of gates in quantum computing, as well as the frequency with which quantum algorithms require such large circuits.",Conceptual,,,, Conceptual,
17768.0,Qiskit: Get approximate execution time,"<p>The IBMQ web interface shows both queue position and an approximate execution time for every pending job (see image below). Is there a way to retrieve this information via Qiskit? I know that <code>qiskit.providers.ibmq.job.IBMQJob</code> has a <code>queue_position()</code> method, but what about the approximate execution time?</p>
<p>Thanks in advance!</p>
<p><a href=""https://i.stack.imgur.com/JoO2s.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JoO2s.png"" alt=""IBMQ Job table"" /></a></p>
",<qiskit><programming>,06/01/2021 14:01,17772.0,17772.0,"<p>If you're looking for the actual time spent on the device, <code>time_taken</code> mentioned by @KAJ226b is the right attribute.</p>
<p>If you're looking for the estimated job completion time, you can use the <code>queue_info()</code> method of <code>IBMQJob</code>. It gives you the estimated start/completion time, job priority, and queue position (if available).</p>
",06/01/2021 15:20,API Usage," The user is inquiring about the capabilities of the Qiskit library and how to retrieve specific information related to job execution, which falls under the category of API usage and interfacing with quantum computing providers like IBMQ.",API Usage,,,,API Usage,
17847.0,quantum label classification using qiskit,"<p>I am generating points for classification. Some will be above the main diagonal, while others will be below (blue or red).</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
import random

m, b = 1, 0

lower, upper = -40, 40
num_points = 80
x1 = [random.randrange(start=-40, stop=40) for i in range(num_points)]
x2 = [random.randrange(start=-40, stop=40) for i in range(num_points)]

y1 = [random.randrange(start=lower, stop=m*x+b) for x in x1]
y2 = [random.randrange(start=m*x+b, stop=upper) for x in x2]


plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.scatter(x1, y1, c='red')
plt.scatter(x2, y2, c='blue')
plt.show()

x1, x2, y1, y2 = np.array(x1).reshape(-1,1), np.array(x2).reshape(-1,1), np.array(y1).reshape(-1,1), np.array(y2).reshape(-1,1)

x_upper = np.concatenate((x2, y2), axis=1)
x_lower = np.concatenate((x1, y1), axis=1)

X = np.concatenate((x_upper, x_lower), axis=0)

res1 = np.array([-1]*len(x1))
res2 = np.array([1]*len(x2))

y = np.concatenate((res1, res2), axis=0)
</code></pre>
<p>Next, I split the data into a training and test dataset.</p>
<pre><code>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
</code></pre>
<p>The next step is to apply the quantum classification algorithm to all test points, in which I calculate the value for the first qubit. With respect to this result, I label the test points. I get the following:</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import Aer
from qiskit import execute
import numpy as np
%matplotlib inline
backend_sim = Aer.get_backend('qasm_simulator')

def quant_state(x1, x2, backend_sim = backend_sim):
    x1 = x1
    x2  = x2
    r = x1 * x1 + x2 * x2
    a = np.sqrt(1 + 2*r)
    psi = [0, 0, 0.5, 0, 0, -0.5, 0, 0, 1/(np.sqrt(2)*a), 0, x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), 0, 0]
    qc = QuantumCircuit(4)
    qc.initialize(psi, [0,1,2,3])
    qc.h(0)
    qc.measure_all()
    job_sim = execute(qc, backend_sim, shots=1000)
    result_sim = job_sim.result()
    counts = result_sim.get_counts(qc)

    quantumState_1 = 0
    for i in counts.keys():
        list_i = list(i)
        if list_i[len(list_i) - 1] == '1':
            quantumState_1 += counts[i]

    return quantumState_1

quant_res = []

for i,j in zip(X_test[:, 0], X_test[:, 1]):
    qs = quant_state(i, j, backend_sim = backend_sim)
    if qs &gt;= 500:
        quant_res.append(1)
    else:
        quant_res.append(-1)

def get_color(y,zn):
    colors = []

    for i in range(len(y)):
        if y[i] == zn:
            colors.append('red')
        else:
            colors.append('blue')

    return(colors)

quantColors = get_color(quant_res, 1)
plt.scatter(X_train[:, 0], X_train[:, 1], c = colors)
plt.scatter(X_test[:, 0], X_test[:, 1], c = quantColors, marker = &quot;x&quot;)
plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.show()
</code></pre>
<p>In the end I get this result:</p>
<pre><code>from sklearn.metrics import f1_score
f1_score(y_test, quant_res)
</code></pre>
<p>0.2162162162162162</p>
<p><a href=""https://i.stack.imgur.com/9ERzL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9ERzL.png"" alt=""results"" /></a></p>
<p>where the crosses are predicted results.
Can someone explain, why this classification is working wrong?</p>
",<programming><qiskit><quantum-state>,06/06/2021 14:58,17851.0,17851.0,"<p>Let us consider the state you are creating. Since there is no mention to the training dataset in your code, I'm assuming that you somehow got this state from previous knowledge. We have:</p>
<pre><code>psi = [0, 0, 0.5, 0, 0, -0.5, 0, 0, 1/(np.sqrt(2)*a), 0, x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), 0, 0]
</code></pre>
<p>which gives us:
<span class=""math-container"">$$|\psi\rangle = \frac12|0010\rangle-\frac12|0101\rangle+\frac{1}{a\sqrt{2}}|1000\rangle+\frac{x_1}{a\sqrt{2}}|1010\rangle+\frac{x_2}{a\sqrt{2}}|1011\rangle+\frac{x_1}{a\sqrt{2}}|1100\rangle+\frac{x_2}{a\sqrt{2}}|1101\rangle$$</span>
We then apply an <span class=""math-container"">$\mathbf{H}$</span> gate on this state, which gives us:
<span class=""math-container"">$$\mathbf{H}|\psi\rangle=\frac{1}{2\sqrt{2}}\left(|0010\rangle+|1010\rangle\right) - \frac{1}{2\sqrt{2}}\left(|0101\rangle+|1101\rangle\right)+\frac{1}{2a}\left(|0000\rangle-|1000\rangle\right)+\frac{x_1}{2a}\left(|0010\rangle-|1010\right)+\frac{x_2}{2a}\left(|0011\rangle-|1011\rangle\right)+\frac{x_1}{2a}\left(|0100\rangle-|1100\rangle\right)+\frac{x_2}{2a}\left(|0101\rangle-|1101\rangle\right)$$</span>
which can finally be reduced to:
<span class=""math-container"">$$\mathbf{H}|\psi\rangle=\frac{1}{2a}|0000\rangle+\left(\frac{1}{2\sqrt{2}}+\frac{x_1}{2a}\right)|0010\rangle+\frac{x_2}{2a}|0011\rangle+\frac{x_1}{2a}|0100\rangle+\left(\frac{x_2}{2a}-\frac{1}{2\sqrt{2}}\right)|0101\rangle - \frac{1}{2a}|1000\rangle+\left(\frac{1}{2\sqrt{2}}-\frac{x_1}{2a}\right)|1010\rangle-\frac{x_2}{2a}|1011\rangle-\frac{x_1}{2a}|1100\rangle-\left(\frac{x_2}{2a}+\frac{1}{2\sqrt{2}}\right)|1101\rangle$$</span>
This can finally be used to compute the probability of measuring <span class=""math-container"">$|0\rangle$</span> on the first qubit and <span class=""math-container"">$|1\rangle$</span> on the first qubit. Let us denote <span class=""math-container"">$p_0$</span> and <span class=""math-container"">$p_1$</span> these probabilities. We have:
<span class=""math-container"">$$p_0-p_1=\frac{x_1-x_2}{a\sqrt{2}}$$</span>
In particular, <span class=""math-container"">$p_0$</span> is greater than <span class=""math-container"">$p_1$</span> iff <span class=""math-container"">$x_1$</span> is greater than <span class=""math-container"">$x_2$</span>, which is logical, since this directly comes from the fact that your data has been generated around the curve <span class=""math-container"">$y=x$</span>. According to your code, a point <span class=""math-container"">$(x,y)$</span> will have label <span class=""math-container"">$1$</span> iff <span class=""math-container"">$x&gt;y$</span>, so if we measure <span class=""math-container"">$0$</span> on the first qubit.</p>
<p>So now that we know that your method is expected to give the right results, why does it not?</p>
<p>While <code>qiskit</code> uses a quite non-traditional method to index qubits, that is little-endian, it is consistent throughout its code. So, for instance, if you were to initialize <code>psi</code> like this:</p>
<pre><code>psi = np.zeros(16, dtype=float)
psi[5] = 1
</code></pre>
<p>What you tell qiskit is &quot;Create a state whose amplitude in basis state <span class=""math-container"">$|1010\rangle$</span> is <span class=""math-container"">$1$</span>&quot;. If you immediately measure this state, you will get, without surprise, <span class=""math-container"">$1010$</span> with probability <span class=""math-container"">$1$</span>. Now, if you were to apply an <span class=""math-container"">$\mathbf{H}$</span> gate on the first qubit like this:</p>
<pre><code>qc.h(0)
</code></pre>
<p>then you would measure states <span class=""math-container"">$|0100\rangle$</span> and <span class=""math-container"">$|0101\rangle$</span>, each with probability <span class=""math-container"">$\frac12$</span>. Notice that compared to what we could have expected, the <span class=""math-container"">$\mathbf{H}$</span> gate actually was applied to the last qubit. This is due to the fact that in <code>qiskit</code>, <code>qc.h(0)</code> means &quot;Apply an <span class=""math-container"">$\mathbf{H}$</span> gate on the first wire&quot;, but the first wire is the one which gives, once measured, the last qubit.</p>
<p>So, coming back on your case, the problem is that you have to apply the <span class=""math-container"">$\mathbf{H}$</span> gate to what will give the first qubit, that is the third wire:</p>
<pre><code>qc.h(3)
</code></pre>
<p>And when counting the states you obtained, you are interested by the first qubit. So you have to replace:</p>
<pre><code>if list_i[len(list_i) - 1] == '1':
</code></pre>
<p>by:</p>
<pre><code>if list_i[0] == '1':
</code></pre>
<p>By doing so (and by adding the missing line <code>colors = get_color(y_train, 1)</code>), here's the result I got:
<a href=""https://i.stack.imgur.com/BICbL.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/BICbL.png"" alt=""Inverted results"" /></a>
You can see that the model is behaving at the exact opposite of what we want him to. Hence, you just have to change this line:</p>
<pre><code>if list_i[0] == '1':
</code></pre>
<p>to:</p>
<pre><code>if list_i[0] == '0':
</code></pre>
<p>to finally get the result you want. This last change is due to the fact that <span class=""math-container"">$p_0$</span> is bigger than <span class=""math-container"">$p_1$</span> if <span class=""math-container"">$x_1&gt;x_2$</span>, that is if <span class=""math-container"">$\left(x_1,x_2\right)$</span> is below the diagonal, to which you affected the label 1. By doing this final modification, here's the result I got:
<a href=""https://i.stack.imgur.com/K2FS1.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/K2FS1.png"" alt=""Correct result"" /></a></p>
<p>As a side note, you may want to directly use the <a href=""https://qiskit.org/documentation/tutorials/machine_learning/01_qsvm_classification.html"" rel=""noreferrer""><code>qiskit</code> QVSM algorithm</a> to perform such a task next time.</p>
",06/06/2021 23:19,Errors,"The user is encountering an issue with a quantum classification algorithm that is not working as expected, which falls under seeking solutions for errors and exceptions in quantum program development",Errors,,,,Errors,
17852.0,Use one_body_integrals to know which orbitals to freeze in ElectronicStructureProblem,"<p>In exercise 5 of the this year's IBM Quantum Challenge, you need to use the <code>FreezeCoreTransformer</code> (along <code>two_qubit_reduction</code> and <code>z2symmetry_reduction</code>) to reduce the number of qubits to 4 and achieve a cost of 3. I managed to figure out that the optimal array to pass to the <code>remove_orbitals</code> parameter was <code>[3,4]</code>; however, I did this by experimenting with different arrays.</p>
<p>In the Qiskit slack, I saw that the one body integrals of the <code>QMolecule</code> are supposed to give you an insight on which orbitals to freeze. However, they didn't explain how to use it to figure this out.</p>
<p>The molecule and one body integrals I am working with is the following.</p>
<pre><code>molecule = 'Li 0.0 0.0 0.0; H 0.0 0.0 1.5474'
driver = PySCFDriver(atom=molecule)
qmolecule = driver.run()
Matrix(np.round(qmolecule.one_body_integrals, 10))
</code></pre>
<p><span class=""math-container"">$$
\displaystyle \left[\begin{array}{cccccccccccc}-4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\-0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042\end{array}\right]
$$</span></p>
<p>How am I supposed to interpret this matrix to know which orbitals to freeze?</p>
",<programming><qiskit><vqe><chemistry>,06/07/2021 02:25,17855.0,17855.0,"<p><a href=""https://www.youtube.com/watch?v=3B04KB0pDwE&amp;t=667s"" rel=""nofollow noreferrer"">Lab 8</a> explains exactly how to do this for <code>LiH</code></p>
<p>For more information, check out <a href=""https://qiskit.org/learn/intro-qc-qh/"" rel=""nofollow noreferrer"">Introduction to Quantum Computing and Quantum Hardware</a></p>
<p><strong>Lecture 22</strong>
<a href=""https://www.youtube.com/watch?v=2XEjrwWhr88"" rel=""nofollow noreferrer"">Quantum Chemistry I: Obtaining the Qubit Hamiltonian for H2 and LiH Part 1</a></p>
<p><strong>Lecture 23</strong>
<a href=""https://www.youtube.com/watch?v=DWOfMWPKHDU"" rel=""nofollow noreferrer"">Quantum Chemistry I: Obtaining the Qubit Hamiltonian for H2 and LiH Part 2</a></p>
",06/07/2021 09:20,Tooling," The user is asking about how to interpret the one body integrals of a QMolecule in Qiskit to determine which orbitals to freeze, which falls under the usage of tools and software in quantum programming",Conceptual,"The user is seeking an explanation of how to interpret a matrix of one-body integrals in the context of freezing orbitals in quantum chemistry. This question relates to the conceptual understanding of quantum chemistry calculations, particularly the interpretation of one-body integrals.",No,111.0, Conceptual,"The user is asking for an explanation of how to interpret a matrix of one-body integrals to determine which orbitals to freeze in quantum chemistry calculations. This question relates to the conceptual understanding of quantum chemistry, specifically the interpretation of one-body integrals."
17904.0,Qiskit: set_frequency workaround in PulseSimulator,"<p>I am trying to run exercise 4 from the recent IBM Quantum Challenge using a PulseSimulator since the device used in the challenge is not available for public use. A snippet of what I am trying to run is the following:</p>
<pre><code>from qiskit import pulse, IBMQ, assemble
from qiskit.pulse import Play, Schedule, DriveChannel, Gaussian, AcquireChannel
from qiskit.providers.aer import PulseSimulator
from qiskit.tools.monitor import job_monitor
import numpy as np

# Constants and units

job_params = {
    'meas_level': 1,
    'meas_return': 'avg',
    'shots': 512
}

spec_range = 0.300 # GHz
num_spec01_freqs = 71
GHz = 1.0e9 # Gigahertz

# Helper functions

def get_exc_chans(gv):
    return [AcquireChannel(i) for i in range(gv['backend_config'].n_qubits)]

def get_spec01_freqs(center_freqs, qubit):
    center_freq = round(center_freqs[qubit], -8) # 2 significant digits
    return np.linspace(center_freq/GHz - spec_range/2,
        center_freq/GHz + spec_range/2, num_spec01_freqs)

# Set up backend and config

provider = IBMQ.load_account()
backend_name = 'ibmq_armonk'
backend_real = provider.get_backend(backend_name)
backend = PulseSimulator.from_backend(backend_real)

qubit = 0

backend_config = backend.configuration()
exc_chans = get_exc_chans(globals())
dt = backend_config.dt

backend_defaults = backend.defaults()
center_frequency = backend_defaults.qubit_freq_est
inst_sched_map = backend_defaults.instruction_schedule_map 

# |0â© -&gt; |1â©  pulse

# Retrieve calibrated measurement pulse from backend
meas = inst_sched_map.get('measure', qubits=[qubit])

# The same spec pulse for both 01 and 12 spec
drive_amp = 0.25
drive_duration = inst_sched_map.get('x', qubits=[qubit]).duration

# Calibrated backend pulse use advanced DRAG pulse to reduce leakage to the |2&gt; state.
# Here we will use simple Gaussian pulse
drive_sigma = drive_duration // 4 # DRAG pulses typically 4*sigma long. 
spec_pulse = Gaussian(duration=drive_duration, amp=drive_amp, 
                        sigma=drive_sigma, name=f&quot;Spec drive amplitude = {drive_amp}&quot;)

# Construct an np array of the frequencies for our experiment
spec_freqs_GHz = get_spec01_freqs(center_frequency, qubit)

# Create the base schedule
# Start with drive pulse acting on the drive channel
spec01_scheds = []
for freq in spec_freqs_GHz:
    with pulse.build(name=&quot;Spec Pulse at %.3f GHz&quot; % freq) as spec01_sched:
        with pulse.align_sequential():
            # Pay close attention to this part to solve the problem at the end
            pulse.set_frequency(freq*GHz, DriveChannel(qubit))
            pulse.play(spec_pulse, DriveChannel(qubit))
            pulse.call(meas)
            
    spec01_scheds.append(spec01_sched)

qobj = assemble(spec01_scheds, backend=backend, **job_params)
spec01_job = backend.run(qobj)
job_monitor(spec01_job)
</code></pre>
<p>However, everytime I run this I get the following (not very helpful) error message:</p>
<pre><code>Job Status: job incurred error
</code></pre>
<p>I opened an issue about this in the Qiskit Aer GitHub repository (issue <a href=""https://github.com/Qiskit/qiskit-aer/issues/1264"" rel=""nofollow noreferrer"">#1264</a>) and got a response. They told me that &quot;the set/shift frequency instructions are not supported by the pulse simulator&quot;. And they suggested the following workaround:</p>
<blockquote>
<p>A way to bypass this issue as a user is to manually add an oscillation to the pulse envelopes. E.g. if the channel's LO frequency is <span class=""math-container"">$w$</span>, but you want to set it to <span class=""math-container"">$v$</span> for a given pulse (or pulses), convert the pulse to an explicit WaveForm specified in terms of a sample list, then multiply the sample array <span class=""math-container"">$exp(i(v-w)t)$</span>, where <span class=""math-container"">$t$</span> is the array of associated times. I may be missing some book keeping here but some version of this should work.</p>
</blockquote>
<p>As simple as this sounds, I don't quite understand how to do this. Can anyone explain to me, with code, how to do this? Or point me to somewhere where this is done?</p>
",<programming><qiskit>,06/10/2021 14:24,18065.0,18065.0,"<p>So, if you just want to create Pulse to go from ground state <span class=""math-container"">$|0\rangle$</span> to first excited state <span class=""math-container"">$|1\rangle$</span> for can do it with simulator by using a fake Armonk and following the tutorial : <a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html</a> and <a href=""https://qiskit.org/textbook/ch-quantum-hardware/accessing_higher_energy_states.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/accessing_higher_energy_states.html</a></p>
<p>but if you want to get the 2nd energy state <span class=""math-container"">$|2\rangle$</span> with a simulator you need to construct your own oscillator by using the dim_oscillator, the oscillator allow you to create noise in your system. The lib doc : <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.pulse.duffing_system_model.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.providers.aer.pulse.duffing_system_model.html</a> and here the textbook entry : <a href=""https://qiskit.org/textbook/ch-quantum-hardware/hamiltonian-tomography.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/hamiltonian-tomography.html</a></p>
<p>The think to know is the <span class=""math-container"">$|2\rangle$</span> is a singular property of transmon qubit and so can't be simulate with perfect qubit in other way than having noise or a physical like system.</p>
<p>Here some other tutorial explaining how to do get energies states from custom model <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/10_pulse_simulator_backend_model.html?highlight=oscillator"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/10_pulse_simulator_backend_model.html?highlight=oscillator</a> and <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/09_pulse_simulator_duffing_model.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/09_pulse_simulator_duffing_model.html</a></p>
<p>I'm absolutly not an expert at all so maybe this way isn't the best way to get to do it.</p>
<blockquote>
<p>As simple as this sounds, I don't quite understand how to do this.</p>
</blockquote>
<p>Oh and yes I didn't find it easy at all neither</p>
",6/21/2021 8:46, Errors,"The user is encountering an error while trying to run a quantum experiment using a PulseSimulator, and they are seeking help to understand and implement a workaround for the error, which falls under seeking solutions for errors and exceptions in quantum program development.", Errors,,,, Errors,
17916.0,What is the counting argument for the number of elementary operations required for a random function?,"<p>What is the counting argument for the following statement (classical)?</p>
<p>&quot;A random function on n bits requires <span class=""math-container"">$e^{\Omega(n)}$</span> elementary operations.&quot;</p>
<p>It appears in the introduction of PRL 116, 170502 (2016): <a href=""https://dspace.mit.edu/bitstream/handle/1721.1/115397/PhysRevLett.116.170502.pdf?sequence=1&amp;isAllowed=y"" rel=""nofollow noreferrer"">Efficient Quantum Pseudorandomness</a>.</p>
<p>Is it that since there are infinitely many n-bit boolean functions, implementing one such randomly chosen function using elementary operations would require an exponentially large number? (I'm assuming that elementary operations here mean two-bit universal gates.)</p>
<p>Also, why <span class=""math-container"">$\Omega(n)$</span> and not <span class=""math-container"">$O(n)$</span>?</p>
<p>Thanks in advance.</p>
",<complexity-theory><classical-computing><random-quantum-circuit>,06/11/2021 11:39,17921.0,17921.0,"<p>We say that a function <span class=""math-container"">$f(n)$</span> is <span class=""math-container"">$O(n)$</span> if its <em>bounded above</em> by <span class=""math-container"">$n$</span> asymptotically, which is not to be confused with a function <span class=""math-container"">$f(n)$</span> being <span class=""math-container"">$\Omega(n)$</span> which means that <span class=""math-container"">$f(n)$</span> is <em>bounded below</em> by <span class=""math-container"">$n$</span> asymptotically.</p>
<p>Also, there are <span class=""math-container"">$2^n$</span> boolean functions on <span class=""math-container"">$\{0,1\}^n$</span> since each boolean function <span class=""math-container"">$f:\{0,1\}^n\rightarrow \{0,1\}$</span> is in one-to-one correspondence with a subset <span class=""math-container"">$S$</span> of <span class=""math-container"">$\{1,2,\ldots,n\}$</span> via the identification <span class=""math-container"">$f^{-1}(1)=S$</span>.</p>
<p>So like you said in the comments <span class=""math-container"">$2^n=e^{\Omega(n)}$</span>.</p>
",06/11/2021 15:59,Theoretical,"The user is inquiring about a theoretical concept related to the counting argument mentioned in a research paper. They are seeking an explanation for why a random function on n bits would require a certain number of elementary operations and why it's represented as ""e^?(n)"" rather than ""O(n),"" which falls under inquiries about theoretical concepts, algorithms, and principles in quantum computing.",Theoretical,,,,Theoretical,
17950.0,ibmq_16_melbourne system of Qiskit giving wrong result for Bernstein-Vazirani Algorithm,"<p>I have just started learning Qiskit and to begin I tried running the Bernstein Vazirani Algorithm(secret number detector) on <code>qasm_simulator</code> and the <code>ibmq_16_melbourne</code> system and compared their results. My results on the Qasm simulator exactly matches the secret number, but I am getting wrong result on the real system.
Please review my codes, circuits and results below:</p>
<pre><code>import qiskit
from qiskit import IBMQ
import time
from qiskit import *
from qiskit.tools.visualization import plot_histogram
from qiskit.tools.visualization import plot_bloch_multivector
import matplotlib.pyplot as plt
from qiskit.tools.monitor import job_monitor
#IBMQ.save_account('Account key',overwrite=True)  #  Run it for once

# 6 bit secret number
secretNumber= '101001'

circuit= QuantumCircuit(6+1,6) # 6 qubit for secret no. +1 qubit
circuit. h([0,1,2,3,4,5])
circuit.x(6)
circuit.h(6)
circuit.barrier()

# splitting the string into char
splitSecretNumber= list(secretNumber)
lengthofSecretNumber= len(splitSecretNumber)

x=0
while(x&lt; lengthofSecretNumber):
    if(str(splitSecretNumber[x])=='1'):
        circuit.cx(int(x),6)
    x=x+1

circuit.barrier()
circuit.h([0,1,2,3,4,5])
circuit.barrier()
circuit.measure([0,1,2,3,4,5],[0,1,2,3,4,5])
circuit.draw(output=&quot;mpl&quot;)

simulator= Aer.get_backend('qasm_simulator')
simulationResult = execute(circuit,simulator, shots=1).result()
counts= simulationResult.get_counts()
print(counts)
plot_histogram(simulationResult.get_counts(circuit))
plt.show()
</code></pre>
<p><strong>The histogram and circuit obtained are for Qasm simulator are as below:</strong>
<a href=""https://i.stack.imgur.com/6nYH7.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6nYH7.jpg"" alt=""enter image description here"" /></a><br />
<a href=""https://i.stack.imgur.com/1bt7u.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1bt7u.jpg"" alt=""enter image description here"" /></a></p>
<p><strong>Python Code executed on ibmq_16_melbourne system using Pycharm IDE-</strong></p>
<pre><code>import qiskit
from qiskit import IBMQ
import time
from qiskit import *
from qiskit.tools.visualization import plot_histogram
from qiskit.tools.visualization import plot_bloch_multivector
import matplotlib.pyplot as plt
from qiskit.tools.monitor import job_monitor
#IBMQ.save_account('Account key',overwrite=True)  #  Run it for once

# 6 bit secret number
secretNumber= '101001'

circuit= QuantumCircuit(6+1,6) # 6 qubit for secret no. +1 qubit
circuit. h([0,1,2,3,4,5])
circuit.x(6)
circuit.h(6)
circuit.barrier()

# splitting the string into char
splitSecretNumber= list(secretNumber)
lengthofSecretNumber= len(splitSecretNumber)

x=0
while(x&lt; lengthofSecretNumber):
    if(str(splitSecretNumber[x])=='1'):
        circuit.cx(int(x),6)
    x=x+1

circuit.barrier()
circuit.h([0,1,2,3,4,5])
circuit.barrier()
circuit.measure([0,1,2,3,4,5],[0,1,2,3,4,5])
circuit.draw(output=&quot;mpl&quot;)

IBMQ.load_account()
provider=IBMQ.get_provider('ibm-q')
realMachine= provider.get_backend('ibmq_16_melbourne')
result = execute(circuit,realMachine, shots=1000).result()
counts= result.get_counts()
print(counts)
plot_histogram(counts)
plt.show()
</code></pre>
<p><strong>The histogram and circuit obtained are for ibmq_16_melbourne system are as below:</strong>
<a href=""https://i.stack.imgur.com/fzt35.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fzt35.jpg"" alt=""enter image description here"" /></a>
<a href=""https://i.stack.imgur.com/p5jJO.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/p5jJO.jpg"" alt=""enter image description here"" /></a></p>
<p>Please help, I am completely stuck. I could not find what is going wrong.</p>
",<qiskit><programming><quantum-gate><algorithm>,6/14/2021 1:31,17953.0,17953.0,"<p>The <a href=""https://quantumcomputing.stackexchange.com/a/17951/1859"">@epelaaez explanation</a> is on the spot on how noise works.</p>
<p>In this answer I would like to focus more on how to reduce that noise. For that, let's introduce the notion of the <em>Qiskit transpiler</em>. The transpiler adapts the circuit to run it in the backend.</p>
<p>The circuit that you are running in <code>ibmq_16_melbourne</code> is the following:</p>
<pre><code>from qiskit import transpile

realMachine_circuit = transpile(circuit, realMachine)
realMachine_circuit.draw('mpl', idle_wires=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/aNn9r.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aNn9r.png"" alt=""optimization_level=1"" /></a></p>
<p>The depth of this circuit (check <code>realMachine_circuit.depth()</code>) is 22 layers, which has the T1 and T2 noise effect described by <a href=""https://quantumcomputing.stackexchange.com/a/17951/1859"">@epelaaez</a>. Also has the following amount of gates(check <code>realMachine_circuit.count_ops()</code>):</p>
<pre><code>OrderedDict([('rz', 26),
             ('cx', 18),
             ('sx', 13),
             ('measure', 6),
             ('barrier', 3)])
</code></pre>
<p>More gates means more single (for <code>rz</code> and <code>sx</code>) and 2-qubit (for <code>cx</code>) gates error.</p>
<p>Therefore, for reducing noise, the option is to reduce the depth of the circuit and the amount of gates used in the circuit. The easier way to do this is to tell the transpiler to spend more computational resources in optimization. You can do that with the parameter <code>optimization_level</code>, which maxim number is <code>3</code>. Here, the result:</p>
<pre><code>realMachine_circuit = transpile(circuit, realMachine, optimization_level=3)
realMachine_circuit.draw('mpl', idle_wires=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/TpxP7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TpxP7.png"" alt=""optimization_level3"" /></a></p>
<p>This results in a <em>better</em> circuit:</p>
<pre><code>print('depth: ', realMachine_circuit.depth())
print('count_ops: ', list(realMachine_circuit.count_ops().items()))
</code></pre>
<pre><code>depth:  10
count_ops:  [('rz', 26), ('sx', 13), ('measure', 6), ('barrier', 3), ('cx', 3)]
</code></pre>
<p>Other aspect to consider is the effect of <code>barrier</code>. While I understand you put them there for pedagogic reasons, <a href=""https://quantumcomputing.stackexchange.com/a/16491/1859"">they do have meaning for the transpiler</a>. The transpiler does not optimize gates across barriers. So you can remove them before transpiling like this:</p>
<pre><code>from qiskit.transpiler.passes import RemoveBarriers
realMachine_circuit = transpile(RemoveBarriers()(circuit), realMachine, optimization_level=3)
print('depth: ', realMachine_circuit.depth())
print('count_ops: ', list(realMachine_circuit.count_ops().items()))
realMachine_circuit.draw('mpl', idle_wires=False)
</code></pre>
<pre><code>depth:  9
count_ops:  [('rz', 11), ('sx', 7), ('measure', 6), ('cx', 3)]
</code></pre>
<p><a href=""https://i.stack.imgur.com/zX5e6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zX5e6.png"" alt=""optimization_level3_without_barriers"" /></a></p>
<p>Now, with all this together, let's execute in real hardware to see the result:</p>
<pre><code>job = execute(RemoveBarriers()(circuit), realMachine, optimization_level=3)
counts= job.result().get_counts()
plot_histogram(counts)
</code></pre>
<p><a href=""https://i.stack.imgur.com/DK7ww.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DK7ww.png"" alt=""final result"" /></a></p>
<p>Now, the correct result is &quot;more evident&quot;. Here is the most frequent result (in this case, matching the simulation):</p>
<pre><code>counts.most_frequent()
</code></pre>
<pre><code>'100101'
</code></pre>
",6/14/2021 8:42,Errors,"The user is experiencing an issue with their quantum circuit when running it on the IBMQ quantum computer. They are seeking help to identify and resolve the problem, which falls under seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors,
17957.0,Qiskit: total number of parameters after composing parametrized circuits,"<p>I'm trying to use the <code>.compose()</code> method to join two parametrized circuits, specifically <code>TwoLocal</code> instances from the <code>qiskit.circuit.library</code>.</p>
<p>While I would expect that <code>.num_parameters_settable()</code> would be the sum of the parameters in each circuit, the final circuit will have only as many settable parameters as only one of them.</p>
<p>Version: qiskit-0.26.2</p>
<p>Thank you very much for your help!</p>
<p>My code is:</p>
<pre><code>from qiskit.circuit.library import TwoLocal
import numpy as np

    rot = TwoLocal(
        int(np.sum(num_qubits)),
        &quot;ry&quot;,
        [],
        reps=1,
        skip_final_rotation_layer=True,
        parameter_prefix=&quot;p&quot;,
    )

    var = TwoLocal(
            int(np.sum(num_qubits)),
            &quot;ry&quot;,
            &quot;cx&quot;,
            entanglement=&quot;linear&quot;,
            reps=1,
            skip_final_rotation_layer=True,
        )
    rot.num_parameters_settable()
    &gt;&gt; 2
    rot.compose(var, inplace=True)
    rot.num_parameters_settable()
    &gt;&gt; 2
</code></pre>
",<programming><qiskit>,6/14/2021 17:18,17959.0,17959.0,"<p>Looking at the <a href=""https://qiskit.org/documentation/stable/0.25/stubs/qiskit.circuit.library.TwoLocal.html"" rel=""nofollow noreferrer"">documentation for TwoLocal</a>, you can see that <code>.num_parameters_settable</code> refers to the number of parameters originally available in the circuit.</p>
<p><a href=""https://i.stack.imgur.com/v0u7G.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/v0u7G.png"" alt=""Documentation for num_parameters_settable"" /></a></p>
<p>However, <code>.num_parameters</code> will give you what you are looking for. I tried it with your code setting <code>num_qubits=2</code> and it indeed works as you want. This property is defined as:</p>
<p><a href=""https://i.stack.imgur.com/NS7qo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NS7qo.png"" alt=""enter image description here"" /></a></p>
<p>Meaning that it actually updates when an action like <code>.compose()</code> is made on the circuit.</p>
",6/14/2021 17:45,Errors,The user is encountering an issue with the .compose() method in Qiskit when trying to join two TwoLocal instances. They are not getting the expected number of settable parameters in the final circuit.,Errors,,,,Errors,
17974.0,How to find the expectation value of several circuits using Qiskit aqua operator logic?,"<p>I am using the method from <a href=""https://quantumcomputing.stackexchange.com/questions/12080/evaluating-expectation-values-of-operators-in-qiskit"">this SE answer</a> to calculate the expectation value using qiskit aqua operator logic which works well for a single circuit. Here is a simplified code snippet to demonstrate how it works.</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn, CircuitOp, CircuitStateFn

qctl = QuantumRegister(1)
psi  = QuantumCircuit(qctl)
psi  = CircuitStateFn(psi)

qctl = QuantumRegister(2)
op   = QuantumCircuit(qctl)
op.z(0)
op.ry(np.pi/4,0)
op   = CircuitOp(op)

backend = Aer.get_backend('qasm_simulator')
q_instance = QuantumInstance(backend, shots=1024)
measurable_expression = StateFn(op, is_measurement=True).compose(psi)
expectation = PauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(q_instance).convert(expectation)
print('Expectation Value = ', sampler.eval())
</code></pre>
<p>However, I am applying it to a VQE application and for each iteration I have $x&gt;1$ circuits. There is no issue when I run on my local machine because there is no queue time, but on the IBMQ machines I would like to submit a batch of the aqua expectation value circuits for each iteration to reduce queue times. For a list of circuits I can submit a batch using the <code>IBMQJobManager()</code> function, however, the method I am using does not store circuits as a list. My question is, can I use the jobmanager with the aqua expectation value to submit a batch of jobs to IBMQ? If not, is there a different way to submit a batch of the aqua expectation value circuits?</p>
",<programming><qiskit><ibm-q-experience><vqe>,6/15/2021 21:09,18016.0,18016.0,"<p>There is no need to use <code>IBMQJobManager</code> as <code>QuantumInstance</code> will do the necessary work for you. Just add your <code>CircuitOp</code>s to a <code>ListOp</code> then pass it to StateFn constructor:</p>
<pre><code>ops = []

# ... Construct your first circuit ...
# Now, add it to the list:
ops.append(op1)

# ... Construct your second circuit ...
# Now, add it to the list:
ops.append(op2)

measurable_expression = StateFn(ListOp(ops), is_measurement=True).compose(psi)
</code></pre>
<p>This way, <code>QuantumInstance</code> will assemble these circuits into a single <code>Qobj</code> and pass it to the backend.</p>
<p>Note that if the number of circuits is larger than <code>backend.configuration().max_experiments</code>, it will be splitted into multiple payloads.</p>
",6/18/2021 7:24, Tooling, The user is looking for a way to submit a batch of Aqua expectation value circuits to IBMQ using the IBMQJobManager or an alternative method. This question falls under the category of tools and software usage in quantum programming.,Tooling,,,, Tooling,
18010.0,How can I write unit tests for a pennylane circuit?,"<p>I have several mixing unitary circuits written using Pennylane to be used in the QAOA algorithm. Furthermore, I'd like to write unit tests for these mixing circuits to ensure that the code is doing what it is supposed to in the future as changes are made to the codebase. Consider the basic example:</p>
<pre><code>def x_mixer(beta, wires):
    for i in wires:
        qml.RX(beta, wires=i)
</code></pre>
<p>Currently, I'm thinking of using assert statements to check that the output of:</p>
<pre><code>dev = qml.device('lightning.qubit', wires=2, shots=10000)
circuit = qml.QNode(mixer_circuit, dev)
result = circuit(0.5, wires=[0, 1])
</code></pre>
<p>is a certain value. Now one issue is that the results themselves are probabilistic and change during each run. My first question: What's the best way to get around this? Can you set random_seed in any of the simulator devices?</p>
<p>In general if someone has ideas on how to do unit testing for Pennylane circuits, it would be really appreciated.</p>
",<programming><quantum-circuit><pennylane>,6/17/2021 19:32,18011.0,18011.0,"<p>Simulator devices, like <code>'lightning.qubit'</code> or <code>'default.qubit'</code>, can usually be run analytically. This is the default for most devices, but can be explicitly specified by setting <code>shots=None</code>.</p>
<p>Devices inheriting from <code>QubitDevice</code>, like <code>&quot;default.qubit&quot;</code> and <code>&quot;lightning.qubit&quot;</code> currently rely on <code>numpy.random</code> for their random number generation. So you can also specify the global numpy seed to get reproducible results:</p>
<pre><code>import numpy as np
np.random.seed(1234)
</code></pre>
<p>Hope that helps  :)</p>
",6/17/2021 20:21,Tooling,"The user is asking about how to use Pennylane, a quantum computing software, to write unit tests for their quantum circuits. This falls under the category of Tooling as it involves questions related to tools and software usage in quantum programming. ",Tooling,,,,Tooling,
18023.0,Cascade/Feedforward quantum circuits,"<p>I would like to know if it is possible implement the following situation in Qiskit (either using the simulators or real quantum computers).</p>
<p>Consider this illustrative toy example:</p>
<p><a href=""https://i.stack.imgur.com/oI0yT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oI0yT.png"" alt=""enter image description here"" /></a></p>
<p>The arrows illustrate that the outcomes <span class=""math-container"">$\{\sigma_1,...,\sigma_i\}$</span> determine the unitaries <span class=""math-container"">$U_j$</span> for <span class=""math-container"">$j=i+1,...,n$</span>.
That is, the idea is that the unitary <span class=""math-container"">$U_2$</span> can only be determined once the outcome <span class=""math-container"">$\sigma_1$</span> is known, then the unitary <span class=""math-container"">$U_3$</span> can be determined once <span class=""math-container"">$\sigma_1$</span> and <span class=""math-container"">$\sigma_2$</span> are known, and so on and so forth as we move along the circuit.</p>
<p>The main idea and difficulty is precisely that we do not know the unitaries <em>a priori</em> and need to calculate them from the previous outcomes. (Note that determining all the possible unitary sequences before we start the computation would mean <span class=""math-container"">$2^n$</span> possible sequences for a computation with <span class=""math-container"">$n$</span> layers.)</p>
<p>So basically, I need Qiskit to run the blue box, do the first measurement and stay in &quot;stand-by&quot; (so to speak) while I determine what <span class=""math-container"">$U_2$</span> is. Once I have that information I would have to append <span class=""math-container"">$U_2$</span> to the previous circuit and execute this new portion of the circuit alone (i.e. without running the previous one again!). (If Qiskit re-executes the first block again, it might get the wrong outcome for <span class=""math-container"">$\sigma_1$</span> and everything will be ruined). <strong>Is this possible at all? If not: (i) what is the next best thing? and (ii) is there a prediction for when such functionality will be available and in which shape?</strong></p>
<p>Thank you all!</p>
<hr />
<p><strong>EDIT:</strong>
I seem to be looking for this: <a href=""https://www.ibm.com/blogs/research/2021/02/quantum-phase-estimation/"" rel=""nofollow noreferrer"">https://www.ibm.com/blogs/research/2021/02/quantum-phase-estimation/</a> (&quot;<em><strong>dynamic quantum circuits</strong></em>&quot;). There is also the arxiv pre-print reporting this: <a href=""https://arxiv.org/abs/2102.01682"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2102.01682</a>.
Now, I need only understand if this is a functionality that is accessible to general IBMQ users like myself, or if it is still to be made available.</p>
<p>Particularly, what I want is what the authors call &quot;<em><strong>real-time compute</strong></em>&quot; or &quot;<em><strong>classical real-time logic</strong></em>&quot;. Because what I want to write is an algorithm that requires a <em>dynamic circuit</em>, <strong>not</strong> a <em>static</em> one.</p>
",<programming><qiskit><quantum-circuit>,6/18/2021 17:41,18067.0,18067.0,"<p>IBM's Development Roadmap indicates that dynamic quantum circuits will be available by the end of 2022. See here:</p>
<p><a href=""https://www.ibm.com/blogs/research/2021/02/quantum-development-roadmap/"" rel=""nofollow noreferrer"">https://www.ibm.com/blogs/research/2021/02/quantum-development-roadmap/</a></p>
",6/21/2021 10:53, Tooling,"The user is asking about how to implement a specific situation in Qiskit, a quantum computing software. This falls under the category of Tooling as it involves questions related to tools and software usage in quantum programming.", Tooling,,,, Tooling,
18063.0,How to get measurement result on Qiskit,"<p>I want to get measurement result from my circuit output, like '00', '01', '10', or '11' because want to process it further classically. Any suggestion? We can see the highest probability '01'. How I can extract the result?</p>
<p><a href=""https://i.stack.imgur.com/rENNK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rENNK.png"" alt=""enter image description here"" /></a></p>
",<programming><qiskit><measurement>,6/21/2021 8:18,18064.0,18064.0,"<p>You need to know your job id fist. You can get it from <a href=""https://quantum-computing.ibm.com/jobs"" rel=""noreferrer"">https://quantum-computing.ibm.com/jobs</a>:</p>
<p><a href=""https://i.stack.imgur.com/vfSbN.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/vfSbN.png"" alt=""sreenshot"" /></a></p>
<p>With the job id and the backend, you can enter that information to retrieve the job in Qiskit:</p>
<pre><code>from qiskit import IBMQ
provider = IBMQ.load_account()
job = provider.get_backend(&lt;backend_name&gt;).retrieve_job(&lt;job_id&gt;)
</code></pre>
<p>With the job, you can access the count like this:</p>
<pre><code>counts = job.result().get_counts()
print(counts)
</code></pre>
<pre><code>{'000000': 8,
 '000001': 16,
 '010000': 2,
 '010001': 3,
 '010100': 6,
 '010101': 2,
 '010110': 3,
 ...
}
</code></pre>
",6/21/2021 8:44, Tooling,"The question asks how to get the measurement result from the output of a Qiskit circuit, in order to process it further classically.",Tooling,,,, Tooling,
18087.0,Are job IDs unique across backends?,"<p>Are job IDs unique across backends, or is it possible that two jobs on two different backends have the same job ID? I'd like to use the job ID as primary key in a database.</p>
<p>Thanks in advance!</p>
",<programming><qiskit>,6/22/2021 12:07,18095.0,18095.0,"<p>Yes, they are unique across the full system. They are assigned by the server and it is safe to use them as primary key.</p>
",6/22/2021 18:25,API Usage,"The question is related to the uniqueness and usage of job IDs in the context of a quantum programming API, specifically in backends. The user wants to know if job IDs can be used as primary keys in a database, which is a concern tied to API usage and data management.",API Usage,,,,API Usage,
18107.0,How to construct a controlled $V$ gate in qiskit?,"<p>I have come across most of the quantum circuit which contains gate such as controlled <span class=""math-container"">$V$</span> and <span class=""math-container"">$V^{\dagger}$</span> but I dont know how to code it in Qiskit.</p>
<p><a href=""https://i.stack.imgur.com/wkSov.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wkSov.png"" alt=""The above image is the zplg gate circuit "" /></a></p>
",<programming><qiskit><quantum-gate><quantum-circuit>,6/23/2021 10:47,18118.0,18118.0,"<p><span class=""math-container"">$V$</span> is the square root of <span class=""math-container"">$X$</span>. That is,</p>
<p><span class=""math-container"">\begin{align*}
V = \sqrt X = \frac{1}{2}\left( {\begin{array}{*{20}{c}}
{1 + i}&amp;{1 - i}\\
{1 - i}&amp;{1 + i}
\end{array}} \right)
\end{align*}</span></p>
<p>It is implemented in Qiskit with the name <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.SXGate.html"" rel=""nofollow noreferrer""><span class=""math-container"">$SX$</span></a>. So, the circuit in your question is easy to implement:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import SXdgGate

qc = QuantumCircuit(4)

qc.cx(2, 3)
qc.cx(0, 3)

qc.csx(1, 2)
qc.cx(0, 1)

csxdg_gate = SXdgGate().control()
qc.append(csxdg_gate, [1, 2])

qc.csx(0, 2)
qc.cx(2, 0)

qc.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/m4Y3g.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m4Y3g.png"" alt=""enter image description here"" /></a></p>
",6/24/2021 5:49, Learning,"The user is seeking guidance on how to code quantum circuits in Qiskit that involve controlled operations with the $V$ and $V^\dagger$ gates, indicating a need for learning how to implement these specific gates in Qiskit.", Learning,,,, Learning,
18154.0,"QuantumInstance object has no attribute ""name""","<p>I follow qiskit tutorial &quot;Portfolio optimization&quot;. When I executed this cell, I encounter the attribute error as the title(picture showed below).
<a href=""https://i.stack.imgur.com/HrVwV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HrVwV.png"" alt=""enter image description here"" /></a></p>
<p>Do anyone know how to fix this problem?
It seems like the problem is inside the package, so I have no idea...</p>
",<programming><qiskit>,6/27/2021 9:45,18156.0,18156.0,"<p>As the error message stated, <code>QuantumInstance</code> has no attribute <code>name</code>.</p>
<p>What it has is <code>backend</code> and from <code>backend</code> you can retrieve <code>name</code>.</p>
<p>For example:</p>
<pre><code>quantum_instance = QuantumInstance(backend=Aer.get_backend('statevector_simulator'))
quantum_instance.backend
</code></pre>
<p>will printout:</p>
<pre><code>StatevectorSimulator('statevector_simulator')
</code></pre>
<p>and if you do</p>
<pre><code>quantum_instance.backend.name() 
</code></pre>
<p>it will printout</p>
<pre><code>'statevector_simulator'
</code></pre>
",6/27/2021 16:42,Errors,"The user is encountering an attribute error while following a Qiskit tutorial, which falls under seeking solutions and explanations for errors and exceptions in quantum program development.",Errors,,,,Errors,
18178.0,How to implement parametric iSWAP gate in Qiskit?,"<p>I'm trying to implement the parametric <span class=""math-container"">$\text{iSWAP}$</span> gate, also known as <span class=""math-container"">$\text{XY}(\theta)$</span>, in Qiskit.</p>
<p><span class=""math-container"">$$
\text{XY}(\theta)=
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos{\theta/2} &amp; i\sin{\theta/2} &amp; 0 \\
0 &amp; i\sin{\theta/2} &amp; \cos{\theta/2} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.
$$</span></p>
<p>Furthermore, once I've implemented this gate I would like to use it in order to decompose quantum circuits in terms of single-qubit gates and <span class=""math-container"">$\text{XY}(\theta)$</span> as the only two-qubit gate.</p>
<p>What are the steps that I need to do in order to achieve this?</p>
<p>Cheers!</p>
",<qiskit><programming><quantum-gate>,6/29/2021 8:22,18186.0,18186.0,"<p><strong>Update</strong>
Qiskit 0.35 introduced a new gate <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.XXPlusYYGate.html"" rel=""nofollow noreferrer""><code>XXPlusYYGate</code></a>.</p>
<p><span class=""math-container"">$$\newcommand{\th}{\frac{\theta}{2}}\\\begin{split}R_{XX+YY}(\theta, \beta)\ q_0, q_1 =
    \begin{pmatrix}
        1 &amp; 0                     &amp; 0                    &amp; 0  \\
        0 &amp; \cos(\th)             &amp; i\sin(\th)e^{i\beta} &amp; 0  \\
        0 &amp; i\sin(\th)e^{-i\beta} &amp; \cos(\th)            &amp; 0  \\
        0 &amp; 0                     &amp; 0                    &amp; 1
    \end{pmatrix}\end{split}$$</span>
So, you can now add parameterized <span class=""math-container"">$\text{XY}$</span> to your circuit as follows:</p>
<pre><code>theta = Parameter('Î¸')
circ.append(XXPlusYYGate(theta, 0), [0, 1])
</code></pre>
<hr />
<p><strong>Original Answer</strong></p>
<p>For the first part of your question, we have
<span class=""math-container"">$$XY(\theta) = exp(-i {\frac{\theta}{2}} (X{\otimes}X + Y{\otimes}Y))$$</span>
And since <span class=""math-container"">$X{\otimes}X$</span> and <span class=""math-container"">$Y{\otimes}Y$</span> commute, we can write it as
<span class=""math-container"">$$XY(\theta) = exp(-i {\frac{\theta}{2}} X{\otimes}X) exp(-i {\frac{\theta}{2}} Y{\otimes}Y)$$</span>
Qiskit already has these two gates:
<span class=""math-container"">$$R_{XX}(\theta) = exp(-i {\frac{\theta}{2}} X{\otimes}X)$$</span>
And,
<span class=""math-container"">$$R_{YY}(\theta) = exp(-i {\frac{\theta}{2}} Y{\otimes}Y)$$</span></p>
<p>Hence, the implementation of <span class=""math-container"">$XY(\theta)$</span> as a parameterized gate in Qiskit will be as simple as</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit import Parameter

theta = Parameter('Î¸')

circuit = QuantumCircuit(2)
circuit.rxx(theta, 0, 1)
circuit.ryy(theta, 0, 1)
param_iswap = circuit.to_gate()
</code></pre>
<hr />
<p><strong>Another Solution</strong></p>
<p>If you want to use more basic gates than <code>rxx</code> and <code>ryy</code>, you can use Qiskit's Operator Flow:</p>
<pre><code>H = 0.5 * ((X^X) + (Y^Y))
theta = Parameter('Î¸')
evolution_op = (theta * H).exp_i() # exp(-iÎ¸H)

trotterized_op = PauliTrotterEvolution(trotter_mode = Suzuki(order = 1, reps = 1)).convert(evolution_op)
circuit = trotterized_op.to_circuit()
circuit.draw('mpl')
</code></pre>
<p>The composition:
<a href=""https://i.stack.imgur.com/BoO7c.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BoO7c.png"" alt=""enter image description here"" /></a>
And as before</p>
<pre><code>param_iswap = circuit.to_gate()
</code></pre>
<p>For the second part of your question, I think the best answer you can have is the <a href=""https://quantumcomputing.stackexchange.com/a/17861/9474"">one</a> mentioned in the comments by @epelaaez, as it is recent and from a member of Qiskit's development team.</p>
",6/29/2021 17:44,Theoretical,The user is seeking guidance on how to implement the parametric XY gate (iSWAP) in Qiskit and how to use it to decompose quantum circuits. This question falls under the Theoretical category as it pertains to the theoretical aspects of quantum gate implementation and circuit decomposition.,Theoretical,,,,Theoretical,
18194.0,How to get the matrix representation of a circuit in Amazon braket?,"<p>Say I define a circuit using the <a href=""https://amazon-braket-sdk-python.readthedocs.io/en/latest/index.html"" rel=""nofollow noreferrer"">amazon-braket-sdk</a>, for example:</p>
<pre><code>braket_circuit = braket.circuits.Circuit()

braket_circuit.h(0)
braket_circuit.h(1)
braket_circuit.h(2)
braket_circuit.rx(0, np.pi / 4)
braket_circuit.ry(1, np.pi / 2)
braket_circuit.rz(2, 3 * np.pi / 4)
</code></pre>
<p>Are there any built-in functions that allow you to retrieve the matrix representation of the entire circuit? If all else fails, I know that I can go moment-by-moment, gate-by-gate, and use tensor products to iteratively calculate the circuit's unitary. However, I'm hoping for a one-liner similar to <a href=""https://quantumai.google/reference/python/cirq/protocols/unitary"" rel=""nofollow noreferrer""><code>cirq.protocols.unitary</code></a> or <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Operator.html#qiskit.quantum_info.Operator.data"" rel=""nofollow noreferrer""><code>qiskit.quantum_info.Operator.data</code></a>. Does such a function exist in braket? The <a href=""https://amazon-braket-sdk-python.readthedocs.io/en/latest/_apidoc/braket.circuits.quantum_operator.html?"" rel=""nofollow noreferrer""><code>braket.circuits.quantum_operator.QuantumOperator</code></a> class contains a <a href=""https://amazon-braket-sdk-python.readthedocs.io/en/latest/_apidoc/braket.circuits.quantum_operator.html?#braket.circuits.quantum_operator.QuantumOperator.to_matrix"" rel=""nofollow noreferrer""><code>to_matrix</code></a> method, but it's not clear if or how a braket <code>Circuit</code> can be converted to a <code>QuantumOperation</code> without defining a new, custom <code>QuantumOperation</code> which would of course require its own implementation of the <code>to_matrix</code> method. Thanks for any help in advance!</p>
",<programming><matrix-representation><amazon-braket>,6/29/2021 21:45,18315.0,18315.0,"<p>Up until very recently, braket had no such feature. However, as of <a href=""https://github.com/aws/amazon-braket-sdk-python/blob/main/CHANGELOG.md#v170-2021-06-25"" rel=""nofollow noreferrer"">v1.7.0 (2021-06-25)</a>, unitary representations of circuits can now be calculated using the <a href=""https://github.com/aws/amazon-braket-sdk-python/blob/main/src/braket/circuits/unitary_calculation.py"" rel=""nofollow noreferrer""><code>calculate_unitary</code></a> function. Using the circuit you provided as an example:</p>
<pre><code>In [1]: from braket.circuits import Circuit
   ...: from braket.circuits.gate import Gate
   ...: from braket.circuits.instruction import Instruction
   ...: from braket.circuits.unitary_calculation import calculate_unitary
   ...: import numpy as np

In [2]: circuit = Circuit()
   ...: 
   ...: instructions = [
   ...:     Instruction(Gate.H(), 0),
   ...:     Instruction(Gate.H(), 1),
   ...:     Instruction(Gate.H(), 2),
   ...:     Instruction(Gate.Rx(np.pi/4), 0),
   ...:     Instruction(Gate.Ry(np.pi/2), 1),
   ...:     Instruction(Gate.Rz(3*np.pi/4), 2),
   ...: ]
   ...: 
   ...: for inst in instructions:
   ...:     circuit.add_instruction(inst)
   ...: 
   ...: print(circuit)
T  : |0|    1    |
                  
q0 : -H-Rx(0.785)-
                  
q1 : -H-Ry(1.57)--
                  
q2 : -H-Rz(2.36)--

T  : |0|    1    |

In [3]: matrix_rep = calculate_unitary(3, instructions)
   ...: matrix_rep.shape
Out[3]: (8, 8)
</code></pre>
",07/06/2021 17:11,Tooling,"The user is inquiring about a built-in function or method in the Amazon Braket SDK to retrieve the matrix representation of a quantum circuit, which relates to the usage of tools and software in quantum programming.",Tooling,,,,Tooling,
18225.0,How to assemble two quantum circuits which has each own qubit mapping state?,"<p>I'm curious about something.
I tried to do some qubit mapping using SABRE algorithm. Suppose I have two quantum circuits and apply SABRE algorithm to both of them. Then each of them has its own qubit mapping states. After that, I want to compose them to make it as one long quantum circuit. How can I do it?
I used python code and <code>qiskit</code>. I have already searched <code>qiskit</code> API and used some functions (compose, combine, append). But the circuits could not be combined. How can I assemble two quantum circuit which have different qubit mapping state respectively?</p>
<p>Thank you</p>
",<programming><qiskit>,07/01/2021 02:26,18227.0,18227.0,"<p>The short answer to composed circuit is the following. Given <code>circuit1</code> and <code>circuit2</code>, you can do like this:</p>
<pre><code>circuit = circuit1 + circuit2
</code></pre>
<p>You can also do that with transpiled circuits:</p>
<pre><code>transpiled1 = transpile(circuit1, backend, routing_method='sabre')
transpiled2 = transpile(circuit2, backend, routing_method='sabre')

circuit = transpiled1 + transpiled2
</code></pre>
<p>Notice that the circuits to composed need to be the same size. After transpilation, that is ensured. <code>transpile</code> will make the circuit as big as the backend (given that you use the same backend during transpilation). The operation <code>+</code> will wire the links one-to-one.</p>
<p>Here is an example to compose circuit with different sizes:</p>
<pre><code>circuit1 = QuantumCircuit(5)
circuit1.mcx([0, 1, 3, 4], 2)
print(circuit1)
circuit2 = QuantumCircuit(2)
circuit2.cx(0, 1)
print(circuit2)
</code></pre>
<pre><code>          
q_0: âââ ââ
       â  
q_1: âââ ââ
     âââ´ââ
q_2: â¤ X â
     âââ¬ââ
q_3: âââ ââ
       â  
q_4: âââ ââ
          
          
q_0: âââ ââ
     âââ´ââ
q_1: â¤ X â
     âââââ
</code></pre>
<p>In this case, you need to use <code>compose(..., qubits=...)</code>. The parameter qubits indicates how to wire the circuits.</p>
<pre><code>circuit = circuit1.compose(circuit2, qubits=[3,2])
print(circuit)
</code></pre>
<pre><code>q_0: âââ âââââââ
       â       
q_1: âââ âââââââ
     âââ´âââââââ
q_2: â¤ X ââ¤ X â
     âââ¬âââââ¬ââ
q_3: âââ âââââ ââ
       â       
q_4: âââ âââââââ
</code></pre>
",07/01/2021 07:27,Tooling," The user is seeking guidance on how to assemble two quantum circuits with different qubit mapping states in Qiskit, which pertains to using tools and software in quantum programming.",Tooling,,,,Tooling,
18241.0,Are there any packages that can calculate stabilizer tableau of a QECC,"<p>I'm experimenting with some small quantum error correcting codes (QECC). For example
<span class=""math-container"">$[[5,1,3]]$</span>, <span class=""math-container"">$[[8,3,3]]$</span> or toric codes <span class=""math-container"">$[[2d^2,2,d]]$</span> (<span class=""math-container"">$d=2,3,\cdots$</span>). The last one
being defined by redundant stabilizers. What packages can take in a set of <span class=""math-container"">$m'$</span> stabilizers
and produce the tableau? (<span class=""math-container"">$m'$</span> could be larger than <span class=""math-container"">$m=n-k$</span> in case stabilizers are not independent).</p>
<p>Here are the details for the <span class=""math-container"">$[[8,3,3]]$</span> code : the code is in standard form; <span class=""math-container"">$1=X$</span>, <span class=""math-container"">$2=Z$</span>, <span class=""math-container"">$3=XZ$</span>;</p>
<pre><code>[[3,0,2,2,1,1,3,0],
[2,3,0,2,1,3,0,1],
[2,0,3,0,1,2,1,3],
[2,2,0,1,0,1,3,3],
[2,2,2,2,2,2,2,2],
[2,2,0,2,0,2,0,0],
[2,0,2,2,0,0,2,0],
[0,2,2,2,0,0,0,2],
[2,0,0,0,0,0,0,0],
[0,2,0,0,0,0,0,0],
[0,0,2,0,0,0,0,0],
[0,0,0,2,0,0,0,0],
[0,0,0,0,1,0,0,0],
[0,2,2,0,1,1,0,0],
[2,0,0,2,1,0,1,0],
[0,0,2,2,1,0,0,1]]
</code></pre>
<p>first 5 rows of the matrix above are stabilizers; next 3 are logical Z; next 5 are destabilizers; last 3 logical X.</p>
",<programming><error-correction><stabilizer-code><stabilizer-state>,07/01/2021 17:15,18242.0,18242.0,"<p>You can use <a href=""https://pypi.org/project/stim/"" rel=""nofollow noreferrer"">stim</a> for this, although you do have to write the stabilizer projection procedure for yourself.</p>
<p>Write some methods to project a system into the +1 eigenstate of several stabilizers:</p>
<pre><code>from typing import List

import stim

def find_compatible_tableau(stabilizers: List[stim.PauliString]) -&gt; stim.Tableau:
    num_qubits = max(len(e) for e in stabilizers)
    sim = stim.TableauSimulator()
    # Start the target qubits in a state that overlaps all stabilizers.
    for q in range(num_qubits):
        sim.h(q)
        sim.cnot(q, q + num_qubits + 1)
    # Project into each stabilizer's +1 eigenbasis.
    for s in stabilizers:
        project_stabilizer(sim, s, ancilla=num_qubits)
    # Discard ancillary qubits.
    sim.set_num_qubits(num_qubits)

    # Simulator happens to track the inverse tableau.
    # Invert it to get the normal one.
    return sim.current_inverse_tableau()**-1


def project_stabilizer(sim: stim.TableauSimulator, stabilizer: stim.PauliString, ancilla: int):
    assert ancilla &gt;= len(stabilizer)
    sim.reset(ancilla)
    sim.h(ancilla)
    for q, p in enumerate(stabilizer):
        if p == 1:
            sim.cnot(ancilla, q)
        elif p == 2:
            sim.cy(ancilla, q)
        elif p == 3:
            sim.cz(ancilla, q)
    if stabilizer.sign == -1:
        sim.z(ancilla)
    sim.h(ancilla)
    returned_true, kickback = sim.measure_kickback(ancilla)
    if returned_true:
        if kickback is None:
            raise ValueError(&quot;Contradictory stabilizers.&quot;)
        sim.do(kickback)
</code></pre>
<p>Use it on your problem:</p>
<pre><code>solved_tableau = find_compatible_tableau(stabilizers=[
    stim.PauliString(&quot;+ZZ_&quot;),
    stim.PauliString(&quot;+_ZZ&quot;),
    stim.PauliString(&quot;-XXX&quot;),
])

print(repr(solved_tableau))
</code></pre>
<p>And voilÃ :</p>
<pre><code>stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;-X__&quot;),
        stim.PauliString(&quot;+_X_&quot;),
        stim.PauliString(&quot;+__Z&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Z_Z&quot;),
        stim.PauliString(&quot;+_ZZ&quot;),
        stim.PauliString(&quot;-XXX&quot;),
    ],
)
</code></pre>
<p>The stabilizers are a bit re-arranged, but the table is consistent with the ones that were asked for.</p>
",07/01/2021 17:29,Tooling,The user is asking about a software package that can take a set of stabilizers and produce the tableau for quantum error correcting codes. This falls under the category , Tooling,,,,Tooling,
18272.0,How do you create a square pulse in Qiskit?,"<p>I am wondering how to create a square pulse in Qiskit. I am working off <a href=""https://qiskit.org/documentation/stubs/qiskit.pulse.Constant.html"" rel=""nofollow noreferrer"">this Qiskit documentation</a> but still cannot figure out how to create a square pulse.</p>
",<programming><qiskit>,07/04/2021 02:53,18290.0,18290.0,"<p>From <a href=""https://qiskit.org/documentation/apidoc/pulse.html#instructions"" rel=""nofollow noreferrer"">qiskit documentation on pulses</a>, here is a code that implement a constant (square) pulse. I also included the other examples given in the previous link.</p>
<p>Note that the API used here is brand new and still in beta, so it might change in the near future.</p>
<pre><code>from math import pi

import matplotlib.pyplot as plt
from qiskit import pulse
from qiskit.test.mock import FakeCasablanca

backend = FakeCasablanca()

pulse_duration = 64
pulse_amplitude = 1.0

with pulse.build(backend) as schedule:
    d0 = pulse.drive_channel(0)
    # The constant you are looking for
    pulse.play(pulse.library.Constant(pulse_duration, pulse_amplitude), d0)
    # Other pulses
    pulse.delay(20, d0)
    pulse.shift_phase(pi / 2, d0)
    pulse.set_phase(pi, d0)
    pulse.shift_frequency(1e7, d0)
    pulse.set_frequency(5e9, d0)

    with pulse.build() as temp_sched:
        pulse.play(pulse.library.Gaussian(20, 1.0, 3.0), d0)
        pulse.play(pulse.library.Gaussian(20, -1.0, 3.0), d0)

    pulse.call(temp_sched)
    # Measurement
    a0 = pulse.acquire_channel(0)
    pulse.acquire(30, a0, pulse.MemorySlot(0))

schedule.draw()
plt.show()
</code></pre>
<p>The code above gives the following image
<a href=""https://i.stack.imgur.com/HSGT9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HSGT9.png"" alt=""plot of the pulse schedule obtained"" /></a></p>
",07/05/2021 13:36,Tooling,"The user is seeking guidance on how to create a square pulse in Qiskit, which falls under the category of tools and software usage in quantum programming.",Tooling,,,,Tooling,
18279.0,How can I get the number of measurements where any specific qubit is equal to 0?,"<p>Say I am using a 100 qubit quantum computer, but my circuit is such that I am only interested in the output of a particular qubit. So for example I want to know how many outcomes had a result of 0 on the 50th qubit. Is there an easy way to do this rather than writing out all possible combinations which have this result?</p>
<p>Obviously writing all the combinations becomes more computationally expensive as the number of qubits increases.</p>
",<programming><qiskit>,07/04/2021 23:24,18288.0,18288.0,"<p>To add to the already existing answers you can also use <a href=""https://qiskit.org/documentation/stubs/qiskit.result.marginal_counts.html"" rel=""nofollow noreferrer"">qiskit.result.marginal_counts</a>.</p>
<p>To illustrate, I took the circuit from <a href=""https://quantumcomputing.stackexchange.com/a/18284/1386"">@KAJ226 answer</a> verbatim:</p>
<pre><code>from qiskit import QuantumCircuit, BasicAer, execute
circuit = QuantumCircuit(5,5)
for i in range(5):
    circuit.h(i)
circuit.measure([0,1,2,3,4],[0,1,2,3,4])
circuit.draw()
# Get results
backend = BasicAer.get_backend('qasm_simulator')
job = execute(circuit, backend, shots = 100)

     ââââââââ            
q_0: â¤ H ââ¤Mâââââââââââââ
     âââââ¤ââ¥ââââ         
q_1: â¤ H âââ«ââ¤Mââââââââââ
     âââââ¤ â ââ¥ââââ      
q_2: â¤ H âââ«âââ«ââ¤Mâââââââ
     âââââ¤ â  â ââ¥ââââ   
q_3: â¤ H âââ«âââ«âââ«ââ¤Mââââ
     âââââ¤ â  â  â ââ¥ââââ
q_4: â¤ H âââ«âââ«âââ«âââ«ââ¤Mâ
     âââââ â  â  â  â ââ¥â
c: 5/âââââââ©âââ©âââ©âââ©âââ©â
           0  1  2  3  4 
</code></pre>
<p>and then you can post-process the results obtained using this <code>marginal_counts</code> function:</p>
<pre><code>from qiskit.result import marginal_counts
full_results = job.result()

# Can be any qubit index or any list of qubit indices.
qubits_of_interest = [0]

marginalised_results = marginal_counts(full_results, indices=qubits_of_interest)
marginalised_counts = marginalised_results.get_counts()

print(&quot;Frequency of zeros =&quot;, marginalised_counts.get(&quot;0&quot;, 0) / sum(marginalised_counts.values()))
</code></pre>
<p>This solution have the advantage of not requiring you to split the classical registers. On the other side, I do not think it is adapted if you have more than one classical register in your circuit.</p>
",07/05/2021 12:02,Tooling , The user is asking about how to efficiently extract the outcome of a specific qubit from a quantum circuit using a quantum computing software. This falls under the category ,Tooling,,,,Tooling ,
18310.0,Get the inverse of a Hermitian operator for measurement in qiskit,"<p>I am using Qiskit to measure the Hamiltonian <code>H</code>, which isbasically sum of Pauli strings, say something like <code>2*X^X+0.5*Z^Y</code>. For one variable, I need to get the analytically form of the inverse of <code>H</code>. It seems that there is no easy way to directly get the inverse observable. So, I am wondering that how can I get this done by using qiskit?</p>
",<programming><qiskit><measurement>,07/06/2021 12:38,18311.0,18311.0,"<p>It seems that Qiskit does not have this feature. However, you can get the matrix, inverse it using <code>numpy.linalg.inv()</code>, then convert it to operator object again:</p>
<pre><code>from qiskit.opflow import X, Y, Z
from qiskit.opflow.primitive_ops import MatrixOp
import numpy as np

op = 2*(X^X)+0.5*(Z^Y)
inv_matrix = np.linalg.inv(op.to_matrix())
operator = MatrixOp(inv_matrix)

print(operator.to_pauli_op())
</code></pre>
<p>And to get a <code>PauliSumOp</code>:</p>
<pre><code>pauli_list = [(p.primitive.to_label(), p.coeff) for p in operator.to_pauli_op().oplist]

pauli_sum_op = PauliSumOp.from_list(pauli_list)
</code></pre>
",07/06/2021 13:18,Theoretical,"The user is seeking a theoretical solution for obtaining the analytical form of the inverse of a Hamiltonian in the context of quantum computing, which involves concepts related to quantum algorithms and mathematical transformations.",Theoretical,,,,Theoretical,
18343.0,Manual measurement error mitigation returning a negative number of counts,"<p>I have a simple 2 qubit circuit which I am trying to protect from errors using the measurement error mitigation technique laid out here:
<a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html</a>. My circuit is</p>
<pre><code>qr=QuantumRegister(2)
circuit2 = QuantumCircuit();
circuit2.add_register(qr)
cr=ClassicalRegister(2)
circuit2.add_register(cr)

circuit2.measure(0,0);
circuit2.measure(1,1);
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])
result = execute(circuit2,backend=Aer.get_backend('qasm_simulator'),shots=maxShot,noise_model=noise_model).result()
counts = result.get_counts(0)
</code></pre>
<p>I then get the counts for each outcome and store it in a vector</p>
<pre><code>n00=counts.get('00')
etc..
n2qvec=np.array([n00,n01,n10,n11])
</code></pre>
<p>As is laid out in the tutorial I obtain the calibration matrix and filter</p>
<pre><code>aer_sim = Aer.get_backend('aer_simulator')
qr2q = QuantumRegister(2)
my_layout2q={qr2q[0]:0,qr2q[1]:1}
meas_calibs2q, state_labels2q = complete_meas_cal(qr=qr2q, circlabel='mcal2q')
t_qc = transpile(meas_calibs2q, aer_sim)
qobj = assemble(t_qc, shots=10000)
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])    
cal_results2q = aer_sim.run(qobj, shots=10000,noise_model=noise_model).result()
meas_fitter2q = CompleteMeasFitter(cal_results2q, state_labels2q, circlabel='mcal2q')
meas_filter2q = meas_fitter2q.filter
calmat2q=meas_fitter2q.cal_matrix
import scipy.linalg as la
calmatinv2q = la.inv(calmat2q)
</code></pre>
<p>I then apply this to the earlier results to account for the noise</p>
<pre><code>mitigated_results2q = meas_filter2q.apply(res2q[1])
mitigated_counts2q = mitigated_results2q.get_counts()
print(mitigated_counts2q)
</code></pre>
<p>This works sensibly. However I thought that this is equivalent to applying the inverse of the calibration matrix to the vector of results that I have:</p>
<pre><code>print(np.dot(calmatinv2q,n2qvec))
print(min(np.dot(calmatinv2q,n2qvec)))
</code></pre>
<p>However sometimes this returns a negative counts. Obviously this isn't sensible so I assume that the measurement filter takes care of this somehow. Does anyone know how this is done? I wish to be able to do this manually because ideally I will run multiple two qubit circuits in parallel on the same quantum computer. So rather than running <span class=""math-container"">$2^n$</span> calibration circuits I will run 4 calibration circuits for each pair of qubits in isolation.</p>
",<programming><qiskit><measurement><error-mitigation>,07/08/2021 00:36,18344.0,18344.0,"<p>Unfortunately, the Qiskit textbook does not cover this topic correctly. In general you do get negative values when inverting the calibration matrix. These are called quasiprobabilities. You can use these directly for computing expectation values. Alternatively you can use a bounded least squares method to get the maximum likelihood estimate for the nearest probability distribution. In your case Qiskit is doing the latter.</p>
",07/08/2021 02:29, Tooling," The user is asking about how to manually apply the inverse of the calibration matrix to the vector of results in Qiskit, a quantum computing software. This falls under the category of Tooling",Errors, The user is encountering discrepancies in the results while applying measurement error mitigation manually to a vector of results. They are seeking clarification on why this happens and how the measurement filter in the Qiskit tutorial avoids such issues,No,112.0,Errors,"The user is encountering discrepancies in the results while applying measurement error mitigation manually and seeks clarification on why this happens and how the measurement filter in the Qiskit tutorial avoids such issues, which falls under the category of addressing errors and discrepancies in quantum computing"
18368.0,Qiskit: rounding with get_statevector does not work?,"<p>I am trying to follow some tutorials for Qiskit and came to the point where I wanted to get some statevector containing <span class=""math-container"">$1/\sqrt{2}$</span> with the following line of code:</p>
<p><code>outputstate = result.get_statevector(circ, decimals=3)</code></p>
<p>By specifying the option <code>decimals=3</code>, it should round the numerical value in the statevector to 0.707. However, it does not do that. Instead, what is displayed is <code>0.70710678+0.j</code>as it apparently fails to round.</p>
<p>What could be the problem causing this? Or how else could I resolve this issue to get nicer looking results when displayed?</p>
",<programming><qiskit>,07/09/2021 09:55,18369.0,18369.0,"<p>This looks like it could be a bug so it might be worth checking the <a href=""https://github.com/Qiskit/qiskit-terra"" rel=""nofollow noreferrer"">Qiskit repo</a> to raise an issue or see if anyone else has spotted it already.</p>
<p>If you are simply looking to format the results, you can use Python's f strings, for example <code>print(f'{outputstate:.3f}')</code> would print <code>outputstate</code> to 3 decimal places.</p>
",07/09/2021 10:05, Tooling,"The question asks about a specific function in Qiskit, which is a tooling topic.",Tooling,,,, Tooling,
18371.0,Custom labelling of randomly generated unitaries in Qiskit,"<p>I'm writing a program in Qiskit involving the generation of Haar-random unitaries. Is there a way to label each unitary such that the label appears instead of 'unitary' when I draw the circuit?</p>
<pre><code>qc = qiskit.QuantumCircuit(2,1)
randUnitary = qiskit.quantum_info.random_unitary(4)
qc.append(randUnitary,[0,1])
qc.draw()
</code></pre>
<p><a href=""https://i.stack.imgur.com/asw51.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/asw51.png"" alt=""Circuit output"" /></a></p>
",<programming><qiskit>,07/09/2021 11:25,18374.0,18374.0,"<p>Yeah, you can assign a label to a <code>Gate</code> or an <code>Instruction</code> object for this. For example, something like:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.extensions import UnitaryGate
from qiskit.quantum_info import random_unitary

qc = QuantumCircuit(2,1)
randUnitary = UnitaryGate(random_unitary(4), label='My Special Unitary')
qc.append(randUnitary, [0,1])
qc.draw()
</code></pre>
<p>which yields</p>
<p><a href=""https://i.stack.imgur.com/fg79R.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fg79R.png"" alt=""Unitary with label"" /></a></p>
",07/09/2021 11:48,Tooling ,"The user is asking how to label a unitary in a Qiskit circuit diagram, which is related to using the Qiskit tool effectively and falls under the ""Tooling"" category.",Tooling,,,,Tooling ,
18372.0,How to convert the output column vector or matrix into bra ket notation using python?,"<p>When using qiskit, we normally get the output inform of column vectors or matrix. But is it possible to convert then into bra ket notation using some python code?
Can someone help me with this?</p>
",<programming><qiskit>,07/09/2021 11:26,18375.0,18375.0,"<p>Qiskit doesn't expose a method to do this yet. There is a proposed feature under review now here: <a href=""https://github.com/Qiskit/qiskit-terra/pull/6154"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/pull/6154</a> that adds a new output style for the <code>Statevector.draw()</code> method doing this which will generate LaTeX output in the ket notation.</p>
<p>If you'd like to leverage this now it shouldn't be too difficult to adapt the code from that pull request into a standalone function you can use until that feature is merged into Qiskit for a release.</p>
",07/09/2021 11:59,Tooling,"The user is seeking a way to convert Qiskit quantum state output, which is typically represented as column vectors or matrices, into bra-ket notation using Python code. This question relates to tools and software usage in quantum programming, falling under the ""Tooling"" category.",Tooling,,,,Tooling,
18395.0,Which Qiskit Aer ideal quantum circuit simulator to use when aer_simulator is no longer available?,"<p>Some Qiskit tutorials have aer_simulator in the code and I have noticed that this simulator is no longer available.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit import Aer
Aer.backends()
</code></pre>
<p>Which of the existing simulators should I use to replace aer_simulator?</p>
<p>The example tutorial is <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/simulators/1_aer_provider.ipynb"" rel=""nofollow noreferrer"">here</a>.</p>
",<programming><qiskit>,07/11/2021 18:19,18396.0,18396.0,"<p>The <code>aer_simulator</code> was introduced in version 0.25.0 of Qiskit.</p>
<p>If it is not listed by <code>Aer.backends()</code> you should try upgrading Qiskit to the latest version.</p>
<p>You can use <code>pip install qiskit --upgrade</code> to install the latest version.</p>
",07/11/2021 22:44,Tooling,"The user is inquiring about replacing the aer_simulator with an alternative simulator in Qiskit, which involves tools and software usage in quantum programming. This question falls under the ""Tooling"" category.",Tooling,,,,Tooling,
18398.0,How do you map an X gate to a constant pulse?,"<p>I was wondering how to map an X gate to a constant pulse shape. This <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/05_pulse_gates.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/05_pulse_gates.html</a> is the link that I am working off. It shows an example of a Hadamard on a Gaussian pulse and how to do custom gates. I cannot figure out what changes I should make to the code in the Custom gates section of the link that would result in an X gate on a constant pulse shape.</p>
",<programming><qiskit>,07/12/2021 03:21,18404.0,18404.0,"<p>Following the tutorial, you can change the Gaussian and the add_calibration.</p>
<p>To build a constant pulse shape, there is <code>qiskit.pulse.library.Constant</code>, and for the mapping, change the gate from 'h' to 'x' in <code>circ.add_calibration</code>.</p>
<p>Here's the code:</p>
<pre><code>from qiskit import QuantumCircuit, pulse, transpile
from qiskit.test.mock import FakeValencia
from qiskit.pulse.library import Constant
backend = FakeValencia()

# build a simple circuit that only contain one x gate and measurement
circ = QuantumCircuit(1, 1)
circ.x(0)
circ.measure(0, 0)
with pulse.build(backend) as my_schedule:
    pulse.play(Constant(duration=10, amp=0.1), pulse.drive_channel(0)) # build the constant pulse

circ.add_calibration('x', [0], my_schedule) # map x gate in qubit 0 to my_schedule
circ = transpile(circ, backend)
circ.draw('mpl', idle_wires=False)
</code></pre>
",07/12/2021 09:28, Tooling,"The user is looking for guidance on how to implement an X gate on a constant pulse shape in Qiskit, which involves tools and software usage for defining custom gates with specific pulse shapes. This question falls under the ""Tooling"" category.",Tooling,,,, Tooling,
18408.0,Measuring the accuracy of a circuit output?,"<p>I have created a circuit and got the output which matches the truth table but, I'm not understanding the measuring the circuit output in terms of the probabilities, power or error.</p>
<p>This is the circuit I tried to create. It is the uppg gate.</p>
<pre><code>from qiskit import *
def uppg(inp1, inp2, inp3, inp4):
    
    qc = QuantumCircuit(4, 4)
    #conditions
    if(inp1 == '1'):
        qc.x(0)
    if(inp2 == '1'):
        qc.x(1)
    if(inp3 == '1'):
        qc.x(2)
    if(inp4 == '1'):
        qc.x(3)
       
    qc.barrier()
    
    #circuit
    
    qc.cx(3, 1)
    qc.cx(1, 0)
    qc.cx(0, 1)
    qc.ccx(3, 2, 1)
    qc.cx(1, 2)
    qc.cx(3, 2)
    
    #measure
    qc.measure(0, 3)
    qc.measure(1, 2)
    qc.measure(2, 1)
    qc.measure(3, 0)
    qc.draw()

    #backend
    backend = Aer.get_backend('qasm_simulator')
    job = execute(qc, backend, memory= True)
    output = job.result().get_memory()[0]
    return qc, output

    for inp1 in ['0', '1']:
        for inp2 in ['0', '1']:
            for inp3 in ['0', '1']:
                for inp4 in ['0', '1']:
                   qc_new, output = uppg(inp1, inp2, inp3, inp4)
                   print('{} {} {} {}'.format(inp1, inp2, inp3, inp4), '=', output)        
    display(qc_new.draw())
</code></pre>
<p><a href=""https://i.stack.imgur.com/7iGTr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7iGTr.png"" alt=""enter image description here"" /></a></p>
<p>The above is the output I got, but I want the output to show in terms of probability or the accuracy of circuit output. How to achieve this in Qiskit?</p>
",<programming><qiskit><quantum-gate><ibm-q-experience>,07/12/2021 11:00,18409.0,18409.0,"<p>If you use memory=True in <code>execute()</code>, then you store the measurement outcomes for each individual shots. <code>job.result().get_memory()[0]</code> mean that you access measurement outcome of the first shot.</p>
<p>The meaning of your output is for inp1, inp2, inp3, inp4 = 0, the measurement outcome of the first shot is 0000, for inp1, inp2, inp3 = 0, and inp4 = 1, the first shot is 1011, etc.</p>
<p>If you want the output show in terms of probability, or counts, you can use <code>job.result().get_counts()</code>.</p>
<p>Here's the code:</p>
<pre><code>from qiskit import * 

def uppg(inp1, inp2, inp3, inp4):
    qc = QuantumCircuit(4, 4)
    #conditions
    if(inp1 == '1'):
        qc.x(0)
    if(inp2 == '1'):
        qc.x(1)
    if(inp3 == '1'):
        qc.x(2)
    if(inp4 == '1'):
        qc.x(3)

    qc.barrier()

    #circuit

    qc.cx(3, 1)
    qc.cx(1, 0)
    qc.cx(0, 1)
    qc.ccx(3, 2, 1)
    qc.cx(1, 2)
    qc.cx(3, 2)

    #measure
    qc.measure(0, 3)
    qc.measure(1, 2)
    qc.measure(2, 1)
    qc.measure(3, 0)
    qc.draw()

    #backend
    backend = Aer.get_backend('qasm_simulator')
    job = execute(qc, backend, shots=1024)
    output = job.result().get_counts()
    return qc, output

for inp1 in ['0', '1']:
    for inp2 in ['0', '1']:
        for inp3 in ['0', '1']:
            for inp4 in ['0', '1']:
               qc_new, output = uppg(inp1, inp2, inp3, inp4)
               print('{} {} {} {}'.format(inp1, inp2, inp3, inp4), '=', output)        
display(qc_new.draw())
</code></pre>
<p>output:</p>
<p><a href=""https://i.stack.imgur.com/9hG12.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9hG12.png"" alt=""output"" /></a></p>
<p>From above output, you can see that for inp1, inp2, inp3, inp4 = 0 the measurement outcomes are 0000 for all 1024 shots, meaning the probability for 0000 is 100%.</p>
",07/12/2021 12:32, Tooling ,"The question asks about how to measure the circuit output in terms of probabilities or accuracy in Qiskit, which is a tooling topic.",Tooling,,,, Tooling ,
18410.0,How to build a QAOA Ansatz,"<p>I saw there is a qiskit package called &quot;QAOAAnsatz&quot; <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.QAOAAnsatz.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.library.QAOAAnsatz.html</a>.
But I didn't find out any tutorial related, so I have no idea how to use it.
Can anyone help me please? e.g. how to build parameter &quot;cost_operator&quot; etc. .</p>
",<programming><qiskit><qaoa>,07/12/2021 14:45,18423.0,18423.0,"<p>You can have a look at how the <code>QAOAAnsatz</code> class is used in the tests <a href=""https://github.com/Qiskit/qiskit-terra/blob/fcedd7e17a21a9ac3dcc1891d38895c1bebca98a/test/python/circuit/library/test_qaoa_ansatz.py"" rel=""nofollow noreferrer"">here</a>.</p>
<p>Note that the link given @KAJ226 in the question comments does not use <code>QAOAAnsatz</code> directly but use the <code>QAOA</code> class that forward the given operator to the <code>QAOAAnsatz</code> class. So when the line</p>
<pre><code>result = qaoa.compute_minimum_eigenvalue(qubit_op)
</code></pre>
<p>in cell 6 of <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/algorithms/05_qaoa.ipynb"" rel=""nofollow noreferrer"">KAJ226 link</a> is executed, it will call the <code>_check_operator_ansatz</code> with the exact same operator.
To summarise, the QAOAAnsatz class takes as parameter a <code>cost_operator</code> that can be constructed exactly like in cell nÂ°5 of <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/algorithms/05_qaoa.ipynb"" rel=""nofollow noreferrer"">KAJ226 link</a>.</p>
<p>The way you construct your operator depends on your particular cost function, so you will have to construct the operator by yourself, but you have a working example to start.</p>
",7/13/2021 8:55,Tooling,"The user is asking about how to use the QAOAAnsatz package in Qiskit, a quantum computing software.", Learning," The user is looking for guidance on how to use the QAOAAnsatz package in Qiskit and how to build parameters like the ""cost_operator."" This question falls under the Learning category ",No,113.0,Learning," The user is seeking guidance on how to use the QAOAAnsatz package in Qiskit and how to build parameters like the ""cost_operator,"" which falls under the Learning category as they are seeking to understand and learn about a specific feature in quantum computing."
18454.0,About qiskit's error mitigation,"<p>In qiskit, the error correction using least squares is apparently in <code>qiskit-ignis/qiskit/ignis/mitigation/measurement/filters.py</code>, source code from github and reads:</p>
<pre><code># Apply the correction
    for data_idx, _ in enumerate(raw_data2):

        if method == 'pseudo_inverse':
            raw_data2[data_idx] = np.dot(
                pinv_cal_mat, raw_data2[data_idx])

        elif method == 'least_squares':
            nshots = sum(raw_data2[data_idx])

            def fun(x):
                return sum(
                    (raw_data2[data_idx] - np.dot(self._cal_matrix, x))**2)
            x0 = np.random.rand(len(self._state_labels)) # ********
            x0 = x0 / sum(x0)                            # ********
            cons = ({'type': 'eq', 'fun': lambda x: nshots - sum(x)})
            bnds = tuple((0, nshots) for x in x0)
            res = minimize(fun, x0, method='SLSQP',
                           constraints=cons, bounds=bnds, tol=1e-6)
            raw_data2[data_idx] = res.x

        else:
            raise QiskitError(&quot;Unrecognized method.&quot;)
</code></pre>
<p>I'm not too skilled in python and I would not like to change my qiskit's base installation. I have marked with <code>*</code> the two lines that seems to me strange.</p>
<p>My question is: in this error correction, one does least squares to minimize the function <span class=""math-container"">$F=|c_{\rm exp} - Mc_{\rm corr}|^2$</span>, where <span class=""math-container"">$c_{\rm exp}, c_{\rm corr}$</span> are the experimental and corrected counts, respectively and <span class=""math-container"">$M$</span> is the &quot;correction matrix&quot;.</p>
<p>As it is common, <code>minimize</code> requires a fair guess <code>x0</code> in order to find the answer of <span class=""math-container"">$F$</span>. I don't understand why the built-in function sets <code>x0</code> as a random vector. Ok, I can buy that the method &quot;does not know which previous circuit was ran&quot;, but in theory if one knows the circuit, one should choose <code>x0</code> based on this information, right?</p>
",<programming><qiskit><error-mitigation>,7/16/2021 11:14,18461.0,18461.0,"<p>So yeah it is not the best choice. My guess is the individual who programmed it did not think about the physics of the problem. In short, it is best to use the raw input data as the starting point when measurement errors are small. In practice this gives you much faster convergence.</p>
",7/16/2021 21:01,Tooling ,"The user is asking about the implementation of the least squares error correction in Qiskit, a quantum computing software",Tooling ,,,,Tooling ,
18465.0,Are there problems that a classical computer can solve and a quantum computer can never solve?,"<p>Apologies if this is a silly question. But I've heard quantum computers can solve <a href=""https://www.quantamagazine.org/finally-a-problem-that-only-quantum-computers-will-ever-be-able-to-solve-20180621/"" rel=""nofollow noreferrer"">problems</a> that classical computers can't. What about the converse, are there any problems that a classical computer can solve and a quantum computer can never solve?</p>
",<classical-computing>,7/17/2021 9:17,18466.0,18466.0,"<p>The classical computer only manipulates logic 0 and logic 1, composing the essence of the logical circuit. So the question that classical computers can solve is merely by manipulating logic 0 and logic 1, while quantum can easily mimic it by only manipulating <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span>. So I think there does not exist any question that classical computers can solve while the quantum computers cannot.</p>
",7/17/2021 10:33,Theoretical,"The question asks whether there are any problems that a classical computer can solve and a quantum computer can never solve, which is a theoretical question",Theoretical,,,,Theoretical,
18539.0,Pack Header Error when using QAOAProgram,"<p>I want to use QAOAProgram from Qiskit in the following way:</p>
<pre><code>from qiskit_optimization.runtime import QAOAProgram
from qiskit_optimization.converters import QuadraticProgramToQubo
from qiskit_optimization.applications.max_cut import Maxcut

max_cut_quadr_program = Maxcut(graph).to_quadratic_program()
pauli, f = max_cut_quadr_program.to_ising()

optimizer = {'name': 'SPSA',
             'maxiter': 50}
backend = provider.get_backend('ibmq_qasm_simulator')

runtime_qaoa = QAOAProgram(
                         callback=None,
                         optimizer=optimizer,
                         initial_point=None,
                         provider=provider,
                         backend=backend,
                         shots=8192,
                         measurement_error_mitigation=True)

runtime_result = runtime_qaoa.compute_minimum_eigenvalue(pauli)

</code></pre>
<p>But I got this error:</p>
<pre><code>
---------------------------------------------------------------------------
error                                     Traceback (most recent call last)
&lt;ipython-input-40-1f2a3143b054&gt; in &lt;module&gt;()
     19                          measurement_error_mitigation=True)
     20 
---&gt; 21 runtime_result = runtime_qaoa.compute_minimum_eigenvalue(pauli)

10 frames
/usr/local/lib/python3.7/dist-packages/qiskit_optimization/runtime/qaoa_program.py in compute_minimum_eigenvalue(self, operator, aux_operators)
    158             mixer_operator=self.mixer,
    159         )
--&gt; 160         return super().compute_minimum_eigenvalue(operator, aux_operators)

/usr/local/lib/python3.7/dist-packages/qiskit_optimization/runtime/vqe_program.py in compute_minimum_eigenvalue(self, operator, aux_operators)
    272             inputs=inputs,
    273             options=options,
--&gt; 274             callback=self._wrap_vqe_callback(),
    275         )
    276         # print job ID if something goes wrong

/usr/local/lib/python3.7/dist-packages/qiskit/providers/ibmq/runtime/ibm_runtime_service.py in run(self, program_id, options, inputs, callback, result_decoder)
    233 
    234         backend_name = options['backend_name']
--&gt; 235         params_str = json.dumps(inputs, cls=RuntimeEncoder)
    236         result_decoder = result_decoder or ResultDecoder
    237         response = self._api_client.program_run(program_id=program_id,

/usr/lib/python3.7/json/__init__.py in dumps(obj, skipkeys, ensure_ascii, check_circular, allow_nan, cls, indent, separators, default, sort_keys, **kw)
    236         check_circular=check_circular, allow_nan=allow_nan, indent=indent,
    237         separators=separators, default=default, sort_keys=sort_keys,
--&gt; 238         **kw).encode(obj)
    239 
    240 

/usr/lib/python3.7/json/encoder.py in encode(self, o)
    197         # exceptions aren't as detailed.  The list call should be roughly
    198         # equivalent to the PySequence_Fast that ''.join() would do.
--&gt; 199         chunks = self.iterencode(o, _one_shot=True)
    200         if not isinstance(chunks, (list, tuple)):
    201             chunks = list(chunks)

/usr/lib/python3.7/json/encoder.py in iterencode(self, o, _one_shot)
    255                 self.key_separator, self.item_separator, self.sort_keys,
    256                 self.skipkeys, _one_shot)
--&gt; 257         return _iterencode(o, 0)
    258 
    259 def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,

/usr/local/lib/python3.7/dist-packages/qiskit/providers/ibmq/runtime/utils.py in default(self, obj)
    127             value = _serialize_and_encode(
    128                 data=obj,
--&gt; 129                 serializer=lambda buff, data: qpy_serialization.dump(data, buff)
    130             )
    131             return {'__type__': 'QuantumCircuit', '__value__': value}

/usr/local/lib/python3.7/dist-packages/qiskit/providers/ibmq/runtime/utils.py in _serialize_and_encode(data, serializer, compress, **kwargs)
     54     &quot;&quot;&quot;
     55     buff = io.BytesIO()
---&gt; 56     serializer(buff, data, **kwargs)
     57     buff.seek(0)
     58     serialized_data = buff.read()

/usr/local/lib/python3.7/dist-packages/qiskit/providers/ibmq/runtime/utils.py in &lt;lambda&gt;(buff, data)
    127             value = _serialize_and_encode(
    128                 data=obj,
--&gt; 129                 serializer=lambda buff, data: qpy_serialization.dump(data, buff)
    130             )
    131             return {'__type__': 'QuantumCircuit', '__value__': value}

/usr/local/lib/python3.7/dist-packages/qiskit/circuit/qpy_serialization.py in dump(circuits, file_obj)
    853     file_obj.write(header)
    854     for circuit in circuits:
--&gt; 855         _write_circuit(file_obj, circuit)
    856 
    857 

/usr/local/lib/python3.7/dist-packages/qiskit/circuit/qpy_serialization.py in _write_circuit(file_obj, circuit)
    871         num_instructions=num_instructions,
    872     )
--&gt; 873     header = struct.pack(HEADER_PACK, *header_raw)
    874     file_obj.write(header)
    875     file_obj.write(circuit_name)

error: required argument is not a float

</code></pre>
<p>Qiskit verison: 0.28</p>
<p>What am I doing wrong?</p>
<p>My idea is that there is some issue  with my ansatz or <code>PauliSumOp</code> is not correct, but maybe someone has a better explanation.</p>
",<programming><qiskit><optimization><qaoa>,7/21/2021 19:58,18575.0,18575.0,"<p>I submitted an issue on GitHub <a href=""https://github.com/Qiskit/qiskit-optimization/issues/211"" rel=""nofollow noreferrer"">here</a>.</p>
",7/23/2021 8:26, Errors,The user is seeking solutions and explanations for errors and exceptions encountered in their quantum program development., Errors,,,, Errors,
18566.0,Job ids retrieval from ID. Big set of jobs,"<p>I'm in the need of running a lot of jobs in the IBM backends. If one likes to run in parallel two jobs (say, with two different parameters), I have seen in the <code>Jobs</code> webpage that sometimes the jobs are mixed. What I mean with this is that e.g. in the downloadable cvs file, row 3 belongs to job 1 and row 4 to job 2. To filter out every single cell in the cvs does not appear feasible.</p>
<p>Now, in qiskit, if I send a big job, this is partitioned into several chunks, something that <code>job_set_foo.report(detailed=True)</code> returns is:</p>
<pre><code>Job set name: 2021-07-22T14:09:01.003237
      ID: XXXX-YYYY
    tags: []
...
Detail report:
  experiments: 0-74
    job index: 0
    job ID: ZZZ1
...
</code></pre>
<p>So suppose that my ID <code>XXX-YYY</code> contains 20 jobs ids <code>ZZZx</code>. Is there a way to, from directly the ID, retrieve as a list all the <code>ZZZx</code>'s jobs ids?</p>
<p>*<code>job_set_foo = job_manager.run(circuits, backend=backend, shots=2**13)</code></p>
",<programming><ibm-q-experience>,7/22/2021 14:29,18567.0,18567.0,"<p>If all what you want is a list of all job IDs for the jobs in a job set:</p>
<pre><code>job_set = job_manager.retrieve_job_set(job_set_id = 'XXX-YYY', provider = provider)
id_list = [ job.job_id() for job in job_set.jobs() ]
</code></pre>
",7/22/2021 15:46,Tooling,"The user is asking about how to use Qiskit, a specific quantum computing tool, to manage and retrieve information about multiple jobs.",Tooling,,,,Tooling,
18568.0,"How does one even get started in Quantum Computing, specifically building qApps?","<p>I want to build a quantum application, qApp if you will; how does one go about figuring out the right use-case and best framework to turn to, to start building these things?</p>
<p>Quantum REPL? How do I learn how to program qBits? Polarity? Spin? Quantum entanglement? How do you even program that? What are we even talking about; do I even own a dead cat or not?</p>
<p>Unlocking Satoshi Nakamoto's BTC PrivateKey seems like a great place to start no?? Did he even exist to begin with? Anyone have any clues?</p>
<p>Quantum Backend anyone? Maybe like a QuantumNode.js of sorts?</p>
<p>Bueller? Bueller? Anyone?</p>
",<programming>,7/22/2021 22:26,18573.0,18573.0,"<p>qApps as you have described them in your question don't exist yet. The number of qubits available through classical simulation or real quantum hardware is not enough  and the noise present is too high to run applications that would require a framework like QuantumNode.js or similar.</p>
<p>Right now, we are going through the NISQ era. Which stands for Noisy Intermediate Scale Quantum. This basically means that the noise in qubits limits the depth (number of gates) of the circuits we can run on them. This doesn't mean that these qubits are useless, some applications of NISQ computers are: small molecule simulations with <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">VQE</a>, prime factorization (<a href=""https://qiskit.org/textbook/ch-algorithms/shor.html"" rel=""nofollow noreferrer"">Shor's algorithm</a>), and unstructured data search with <a href=""https://qiskit.org/textbook/ch-applications/satisfiability-grover.html"" rel=""nofollow noreferrer"">Grover's algorithm</a>. I recommend the paper <a href=""https://arxiv.org/abs/1801.00862"" rel=""nofollow noreferrer""><em>Quantum Computing in the NISQ era and beyond</em></a> if you want to learn more about this.</p>
<p>To program algorithms like the ones I've described, one of the most popular tools is <a href=""https://qiskit.org/documentation/"" rel=""nofollow noreferrer"">Qiskit</a>. This is a Python library in which you can build circuits and simulate them in your device or send them to one of IBM's real quantum comptuers. Other tools also exist, like <a href=""https://docs.microsoft.com/en-us/azure/quantum/user-guide/"" rel=""nofollow noreferrer"">Q#</a> and <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a>.</p>
",7/23/2021 3:04,Learning,"The question is asking about how to get started with building quantum applications, including learning about the basics of quantum computing, choosing the right framework, and finding a good use case",Learning,,,,Learning,
18577.0,Matplotlib graphs are being duplicated each time,"<p>Simple UI question. I have installed qiskit according to the instruction and try to implement some basic operations. I have the issue that anything I plot appears twice. I am not sure why this is happening, so I am looking for some suggestions.</p>
<p>See the attached image:<a href=""https://i.stack.imgur.com/8R19x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8R19x.png"" alt=""enter image description here"" /></a></p>
",<programming><qiskit>,7/23/2021 10:37,18579.0,18579.0,"<p>There was an issue raised on qiskit-tutorials about this duplicate drawing. The solution that was done there was to remove <code>%matplotlib inline</code> from the notebooks.</p>
<p>If you would like to know more you can see the fix here <a href=""https://github.com/Qiskit/qiskit-tutorials/pull/1206"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-tutorials/pull/1206</a> which also links back to issues which report the problem.</p>
",7/23/2021 12:55,Errors,"The user is encountering an issue with the Qiskit plotting functionality where the plots appear twice, indicating a potential error or bug in the plotting functionality that they are seeking to resolve.",Errors,,,,Errors,
18593.0,How to re-ordering physical qubit location into desired one?,"<p>Suppose original quantum circuit have 4 qubits and some quantum operation. Also suppose the result of original quantum circuit state is '1100'. Then apply qubit mapping then mapping state is like below</p>
<pre><code>1 -&gt; 0
3 -&gt; 1
0 -&gt; 2
2 -&gt; 3
</code></pre>
<p>Then the result of quantum circuit after qubit mapping will be '1010'.
But I want to know how to change these physical qubit state location.
So ultimately, I want to see the result after qubit mapping like '1100' which is the same result of original quantum circuit.</p>
<p>How can I do that?</p>
",<programming><physical-qubit><qubit-mapping>,7/24/2021 4:55,18594.0,18594.0,"<p>I will answer using Python, but the underlying method can be easily adapted to another language.</p>
<p>You can represent the mapping you describe in your question</p>
<pre><code>1 -&gt; 0
3 -&gt; 1
0 -&gt; 2
2 -&gt; 3
</code></pre>
<p>as a map, or a Python dictionary in this case (it can also be represented as a simple array, but this complicates a little bit the code):</p>
<pre><code>logical2hardware_mapping = {0: 1, 1: 3, 2: 0, 3: 2}
</code></pre>
<p>From this map representation, you can post-process your result quite easily by re-arranging the bits:</p>
<pre><code>import typing as ty

def rearrange_hardware_result(hardware_result: str, mapping: ty.Dict[int, int]) -&gt; str:
    # 1. Invert the mapping
    hardware2logical_mapping = {v: k for k, v in mapping.items()}
    # 2. Construct the rearranged result
    return &quot;&quot;.join(
        hardware_result[hardware2logical_mapping[i]]
        for i in range(len(hardware_result))
    )
</code></pre>
<p>Finally, you can test the function on your example and check that it works as expected:</p>
<pre><code>hardware_result = &quot;1010&quot;
print(rearrange_hardware_result(hardware_result, logical2hardware_mapping))
# Output &quot;1100&quot;
</code></pre>
<p>Side note: I worked quite a bit with these issues of mapping and how to change them. The <strong>most important</strong> thing to do at the very beginning in order to understand what you are doing is to note somewhere what is represented. For example in your mapping, you do not explicitly say what the indices on the left-hand side of the arrows are, same for the right-hand side ones. Once the meaning of the indices you are using is clear, everything starts to become easier.</p>
",7/24/2021 8:25,Conceptual,"The user is seeking a conceptual understanding of qubit mapping and how to change the physical qubit state locations in a quantum circuit to achieve a specific mapping, which involves understanding the underlying principles of qubit mapping and circuit manipulation.",Conceptual,,,,Conceptual,
18608.0,Integer factorization using Shor's Alorithm,"<p>I have question about Shor's algorithm, from I know it's for factorize an integer and can factorize big number with ease. I using Qiskit to try make a simple factorization program (with local simulator and I have planning to make it run to real device soon), but I confuse in these part of the code: <a href=""https://i.stack.imgur.com/r1Y7F.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r1Y7F.png"" alt=""enter image description here"" /></a><br/> Did the <code>a</code> are must in range <code>[2,7,8,11,13]</code> ? can I use another number ? or it just best practice ? and what purpose of <code>a</code> ?<br/>
Number I want try to factorize roughly 10 digit random number.<br/>
Thanks<br/>
PS: Noob here please nice :)</p>
",<programming><qiskit><shors-algorithm>,7/26/2021 3:55,18609.0,18609.0,"<p>Qiskit uses the implementation of Shor's algorithm from <a href=""https://arxiv.org/abs/quant-ph/0205095"" rel=""nofollow noreferrer""><em>Circuit for Shor's algorithm using 2n+3 qubits</em></a>, so I recommend looking into that for more detail on how to implement the general case of Shor's algorithm.</p>
<h3>Values for <span class=""math-container"">$a$</span></h3>
<p>Anyways, now regarding your specific question. The code snippet that you shared is for factorizing the number 15. I first refer to <a href=""https://www.quantiki.org/wiki/shors-factoring-algorithm"" rel=""nofollow noreferrer"">this</a> post to explain your question of the values of <span class=""math-container"">$a$</span>. In there, the first three steps for the algorithm are detailed as:</p>
<blockquote>
<ol>
<li>Pick a pseudo-random number <span class=""math-container"">$a &lt; N$</span></li>
<li>Compute <span class=""math-container"">$\gcd(a, N)$</span>. This may be done using the Euclidean algorithm.</li>
<li>If <span class=""math-container"">$\gcd(a, N) \not = 1$</span>, then there is a nontrivial factor of <span class=""math-container"">$N$</span>, so we are
done.</li>
</ol>
</blockquote>
<p>Also let me add that <span class=""math-container"">$a$</span> must be larger than or equal to <span class=""math-container"">$2$</span>. So, that explains why <span class=""math-container"">$3, 5, 6, 9, 10$</span> and <span class=""math-container"">$12$</span> are not valid values for <span class=""math-container"">$a$</span>. This still leaves the question of why <span class=""math-container"">$4$</span> (see update below) and <span class=""math-container"">$14$</span> were left out.</p>
<p>To rule out <span class=""math-container"">$14$</span>, take a look at the following graph and explanation from <a href=""https://quantum-computing.ibm.com/composer/docs/iqx/guide/shors-algorithm#shors-algorithm"" rel=""nofollow noreferrer"">IBM Quantum Composer's documentation for Shor's algorithm</a>.</p>
<p><a href=""https://i.stack.imgur.com/kELQj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kELQj.png"" alt=""enter image description here"" /></a></p>
<blockquote>
<p>At this point we have found some pair <span class=""math-container"">$r,a$</span> such that <span class=""math-container"">$r$</span> is even, and <span class=""math-container"">$r$</span> is the smallest integer such that <span class=""math-container"">$a^r-1$</span> is a multiple of <span class=""math-container"">$N$</span>. Let us use the identity
<span class=""math-container"">$$ a^r - 1 = (a^{r/2} - 1)(a^{r/2} + 1) $$</span>
The above shows that <span class=""math-container"">$a^{r/2}-1$</span> is not a multiple of <span class=""math-container"">$N$</span> (otherwise the period of <span class=""math-container"">$a$</span> would be <span class=""math-container"">$r/2$</span>). Assume for a moment that <span class=""math-container"">$a^{r/2}+1$</span> is not a multiple of <span class=""math-container"">$N$</span>. Then neither of the integers <span class=""math-container"">$a^{r/2}\pm 1$</span> is a multiple of <span class=""math-container"">$N$</span>, but their product is.  This is possible only if <span class=""math-container"">$p_1$</span> is a prime factor of <span class=""math-container"">$a^{r/2}-1$</span> and <span class=""math-container"">$p_2$</span> is a prime factor of <span class=""math-container"">$a^{r/2}+1$</span> (or vice versa). We can thus find <span class=""math-container"">$p_1$</span> and <span class=""math-container"">$p_2$</span> by computing <span class=""math-container"">$\gcd(N, a^{r/2}\pm1)$</span>; see Table 1 for examples. In the remaining âunluckyâ case, when <span class=""math-container"">$a^{r/2}+1$</span> is a multiple of <span class=""math-container"">$N$</span>, we give up and try a different integer <span class=""math-container"">$a$</span>.  For example, <span class=""math-container"">$a=14$</span> is the only unlucky integer in Table 1. In general, it can be shown that the unlucky integers <span class=""math-container"">$a$</span> are not too frequent, so on average, only two calls to the period-finding machine are sufficient to factor <span class=""math-container"">$N$</span>.</p>
</blockquote>
<p>For why <span class=""math-container"">$4$</span> is left out, I have no answer. My guess is that hard coding the unitary for the operation with <span class=""math-container"">$a=4$</span> was too complicated compared to the other values of <span class=""math-container"">$a$</span> to include in an early chapter of the Qiskit textbook like this one.</p>
<p><strong>Update:</strong> the <a href=""https://qiskit.org/textbook/ch-algorithms/shor.html"" rel=""nofollow noreferrer"">tutorial</a> was updated, and now <span class=""math-container"">$4$</span> is included as it should be.</p>
<h3>Shor's for 10 digit random number</h3>
<p>Now, I'll briefly address this part of your question. The circuit for Shor's algorithm gets bigger in depth and number of qubits in relation to the number you want to factorize. Like in the paper I linked first, their construction grows as <span class=""math-container"">$2n+3$</span>, where <span class=""math-container"">$n$</span> is not exactly the number of factorize but it depends on it. Therefore, running Shor's algorithm for a number this big (either simulating it or in a real device), is not feasible yet. It would take a number of qubits not yet available on real devices; or at least in the public ones. And simulating it would not be feasible as the maximum number of qubits you can simulate is 32 (per <a href=""https://quantumcomputing.stackexchange.com/a/14931/16092"">this</a> answer), which I don't believe are enough to factorize a 10 digit number.</p>
",7/26/2021 4:25,Conceptual,"The user is seeking a conceptual understanding of Shor's algorithm and its implementation in Qiskit, particularly regarding the choice of values for the variable ""a"" in the algorithm. Understanding the purpose of ""a"" and its range is essential for implementing Shor's algorithm correctly.",Conceptual,,,,Conceptual,
18624.0,How to re-order logical qubit location into desired state?,"<p>Now, I'm studying about qubit mapping. When the mapping is done, the logical qubit will be randomly mapped to physical qubit. But I want to move the logical qubit location into desired state.
For example, if the mapping state is like below. Left side is logical and right side is physical</p>
<pre><code>1 -&gt; 0
3 -&gt; 1
2 -&gt; 2
0 -&gt; 3
</code></pre>
<p>So, after executing all quantum gates, I want the logical qubit's location would be like below</p>
<pre><code>0
1
2
3
</code></pre>
<p>It means change the qubit state into desired state. (0, 1, 2, 3)</p>
<p>Or Is there any way(qiskit function) that I can extract the circuit's qubit location and change them?</p>
",<programming><algorithm><qubit-mapping>,7/27/2021 0:53,18625.0,18625.0,"<p>I found something that could help you, it's a <a href=""https://qiskit.org/documentation/stubs/qiskit.transpiler.Layout.html"" rel=""nofollow noreferrer"">documentation</a> with commands to do different operations between physical and virtual [qu]bits.</p>
<p>You could use something like this:</p>
<pre><code>{(QuantumRegister(3, 'qr'), 0): 0,
 (QuantumRegister(3, 'qr'), 1): 1,
 (QuantumRegister(3, 'qr'), 2): 2}

Can be written more concisely as follows:

* virtual to physical::

    {qr[0]: 0,
     qr[1]: 1,
     qr[2]: 2}

* physical to virtual::

    {0: qr[0],
     1: qr[1],
     2: qr[2]}
</code></pre>
",7/27/2021 1:13,Tooling,"The user is asking about how to use Qiskit, a specific quantum computing tool, to manipulate the mapping of logical qubits to physical qubits.",Tooling,,,,Tooling,
18647.0,Print runtime of an optimizer,"<p>I want to find the runtime of my program, i.e. the time it is in the quantum computer without queue time. However, I am using an optimizer so the code is a little different.</p>
<pre><code>from qiskit.utils import algorithm_globals




algorithm_globals.random_seed = 1234
backend = provider.get_backend('ibmq_belem')

#backend = Aer.get_backend('statevector_simulator')

cobyla = COBYLA()
cobyla.set_options(maxiter=1)
ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full')
quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed)
vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance)
vqe = MinimumEigenOptimizer(vqe_mes)
result = vqe.solve(qp)



print(result)
#print_result(result)
</code></pre>
<p>How do I figure out the runtime? Printing result only shows</p>
<pre><code>optimal function value: -0.01488461311339271
optimal value: [1. 0. 0. 1.]
status: SUCCESS
</code></pre>
",<programming><quantum-computing-for-finance>,7/28/2021 18:48,18648.0,18648.0,"<p>I made a <code>start</code> and <code>end_operation</code> point with the method <code>now()</code>. At the end of the operation it will display the time it needed:</p>
<pre><code>from qiskit.utils import algorithm_globals
from time import time as now



algorithm_globals.random_seed = 1234
backend = provider.get_backend('ibmq_belem')

#backend = Aer.get_backend('statevector_simulator')

cobyla = COBYLA()
cobyla.set_options(maxiter=1)
ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full')
quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed)
start_operation = now()
vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance)
vqe = MinimumEigenOptimizer(vqe_mes)
end_operation = now()
result = vqe.solve(qp)

    
    process_time = (
end_operation - start_operation
)
print(f&quot;Operation took {process_time:.2f} seconds in machine&quot;)



print(result)
#print_result(result)
</code></pre>
<hr />
<p>Another possibility to meassure the program is to use the command <code>rep_time</code>:</p>
<blockquote>
<p><code>rep_time</code> (int) â Time per program execution in seconds. Must be from
the list provided by the backend
(<code>backend.configuration().rep_times</code>). Defaults to the first entry.</p>
</blockquote>
<p>In your specific case you need to add it in your code like this:</p>
<pre><code>...
quantum_instance = QuantumInstance(backend=backend, rep_time=rep_time, seed_simulator=seed, seed_transpiler=seed)
...
</code></pre>
",7/28/2021 19:02,Tooling ,"The user is asking about how to use a specific feature of the Qiskit tool, specifically how to find the runtime of their quantum program.",Tooling ,,,,Tooling ,
20669.0,Apply a custom gate to qubits in separate quantum registers,"<p>Let there be a custom gate (simply called <code>gate</code> that takes <span class=""math-container"">$N$</span> qubits as input. Also, let <span class=""math-container"">$A$</span> of those qubits be in <code>first_register</code> and <span class=""math-container"">$B$</span> of those qubits be in <code>second_register</code> (<span class=""math-container"">$B = N-A$</span>, obviously).
Both registers are <code>QuantumRegisters</code>.</p>
<p>How to append this custom gate to circuit, like what to write in <code>circuit.append(gate, HERE)</code>.</p>
",<programming><qiskit><quantum-gate>,7/30/2021 7:56,20670.0,20670.0,"<p>You can simply merge the lists of qubits from two quantum registers or more as any python lists using &quot;+&quot; sign. For example</p>
<pre><code>gate = UnitaryGate(random_unitary(2 ** 4).data, 'RND-U16')

qr1 = QuantumRegister(2, 'q')
qr2 = QuantumRegister(3, 'a')
circ = QuantumCircuit(qr1, qr2)

circ.mct(qr1[0:2] + qr2[0:2], qr2[2])
circ.append(gate, qr1[1:2] + qr2[0:3])
</code></pre>
<p>The result:</p>
<p><a href=""https://i.stack.imgur.com/Jvmg5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Jvmg5.png"" alt=""enter image description here"" /></a></p>
",7/30/2021 8:17,API Usage,"The user is seeking information on how to use the Qiskit API to append a custom gate to a quantum circuit, specifically when dealing with different registers (i.e., first_register and second_register).",API Usage,,,,API Usage,
20675.0,Measure $\langle \hat{X}\rangle$ and $\langle \hat{Y}\rangle$ from counts,"<p>I'm confused about how I can measure <span class=""math-container"">$\langle \hat{X}\rangle$</span> and <span class=""math-container"">$\langle \hat{Y}\rangle$</span> using counts. Here's my code for X:</p>
<p>x-basis:</p>
<pre><code># Measurement in x-basis. 
quanc_x = QuantumCircuit(1)
quanc_x.u(1,2,3,0) # prepare some random state
quanc_x.h(0)
quanc_x.measure_all()
quanc_x.draw(output='mpl')
</code></pre>
<pre><code># number of repetitions
N = 10000

backend = Aer.get_backend( 'qasm_simulator' )
job = execute( quanc_x, backend, shots=N )
result = job.result()

measurement_result = result.get_counts( quanc_x )
print( measurement_result )
plot_histogram( measurement_result )
</code></pre>
<pre><code>cos_phi_est = ( measurement_result['0'] - measurement_result['1'] ) / N  #&lt;--Question
print( &quot;cos(phi) estimated: &quot;, cos_phi_est )
</code></pre>
<p>My question of this code is marked above. I'm not pretty sure if that looks correct. For Pauli X, we have
<span class=""math-container"">$$
\langle \hat{X}\rangle=\langle\psi|0\rangle\langle1|\psi\rangle+\langle\psi|1\rangle\langle0|\psi\rangle
$$</span>
Can I simplify that further? Should that correspond to my code with the question mark? How can I apply that to  <span class=""math-container"">$\langle \hat{Y}\rangle$</span>? Thanks for the help!</p>
",<programming><ibm-q-experience><measurement>,7/30/2021 20:48,20679.0,20679.0,"<p>That looks right to me.</p>
<p>Since, <span class=""math-container"">$HZH = X$</span> then we have that <span class=""math-container"">$\langle \psi | X | \psi \rangle = \langle \psi  | HZH | \psi \rangle = \langle \psi H  | Z |  H\psi \rangle $</span>.</p>
<p>In your code, you generate <span class=""math-container"">$|\psi \rangle$</span> with a <span class=""math-container"">$U_3(\theta, \phi, \lambda) $</span> gate applied to <span class=""math-container"">$|0\rangle$</span>. Then you applied the Hadamard gate (<span class=""math-container"">$H$</span>) before measuring which is what needed to measure in the <span class=""math-container"">$X$</span> basis as discussed above.</p>
<hr />
<p>For <span class=""math-container"">$\langle Y \rangle$</span> you should note that <span class=""math-container"">$(SH)Z(HS^\dagger) = Y $</span></p>
<p><span class=""math-container"">$$\langle \psi |Y| \psi \rangle = \langle \psi  | (SH)Z (HS^\dagger) | \psi \rangle = \langle \psi SH  | Z |  H S^\dagger   \psi \rangle $$</span></p>
<p>Thus, here you want to apply <span class=""math-container"">$S^\dagger$</span> follow by the Hadamard gate <span class=""math-container"">$H$</span> before measurement.</p>
<p><a href=""https://i.stack.imgur.com/W53qC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/W53qC.png"" alt=""enter image description here"" /></a></p>
",7/30/2021 23:03,Theoretical," The user is asking about theoretical concepts in quantum computing, specifically about the measurement of expectation values of Pauli X and Y operators and how it relates to their code.",Theoretical,,,,Theoretical,
20707.0,Encoding Numeric data as a quantum circuit in TFQ,"<p>I am working on a dataset where I have 6 input features that are numbers in the range of 1 - 1000 that need to be encoded as a quantum circuit. I am using TensorFlow Quantum for my research.
While I have come across papers that explain angle encoding and amplitude encoding quite well, I have not quite been able to understand how to express the math in TFQ.
I went through the Quantum MNIST tutorial on the TFQ pages but the way the images are encoded there is vastly different from how how numeric data rows would be encoded.
Any help guiding me to encode this data would be appreciated!</p>
",<programming><cirq><tfq>,08/03/2021 14:15,20710.0,20710.0,"<p>I can lend some ideas, but since I don't know exactly what you're after I will have to guess a bit.</p>
<p>Looking at the original snippet from the MNIST tutorial:</p>
<pre><code>def convert_to_circuit(image):
    &quot;&quot;&quot;Encode truncated classical image into quantum datapoint.&quot;&quot;&quot;
    values = np.ndarray.flatten(image)
    qubits = cirq.GridQubit.rect(4, 4)
    circuit = cirq.Circuit()
    for i, value in enumerate(values):
        if value:
            circuit.append(cirq.X(qubits[i]))
    return circuit
</code></pre>
<p>It's clear that if a pixel is turned on there is an X gate applied to that qubit. Building off of this we can try something like:</p>
<pre><code>def convert_to_circuit(row):
    &quot;&quot;&quot;Encode a vector with features in [1, 1000] using angle-encoding&quot;&quot;&quot;
    values = (np.ndarray.flatten(row).astype(np.float32) - 1) / 999
    qubits = cirq.GridQubit.rect(1, len(values))
    circuit = cirq.Circuit(cirq.X(q) ** v for v,q in zip(values, qubits))
    return circuit
</code></pre>
<p>Which applies an X rotation on each qubit proportional to that features value (if <code>row[5] == 321</code> then qubit 5 would be given <code>cirq.X ** 0.321</code> and if <code>row[6] == 1000</code> then qubit 6 in the circuit would be given a full <code>cirq.X ** 1.0</code> rotation). Here the rotations are normalized to the range <span class=""math-container"">$[0, 1]$</span>. If I wanted to get them between <span class=""math-container"">$[-\pi, \pi]$</span> we could do something like:</p>
<pre><code>def convert_to_circuit(row):
    &quot;&quot;&quot;Encode a vector with features in [1, 1000] using angle-encoding&quot;&quot;&quot;
    values = (np.ndarray.flatten(row).astype(np.float32) - 1) / 999
    values = values * (2 * np.pi) - np.pi
    qubits = cirq.GridQubit.rect(1, len(values))
    circuit = cirq.Circuit(cirq.rx(v)(q) for v,q in zip(values, qubits))
    return circuit
</code></pre>
<p>This is a rough implementation of &quot;angle encoding&quot; like is talked about <a href=""https://quantumcomputing.stackexchange.com/questions/11370/how-is-data-encoded-in-a-quantum-neural-network"">here</a> or <a href=""https://arxiv.org/pdf/2003.01695.pdf"" rel=""nofollow noreferrer"">here</a>. You could then feed these datapoint circuits into any downstream TFQ model (as long as they acted on the same qubits of course).</p>
<p>For some more ideas check out the scheme used <a href=""https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning"" rel=""nofollow noreferrer"">here</a>  or <a href=""https://github.com/tensorflow/quantum/tree/research"" rel=""nofollow noreferrer"">here</a> it contains a few (decently well written) examples that might give you some inspiration on encoding you data. In general the field doesn't have complete consensus on what &quot;the absolute best encoding to use for all cases&quot; is so you have to try stuff, do some math and see what works. Hope this helps.</p>
<p>-Michael</p>
",08/03/2021 18:21,Tooling," The question is asking about how to use TensorFlow Quantum to encode numeric data as a quantum circuit, which is a tooling topic.",Tooling,,,,Tooling,
20722.0,Defining native gate dictionary in pyGSTi,"<p>In pyGSTi in order to construct Randomized Benchmarking circuits, we first need to define a <code>pspec</code> object that contains information about the number of qubits, basis gates and gate availability.*</p>
<p>In the tutorial notebooks (<a href=""https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb"" rel=""nofollow noreferrer"">https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb</a>), they use a predefined gate dictionary for this, where each gate is called by a certain key (string) and it's value corresponds to the numpy array for the matrix representation of the gate. This does not seem to allow parametrized gates but if we want to characterize for example an ibmq device, then we would need a dictionary for continuously parametrized gates.</p>
<p>I would be really happy, if someone knows how to define a <code>pspec</code> object so that it corresponds to the device, I want run the experiments later on.</p>
<p>*(Interestingly the qubit topology doesn't play a role here, but the sampling algorithms for direct and mirror randomized benchmarking need to work with the topology of the device in order to achieve the desired sampling process of single- and two-qubit gate layers...)</p>
",<programming><quantum-gate><randomised-benchmarking>,08/04/2021 09:54,22106.0,22106.0,"<p>This is a totally reasonable question and request, but unfortunately as of November 2021, pyGSTi doesn't support continuously parameterized gates in any useful way.  It's something we (the Sandia QPL team behind pyGSTi) are working on, because we want to characterize continuously parameterized gates too!  But at this point in time, there aren't really any protocols in the literature for performing QCVV on continously parameterized gates.  Even RB -- which is conceptually a lot easier to generalize to continously parameterized gates than, e.g., GST -- is tricky because you need to derive or choose-and-justify some distribution over the rotation angles that appear in the circuits.  (Obviously you could just pick one... but that's the problem.  You could pick <em>many</em> distributions, and they would give different results.  Which one is &quot;right&quot;?).  This constitutes basically a whole new variant of RB, with all the concomitant theory.  So fundamentally the obstacle isn't about implementation in pyGSTi; it's about the underlying research.</p>
<p>There's a really straightforward workaround, though, which is to just pick a discrete set of gates and work with those.  Any set of gates that generates the Cliffords is sufficient for RB.  Users (including us) do this reasonably frequently with IBM processors.  AFAIK that's how IBM compile their own RB routines used to report device metrics.</p>
",11/28/2021 1:16,Tooling," The question is asking about how to define a pspec object in pyGSTi for a device with parameterized gates, which is a tooling topic.",Tooling,,,,Tooling,
20725.0,Keep receiving Error - AttributeError: 'QuantumCircuit' object has no attribute 'save_statevector',"<p>I am attempting to code a feed-forward simulation of a QECC in Qiskit. Qiskit (to my knowledge) does not directly support feed-forward simulation, so I attempted a work-around. I call the simulator firstly:</p>
<pre><code>    #c/q register
    self.qubits = QuantumRegister(9)
    self.round1 = ClassicalRegister(2)
    self.round2 = ClassicalRegister(3)
    self.decoded = ClassicalRegister(7)
    self.circuit = QuantumCircuit(self.qubits,self.round1,self.round2,self.decoded,name=&quot;circuit&quot;)

    #noise model
    self.noisy = NoiseModel()
    self.error_rate = self.error_rates
    self.error_two_qubit = errors.depolarizing_error(self.error_rate/15, 2)
    self.noisy.add_all_qubit_quantum_error(self.error_two_qubit, ['cx','cz','cy']

    #simulator backend
    self.simulator = Aer.get_backend('qasm_simulator',noise_model=self.noisy)
</code></pre>
<p>Next, I attempt to save the statevector after calling the first stabilizer operator:</p>
<pre><code>    self.circuit.reset(self.qubits[7])
    self.circuit.reset(self.qubits[8])
    self.circuit.h(self.qubits[8])
    self.circuit.cx(self.qubits[8],self.qubits[7])
    self.circuit.cx(self.qubits[target1],self.qubits[7])
    self.circuit.cx(self.qubits[target2],self.qubits[8])
    self.circuit.cx(self.qubits[target3],self.qubits[7])
    self.circuit.cx(self.qubits[target4],self.qubits[8])
    self.circuit.cx(self.qubits[8],self.qubits[7])
    self.circuit.h(self.qubits[8])
    self.circuit.measure(self.qubits[7],self.round1[0])
    self.circuit.measure(self.qubits[8],self.round1[1])
    self.circuit.save_statevector()
</code></pre>
<p>I lastly then attempt to execute the code up to the save-point:</p>
<pre><code>self.result = execute(self.circuit,self.simulator,shots=1).result()
self.statevector = self.result.get_statevector(self.circuit)
</code></pre>
<p>I am not entirely sure why the error I get is of the following form:</p>
<pre><code>Traceback (most recent call last):
self.circuit.save_statevector()
AttributeError: 'QuantumCircuit' object has no attribute 'save_statevector'
</code></pre>
<p>I have looked at the answers from the following URLs:</p>
<ol>
<li><a href=""https://stackoverflow.com/questions/67362847/attributeerror-quantumcircuit-object-has-no-attribute-config"">https://stackoverflow.com/questions/67362847/attributeerror-quantumcircuit-object-has-no-attribute-config</a></li>
<li><a href=""https://githubmemory.com/repo/Qiskit/qiskit-terra/issues/6346?page=2"" rel=""nofollow noreferrer"">https://githubmemory.com/repo/Qiskit/qiskit-terra/issues/6346?page=2</a> .</li>
</ol>
<p>I still am not able to fix the issue. Help would be much appreciated.</p>
",<programming><qiskit><error-correction>,08/04/2021 15:34,20730.0,20730.0,"<p>According to Qiskit's <a href=""https://qiskit.org/documentation/release_notes.html"" rel=""nofollow noreferrer"">release notes</a>, it seems that <code>save_statevector</code> is added in version 0.25 (Aer 0.8.0)</p>
<p>So, upgrading Qiskit should fix this issue.</p>
",08/04/2021 21:03, Errors,"The user is seeking solutions and explanations for an error they encountered in their quantum program development using Qiskit, specifically an AttributeError related to the save_statevector method.", Errors,,,, Errors,
20749.0,Define customized excitation for the unitary coupled-cluster (UCC) algorithm in qiskit,"<p>I encountered the issue that when defining my customized excitation list in the UCC  algorithm, there was only one parameter. How to fix this so that the algorithm assign one parameter for each excitation defined? The code is as follow:</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.drivers import PySCFDriver, UnitsType, QMolecule, FermionicDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock, UCCSD, UCC
from qiskit_nature.transformers import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms.optimizers import L_BFGS_B, SPSA, AQGD, CG, ADAM, P_BFGS, SLSQP, NELDER_MEAD
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.circuit.library import TwoLocal, EfficientSU2
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
matplotlib.use('Agg')


driver = PySCFDriver(atom='H -1.9767, .0, 1.53054; \
                        O  .0, .0, .0; \
                        H 1.9767, .0, 1.53054;',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

at = ActiveSpaceTransformer(8, 5)
ft = FreezeCoreTransformer()

problem = ElectronicStructureProblem(driver, q_molecule_transformers=[ft, at])

# generate the second-quantized operators
second_q_ops = problem.second_q_ops()
main_op = second_q_ops[0]

num_particles = (problem.molecule_data_transformed.num_alpha,
                 problem.molecule_data_transformed.num_beta)

num_spin_orbitals = 2 * problem.molecule_data.num_molecular_orbitals
mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)
qubit_op = converter.convert(main_op, num_particles=num_particles)
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
# print(main_op)

def custom_excitation_list(num_spin_orbitals, num_particles):
   my_excitation_list = [((0, 2, 4, 6), (0 ,2, 4, 7), (0,2,5,6))]

   return my_excitation_list

circ = UCC(qubit_converter=converter, num_particles=num_particles, num_spin_orbitals=num_spin_orbitals, excitations=custom_excitation_list,  reps=1, initial_state=init_state)

print(circ.parameters)
<span class=""math-container"">```</span>
</code></pre>
",<programming><qiskit>,08/06/2021 04:12,20754.0,20754.0,"<p>It looks to me like the format of the excitation list is not very clear. Guessing based on your example I think the correct excitation list should be:</p>
<pre><code>my_excitation_list = [
    ((0, 2), (4, 6)),
    ((0, 2), (4, 7)),
    ((0, 2), (5, 6)),
]
</code></pre>
<p>This code will result in 3 parameters, one per excitation.</p>
<p>Let me try to explain the format above: each entry in the excitation list must be a pair of tuples: <code>( (...), (...) )</code>. The first entry of this pair should contain all orbital indices <em>which are occupied</em>, whereas the second tuple should contain all <em>unoccupied orbitals</em> into which the excitation occurs. Thus, <code>( (0, 2), (4, 6) )</code> will result in the electrons of the orbitals <code>0</code> and <code>2</code> to be excited into the orbitals <code>4</code> and <code>6</code>, making this a double excitation.</p>
<p>I had a quick look at the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.circuit.library.UCC.html"" rel=""nofollow noreferrer"">documentation</a> and noticed that it is referring to another module's documentation which is actually not available in the public docs, but can be found <a href=""https://github.com/Qiskit/qiskit-nature/blob/main/qiskit_nature/circuit/library/ansatzes/utils/fermionic_excitation_generator.py"" rel=""nofollow noreferrer"">in the source code</a>. I have opened an issue to address this, <a href=""https://github.com/Qiskit/qiskit-nature/issues/307"" rel=""nofollow noreferrer"">here</a>.</p>
<p>I hope this clears up any confusion!</p>
",08/06/2021 07:04,Errors,"The user is seeking solutions and explanations for an issue they encountered in their quantum program development using Qiskit, specifically a problem with the number of parameters in a custom excitation list for the UCC algorithm.", Errors,,,,Errors,
20751.0,What is the proper area for a Gaussian Pulse so it will be able to perform a rotation of pi on a qubit?,"<pre><code>with pulse.build(backend, name='hadamard') as h_q0:
    pulse.play(Gaussian(duration=1289, amp=0.99, sigma=32), pulse.drive_channel(0))
   
    reg = pulse.measure(qubit)
    
   
h_q0.draw()
</code></pre>
<p>Above is code that I have for a Gaussian Pulse. How would you change the duration, amp, and sigma parameters, so that the Gaussian Pulse would have the proper area for conducting an X gate on a qubit?</p>
",<programming><qiskit><openpulse>,08/06/2021 05:00,20755.0,20755.0,"<p>There is a dedicated section about this <a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html#calib"" rel=""nofollow noreferrer"">on Qiskit Textbook</a>.</p>
<p>A quick summary:</p>
<ol>
<li>pick a duration and a sigma and make them constant.</li>
<li>apply the Gaussian pulse with several different amplitudes.</li>
<li>recover the results that should look like a sinusoid (Rabi experiment).</li>
<li>the amplitude you are searching for is the period of the sinusoid divided by 2.</li>
</ol>
<p>I cannot possibly include all the details from the Qiskit Textbook in this answer, but the process above is described and illustrated there.</p>
<p>Note also that any pulse duration have to be a multiple of 16 dt. The Gaussian pulse you are using in your question will be rejected by the hardware.</p>
",08/06/2021 07:49, Tooling,"The user is asking about how to use a specific feature of the Qiskit tool, specifically how to adjust the parameters of a Gaussian pulse for an X gate.",Tooling ,,,, Tooling,
20763.0,IBM Quantum: Are ibmq_5_yorktown and ibmqx2 different devices?,"<p>When I run <code>provider.backends()</code>, <code>ibmqx2</code> is listed as an available backend, but is not listed on the <a href=""https://quantum-computing.ibm.com/services?services=systems"" rel=""nofollow noreferrer"">IBMQ systems page</a>. <a href=""https://github.com/Qiskit/ibmq-device-information/tree/master/backends/yorktown/V1"" rel=""nofollow noreferrer"">This file</a> from the archived repository <a href=""https://github.com/Qiskit/ibmq-device-information"" rel=""nofollow noreferrer"">ibmq-device-information</a> associates backend name <code>ibmqx2</code> with display name IBM Q 5 Yorktown. The IBMQ systems page does list a 5 qubit Yorktown device, but under the name <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibmqx2"" rel=""nofollow noreferrer"">ibmq_5_yorktown</a>. This backend is also available via <code>ibmq/open/main</code>, but is not listed by <code>provider.backends()</code>. Are <code>ibmqx2</code> and <code>ibmq_5_yorktown</code> respectively versions 1 and 2 of backend software providing access to a single Yorktown device? Or do these names refer to two distinct Yorktown devices?</p>
",<programming><qiskit><ibm-q-experience>,08/06/2021 21:41,20764.0,20764.0,"<p>Actually, <code>ibmqx2</code> and Yorktown are one quantum processor. When IBM Quantum platform was released, two processors - Yorktown and Tenerife were available. These processor were denoted also <code>ibmqx2</code> and <code>ibmqx4</code>, respectivelly. Note that Tenerife processor is retired now.</p>
<p>If you have a look into IBM Quantum environment, you can see that there is <code>ibmqx2</code> processor in list of available devices. See here:</p>
<p><a href=""https://i.stack.imgur.com/rvWxG.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/rvWxG.png"" alt=""enter image description here"" /></a></p>
<p>When you click on <code>ibmqx2</code>, this page is shown:</p>
<p><a href=""https://i.stack.imgur.com/HVHOV.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/HVHOV.png"" alt=""enter image description here"" /></a></p>
<p>So, it means that <code>ibmqx2</code> and Yorktown are identical devices.
The naming is just a legacy of former times.</p>
<p><em>I would be happy if anybody from IBM can add more comments.</em></p>
",08/06/2021 21:59,Conceptual," The user is seeking conceptual clarification regarding the backend names ""ibmqx2"" and ""ibmq_5_yorktown"" and whether these names refer to different versions of backend software providing access to a single Yorktown device or to two distinct Yorktown devices. This question pertains to understanding the naming and organization of IBM Quantum devices and backends.",Conceptual,,,,Conceptual,
20766.0,Python shorthand for tensor product (Kronecker product),"<p>When using <code>numpy</code> or <code>tensorflow</code> in Python, we can simply write</p>
<pre><code>C = A @ B
</code></pre>
<p>for matrix multiplication <code>C = np.matmul(A,B)</code>. I wonder if there is a shorthand for tensor product (Kronecker product), <span class=""math-container"">$C=A\otimes B$</span> . Now I can only do this by using <code>np.kron(A, B)</code>  or using qutip <code>qutip.tensor(A, B)</code></p>
",<programming><tensor-product><qutip>,08/07/2021 03:54,20776.0,20776.0,"<p>Python currently doesn't support an operator for Kronecker products. Note how the <code>@</code> symbol works: when you write the statement <code>A @ B</code>, Python<span class=""math-container"">$^1$</span> checks the objects <code>A</code> and <code>B</code> for a <code>__matmul__</code> method and then returns <code>A.__matmul__(B)</code>. But there's no built-in operator that corresponds to something like a <code>__kron__</code> method.</p>
<p>If you really want this functionality, one way might be to change how the <code>*</code> operator works by redefining <code>__mul__</code> (e.g. see <a href=""https://stackoverflow.com/questions/40252765/overriding-other-rmul-with-your-classs-mul"">here</a> or <a href=""https://stackoverflow.com/questions/38229953/array-and-rmul-operator-in-python-numpy"">here</a>) to perform a kronecker product, so that calling <code>A * B</code> would return <code>np.kron(A, B)</code>. However this could end up being very confusing for yourself and others reading your code.</p>
<hr />
<p><span class=""math-container"">$^1$</span> as of Python 3.5, see PEP 465: <a href=""https://www.python.org/dev/peps/pep-0465/"" rel=""nofollow noreferrer"">https://www.python.org/dev/peps/pep-0465/</a></p>
",08/07/2021 20:13,Tooling," The user is inquiring about a shorthand or tool for performing the tensor product (Kronecker product) operation in Python, similar to the shorthand for matrix multiplication provided by the ""@"" operator in NumPy and TensorFlow. This question is related to the usage of tools and libraries for mathematical operations in Python.",Tooling,,,,Tooling,
20772.0,Initialization time for StatevectorSimulator Qiskit,"<p>I have a question about initializing a quantum circuit to a custom state using Qiskit's <code>StatevectorSimulator()</code>. My naive understanding is that eventually, the simulator would be doing matrix multiplications on the backend (I might be wrong here, if so please correct me). And thus it seems to me that there should be a way of setting a custom initial state with no extra time cost each time you run the circuit. Here is an example. The following code compares the run time of two circuits: <code>qc_1</code> has initialization to some custom state using <code>qc_1.initialize(state_vec, q_args)</code>, and <code>qc_2</code> which doesn't has such initialization.</p>
<pre><code>import time 
from numpy import pi
from numpy.random import random
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import StatevectorSimulator


qc = QuantumCircuit(16)
# This for loop is irrelevant. Just used to get some nontrivial statevector
for i in range(num_terms):
    rz_pos = (i//2) % 14 + 1
    for j in range(rz_pos): 
        qc.cx(j, j+1)
    qc.rz(pi*random(1)[0], rz_pos)
    for j in range(rz_pos)[::-1]: 
        qc.cx(j, j+1)
    qc.h([*range(rz_pos)])

qc = transpile(qc)  
simulator = StatevectorSimulator()
result = simulator.run(qc).result()
state_vec = result.get_statevector()

qc_1 = QuantumCircuit(16)
qc_1.initialize(state_vec, [*range(16)]) # pylint: disable=no-member

qc_2 = QuantumCircuit(16)

start = time.time()
for i in range(1000): 
    result = simulator.run(qc_1).result()
time_1 = time.time() - start
print(f'time took to run circuit w initialization {1000} times: {round(time_1,3)}s')

start = time.time()
for i in range(1000): 
    result = simulator.run(qc_2).result()
time_2 = time.time() - start
print(f'time took to run circuit w/o initialization {1000} times: {round(time_2,3)}s')
</code></pre>
<p>This gives the following output:</p>
<pre><code>time took to run circuit w initialization 1000 times: 5.93s
time took to run circuit w/o initialization 1000 times: 0.62s
</code></pre>
<p>My assumption is that, using <code>StatevectorSimulator()</code>, there should be a way to set up <code>qc_1</code> such that the initialization process takes virtually no extra time. This way would be just like saying, instead of using the '0' vector to start <em>multiplying</em> the gates to, use the cutom statevector. This way there should be no extra time cost, correct? Again I understand that this way of thinking only applies to <code>StatevectorSimulator()</code>.</p>
",<programming><qiskit>,08/07/2021 15:50,20790.0,20790.0,"<p>The <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html?highlight=quantumcircuit#qiskit.circuit.QuantumCircuit.set_statevector"" rel=""nofollow noreferrer""><code>QuantumCircuit.set_statevector</code></a> method is exactly what you are searching for.</p>
<p>Adding</p>
<pre><code>from qiskit.quantum_info import Statevector
qc_3 = QuantumCircuit(16)
qc_3.set_statevector(state_vec)

start = time.time()
for i in range(1000):
    result = simulator.run(qc_3).result()
time_3 = time.time() - start
print(f&quot;time took to run circuit w set_statevector {1000} times: {round(time_3,3)}s&quot;)
</code></pre>
<p>at the end of your code snippet illustrates how to use it.</p>
<p>On my benchmarks, it is faster than <code>QuantumCircuit.initialize</code> but still way slower than <code>noop</code>:</p>
<pre><code>time took to run circuit w initialization 1000 times: 11.65s
time took to run circuit w/o initialization 1000 times: 1.056s
time took to run circuit w set_statevector 1000 times: 7.663s
</code></pre>
<p>I suspect that copying the statevector is the costly part, but I have no data to backup my claim.</p>
",08/09/2021 08:01,Tooling,"The question is asking about how to initialize a quantum circuit to a custom state using Qiskit's StatevectorSimulator() without incurring any extra time cost, which is a tooling topic.",Tooling,,,,Tooling,
20798.0,Can I extract information from a single shot efficiently?,"<p>I'm running a quantum simulation and want to obtain some information from a single shot of an experiment. Here's part of the code I'm working on:</p>
<pre><code>for i in range(Nshot):
    Expeb = []
    for measure_circuit in [circ_1, circ_2, circ_3, circ_4]:
        measure_circuit = transpile(measure_circuit,backend=backend,optimization_level=2,initial_layout = [1])
        counts = execute(measure_circuit, backend = backend, shots=1).result().get_counts()
        for output in ['0','1']:
            if output not in counts:
                counts[output] = 0
        expe = (counts['0'] - counts['1']) 
        Expeb.append(expe)
    Est = sum(x*y for x,y in zip(Expeb,[a,b,c,d]))
</code></pre>
<p>The code works on simulators, but it might take a very long time if <code>Nshot</code> gets large (Like 5000, I think that's because I generated a lot of circuits) and I submit the jobs to a quantum device. I wonder is there a way I can extract information (like making calculations for) a single shot but in a more efficient way? Thanks for the help!</p>
",<programming><ibm-q-experience><simulation>,08/09/2021 16:17,20799.0,20799.0,"<p>You can use <code>memory</code> option. It will make the per-shot measurement bit-strings returned in the result:</p>
<pre><code>memory = execute(measure_circuit, backend = backend, memory = True, shots = 1024).result().get_memory()
</code></pre>
",08/09/2021 16:33,Tooling,"The user is asking about how to use a specific feature of the Qiskit tool, specifically how to efficiently extract information from a single shot in a quantum simulation",Tooling,,,,Tooling,
20854.0,Simulating OpenQASM 2.0 in Qiskit?,"<p>I'm just getting started with OpenQASM, but I'm feeling a bit confused. Is there a way to run the <code>.qasm</code> file I've written in Qiskit (i.e. in Python), or is OpenQasm only meant to be used within the IBM Quantum experience?</p>
",<programming><qiskit><ibm-q-experience><qasm>,8/17/2021 7:41,20857.0,20857.0,"<p>You can use qasm files to create a quantum circuit, two ways : via the methods <code>from_qasm_str</code> or <code>from_qasm_file</code> on a <code>QuantumCircuit</code>. See the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html?highlight=quantumcircuit#qiskit.circuit.QuantumCircuit.from_qasm_file"" rel=""nofollow noreferrer"">documentation</a> about this. For example :</p>
<pre><code>test = ''' OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[2];
creg c[2];

h q[0];
cx q[0],q[1];
'''
from qiskit import QuantumCircuit
qc = QuantumCircuit.from_qasm_str(test)
</code></pre>
<p>This will create a <code>QuantumCircuit</code> from the str <code>test</code>. The same syntax work with the other method, just replace <code>test</code> with the path to the qasm file.</p>
<p>Hope this helps! :)</p>
",8/17/2021 8:28, Tooling,"The user is asking about how to use a specific feature of the Qiskit tool, specifically how to run a .qasm file in Qiskit (i.e., in Python). ", Tooling,,,, Tooling,
20859.0,Cannot get a provider from IBMQ,"<p>My code is:</p>
<pre><code>    from qiskit import IBMQ
    IBMQ.load_account()
    provider = IBMQ.get_provider('ibm-q')
    qcomp = provider.get_backend('ibmq_16_melbourne')
</code></pre>
<p>but I run it in Jupyter I get the following message</p>
<pre><code>    QiskitBackendNotFoundError                Traceback 
    (most recent call last)
    &lt;ipython-input-6-f874d37829a9&gt; in &lt;module&gt;
      2 IBMQ.load_account()
      3 provider = IBMQ.get_provider('ibm-q')
    ----&gt; 4 qcomp = 
    provider.get_backend('ibmq_16_melbourne')

                                                                        
 
    ~\anaconda3\lib\sitepackages\qiskit\providers
     \providers\provider.py in get_backend(self, name, 
     **kwargs)
     53             raise 
     QiskitBackendNotFoundError(&quot;More than one backend 
     matches the criteria&quot;)
     54         if not backends:
     ---&gt; 55             raise 
     QiskitBackendNotFoundError(&quot;No backend matches the 
     criteria&quot;)
     56 
     57         return backends[0]

     QiskitBackendNotFoundError: 'No backend matches the 
     criteria'
</code></pre>
<p>I have already made an account at IBM, and have already seen the post (<a href=""https://quantumcomputing.stackexchange.com/questions/11966/trying-to-get-a-provider-from-ibmq-but-get-no-provider-matches-the-criteria?newreg=2e701ee65b994f2bb3ac9924e7f2abfc"">Trying to get a provider from IBMQ but get &#39;No provider matches the criteria.&#39;</a>), but the problem still exists.</p>
",<programming><qiskit><ibm-q-experience>,8/17/2021 10:36,20860.0,20860.0,"<p>The backend that you choose ( 'ibmq_16_melbourne' ) was retired recently. With a different backend, it should work. You can find available IBM Quantum systems here.</p>
<p><a href=""https://quantum-computing.ibm.com/services?services=systems"" rel=""noreferrer"">https://quantum-computing.ibm.com/services?services=systems</a></p>
",8/17/2021 11:00,Errors, The user is seeking a solution and explanation for an error they encountered while running their quantum programming code,Errors,,,,Errors,
20862.0,HHL - the result is correct for one matrix but wrong for another one,"<p>I tried to run HHL algorithm in new version of Qiskit (0.29). Firstly I tried to solve a diagonal system 4x4 with matrix <code>[[1,0,0,0],[0,2,0,0],[0,0,3,0],[0,0,0,4]]</code> and right side <code>[1,4,0.5,3]</code>. Clearly, the solution is <code>[1, 2, 0.1667, 0.75]</code>. In this case, everything was according to the expectation. Then I switched to matrix <code>[[-1,2,0,0],[2,-1,2,0],[0,2,-1,2],[0,0,2,-1]]</code> with right side <code>[1,1,1,1]</code>. Expected solution is <code>[0.2, 0.6, 0.6, 0.2]</code>, however <code>[0.0988, 0.1083, 0.119, 0.0884]</code> is returned.</p>
<p>There is no error during a code execution.</p>
<p>Here is my code:</p>
<pre><code>from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, Aer, execute, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.quantum_info import Statevector

from qiskit.algorithms.linear_solvers.hhl import HHL

import numpy as np
import math as m

def dec2bin(decimal, bits): #auxiliary function for conversion dec to bin
    b = bin(decimal)
    b = b[2:len(b)]
    while len(b) &lt; bits:
        b = '0' + b
    return b

processor = Aer.backends(name='qasm_simulator')[0]

#1st linear system
matrix_A = np.array([[1,0,0,0],[0,2,0,0],[0,0,3,0],[0,0,0,4]])
vector_b = np.array([1,4,0.5,3]) #x = [1, 2, 0.1667, 0.75]

#2nd linear system
#matrix_A = np.array([[-1,2,0,0],[2,-1,2,0],[0,2,-1,2],[0,0,2,-1]])
#vector_b = np.array([1,1,1,1])  #x = [0.2, 0.6, 0.6, 0.2]


n = len(matrix_A[2,:]) #number of variables (assuming n=2^k)
qubitsForResults = m.ceil(m.log(n,2)) #number of necessary qubits

bNorm = np.linalg.norm(vector_b) #norm of right-side

hhlSolver = HHL(quantum_instance = processor)
hhlCircuit = hhlSolver.construct_circuit(matrix_A, vector_b) #preparing circuit in general form

circuitToRun = transpile(hhlCircuit,basis_gates=['id', 'rz', 'sx', 'x', 'cx']) #adapt circuit to real quantum processor
circuitToRun.measure_all() #add measurement

#execute the circuit
Shots = 8192
M = execute(circuitToRun, processor, shots = Shots).result().get_counts(circuitToRun)

usedQubits = circuitToRun.width()/2 #width - num of qubits and classical bit summed
zeros = dec2bin(0,usedQubits - qubitsForResults - 1) #working qubits

for i in range(0,n):
    #ancilla qubit has to be |1&gt;, working qubits |0&gt;, results are in last &quot;qubitsForResults&quot; qubits
    #e.g. if qubitsForResults and total qubits is 6, then 3 are working qubits
    #results are stored in |1 000 00&gt;, |1 000 01&gt;, |1 000 10&gt;, |1 000 11&gt;
    indx = '1' + zeros + dec2bin(i,qubitsForResults)
    #bNorm*m.sqrt(M[indx]/Shots) - we need probability amplitudes =&gt; sqrt
    #and adjust them by norm of vector b to get &quot;unnormalized&quot; solution x
    print('x_' + str(i) + ': ' + str(round(bNorm*m.sqrt(M[indx]/Shots),4)))
</code></pre>
<p><em>Note that my code works only in case the solution of the system is real and non-negative.</em></p>
<p>Could anybody help me to understand where is a mistake?</p>
<hr />
<p><strong>EDIT:</strong>
I also tried to use matrix <code>[[1,0,0,0],[0,2,0,0],[0,0,3.5,-0.5],[0,0,-0.5,3.5]]</code> with right side <code>[1 1 1 1]</code>, expected solution is <code>[1 0.5 0.333 0.333]</code>. In this case the code works fine. I prepared this matrix by a unitary transformation of <span class=""math-container"">$\text{diag}(1,2,3,4)$</span>. As a result, eigenvalues of the matrix are 1, 2, 3 and 4. So, it seems that the code works correctly if the matrix of the linear system has interger eigenvalues. I observed similar behavior also for 2x2 matrices.</p>
<p><strong>Is it possible that the errors are caused by lack of qubits used for eigenvalue approximation? In case of integer eigenvalues, there is no loss of accuracy if we have enough qubits. In this case the max. eigenvalue is 4 (100b), so three working qubits are sufficient.</strong></p>
<hr />
<p><strong>EDIT 2:</strong>
I experimented further with 2x2 matrices and directly with state vector instead of probabilities. I found out that (note that right side is <code>[1, 1.2]</code>):</p>
<ul>
<li>if matrix is <code>[[1.5, 0.5],[0.5, 1.5]]</code> then HHL returns correct result, note that eigenvalues of the matrix are 1 and 2</li>
<li>for matrix <code>[[2.5, 1.5],[1.5, 2.5]]</code> everything is also fine, eigenvalues are 4 and 1</li>
<li>for matrix <code>[[2/3, -1/3],[-1/3, 2/3]]</code> the results are wrong, eigenvalues are 1/3 and 1</li>
<li>finally, for matrix <code>[[-0.5, -1.5],[-1.5, -0.5]]</code> the result is <code>(0.45, 0.65)</code> but expected is <code>(-0.65, -0.45)</code>, eigenvalues of the matrix are -2 and 1. Result <code>(0.45, 0.65)</code>  is same as in case of matrix from the first bullet point with eigenvalues 1 and 2</li>
</ul>
<p>To conclude, it seems that HHL works well only for matrices with positive integer eigenvalues.</p>
<p>I also had a look at the circuits prepared with HHL method and realized that number of working qubits is equivalent to <span class=""math-container"">$\log_2(\max\{|\lambda_i|\})$</span>. There is no qubit for sign or additional qubits to represent fractional eigenvalues.</p>
<p><strong>So, am I right that current HHL implementation in Qiskit is intended only for matrices with positive integer eigenvalues?</strong></p>
",<programming><qiskit><ibm-q-experience><hhl-algorithm>,8/17/2021 11:50,20982.0,20982.0,"<p>Based on comment by <em>Lena</em>, I found out that HHL implementation in Qiskit cannot be used for matrices with negative eigenvalues for time being. As stated <a href=""https://github.com/Qiskit/qiskit-terra/issues/6880"" rel=""nofollow noreferrer"">here</a></p>
<blockquote>
<p>The current version of HHL doesn't support matrices with negative eigenvalues, which seems to be the reason this example is failing. That's a feature we're looking to integrate and will soon be working on!</p>
</blockquote>
<p>During experiments, I also realized that current Qiskit HHL implementation has sometimes difficulties with matrices having non-integer eigenvalues. So, this seems to a matter of accuracy and low number of available qubits.</p>
<p><strong>To conclude, my code works well, however, I used it in cases the current HHL implementation is not suitable for.</strong></p>
",8/26/2021 13:11,Errors,The user is encountering unexpected results when running the HHL algorithm in Qiskit and is seeking help to understand where the mistake might be in their code or if there is a limitation in the HHL implementation.,Errors,,,,Errors,
20873.0,How to design Multi qubit Controlled Z rotations,"<p>I need some help in multi-qubit controlled -Z rotation.
Below is the qiskit code of triple controlled z rotation</p>
<pre><code>def cccZ():                                      
qc = QuantumCircuit(4)
qc.cp(pi/4, 0, 3)            

qc.cx(0, 1)
qc.cp(-pi/4, 1, 3)

qc.cx(0, 1)
qc.cp(pi/4, 1, 3)

qc.cx(1, 2)
qc.cp(-pi/4, 2, 3)

qc.cx(0, 2)
qc.cp(pi/4, 2, 3)

qc.cx(1, 2)
qc.cp(-pi/4, 2, 3)

qc.cx(0, 2)
qc.cp(pi/4, 2, 3)


gate = qc.to_gate(label=' cccZ')
return gate
</code></pre>
<p>Please help me in modifying this code to hexa qubit z rotation? It would be really great if someone can explain its theory also. I am really struggling with random nature of quantum computing with no fixed pattern at all.</p>
",<programming><qiskit><quantum-gate>,8/19/2021 4:09,20874.0,20874.0,"<p>The mostly flexible way to create gates beyond the ones included as methods is with the circuit library:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import ZGate

circuit = QuantumCircuit(7)
c6z = ZGate().control(6)
circuit.append(c6z, range(7))
circuit.draw()
</code></pre>
<pre><code>q_0: ââ â
      â 
q_1: ââ â
      â 
q_2: ââ â
      â 
q_3: ââ â
      â 
q_4: ââ â
      â 
q_5: ââ â
      â 
q_6: ââ â
</code></pre>
<p>The decomposition of this gate is deep:</p>
<pre><code>circuit.decompose().depth()
</code></pre>
<pre><code>315
</code></pre>
<h3>How to construct multi-controlled gates, in general</h3>
<p>Any single-qubit gate can be arbitrarily-n-controlled with <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.Gate.html?#qiskit.circuit.Gate.control"" rel=""nofollow noreferrer"">the method <code>Gate.control</code></a>. The parameter <code>n</code> sets the amount of controlled qubits. As a consequence, the resulting controlled-gate will be a n-plus-one-qubits gate.</p>
<pre><code>from qiskit.circuit.library import &lt;some&gt;Gate
cN_gate = &lt;some&gt;Gate(&lt;gate_params&gt;).control(&lt;n&gt;)
print(cN_gate.num_qubits)  # n+1
</code></pre>
<p>You can append this custom gate to a circuit using <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.append"" rel=""nofollow noreferrer"">the <code>QuantumCircuit.append</code> method</a>:</p>
<pre><code>circuit.append(cN_gate, [....., i])
                         \_n_/
</code></pre>
<p>The first <span class=""math-container"">$n$</span> parameters are the qubits in which you want to control. The last one (<code>i</code>) is the target qubit.</p>
",8/19/2021 5:20, Conceptual,"The user is seeking help with modifying a quantum circuit to perform a hexa-qubit Z rotation and is also looking for an explanation of the theory behind it, indicating a need for conceptual understanding and guidance in quantum computing.",Conceptual,,,, Conceptual,
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"<p>So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system?</p>
<p>Below you can see the code idea:</p>
<pre><code>q1 = QuantumCircuit(2)
q1.save_statevector() # Save initial state
q1.h(0)
q1.save_statevector() # Save state after Hadamard
q1.cx(0, 1)
q1.save_statevector() # Save state after CNOT (also a final state)
job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024)
statevectors = job.result().get_statevector()
</code></pre>
<p>However, if I were to try and run this, an error occurs upon reaching <code>execute</code> command.
If anyone can provide any insight on this, I would be very grateful.</p>
",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"<p>You can also obtain the states at any point during circuit construction using <code>Statevector</code>, the class from Qiskit's quantum_info module as follows.</p>
<p>First, import the <code>Statevector</code> class,</p>
<pre><code>from qiskit.quantum_info import Statevector
</code></pre>
<p>And for your example, the code below will produce all the intermediate states that you want.</p>
<pre><code>qc = QuantumCircuit(2)
st0 = Statevector.from_instruction(qc) 
qc.h(0)
st1 = Statevector.from_instruction(qc)
qc.cnot(0, 1)
st2 = Statevector.from_instruction(qc)

print(st0)
print(st1)
print(st2)


Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
        dims=(2, 2))
Statevector([0.70710678+0.j, 0.70710678+0.j, 0.             +0.j,
         0.        +0.j],
        dims=(2, 2))
Statevector([0.70710678+0.j, 0.        +0.j, 0.        +0.j,
         0.70710678+0.j],
        dims=(2, 2))
</code></pre>
",8/25/2021 13:41,API Usage, The user is encountering an issue related to using Qiskit's API to save intermediate statevectors at different points in a quantum circuit. They are seeking guidance on how to correctly use the API for this purpose., Errors,"The user is encountering an error when attempting to save statevectors at multiple points in their quantum circuit and is seeking help to resolve this issue, which falls under the Errors category.",No,114.0,Errors,"The user is encountering an error when attempting to save statevectors at multiple points in their quantum circuit and is seeking help to resolve this issue, which falls under the Errors category as they are seeking assistance with a specific problem they are facing."
20904.0,Q# install issue,"<p>I have followed the instructions to install Q# using conda as recommended, and given by MS. When I try to import <code>qsharp</code> from my virtual env within a Python program, I get the following error:</p>
<pre><code>Microsoft.Quantum.IQSharp.Workspace[0] QS5022: No identifier with the name âvâ exists.
</code></pre>
<p>Does any one have experience of this issue please?  I have googled it but to no avail.</p>
<p>I use .NET run perfectly with <code>example.qs</code> and <code>example.csproj</code> files, but I would like to work within VSCode.
(Ubuntu v. 20.04, .NET SDK v. 3.1, Python v. 3.7 + latest Miniconda)</p>
",<programming><q#>,8/21/2021 15:38,20938.0,20938.0,"<p>When you call <code>import qsharp</code>, it will try to compile the <code>.qs</code> files in the current folder so the corresponding operations are available from Python. It seems the Q# compiler is having some problems with one of the files.
Try to see if any of the <code>.qs</code> files in the directory have any syntax errors, and try removing the <code>obj</code> folder with temporary files if it exists.</p>
",8/23/2021 15:27, Errors, The user is encountering an error while trying to import the Q# package in a Python program. They are seeking a solution and explanation for this issue,Errors,,,, Errors,
20906.0,How to execute a qiskit circuit from strangeworks hub?,"<p>I would like to execute a circuit in the strangeworks hub on IBM's &quot;ibm_nairobi&quot; system.</p>
<p>Could someone just please send me a general layout of execute and provide a command for stangeworks hub?</p>
",<programming><qiskit><ibm-q-experience>,8/22/2021 6:27,20946.0,20946.0,"<p>First, make sure to sync your IBMQ account. You can add in your IBMQ API token:</p>
<p><a href=""https://i.stack.imgur.com/XLDDN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XLDDN.png"" alt=""enter image description here"" /></a></p>
<p>Once you do this, you can click on the hardware tab and see that your IBM Q account has linked to here.</p>
<p><a href=""https://i.stack.imgur.com/UG7jA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UG7jA.png"" alt=""enter image description here"" /></a></p>
<p>Now you can create and run your circuit as the template given to your by StrangeWork:</p>
<p><a href=""https://i.stack.imgur.com/Up95l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Up95l.png"" alt=""enter image description here"" /></a></p>
<pre><code>import strangeworks.qiskit
import qiskit

qc = qiskit.QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])

# uncomment the next line if you have more than one account
# backend = strangeworks.qiskit.get_backend(&quot;ibmqx2&quot;, account_id=&quot;ibm&quot;)
backend = strangeworks.qiskit.get_backend(&quot;ibmq_bogota&quot;)

job = qiskit.execute(qc, backend, shots=50)
result = job.result()
print(&quot;result:&quot;, result)
counts = result.get_counts()
print(&quot;counts:&quot;, counts)
</code></pre>
<p>If you check your IBMQ job status, then you will see the StrangeWork tag in your job:</p>
<p><a href=""https://i.stack.imgur.com/Y8QRo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Y8QRo.png"" alt=""enter image description here"" /></a></p>
<p>Upon completion of your job, you can view your result just as you would through Qiskit.</p>
<p><a href=""https://i.stack.imgur.com/IpX7j.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IpX7j.png"" alt=""enter image description here"" /></a></p>
",8/24/2021 6:15,Tooling,"The user is seeking guidance on how to execute a quantum circuit on the IBM ""ibm_nairobi"" system using Strangeworks Hub. This falls under the tooling category as it pertains to using specific tools and software for quantum programming.",Tooling,,,,Tooling,
20952.0,Are these two circuits equivalent in performing controlled time-evolution?,"<p>I want to perform the controlled time-evolution of some 2 or 3-qubit Hamiltonian. Say we have this example:
<span class=""math-container"">$$
H= Z_0\otimes Z_1 + Z_1\otimes Z_2
$$</span>
The circuit performing the time-evolution controlled by qubit 3 could be generated as (the arguments of R_Z gate are randomly chosen to be pi):</p>
<pre><code>qrz = QuantumRegister(4,'q')
crz = ClassicalRegister(1,'c')
qcz = QuantumCircuit(qrz,crz)
qcz.cx(0,1)
qcz.crz(np.pi,3,1)
qcz.cx(0,1)
qcz.cx(1,2)
qcz.crz(np.pi,3,2)
qcz.cx(1,2)
qcz.draw(output = 'mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/KRKMz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KRKMz.png"" alt=""enter image description here"" /></a></p>
<p>However, I wonder is it possible that we can turn the circuit responsible for time-evolution directly into a quantum gate, and then the gate is controlled by qubit 3? Here's what I tried:</p>
<pre><code>my_circ = QuantumCircuit(3)
my_circ.cx(0,1)
my_circ.rz(np.pi,1)
my_circ.cx(0,1)
my_circ.cx(1,2)
my_circ.rz(np.pi,2)
my_circ.cx(1,2)
my_circ.draw(output = 'mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/R6POf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/R6POf.png"" alt=""enter image description here"" /></a></p>
<p>Then I have</p>
<pre><code>new_circ = QuantumCircuit(4)
new_circ.append(custom,[3,2,1,0])
new_circ.draw(output = 'mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/FzRQ2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FzRQ2.png"" alt=""enter image description here"" /></a></p>
<p>Are the two circuits <code>qcz</code> and <code>new_circ</code> equivalent? Generally, if I know how to construct the quantum circuit for the time evolution of some Hamiltonian but don't know exactly how to perform controlled time-evolution, can I just transform the time-evolution circuit into a gate, and then do something similar to this example? Thanks for the help!</p>
",<programming><qiskit><quantum-gate><ibm-q-experience><hamiltonian-simulation>,8/24/2021 17:57,20953.0,20953.0,"<p>Yes, they should be.</p>
<p>You can check their statevector to confirm that they indeed generate the same state. First, you can generate some <strong>arbitrary</strong> initial state and use the following two methods to show that they generate the same statevector.  For instance:</p>
<pre><code>init_circ = QuantumCircuit(3)
init_circ.ry(2.5,0)
init_circ.ry(1.2, 1)
init_circ.ry(0.5, 2) 
print(init_circ)
     âââââââââââ
q_0: â¤ RY(2.5) â
     âââââââââââ¤
q_1: â¤ RY(1.2) â
     âââââââââââ¤
q_2: â¤ RY(0.5) â
     âââââââââââ
                    


my_circ = QuantumCircuit(3)
my_circ.cx(0,1)
my_circ.rz(np.pi,1)
my_circ.cx(0,1)
my_circ.cx(1,2)
my_circ.rz(np.pi,2)
my_circ.cx(1,2)
print(my_circ)

                                           
q_0: âââ ââââââââââââââ âââââââââââââââââââââ
     âââ´ââââââââââââââ´ââ                   
q_1: â¤ X ââ¤ RZ(Ï) ââ¤ X ââââ ââââââââââââââ ââ
     ââââââââââââââââââââââ´ââââââââââââââ´ââ
q_2: ââââââââââââââââââââ¤ X ââ¤ RZ(Ï) ââ¤ X â
                        âââââââââââââââââââ



xs_gate = my_circ.to_gate()
cxs_gate = xs_gate.control()
circuit = QuantumCircuit(4) 
circuit.append(init_circ, [1,2,3]) 
circuit.append(cxs_gate, [0,1,2,3])
print(circuit)

                                     
q_0: ââââââââââââââââââââââââ ââââââââ
     ââââââââââââââââââââââââ´ââââââââ
q_1: â¤0             ââ¤0             â
     â              ââ              â
q_2: â¤1 circuit-155 ââ¤1 circuit-156 â
     â              ââ              â
q_3: â¤2             ââ¤2             â
     ââââââââââââââââââââââââââââââââ

from qiskit.quantum_info import Statevector
circuit_statevector = Statevector(circuit)
print(circuit_statevector )
Statevector([0.25215633+0.j, 0.        +0.j, 0.75888206+0.j,
             0.        +0.j, 0.17250943+0.j, 0.        +0.j,
             0.51917915+0.j, 0.        +0.j, 0.06438608+0.j,
             0.        +0.j, 0.1937744 +0.j, 0.        +0.j,
             0.04404889+0.j, 0.        +0.j, 0.1325682 +0.j,
             0.        +0.j],
            dims=(2, 2, 2, 2))
</code></pre>
<p><strong>Note:</strong> I added a layer of some arbitrary <span class=""math-container"">$RY$</span> rotations at the beginning just so that we don't start at the <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>And for the other circuit you have:</p>
<pre><code>qcz = QuantumCircuit(4)
qcz.ry(2.5,1)
qcz.ry(1.2, 2)
qcz.ry(0.5, 3)
qcz.cx(1,2)
qcz.crz(np.pi,0,2)
qcz.cx(1,2)
qcz.cx(2,3)
qcz.crz(np.pi,0,3)
qcz.cx(2,3)
print(qcz)
                                                      
q_0: âââââââââââââââââââââ âââââââââââââââââââ âââââââââ
     âââââââââââ         â                  â         
q_1: â¤ RY(2.5) ââââ âââââââ¼âââââââ ââââââââââââ¼âââââââââ
     âââââââââââ¤âââ´âââââââ´âââââââ´ââ         â         
q_2: â¤ RY(1.2) ââ¤ X ââ¤ RZ(Ï) ââ¤ X ââââ âââââââ¼âââââââ ââ
     âââââââââââ¤ââââââââââââââââââââââ´âââââââ´âââââââ´ââ
q_3: â¤ RY(0.5) âââââââââââââââââââââ¤ X ââ¤ RZ(Ï) ââ¤ X â
     âââââââââââ                   âââââââââââââââââââ

qcz_statevector = Statevector(qcz)
print(qcz_statevector )
Statevector([0.25215633+0.j, 0.        +0.j, 0.75888206+0.j,
             0.        +0.j, 0.17250943+0.j, 0.        +0.j,
             0.51917915+0.j, 0.        +0.j, 0.06438608+0.j,
             0.        +0.j, 0.1937744 +0.j, 0.        +0.j,
             0.04404889+0.j, 0.        +0.j, 0.1325682 +0.j,
             0.        +0.j],
            dims=(2, 2, 2, 2))
</code></pre>
<p><strong>Notice how the two statevectors are the same</strong>. This is because the two circuits are equivalent.</p>
<hr />
<hr />
<h3>Update:</h3>
<p>I didn't think much when I answered this, and knew that the two circuits were equivalent to start so I just tested it out using the method above. Which is kinda convoluted. The other answer used <code>Operator</code> from <code>quantum_info</code> to show that the two operators are indeed equivalent is much better as it show they are two equivalent unitary matrix. There is a another method to do this, and I will provide it below:</p>
<pre><code>qcz = QuantumCircuit(4)
qcz.cx(1,2)
qcz.crz(np.pi,0,2)
qcz.cx(1,2)
qcz.cx(2,3)
qcz.crz(np.pi,0,3)
qcz.cx(2,3)
backend = Aer.get_backend('unitary_simulator')
job = execute(qcz, backend)
result = job.result()
qcz_unitary  = result.get_unitary(qcz, decimals=3)


my_circ = QuantumCircuit(3)
my_circ.cx(0,1)
my_circ.rz(np.pi,1)
my_circ.cx(0,1)
my_circ.cx(1,2)
my_circ.rz(np.pi,2)
my_circ.cx(1,2)
xs_gate = my_circ.to_gate()
cxs_gate = xs_gate.control()
circuit = QuantumCircuit(4) 
circuit.append(cxs_gate, [0,1,2,3])
backend = Aer.get_backend('unitary_simulator')
job = execute(circuit, backend)
result = job.result()
circuit_unitary  = result.get_unitary(circuit, decimals=3)
</code></pre>
<p>Now you can check that the two operators, <code>qcz_unitary</code> and <code>circuit_unitary</code>, represent the two circuits are equivalent.</p>
<p>Also note that these two circuits are equivalent fundamentally as pointed out by DaftWullie in this answer. Here, we are just checking to make sure what being implemented in Qiskit is correct.</p>
",8/24/2021 18:49,Conceptual ,The user is seeking to understand the equivalence of two quantum circuits and the general approach to transforming a time-evolution circuit into a controlled gate in quantum computing.,Conceptual,,,,Conceptual ,
20978.0,Return only the measurements of a circuit,"<p>I have written the following program in jupyter:</p>
<pre><code>from qiskit import *
from qiskit import plot_histogram, matplotlib

circuit = QuantumCircuit(16,16) #Making a circuit with 16 qubits
qr = QuantumRegister(16)
cr = ClassicalRegister(16)
for i in range(16):
    circuit.h(i)
    circuit.measure(i,i)

simulator = Aer.get_backend('qasm_simulator')
result = execute(circuit, backend = simulator, shots = 200).result()
counts = result.get_counts()
print(counts)
</code></pre>
<p>and the output is of the form :</p>
<pre><code>{'0111001100011110': 1, '0101000101101001': 1, '1100010111000100': 1, 
'0111111110101110': 1,..., '0110110010010110': 1}
</code></pre>
<p>Is there any way that what I get as an output is the measurement only (e.g. '0111001100011110')  without getting the times the measurement has appeared (: 1)?</p>
",<programming><qiskit><measurement>,8/26/2021 7:02,20980.0,20980.0,"<p>You can take only the keys of the returned dictionary:</p>
<pre><code>measurements = set(counts.keys())
print(measurements)
</code></pre>
<p>If you want only one random key, you can just take the first one in the set:</p>
<pre><code>random_key = next(iter(a))
</code></pre>
<p>or store all the keys in a list and take a random one from here:</p>
<pre><code>from random import randint
measurements_list = list(measurements)
random_key = measurement_list[randint(0, len(measurement_list)-1)]
</code></pre>
",8/26/2021 7:37,API Usage,The user is seeking guidance on how to modify the output of their Qiskit program to display only the measurement results without the count of occurrences. This involves understanding how to use the Qiskit API effectively,API Usage,,,,API Usage,
20983.0,Get the probability amplitudes of the 0 and 1 states of a single qubit in Qiskit considering a system of multiple qubits,"<p>I am looking for a method to get the values of <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> probability amplitudes of each single qubit in a multiple qubit system. Is that possible?<a href=""https://i.stack.imgur.com/LuLrq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LuLrq.png"" alt=""enter image description here"" /></a></p>
<p>As you can see in the image, I have a 4-qubit quantum circuit. I want to read the values of the amplidues in each qubit individually.</p>
<p>Here I used the Aer simulation for getting the statevector, but this for the states of the whole quantum system, i.e. 0000, 0001, 0010, ..., 1111, if I get this right.</p>
<p><a href=""https://i.stack.imgur.com/PD9Cr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PD9Cr.png"" alt=""Code"" /></a></p>
<p><a href=""https://i.stack.imgur.com/xoMwu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xoMwu.png"" alt=""Output"" /></a></p>
",<programming><qiskit><quantum-state>,8/26/2021 15:15,20994.0,20994.0,"<p>It is always useful to check the documentation: <a href=""https://qiskit.org/documentation/_modules/qiskit/visualization/state_visualization.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/_modules/qiskit/visualization/state_visualization.html</a>  You can see there the source code for all visualization tools in <code>qiskit.visualization</code>.</p>
<p>The function <code>plot_bloch_multivector</code>  is somehow factorizing the state and converting the statevector data into products of individual qubit vectors in the Bloch sphere.</p>
<p>The steps are the following, import the factorization routine called <code>_bloch_multivector_data</code> as follows:</p>
<p><code>from qiskit.visualization.utils import _bloch_multivector_data</code></p>
<p>and then store the data of your multivector called <code>state</code> as</p>
<p><code>bloch_data = (_bloch_multivector_data(state))</code></p>
<p>each <code>bloch_data[i]</code>, for <code>i</code>=0,1,2,3 has three entries with correspond  to the  <code>i</code>-th qubit in Cartesian coordinates (<span class=""math-container"">$x,y,z$</span>), which can be used to get the angles.</p>
<p>For example if you chose qubit 2
<code>qubitvector=bloch_data[2]</code>
then its coordinates are :</p>
<ul>
<li><code>qubitvector_x=qubitvector[0]</code> for <span class=""math-container"">$x$</span>,</li>
<li><code>qubitvector_y=qubitvector[1]</code> for <span class=""math-container"">$y$</span>,</li>
<li><code>qubitvector_z=qubitvector[2]</code> for <span class=""math-container"">$z$</span>.</li>
</ul>
<p>The angles can be retrieved by looking at the definition of the spherical coordinates (in a unit sphere):</p>
<ul>
<li>the azimuthal angle is given by <span class=""math-container"">$\tan \varphi = y/x$</span>, and</li>
<li>the polar angle is given by <span class=""math-container"">$\cos \theta = z$</span>.</li>
</ul>
<p>Disclaimer: this procedure works only for products of single qubit states. This procedure will not work if you use any entangling gates (gates that apply to more than one qubit like CNOT) in your quantum circuit.</p>
",8/27/2021 10:14, Conceptual,The user is seeking to understand how to obtain the probability amplitudes of individual qubits in a multiple qubit system. This is a conceptual question that requires an understanding of the quantum statevector and how to manipulate it.,Theoretical,"The user is asking about theoretical concepts in quantum computing, specifically about the probability amplitudes of each single qubit in a multiple qubit system",No,115.0, Conceptual,"The user is seeking to understand how to obtain the probability amplitudes of individual qubits in a multiple qubit system, indicating a conceptual inquiry into quantum state manipulation and measurement, rather than a purely theoretical discussion."
21001.0,Passing arrays to operations/functions in Q# Jupyter Notebooks,"<p>In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, <code>%simulate</code>, and writes out the inputs as key-value pairs, <code>key=value</code>.</p>
<p>For example, if I had some operation, operation <code>HelloHardy (number : Int) : Unit {...}</code>, then I would run the following <code>%simulate HelloHardy number=1729</code>.</p>
<p>I am currently working with the operation, <code>EvaluatePolynomial</code>, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated.</p>
<pre><code>%simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false.

Received invalid parameters. Please fix and try again:

 coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.

 evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.
</code></pre>
",<programming><q#>,8/28/2021 19:51,21010.0,21010.0,"<p>IQ# magics don't support passing arrays as parameters at the moment. When I need to pass something more complicated than a scalar, I usually define a wrapper operation that defines all parameters and calls the original operation, and call <code>%simulate</code> for that wrapper operation.</p>
",8/29/2021 17:56,Errors,The user is encountering an error while trying to pass inputs to a Q# operation in a Jupyter Notebook. They are seeking a solution and explanation for this issue,Errors,,,,Errors,
21039.0,What is difference between qasm_simulator and ibmq_qasm_simulator?,"<p>There are many ways how to simulate a quantum circuit on IBM Q. However, in partiuclar I am interested in a difference between <code>qasm_simulator</code> and <code>ibmq_qasm_simulator</code>.</p>
<p>In Qiskit, the former can be called with statement</p>
<pre><code>processor = Aer.backends(name = 'qasm_simulator')[0]
</code></pre>
<p>while the latter with</p>
<pre><code>provider = IBMQ.load_account()
processor = provider.backends(name='ibmq_qasm_simulator')[0]
</code></pre>
<p>I realized that <code>ibmq_qasm_simulator</code> sends jobs similarly to a real quantum processor, i.e. I see the job in Job pane in IBM Q environment. But this is not the case for <code>qasm_simulator</code>.</p>
<p>In list of services on IBM Q page I found out only one <code>qasm_simulator</code>. So, my question is how these two simulators differ?</p>
",<programming><qiskit><ibm-q-experience><simulation>,09/01/2021 13:53,21040.0,21040.0,"<p><code>ibmq_qasm_simulator</code> performs the simulation on a classic computer on that resides on the cloud, whereas <code>qasm_simulator</code> does it locally on your computer and consumes your CPU.</p>
",09/01/2021 14:21,API Usage,"The user is asking about the difference between two APIs (qasm_simulator and ibmq_qasm_simulator) in the Qiskit library for quantum computing, which falls under the usage of APIs in quantum programming",API Usage,,,,API Usage,
21056.0,Can I use `job_manager` to get memories for 3 parts of the experiment?,"<p>Here's part of the code I'm working on:</p>
<pre><code>all_circuits = []
for _ in range(100):
    all_circuits.extend([quanc_z,quanc_x,quanc_y])
all_circuits = transpile(all_circuits, backend=backend)
MExperiments = job_manager.run(all_circuits, backend=backend, shots = 1024)
results = meas_filter.apply(MExperiments.results())
memory_z = results.get_memory()
memory_x = results.get_memory() 
memory_y = results.get_memory()   # Question
</code></pre>
<p>I have a list of quantum circuits <code>all_circuits</code> composed of the repeating circuit sequence <code>quanc_z(,x,y)</code> and I'm trying to run them using qiskit <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.ibmq.managed.IBMQJobManager.html"" rel=""nofollow noreferrer"">job_manager</a>. I applied the readout error mitigation to the results and I want to <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.html#qiskit.result.Result.get_memory"" rel=""nofollow noreferrer"">get the memories</a> of each quantum circuit in <code>all_circuits</code>, and combine the memories with the same label <code>z,x,y</code> on their associated circuits. I wonder is there a way I can get the memory for each circuit that I submitted in a bundle using job manager? Thanks for the help!!</p>
",<programming><qiskit><ibm-q-experience>,09/02/2021 23:31,21063.0,21063.0,"<p>Yes, but it has more to do with extracting data from the result and not so much with job manager.</p>
<p>Method 1, use the circuit index. If your circuits are always in the z, x, y order, then you can do something like</p>
<pre><code>memory_z = []
memory_x = []
memory_y = []

for i in range(len(all_circuits)):
    mem = results.get_memory(i)
    if i % 3 == 0:
        memory_z.append(mem) # or however you want to combine them
    elif i % 3 == 1:
        memory_x.append(mem)
    else:
        memory_y.append(mem)
</code></pre>
<p>Method 2, assign metadata to each circuit and use that to differentiate individual result data, something like</p>
<pre><code>quanc_z.metadata = {&quot;tag&quot;: &quot;z&quot;}
quanc_x.metadata = {&quot;tag&quot;: &quot;x&quot;}
quanc_y.metadata = {&quot;tag&quot;: &quot;y&quot;}

combined = results.combine_results()
for i, r in enumerate(combined.results):
    if r.header.metadata[&quot;tag&quot;] == &quot;z&quot;:
        memory_z.append(results.get_memory(i))
    ...  # repeat for the other 2
</code></pre>
<p>2 additional things to note:</p>
<ol>
<li><p>You need a lower measurement level or <code>memory=True</code> in your <code>job_manager.run()</code> to get memory data. See the <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.html#qiskit.result.Result.get_memory"" rel=""nofollow noreferrer""><code>get_memory</code> doc</a> for more details.</p>
</li>
<li><p>Measurement correction fitters in qiskit-ignis, if that's what you're using, usually takes a <code>Result</code> object as an input. Job manager, on the other hand, returns a <code>ManagedResults</code> object. But you can use the <code>combine_results()</code> method to convert a <code>ManagedResults</code> to a <code>Result</code>:</p>
</li>
</ol>
<pre><code>managed_result = job_manager.run(...).results()
result_to_fitter = managed_result.combine_results()
</code></pre>
<p>This <code>combine_results()</code> was needed in method 2 above because <code>ManagedResults</code> doesn't have the <code>results</code> attributes.</p>
",09/03/2021 14:01,API Usage,"This question falls under the ""API Usage"" category because it is seeking guidance on how to use the Qiskit API, specifically the job_manager, to retrieve memory information for multiple quantum circuits that were submitted in a bundle.", API Usage,,,,API Usage,
21058.0,How is quantum transpilation scaled?,"<p>While thinking about a quantum transpiler's working I had a pretty basic doubt. Say that we are trying to transpile an <span class=""math-container"">$n$</span> qubit circuit where <span class=""math-container"">$n &gt; 100$</span>. What transpiler does is that it first tries to find a mapping, decompose the gates into basis set of the quantum computer and then tries to optimize the circuit for a reduced depth. My question is that since transpilation is done <em>classically</em>, isn't there going to be a limit to the circuits that we can optimize?</p>
<p>My understanding is that if we want to optimize the running of a quantum circuit and try to reduce its gate count or depth, won't we need to have <span class=""math-container"">$2^n \times 2^n$</span> size tensors in memory for that to be carried out? We would try to see if a particular computation is redundant or a better gate sequence can carry out the same with a lesser number of gates.</p>
<p>Or is it carried out through pure textual formats eg. optimizations based on a sequence of gate <em>names</em> instead of matrices? Sorry if I'm missing something fundamental here.</p>
<p>Thanks!</p>
",<programming><qiskit><quantum-circuit><transpile>,09/03/2021 08:01,21061.0,21061.0,"<p>tl;dr
Indeed, if at any point one would need to compute and store <span class=""math-container"">$2^n\times2^n$</span> unitary of the circuit in memory that would be infeasible and render the quantum computation obsolete (it may still be useful for benchmarking NISQ computers though). Transpilation mostly works either with individual 1- and 2-qubit gates or with the whole circuit but not as a large tensor, but in some alternative representation (which are numerous: graphs, ZX-calculus, tensornetworks, decision trees etc). Optimization proceeds within these data structures and does not require full matrix representation of the circuit.</p>
<hr />
<p>What is exactly meant by transpilation is a bit ambiguous I would say, so I will have a <code>qiskit</code> <a href=""https://qiskit.org/documentation/apidoc/transpiler.html"" rel=""nofollow noreferrer"">transpilation model</a> in mind. There are two main goals of the transpilation process</p>
<ol>
<li>Compatibility.</li>
<li>Efficiency.</li>
</ol>
<p>Compatibility means that you can not immediately execute a textbook quantum circuit of your choice on a given hardware. For example, the native gates on the hardware may not be those used in your circuit. Then you need to decompose the gates in your circuit into the native set. Another issue is the connectivity problem: on a real hardware typically one can not perform two-qubit gates on an arbitrary pair of qubits. If your textbook circuit features a gate that is not allowed directly by the hardware, you need to circumvent this problem somehow (usually by adding a bunch of <code>SWAP</code> gates).</p>
<p>After the circuit is made compatible with the hardware it is of course desirable to compress it as efficiently as possible. Some things are trivial to do, like cancelling two adjacent <code>CNOT</code> gates (which might appear after the first step), but there are of course many other types of transformations that one can attempt to simplify the circuit. Such transformations never require to compute the whole unitary/state of the circuit. For larger number of qubits / depth of the circuit you might want to try and optimize a larger piece of the circuit, so there will be a trade-off between the classical transpilation time and gains in simplicity of the resulting circuit.</p>
",09/03/2021 11:26,Conceptual,"This question falls under the ""Conceptual"" category because it's exploring a fundamental concept related to quantum transpilation. The user is trying to understand the limitations and processes involved in optimizing quantum circuits using classical methods",Conceptual,,,,Conceptual,
21138.0,Qiskit's QFT not returning the expected state,"<p>I'm currently going through the lab problems for the Qiskit course <a href=""https://qiskit.org/learn/intro-qc-qh/"" rel=""nofollow noreferrer"">here</a>. I'm trying to finish lab set number 3 on QPE but I can't seem to get the desired output, even from the solution notebook. I'm trying to estimate the phase of the following unitary:</p>
<p><span class=""math-container"">$$ U_{\theta} = \left(\begin{matrix} 1&amp;0\\ 0&amp;e^{2\pi i \theta} \end{matrix}\right)$$</span></p>
<p>Specifically I want to implement a circuit for the case <span class=""math-container"">$\theta=0.5$</span> and I am using a 5 qubit estimation. Here is the code for the circuit:</p>
<pre><code>import numpy as np
from qiskit.circuit.library import QFT
from qiskit import QuantumCircuit
pi = np.pi    


def initialize_qubits(given_circuit, measurement_qubits, target_qubit):
  given_circuit.h(measurement_qubits)
  given_circuit.x(target_qubit)

def unitary_operator_exponent(given_circuit, control_qubit, target_qubit, theta, exponent):
  given_circuit.cp(2*pi*theta*exponent, control_qubit, target_qubit)

def apply_iqft(given_circuit, measurement_qubits, n):
  given_circuit.append(QFT(n).inverse(), measurement_qubits)

def qpe_program(n, theta):


  qc = QuantumCircuit(n+1, n)

  # Initialize the qubits
  initialize_qubits(qc, range(n), n)

  qc.barrier()

  # Apply the controlled unitary operators in sequence
  for x in range(n):
    exponent = 2**(n-x-1)
    unitary_operator_exponent(qc, x, n, theta, exponent)

  qc.barrier()

  # Apply the inverse quantum Fourier transform
  apply_iqft(qc, range(n), n)


  # Measure all qubits
  qc.measure(range(n), range(n))

  return qc

n = 5; theta = 0.5
mycircuit = qpe_program(n, theta)
mycircuit.draw(output='mpl')
</code></pre>
<p>This is a fairly standard phase estimation circuit and I don't see why it's not working (especially since it's in the solution manual).</p>
<p>The problem is when I run a simulator on this and get counts, the state <span class=""math-container"">$|{11111}\rangle$</span> shows up in half the instances and I can't for the life of me find out why (it should just be <span class=""math-container"">$|{00001}\rangle$</span> plus some small error). Here is the simulation code:</p>
<pre><code>from qiskit import Aer, execute
simulator = Aer.get_backend('qasm_simulator')
counts = execute(mycircuit, backend=simulator, shots=1000).result().get_counts(mycircuit)

from qiskit.visualization import plot_histogram
plot_histogram(counts)
</code></pre>
<p>Here's a screenshot of the circuit and then the simulation results:</p>
<p><a href=""https://i.stack.imgur.com/SGT8W.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SGT8W.png"" alt=""Circuit Diagram"" /></a></p>
<p><a href=""https://i.stack.imgur.com/QYOIB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QYOIB.png"" alt=""Simulation Results"" /></a></p>
<p>Notes: Running on Python v3.9.7 and Qiskit v0.29</p>
",<programming><qiskit><circuit-construction><quantum-fourier-transform>,09/10/2021 12:49,21139.0,21139.0,"<p>In order to understand why this does not work, let us consider the circuit you've created with two measurement qubits:
<a href=""https://i.stack.imgur.com/VPcL1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VPcL1.png"" alt=""Two-qubits circuit"" /></a>
Running this circuit using the following code:</p>
<pre><code>backend = Aer.get_backend('aer_simulator')
job = execute(mycircuit, backend)
result = job.result()
result.get_counts()
</code></pre>
<p>yielded for me:</p>
<pre><code>{'11': 499, '01': 525}
</code></pre>
<p>If we write down the state you create before applying the <span class=""math-container"">$IQFT$</span>, you would get:
<span class=""math-container"">$$\frac12|1\rangle\left(|00\rangle+|01\rangle-|10\rangle-|11\rangle\right)$$</span>
Note that you have to consider that <code>qiskit</code> uses little-endian for ordering qubits. Thus, the state which would have been written in textbooks is:
<span class=""math-container"">$$\frac12\left(|00\rangle-|01\rangle+|10\rangle-|11\rangle\right)|1\rangle$$</span>
Now, why does this matter? If we write down the definition of the <span class=""math-container"">$QFT$</span> matrix on two qubits, <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html#1.-Introduction-"" rel=""nofollow noreferrer"">according to the qiskit documentation</a>, we get:
<span class=""math-container"">$$QFT=\begin{pmatrix}1&amp;1&amp;1&amp;1\\1&amp;\mathrm{i}&amp;-1&amp;-\mathrm{i}\\1&amp;-1&amp;1&amp;-1\\1&amp;-\mathrm{i}&amp;-1&amp;\mathrm{i}\end{pmatrix}$$</span>
In particular, the state we obtained using the little-endian version can be written as:
<span class=""math-container"">$$\frac12|1\rangle\left(|00\rangle+|01\rangle-|10\rangle-|11\rangle\right)=\frac12|1\rangle\left[(1-\mathrm{i})QFT|01\rangle+(1+\mathrm{i})QFT|11\rangle\right]$$</span>
while the texbook version can be written as:
<span class=""math-container"">$$(QFT|10\rangle)|1\rangle$$</span>
By linearity, you can now see that the state you get in the little-endian version is, omitting the qubit in state <span class=""math-container"">$|1\rangle$</span>:
<span class=""math-container"">$$\frac{1-\mathrm{i}}{2}|01\rangle+\frac{1+\mathrm{i}}{2}|11\rangle$$</span>
which explains why we measured these states with equal probability. On the other hand, the textbook version yields the state <span class=""math-container"">$|10\rangle$</span>.</p>
<p>Thus, the problem is that you've created the big-endian/textbook version of the QPE algorithm, while <code>qiskit</code> works with little-endian. The fix one can immediately think of is to change the qubits on which you apply the controlled phase gates. In order to do this, yuo can just replace the line:</p>
<pre><code>exponent = 2**(n-x-1)
</code></pre>
<p>with:</p>
<pre><code>exponent = 2**x
</code></pre>
<p>which then yields the correct result. Another way to do it is to apply SWAP gates on the state before applying the <span class=""math-container"">$IQFT$</span>. The neat property is that the <span class=""math-container"">$IQFT$</span> already has swap gates in its implementation. You can see this with:</p>
<pre><code>QFT(4, inverse=True).decompose().draw(&quot;mpl&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/yMCfv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yMCfv.png"" alt=""IQFT for 4 qubits"" /></a>
Thus, what we want to do is essentially not to apply these gates, so that the qubits ordering is reversed. You can do it using the <code>do_swaps</code> argument of <span class=""math-container"">$QFT$</span>:</p>
<pre><code>QFT(4, inverse=True, do_swaps=False).decompose().draw(&quot;mpl&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/q23MD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q23MD.png"" alt=""IQFT for 4 qubits without swaps"" /></a>
Thus, if you let the line <code>exponent = 2 ** (n - x - 1)</code> unchanged but instead replace the line:</p>
<pre><code>given_circuit.append(QFT(n).inverse(), measurement_qubits)
</code></pre>
<p>by:</p>
<pre><code>given_circuit.append(QFT(n, inverse=True, do_swaps=False), measurement_qubits)
</code></pre>
<p>Then you will get the right result, while applying less gates than with the other solution.</p>
",09/10/2021 15:24,Errors,"The user is encountering an issue with their quantum programming code, specifically with the output of their phase estimation circuit, and is seeking a solution or explanation for the unexpected results.",Errors,,,,Errors,
21143.0,qiskit transpile initial_layout determination,"<p>So, I am fairly new to Qiskit, and I've been following Qiskit textbook recently. In the chapter 7, where the QC lab exercises are located, in the first lab when working on the real hardware it is required to select the optimal <code>initial_layout</code> setting during the <code>transpile</code> function call based on the error map consideration.
Now, I understand that the initial layout governs how computational qubits map onto the physical qubits.
For instance, if we select hardware option with 5 qubits (e.g. <code>ibmq_quito</code>) and we designe a circuit with e.g. 4 qubits, with <code>initial_layout</code> we can specify any 4-element combination out of 5 possible elements. However, what I fail to understand is what exactly is the error map specified in the lab exercise. Does it mean to sweep all possible qubit configurations (<code>c1 = [0, 1, 2, 3]</code>, <code>c2 = [0, 1, 2, 4]</code>, <code>c3 = [1, 2, 3, 4]</code>, ...) and pick the one with lowest noise impact, or a different approach must be taken?</p>
<p>I would appreciate any input on this.</p>
",<qiskit><programming>,09/10/2021 19:27,21149.0,21149.0,"<p>One of the pre-coded cells in the lab has the command <code>backend</code>. If you execute the cell with the command <code>backend</code> after running the command <code>import qiskit.tools.jupyter</code>, the widget will be opened for the backend.</p>
<p>The widget shows the chosen backend information graphically and one of the tabs is called <code>error map</code> showing the qubit connectivity with all kinds of error information coded in color. You can find same information <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibmq_quito"" rel=""nofollow noreferrer"">here</a> for <code>ibmq_quito</code> for example. The question is asking to find a good initial layout considering connectivity and error information that you can find from the map. Hope that it helps.</p>
",09/10/2021 22:53,Learning ,The user is learning how to use Qiskit and is seeking clarification on how to select the optimal initial_layout setting during the transpile function call based on the error map consideration. This falls under the Learning category as it involves understanding and applying new concepts in quantum computing,Learning ,,,,Learning ,
21194.0,Does Qiskit transpiler execute multiple circuits in parallel?,"<p>I have something to ask about Qiskit's transpiler.
Before that, please check this document.</p>
<pre><code>qiskit.compiler.transpile
https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html
</code></pre>
<p>In here, transpile function can get input as multiple quantum circuit as list and can transpile them in parallel.</p>
<p>I want to know how they can do in parallel.</p>
",<qiskit><programming><transpile>,9/15/2021 1:58,21211.0,21211.0,"<p>It depends on your local environment and local configuration. By default if you're running on Linux with Python &lt; 3.9 or macOS with Python &lt; 3.8 then passing mutiple circuit's to <code>transpile()</code> will run in multiple process locally. This is done using Python's <a href=""https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor"" rel=""nofollow noreferrer""><code>ProcessPoolExecutor</code></a> to launch parallel processes and call transpile on each circuit in the input list in the process pool. The code for how Qiskit does this is in: <a href=""https://github.com/Qiskit/qiskit-terra/blob/0.18.2/qiskit/tools/parallel.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/blob/0.18.2/qiskit/tools/parallel.py</a> (the <code>parallel_map()</code> function is what <code>transpile()</code> uses under the covers when you pass in &gt;1 circuit).</p>
<p>Also, the defaults are adjustable so if you run on windows or with a newer python version you can still run in parallel but it's not enabled by default because there were some issues found using python's <code>multiprocessing</code> module in those environments. You can refer to <a href=""https://qiskit.org/documentation/configuration.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/configuration.html</a> on how to set the options controlling parallelism.</p>
",9/15/2021 13:28,Tooling,he question is about how the Qiskit transpiler can transpile multiple quantum circuits in parallel. This is a feature of the Qiskit transpiler that can be used to improve the performance of quantum circuit compilation.,Tooling,,,,Tooling,
21210.0,Expected outcome of adding two PauliOp,"<p>first of all, I would probably report this as a bug if I was confident enough in my QC abilities. As it stands, I've just started out, so I'm phrasing it as a question.</p>
<p>From what I can tell, adding two PauliOps in this specific case does not result in the expected operator matrix:</p>
<pre><code>import qiskit as qk
from qiskit.opflow.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>results in</p>
<pre><code>array([[0.+0.j, 1.-1.j],
       [1.+1.j, 0.+0.j]])
</code></pre>
<p>whereas the result that I would expect is the one i get when I run the following code:</p>
<pre><code>PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)).to_matrix() + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;)).to_matrix()
</code></pre>
<p>Result:</p>
<pre><code>array([[0.+0.j, 2.+0.j],
       [0.+0.j, 0.+0.j]])
</code></pre>
<p>What further confuses me is that the deprecated version of PauliOp actually results in the expected operator. Running this code:</p>
<pre><code>import qiskit as qk
from qiskit.aqua.operators.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>gives a deprecation warning and the [[0,2],[0,0]]-array that I want.</p>
<p>Has the behaviour of the addition changed or is this a bug? In any case, how can I construct the operator that I want (in a non-deprecated way)?</p>
<p>I'm running qiskit version 0.29.0</p>
<p>Thanks in advance!</p>
",<qiskit><programming>,9/15/2021 13:03,21217.0,21217.0,"<p>You can do this instead:</p>
<pre><code>(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + 1j*PauliOp(qk.quantum_info.Pauli(&quot;Y&quot;))).to_matrix()
</code></pre>
<p>which gives what you expect:</p>
<pre><code>array([[0.+0.j, 2.+0.j],
       [0.+0.j, 0.+0.j]])
</code></pre>
",9/15/2021 20:21, Errors,"The user is encountering an issue with their quantum programming code, specifically with the addition of two PauliOps not resulting in the expected operator matrix, and is seeking a solution or explanation for this unexpected behavior", Errors,,,, Errors,
21311.0,Implement the classical shadow coding error?,"<p>I'm trying to reproduce the basic method of <a href=""https://arxiv.org/abs/2002.08953"" rel=""nofollow noreferrer"">classical shadow</a>, which is based on the <a href=""https://pennylane.ai/qml/demos/tutorial_classical_shadows.html#classical-shadows"" rel=""nofollow noreferrer"">tutorial of pennylane</a>. However, I've met some realization problems here when I finish reading the tutorial of pennylane, and trying to finish the method myself, just to check if my understanding is correct, because I'm not sure if my understanding about the inverse of the map <span class=""math-container"">$M$</span> mentioned in the paper is correct.</p>
<p>I will describe the method shortly first, and then showing my code with <em>qiskit</em>, <em>pennylane</em>, and <em>matlab</em>. But all of them failed to have the same effect as the <em>tutorial of pennylane</em> does(increasing the number of measurements, the distance between the state I want to reconstruct and the original state should be more and more close).</p>
<p>The idea of classical shadow(or the process of the algorithm) is kind of simple while the math behind it might be complicated. The process states that for any density matrix <span class=""math-container"">$\rho$</span>, we act some unitary matrix <span class=""math-container"">$U$</span> which are chosen <em>randomly</em> from a specific set of the unitary matrix <span class=""math-container"">$\mathcal{U}$</span> on it, i.e., <span class=""math-container"">$U\rho U^\dagger$</span>. Then we do one-shot measurement based on the computational basis on <span class=""math-container"">$U\rho U^\dagger$</span>. Then the state will collapse into some state <span class=""math-container"">$|\hat{b}\rangle$</span>. And then we do the rest of the work in classical data analysis style. First we undo the unitary matrix, i.e., <span class=""math-container"">$U^\dagger |\hat{b}\rangle\langle \hat{b}| U$</span> . Then we do the inverse of the map <span class=""math-container"">$\hat{\rho}\equiv M^{-1}(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span> which can be defined as <span class=""math-container"">$M(\rho)\equiv E(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span>, where the <span class=""math-container"">$E$</span> stands for expectation over both unitary matrix and measurement result <span class=""math-container"">$|\hat{b}\rangle$</span>.  And for a specific choice of unitary set(seems Clifford group, not very clear here), we have a form of the inverse of <span class=""math-container"">$M$</span> states as
<span class=""math-container"">$$
\hat{\rho} = \bigotimes_{j=1}^n(3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I})\tag{1}
$$</span>
Then I will introduce my code first. We specify the unitary group into Hadamard gate, phase gate, and identity. Then we do the computational basis measurement and rebuild the classical shadow <span class=""math-container"">$\hat{\rho}$</span> with the help of eq.(1), and then calculate the expectation value of <span class=""math-container"">$\hat{\rho}$</span> by directly divide measurement times.</p>
<p>Following the codes(pennylane, qiskit, Matlab), aiming at construct the classical shadow of bell state:</p>
<pre><code>from networkx.algorithms.centrality import harmonic
from networkx.exception import HasACycle
from networkx.readwrite.sparse6 import write_sparse6
from numpy import dtype
from numpy.random.mtrand import rand
import pennylane as qml
from pennylane import wires
import pennylane.numpy as np
import matplotlib.pyplot as plt
import time

def distance(rho):
    return np.sqrt(np.trace(rho.conjugate().transpose() @ rho))

def my_quantum_function(x, y):
    unitary = [qml.Hadamard, qml.S, qml.Identity]
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0,1])
        
    unitary[y[0]](wires=0)
    unitary[y[1]](wires=1)

    # all measure in computational basis, i.e., mean value of pauliz, one-shot case
    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]

# one-shot case shots = 1 to simulate the measure in computational basis requirement
dev = qml.device('default.qubit', wires=2, shots=1)
circuit = qml.QNode(my_quantum_function, dev)

# generate random number seed for easy replicate the experiment
np.random.seed(666)

# init
phase_z = np.array([[1, 0], [0, 1j]], dtype=complex)
hadamard = qml.Hadamard(0).matrix
identity = qml.Identity(0).matrix

unitary = [hadamard, phase_z, identity]

snapshot = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])

for i in range(snapshot):
    randnum = np.random.randint(0,3,size=2)
    [res0, res1] = circuit(0,randnum)
    # print(circuit.draw())
    if res0 == 1:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state0 @ unitary[randnum[0]]) - identity
    else:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state1 @ unitary[randnum[0]]) - identity

    if res0 == 1:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state0 @ unitary[randnum[1]]) - identity
    else:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state1 @ unitary[randnum[1]]) - identity

    record_rho = record_rho + np.kron(rho1,rho2)

record_rho = record_rho/snapshot
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)

print(distance(record_rho - bell_state))

</code></pre>
<pre><code>from math import exp
from qiskit import *
from qiskit import Aer
import numpy as np
import matplotlib.pyplot as plt
from random import randrange

np.random.seed(222)
def one_shot(operator):
    
    sim = Aer.get_backend('aer_simulator')
    qc = QuantumCircuit(2)
    unitary = [qc.h, qc.sdg, qc.id]
    qc.h(0)
    qc.cx(0,1)
    unitary[operator[0]](0)
    unitary[operator[1]](1)
    qc.measure_all()

    qobj = assemble(qc,shots=1)
    result = sim.run(qobj).result().get_counts()
    return result

def distance(rho):
    '''
    calculate distance of two density matrix
    '''
    return np.sqrt(np.trace(rho.conjugate().transpose().dot(rho)))

hadamard = 1/np.sqrt(2)*np.array([[1,1],[1,-1]])
s_gate = np.array([[1,0],[0,-1j]],dtype=complex)
id = np.identity(2)
unitary = [hadamard,np.dot(hadamard,s_gate),id]

snapshot_num = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])
for i in range(snapshot_num):
    randnum = np.random.randint(0,3,size=2)
    result = one_shot(randnum)
    if result.get('00') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    elif result.get('01') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)
    elif result.get('10') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    else:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)

    record_rho = record_rho + rho
record_rho = record_rho/snapshot_num
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)
print(distance(record_rho - bell_state))

</code></pre>
<pre><code>% Pauli matrix as random unitary
pauli = eye(2);
pauli(:,:,2) = [1 0;0 -1j]; pauli(:,:,3) = 1/sqrt(2)*pauli(:,:,2)'*[1 1;1 -1];
% two computational basis |0) and |1)
state = eye(4);
state0 = [1;0];
state1 = [0;1];

psi = 1/sqrt(2)*[1;0;0;1];
rho = psi*psi';
record_rho = zeros(4);
n = 6000;
for i = 1:n
    randnum = randi([1 3],[1 2]);
    rhot = kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))*rho*kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))';
    prob1 = state(:,1)'*rhot*state(:,1);
    prob2 = state(:,2)'*rhot*state(:,2);
    prob3 = state(:,3)'*rhot*state(:,3);
    prob4 = state(:,4)'*rhot*state(:,4);
    
    % Utilizing if to simulate the quantum measurement
    % The inverse process is using the formula of eq(S44) in supplemental
    % material of the original paper
    if rand &lt; prob1
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2 + prob3
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    else
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    end
    record_rho = record_rho + rhot;
end
record_rho = record_rho/n;
sqrt(trace((rho - record_rho)'*(rho - record_rho)))
Fidelity(rho,record_rho)
</code></pre>
",<qiskit><programming><algorithm><tomography><shadow-tomography>,9/23/2021 13:35,21318.0,21318.0,"<p>There's a few bugs in your code as well as a slight misunderstanding about the guarantees of the protocol.</p>
<p>First to clarify some details: The protocol you implement samples <span class=""math-container"">$U \in \text{Cl}(2)^{\otimes 2}$</span> (not the same as <span class=""math-container"">$U\in \text{Cl}(2^2)$</span>!) and then applies these operators pre-measurement. Up to global phase this is equivalent to performing local measurements randomly selected to be in either the <span class=""math-container"">$x$</span>-, <span class=""math-container"">$y$</span>-, or <span class=""math-container"">$z$</span>-basis. And so equivalently this can be implemented as randomly applying a unitary <span class=""math-container"">$U_j$</span> drawn from <span class=""math-container"">$\{H, HS^\dagger, I\}$</span>, applying to each qubit <span class=""math-container"">$j=0, 1$</span>, and then measuring <span class=""math-container"">$|b_0 b_1\rangle\langle b_0 b_1|$</span>.</p>
<p>Mathematically the effect of this pre-measurement rotation on an input state averaged over many trials turns out to be the depolarizing channel. This is why you recover a shadow of the input state by applying the inverse of a depolarizing channel
<span class=""math-container"">\begin{align}
\hat{\rho} &amp;= \left(\mathcal{D}_{1/3}^{-1}\right)^{\otimes 2}  \circ (U_0^\dagger \otimes U_1^\dagger)|b_0 b_1\rangle\langle b_0 b_1| (U_0 \otimes U_1)\tag{1}
\\&amp;=\bigotimes_{j=1}^2(3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I})
\end{align}</span></p>
<p>where the equivalence of these two expressions is derived very nicely in Huang's paper. However, this protocol <strong>doesn't</strong> actually guarantee tight bounds on  <span class=""math-container"">$\text{Tr}(\rho \hat{\rho})$</span>. Rather, the guarantee of this protocol is that for <span class=""math-container"">$O_i$</span> taken from the set of <span class=""math-container"">$2$</span>-local Paulis, the difference</p>
<p><span class=""math-container"">$$\tag{2}
|\text{Tr}(O_i \hat{\rho}) - \text{Tr}(O_i \rho)| \leq \epsilon
$$</span></p>
<p>will be upper bounded according to the shadow norm and accuracy parameters. On the other hand, if you were interested in observables with much lower locality than the size of the system you would still see good convergence re: Equation (2) but the distance between the input state and the classical shadow could be large.</p>
<p>With these factors in mind, here is a working codeblock slightly modified from yours:</p>
<pre><code>from math import exp
from qiskit import *
from qiskit import Aer
import numpy as np
import matplotlib.pyplot as plt
from random import randrange

np.random.seed(222)
def one_shot(operator):
    
    sim = Aer.get_backend('aer_simulator')
    qc = QuantumCircuit(2)
#     unitary = [qc.h, qc.sdg, qc.id] # no! Bug #1
    unitary = [[qc.h], [qc.sdg, qc.h], [qc.id]] 
    qc.h(0)
    qc.cx(0,1)
    # new code:
    for x in unitary[operator[0]]:
        x(0)
    for x in unitary[operator[1]]:
        x(1)
    qc.measure_all()
    qobj = assemble(qc,shots=1)
    result = sim.run(qobj).result().get_counts()
    return result

def distance(rho):
    '''
    calculate distance of two density matrix
    '''
    return np.sqrt(np.trace(rho.conjugate().transpose().dot(rho)))

hadamard = 1/np.sqrt(2)*np.array([[1,1],[1,-1]])
s_gate = np.array([[1,0],[0,-1j]],dtype=complex)
id = np.identity(2) # don't overwrite builtins with variables!
unitary = [hadamard,np.dot(hadamard,s_gate),id]
snapshot_num = 5000 # more shots
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
states = [state0, state1]
record_rho = np.zeros([4,4])
for i in range(snapshot_num):
    randnum = np.random.randint(0,3,size=2)
    result = one_shot(randnum)
    
    bit0, bit1 = [int(x) for x in list(result.keys())[0]] # assuming one shot
    U0, U1 = unitary[randnum[0]], unitary[randnum[1]]
    # No! Bug #2: your parentheses were incorrect here
    rhohat = np.kron(3* U0.conj().T @ states[bit0] @ U0 - id , 3* U1.conj().T @ states[bit1] @ U1 - id)
    record_rho = record_rho + rhohat
    
record_rho = record_rho/snapshot_num
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])

print(&quot;State distance&quot;)
print(distance(record_rho - bell_state))

# VERIFICATION
print(&quot;verify 2-local expecations converge&quot;)
I = np.eye(2)
X = np.array([[0, 1], [1, 0]])
Y = np.array([[0, -1j], [1j, 0]])
Z = np.array([[1, 0], [0, -1]])
paulis = [I, X, Y, Z]

for i in range(4):
    for j in range(4):
        twolocal_pauli = np.kron(paulis[i], paulis[j])
        expectation_true = np.trace(bell_state @ twolocal_pauli)
        expectation_rhohat = np.trace(record_rho @ twolocal_pauli)
        print((i,j), abs(expectation_true - expectation_rhohat))
</code></pre>
<p>which outputs:</p>
<pre><code>State distance
(0.06070337717129093+0j)
verify 2-local expecations converge
(0, 0) 0.0
(0, 1) 0.045599999999999995
(0, 2) 0.0108
(0, 3) 0.008400000000000074
(1, 0) 0.009000000000000003
(1, 1) 0.03160000000000007
(1, 2) 0.03779999999999999
(1, 3) 0.003599999999999997
(2, 0) 0.006599999999999998
(2, 1) 0.0342
(2, 2) 0.04960000000000009
(2, 3) 0.04319999999999999
(3, 0) 0.013200000000000045
(3, 1) 0.0414
(3, 2) 0.034199999999999994
(3, 3) 0.036799999999999944
</code></pre>
<p>So after increasing shots to 5000 can see nice convergence on <span class=""math-container"">$\text{Tr}(\hat{\rho} \sigma_i \otimes \sigma_j)$</span> even if the fidelity <span class=""math-container"">$\text{Tr}(\hat{\rho}\rho)$</span> is increasing at a slower rate<span class=""math-container"">$^1$</span>.</p>
<p>The bugs are described below:</p>
<ol>
<li><code>unitary = [qc.h, qc.sdg, qc.id]</code> in the function <code>one_shot</code>: The <span class=""math-container"">$S^\dagger$</span> is not how you perform a measurement in the Y-basis. You need <span class=""math-container"">$H S^\dagger$</span>.</li>
<li><code>rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)</code> in the loop over <code>snapshot_num</code>: specifically, <code>.dot(unitary[randnum[0]] - id)</code> has the parentheses in the wrong place. If you had inspected <span class=""math-container"">$\rho$</span> you would have observed it was often equal to the all-zeros matrix which is a bad sign. While we can't rely on <span class=""math-container"">$\text{Tr}(\hat{\rho})=1$</span> in this protocol because <span class=""math-container"">$M^{-1}$</span> is not trace preserving, we can at least expect <span class=""math-container"">$\text{Tr}(\hat{\rho})\geq 1$</span>.</li>
</ol>
<hr />
<p><span class=""math-container"">$^1$</span> In this special case where the observables are <span class=""math-container"">$n$</span>-local rather than <span class=""math-container"">$k$</span>-local for <span class=""math-container"">$k&lt;n$</span>, I think by triangle inequality the state distance is actually bounded as a sum of the bounds on the observables:
<span class=""math-container"">\begin{align}
\lVert\rho - \hat{\rho}\rVert_1 &amp;= \left\lVert \sum_{i \in \{I, X,Y,Z\}^2 } (\text{Tr}(P_i\rho )- \text{Tr}(P_i\hat{\rho} ) )P_i \right\rVert_1
\\\leq   &amp;\sum_{i \in \{I, X,Y,Z\}^2 } \left\lVert(\text{Tr}(P_i\rho )- \text{Tr}(P_i\hat{\rho} ) )P_i \right\rVert_1
\\&amp;\leq 16 \epsilon
\end{align}</span>
where <span class=""math-container"">$P_i = \sigma_{i_1} \otimes \sigma_{i_2}$</span> and the bound of Equation (2) was applied. This is why the sample complexity of estimating classical shadows for <span class=""math-container"">$n$</span>-local Pauli operators (which are a basis for <span class=""math-container"">$n$</span>-qubit states) with error parameter <span class=""math-container"">$\epsilon$</span> is much lower than the sample complexity for state tomography with error parameter <span class=""math-container"">$\epsilon$</span>.</p>
",9/23/2021 20:16,Errors,"This question falls under the ""Errors"" category because the user is facing issues in reproducing the classical shadow method described in a research paper and a PennyLane tutorial using different quantum programming frameworks (Qiskit, PennyLane, and Matlab). They are encountering problems with the results not matching the expected outcomes, and they are seeking assistance in identifying the errors in their code or approach.",Tooling,"The question is about how to implement the classical shadow algorithm in Qiskit, PennyLane, and MATLAB. This is a common task in quantum computing research.",No,116.0, Errors,"The user is encountering issues with reproducing the classical shadow method across different quantum programming frameworks, indicating a problem with their implementation or understanding. They seek assistance in identifying errors and resolving discrepancies in their code, falling under the Errors category."
21384.0,Is it possible to perform $z$ rotation in Qiskit with just $x$ and $y$ rotations?,"<p>Is it possible to perform <span class=""math-container"">$z$</span> rotation in Qiskit with just <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> rotations?</p>
<p>I tried the following:</p>
<pre><code>from qiskit import *
qc = QuantumCircuit(1)

theta = 0.5*np.pi
qc.ry(np.pi/2,0)
qc.rx(-np.pi/2,0)

qc.ry(theta,0)

qc.rx(np.pi/2,0)
qc.ry(-np.pi/2,0)
</code></pre>
<p>The code is based on (<a href=""https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.021058"" rel=""nofollow noreferrer"">Realization of High-Fidelity CZ and ZZ-Free iSWAP Gates with a Tunable Coupler</a>) (page 26), but it seems that I do something wrong.</p>
",<qiskit><programming><quantum-gate><circuit-construction>,10/01/2021 13:47,21388.0,21388.0,"<p>The decomposition they give is the following:</p>
<p><span class=""math-container"">$$
R_z(\theta) = R_x\left(\pi / 2\right) R_y(\theta) R_x\left(-\pi / 2\right)
$$</span></p>
<p>Therefore, the Qiskit code would look like:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator
import numpy as np

theta = np.pi / 4

qc = QuantumCircuit(1)
qc.rx(-np.pi / 2, 0)
qc.ry(theta, 0)
qc.rx(np.pi / 2, 0)

Operator(qc).data
</code></pre>
<p>Which gives output:</p>
<pre><code>array([[0.92387953-0.38268343j, 0.        +0.j        ],
       [0.        +0.j        , 0.92387953+0.38268343j]])
</code></pre>
<p>And we can see it is equivalent to <span class=""math-container"">$R_z(\theta)$</span>:</p>
<pre><code>qc = QuantumCircuit(1)
qc.rz(theta, 0)

Operator(qc).data
</code></pre>
<pre><code>array([[0.92387953-0.38268343j, 0.        +0.j        ],
       [0.        +0.j        , 0.92387953+0.38268343j]])
</code></pre>
",10/01/2021 14:23,Conceptual,"The question is asking about how to implement a Z rotation using only X and Y rotations. This is a conceptual question, as it requires understanding of the underlying principles of quantum mechanics and quantum computation.",Conceptual,,,,Conceptual,
21414.0,Which quantum computing frame is suitable for optimization problems?,"<p>As in the computer world, not all programming languages are suitable for everything.</p>
<p><strong>Php</strong> = Backend<br />
<strong>Javascript</strong> = Frontend<br />
<strong>Data Analsys/ML</strong> = Python<br />
<strong>embedded systems</strong> = C<br />
<strong>Mobilphone/apps</strong> = Android / Swift</p>
<p>As far as I know not all quantum languages solve the same problems. I would like to know which framework(qiskit, cirq..) would be suitable for optimisation problems (for example Travel Salesman Problem).</p>
",<qiskit><programming><q#><cirq>,10/05/2021 07:53,21416.0,21416.0,"<p>There is Qiskit Optimization application module entirely suitable for solving optimization problems as it can be noticed from the name. This module is based on Qiskit and provides high level interfaces to optimization define problems and solve them via various quantum algorithms. The module is written in python. Take a look at the module page and tutorials:</p>
<p>Documentation:
<a href=""https://qiskit.org/documentation/optimization/"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/optimization/</a></p>
<p>Tutorials:
<a href=""https://qiskit.org/documentation/optimization/tutorials/index.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/optimization/tutorials/index.html</a></p>
<p>Solving traveling salesman problem problem:
<a href=""https://qiskit.org/documentation/optimization/tutorials/06_examples_max_cut_and_tsp.html#Traveling-Salesman-Problem"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/optimization/tutorials/06_examples_max_cut_and_tsp.html#Traveling-Salesman-Problem</a></p>
",10/05/2021 08:56,Tooling," The user is asking about which quantum computing framework (like Qiskit, Cirq) would be suitable for optimization problems, which falls under the category of tool and software usage in quantum programming",Tooling,,,,Tooling,
21419.0,Equivalent matrix for operators in qiskit,"<p>What is eqivalent matrix to <code>qc.rx(np.pi, 0)</code>:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, Aer, execute
from qiskit.quantum_info import Operator

qc = QuantumCircuit(1)

qc.rx(np.pi, 0)
print('Final matrix:', np.round(Operator(qc).data, 3))
</code></pre>
<p>I thought it is the following:</p>
<p><span class=""math-container"">$$X = \begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}
1 \\
0 \\
\end{pmatrix}
 =\begin{pmatrix}
0 &amp; 1 \\
0 &amp; 0 \\
\end{pmatrix}
$$</span></p>
<p>but it is not, because of different result. And what would be equivalent matrices in case:</p>
<pre><code>qc.rx(np.pi, 0)
qc.ry(np.pi, 0)
</code></pre>
",<qiskit><programming><quantum-gate><circuit-construction>,10/05/2021 14:10,21422.0,21422.0,"<p>Qiskit defines the <span class=""math-container"">$RX$</span> gate as follows:</p>
<p><span class=""math-container"">$$
RX(\theta) = \exp\left(-i \frac{\theta}{2} X\right) =
            \begin{pmatrix}
                \cos{\frac{\theta}{2}}   &amp; -i\sin{\frac{\theta}{2}} \\
                -i\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
            \end{pmatrix}
$$</span></p>
<p>Thus, setting <span class=""math-container"">$\theta = \pi$</span>, would give us:</p>
<p><span class=""math-container"">$$
RX(\pi) = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} = -iX
$$</span></p>
<p>Which is what I suspect you got as output to <code>Operator(qc).data</code> in the first code cell. Thus, a rotation of <span class=""math-container"">$\pi$</span> radians about the <span class=""math-container"">$x$</span>-axis is equivalent to the normal bit flip gate <span class=""math-container"">$X$</span> up to a global phase of <span class=""math-container"">$-i$</span>.</p>
<blockquote>
<p>I thought it is the following:
<span class=""math-container"">$$X = \begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}
1 \\
0 \\
\end{pmatrix}
 =\begin{pmatrix}
0 &amp; 1 \\
0 &amp; 0 \\
\end{pmatrix}
$$</span></p>
</blockquote>
<p>I think you got confused about matrix multiplication here. First of all, <span class=""math-container"">$X$</span> is only <span class=""math-container"">$\begin{pmatrix} 0 &amp; 1 \\ 1&amp; 0 \end{pmatrix}$</span>. I suspect you are trying to get the final state of the circuit, which would correspond to the operation you do in the middle of the above equation (up to the global phase we discussed earlier). But, remember that the product of a matrix of size <span class=""math-container"">$2 \times 2$</span> with a vector of size <span class=""math-container"">$2 \times 1$</span> is another vector of size <span class=""math-container"">$2 \times 1$</span>. Thus, you can't get a matrix from this operation.</p>
<p>The correct operation to get the final state of your circuit would be the following:</p>
<p><span class=""math-container"">$$
RX(\pi)|0\rangle = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ -i \end{pmatrix} = -i|1\rangle
$$</span></p>
<p>Which is equivalent to <span class=""math-container"">$|1\rangle$</span> up to a global phase that we can ignore here since we only have one qubit. If there were more qubits, this global phase would turn into a relative phase.</p>
<blockquote>
<p>And what would be equivalent matrices in case:</p>
<pre><code>qc.rx(np.pi, 0)
qc.ry(np.pi, 0)
</code></pre>
</blockquote>
<p>The <span class=""math-container"">$RY$</span> gate is defined as follows:</p>
<p><span class=""math-container"">$$
RY(\theta) = \exp\left(-i \frac{\theta}{2} Y\right) =
            \begin{pmatrix}
                \cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} \\
                \sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
            \end{pmatrix}
$$</span></p>
<p>Thus, to get the unitary corresponding to that circuit, plug in the angle to each of the gates definition and perform matrix multiplication. The operation you need to do is <span class=""math-container"">$RY(\pi)RX(\pi)$</span>. And then you could get the final state of the circuit following the same steps as with the first example.</p>
",10/05/2021 19:39,Errors,"The user is trying to understand why their expected output (a certain matrix) does not match the actual output when using the rx function in Qiskit, which is a type of error or exception in quantum program development. ", Errors,,,,Errors,
21431.0,Getting non-Clifford after performing several Clifford gates in qiskit,"<p>I'm trying to test Clifford gates in qiskit according to the table in <a href=""https://web.physics.ucsb.edu/%7Emartinisgroup/theses/Kelly2015.pdf"" rel=""nofollow noreferrer"">Fault-tolerant SQ, page 101</a>. I tried 4 Cliffords in the test <span class=""math-container"">$$-X/2 - X -X/2,Y/2,X/2 - -X/2,Y/2,-X/2$$</span></p>
<p>using the following code</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, Aer, execute
from qiskit.quantum_info import Operator

qc = QuantumCircuit(1) 

qc.rx(-np.pi/2, 0)
qc.rx(np.pi, 0)
qc.rx(-np.pi/2, 0)
qc.ry(np.pi/2, 0)
qc.rx(np.pi/2, 0)

# 4th
qc.rx(-np.pi/2, 0)
qc.ry(np.pi/2, 0)
qc.rx(-np.pi/2, 0)

print('Final matrix:', Operator(qc).data)

qc.draw('mpl')
</code></pre>
<p>which gives me the output:</p>
<pre><code>Final matrix: [[ 0.   +0.707j -0.707+0.j   ]
 [ 0.707+0.j     0.   -0.707j]]
</code></pre>
<p>next, I found the inverse of this:</p>
<pre><code>np.linalg.inv(Operator(qc).data)
</code></pre>
<p>which gives me:</p>
<pre><code>[[ 0.   -0.707j  0.707+0.j   ]
 [-0.707+0.j    -0.   +0.707j]]
</code></pre>
<p>and didn't find the corresponding Clifford in the table as I was expeccting.</p>
<p>What do I do wrong in my calculations in qiskit?</p>
",<qiskit><programming><quantum-gate><circuit-construction><clifford-group>,10/06/2021 14:42,21437.0,21437.0,"<p>The matrix</p>
<p><span class=""math-container"">$$
M = \frac{1}{\sqrt{2}}\begin{bmatrix}-i &amp; 1\\-1 &amp; i\end{bmatrix}
$$</span></p>
<p>resembles</p>
<p><span class=""math-container"">$$
X/2 = \frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; -i\\-i &amp; 1\end{bmatrix}\tag1
$$</span></p>
<p>where we follow the notation <span class=""math-container"">$\pm X/2$</span> for the <span class=""math-container"">$\pm\frac{\pi}{2}$</span> rotation around the <span class=""math-container"">$X$</span> axis as used in the table B.6 on page 101 in Julian Kelly's PhD thesis. We can make the similarity more apparent by multiplying <span class=""math-container"">$M$</span> by the imaginary unit. We get</p>
<p><span class=""math-container"">$$
M\equiv iM = \frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; i\\-i &amp; -1\end{bmatrix}\tag2
$$</span></p>
<p>where <span class=""math-container"">$\equiv$</span> signifies equality up to global phase.</p>
<p>Comparing <span class=""math-container"">$(1)$</span> and <span class=""math-container"">$(2)$</span>, we see that up to global phase <span class=""math-container"">$M$</span> differs from <span class=""math-container"">$X/2$</span> only by the relative phase of <span class=""math-container"">$\pi$</span> between the two columns. We can introduce this phase difference using right-multiplication by <span class=""math-container"">$Z$</span>. We have</p>
<p><span class=""math-container"">$$
\begin{align}
M &amp;\equiv (X/2) Z \\
M &amp;\equiv (X/2) XY \\
M &amp;\equiv (-X/2) Y \\
M &amp;\equiv Y (X/2)
\end{align}
$$</span></p>
<p>where we used the identity <span class=""math-container"">$(X/2)X\equiv(-X/2)$</span> which follows from <span class=""math-container"">$X^2=I$</span> and <span class=""math-container"">$(-X/2)Y=Y(X/2)$</span> which follows from the fact that <span class=""math-container"">$X$</span> and <span class=""math-container"">$Y$</span> anti-commute.</p>
<p>Finally, we find <span class=""math-container"">$M\equiv Y(X/2)$</span> in the third row of the &quot;Hadamard-like&quot; section of the table B.6 and conclude that <span class=""math-container"">$M$</span> is a Clifford gate as expected.</p>
",10/06/2021 22:30,Errors ,"The user is trying to test Clifford gates in Qiskit and is not getting the expected output, which indicates an error or exception in quantum program development",Errors,,,,Errors ,
21485.0,How to import a generic stabilizer code in stim,"<p>I just started using <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> to simulate the performance of quantum error correcting codes. I hope this is the right place to ask questions about the subject. The
<a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">example code</a>
with the repetition code and depolarizing channel worked fine. Now I want to try one of my codes and the same channel. How would I import my code into stim? I can write the stabilizers as an <span class=""math-container"">$m \times n$</span> array (<span class=""math-container"">$m$</span> stabilizers, <span class=""math-container"">$n$</span> qubits) with entries from <span class=""math-container"">$(0,1,2,3)$</span>; this seems like the most straight forward way. <span class=""math-container"">$(0=I,1=X,2=Z,3=Y)$</span>.</p>
<p>For example, for the <span class=""math-container"">$[[5,1,3]]$</span> code <span class=""math-container"">$S:=[[1,2,2,1,0],[0,1,2,2,1],[1,0,1,2,2],[2,1,0,1,2]];$</span></p>
<p>Is this the preferred way? Do I also need to specify the logicals or destabilizers (I have these for some codes but maybe stim calculates them from the stabilizer...)</p>
",<programming><error-correction><simulation><stabilizer-code><stim>,10/09/2021 18:48,21486.0,21486.0,"<p>Stim is very much a circuit focused simulator. It speaks quantum operations, not stabilizer configurations, so you have to convert your table of stabilizers into a stabilizer circuit. This is a bit inconvenient, but ultimately makes Stim much more flexible as a tool (e.g. it has no issues with gauge codes or non-foliated codes).</p>
<p>The &quot;proper&quot; thing for you to do would be to find the encoding circuit for your code and put that into Stim. A fallback strategy could be to use the <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.5-Gate-Reference#MPP"" rel=""nofollow noreferrer""><code>MPP</code> instruction</a> (Measure Pauli Product) to measure the stabilizers of the code. For example, here is a circuit that projects into your given code, applies single qubit depolarizing noise, re-measures the stabilizers, and produces detection events based on whether or not each stabilizer was flipped:</p>
<pre><code>MPP X0*Z1*Z2*X3 X1*Z2*Z3*X4 X0*X2*Z3*Z4 Z0*X1*X3*Z4
DEPOLARIZE1(0.001) 0 1 2 3 4
MPP X0*Z1*Z2*X3 X1*Z2*Z3*X4 X0*X2*Z3*Z4 Z0*X1*X3*Z4
DETECTOR rec[-1] rec[-5]
DETECTOR rec[-2] rec[-6]
DETECTOR rec[-3] rec[-7]
DETECTOR rec[-4] rec[-8]
</code></pre>
<p>In python, you append MPP instructions like this:</p>
<pre><code>circuit.append_operation(&quot;MPP&quot;, [
    stim.target_x(0),
    stim.target_combiner(),
    stim.target_z(1),
    stim.target_combiner(),
    stim.target_z(2),
    stim.target_combiner(),
    stim.target_x(3),
])
</code></pre>
<p>(The target combiners (<code>*</code>) are needed because you can give multiple products to <code>MPP</code>.)</p>
<p>Measuring the stabilizers will randomly project the system into their +1 or -1 eigenstates. If for some reason you <strong>need</strong> the +1 eigenstate you can do a conditional Pauli correction, e.g. <code>CNOT rec[-1] 3</code> would apply an X gate to qubit 3 if the most recent measurement was True (presumably indicating the associated stabilizer measurement said the system was in the -1 eigenstate). The <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.5-Python-API-Reference#stimtableausimulatormeasure_kickbackself-target-int---tuple"" rel=""nofollow noreferrer""><code>stim.TableauSimulator.measure_kickback</code> method</a> is a bit technical but can be used for finding a Pauli correction that won't ruin the other stabilizers of the state.</p>
<p>Anyways, <em>ideally</em> you would know an encoding circuit already. Otherwise, Stim provides a few basic tools like <code>MPP</code> and<code>measure_kickback</code> to help discover some of the pieces of such a circuit, but doesn't currently have an end-to-end &quot;give me a well formed list of stabilizers and I give you a circuit&quot; helper method.</p>
",10/09/2021 20:05,Tooling,"This question falls under the ""Quantum Programming Tools"" category as it relates to using the Stim library to simulate quantum error correcting codes, which is a tool for quantum programming and simulation",Tooling,,,,Tooling,
21499.0,What is the syntax for general control gate in stim,"<p>For a stabilizer code with the stabilizers in canonical form, an encoding circuit has the form
that's a product of hadamard gates and general control gates : <span class=""math-container"">$H_i C_i(U_i)$</span>. For example for
the <span class=""math-container"">$[[5,1,3]]$</span> code, the circuit would be :</p>
<p><span class=""math-container"">$H_{2}C_{2}(Y_{1})$</span>
<span class=""math-container"">$H_{3}C_{3}(X_{1})$</span>
<span class=""math-container"">$H_{4}C_{4}(X_{1}Z_{2}Z_{3})$</span>
<span class=""math-container"">$H_{5}C_{5}(Y_{1}Z_{2}Z_{4})$</span></p>
<p><span class=""math-container"">$C_i(U_i)$</span> means apply <span class=""math-container"">$U_i$</span> depending on qubit <span class=""math-container"">$i$</span>. The normal <span class=""math-container"">$CNOT_{ij}$</span> would be <span class=""math-container"">$C_i(X_j)$</span>.
<span class=""math-container"">$CZ_{ij}$</span> gate would be <span class=""math-container"">$C_i(Z_j)$</span>; <span class=""math-container"">$U_i$</span> usually needs to be applied to multiple qubits.
How would a circuit like this be entered into stim?</p>
",<programming><circuit-construction><stabilizer-code><stim>,10/11/2021 03:14,21501.0,21501.0,"<p>There currently isn't a controlled Pauli product gate in Stim. You have to decompose it into a series of <code>CX</code>, <code>CY</code>, and <code>CZ</code> gates.</p>
<pre><code># Apply X1*Y2*Z3 controlled by qubit 0
CX 0 1
CY 0 2
CZ 0 3

# Apply X1*Y2*Z3 if latest measurement result was True
CX rec[-1] 1
CY rec[-1] 2
CZ rec[-1] 3
</code></pre>
",10/11/2021 07:10, Tooling,The question is asking about how to enter a stabilizer code circuit into Stim. This is a tooling question,Tooling,,,, Tooling,
21510.0,"Q#/VS: No namespace with the name ""Microsoft.Quantum.Canon"" exists","<p>I am trying to run a simple &quot;Hello World&quot; project in Q#, following <a href=""https://www.c-sharpcorner.com/article/getting-started-with-q-programming/"" rel=""nofollow noreferrer"">this tutorial</a>. I have completed the following steps (Step #s from tutorial link):</p>
<ul>
<li>Step 1: Installed the latest version of Visual Studio 2019 (16.11.4 Preview 1.0)</li>
<li>Step 2: Installed Microsoft Quantum Development Kit</li>
<li>Step 3: Created a Q# Project using the Q# Application Template</li>
</ul>
<p>The resulting <code>Program.qs</code> file appears in vs:</p>
<pre><code>namespace Quantum.QSharpHelloWorld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    
    @EntryPoint()
    operation HelloQ () : Unit {
        Message(&quot;Hello quantum world!&quot;);
    }
}
</code></pre>
<p>The two namespaces I am trying to <code>open</code> show the red squiggly line, with the errors</p>
<blockquote>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Canon&quot; exists.</p>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Intrinsic&quot; exists.</p>
</blockquote>
<p>Additionally and likely the same root cause, the <code>@EntryPoint</code> annotation and <code>Message()</code> call fail:</p>
<blockquote>
<p>QS6005: No type with the name &quot;EntryPoint&quot; exists in any of the open namespaces.</p>
<p>QS5022: No identifier with the name &quot;Message&quot; exists.</p>
</blockquote>
<p>In the solution explorer for my projet <code>QSharpHelloWorld</code>, the Dependencies, Packages, and each of five packages (Microsoft.Quantum.CSharpGeneration, .EntryPointDriver, .QSharp.Core, .Runtime.Core, and .Standard) all have the yellow triangle warning indicating a problem.</p>
<p>The error is similar to the one in <a href=""https://quantumcomputing.stackexchange.com/questions/12520/q-error-no-namespace-with-the-name-microsoft-quantum-machinelearning-exists"">this question</a>, except I'm not using Python so the accepted answer is irrelevant.  I attempted to use the command suggested in <a href=""https://quantumcomputing.stackexchange.com/a/12573/13421"">another answer</a>:</p>
<pre><code>dotnet add QSharpHelloWorld.csproj package Microsoft.Quantum.CSharpGeneration
</code></pre>
<p>However, this failed with the following error, suggesting this is the wrong solution:</p>
<pre><code>error: Error while performing Update for package 'Microsoft.Quantum.CSharpGeneration'. Cannot edit items in imported files -
error:   Item 'PackageReference' for 'Microsoft.Quantum.CSharpGeneration' in Imported file 'C:\[...]\.nuget\packages\microsoft.quantum.sdk\0.19.2109165653\Sdk\Sdk.props'.
</code></pre>
<p>I can't find any other obvious/easy menu options or fixes for this.  Other questions I've found here on SE all seem to be related to Python integration, not using Visual Studio.  I have the feeling I'm missing something trivial and obvious. Can anyone suggest additional steps I can take?</p>
",<programming><q#>,10/11/2021 18:25,21511.0,21511.0,"<p>Thanks to <a href=""https://quantumcomputing.stackexchange.com/users/2879/mariia-mykhailova"">@Maria Mykhailova</a> who pointed me to <a href=""https://stackoverflow.com/questions/67831975/how-do-i-get-hellow-quantum-world-to-run-in-visual-studio-2019"">this StackOverflow question</a> with similar symptoms.  This comment (lightly edited) in one of the answers was helpful:</p>
<blockquote>
<p>Then there is something broken with your local NuGet cache. Empty it by removing everything inside the packages folder and then run the command dotnet restore again.</p>
</blockquote>
<p>While I didn't &quot;remove everything&quot; I did remove the five problematic packages, which enabled the program to execute following a restore.</p>
<p>I still had the &quot;red squiggly&quot; symptom in the VS editor, but <a href=""https://youtu.be/5UT8RkSmN4k"" rel=""nofollow noreferrer"">closing and reopening Visual Studio</a> seemed to resolve these as well.</p>
",10/11/2021 20:06,Tooling,"The question is asking how to fix a problem with the Microsoft Quantum Development Kit in Visual Studio. This is a tooling question, as it is asking about how to use a specific tool.",Tooling,,,,Tooling,
21534.0,How to perform encoding and syndrome measurement in stim,"<p>I can generate the encoding circuit of a stabilizer code and can read it into
<a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a>. For example for the <span class=""math-container"">$[[5,1,3]]$</span> code :</p>
<pre><code> circuit=stim.Circuit()
 circuit.append_operation(&quot;H&quot;,[1])
 circuit.append_operation(&quot;CY&quot;,[0,4])
 circuit.append_operation(&quot;H&quot;,[2])
 circuit.append_operation(&quot;CX&quot;,[1,4])
 circuit.append_operation(&quot;H&quot;,[3])
 circuit.append_operation(&quot;CZ&quot;,[2,0])
 circuit.append_operation(&quot;CZ&quot;,[2,1])
 circuit.append_operation(&quot;CX&quot;,[2,4])
 circuit.append_operation(&quot;H&quot;,[4])
 circuit.append_operation(&quot;CZ&quot;,[3,0])
 circuit.append_operation(&quot;CZ&quot;,[3,2])
 circuit.append_operation(&quot;CY&quot;,[3,4])
</code></pre>
<p>To check this I'd like to encode a random qubit then measure the syndrome for the 4 stabilizers; if everything is correct the syndrome should always be <span class=""math-container"">$(0,0,0,0)$</span>.</p>
<p>First step : the &quot;data&quot; qubit is placed on qubit 4 (numbering starts from 0). So the input to
the encoder is <span class=""math-container"">$(q0=0,q1=0,q2=0,q3=0,q4=d0)$</span>. <span class=""math-container"">$k=1$</span> for this code so there's only one data qubit.
How would I initialize the input to be of that form?</p>
<p>Second step : I have 4 stabilizers which are just Pauli strings of length 5. I'd like to measure the syndromes and place the result on 4 ancilla qubits. How would I do that and then check that the syndromes are 0?</p>
",<programming><error-correction><stabilizer-code><stim>,10/14/2021 2:16,21535.0,21535.0,"<p>You can use the <code>MPP</code> instruction to measure a Pauli product. For example, if one of the prepared stabilizers is <span class=""math-container"">$X_1 \cdot Z_2 \cdot Y_3 = +1$</span> then you can do:</p>
<pre><code># [... encoding circuit ... ]

# measure stabilizer
MPP X1*Z2*Y3
# and claim it's supposed to have a deterministic result
DETECTOR rec[-1]
</code></pre>
<p>If you now sample the detectors of the circuit via <code>circuit.compile_detector_sampler().sample(shots=10)</code> you should get back a numpy array filled with 0s, indicating the system has been prepared into an eigenstate of the stabilizer. If you instead see a 50/50 mix of 0s and 1s, something is wrong.</p>
<p>The next step would be to do that for each stabilizer, and then add noise and confirm that you see the stabilizers flipping:</p>
<pre><code># [... encoding circuit ... ]

# phase damp qubit 3, potentially flipping the stabilizer
Z_ERROR(0.1) 3

# measure stabilizer
MPP X1*Z2*Y3
# and claim it's supposed to have a deterministic result
DETECTOR rec[-1]
</code></pre>
<p>Beware that adding <code>Z 3</code> is <em>not</em> the same thing as adding <code>Z_ERROR(1) 3</code>. Detectors compute what the expected value is supposed to be, and report deviations from that value arising from noise. <code>Z 3</code> is part of the expected value calculation, whereas <code>Z_ERROR(1) 3</code> is part of the noise.</p>
<p>You can use <code>MPP(wrong_result_probability)</code> to make the measurement result itself noisy (with no effect on the qubits).</p>
<p>You may also want to decompose the compound measurement into some underlying gateset, and make each of the individual operations noisy. Stim won't do that for you, but you can of course tell it the decomposed measurement's circuit as well as the noise mechanism instructions around each of its pieces.</p>
",10/14/2021 3:05,Tooling,"The user question primarily pertains to the practical aspects of implementing quantum error correction using the Stim library, which involves tools and software usage in quantum programming.",Tooling,,,,Tooling,
21541.0,Computing expectation value of a Pauli string on stabilizer states,"<p>I need some help on <code>stim</code>, where I'm trying to compute expectation values of Pauli strings. Hopefully I did not overlook on the documentation an implementation of this method.</p>
<h1><strong>Problem Statement</strong></h1>
<p>Given a generic Pauli string <span class=""math-container"">$O$</span> acting on <span class=""math-container"">$N$</span> qubits and a stabilizer state <span class=""math-container"">$\rho$</span> on <span class=""math-container"">$N$</span> qubits, compute within <code>stim</code> the expectation value
<span class=""math-container"">\begin{equation}
\langle O\rangle \equiv \mathrm{Tr}(O \rho).
\end{equation}</span>
Since <span class=""math-container"">$O$</span> is a Pauli string, <span class=""math-container"">$\langle O\rangle \in \{0,+1,-1\}$</span>.</p>
<h1><strong>Tentative Solution</strong></h1>
<p>To be concrete, within this question I fix <span class=""math-container"">$N=4$</span>, and I want to compute <span class=""math-container"">$\mathrm{Tr}(X_1 Z_3 \rho)$</span>. Furthermore, I specify I work on the <code>c++</code> library, within which my state is contained in an instance of <code>TableauSimulator</code>:</p>
<pre><code>...
using namespace stim;
using namespace std;

mt19937_64 rng(1); // Random generator with SEED=1
MeasureRecord record; // Measurement records
TableauSimulator Psi(ref(rng),4,0,record); 
// 0 is the unbiased-condition of the output sign for non-deterministic measurements

...
</code></pre>
<p>Now, I know I can apply a measurement gate <code>MPP X1Z3</code>. If this measurement is deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> commute with <span class=""math-container"">$\rho$</span>), the measurement readout gives <span class=""math-container"">$\langle O\rangle$</span>, which is either <span class=""math-container"">$+1$</span> or <span class=""math-container"">$-1$</span>.
If, instead, the measurement is non-deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> anticommute with <span class=""math-container"">$\rho$</span>), <span class=""math-container"">$\langle O\rangle=0$</span>.
Given the above, I tried the following. I initialize two new <code>TableauSimulator</code></p>
<pre><code>TableauSimulator PsiPlus = Psi;
TableauSimulator PsiMinus = Psi;
</code></pre>
<p>and applied to them <code>PsiPlus</code> the gate <code>MPP X1Z3</code>, whereas in <code>PsiMinus</code> the gate <code>MPP !X1Z3</code>. Then, since in general
<span class=""math-container"">\begin{equation}
\langle O\rangle = \mathrm{Tr}(O\rho) = \mathrm{Tr}\left(\frac{1+O}{2}\rho\right) -\mathrm{Tr}\left(\frac{1-O}{2}\rho\right) = p(+1) - p(-1),
\end{equation}</span>
I expect the difference:</p>
<pre><code>int aveO = PsiPlus.measurement_record.storage[last_entry]-PsiMinus.measurement_record.storage[last_entry];
</code></pre>
<p>where last_entry is the index of the last measurement (respectively of <code>MPP X1Z3</code> for <code>PsiPlus</code> and <code>MPP !X1Z3</code> for <code>PsiMinus</code>) should be the required value <span class=""math-container"">$\langle O\rangle$</span>.</p>
<p><strong>Problems</strong> There are problems with the above approach/ideas/implementation. It works if the measurement is deterministic, but it in general it doesn't for non-deterministic measurements (which is the main issue to solve). I think the reason is, since both states refer to the same random generator, the randomness in PsiPlus and PsiMinus are inequivalent, leading to different results (e.g. different internally drawn random numbers).
Furthermore, the operations required can be probably reduced.
Lastly, I conclude with a remark.
For single site measurements, the above issue do not figure in the present release of <code>stim</code>, as there is a method <code>TableauSimulator.is_deterministic_x</code> (and similarly for y,z) which should exactly check if the outcome of <code>MX</code> (<code>MY</code>,<code>MZ</code>) is deterministic or not. If a similar method would be present for generic <code>MPP</code>, probably a solution would still be easily implementable. In <em>pseudo-code</em>:</p>
<pre><code>int aveO;
if (Psi.is_deterministic_mpp(`X1Z3`,{1,3}) {
    TableauSimulator PsiM = Psi;
    PsiM.apply_mpp(`X1Z3`,{1,3});
    aveO = PsiM.measurement_record.storage[last_item];
}
</code></pre>
<p>Still, I'm not an expect in HPC, but probably there are smarter way to implement the computation of expectation values.</p>
",<programming><stabilizer-state><stim>,10/14/2021 13:15,21544.0,21544.0,"<p>You can use <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.8-Python-API-Reference#stim.TableauSimulator.peek_observable_expectation"" rel=""nofollow noreferrer""><code>stim.TableauSimulator.peek_observable_expectation</code></a> to compute the expected value of Pauli product observables without affecting the simulator's state:</p>
<pre><code>import stim
s = stim.TableauSimulator()
s.h(0)
s.cnot(0, 1)
obs = stim.PauliString('-YY')
expect = s.peek_observable_expectation(obs)
print('peek', obs, '=', expect)
</code></pre>
<p>prints:</p>
<pre><code>peek -YY = +1
</code></pre>
",10/14/2021 16:28,Tooling,The question is asking about how to compute the expectation value of a Pauli string using the Stim library. This is a tooling question, Tooling,,,,Tooling,
21574.0,How to set hyper parameters for a Variational Quantum Classifier (qiskit)?,"<p>I am trying to implement a Variational Quantum Classifier using qiskit's VQC. I have set the feature map to <code>ZZFeatureMap</code> and am using the <code>RealAmplitudes</code> ansatz. I am using <code>cross_entropy</code> loss function and <code>ADAM</code> optimiser. One more parameter that VQC requires is a QuantumInstance object and this I have set to <code>aer_simulator</code> with <code>1024 shots</code>.
The code and instructions I followed is in this <a href=""https://qiskit.org/documentation/machine-learning/tutorials/02_neural_network_classifier_and_regressor.html"" rel=""nofollow noreferrer"">qiskit's tutorial</a>.</p>
<p>When I try to train the classifier, it running for a different number of iterations each time. <strong>Is there a way to set minimum number of iterations ? and how are iterations different from shots ?</strong></p>
<p>Also, how can I set the learning rate for the algorithm ? Thank you !</p>
",<qiskit><programming><quantum-enhanced-machine-learning>,10/18/2021 4:05,21577.0,21577.0,"<p>The VQC consists of a feedback loop of quantum and classical processor, where the loss function is evaluated on a quantum computer and the classical part suggests new parameters. The number of shots is the number of samples the quantum computer does to estimate the expectation values (-&gt; the loss function). The number of iterations is the number of times the classical part updates the parameters.</p>
<p>The settings you want to specify are part of the <em>classical optimizer</em>, in your case ADAM. Following the tutorial you linked, I'm assuming you're constructing the algorithm as</p>
<pre><code># construct feature map, ansatz, and optimizer
feature_map = ZZFeatureMap(num_inputs)
ansatz = RealAmplitudes(num_inputs, reps=1)
optimizer = ADAM()

# construct variational quantum classifier
vqc = VQC(feature_map=feature_map,
          ansatz=ansatz,
          loss='cross_entropy',
          optimizer=optimizer,
          quantum_instance=quantum_instance,
          callback=callback_graph)
</code></pre>
<p>You can pass your settings into the <code>ADAM</code> class, for instance to set the learning rate</p>
<pre><code>optimizer = ADAM(lr=your_desired_learning_rate)
</code></pre>
<p>The number of iterations depends on the convergence and I don't think you can set a minimum number of them. However you can set a lower tolerance which will lead to more iterations. For example</p>
<pre><code>optimizer = ADAM(lr=0.01, tol=1e-7)
</code></pre>
<p>You can find more on that in the <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.ADAM.html?highlight=adam#qiskit.algorithms.optimizers.ADAM"" rel=""nofollow noreferrer"">documentation</a>.</p>
",10/18/2021 8:41,API Usage," The user is asking about how to configure specific parameters and settings, such as the minimum number of iterations, the difference between iterations and shots, and setting the learning rate for a machine learning algorithm in Qiskit's VQC. These questions involve interacting with the API and configuring the behavior of the quantum machine learning algorithm.",Tooling,"The user is seeking assistance in configuring and controlling the training process of a Variational Quantum Classifier (VQC) using Qiskit, which falls under the tooling category, as it's related to the usage and settings of the software/library for quantum programming.",No,117.0,API Usage,"The user is inquiring about configuring specific parameters and settings for a Variational Quantum Classifier (VQC) in Qiskit, such as setting the minimum number of iterations, understanding the difference between iterations and shots, and setting the learning rate. These questions pertain to interacting with the API and configuring the behavior of the machine learning algorithm, making it fitting for the API Usage category."
21618.0,"What is the meaning of ""shots"" and ""rounds"" in Stim?","<p>I'm running simulations using Stim to get logical error rate vs. physical error rates of some quantum error correcting codes (<a href=""https://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">QECC</a>).</p>
<p>I looked into the documentation, but I'm confused about the meaning of &quot;shots&quot; and &quot;rounds&quot;. I think I understand the meaning of &quot;shots&quot;: repeat the state generation, add random noise at physical error rate, measure, decode, count logical errors. How would the &quot;rounds&quot; parameter enter the picture? Why would I need more than one round of measurement? (Assuming each round measures all stabilizers.)</p>
<p>Here a code sniplet of an example:</p>
<pre><code>def Test():
 num_shots = 1000
 xs = []
 ys = []
 for noise in [0.1, 0.2, 0.3, 0.4, 0.5]:
  circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_z&quot;,distance=3,rounds=1,before_round_data_depolarization=noise)
  xs.append(noise)
  ys.append(count_logical_errors(circuit, num_shots) / num_shots)
 plt.plot(xs, ys)
 plt.semilogy()
 plt.xlabel(&quot;physical error rate&quot;)
 plt.ylabel(&quot;logical error rate&quot;)
 plt.show()
</code></pre>
",<programming><error-correction><stim>,10/20/2021 18:41,21619.0,21619.0,"<p>A <em>shot</em> is a full run of a circuit. If your circuit contains 100 measurements, sampling a shot from that circuit will produce 100 bits of measurement information.</p>
<p>A <em>round</em> is a concept used by the circuit generation methods to parameterize how deep you want the generated circuit to be. Each of the generated circuits repeatedly measures some set of local stabilizers by using ancillary measurement qubits. The number of rounds is defined to be the number of times each ancillary measurement qubit is measured. Concretely, these circuits all have a big <code>REPEAT X { ... }</code> block in the middle, and incrementing the number of rounds will increment <code>X</code>.</p>
",10/20/2021 20:18,Tooling,"The user is asking about the meaning of shots and rounds parameters in the Stim library, which falls under the category of tool",Tooling,,,,Tooling,
21661.0,How to perform multi-class classification with qiskit's VQC?,"<p>I am following the tutorial given in qiskit's website <a href=""https://qiskit.org/documentation/machine-learning/tutorials/02_neural_network_classifier_and_regressor.html"" rel=""nofollow noreferrer"">Neural Network Classifier and Regressor</a>. In the first part, classification, the third section refers to qiskit's VQC library. Everything works fine with the given X and y where there are only two classes. I modified the X and y slightly to include four classes instead of two using the following lines:</p>
<pre><code>num_inputs = 2
num_samples = 100

X = 2*np.random.rand(num_samples, num_inputs) - 1
y = np.random.choice([0,1,2,3], 100)

y_one_hot = np.zeros(( num_samples, 4 ))
for i in range(len(y)):
    y_one_hot[i, y[i]]=1
</code></pre>
<p>The rest of the code is untouched. VQC with ZZFeatureMap, RealAmplitudes ansatz, cross_entropy loss function and COBYLA() optimizer.
However, when I try to fit with this new data, the classifier is only running for 5 iterations and the weights are not being changed at all. The loss or objection function's value is always calculated as &quot;nan&quot;.</p>
<p>There is a <a href=""https://quantumcomputing.stackexchange.com/questions/21568/qiskits-classifier-is-not-optimising-the-weights"">similar question</a> I had posted about weights not being optimized with VQC, but then I thought it was because of my data or VQC's configuration. After trying this example, I realised it is clearly to do something with multiple classes and not just the classifier's configuration.</p>
<p>Please shine light on how to do multi-class classification using the qiskit's VQC library.</p>
",<qiskit><programming><quantum-enhanced-machine-learning>,10/24/2021 18:43,23948.0,23948.0,"<p>This has been resolved now. The above mentioned problem was an issue with 0.3.0 version qiskit_machine_learning library. You can get more details about the issue and how it has been resolved <a href=""https://github.com/Qiskit/qiskit-machine-learning/issues/251"" rel=""nofollow noreferrer"">here</a>.</p>
<p><strong>TLDR</strong>: Install the 0.4.0 developer's version of qiskit_machine_learning library. Clone this <a href=""https://github.com/Qiskit/qiskit-machine-learning"" rel=""nofollow noreferrer"">repository</a> and from with the folder, run <code>pip install .</code></p>
",02/04/2022 12:27,Errors,"The user is facing an issue related to the behavior of the qiskit's VQC library when performing multi-class classification. They are encountering problems with weight optimization and obtaining ""nan"" loss values, which are errors or issues in their implementation.",Errors,,,,Errors,
21680.0,How to create known quantum state in Qiskit (or any other platform) comprising of two or more bits?,"<p>Is there there any way to create a known quantum state in Qiskit (or any other platform) comprising of two or more than two bit?</p>
<p>For example if I want to create <span class=""math-container"">$\frac{1}{\sqrt{3}}[|00\rangle+|01\rangle+|11\rangle]$</span>. What I want to do is to know the unitary transformation ( or the quantum circuit) to prepare this (or any valid) quantum state for me.</p>
",<qiskit><programming><quantum-state><state-preparation>,10/26/2021 9:51,21684.0,21684.0,"<p>As Martin Vesely mentioned in the comments, you can use the <code>initialize</code> function to perform such a task. For instance, to create the state you desire, you can do the following:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.transpiler.passes import Decompose

qc = QuantumCircuit(2)
initial_state = np.array([1, 1, 0, 1], dtype=float)
initial_state /= np.linalg.norm(initial_state)
qc.initialize(initial_state)
qc.decompose().decompose().decompose().decompose().draw(&quot;mpl&quot;)
</code></pre>
<p>which draws the following output:</p>
<p><a href=""https://i.stack.imgur.com/EtzWM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EtzWM.png"" alt=""Decomposed circuit"" /></a></p>
<p>To know how does qiskit create this unitary, have a look at <a href=""https://quantumcomputing.stackexchange.com/a/18475/10454"">this answer</a>.</p>
",10/26/2021 22:04,Tooling,"The user is asking about how to create a known quantum state in Qiskit, which falls under the category of tool",Tooling,,,,Tooling,
21700.0,Measurement bitstrings to detection event bitstrings in stim,"<p>Does Stim have exposed functionality for converting a measurement outcome string into a detection event string?</p>
<p>I.e. I feed stim a string of 0,1's corresponding to measurements in a circuit along with the circuit itself, and it spits out a string of 0,1's corresponding to the detection events in that circuit?  Of course this functionality exists under the hood, but just wondering where and how it's accessible.</p>
",<programming><error-correction><stim>,10/27/2021 18:55,21701.0,21701.0,"<p>You can use <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.6-Python-API-Reference#stim.Circuit.compile_m2d_converter"" rel=""nofollow noreferrer""><code>stim.Circuit.compile_m2d_converter</code></a> to get an object that converts measurements into detection event data (and optionally also observable flip data). The actual conversion is then done with the method <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.6-Python-API-Reference#stim.CompiledMeasurementsToDetectionEventsConverter.convert"" rel=""nofollow noreferrer""><code>stim.CompiledMeasurementsToDetectionEventsConverter.convert</code></a> for in-memory results or <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.6-Python-API-Reference#stim.CompiledMeasurementsToDetectionEventsConverter.convert_file"" rel=""nofollow noreferrer""><code>stim.CompiledMeasurementsToDetectionEventsConverter.convert_file</code></a> for on-disk results.</p>
<p>This functionality is also available from the command line using <a href=""https://github.com/quantumlib/Stim/blob/main/doc/usage_command_line.md#m2d"" rel=""nofollow noreferrer""><code>stim m2d</code></a>.</p>
<p>Example:</p>
<pre><code>import stim

circuit = stim.Circuit(&quot;&quot;&quot;
    X 0
    X_ERROR(0.1) 0 1
    M 0 1
    DETECTOR rec[-1]
    DETECTOR rec[-2]
    OBSERVABLE_INCLUDE(0) rec[-1] rec[-2]
&quot;&quot;&quot;)
measurements = circuit.compile_sampler().sample(shots=100)

#############################################
#### Convert from measurements to detection events and observable flips.
#############################################
converter = circuit.compile_m2d_converter()
dets_and_obs = converter.convert(measurements=measurements, append_observables=True)

mes0 = measurements[:, 0]
mes1 = measurements[:, 1]
det0 = dets_and_obs[:, 0]
det1 = dets_and_obs[:, 1]
obs0 = dets_and_obs[:, 2]
print(&quot;mes0: &quot;, &quot;&quot;.join(&quot;01&quot;[int(e)] for e in mes0))
print(&quot;mes1: &quot;, &quot;&quot;.join(&quot;01&quot;[int(e)] for e in mes1))
print(&quot;det0: &quot;, &quot;&quot;.join(&quot;_!&quot;[int(e)] for e in det0))
print(&quot;det1: &quot;, &quot;&quot;.join(&quot;_!&quot;[int(e)] for e in det1))
print(&quot;obs0: &quot;, &quot;&quot;.join(&quot;_!&quot;[int(e)] for e in obs0))
</code></pre>
<p>Example output:</p>
<pre><code>mes0:  1111111111111001011111101010111111111111101101110111111111111111111111111111110111111011111111111011
mes1:  0000000100010000110000000000000000000100000000000000000001000000000000100100000000000000000000001100
det0:  _______!___!____!!___________________!___________________!____________!__!______________________!!__
det1:  _____________!!_!______!_!_!_____________!__!___!_____________________________!______!___________!__
obs0:  _______!___!_!!__!_____!_!_!_________!___!__!___!________!____________!__!____!______!__________!___
</code></pre>
<p>Note that creating the converter is as expensive as sampling measurements; it involves performing a stabilizer simulation of the circuit to get a reference sample (because otherwise it's unknown if the measurement set defining a detector is supposed to have even or odd parity).</p>
",10/27/2021 19:14,Tooling,"The user is asking about a specific functionality in the Stim library, which falls under the category of tool",Tooling,,,,Tooling,
21779.0,"How can I initialize a state like, $|00\rangle$ or $|01\rangle$ or $|10\rangle$ or $|11\rangle$ in Qiskit?","<p>Many thanks in advance for your help.
I am a beginner in Qiskit. I want to implement a circuit that uses the position of an element/item, of the form (x,y) and I would like to represent it as a state <span class=""math-container"">$|\phi\rangle = |xy\rangle$</span>.
How can I initialize a state like, <span class=""math-container"">$|00\rangle$</span> or <span class=""math-container"">$|01\rangle$</span> or <span class=""math-container"">$|10\rangle$</span> or <span class=""math-container"">$|11\rangle$</span>? Or how could I apply the tensor product to get it?</p>
",<qiskit><programming><quantum-gate><quantum-state>,11/03/2021 02:41,21781.0,21781.0,"<p>Here is Qiskit code you wanted:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister

q = QuantumRegister(2)
c = ClassicalRegister(2)

#state |00&gt;
circ00 = QuantumCircuit(q,c)
circ00.draw()
#do nothing, both qubits are already in state |0&gt;

#state |01&gt;
circ01 = QuantumCircuit(q,c)
circ01.x(q[1])
circ01.draw()

#state |10&gt;
circ10 = QuantumCircuit(q,c)
circ10.x(q[0])
circ10.draw()

#state |11&gt;
circ11 = QuantumCircuit(q,c)
circ11.x(q[0])
circ11.x(q[1])
circ11.draw()
</code></pre>
<p>State you want to prepare are so-called basis states in computational basis. You can easily prepare them with <span class=""math-container"">$X$</span> gate (i.e. equivalent of NOT in classical computation).
Initially, qubits are in state <span class=""math-container"">$|0\rangle$</span>. If you want to change one of them to state <span class=""math-container"">$|1\rangle$</span>, simply put on that qubit the <span class=""math-container"">$X$</span> gate.</p>
<p>Please run the code <em>per partes</em> to see how circuits differ for each of the basis states.</p>
<p>In Qiskit, you can also use function <code>initialize</code>. It uses vector representation of states, which are in your case:</p>
<ul>
<li><span class=""math-container"">$|00\rangle = \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}^T$</span></li>
<li><span class=""math-container"">$|01\rangle = \begin{pmatrix}0 &amp; 1 &amp; 0 &amp; 0\end{pmatrix}^T$</span></li>
<li><span class=""math-container"">$|10\rangle = \begin{pmatrix}0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}^T$</span></li>
<li><span class=""math-container"">$|11\rangle = \begin{pmatrix}0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}^T$</span></li>
</ul>
<p>So, the Qiskit code is following</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister, execute
import numpy as np

import numpy as np

q = QuantumRegister(2)
c = ClassicalRegister(2)
circ = QuantumCircuit(q,c)

#state = np.array([1,0,0,0]) #00
#state = np.array([0,1,0,0]) #01
#state = np.array([0,0,1,0]) #10
state = np.array([0,0,0,1]) #11

circ.initialize(state)
circ.measure(q,c)

processor = Aer.backends(name='qasm_simulator')[0] #simulator
res = execute(circ, processor, shots = 1).result().get_counts(circ)
print(res)

</code></pre>
",11/03/2021 09:36,Tooling ,"The user is asking about how to initialize a specific quantum state in Qiskit, which falls under the category of tool.",Tooling,,,,Tooling ,
21793.0,Qiskit's PauliTrotterEvolution yields weird gates,"<p>I am trying to work with Qiskit's PauliTrotterEvolution() module, but the resulting circuits contain weird gates that I know nothing about.</p>
<p>Here is a simple example: I want to implement the fermionic creation operator on one of two qubits</p>
<pre><code>from qiskit_nature.mappers.second_quantization import BravyiKitaevMapper
from qiskit_nature.operators.second_quantization import FermionicOp 
from qiskit.opflow.evolutions import PauliTrotterEvolution

fermi_op = FermionicOp(&quot;+I&quot;, display_format=&quot;dense&quot;) 
</code></pre>
<p>The fermionic operator is mapped to a sum of Pauli gates using the Bravyi-Kitaev mapper:</p>
<pre><code>mapper = BravyiKitaevMapper()
bosonic_op = mapper.map(fermi_op)
</code></pre>
<p>Now we apply the PauliTrotterEvolution to the exponential of the bosonic operator:</p>
<pre><code>pauli_trotter = PauliTrotterEvolution(&quot;trotter&quot;, reps=1)

conv = pauli_trotter.convert(bosonic_op.exp_i())

circ = conv.to_circuit()

circ.draw(&quot;latex&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/7inob.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7inob.png"" alt="""" /></a></p>
<p>I have no clue what these &quot;circuit&quot; gates are. Has anyone seen something similar before?</p>
",<qiskit><programming><quantum-gate><pauli-gates>,11/04/2021 10:16,21796.0,21796.0,"<p>These &quot;circuit&quot; gates are empty, if you transpile the circuit to a basis gate set they will disappear:</p>
<pre><code>from qiskit import transpile

circ = # your circuit
transpiled = transpile(circ, basis_gates=[&quot;h&quot;, &quot;s&quot;, &quot;sdg&quot;, &quot;rz&quot;, &quot;cx&quot;])
print(transpiled.draw())
</code></pre>
<p>As the answer of @viwosh points out, that behavior is also fixed in the newer versions of Qiskit.</p>
",11/04/2021 18:36,Errors,"The user is encountering unexpected gates in the resulting circuit when working with Qiskit's PauliTrotterEvolution module, and they are seeking an explanation for these unusual gates, which falls under the category of error.", Errors,,,,Errors,
21795.0,Is there a quantum circuit builder package that allows you to import/export a circuit as a JSON?,"<p>I've done a superficial search in each of the qiskit, cirq, and braket open source repositories for such a feature, but can't find any explicit examples of this functionality. I'm wondering if anyone knows more about how the quantum circuit objects are constructed behind the scenes in one or each of these packages and if any of the above-mentioned packages store circuit information in a data structure accessible to the user that could be translated to a JSON, or conversely, translate an appropriately formatted JSON to said data-structure and construct a circuit object through the &quot;back door&quot; in this way?</p>
",<qiskit><programming><quantum-circuit><cirq><amazon-braket>,11/04/2021 18:16,21800.0,21800.0,"<p>For Qiskit if your goal is to just export the circuit (or circuits) object to a file and then to create an identical circuit later I would suggest looking at QPY serialization: <a href=""https://qiskit.org/documentation/apidoc/qpy.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/apidoc/qpy.html</a> it's not a JSON serialization format but a binary one. It's designed to be a lossless backwards compatible format for saving and loading Qiskit's <code>QuantumCircuit</code> object. If you need it to be JSON you can base64 encode it to a string and embed it into a JSON payload with something like:</p>
<pre><code>import io
import json
import base64

from qiskit.circuit import qpy_serialization
from qiskit.circuit import QuantumCircuit

circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cx(0, 1)
circuit.measure_all()

buf = io.BytesIO()
qpy_serialization.dump(circuit, buf)
json_str = json.dumps({
    'circuits': base64.b64encode(buf.getvalue()).decode('utf8')
})
</code></pre>
<p>which will set <code>json_str</code> as a JSON payload like:</p>
<pre><code>{&quot;circuits&quot;: &quot;B64 Encoded QPY&quot;}
</code></pre>
<p>where <code>&quot;B64 Encoded QPY&quot;</code> is a large unreadable string. But then you can load this with Qiskit using:</p>
<pre><code>circuit_json = json.loads(json_str)
qpy_file = io.BytesIO(base64.b64decode(circuit_json[&quot;circuits&quot;]))
circuit = qpy_serialization.load(qpy_file)[0] # qpy works with multiple circuits at a time and returns a list
</code></pre>
<p>If this isn't a viable solution for what you need, you can look at Qobj which is a JSON payload format defined here: <a href=""https://arxiv.org/abs/1809.03452"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1809.03452</a> that you can use with something like:</p>
<pre><code>from qiskit import assemble

json_str = json.dumps(assemble(circuit).to_dict())
</code></pre>
<p>and loaded with:</p>
<pre><code>from qiskit.assembler import disassemble
from qiskit.qobj import QasmQobj

qasm_dict = json.loads(json_str)
circuits, _, __ = disassemble(QasmQobj.from_dict(qasm_dict))
circuit = circuits[0]
</code></pre>
<p>The tradeoff with Qobj is that it's not designed to be a lossless representation of a <code>QuantumCircuit</code> object and more a job submission payload for running on quantum computers. So it can't represent all the higher level objects a <code>QuantumCircuit</code> may contain.</p>
<p>However, if your goal is interoperability between tools then I would suggest looking at the OpenQASM language. OpenQASM 2.0 [1][2] is pretty widely supported by most quantum computing software (including Qiskit and Cirq), and the next version of the language OpenQASM 3.0 [3][4] is starting to be used.</p>
<p>[1] <a href=""https://arxiv.org/abs/1707.03429"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1707.03429</a></p>
<p>[2] <a href=""https://github.com/Qiskit/openqasm/tree/OpenQASM2.x"" rel=""nofollow noreferrer"">https://github.com/Qiskit/openqasm/tree/OpenQASM2.x</a></p>
<p>[3] <a href=""https://arxiv.org/abs/2104.14722"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2104.14722</a></p>
<p>[4] <a href=""https://github.com/Qiskit/openqasm"" rel=""nofollow noreferrer"">https://github.com/Qiskit/openqasm</a></p>
",11/04/2021 20:40,Tooling,"The user is asking about how quantum circuit objects are constructed and stored in Qiskit, Cirq, and Braket, and whether these can be translated to a JSON format. This falls under the category of tool .",Tooling,,,,Tooling,
21811.0,How to convert code from QISKIT to QuEST using QASM,"<p>I have been working on this project which requires a lot of qubits. Originally we have made the whole project in QISKIT as we have been using it for a long time. But the maximum number of qubits that can be simulated in qiskit can not be more than a 100 qubits. Due to which are planning to use <a href=""https://quest.qtechtheory.org/"" rel=""nofollow noreferrer"">QuEST</a> which can simulate a lot more qubits. Now instead of converting the whole code which is taking a lot of time, we were thinking if we could convert the qiskit code for each case into QASM and then use the QASM code to convert to QuEST, this way we will be saving a lot of time. And we found another <a href=""https://github.com/oerc0122/QASMParser"" rel=""nofollow noreferrer"">project</a> which is based on this itself. But as there are not a lot of resources regarding this I am facing a lot of issues with this. I was wondering if you guys had some tips and tricks .</p>
<p>Thanks any help is greatly appreciated!!</p>
",<qiskit><programming><qasm>,11/05/2021 11:51,24239.0,24239.0,"<p>Developer of QuEST here. It sounds like QuEST isn't the right tool for your needs. QuEST is a 'full-state' simulator (the 'E' stands for 'exact'), so its memory requirements scale exponentially with the number of simulated qubits. A <code>250</code> qubit simulation (at double precision) would require <code>~10^64 TiB</code>,
which you could get by magicking every atom on Earth into a Titan supercomputer.</p>
<p>For a generic quantum circuit, <code>250</code> qubits is a very demanding simulation. Are you simulating a specific family of circuits that permit bespoke classical simulation?</p>
",2/24/2022 5:35,Tooling,"The question is asking about how to convert Qiskit code to QuEST code using QASM. This is a question about using the tools Qiskit, QuEST, and QASMParser, so it falls under the category of tool usage.",Tooling,,,,Tooling,
21820.0,Create your own n-qubit quantum gate in Qiskit,"<p>I need to create the 2-qubit gates that are not supported by Qiskit (Ex: Controlled - F gate). Is there any way to create a class/object and use it as other basic gates?</p>
<p>Example:</p>
<pre><code>qc = qiskit.QuantumCircuit(2,2)
qc.h(0)
qc.cf(0, 1)
</code></pre>
<p>Thanks!</p>
",<qiskit><programming><quantum-gate>,11/06/2021 12:50,21824.0,21824.0,"<p>One way to achieve this is as follows:</p>
<pre><code>from qiskit import QuantumCircuit

def cf(circuit, qubit1, qubit2):
    # Create a circuit that is equivalent to your gate:
    qc = QuantumCircuit(2)
    qc.cx(0, 1)
    qc.csx(1, 0)
    qc.cx(0, 1)

    # Convert the circuit to a gate:
    sr_swap = qc.to_gate(label = 'âSWAP')

    # Add the gate to your circuit which is passed as the first argument to cf function:
    circuit.append(sr_swap, [qubit1, qubit2])

# We need this line to add the method to QuantumCircuit class:
QuantumCircuit.cf = cf
</code></pre>
<p>Now, you can use <code>cf</code> as other <code>QuantumCircuit</code> gates:</p>
<pre><code>circ = QuantumCircuit(2)
circ.cf(0, 1)
circ.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/NeHys.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NeHys.png"" alt=""enter image description here"" /></a></p>
",11/06/2021 21:28,Tooling," The user is asking about how to create custom 2-qubit gates in Qiskit, which falls under the category of tool",Tooling,,,,Tooling,
21826.0,is there such things as Quantum Operating system?,"<p>Wikipedia informed me about quite a lot of language that exist for quantum computing, with diverse low or high level language, but I don't know about specific operating system made for specific architecture of quantum computers.</p>
<p>Are we at the same level of development of the (personnal) computer's themselves in the 70/80's where every brand has his own language, instruction set and chipset ? or is there something like a posix for QC ?</p>
",<programming>,11/07/2021 03:22,21827.0,21827.0,"<p>There does exist the so-called quantum operating system, for example, <a href=""https://www.rayradar.com/2021/02/08/benyuan-quantum-releases-benyuan-sinan-the-first-quantum-computer-operating-system-in-china/"" rel=""nofollow noreferrer"">this one</a>. But I don't think you can compare the process of a quantum computer with a classical computer. At least for now, I think the best hope is to build a quantum computer that can offer quantum computing services in the style of cloud computing, while universal quantum computers might really be very far from us.</p>
",11/07/2021 09:24,Conceptual,"The question is asking about the state of development of operating systems for quantum computers, which is a conceptual topic.", Conceptual,,,,Conceptual,
21905.0,Simulating readout errors on aer simulator,"<p>I'm trying to <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.noise.ReadoutError.html#qiskit.providers.aer.noise.ReadoutError"" rel=""nofollow noreferrer"">simulate quantum experiments using a customized noise model</a>. Here's my code:</p>
<pre><code>probabilities[0] = [0.9, 0.15]
probabilities[1] = [0.1, 0.85]
readout_noise_model = NoiseModel()
readout_noise_model.add_readout_error(probabilities[0], [0])
readout_noise_model.add_readout_error(probabilities[1], [0])
</code></pre>
<p>However, as I run the code, it returns me</p>
<pre><code>--&gt; 259         num_outcomes = len(probabilities[0])
    260         num_qubits = int(np.log2(num_outcomes))
    261         if 2**num_qubits != num_outcomes:

TypeError: object of type 'float' has no len()
</code></pre>
<p>I don't know why this happens since I could find <code>len(probabilities[0])=2</code>. How can I set up the noise model for readout errors? Thanks so much for the help!</p>
",<qiskit><programming><ibm-q-experience><simulation>,11/12/2021 17:56,21914.0,21914.0,"<p>According to the link that you provide in the first sentence of the question, you should write a single line</p>
<pre><code>readout_noise_model.add_readout_error(probabilities, [0])
</code></pre>
",11/13/2021 19:19,Errors,"The user is encountering an error in their code while attempting to set up a noise model for readout errors in Qiskit. They are seeking a solution to resolve this error, making it fall under the category of error.",Errors,,,,Errors,
21960.0,Reading a classical register in OPENQASM,"<p>The IBM OpenQASM program below clones a state selected from an orthogonal pair. It seems to work but there is a mystery. I declare the classical register as an array c[1] but when I try to test its contents, the assembler will not allow me to index it. That is, it rejects &quot;c[0]&quot;. I get similar results if there is an array of two registers; I always have to use the array name rather than a reference to an array element. My question is, how do you reference one classical register within an array, for example in an &quot;if&quot; statement.</p>
<p>There is a second question, less pressing but important. I don't know who to make a block of code that is executed when the &quot;if&quot; test passes. I am forced to repeat the test for each line in the block. How do you declare a block of code or, equivalently, use a branch statement to skip a block?</p>
<pre><code>cloner1 = &quot;&quot;&quot;
OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
qreg q[5];
creg c[1];
x q[2];
x q[4];

x q[0]; //Set up input
measure q[0] -&gt; c[0];
if (c==1) CX q[1],q[2];
if (c==1) CX q[2],q[1];
if (c==1) CX q[1],q[2];
if (c==1) CX q[3],q[4];
if (c==1) CX q[4],q[3];
if (c==1) CX q[3],q[4];
measure q[1]-&gt;c[0];
measure q[3]-&gt;c[0];
&quot;&quot;&quot;
<span class=""math-container"">```</span>
</code></pre>
",<qiskit><programming>,11/17/2021 5:03,22004.0,22004.0,"<p>In OpenQASM 2, <code>if</code> statement conditionally executes a single quantum operation based on the integer value stored across the classical register rather than on the individual bits.</p>
<p>As per the language specs (<a href=""https://arxiv.org/abs/1707.03429"" rel=""nofollow noreferrer"">arXiv:1707.03429</a>):</p>
<blockquote>
<p>The <code>if</code> statement conditionally executes a quantum operation based on
the value of a classical register. This allows measurement outcomes to
determine future quantum operations. We choose to have one decision
register for simplicity. This register is interpreted as an integer,
using the bit at index zero as the low order bit. The quantum
operation executes only if the register has the given integer value.
Only quantum operations, i.e. builtin gates, gate (and opaque)
subroutines, preparation, and measurement, can be prefaced by <code>if</code>.</p>
</blockquote>
<p>This fact is repeated in OpenQASM 3 document also (<a href=""https://arxiv.org/abs/2104.14722"" rel=""nofollow noreferrer"">arXiv:2104.14722</a>):</p>
<blockquote>
<p>The only control flow supported by OpenQASM2 are <code>if</code> statements.
These can be used to compare the value of a classical bit-register
(interpreted as a little-endian representation of an integer) to an
integer, and conditionally execute a single gate. An example of such a
statement is</p>
<p><code>if (c == 5) mygate q, r, s;</code></p>
<p>which would test whether a
classical register c (of length three or more) stores a bit-string
<span class=""math-container"">$c_{n-1} ... c_3c_2c_1c_0$</span> equal to <span class=""math-container"">$0...0101$</span>, to determine whether
to execute <code>mygate q, r, s</code>. If-statements (and classical register
comparisons) of this kind are supported in OpenQASM3, as is more
general syntax for <code>if</code> statements and other forms of control-flow.</p>
</blockquote>
<p>Also, see this answer:
<a href=""https://quantumcomputing.stackexchange.com/a/4516/9474"">https://quantumcomputing.stackexchange.com/a/4516/9474</a></p>
<p>Note that, in OpenQASM 3 you can condition on the value of single classical bit:</p>
<pre><code>if (c[0] == 1) p(-ð/4) q[2];
if (c[1] == 1) p(-ð/2) q[2];
</code></pre>
<p>See the example in page 20 in the language specs. Moreover, the document states that:</p>
<blockquote>
<p>We also extend the if statement syntax to allow for multiple
instructions within the body of the <code>if</code>, and to allow for an <code>else</code> block
to accompany it.</p>
</blockquote>
",11/20/2021 9:33, Errors ,"The user is seeking solutions and explanations for errors and exceptions in their quantum program development, specifically about referencing a classical register within an array and declaring a block of code in IBM OpenQASM program",Errors,,,, Errors ,
21964.0,Stim: is it possible to add comments when creating a circuit?,"<p>I'm trying to create a Stim.Circuit, given a list of qubits and operations on them. Does the API support adding comments to the circuit's string representation? I've tried using <code>circuit.append_from_stim_program_text('# Some comment')</code>, but such comments never appear when I later call <code>print(repr(circuit))</code>, so I presume this method only cares about appending actual circuit instructions. Any help / workarounds appreciated!</p>
",<programming><stim>,11/17/2021 10:59,21965.0,21965.0,"<p>No, the python API doesn't support adding comments. Neither does the underlying C++ API, actually. Comments are completely discarded by the parser, and the circuit struct has no fields for storing them or related concepts such as whitespace. This is unlikely to change because such things tend to involve performance sacrifices (eg. additional memory allocations to store the comments during parsing or additional branches to deal with a more complex circuit struct during simulation).</p>
<p>(Similar performance-driven limitations are that operation names get canonicalized and adjacent operations get fused. For example, parsing <code>&quot;SQRT_Z 0\nSQRT_Z 1&quot;</code> then printing it gives you <code>&quot;S 0 1&quot;</code>.)</p>
<p>If you need to output a circuit that contains comments, you'll have to track the comments for yourself. For example, you could keep a dictionary mapping instruction indices to strings and then print the circuit instruction-by-instruction while appending comments from the dictionary:</p>
<pre><code>from typing import Dict
import stim

def print_commented_circuit(circuit: stim.Circuit, line_comments: Dict[int, str]):
    for i, instruction in enumerate(circuit):
        line = str(instruction)
        if i in line_comments:
            line += &quot;  # &quot; + line_comments[i]
        print(line)


print_commented_circuit(
    circuit=stim.Circuit(&quot;&quot;&quot;
        H 0
        CX 0 1
        M 0 1
    &quot;&quot;&quot;),
    line_comments = {
        1: &quot;entangle&quot;,
    },
)
</code></pre>
<p>Which outputs:</p>
<pre><code>H 0
CX 0 1  # entangle
M 0 1
</code></pre>
",11/17/2021 12:18,API Usage,"The user is inquiring about how to add comments to a Stim.Circuit using the API, which falls under the category of API Usage in quantum programming.",API Usage,,,,API Usage,
21987.0,Qiskit - Simpler way to create a Hamiltonian,"<p>I am looking for an efficient way to create a Hamiltonian in Qiskit.</p>
<p>Following are my desired input and outputs</p>
<blockquote>
<p>input: 'ZZI'</p>
</blockquote>
<blockquote>
<p>output: Z^Z^I, where Z and I are operators.</p>
</blockquote>
<p>Here is how I am doing it right now:</p>
<pre><code>from qiskit.circuit.library import TwoLocal
from qiskit.opflow import X, Y, Z, I   
from qiskit.utils import QuantumInstance
from qiskit import *
from qiskit.algorithms.optimizers import COBYLA
from qiskit.algorithms import VQE

weights = [i for i in range(1,4)]

hamiltonian = weights[0]*(Z^Z^I) + weights[1]*(Z^I^Z) + weights[2]*(I^Z^Z)


num_qubits = hamiltonian.num_qubits
ansatz = TwoLocal(num_qubits, ['ry','rz'], 'cx', 'linear', reps=1, insert_barriers=True)

qi = QuantumInstance(Aer.get_backend('statevector_simulator'))
    
optimizer = COBYLA(maxiter=100)
vqe = VQE(ansatz, optimizer=optimizer, quantum_instance=qi)
result = vqe.compute_minimum_eigenvalue(hamiltonian)
</code></pre>
<p>If I have to run the same experiment on a 4 qubit, I need to redo the <code>hamiltonian</code> again. For example it would be:</p>
<pre><code>hamiltonian = weights[0]*(Z^Z^I^I) + weights[1]*(Z^I^Z^I) + weights[2]*(Z^I^I^Z) + weights[3]*(I^Z^Z^I) + weights[4]*(I^Z^I^Z) + + weights[4]*(I^I^Z^Z)
</code></pre>
<p>This option is not scalable when I have a 15 qubit circuit. I would really appreciate it if anyone can guide me in a way that I can build a scalable <code>hamiltonian</code>.</p>
<p>I tried the following method and no luck:</p>
<pre><code>from qiskit.quantum_info.operators import Operator, Pauli
hamiltonian = Operator(Pauli(label='ZZI')) + Operator(Pauli(label='ZIZ')) + Operator(Pauli(label='IZZ'))
</code></pre>
<p>Any guidance would be really appreciated!</p>
",<qiskit><programming><vqe>,11/19/2021 2:46,21988.0,21988.0,"<p>You use <a href=""https://qiskit.org/documentation/stubs/qiskit.opflow.primitive_ops.PauliSumOp.html"" rel=""nofollow noreferrer"">PauliSumOp</a> to do (for example) the following:</p>
<pre><code>from qiskit.opflow.primitive_ops import PauliSumOp
paulis  =  ['IZ', 'XZ', 'YZ', 'ZZ', 'XX']
weights  =  [1,2,3,4,5]
pauli_op = [([pauli,weight]) for pauli,weight in zip(paulis,weights)]
hamiltonian = PauliSumOp.from_list([ op for op in pauli_op ])
</code></pre>
<p>You can then pass this <code>hamiltonian</code> object into the VQE instance like you did.</p>
",11/19/2021 6:45,Tooling,"The question is asking about how to create a scalable Hamiltonian in Qiskit. This is a question about using the Qiskit library, which is a tool for programming quantum computers.",Tooling,,,,Tooling,
22065.0,Openfermion state transformation from Bravyi-Kitaev basis to occupation number,"<p>I'm working in the Bravyi-Kitaev basis implemented by the <code>openfermion.bravyi_kitaev()</code> function  to find the ground state of a fermionic operator in the BK representation. Now I want to convert this ground state from the BK basis to the occupation number basis. I couldn't find any functions implementing this, and the transformation matrix shown in arXiv:1208.5986 is not the correct one. Has anyone managed to find a transform between these two bases?</p>
",<programming><cirq><openfermion>,11/25/2021 17:10,22134.0,22134.0,"<p>I managed to solve the problem:</p>
<p>The matrix <span class=""math-container"">$\beta$</span> that transforms a binary string from the occupation number basis to the Bravyi-Kitaev basis, introduced in arXiv:1208.5986 in eq. (23), is the correct matrix. For qubit states in cirq the ordering of the qubits has to be reversed, while qubit states in Qiskit can be transformed directly.</p>
",11/30/2021 10:03,API Usage ,The user is asking about how to use the OpenFermion API to convert a ground state from the Bravyi-Kitaev basis to the occupation number basis. This falls under API usage as they are seeking advice on how to correctly and effectively use this specific API,API Usage ,,,,API Usage ,
22090.0,Setting the $\texttt{state_preparation}$ for $\texttt{AmplificationProblem()}$ in the scope of Grover's algorithm,"<p>I am having trouble setting the <code>state_preparation</code> parameter of <code>AmplificationProblem()</code> from <code>qiskit.algorithms</code>.
Iâd like to apply a <strong>generalized version of Grover</strong> on only one of the multiple registers in my circuit.</p>
<p>The total number of registers in the circuit is 3.
After several computation steps (including quantum counting algo) the target register gets in a superposition of <strong>non-uniform</strong> basis states - also, it is entangled with the other two registers.</p>
<p>According to the  <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.AmplificationProblem.html"" rel=""nofollow noreferrer"">documentation</a>, <code>state_preparation</code> parameter takes just a <code>QuantumCircuit</code> (sometimes also referred to as Operator).
Since my circuit includes the <code>Initialize()</code> method from <code>qiskit.extensions.initialize</code> (for the other two registers), i.e. a non-unitary operation, there exists no inverse.</p>
<p>My questions are two-fold:</p>
<ul>
<li>What should I pass as the <code>state_preparation</code> parameter? I just need
one specific <code>QuantumRegister</code> to be passed, but I do not have a circuit or operator for only that register (have only the full QuantumCircuit of the entire algorithm).</li>
<li>Per the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.GroverOperator.html"" rel=""nofollow noreferrer"">documentation/tutorials</a>, the state_preparation operator <span class=""math-container"">$\mathcal{A}$</span> should be invertible  - but the <code>Initialize()</code> method introduces a qubit reset, which is non-unitary. How can I circumvent this?</li>
</ul>
<p>So as a summary I'm wondering what would be the best approach to avoid passing the entire circuit to the <code>state_preparation</code>?</p>
",<qiskit><programming><grovers-algorithm><amplitude-amplification>,11/26/2021 11:57,22095.0,22095.0,"<p>You have to pass a circuit, but you can just remove the resets from your circuit with the <code>initialize</code> instruction as</p>
<pre><code>&gt;&gt;&gt; from qiskit.circuit import QuantumCircuit
&gt;&gt;&gt; from qiskit.transpiler.passes import RemoveResetInZeroState
&gt;&gt;&gt; init = QuantumCircuit(3)
&gt;&gt;&gt; init.initialize([1, 0, 0, 0, 0, 0, 0, 0], init.qubits)
&gt;&gt;&gt; init.draw()
     ââââââââââââââââââââââââââââââââ
q_0: â¤0                             â
     â                              â
q_1: â¤1 Initialize(1,0,0,0,0,0,0,0) â
     â                              â
q_2: â¤2                             â
     ââââââââââââââââââââââââââââââââ
&gt;&gt;&gt; stateprep = RemoveResetInZeroState()(init.decompose())
&gt;&gt;&gt; stateprep.draw()
     ââââââââââââââââââââ
q_0: â¤0                 â
     â                  â
q_1: â¤1 disentangler_dg â
     â                  â
q_2: â¤2                 â
     ââââââââââââââââââââ
</code></pre>
<p>Now you can pass <code>stateprep</code> as the <code>state_preparation</code> argument in the <code>AmplitudeProblem</code>.</p>
",11/26/2021 19:02,API Usage, The user is asking about how to use the AmplificationProblem() function from qiskit.algorithms and specifically how to set the state_preparation parameter. This falls under API usage , API Usage,,,,API Usage,
22133.0,Can I initialize only one qubit in a 4-qubit circuit?,"<p>I wonder if there's a way we can initialize the quantum state only for part of the qubits in a quantum circuit. Say if I have a quantum circuit defined as <code>qc = QuantumCircuit(4)</code>, can we only initialize the first qubit (qubit 0) to a particular quantum state, and leave other qubits unchanged (i.e. <span class=""math-container"">$|0\rangle$</span>)?</p>
<p>I tried to follow a <a href=""https://qiskit.org/documentation/stubs/qiskit.extensions.Initialize.html"" rel=""noreferrer"">documentation on qiskit</a>, but am still confused about how to do that. I tried to initialize all the qubits by generating a statevector from the tensor product of each qubit: <code>qc.initialize(np.kron(...))</code>, but it returns me <code>LinAlgError: Last 2 dimensions of the array must be square</code>. Is there an easier way I can do that by specifying which qubit I want to initialize? Thanks for the help!!</p>
",<qiskit><programming><ibm-q-experience>,11/30/2021 8:30,22136.0,22136.0,"<p>Adding to Frank's answer, you can also create an Instruction for the state vector initialization, using the <code>Initialize</code> class, which you can construct passing different arguments (vector, statevectors, etc.). You could then <code>append</code> this instruction to your circuit:</p>
<pre><code>qc = QuantumCircuit(4)
init_gate = Initialize([0.8, 0.6])
qc.append(init_gate, [0])
</code></pre>
<pre><code>     âââââââââââââââââââââââ
q_0: â¤ Initialize(0.8,0.6) â
     âââââââââââââââââââââââ
q_1: âââââââââââââââââââââââ
q_2: âââââââââââââââââââââââ
q_3: âââââââââââââââââââââââ
</code></pre>
",11/30/2021 11:01,Tooling,"The question is asking about how to initialize the quantum state only for part of the qubits in a quantum circuit using Qiskit. This is a question about using the Qiskit library, which is a tool for programming quantum computers.",Tooling,,,,Tooling,
22149.0,Replace Gate with Known Identity in Quantum Circuit,"<p>I have a quantum circuit with 3 two-qubits gates <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.RXXGate.html#qiskit.circuit.library.RXXGate"" rel=""nofollow noreferrer"">XX</a>, <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.RYYGate.html#qiskit.circuit.library.RYYGate"" rel=""nofollow noreferrer"">YY</a>, and <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.RZZGate.html#qiskit.circuit.library.RZZGate"" rel=""nofollow noreferrer"">ZZ</a> (as defined in the qiskit circuit library) with arbitrary angles on each gate. I'd like to replace the YY and ZZ gates with XXs. I know how to do this mathematically with RZ and RY single qubit rotations, but I don't know how to programmically get Qiskit to do this switch. Unfortunately, the transpiler converts the YY and ZZ into CNOTs and then into XXs (evaluated at <span class=""math-container"">$\pi/2$</span>). I want to avoid this though and preserve the arbitrary angles on YY and ZZ when converting them into XX gates. Is there a way I can tell the transpiler how to handle YY and ZZ gates?</p>
<p>Or maybe remove the YY and ZZ gates from the quantum circuit from QuantumCircuit.data and insert XX gates (with the appropriate RZ and RY rotations)?</p>
",<qiskit><programming><transpile>,12/01/2021 15:03,22150.0,22150.0,"<p>The proper way to implement this would be writing your own transpiler pass, a <code>TransformationPass</code> to be more precise, which replaces the RYY and RZZ gates with your decomposition. If you want to decompose it into RXX gates the following should do the trick:</p>
<pre><code>from qiskit.circuit import QuantumCircuit
from qiskit.converters import circuit_to_dag
from qiskit.transpiler import TransformationPass

class RXXTranslator(TransformationPass):
    &quot;&quot;&quot;A transpiler pass to replace RYY and RZZ gates with RXX gates.&quot;&quot;&quot;

    def run(self, dag):
        &quot;&quot;&quot;Run the pass.&quot;&quot;&quot;

        # iterate over all operations
        for node in dag.op_nodes():

            # if we hit a RYY or RZZ gate replace it
            if node.op.name in [&quot;ryy&quot;, &quot;rzz&quot;]:
                # get the rotation angle
                angle = node.op.params[0]

                # calculate the replacement
                replacement = QuantumCircuit(2)
                if node.op.name == &quot;ryy&quot;:
                    replacement.sdg([0, 1])
                else:
                    replacement.h([0, 1])

                replacement.rxx(angle, 0, 1)

                if node.op.name == &quot;ryy&quot;:
                    replacement.s([0, 1])
                else:
                    replacement.h([0, 1])

                # replace the node with our new decomposition
                dag.substitute_node_with_dag(node, circuit_to_dag(replacement))

        return dag


circuit = QuantumCircuit(2)
circuit.rxx(0.1, 0, 1)
circuit.ryy(0.2, 0, 1)
circuit.rzz(0.3, 0, 1)

as_rxx = RXXTranslator()(circuit)
print(as_rxx.draw())
</code></pre>
<p>which outputs</p>
<pre><code>     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
q_0: â¤0          ââ¤ Sdg ââ¤0          ââ¤ S ââ¤ H ââ¤0          ââ¤ H â
     â  Rxx(0.1) ââââââââ¤â  Rxx(0.2) ââââââ¤âââââ¤â  Rxx(0.3) ââââââ¤
q_1: â¤1          ââ¤ Sdg ââ¤1          ââ¤ S ââ¤ H ââ¤1          ââ¤ H â
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
</code></pre>
",12/01/2021 15:45,Tooling,"The question is asking about how to programmatically replace YY and ZZ gates with XX gates in Qiskit, while preserving the arbitrary angles on the original gates. This is a question about using the Qiskit library",Tooling,,,,Tooling,
22173.0,Phase Oracle in Qiskit Solving Satisfiability Problems using Grover's Algorithm Section,"<p>In Qiskit Textbook, there is a section on <a href=""https://qiskit.org/textbook/ch-applications/satisfiability-grover.html"" rel=""nofollow noreferrer"">solving satisfiability problems using Grover's Algorithm</a>. For the 3SAT instance <a href=""https://i.stack.imgur.com/W4w1U.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/W4w1U.png"" alt=""enter image description here"" /></a>
they construct the following phase oracle:</p>
<p><a href=""https://i.stack.imgur.com/htq96.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/htq96.png"" alt=""enter image description here"" /></a></p>
<p>Is there any reasoning behind this construction? Are they using the solutions to the actual problem while constructing it?</p>
",<qiskit><programming><grovers-algorithm><oracles>,12/03/2021 09:17,22205.0,22205.0,"<p>For small boolean functions, up to 16 variables, <code>tweedledum</code> (the library used by Qiskit, <a href=""https://i.stack.imgur.com/ZViq9.png"" rel=""nofollow noreferrer"">repo</a>|<a href=""https://si2.epfl.ch/%7Edemichel/publications/archive/2019/08418797.pdf"" rel=""nofollow noreferrer"">docs</a>) synthesizes the circuit using the truth table: it uses to truth table to extract a special case of an ESOP (Exclusive-or Sum-Of-Products) representation, known as Pseudo-Kronecker expression. Indeed, if you are using this method to implement an oracle that will be use in Grover's algorithm to solve satisfiability, then you have the solution before using Grover's.</p>
<p>When dealing with bigger functions, however, this method will not work. Truth tables are expensive to represent, hence we need to represent bigger boolean functions through other means.  In <code>tweedledum</code>, that method is Xor-And graph (XAG).</p>
<p>Once we build a XAG representation of a given function, <code>tweedledum</code> has a few options to how synthesize a reversible (quantum) circuit for it. This figures show a bird's eye view of two ways it can be done:</p>
<p><a href=""https://i.stack.imgur.com/ZViq9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZViq9.png"" alt=""enter image description here"" /></a></p>
<p>In one flow (upper path) the XAG is processed with a  technique that synthesizes a reversible circuit for it, directly from the XAG. On the other flow, the big function is broken into smaller ones. A k-LUT graph is basically a graph of truth tables. <span class=""math-container"">$k$</span> is the number of inputs. Then the truth table based technique can be applied to each of these smaller functions, and combine them together to create the desired circuit.</p>
<p>You can read more about it in:</p>
<ul>
<li>Soeken, et al. <a href=""https://si2.epfl.ch/%7Edemichel/publications/archive/2019/08418797.pdf"" rel=""nofollow noreferrer"">&quot;LUT-based hierarchical reversible logic synthesis.&quot;</a> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems 38.9 (2018): 1675-1688.</li>
<li>Schmitt, et al. <a href=""https://ieeexplore.ieee.org/document/9474163"" rel=""nofollow noreferrer"">&quot;Compilation flow for classically defined quantum operations.&quot;</a> 2021 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). IEEE, 2021.</li>
<li>Meuli, et al. <a href=""https://arxiv.org/pdf/1908.01609.pdf"" rel=""nofollow noreferrer"">&quot;The role of multiplicative complexity in compiling low <span class=""math-container"">$T$</span>-count oracle circuits.&quot;</a> 2019 IEEE/ACM International Conference on Computer-Aided Design (ICCAD). IEEE, 2019.</li>
</ul>
<p>Or look at <code>tweedledum</code> <a href=""https://github.com/boschmitt/tweedledum"" rel=""nofollow noreferrer"">source code</a>. You will find these techniques and others in the <code>synthesis</code> folder.</p>
",12/06/2021 15:22,Conceptual,The user is inquiring about the reasoning and construction of a phase oracle for solving satisfiability problems using Grover's Algorithm in Qiskit. This question pertains to the conceptual understanding of how the phase oracle is constructed and its relationship to solving the given problem.,Theoretical,The user is asking about the reasoning and construction of a phase oracle for solving a satisfiability problem using Grover's Algorithm. This relates to the theoretical aspects of quantum computing and quantum algorithms.,No,118.0, Conceptual,The user is seeking an understanding of the construction and reasoning behind a phase oracle for solving satisfiability problems using Grover's Algorithm in Qiskit. This aligns with the conceptual aspect of understanding how the phase oracle is constructed and its relationship to solving the given problem.
22234.0,Variational quantum eigensolver in qiskit,"<p>I have implemented a hybrid quantum NN on a dataset to perform classification. Now I want to apply quantum PCA to my dataset to find the eigenvalues. After going through a few qiskit tutorials, I found that VQE is used for finding eigenvalues in qiskit. Is there a demo program implementing VQE on a dataset where we can check the steps?</p>
",<qiskit><programming><vqe>,12/09/2021 05:24,23339.0,23339.0,"<p>The Qiskit textbook <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">chapter on VQE</a> is specific to molecule ground state, though it has a good introduction on what VQE is and how it works.</p>
<p>The <a href=""https://qiskit.org/documentation/tutorials/optimization/3_minimum_eigen_optimizer.html"" rel=""nofollow noreferrer"">Qiskit Tutorial on Minimum Eigen Optimizer</a>, also available in <a href=""https://lab.quantum-computing.ibm.com/"" rel=""nofollow noreferrer"">Quantum Lab</a> where you can interactively play with it, should be good to get you going.</p>
",12/19/2021 22:39,Learning ,The user is asking for a demo program or tutorial that implements the Variational Quantum Eigensolver (VQE) on a dataset. This falls under the Learning category, Learning,,,,Learning ,
22235.0,Very simple matrix operation (Markov chain) in terms of Qiskit,"<p>I am trying to approach Markov chains as a use case for Quantum Computing. For this I took the simple introductory case from <a href=""https://de.wikipedia.org/wiki/Markow-Kette"" rel=""nofollow noreferrer"">Wikipedia (Markow-Kette)</a>:</p>
<ul>
<li><span class=""math-container"">$v_0=\begin{pmatrix}
1 &amp; 0 &amp; 0
\end{pmatrix}$</span></li>
<li>M=<span class=""math-container"">$\begin{pmatrix}
0 &amp; 0.2 &amp; 0.8\\
0.5 &amp; 0 &amp; 0.5\\
0.1 &amp; 0.9 &amp; 0\\
\end{pmatrix}$</span></li>
<li><span class=""math-container"">$v_1=v_0M$</span></li>
<li><span class=""math-container"">$v_3=v_0M^3$</span></li>
</ul>
<p>As a starter/&quot;appetizer&quot; I implemented this situation with the following 3-liner using <code>Numpy</code> and got very straight forwardly the correct result <code>v3=[0.37  0.126 0.504]</code> which is in line with the result from the Wikipedia Site:</p>
<pre><code>M = np.array([[0, 0.2, 0.8], [0.5, 0, 0.5], [0.1, 0.9, 0]])
v0=np.array([1,0,0])
v1=v0.dot(M)
print(v1)
v3=v0.dot(matrix_power(M, 3))
print(v3)
</code></pre>
<p>Now I'm stuck porting the whole thing to Qiskit, where I am really would be satisfied with a simulator-based solution:</p>
<pre><code>qiskit.IBMQ.save_account('your_token', overwrite=True)
qiskit.IBMQ.load_account()
n_wires = 1
n_qubits = 1
provider = qiskit.IBMQ.get_provider('ibm-q')
backend = Aer.get_backend('qasm_simulator')
[...]
</code></pre>
<p>Asking Google led me to <a href=""https://qiskit.org/documentation/tutorials/simulators/7_matrix_product_state_method.html"" rel=""nofollow noreferrer"">Matrix product state simulation method</a>, but it seems to be not obvious how to apply this to my simple problem. A simple nudge in the right direction would be really appreciated.</p>
",<qiskit><programming>,12/09/2021 13:54,22287.0,22287.0,"<p>I made an implementation, I'm not sure whether it has advantages or how it generalizes. I hope it might steer you (or us) in the right direction.</p>
<p>The approach is as follows:</p>
<p>You have a matrix <span class=""math-container"">$M$</span>, then:</p>
<ol>
<li>Create a circuit with <span class=""math-container"">$2N=6$</span> qubits
<ul>
<li>The first 3 qubits represent 'being in state <span class=""math-container"">$i$</span>' (<span class=""math-container"">$i$</span> is a state in <span class=""math-container"">$N$</span>) (i.e. <span class=""math-container"">$|001&gt;$</span> is state <span class=""math-container"">$0$</span>, <span class=""math-container"">$|010&gt;$</span> is state <span class=""math-container"">$1$</span>,
<span class=""math-container"">$|100&gt;$</span> state <span class=""math-container"">$2$</span>)</li>
<li>The last 3 qubits represent 'going to state <span class=""math-container"">$j$</span>' (<span class=""math-container"">$j$</span> is a state in <span class=""math-container"">$N$</span>)</li>
</ul>
</li>
<li>Controlled go from state <span class=""math-container"">$i$</span> to state <span class=""math-container"">$j$</span> with probability <span class=""math-container"">$M_{i,j}$</span> *</li>
<li>Make sure to <em>not</em> go to state <span class=""math-container"">$j'$</span> when you're going to state <span class=""math-container"">$j$</span></li>
<li>Make sure the naming of states checks out (i.e. <span class=""math-container"">$|001&gt;$</span> state <span class=""math-container"">$0$</span>, <span class=""math-container"">$|010&gt;$</span> is state <span class=""math-container"">$1$</span>, <span class=""math-container"">$|100&gt;$</span> is state <span class=""math-container"">$2$</span>)</li>
<li>Repeat steps 2-4 for all <span class=""math-container"">$i$</span></li>
<li>Swap the last 3 qubits with the first 3 qubits, (in words, these were the states that you're 'going to' and now they are the state 'you are in').</li>
<li>Reset the last 3 qubits.</li>
</ol>
<p><a href=""https://quantum-computing.ibm.com/composer/files/new?initial=N4IgdghgtgpiBcICyEBOBrA9gNwAQGUAXGAB1wFpcBhaASwBt6ZcATZgNQnvRABoQAjhADOUBCADyABQCiAOQCKAQXxJcAJgB0ABgDcAHTC0wAY3oBXNrn2CY9WgCMAjJuMmbBsAHMIxXFDQsbAB9YWIyCF5cByiTKJYogDMor1xgQ1xcE3MACm1NAE51AHZ1AoBWKO0okloAenUa%2BvUASlxI3ETPTJMTAA9OqI6vbqyBjq6MrNzahqa53FnGxea2mNwRqd6Bryj1llH%2B6JTD3PyANgAWAGZy7Sd55aXHtrjWQ6OErKTDgbeDqbCADuEDIb02YEywNBx06o2hEXingAvoZDAJUDBUgIANrnAC6nhMmNSJjxhLRpjOhRKZUq1WeSzauO0%2BN4uMuFNMRw5bJZfJx5S5PJxrPZOM5RJmzV4jJlTNwuKcAqFRJFQvFyvF12FAyVKuF1Kut3usvl5oazJx6gFOrVepxOvFNvFksMIpduLthgRiutBs8vv1rq5mOEMEIftVPpBZH52tDMHDkd5njDEb9dr4IDYwmJtBIhFomDA4hAyKAA"" rel=""nofollow noreferrer"">The circuit now looks like this:</a></p>
<p><img src=""https://i.stack.imgur.com/n3OZ4.png"" alt=""markov step"" /></p>
<p>With this circuit, you can do the same steps as you proposed before, so in your case you have:</p>
<pre><code>import numpy as np
M = np.array([[0, 0.2, 0.8], [0.5, 0, 0.5], [0.1, 0.9, 0]])
v0=np.array([1,0,0])
v1=v0.dot(M)
print(v1)
v2=v0.dot(np.linalg.matrix_power(M, 2))
print(v2)
v3=v0.dot(np.linalg.matrix_power(M, 3))
print(v3)
</code></pre>
<p>output:</p>
<pre><code>[0.  0.2 0.8]
[0.18 0.72 0.1 ]
[0.37  0.126 0.504]
</code></pre>
<p>In Qiskit, this now is the following **:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile
from numpy import pi

# Inilialise registers
qreg_q = QuantumRegister(6, 'q')
creg_c = ClassicalRegister(3, 'c')

# Create Markov Step as a circuit
markov_step = QuantumCircuit(qreg_q)

# Create the Markov Step
# From state 0 to state 1 and 2
markov_step.cu3(2*np.arccos(np.sqrt(M[0,1])), pi/2, pi/2, qreg_q[0], qreg_q[4])
markov_step.ccx(qreg_q[4], qreg_q[0], qreg_q[5])
markov_step.cx(qreg_q[0], qreg_q[4])

# From state 1 to state 0 and 2
markov_step.cu3(2*np.arccos(np.sqrt(M[1,2])), pi/2, pi/2, qreg_q[1], qreg_q[5])
markov_step.ccx(qreg_q[5], qreg_q[1], qreg_q[3])
markov_step.cx(qreg_q[1], qreg_q[5])

# From state 2 to state 0 and 1
markov_step.cu3(2*np.arccos(np.sqrt(M[2,0])), pi/2, pi/2, qreg_q[2], qreg_q[3])
markov_step.ccx(qreg_q[3], qreg_q[2], qreg_q[4])
markov_step.cx(qreg_q[2], qreg_q[3])

# Swap
markov_step.swap(qreg_q[0], qreg_q[3])
markov_step.swap(qreg_q[1], qreg_q[4])
markov_step.swap(qreg_q[2], qreg_q[5])

# Initialise circuit
circuit = QuantumCircuit(qreg_q,creg_c)

# Initialise state (1,0,0)
circuit.x(0)

# Do the markov step n times
n = 3
for _ in range(n):
    for ins in markov_step:
        circuit.append(ins[0], ins[1], ins[2])
    circuit.reset(qreg_q[3:])

# Measure outcome
circuit.measure(qreg_q[:3], creg_c)
</code></pre>
<p>And you can run it by</p>
<pre><code>from qiskit.visualization import plot_histogram
backend = provider.get_backend('ibmq_qasm_simulator')
job = backend.run(circuit)
result = job.result()
counts = result.get_counts(circuit)

plot_histogram(counts)
</code></pre>
<p>And the output:</p>
<p><img src=""https://i.stack.imgur.com/XzN5W.png"" alt=""output counts"" /></p>
<p>Which is approximately equal to the exact answers <code>[0.37  0.126 0.504]</code>.</p>
<p>This approach definitely isn't perfect and I'm quite sure optimizations can be made (e.g. not using 1 qubit per state, but using the full <span class=""math-container"">$2^N$</span> possible states) and I'm not sure how to go to larger state spaces. But it's the first step!</p>
<p>Some notes:</p>
<p>* note: Step 2 is not trivial. I implemented it as a controlled <span class=""math-container"">$X$</span>-rotation. An <span class=""math-container"">$X$</span>-rotation is (according to the <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Rotation-around-X-axis"" rel=""nofollow noreferrer"">qiskit-textbook</a>) given by</p>
<p><span class=""math-container"">\begin{equation}
R_x(\theta) = 
\begin{pmatrix}
\cos(\theta /2) &amp; -i \sin(\theta /2) \\
-i \sin(\theta /2) &amp; \cos(\theta /2)
\end{pmatrix},
\end{equation}</span></p>
<p>and it brings the <span class=""math-container"">$|0&gt;$</span> state to <span class=""math-container"">$\cos(\theta /2) |0&gt; - i \sin(\theta /2) |1&gt;$</span>. Now, for example, we want the target qubit to be in state <span class=""math-container"">$|0&gt;$</span> with probability 0.2 (when starting the target is in state 0). The probability of finding the target in state <span class=""math-container"">$|0&gt;$</span> is <span class=""math-container"">$|\cos(\theta /2)|^2$</span> and this must be equal to <span class=""math-container"">$0.2$</span>.
Thereby, it can be found that <span class=""math-container"">$\theta = 2 \arccos{\sqrt{0.2}}$</span>.</p>
<p>** note: Implementing the circuit is a bit annoying because not all gates are available in all backends. Sometimes, you have to 'translate' the gates. A controlled <span class=""math-container"">$X$</span>-rotation (CRX) is also a controlled U3 gate, where <span class=""math-container"">$CR_x(\theta) = CU3(\theta, \pi/2,\pi/2)$</span>. Some backend also doesn't allow for the CU3 gate, but they do allow the multi-controlled gate <code>.mcu3</code>. In that case, just put your control qubit in a list by putting square brackets around it.</p>
",12/15/2021 11:06,Tooling," The question is asking about how to implement a simple Markov chain simulation in Qiskit using the Matrix Product State (MPS) method. This is a question about using the Qiskit library, which is a tool for programming quantum computers.",Tooling,,,,Tooling,
22281.0,Simulating flag qubits and conditional branches using Stim,"<p>In a quantum error correcting code using flag qubits, it's common to have flag measurements that tell you it's necessary to do some extra measurements for safety. So, for example, I want to say:</p>
<pre><code>if measurement_result_was_true:
    do_a_different_measurement
</code></pre>
<p>How do I do this in Stim? There doesn't seem to be an <code>if</code>.</p>
<p><em>(This was a question I received by email. Moving it here for posterity.)</em></p>
",<programming><error-correction><stim>,12/14/2021 21:51,22282.0,22282.0,"<p>This is definitely a place where you'll struggle to use Stim. It's <em>possible</em> but it's not <em>nice</em>. It could still be worth your time just because you don't have to eg. manually write code to turn a circuit into a matching graph, but it'll be more tedious than branchless code.</p>
<p><em>Part 1: Simulating</em></p>
<p>The easiest thing to do is to use <code>stim.TableauSimulator</code>. It gives you the ability to apply operations one by one driven by python code, which is more than flexible enough to do what you need.</p>
<p>Here is python code showing the general idea:</p>
<pre><code>import stim

simulator = stim.TableauSimulator()

# Run first part of circuit.
simulator.do(stim.Circuit(&quot;&quot;&quot;
    H 0
    CNOT 0 1
    M 0
&quot;&quot;&quot;))

# Do something depending on the measurement result.
latest_measurement_result = simulator.current_measurement_record()[-1]
if latest_measurement_result:
    simulator.do(stim.Circuit(&quot;&quot;&quot;
        # ...
    &quot;&quot;&quot;))

# Run the rest of the circuit.
simulator.do(stim.Circuit(&quot;&quot;&quot;
    # ...
&quot;&quot;&quot;))

shot = simulator.current_measurement_record()
</code></pre>
<p>The reason Stim doesn't support branching in its circuit format is because branches break an algorithmic optimization where the tableau simulator is only used once for a reference sample, and then stim switches to using much faster error frame simulation. Consequently, you will find that getting thousands of samples by repeatedly using <code>stim.TableauSimulator</code> is easily 100x slower than using <code>circuit.compile_sampler().sample(shots)</code>. Hopefully it's still fast enough for your needs.</p>
<p>If you have less than 10 branches, a possible alternative would be to run simulations for each possible case and then postselect out the inconsistent ones where the hardcoded branch disagreed with the measurement result deciding whether or not it was taken. The performance difference can be large enough to overcome the losses from the postselections.</p>
<p><em>Part 2: Correcting</em></p>
<p>I'm assuming you're using PyMatching.</p>
<p>For each shot, you need to build the circuit that was actually run. This circuit will give you access to a detector error model (<code>circuit.detector_error_model(decompose_errors=True)</code>) and the ability to convert the measurement results into detection events (<code>circuit.compile_m2d_converter().convert(shot, append_observables=True)</code>). Convert the measurements into detection events + observable frame changes, and then run pymatching on the detector data, configured with the circuit's detector error model, and check whether or not it predicted the observable frame data.</p>
<p>If you only have a few possible cases, you will get a large benefit from grouping shots that took the same paths together. If you have a lot of possible cases, so that each case is hit less than 3 times on average, grouping isn't worth it.</p>
<p>It's likely that error model extraction will be your main bottleneck here. Stim is pretty quick at this, it takes it a third of a second or so to analyze the error model of a distance 25 surface code, but a third of a second <em>per sample</em> is <em>awful</em>.</p>
<p>I intend for this use case to get better in the future, but haven't got any concrete designs I'm happy with yet.</p>
",12/14/2021 21:51,API Usage,The user is asking about how to use the Stim API to perform conditional measurements in a quantum error correcting code. This falls under API usage,API Usage,,,,API Usage,
23316.0,Projection Operator in qiskit.opflow,"<p>I am looking for a way to implement a projection operator like <span class=""math-container"">$\mid +\rangle\langle+\mid$</span> in qiskits opflow module. I tried <code>Plus @ ~Plus</code> but this gives me an error message. There must be a direct implementation of projection operators right? I can't use the operators in <code>qiskit.quantum_info</code> for what I want to do, except if there is a way to convert those operators to the ones in opflow.</p>
<p>Edit:
The error message I get from <code>(Plus)@(~Plus)</code> is <code>ValueError: Composition with a Statefunctions in the first operand is not defined.</code></p>
<p>The reason I think I can't use <code>qiskit.quantum_info</code>'s opearotors it that I want to compute the spectrum using <code>qiskit.algorithms.NumPyEigensolver</code> and this seems to me to not work with a <code>quantum_info</code> operator:</p>
<pre><code>&gt;&gt;&gt;plus = Statevector([1/np.sqrt(2),1/np.sqrt(2)]).to_operator()
&gt;&gt;&gt;plus
Operator([[0.5+0.j, 0.5+0.j],
          [0.5+0.j, 0.5+0.j]],
         input_dims=(2,), output_dims=(2,))

&gt;&gt;&gt;solver = NumPyEigensolver()
&gt;&gt;&gt;spectrum = solver.compute_eigenvalues(plus)
AttributeError: 'Operator' object has no attribute 'to_spmatrix'
</code></pre>
<p>I am generally confused about the connection and difference between <code>qiskit.quantum_info</code> and <code>qiskit.opflow</code> because they seem to me to have a large overlap. Is one of those an older module and should not be used anymore? Is there a general way to convert objects like operators from one to the other?</p>
",<qiskit><programming>,12/17/2021 16:18,28930.0,28930.0,"<p>You can convert a <code>qiskit.quantum_info</code> operator to a <code>qiskit.opflow</code> operator easily by passing it as a parameter to <a href=""https://qiskit.org/documentation/stubs/qiskit.opflow.primitive_ops.PrimitiveOp.html"" rel=""nofollow noreferrer""><code>PrimitiveOp</code></a> constructor:</p>
<pre><code>from qiskit.opflow import PrimitiveOp

# |+&gt;
sv = Statevector.from_label('+')

# |+&gt;&lt;+|
proj = sv.to_operator()

# Convert to opflow operator:
op = PrimitiveOp(proj)
</code></pre>
",11/09/2022 11:44, API Usage,The user is asking about how to use the Qiskits opflow module to implement a projection operator. They are also seeking advice on how to convert operators from qiskit.quantum_info to qiskit.opflow. This falls under API usage ,API Usage,,,, API Usage,
23329.0,Has the possibility of there being a classical cryptography algorithm able to withstand quantum computing been proven?,"<p>Has it been proven, that a classical codec (encoder-decoder) (classical meaning one that doesn't require a quantum system for its operation) is possible, such that a quantum computer cannot crack it?</p>
<p>I'm assuming that a quantum computer can only solve problems from the NP class and problems that classical computers can solve, where an &quot;NP class problem&quot; is one for which a solution can not be found in polynomial time but if a correct answer is provided, its correctness can be checked in polynomial time.</p>
",<complexity-theory><classical-computing><cryptography>,12/19/2021 8:04,23343.0,23343.0,"<p><strong>[0001]</strong> Regarding the OP's first paragraph and the comments therein, there is no protocol, call it <span class=""math-container"">$X$</span>, that can be executed efficiently on classical computers, that has been proven to be secure against quantum computers.  If we had such a proof then we would also know that P<span class=""math-container"">$\ne$</span>NP.  This follows because, as @Martin said, a quantum computer can efficiently simulate a classical computer.  If we could prove <span class=""math-container"">$X$</span> to be secure against quantum computers, then it follows that <span class=""math-container"">$X$</span> is secure against classical computers.  But if <span class=""math-container"">$X$</span> is efficient to execute, then it follows that <span class=""math-container"">$X$</span> is in NP, since verifying a solution must be efficient. If <span class=""math-container"">$X$</span> is further secure against classical computers, then <span class=""math-container"">$X$</span> would not be in P, which means that we have split P from NP and shown them not to be equal.</p>
<p><strong>[0002]</strong> Nonetheless, as @gIS provides and as I think is the real intent of the question, there is a whole field called &quot;post-quantum cryptography&quot; - see the Wikipedia link (mentioned by gIS) as well as the links on a <a href=""https://crypto.stackexchange.com/questions/tagged/post-quantum-cryptography"">sister site</a>, for example.  Herein, although there may be no <em>proof</em> that such protocols are secure against a quantum computer, there is other evidence that such protocols may exist.  There is an expectation that we may convert to such protocols if and when RSA is broken by a quantum computer capable of running large enough instances of Shor's algorithm.  Many leading contenders for such post-quantum cryptography are based on lattices - the <a href=""https://en.wikipedia.org/wiki/Learning_with_errors"" rel=""nofollow noreferrer"">learning with errors</a> class of problems being an example therein.</p>
<p><strong>[0003]</strong> Regarding the OP's second paragraph, however, the relationship between what is efficient to execute on a quantum computer (researchers call the class of such problems BQP), and what is efficient to verify on a classical computer (as the OP correctly identified, researchers call the class of these problems NP), is really very rich and dynamic.  Indeed, there are lots of reasons to believe that the class BQP and the class NP are incomparable - that is, there are problems (such as those in knot theory) that are easy to solve on a quantum computer, and are not even efficiently verifiable on a classical computer.  There are interesting approaches to classical verification of quantum computation for such problems.  See, e.g., <a href=""https://www.quantamagazine.org/graduate-student-solves-quantum-verification-problem-20181008/"" rel=""nofollow noreferrer"">this Quanta article</a> on a breakthrough of Mahadev, who showed how a classically constrained verifier can force a quantum prover to tell the truth.</p>
<p><strong>[0004]</strong> <em>However</em>, post-quantum cryptography for classically secure communication, as discussed above, is not based on or invalidated by the existence of problems in BQP but not in NP - which are precisely the kinds of problems Mahadev's protocol addresses.  This is not to say that Mahadev's protocol doesn't rely on post-quantum cryptography (indeed it does), but rather, nothing is precluding us to adopt a post-quantum secure protocol even in the event that we never have cryptologically viable quantum computers.</p>
",12/20/2021 3:20,Theoretical,"The user is asking about a theoretical concept related to quantum computing, specifically whether a classical codec exists that a quantum computer cannot crack. This falls under the Theoretical category",Theoretical,,,,Theoretical,
23353.0,How to order results after multi-circuit qiskit.execute parallel run?,"<p>I'm kinda new to qiskit and I find really fascinating its parallelization capabilities, then I'm trying to creating all the needed circuits for my application at once and transpile, assemble and execute them all at once using the execute method.</p>
<p>Basically,</p>
<pre><code>qcircuits = []
# construct my circuits and append to qcircuits
# ...
backend: backend: BaseBackend = qiskit.Aer.get_backend('qasm_simulator')

n_shots = 1024
job = qiskit.execute(
            qcircuits,
            backend,
            optimization_level=optimization_level,
            shots=n_shots
        )

counts = job.result().get_counts()
</code></pre>
<p>Nevertheless, I noticed that the <code>job.result().get_couts()</code> output is not deterministic as, I guess, it runs all the circuits using a <code>parallel_map</code> and appends in the returned list in the order they finish. Is there any way to force the <code>execute</code> method respecting the order of <code>qcircuits</code> ? If it is not the case, is there any way to label the execution results so that I can sort them myself afterwards ?
Thanks in advance.</p>
",<qiskit><programming><simulation><quantum-parallelism>,12/21/2021 13:25,23382.0,23382.0,"<p>Each <code>qiskit.QuantumCircuit</code> has a <code>name</code> attribute that is also accessible through each <code>qiskit.result.Result</code>. So, you can do the following to match the circuits to the measurement counts after running in parallel:</p>
<pre><code>for circuit in qcircuits:
    print(circuit.name)

result_dict = jobs.result().to_dict()[&quot;results&quot;]
result_counts = jobs.result().get_counts()
for i in range(len(qcircuits)):
    name = result_dict[i][&quot;header&quot;][&quot;name&quot;]
    counts = result_counts[i]  
    print(f&quot;{name}: {counts}&quot;)
</code></pre>
<p>Before running your circuits, you could also assign your own descriptive names, e.g.</p>
<pre><code>for i in range(len(qcircuits)):
    qcircuits[i].name = &quot;mycircuit&quot;+str(i)
</code></pre>
<p><strong>Edit:</strong></p>
<p>Combining the ideas above to show how to order the results:</p>
<pre><code># number input circuits in ascending order
for i in range(len(qcircuits)):
    qcircuits[i].name = &quot;circuit_&quot;+str(i)

job = qiskit.execute(qcircuits, backend, ...)

result_dict = job.result().to_dict()[&quot;results&quot;]
result_counts = job.result().get_counts()

# initialize list to store ordered results
results_ordered = [None] * len(qcircuits)

for i in range(len(qcircuits)):
    name = result_dict[i][&quot;header&quot;][&quot;name&quot;]
    n = int(name.split('_')[1])  # index of circuit in input list
    results_ordered[n] = result_counts[i]  # add to result list at same index  
</code></pre>
",12/22/2021 20:48,API Usage,The user is asking about how to use the Qiskit API to execute multiple circuits in a specific order and how to label the execution results for sorting.,API Usage,,,,API Usage,
23371.0,Calculating the quantum euclidean distance between vectors,"<p>I am trying to get the distance using the swap test circuit.</p>
<p><a href=""https://i.stack.imgur.com/m2fkq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m2fkq.png"" alt=""enter image description here"" /></a>,</p>
<p>With the help of the codes I shared, I can only estimate the distance between two vectors. Can it calculate the distances of many vectors from each other with the help of a single circuit?</p>
<pre><code>
# import the necessary libraries 
import math as m
from qiskit import *
from qiskit import BasicAer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit_quantum_knn.encoding import analog
from numpy import linalg as LA
from scipy.spatial import distance



# First step is to encode the data into quantum states. 
#There are some techniques to do it, in this case Amplitude embedding was used.


A= [2,9,8,5,4,18,16,10]
B= [7,5,10,3,14,10,20,6]


A_norm=LA.norm(A)
B_norm=LA.norm(B)
Dist=distance.euclidean(A, B)
Z = round( A_norm**2 + B_norm**2 )
 
# create phi and psi state with the data    
phi = [A_norm/m.sqrt(Z),-B_norm/m.sqrt(Z)]
psi = []

for i in range(len(A)):
    psi.append(((A[i]/A_norm) /m.sqrt(2)))
    psi.append(((B[i]/B_norm) /m.sqrt(2)))
    
# Quantum Circuit
q1 = QuantumRegister(1,name='q1')
q2 = QuantumRegister(1,name='q2')
q3 = QuantumRegister(4,name='q3')
c = ClassicalRegister(1,name='c')
qc= QuantumCircuit(q1,q2,q3,c)

# states initialization
qc.initialize( phi, q2[0] )
qc.initialize( psi, q3[0:4])

# The swap test operator 
qc.h( q1[0])
qc.cswap( q1[0], q2[0], q3[0] )
qc.h( q1[0] )
qc.measure(q1,c)

display(qc.draw(output=&quot;mpl&quot;))


## Results
shots = 1000000
job = execute(qc,Aer.get_backend('qasm_simulator'),shots=shots)
job_result = job.result()
counts = job_result.get_counts(qc)
x = abs(((counts['0']/shots - 0.5)/0.5)*2*Z)
Q_Dist = round(m.sqrt(x),4)
print('Quantum Distance: ', round(Q_Dist,3))    
print('Euclidean Distance: ',round(Dist,3))   

</code></pre>
",<qiskit><programming><algorithm><quantum-enhanced-machine-learning>,12/22/2021 13:52,23409.0,23409.0,"<p><strong>Edit: this answer refers to v1 of the preprint in the link OP provided. I didn't look closely at the subsequent versions.</strong></p>
<p>As explained in the <a href=""https://arxiv.org/abs/2003.09187v1"" rel=""nofollow noreferrer"">link</a> you provided, given access to an oracle that prepares each state in the set <span class=""math-container"">$\{ |\phi_i\rangle\}$</span> for <span class=""math-container"">$i=1, \dots, M$</span> and some fixed state <span class=""math-container"">$|\psi\rangle$</span>, you can estimate <span class=""math-container"">$F_i =|\langle \psi |\phi_i \rangle|^2$</span> for <span class=""math-container"">$i=1, \dots, M$</span> using many repetitions of the circuit provided in Figure 4 of that preprint. If you read through Section IIIA it will describe how to modify the standard SWAP test for this purpose. The only major change is that you need to add a fourth register containing <span class=""math-container"">$m=\lceil \log (\text{len}(A))\rceil$</span> qubits (3 in your case) and have a unitary <span class=""math-container"">$W$</span> that acts on your third and fourth registers according to
<span class=""math-container"">$$ \tag{1}
W|0\rangle^{\otimes n}|i\rangle = |\phi_i\rangle |i\rangle
$$</span></p>
<p>If you read carefully through the rest of that section it will describe the outputs of this circuit and therefore how it samples approximations of <span class=""math-container"">$F_i$</span> according to their magnitude, thereby sampling the distances of <span class=""math-container"">$|\psi\rangle$</span> to its K nearest neighbors. However, you are probably better off just using your code for a normal SWAP test with randomly sampled <span class=""math-container"">$|\phi_i\rangle$</span>, as I will demonstrate below.</p>
<hr />
<h3>An equivalent alternative</h3>
<p>I'm going to demonstrate why this is maybe not such a good idea compared to just performing the standard SWAP test. Consider Equations 18 and 22 in the preprint, the first of which describes the probability of measuring the first qubit as &quot;0&quot; and the second describes the probability of measuring the fourth register in &quot;i&quot; conditioned on the first register being &quot;0&quot;:</p>
<p><span class=""math-container"">\begin{align}
p(0) &amp;= \frac{1}{2} + \frac{1}{2M} \sum_{j=1}^M F_j \tag{2, 18 in preprint}\\
p(i|0) &amp;= \frac{1 + F_i}{M + \sum_{j=1}^M F_j} \tag{3, 22 in preprint}
\end{align}</span></p>
<p>Then the joint probability distribution over both registers is just
<span class=""math-container"">\begin{align}
p(i, 0) &amp;= p(i|0) p(0) \tag{4}
\\&amp;= \frac{1 + F_i}{M + \sum_{j=1}^M F_j} \cdot \frac{1}{2M}\left(M + \sum_{j=1}^M F_j \right) \tag{5}
\\&amp;=  \frac{1 + F_i}{2M} \tag{6}
\end{align}</span></p>
<p>Now consider a different protocol with joint distribution <span class=""math-container"">$p'(i, 0)$</span> over the same registers. This protocol is very simple: Randomly uniformly sample <span class=""math-container"">$i \in \{1, \dots, M\}$</span>, and then perform a standard SWAP test between <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi_i\rangle$</span>. Using standard results from the <a href=""https://en.wikipedia.org/wiki/Swap_test"" rel=""nofollow noreferrer"">SWAP test</a> we have
<span class=""math-container"">\begin{align}
p'(i, 0) &amp;= p'(i) p'(0|i) \tag{7}
\\&amp;= \frac{1}{M} \left(\frac{1}{2} + \frac{1}{2} F_i\right) \tag{8}
\\&amp;=  \frac{1 + F_i}{2M} \tag{9}
\\&amp;= p(i, 0) \tag{10}
\end{align}</span></p>
<p>This demonstrates that we can exactly reproduce the output distribution of their proposed protocol using classical random numbers instead of quantum superposition (and significantly fewer operations and qubits). Of course, their approach uses marginals <span class=""math-container"">$p(i|0)$</span> which we can't directly access here, but we can of course compute these just using postprocessing on <span class=""math-container"">$p'(i, 0)$</span>.</p>
<hr />
<h3>Why this algorithm isn't necessary</h3>
<p>Intuitively what's going on here is that when they apply <span class=""math-container"">$H^{\otimes m}$</span> to the fourth register that they introduce, they put the register into a uniform superposition over all computational basis states <span class=""math-container"">$\{|i\rangle \}$</span> for <span class=""math-container"">$i=1, \dots, M$</span>. Then the <span class=""math-container"">$W$</span> operator combined with a SWAP test is able to <em>slightly</em> bias sampling of states <span class=""math-container"">$i$</span> according to their inner product <span class=""math-container"">$F_i$</span> with <span class=""math-container"">$|\psi\rangle$</span>, but the amount of bias is bounded by the fact that <span class=""math-container"">$F_i \leq 1$</span>. So your chances of finding the K nearest neighbors can only improve from an initial <span class=""math-container"">$1/M$</span> to <span class=""math-container"">$2/M$</span>. But this is exactly how much you can improve the chance of success for a standard SWAP test when you initially draw <span class=""math-container"">$i$</span> with probability <span class=""math-container"">$1/M$</span></p>
<p>On a more intuitive level, the problem here is that they do not actually <em>use</em> the superposition of the fourth register in a quantum way. Compare their circuit in Figure 4 to the circuit for the Deutsch-Jozsa algorithm, for example, in which case an additional layer of Hadamards is applied at the end of the register to take advantage of destructive intereference of the amplitudes. In contrast, here they just use registers 3 and 4 to prepare a uniform superposition over <span class=""math-container"">$\{|\phi_i\rangle\}$</span> before feeding it into the SWAP test.</p>
",12/24/2021 18:42,API Usage,The user is asking about how to use the Stim API to calculate the distances of many vectors from each other with the help of a single circuit,Tooling ,"The user is asking about how to calculate the distances of many vectors from each other using a single swap test circuit in 'Qiskit', a software for quantum computing. This falls under tool usage in quantum programming",No,119.0,Tooling,"The user is seeking assistance in using Qiskit to calculate the distances of many vectors from each other using a single swap test circuit, which directly relates to the tool usage in quantum programming. This aligns with practical application and usage of a specific quantum computing software."
23450.0,Writing Toffoli Gate Matrix by one and two qubit gate matrices,"<p>I am trying to write Toffoli gate matrice by using one and two qubit gates matrices.
I follow this circuit</p>
<p><a href=""https://en.wikipedia.org/wiki/Toffoli_gate#/media/File:Qcircuit_ToffolifromCNOT.svg"" rel=""nofollow noreferrer"">link for the circuit</a></p>
<p><a href=""https://i.stack.imgur.com/d9vXZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d9vXZ.png"" alt=""enter image description here"" /></a></p>
<p>I first started to write the matrices of one and two qubit gates:</p>
<pre><code>identity = np.array([[1, 0], [0, 1]])
xgate = np.array([[0, 1], [1, 0]])
ygate = np.array([[0,-1j],[1j,0]])
zgate = np.array([[1,0],[0,-1+0j]])
hgate = 1/math.sqrt(2)*(xgate+zgate)
sgate = np.sqrt(zgate)
tgate = np.sqrt(sgate)
tdag = tgate.conj().T
cnot = 0.5*(np.kron(identity,identity)+np.kron(identity,xgate)+np.kron(zgate,identity)-np.kron(zgate,xgate))
deneme = np.kron(identity, swap)
deneme2 = np.kron(cnot,identity)
deneme3 = np.kron(identity,swap)
#deneme_ = deneme*deneme2*deneme3
deneme_ = np.matmul(deneme,deneme2)
non_adjacent  = np.matmul(deneme_,deneme3)
</code></pre>
<p>Then, I started to write each part of the circuit in the following way:</p>
<pre><code>tof1 = np.kron(np.kron(identity,identity),hgate)
tof2 = np.kron(identity,cnot)
tof3 = np.kron(np.kron(identity,identity),tdag)
tof4 = non_adjacent
tof5 = np.kron(np.kron(identity,identity),tgate)
tof6 = np.kron(identity,cnot)
tof7 = np.kron(np.kron(identity,identity),tdag)
tof8 = non_adjacent
tof9 = np.kron(np.kron(identity,tdag),tgate)
tof10 = np.kron(cnot,hgate)
tof11 = np.kron(np.kron(identity,tdag),identity)
tof12 = np.kron(cnot,identity)
toffoli = tof1*tof2*tof3*tof4*tof5*tof6*tof7*tof8*tof9*tof10*tof11*tof12
</code></pre>
<p>And the final matrix is that:
<a href=""https://i.stack.imgur.com/7UH3R.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7UH3R.png"" alt=""enter image description here"" /></a></p>
<p>My guess is that: I did a mistake when I tried to write cnot gate for the first and third qubits or maybe I am wrong to write identities</p>
<p>Can someone explain to me what I missed?
Sorry for this dumb question
Thanks in advance</p>
",<programming><quantum-gate><matrix-representation>,12/28/2021 6:19,23456.0,23456.0,"<p>Here I am providing working code:</p>
<pre><code>import numpy as np
import math as m

idn = np.array([[1, 0], [0, 1]])

h = (1/m.sqrt(2))*np.array([[1, 1], [1, -1]])

t =    np.array([[1, 0], [0, (1/m.sqrt(2))*(1+1j)]])
tdag = np.array([[1, 0], [0, (1/m.sqrt(2))*(1-1j)]])

cnot_adj = np.array([[1, 0, 0, 0],
                     [0, 1, 0, 0],
                     [0, 0, 0, 1],
                     [0, 0, 1, 0]])

cnot_non_adj = np.array(
                        [[1, 0, 0, 0, 0, 0, 0, 0],
                         [0, 1, 0, 0, 0, 0, 0, 0],
                         [0, 0, 1, 0, 0, 0, 0, 0],
                         [0, 0, 0, 1, 0, 0, 0, 0],
                         [0, 0, 0, 0, 0, 1, 0, 0],
                         [0, 0, 0, 0, 1, 0, 0, 0],
                         [0, 0, 0, 0, 0, 0, 0, 1],
                         [0, 0, 0, 0, 0, 0, 1, 0],
                        ]
                        )

toffoli = np.kron(np.kron(idn, idn), h)
toffoli = np.dot(np.kron(idn, cnot_adj), toffoli)
toffoli = np.dot(np.kron(np.kron(idn, idn), tdag), toffoli)
toffoli = np.dot(cnot_non_adj, toffoli)
toffoli = np.dot(np.kron(np.kron(idn, idn), t), toffoli)
toffoli = np.dot(np.kron(idn, cnot_adj), toffoli)
toffoli = np.dot(np.kron(np.kron(idn, idn), tdag), toffoli)
toffoli = np.dot(cnot_non_adj, toffoli)
toffoli = np.dot(np.kron(np.kron(idn, t), t), toffoli)
toffoli = np.dot(np.kron(cnot_adj, h), toffoli)
toffoli = np.dot(np.kron(np.kron(t, tdag), idn), toffoli)
toffoli = np.dot(np.kron(cnot_adj, idn), toffoli)

np.set_printoptions(precision=3) #&quot;rounding&quot;
np.set_printoptions(suppress=True) #supressing scientific format&quot;
print('Real parts')
print(toffoli.real)
print('\nImaginary parts')
print(toffoli.imag)
</code></pre>
<p>Variable <code>cnot_non_adj</code> is CNOT gate with control on the uppermost qubit and target on the lowermost qubit. The matrix is designed according to manual I provided <a href=""https://quantumcomputing.stackexchange.com/questions/9180/how-do-i-write-the-matrix-for-a-cz-gate-operating-on-nonadjacent-qubits/9185#9185"">here</a>.</p>
<p>Note that <code>np.dot</code> is a matrix multiplication. You can see, that the order in the multiplication is reversed in comparison with the diagram.</p>
<p>The result of the code is</p>
<pre><code>Real parts
[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 1. 0.]]

Imaginary parts
[[-0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0. -0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0. -0. -0.]
 [ 0.  0.  0.  0.  0.  0. -0. -0.]]
</code></pre>
<p>This is a matrix description of the Toffoli gate.</p>
",12/28/2021 12:37,Tooling," The question is about how to write the Toffoli gate matrix using one and two qubit gate matrices in Python, which is a tooling question. ",Tooling,,,,Tooling,
23451.0,QuTip: How to multiply symbol with matrix,"<p>I am trying to multiply a symbol with a matrix which is defined by QuTip quantum object, but I got this error:</p>
<pre><code>TypeError: Incompatible object for multiplication
</code></pre>
<p>I used:</p>
<pre><code>from qutip import *
import sympy as sp
w0 = sp.Symbol('\omega_{0}')
w0*destroy(4)
</code></pre>
<p>Did I miss something?</p>
",<programming><qutip>,12/28/2021 6:24,23973.0,23973.0,"<p>well, you can either convert <code>destroy(4)</code> to a sympy matrix or a numpy array like that:</p>
<pre><code>a = destroy(4)
destroy_ = sp.Matrix(a)
destroy_ = w0*destroy_
destroy_
</code></pre>
<p>And here is the result :<a href=""https://i.stack.imgur.com/qBpbT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qBpbT.png"" alt=""enter image description here"" /></a></p>
<p>or try numpy array:</p>
<pre><code>destroy = np.array(a)
result = w0*destroy
</code></pre>
<p>After you finished all stuff (like finding w0 or doing all computations), then, you can convert your final matrix to Qobj</p>
",02/06/2022 22:38,API Usage,The user is asking about how to use the QuTip API to multiply a symbol with a matrix,API Usage,,,,API Usage,
23471.0,Error : Cannot unroll the circuit to the given basis,"<p>I want to run the circuit given below, but I am getting the following error.</p>
<blockquote>
<p>QiskitError: &quot;Cannot unroll the circuit to the given basis, ['u1', 'u2', 'u3', 'cx', 'id', 'unitary']. Instruction cphi_0 not found in equivalence library and no rule found to expand.&quot;</p>
</blockquote>
<p>Why do you think I am encountering this error? I am sharing the codes below. What should I do to run the circuit?</p>
<p><a href=""https://i.stack.imgur.com/y6smL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/y6smL.png"" alt=""Circuit"" /></a></p>
<pre><code>from qiskit_quantum_knn.qknn.qknn_construction import create_oracle, initialise_qknn, state_transformation, add_measurements
from qiskit import BasicAer, execute

n_dim_qubits = 1  # must be log(len(test_state))
n_samps_qubits = 1  # must be log(len(train_data))

test_state = [0, 1]
train_data = [
    [1, 0],
    [0, 1]
]

oracle = create_oracle(train_data)

init_circ = initialise_qknn(n_dim_qubits, n_samps_qubits, test_state)
state_circ = state_transformation(init_circ, oracle)
final_circ = add_measurements(state_circ)
display(final_circ.draw(output=&quot;mpl&quot;))



backend = BasicAer.get_backend('qasm_simulator')
job = execute(final_circ, backend, shots=1024)
</code></pre>
",<qiskit><programming><algorithm><quantum-circuit>,12/29/2021 12:13,23478.0,23478.0,"<p>You are creating a gate from a manually-inputed unitary, and Qiskit does not know how such unitary can be decomposed out of the box.</p>
<p>You can either tell Qiskit transpiler not to decompose your unitary, or extend the Equivalence Library (basically, class that stores information on how gates are decomposed) to know how to decompose your gate. The answer to this question is a fantastic resource: <a href=""https://quantumcomputing.stackexchange.com/questions/17860/transpilation-into-custom-gate-set-in-qiskit"">Transpilation into custom gate set in qiskit</a></p>
<p>Since in your specific case <code>train_data</code> appears to be a basic identity, consider not using a custom gate at all. This way you can rely on already existing gates and you do not need to explain to transpiler how to decompose them.</p>
",12/29/2021 23:08, Errors,The user is encountering an error related to Qiskit while trying to run a specific quantum circuit. This question falls under the category of Qiskit errors as they are seeking help to resolve the issue they are facing with running their circuit in Qiskit., Errors,,,, Errors,
23504.0,"Given this code fragment, what is the probability that a measurement would result in $|0\rangle$?","<p>Trying to understand below probability how it occured?</p>
<pre><code>qc = QuantumCircuit(1)
qc.ry(3 * math.pi/4, 0)
</code></pre>
<p>A. 0.8536</p>
<p>B. 0.5</p>
<p>C. 0.1464</p>
<p>D. 1.0</p>
<p>And the answer is C. But I can't understand the calculation behind it. Can someone please explain?</p>
",<qiskit><programming><quantum-state><ibm-q-experience><textbook-and-exercises>,12/31/2021 10:55,23505.0,23505.0,"<p>We have,
<span class=""math-container"">$$\begin{align}\begin{aligned}\newcommand{\th}{\frac{\theta}{2}}\\\begin{split}Ry(\theta) = \exp\Big(-i \th Y\Big) =
    \begin{pmatrix}
        \cos{\th} &amp; -\sin{\th} \\
        \sin{\th} &amp; \cos{\th}
    \end{pmatrix}\end{split}\end{aligned}\end{align}$$</span></p>
<p>If the input state is <span class=""math-container"">$|0\rangle$</span>, then the probability of getting <span class=""math-container"">$|0\rangle$</span> as a measurement result is the square of the absolute value of the entry in the first row and first column. That is, <span class=""math-container"">$\cos^2\big({\th}\big)$</span>.</p>
<p>Now, <span class=""math-container"">$\theta = 3 \pi/4$</span>, so the probability equals <span class=""math-container"">$\cos^2(3 \pi/8) = 0.1464$</span>.</p>
",12/31/2021 12:43,Theoretical,"The user is asking about a theoretical concept in quantum computing, specifically the calculation of probabilities associated with the application of the Ry gate in a quantum circuit. This falls under the Theoretical category",Theoretical,,,,Theoretical,
23507.0,Efficient Way to Create an LUT in Stim,"<p>What is the fastest and most resource-efficient way to create an LUT decoder for a quantum error correction code using Stim (<a href=""https://quantum-journal.org/papers/q-2021-07-06-497/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2021-07-06-497/</a>)?</p>
<p>Specfically, I am running simulations of a steane QECC using several conditional loops (this was addressed in the question <a href=""https://quantumcomputing.stackexchange.com/questions/22281/simulating-flag-qubits-and-conditional-branches-using-stim"">Simulating flag qubits and conditional branches using Stim</a>).</p>
<p>Is there an efficient way to create the relevant LUTs as well using the TableauSimulator?</p>
",<programming><error-correction><stim>,12/31/2021 13:41,23513.0,23513.0,"<p>The simplest thing to do would be to make a pair of <code>collections.Counter</code>s, sample the circuit millions of times, and add the result-flipped cases into one counter and result-not-flipped to the other. Then for decoding you would look up the current case to see which one had more counts: flip or don't flip.</p>
<pre><code>circuit = ...
assert circuit.num_observables == 1

flip = collections.Counter()
no_flip = collections.Counter()
sampler = circuit.compile_detector_sampler()
for _ in range(1024):
    for shot in sampler.sample(1024, append_observables=True):
        case = tuple(shot[:-1])  # Remove observable bit, make hashable
        was_flipped = shot[-1]
        add_to = flip if was_flipped else no_flip
        add_to[case] += 1

lookup_table = (flip, no_flip)
</code></pre>
",01/01/2022 02:37,Tooling,"The question is asking about how to efficiently create lookup tables (LUTs) for a quantum error correction code (QECC) using the Stim library. This is a question about using the Stim library, which is a tool for programming quantum computers.",Tooling,,,,Tooling,
23528.0,Quantum Phase Estimation - Should be getting exact answer,"<p>Having read the Qiskit demonstration in the Qiskit textbook on how to implement Quantum Phase Estimation, I tried to do so on PennyLane's framework. My code pretty well follows what was done in Qiskit, with a few nuances according to PennyLane, but when I run it over many shots, I get varying answers. For reference, I was implementing the T-Gate (exactly what is done in Qiskit textbook). While my code yields varying possibilities, Qiskit's strictly obtains 001 (which, through post-processing, shows that the applied phase was 1/8). Perhaps there is something wrong with the program I wrote? Is the code supposed to always yield 001?</p>
<pre><code>dev = qml.device('default.qubit', wires = 4, shots=1)

@qml.qnode(dev)

def circuit():

    qml.PauliX(wires = 3)
    
    for qubit in range(3):
        qml.Hadamard(qubit)     
    
    def t_gate(j):
        qml.T(wires = j)
    
    repetitions = 1
    n = len(dev.wires) - 1
    for x in range(n-1, -1, -1):
        for i in range(repetitions):  
            qml.ctrl(t_gate, control = x)(3)
        repetitions *= 2
        
    def ops1(wires = [0, 2]):
        qml.templates.QFT(wires = [0, 2])
    qml.adjoint(ops1)(wires = [0, 2])   

    return qml.sample()

fig, ax = qml.draw_mpl(circuit)()

fig.show()

for i in range(0, 10):

    print(circuit())
</code></pre>
<p>Results:</p>
<pre><code>[0 0 1 1]

[0 1 1 1]

[1 1 1 1]

[0 1 1 1]

[1 1 1 1]

[0 0 1 1]

[1 0 1 1]

[0 0 1 1]

[0 0 1 1]

[0 0 1 1]
</code></pre>
",<programming><pennylane>,01/02/2022 23:43,23544.0,23544.0,"<p>Your circuit is very close, with only minor modifications needed to match the result from the Qiskit textbook.</p>
<ul>
<li><p>The counting registers are the first three wires of the circuit; so we need to apply the inverse QFT to wires 0, 1, and 2.</p>
</li>
<li><p>Similarly, we want to measure samples only from wires 0, 1, and 2.</p>
</li>
</ul>
<p>Here is an updated version of your code with these two changes:</p>
<pre><code>import pennylane as qml
import numpy as np

dev = qml.device(&quot;default.qubit&quot;, wires=4, shots=10)


@qml.qnode(dev)
def circuit():
    qml.PauliX(wires=3)

    for qubit in range(3):
        qml.Hadamard(wires=qubit)

    repetitions = 1

    for x in range(2, -1, -1):
        for i in range(repetitions):
            qml.ControlledPhaseShift(np.pi / 4, wires=[x, 3])

        repetitions *= 2

    qml.adjoint(qml.QFT)(wires=[0, 1, 2])
    return qml.sample(wires=[0, 1, 2])


print(qml.draw(circuit)())
print(circuit())
</code></pre>
<p>This gives the results:</p>
<pre><code> 0: ââHâââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­QFTâ»Â¹âââ­â¤ Sample[basis]
 1: ââHâââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââQFTâ»Â¹ââââ¤ Sample[basis]
 2: ââHâââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ°QFTâ»Â¹âââ°â¤ Sample[basis]
 3: ââXâââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)ââââââââââââ¤

[[0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]
 [0 0 1]]
</code></pre>
<p>matching the expected result from applying phase estimation.</p>
<hr />
<p>Note that I also made some other minor modifications:</p>
<ul>
<li><p>Rather than looping over the QNode executions, if you set <code>shots=N</code> in the device, you will get a somewhat significant speed boost!</p>
</li>
<li><p>While <code>qml.ctrl(qml.T, control=x)(wires=x)</code> works, I have slightly modified this to use <code>qml.ControlledPhaseShift</code>, simply because it prints out slightly nicer in the circuit drawer</p>
</li>
<li><p><code>qml.T</code> and <code>qml.QFT</code> are directly callables, so they can be passed directly to <code>qml.ctrl</code> and <code>qml.adjoint</code>, no need to wrap them in functions :)</p>
</li>
</ul>
",01/04/2022 07:27, API Usage,"The user is asking about how to use the PennyLane API to implement Quantum Phase Estimation. They are encountering an issue where their implementation yields varying results, while a similar implementation in Qiskit consistently yields a specific result. This falls under API usage", API Usage,,,, API Usage,
23545.0,Visualize full UCC circuit in qiskit,"<p>I am experimenting with the UCC module in qiskit nature. From <code>pyscf</code>, I got 1-body and 2-body integrals (I need to use custom integrals) and thus created a mapped Hamiltonian. Then, I create a UCC object and find the optimal parameters, and finally, I visualize the circuit. The code I used (without imports &amp; <code>pyscf</code>-overhead) is shown below.</p>
<pre><code>electronic_energy = ElectronicEnergy.from_raw_integrals(
    ElectronicBasis.MO, one_body_ints, two_body_ints
)
hamiltonian = electronic_energy.second_q_ops()[0]
qubit_converter = QubitConverter(mapper=JordanWignerMapper())
qubit_op = qubit_converter.convert(hamiltonian,num_particles=num_particles)
initial_state = HartreeFock(
        num_spin_orbitals=num_spin_orbitals,
        num_particles=num_particles,
        qubit_converter=qubit_converter,
    )
reps=1
var_form = UCC(
    excitations=&quot;sd&quot;,
    num_particles=num_particles,
    num_spin_orbitals=num_spin_orbitals,
    initial_state=initial_state,
    qubit_converter=qubit_converter,
    reps=reps,
)
optimizer=COBYLA(maxiter=1000)
vqe = VQE(ansatz=var_form, optimizer=optimizer,quantum_instance=Aer.get_backend(&quot;aer_simulator_statevector&quot;))
vqe_result =vqe.compute_minimum_eigenvalue(qubit_op)
from qiskit.tools.visualization import circuit_drawer
circuit=vqe.get_optimal_circuit()
circuit_drawer(circuit, output='mpl', plot_barriers=False)
plt.show()
</code></pre>
<p>I thought that I could visualize the full circuit by printing/drawing the circuit object. This is however not the case, all I get is the following:</p>
<p><a href=""https://i.stack.imgur.com/1TKbl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1TKbl.png"" alt=""Not well visualized UCC circuit"" /></a></p>
<p>How can I visualize the full circuit?</p>
",<qiskit><programming><quantum-circuit>,01/04/2022 08:44,23547.0,23547.0,"<p>You can use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.decompose.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.decompose()</code></a> for shallow decomposition</p>
<pre><code>circuit.decompose().draw('mpl')
</code></pre>
<p>The result will be
<a href=""https://i.stack.imgur.com/BoIk8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BoIk8.png"" alt=""enter image description here"" /></a></p>
<p>For further decomposition you can call <code>decompose()</code> multiple times:</p>
<pre><code>circuit.decompose().decompose().draw('mpl')
</code></pre>
<p>or use <code>reps</code> parameter to specify the number of times the circuit should be decomposed:</p>
<pre><code>circuit.decompose(reps = 6).draw('mpl')
</code></pre>
<p>Another option is to use <a href=""https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.Unroller.html"" rel=""nofollow noreferrer"">Unroller</a> transpiler pass which allows you to specify the target basis gate set:</p>
<pre><code>from qiskit.transpiler.passes import Unroller
from qiskit.converters import circuit_to_dag, dag_to_circuit

# You can specify the target basis gate set:
unroller = Unroller(basis=['u', 'cx'])
unrolled_circuit = dag_to_circuit(unroller.run(circuit_to_dag(circuit)))
unrolled_circuit.draw('mpl')
</code></pre>
",01/04/2022 11:19,API Usage,The user is seeking guidance on how to visualize the full circuit generated by the Qiskit Nature UCC module in their code. This falls under API Usage ,API usage,,,,API Usage,
23577.0,Incorporating idling errors while using stim,"<p>Is there a smart way to incorporate idling errors for a quantum error correction code using the open-source tool stim (preferably using the tableau simulator)? I have perused the <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">code repository</a>, as well as the <a href=""https://quantum-journal.org/papers/q-2021-07-06-497/"" rel=""nofollow noreferrer"">associated paper</a> on the topic, but to no avail.</p>
",<programming><error-correction><noise><stim>,01/05/2022 21:54,23579.0,23579.0,"<p>No, there's no simple built-in way. You have to do it for yourself. This was an intentional design choice, which I will now attempt to justify because I do realize it's inconvenient.</p>
<p>Stim has no concept of an error model separate from the concept of a circuit.  Errors are nothing more than a certain type of instruction that can appear in a circuit file. You can't tell Stim &quot;please add depolarizing errors whenever [some complicated condition is met, such as idling during a measurement]&quot;. Instead, you tell Stim &quot;now do <code>DEPOLARIZE1(0.001) 1 2 3</code>, and then do ..., and then do ...&quot;. <strong>The way you add idling errors is to literally have error instructions, in the circuit, that implement the idling errors.</strong></p>
<p>There are two &quot;nice&quot; ways to do this, I think:</p>
<ol>
<li><p><strong>Add noise parameters to your circuit generation code, and add noise instructions while generating the circuit</strong>. Stim's circuit generation code has a few <em>very</em> simple parameters for this, which I suppose contradicts my statement that stim has literally no concept of a noise model, but the circuit generation code is really just for getting started not for serious use.</p>
</li>
<li><p><strong>Have a method that takes a noiseless circuit and noise parameters, then iterates over the circuit adding noise as appropriate.</strong> For example, that's what I did when analyzing the honeycomb code (<a href=""https://github.com/Strilanc/honeycomb_threshold/blob/main/src/noise.py#L129"" rel=""noreferrer"">source code</a>). Basically: roll your own version of a noise model, specialized for your exact needs.</p>
</li>
</ol>
<p>The motivating reason for the design choice to have noise instructions instead of noise models is that everyone has different ideas about how noise should behave. Here are some examples I've personally run into:</p>
<ul>
<li>Your two qubit gates don't have perfectly uniform depolarizing noise. They have biases towards certain Pauli pairs. So each two qubit gate needs 15 separate noise parameters (one for each non-identity Pauli pair).</li>
<li>Different qubits on your chip have different T1 decay rates. So you need to specify an &quot;idling multiplier&quot; for every qubit you use.</li>
<li>Different operations on your chip have different durations. Qubits idling during a measurement experience more depolarization than qubits idling during other operations. So you need to specify a &quot;duration&quot; for each operation, and a global &quot;idling_per_duration&quot; parameter.</li>
<li>You're writing an error correction circuit, but you don't know how to handle corrections during logical initialization yet. Or during logical measurement. Or during a particularly tricky bit of code deformation right at the midway point. You disable noise during those times while you get the rest working. So every circuit layer needs a &quot;disable noise&quot; flag.</li>
<li>Applying operations simultaneously can create crosstalk. So for every pair of operations that can occur simultaneously you may need a crosstalk parameter.</li>
</ul>
<p>I hope you can see how unnecessarily complicated it would be to jumble all of these things together. And I also hope you can see there would always be just-one-more-thing to add; some other weird use case that wasn't accounted for. There's a natural tendency for the complexity of the rules to ratchet up and up and up until <code>**bam**</code>: you're CSS, you're matplotlib, you're a tangle of spaghetti so dense people can spend a lifetime learning all the exceptions. Disgusting. Stim's design of &quot;I just do exactly what you tell me&quot; bypasses this rule-complexity-ratcheting issue. Each individual user can handle their individual complications, instead of needing to add one more strand to the community spaghetti stack.</p>
",01/05/2022 22:57,Tooling,The user is inquiring about a practical implementation using the open-source tool Stim for incorporating idling errors into a quantum error correction code. This question relates to the tools,Tooling,,,,Tooling,
23616.0,What happens to the elements of the simulated state vector when we set a qubit to $|0\rangle$?,"<p>In IBM's Qiskit online simulator, we have the (non-reversible) ability to set a specific qubit to <span class=""math-container"">$| 0\rangle$</span>. This is convenient but I'm left confused as to what happens to the elements of the statevector. The amplitudes must go somewhere so the probability is conserved, and I imagined at first that the 0 component for each 'Hadamard pair' absorbs the missing amplitude. But this does not take the phase into account.</p>
<p>What happens in the simulator when we set a qubit to <span class=""math-container"">$|0\rangle$</span>?</p>
",<qiskit><programming><quantum-state><ibm-q-experience><measurement>,01/10/2022 01:16,23618.0,23618.0,"<p>Applying a reset to a qubit is equivalent to measuring it, and then applying a bit flip to it conditioned on the measurement result.</p>
<pre><code>def reset(qubit):
    if measure(qubit) == ON:
        X(qubit)
</code></pre>
<p>For example, in this Quirk circuit, you can see that the post-reset state matches the state you'd get when conditioning on a measurement-via-ancilla+bit-flip of the target qubit:</p>
<p><a href=""https://i.stack.imgur.com/uY1gy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uY1gy.png"" alt=""enter image description here"" /></a></p>
<p>An equivalent reset, but perhaps more &quot;physically accurate&quot;, is to swap the qubit for a fresh ancilla, then discard the ancilla.</p>
<pre><code>def reset(qubit):
    ancilla = new_zero_qubit()
    swap(ancilla, qubit)
    discard(ancilla)
</code></pre>
",01/10/2022 03:13,Theoretical ,The question is about the theoretical concept of what happens to the statevector and its amplitudes when a qubit is set to ?0? in IBMs Qiskit online simulator. It involves understanding the principles of quantum computing and how they are implemented in the simulator.,Theoretical,,,,Theoretical ,
23635.0,How to construct a Hamiltonian containing Pauli string by qiskit?,"<p>There is a Hamiltonian I want to construct by a Python package, which is the following:
<span class=""math-container"">$$
H = 5.9I + 0.21Z_0 - 6.12 Z_1 - 2.14(X_0X_1 + Y_0Y_1) + 9.6(I-Z_2) - 3.9(X_1X_2 + Y_1Y_2)
$$</span>
It is very easy for me to create this Hamiltonian by the Python package Projectq. That is:</p>
<pre><code>h = 5.9*QubitOperator('') + 0.21*QubitOperator('Z0') - 6.12*QubitOperator('Z1') - 2.14*(QubitOperator('X0 X1')+QubitOperator('Y0 Y1') )+ 9.6*(QubitOperator('')-QubitOperator('Z2')) - 3.9*(QubitOperator('X1 X2') + QubitOperator('Y1 Y2') )
</code></pre>
<p>However, I want to do this by qiskit. Are there any command like <code>QubitOperator()</code> in qiskit?</p>
",<qiskit><programming><ibm-q-experience>,01/11/2022 01:56,23636.0,23636.0,"<p>You can do something like this:</p>
<pre><code>from qiskit.opflow import X, Y, Z, I
H = 5.9*(I^I^I) + 0.21*(Z^I^I) - 6.12*(I^Z^I) - 2.14*(X^X^I) - 2.14*(Y^Y^I) + 9.6*(I^I^I) - 9.6*(I^I^Z) - 3.9*(I^X^X) - 3.9*(I^Y^Y)
</code></pre>
<p>You can check your answer by printing out the matrix:</p>
<pre><code>from qiskit.visualization.array import array_to_latex
H_matrix = H.to_matrix()
array_to_latex(H_matrix)
</code></pre>
<p><a href=""https://i.stack.imgur.com/vmkGW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vmkGW.png"" alt=""enter image description here"" /></a></p>
",01/11/2022 04:19, Tooling , The question is about how to use a specific function (QubitOperator) in a different Python package (qiskit) to construct a Hamiltonian. It involves understanding the usage of tools and software in quantum programming, Tooling ,,,, Tooling ,
23717.0,Representing Qubit Operator in Circuit,"<p>I am trying to represent a quantum circuit schematically with some operators in QISKIT. I know I can create some operator with <code>Operator()</code> in quantum_info from a circuit circ like</p>
<pre><code>Q1=quantum_info.Operator(circ)
</code></pre>
<p>To add the <span class=""math-container"">$Q_1$</span> operator to the circuit I can do</p>
<pre><code>circ.append(Q1, [0, 1])
</code></pre>
<p>which adds <span class=""math-container"">$Q_1$</span> operator to the circuit and maps the 0th bit of the circuit to the 0th bit of the <span class=""math-container"">$Q_1$</span> operator and 1st bit of the circuit to the 1st bit of the <span class=""math-container"">$Q_1$</span> operator.  The resulting circuit for a 4-qubit circuit circ is</p>
<p><a href=""https://i.stack.imgur.com/5RuOa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5RuOa.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering how to edit the label of the operator. Right now it's just showing Unitary in the circuit block. I tried to find this in the QISKIT documentation. So far, no luck!</p>
",<qiskit><programming><circuit-construction>,1/18/2022 21:01,23718.0,23718.0,"<p>One way to do that is to use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.unitary.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.unitary</code></a> method as follows</p>
<pre><code>circ.unitary(Q1, [0, 1], 'Custom Label')
</code></pre>
<p><a href=""https://i.stack.imgur.com/2CjRN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2CjRN.png"" alt=""enter image description here"" /></a></p>
",1/18/2022 21:13,Tooling,"The question is asking about how to edit the label of an operator in Qiskit, which is a tool for programming quantum computers.", Tooling ,,,,Tooling,
23766.0,Evaluating $\texttt{FermionOperator}$ equality in Openfermion,"<p>Apologies if this is the wrong place to ask this kind of question.</p>
<p>I have a simple question about Openfermion. I have two normal ordered <code>FermionOperator</code>s <code>A</code> and <code>B</code> in Openfermion which are not equal. However, when I evaluate <code>A == B</code>, it returns <code>True</code>. Usually, the equality function seems to work fine, but in this specific case it doesn't seem to work. Below is the source code to replicate this problem.</p>
<p>My question is: why is this happening? I'm wondering if this is maybe a problem with my installation, or perhaps a bug (although, looking at the source code, I cannot see any problems with the equality function). Or maybe I have some sort of conceptual misunderstanding?</p>
<hr />
<p>Source code:</p>
<pre><code>from openfermion import FermionOperator, normal_ordered

#string representation of FermionOperators
A_string = '(4.525943261204361+0j) [0^ 0] +\n(-0.3849231244033131+0j) [0^ 1] +\n(0.8547260787716595+0j) [0^ 2] +\n(-1.1299596129151999+0j) [0^ 3] +\n(-0.3849231244033129+0j) [1^ 0] +\n(-4.381884800061626+0j) [1^ 0^ 1 0] +\n(-4.105905711065374+0j) [1^ 0^ 2 0] +\n(-0.944626497232035+0j) [1^ 0^ 2 1] +\n(3.5938875653898616+0j) [1^ 0^ 3 0] +\n(0.5559380952173161+0j) [1^ 0^ 3 1] +\n(-5.184266085346127+0j) [1^ 0^ 3 2] +\n(0.3677762971945129+0j) [1^ 1] +\n(3.6630156211728777+0j) [1^ 2] +\n(-2.5183774065038045+0j) [1^ 3] +\n(0.8547260787716596+0j) [2^ 0] +\n(-4.105905711065371+0j) [2^ 0^ 1 0] +\n(2.0232821070880056+0j) [2^ 0^ 2 0] +\n(0.8540908922866308+0j) [2^ 0^ 2 1] +\n(1.2460804358695565+0j) [2^ 0^ 3 0] +\n(-5.690396818975691+0j) [2^ 0^ 3 1] +\n(3.2577629759360036+0j) [2^ 0^ 3 2] +\n(3.663015621172878+0j) [2^ 1] +\n(-0.360964409584815+0j) [2^ 1^ 0^ 2 1 0] +\n(-0.515120856381232+0j) [2^ 1^ 0^ 3 1 0] +\n(1.2472039494390206+0j) [2^ 1^ 0^ 3 2 0] +\n(1.2551065744601149+0j) [2^ 1^ 0^ 3 2 1] +\n(-0.9446264972320322+0j) [2^ 1^ 1 0] +\n(0.8540908922866324+0j) [2^ 1^ 2 0] +\n(6.764363308219267+0j) [2^ 1^ 2 1] +\n(-0.5061307336295583+0j) [2^ 1^ 3 0] +\n(1.0665005168981174+0j) [2^ 1^ 3 1] +\n(-1.5870659190452852+0j) [2^ 1^ 3 2] +\n(-1.624576120995937+0j) [2^ 2] +\n(2.9075472932497357+0j) [2^ 3] +\n(-1.1299596129151999+0j) [3^ 0] +\n(3.5938875653898643+0j) [3^ 0^ 1 0] +\n(1.2460804358695592+0j) [3^ 0^ 2 0] +\n(-0.5061307336295612+0j) [3^ 0^ 2 1] +\n(4.19902020363552+0j) [3^ 0^ 3 0] +\n(2.44500249921506+0j) [3^ 0^ 3 1] +\n(-1.4836026643174591+0j) [3^ 0^ 3 2] +\n(-2.518377406503804+0j) [3^ 1] +\n(-0.5151208563812295+0j) [3^ 1^ 0^ 2 1 0] +\n(-0.3481302294514168+0j) [3^ 1^ 0^ 3 1 0] +\n(1.6862584012597264+0j) [3^ 1^ 0^ 3 2 0] +\n(3.6148854702404463+0j) [3^ 1^ 0^ 3 2 1] +\n(0.5559380952173167+0j) [3^ 1^ 1 0] +\n(-5.69039681897569+0j) [3^ 1^ 2 0] +\n(1.066500516898118+0j) [3^ 1^ 2 1] +\n(2.445002499215056+0j) [3^ 1^ 3 0] +\n(0.0213735881799324+0j) [3^ 1^ 3 1] +\n(6.043172803857193+0j) [3^ 1^ 3 2] +\n(2.9075472932497357+0j) [3^ 2] +\n(1.2472039494390192+0j) [3^ 2^ 0^ 2 1 0] +\n(1.686258401259725+0j) [3^ 2^ 0^ 3 1 0] +\n(-4.660442362479951+0j) [3^ 2^ 0^ 3 2 0] +\n(-6.470812728417476+0j) [3^ 2^ 0^ 3 2 1] +\n(-5.184266085346124+0j) [3^ 2^ 1 0] +\n(1.2551065744601169+0j) [3^ 2^ 1^ 2 1 0] +\n(3.6148854702404485+0j) [3^ 2^ 1^ 3 1 0] +\n(-6.470812728417465+0j) [3^ 2^ 1^ 3 2 0] +\n(-3.4393374365242755+0j) [3^ 2^ 1^ 3 2 1] +\n(3.2577629759360045+0j) [3^ 2^ 2 0] +\n(-1.5870659190452812+0j) [3^ 2^ 2 1] +\n(-1.4836026643174585+0j) [3^ 2^ 3 0] +\n(6.043172803857192+0j) [3^ 2^ 3 1] +\n(-0.7285308515736753+0j) [3^ 2^ 3 2] +\n(0.996525236164558+0j) [3^ 3]'
B_string = '(4.525943261204361+0j) [0^ 0] +\n(-0.3849231244033139+0j) [0^ 1] +\n(0.8547260787716593+0j) [0^ 2] +\n(-1.1299596129151999+0j) [0^ 3] +\n(-0.3849231244033138+0j) [1^ 0] +\n(-4.381884800061625+0j) [1^ 0^ 1 0] +\n(-4.105905711065372+0j) [1^ 0^ 2 0] +\n(-0.9446264972320364+0j) [1^ 0^ 2 1] +\n(3.5938875653898648+0j) [1^ 0^ 3 0] +\n(0.5559380952173187+0j) [1^ 0^ 3 1] +\n(-5.184266085346124+0j) [1^ 0^ 3 2] +\n(0.36777629719451244+0j) [1^ 1] +\n(3.6630156211728773+0j) [1^ 2] +\n(-2.518377406503804+0j) [1^ 3] +\n(0.8547260787716591+0j) [2^ 0] +\n(-4.105905711065371+0j) [2^ 0^ 1 0] +\n(2.023282107088007+0j) [2^ 0^ 2 0] +\n(0.8540908922866277+0j) [2^ 0^ 2 1] +\n(1.2460804358695592+0j) [2^ 0^ 3 0] +\n(-5.690396818975689+0j) [2^ 0^ 3 1] +\n(3.257762975936007+0j) [2^ 0^ 3 2] +\n(3.6630156211728773+0j) [2^ 1] +\n(-0.36096440958481857+0j) [2^ 1^ 0^ 2 1 0] +\n(-0.5151208563812304+0j) [2^ 1^ 0^ 3 1 0] +\n(1.2472039494390195+0j) [2^ 1^ 0^ 3 2 0] +\n(1.2551065744601182+0j) [2^ 1^ 0^ 3 2 1] +\n(-0.944626497232038+0j) [2^ 1^ 1 0] +\n(0.8540908922866295+0j) [2^ 1^ 2 0] +\n(6.764363308219268+0j) [2^ 1^ 2 1] +\n(-0.5061307336295606+0j) [2^ 1^ 3 0] +\n(1.0665005168981163+0j) [2^ 1^ 3 1] +\n(-1.5870659190452843+0j) [2^ 1^ 3 2] +\n(-1.624576120995937+0j) [2^ 2] +\n(3.9075472932497366+0j) [2^ 3] +\n(-1.1299596129151999+0j) [3^ 0] +\n(3.5938875653898634+0j) [3^ 0^ 1 0] +\n(1.2460804358695587+0j) [3^ 0^ 2 0] +\n(-0.5061307336295595+0j) [3^ 0^ 2 1] +\n(4.199020203635514+0j) [3^ 0^ 3 0] +\n(2.445002499215058+0j) [3^ 0^ 3 1] +\n(-1.483602664317454+0j) [3^ 0^ 3 2] +\n(-2.518377406503804+0j) [3^ 1] +\n(-0.5151208563812286+0j) [3^ 1^ 0^ 2 1 0] +\n(-0.34813022945142125+0j) [3^ 1^ 0^ 3 1 0] +\n(1.6862584012597162+0j) [3^ 1^ 0^ 3 2 0] +\n(3.6148854702404476+0j) [3^ 1^ 0^ 3 2 1] +\n(0.5559380952173192+0j) [3^ 1^ 1 0] +\n(-5.690396818975689+0j) [3^ 1^ 2 0] +\n(1.066500516898117+0j) [3^ 1^ 2 1] +\n(2.4450024992150574+0j) [3^ 1^ 3 0] +\n(0.02137358817993462+0j) [3^ 1^ 3 1] +\n(6.043172803857192+0j) [3^ 1^ 3 2] +\n(2.9075472932497366+0j) [3^ 2] +\n(1.247203949439014+0j) [3^ 2^ 0^ 2 1 0] +\n(1.6862584012597197+0j) [3^ 2^ 0^ 3 1 0] +\n(-4.660442362479957+0j) [3^ 2^ 0^ 3 2 0] +\n(-6.470812728417478+0j) [3^ 2^ 0^ 3 2 1] +\n(-5.184266085346124+0j) [3^ 2^ 1 0] +\n(1.25510657446012+0j) [3^ 2^ 1^ 2 1 0] +\n(3.614885470240445+0j) [3^ 2^ 1^ 3 1 0] +\n(-6.470812728417472+0j) [3^ 2^ 1^ 3 2 0] +\n(-3.439337436524271+0j) [3^ 2^ 1^ 3 2 1] +\n(3.2577629759360067+0j) [3^ 2^ 2 0] +\n(-1.5870659190452825+0j) [3^ 2^ 2 1] +\n(-1.483602664317455+0j) [3^ 2^ 3 0] +\n(6.043172803857192+0j) [3^ 2^ 3 1] +\n(-0.7285308515736739+0j) [3^ 2^ 3 2] +\n(0.996525236164558+0j) [3^ 3]'

#create FermionOperators
A = normal_ordered(FermionOperator(A_string))
B = normal_ordered(FermionOperator(B_string))

#if A and B are equal, A - B should be zero up to numerical precision
print(&quot;A - B = {}&quot;.format(A - B)) 

#since A and B are not equal, A == B should return False
print(&quot;A == B: {}&quot;.format(A == B))
</code></pre>
<p>The output is</p>
<pre><code>A - B = (-1.0000000000000009+0j) [2^ 3]
A == B: True
</code></pre>
",<programming><chemistry><openfermion>,1/22/2022 19:49,23775.0,23775.0,"<p>This looks like a bug<span class=""math-container"">$^1$</span>. Look at following <a href=""https://github.com/quantumlib/OpenFermion/blob/6a2fdacdd77c5101bc47f3d2bde821f0db717b28/src/openfermion/ops/operators/symbolic_operator.py#L635-L636"" rel=""nofollow noreferrer"">lines of code</a> from the v1.3.0 release branch for the implementation of <code>SymbolicOperator.isclose</code> (which implements <code>FermionOperator.__eq__</code>):</p>
<pre><code>if not (isinstance(a, sympy.Expr) or isinstance(b, sympy.Expr)):
    tol *= max(1, abs(a), abs(b))
</code></pre>
<p>This occurs inside of a for loop comparing <code>A</code> and <code>B</code> componentwise. <code>tol</code> is provided to <code>isclose</code> once at call time, then gets modified by this line to grow larger every time a term of <code>A</code> or <code>B</code> has a (non-sympy) coefficient greater than 1. If the coefficients of each term in <code>A</code> or <code>B</code> are all greater than 1, this will eventually corrupt the tolerance after some number of terms and the comparison becomes vacuous.</p>
<p>Here's a minimal reproducing example</p>
<pre><code>x = FermionOperator(&quot;0^ 0&quot;)
y = FermionOperator(&quot;0^ 0&quot;)
print(EQ_TOLERANCE) # should be 1e-08 for 

# construct two identical operators up to some number of terms
num_terms_before_ineq = 30
for i in range(num_terms_before_ineq):
    x += FermionOperator(f&quot; (10+0j) [0^ {i}]&quot;)
    y += FermionOperator(f&quot; (10+0j) [0^ {i}]&quot;)
    
# add a final term that is equal within tol but gets missed by the isclose check
xfinal = FermionOperator(f&quot; (1+0j) [0^ {num_terms_before_ineq + 1}]&quot;)
yfinal = FermionOperator(f&quot; (2+0j) [0^ {num_terms_before_ineq + 1}]&quot;)
# these two terms are not equal within tol..
print(xfinal == yfinal) # &gt;&gt;&gt; False
print(xfinal - yfinal) # (-1+0j) [0^ 31]

# ...but these two terms will be, because the `tol` argument to `isclose` was corrupted
x += xfinal
y += yfinal
print(x == y) # &gt;&gt;&gt; True
print(x - y) # (-1+0j) [0^ 31]
</code></pre>
<p>If you make <code>num_terms_before_ineq</code> a bit smaller then this issue doesn't come up. But in your case there's a ton of terms, so this seems to be exactly what's happening.</p>
<hr />
<p><span class=""math-container"">$^\dagger$</span> Their intention here <em>almost</em> looks like comparing the terms based on a relative difference compared to <span class=""math-container"">$\lVert \mathbf{a} \rVert_2$</span>, i.e. check if each term agrees within a relative tolerance <span class=""math-container"">$(a_i - b_i) / \text{max}(\lVert \mathbf{a} \rVert_2, \lVert \mathbf{b} \rVert_2) \leq \epsilon$</span>. But in that case <a href=""https://github.com/quantumlib/OpenFermion/blob/6a2fdacdd77c5101bc47f3d2bde821f0db717b28/src/openfermion/ops/operators/symbolic_operator.py#L618-L623"" rel=""nofollow noreferrer"">the docstring</a> for equality checking is wrong,</p>
<pre><code>Comparison is done for each term individually. Return True
if the difference between each term in self and other is
less than EQ_TOLERANCE
</code></pre>
",1/23/2022 20:35, Errors,"The question is about an unexpected behavior (a perceived error) in the Openfermion package, where two FermionOperators that are not equal return True when compared using the equality operator. It involves seeking solutions and explanations for errors and exceptions in quantum program development.", Errors,,,, Errors,
23771.0,"Error Model on id gate, is not giving any error","<p>I am trying to play with <code>NoiseModel</code> of <code>qiskit</code>, and I noticed that error on id gate is not giving any error results, while error on the measurement (or other gates) does give an error:</p>
<pre><code>def get_noise_model(p_err):
    error_gate1 = pauli_error([(&quot;X&quot;, p_err / 2), (&quot;Z&quot;, p_err / 2), (&quot;I&quot;, 1 - p_err)])
    noise_model = NoiseModel()
    noise_model.add_all_qubit_quantum_error(error_gate1, &quot;id&quot;)
    print(error_gate1)
    return noise_model

qc = QuantumCircuit(2, 2)
qc.id(0)
qc.measure([0, 1], [0, 1])

results = (execute(qc,Aer.get_backend(&quot;aer_simulator&quot;),noise_model=get_noise_model(0.2),shots=2048).result().get_counts())

plot_histogram(results)
</code></pre>
<p>Histogram:
<a href=""https://i.stack.imgur.com/FScYS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FScYS.png"" alt=""enter image description here"" /></a></p>
<p>And changing to :</p>
<pre><code>noise_model.add_all_qubit_quantum_error(error_gate1, &quot;measure&quot;)
</code></pre>
<p>gives that:
<a href=""https://i.stack.imgur.com/QEENi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QEENi.png"" alt=""enter image description here"" /></a></p>
<p>Why is that happening? If I perform noisy <code>id</code> gate</p>
<p>imports needed:</p>
<pre><code>from qiskit.visualization import plot_histogram
from qiskit.providers.aer.noise import NoiseModel
from qiskit.providers.aer.noise.errors import pauli_error
from qiskit import QuantumCircuit, execute , Aer
</code></pre>
",<qiskit><programming><quantum-gate><noise>,1/23/2022 12:56,23772.0,23772.0,"<p>By default <code>execute</code> function sets <code>optimization_level</code> value to <span class=""math-container"">$1$</span> which leads to some optimizations such as removing ID gates.</p>
<p>Just set <code>optimization_level</code> to <span class=""math-container"">$0$</span> to override this behavior:</p>
<pre><code>results = (execute(qc,Aer.get_backend(&quot;aer_simulator&quot;),noise_model=get_noise_model(0.2),optimization_level=0,shots=2048).result().get_counts())
</code></pre>
<p>The result should look like:</p>
<p><a href=""https://i.stack.imgur.com/9U3Md.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9U3Md.png"" alt=""enter image description here"" /></a></p>
",1/23/2022 17:55,Errors,"The question is about an unexpected behavior (a perceived error) in the qiskit package, where the NoiseModel does not seem to be applying the expected error to the id gate. It involves seeking solutions and explanations for errors and exceptions in quantum program development", Errors,,,,Errors,
23923.0,Qutip choi_to_kraus and to_kraus functions are not returning list of Kraus representation,"<p>I am trying to find my kraus representation from my process matrix.
Suppose that, I have these process matrix:</p>
<pre><code>proces_matrix =  [[ 1.     0.     0.     0.   ]
  [-0.     0.537 -0.004 -0.005]
  [ 0.023  0.014  0.635 -0.03 ]
  [ 0.011 -0.009  0.017  0.883]]]
</code></pre>
<p>To find the kraus representation, I tried 2 methods.</p>
<ol>
<li>I first tried to use <code>to_kraus</code> function in qutip. According to API documentation, to_kraus Converts a Qobj representing a quantum map to a list of quantum objects, each representing an operator in the Kraus decomposition of the given map. When I gave my process matrix to the function, as a result I got my process matrix back.</li>
</ol>
<p>The code is pretty simple:</p>
<pre><code>    q_proces_matrix = qutip.Qobj(proces_matrix)
    kraus_rep = qutip.to_kraus(q_proces_matrix)
</code></pre>
<ol start=""2"">
<li>Then I thought, I am doing something wrong so I asked this <a href=""https://quantumcomputing.stackexchange.com/questions/23869/how-to-find-the-kraus-operators-from-the-process-matrix"">question</a>, and thanks to a the answer, I first find my Choi matrix with the function of <code>to_choi</code> in qutip and then I used <code>choi_to_kraus</code> function in qutip. The definition of the function is <a href=""https://qutip.org/docs/latest/apidoc/functions.html"" rel=""nofollow noreferrer"">enter link description here</a> It takes choi matrices and turns kraus representations However I got my process matrices as output instead of Kraus representations.</li>
</ol>
<p>The code is again pretty simple:</p>
<pre><code>q_proces_matrix = qutip.Qobj(proces_matrix)
choi = qutip.to_choi(q_proces_matrix)
kraus_rep = qutip.choi_to_kraus(choi)
</code></pre>
<ol start=""3"">
<li>AFter all, I just found the eigenvectors of my Choi matrices and It means the superket operation of my kraus representations. But I am quite confused what I did wrong with qutip function and I did not get my Kraus representations from the functions</li>
</ol>
<p>Could someone explain me what I missed in qutip?</p>
",<programming><kraus-representation><qutip>,02/03/2022 04:12,23933.0,23933.0,"<p>In QuTiP, there are different Qobj types for operators and superoperators, and the <a href=""https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html"" rel=""nofollow noreferrer"">function</a> <code>to_choi</code> will only do what you expect it to if the input has type <code>super</code>.  If you change <code>qutip.Qobj(proces_matrix)</code> to <code>qutip.Qobj(proces_matrix, type='super')</code>, everything should work.</p>
<p>The reason you get the same thing back otherwise is because QuTiP converts to <code>type=oper</code> by default with <code>Qobj()</code> and thus assumes your input is just an operator in the unvectorized convention, such as a single Kraus operator.  Then with your code you ended up converting this to a Choi matrix and back to just a single Kraus operator.</p>
",02/03/2022 15:53,Errors,"The question is about an unexpected behavior (a perceived error) in the qutip package, where the to_kraus and choi_to_kraus functions are not returning the expected Kraus representations. It involves seeking solutions and explanations for errors and exceptions in quantum program development", Errors,,,,Errors,
24003.0,Initialization function of qiskit,"<p>the IBMQ has a initialize function to provide input to the quantum circuit. I am not  understanding the logic used in the initialization function?
Please give me some link related to some useful paper.</p>
",<qiskit><programming><quantum-state>,02/09/2022 03:56,24004.0,24004.0,"<p>This should be what you are looking for: <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Arbitrary-initialization"" rel=""nofollow noreferrer"">Arbitrary initialization</a></p>
<p>Qiskit uses the method proposed in this paper: <a href=""https://arxiv.org/abs/quant-ph/0406176"" rel=""nofollow noreferrer"">Synthesis of Quantum Logic Circuits</a></p>
<hr />
<p><strong>Other related papers:</strong></p>
<ol>
<li><p><a href=""https://arxiv.org/abs/1003.5760"" rel=""nofollow noreferrer"">Quantum-state preparation with universal gate decompositions</a></p>
</li>
<li><p><a href=""https://arxiv.org/pdf/quant-ph/0407010.pdf"" rel=""nofollow noreferrer"">Transformation of quantum states using uniformly controlled rotations</a></p>
</li>
<li><p><a href=""https://arxiv.org/pdf/1501.06911.pdf"" rel=""nofollow noreferrer"">Quantum Circuits for Isometries</a></p>
</li>
<li><p><a href=""https://arxiv.org/abs/0806.4015"" rel=""nofollow noreferrer"">Constructive Quantum Shannon Decomposition from Cartan Involutions</a></p>
</li>
</ol>
",02/09/2022 05:38, Learning,"The question is about understanding the logic used in the initialize function in IBMs Qiskit. It involves a request for learning resources, tutorials, and references in quantum computing", Learning,,,, Learning,
24064.0,Qiskit: PauliTrotterEvolution for Hamiltonian simulation,"<p>Context:<br />
I have H (in qiskit.opflow notation). <br />
I want a circuit which does exp(-itH)</p>
<p>Solution attempt: <br />
I think qiskit.opflow.evolutions.PauliTrotterEvolution should do the trick. <br />
Also, I found this nice tutorial <a href=""https://nahumsa.github.io/n-blog/2021-05-11-quantum_simulation/"" rel=""nofollow noreferrer"">https://nahumsa.github.io/n-blog/2021-05-11-quantum_simulation/</a></p>
<p>Minimalistic example: <br /></p>
<pre><code>from qiskit.opflow import X, Y, Z, I, PauliTrotterEvolution
from qiskit.circuit import Parameter
hamiltonian = 3*(X^X^Z) - 1*(Z^X^Z)
# evolution operator
evo_time = Parameter('t')
evolution_op = (evo_time*hamiltonian).exp_i()
print(evolution_op)
# into circuit
num_time_slices = 1
trotterized_op = PauliTrotterEvolution(
                    trotter_mode='trotter',
                    reps=num_time_slices).convert(evolution_op)
trotterized_op.to_circuit().draw('mpl')
</code></pre>
<p>My output:
<a href=""https://i.stack.imgur.com/gVzAs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gVzAs.png"" alt=""print(evolution_op)"" /></a>
<a href=""https://i.stack.imgur.com/Dn5w2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Dn5w2.png"" alt=""trotterized_op.to_circuit().draw('mpl')"" /></a></p>
<p>Problem: <br />
(a) the Hamiltonian doesn't seem to get trotterized (split up) <br />
(b) the circuit doesn't show the individual gates</p>
<p>Compare that to the nice output of the tutorial quoted above:
<a href=""https://i.stack.imgur.com/x7ja5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/x7ja5.png"" alt=""nice_tutorial_circuit"" /></a></p>
<p>My questions:</p>
<ol>
<li>Is PauliTrotterEvolution the right tool in the first place?</li>
<li>Why does the circuit look different for me than in the linked tutorial?</li>
</ol>
<h2>Solution</h2>
<p>using <code>decompose()</code> shows the gates for single-term-hamiltonians</p>
<pre><code>hamiltonian = (X^X^Z)
evo_time = Parameter('t')
evolution_op = (evo_time*hamiltonian).exp_i()
num_time_slices = 1
trotterized_op = PauliTrotterEvolution(
                    trotter_mode='trotter',
                    reps=num_time_slices).convert(evolution_op)
trot_op_circ = trotterized_op.to_circuit()
trot_op_circ_decomp = trot_op_circ.decompose()
trot_op_circ_decomp.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/whoRa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/whoRa.png"" alt=""hamiltonian=X^X^Z"" /></a></p>
<p>and multiple-term-hamiltonians are split up, but not decomposed into gates:</p>
<pre><code>hamiltonian = (X^X^Z) + (Z^X^Z)
evo_time = Parameter('t')
evolution_op = (evo_time*hamiltonian).exp_i()
num_time_slices = 1
trotterized_op = PauliTrotterEvolution(
                    trotter_mode='trotter',
                    reps=num_time_slices).convert(evolution_op)
trot_op_circ = trotterized_op.to_circuit()
trot_op_circ_decomp = trot_op_circ.decompose()
trot_op_circ_decomp.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/r71GG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r71GG.png"" alt=""hamiltonian = (X^X^Z) + (Z^X^Z)"" /></a></p>
<p>To decompose multiple-term-hamiltonians into gates, decompose can be called repeatedly:</p>
<pre><code>trot_op_circ_decomp = trot_op_circ.decompose()
trot_op_circ_decomp = trot_op_circ_decomp.decompose()
trot_op_circ_decomp.draw('mpl')
</code></pre>
",<qiskit><programming><hamiltonian-simulation>,02/12/2022 16:37,24065.0,24065.0,"<p>You have to decompose the circuit produced by the <code>PauliTrotterEvolution</code> to see what gates are applied inside</p>
<pre><code># your code from above
circuit = trotterized_op.to_circuit()
decomposed = circuit.decompose()
decomposed.draw('mpl')
</code></pre>
<p>In Qiskit we often wrap subcircuits into a block so that you can see what's going on on a higher level of abstraction. But you can still have a look inside those blocks by decomposing :)</p>
",02/12/2022 16:47,Tooling,The question is about how to use the PauliTrotterEvolution function in Qiskit to create a circuit that performs exp(-itH) for a given Hamiltonian H. It involves understanding the usage of tools and software in quantum programming, Errors,The user is seeking solutions and explanations for errors and exceptions in quantum program development. They are trying to understand why the PauliTrotterEvolution function in qiskit is not producing the expected output,No,120.0, Errors,"The user is seeking explanations for discrepancies between their expected output and the actual output when using the PauliTrotterEvolution function in Qiskit. They are trying to understand why the Hamiltonian is not properly trotterized and why the circuit does not display individual gates as expected, indicating issues or errors in their implementation."
24072.0,"What are the differences between Qiskit's AerSimulator, QasmSimulator and StatevectorSimulator?","<p>In Qiskit, we can see the names of available simulators with the command <code>Aer.backends()</code>. These include:</p>
<pre><code>AerSimulator('aer_simulator')
AerSimulator('aer_simulator_statevector')
AerSimulator('aer_simulator_density_matrix') 
QasmSimulator('qasm_simulator')
StatevectorSimulator('statevector_simulator')
</code></pre>
<p>What are differences between <code>AerSimulator('aer_simulator')</code>, <code>AerSimulator('aer_simulator_density_matrix')</code> and <code>QasmSimulator('qasm_simulator')</code>? All three seem to perform similar QASM simulation.</p>
<p>Similarly, what are differences between <code>AerSimulator('aer_simulator_statevector')</code> and <code>StatevectorSimulator('statevector_simulator')</code>?</p>
",<qiskit><programming><qasm>,2/13/2022 5:07,24074.0,24074.0,"<h3>Deprecation Note:</h3>
<ul>
<li><p>The <code>StatevectorSimulator</code> has been superseded by the <code>AerSimulator</code> and will be deprecated in the future.
It has same functionality as <code>AerSimulator(method=&quot;statevector&quot;)</code>.</p>
</li>
<li><p>The same is true for <code>QasmSimulator</code>. It has been superseded by <code>AerSimulator</code> and will be deprecated in the future.</p>
</li>
</ul>
<h3>Difference:</h3>
<p>According to the documentation <a href=""https://qiskit.org/documentation/tutorials/simulators/1_aer_provider.html"" rel=""nofollow noreferrer"">here</a>, the difference between simulation methods like <code>statevector</code> and <code>density_matrix</code> is:</p>
<blockquote>
<p>The <code>AerSimulator</code> supports a variety of simulation methods, each of which supports a different set of instructions. The method can be set manually using <code>simulator.set_option(method=value)</code> option, or a simulator backend with a preconfigured method can be obtained directly from the <code>Aer</code> provider using <code>Aer.get_backend</code>.</p>
</blockquote>
<blockquote>
<p>When simulating ideal circuits, changing the method between the exact simulation methods <code>stabilizer</code>, <code>statevector</code>, <code>density_matrix</code> and <code>matrix_product_state</code> should not change the simulation result (other than usual variations from sampling probabilities for measurement outcomes)</p>
</blockquote>
<p>More information is <a href=""https://qiskit.org/documentation/stubs/qiskit.providers.aer.AerSimulator.html"" rel=""nofollow noreferrer"">here</a>:</p>
<blockquote>
<p><code>&quot;statevector&quot;</code>: A dense statevector simulation that can sample measurement outcomes from ideal circuits with all measurements at end of the circuit. For noisy simulations each shot samples a randomly sampled noisy circuit from the noise model.</p>
</blockquote>
<blockquote>
<p><code>&quot;density_matrix&quot;</code>: A dense density matrix simulation that may sample measurement outcomes from noisy circuits with all measurements at end of the circuit.</p>
</blockquote>
",2/13/2022 6:44,Tooling,"The question pertains to understanding the differences between various simulators in Qiskit, which falls under the category of tooling, as it's related to software usage and tools in quantum programming.", Tooling ,,,,Tooling,
24075.0,"Missing types, namespaces, directives, and assembly references","<p>I use <code>VS Code</code> for <code>C#</code> and <code>Unity3D</code> and <code>TypeScript</code> and <code>Angular</code> and <code>Python</code> programming, so I have pretty much every required extension, including the <code>.NET Framework</code> and <code>Core</code> as well as the <code>Quantum Development Kit (QDK)</code> plus the <code>Q# Interoperability Tools</code> and also <code>C#</code> and <code>Python</code> extensions for <code>VS Code</code>.</p>
<p>I have devised the following steps to create my first quantum Hello World based on a few tutorials:</p>
<pre><code><span class=""math-container"">$ dotnet --version
$</span> dotnet --list-sdks
$ dotnet --list-runtimes

<span class=""math-container"">$ dotnet new globaljson                                     # Create a ""global.json"" file in your current directory folder.  
$</span> dotnet new globaljson --sdk-version 3.1.416 --force       # Change the current SDK version of your project.

<span class=""math-container"">$ dotnet new -i Microsoft.DotNet.Web.Spa.ProjectTemplates
$</span> dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates::0.2-*&quot;

# First, create a Q# application and a .NET host, and then make a call to Q# from the host.
# Create a project for your Q# library and for the .NET host that will call
# into the operations and functions defined in your Q# library.

<span class=""math-container"">$ dotnet new classlib -lang Q# -o quantum                         # Create a new Q# class-library project.
$</span> dotnet new console -lang C# -o host                             # Create a new C# console project.

<span class=""math-container"">$ cd host                                                         # Navigate into the C# host directory.
$</span> dotnet add reference ../quantum/quantum.csproj                  # Add your Q# class-library project as a reference to your C# console project.

<span class=""math-container"">$ cd ..                                                           # Exit the C# host directory.
$</span> dotnet new sln -n quantum-dotnet                                # Create a new solution for both projects.
<span class=""math-container"">$ dotnet sln quantum-dotnet.sln add ./quantum/quantum.csproj      # Add the Q# class-library project to the solution.
$</span> dotnet sln quantum-dotnet.sln add ./host/host.csproj            # Add the C# host project to the solution.

# The -o or --output command specifies the location to place the generated output.
</code></pre>
<p><strong>However</strong>, as soon as this is all done, I get the following load of errors:</p>
<p><a href=""https://i.stack.imgur.com/WcEli.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WcEli.png"" alt=""enter image description here"" /></a></p>
<p>What am I doing wrong? What am I missing?</p>
<hr />
<p>Here is some additional info:</p>
<pre><code>$ dotnet --list-sdks
3.1.416 [C:\Program Files\dotnet\sdk]
5.0.404 [C:\Program Files\dotnet\sdk]

$ dotnet --version  
3.1.416

$ dotnet restore
  Determining projects to restore...
  Restored C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj (in 484 ms).
  Restored C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\host\host.csproj (in 782 ms).
</code></pre>
<hr />
<p>When I run <code>dotnet build</code>, I get the following:</p>
<p>Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.</p>
<p>Determining projects to restore...
All projects are up-to-date for restore.
It was not possible to find any compatible framework version
The framework 'Microsoft.NETCore.App', version '2.0.0' was not found.
- The following frameworks were found:
3.1.22 at [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
5.0.13 at [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]</p>
<p>You can resolve the problem by installing the specified framework and/or SDK.</p>
<p>The specified framework can be found at:
- <a href=""https://aka.ms/dotnet-core-applaunch?framework=Microsoft.NETCore.App&amp;framework_version=2.0.0&amp;arch=x64&amp;rid=win10-x64"" rel=""nofollow noreferrer"">https://aka.ms/dotnet-core-applaunch?framework=Microsoft.NETCore.App&amp;framework_version=2.0.0&amp;arch=x64&amp;rid=win10-x64</a>
C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build\Microsoft.Quantum.Development.Kit.targets(17,5): error MSB3073: The command &quot;dotnet C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build../tools/qsc/qsc.dll --input &quot;Operation.qs&quot; --references &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.canon\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Canon.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.MetaData.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Primitives.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Common.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Core.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Simulators.dll&quot; --outputpath obj\qsharp\src&quot; exited with code -2147450730. [C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj]</p>
<p>Build FAILED.</p>
<p>C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build\Microsoft.Quantum.Development.Kit.targets(17,5): error MSB3073: The command &quot;dotnet C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\build../tools/qsc/qsc.dll --input &quot;Operation.qs&quot; --references &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.canon\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Canon.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.MetaData.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Primitives.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Common.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Core.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.QCTraceSimulatorRuntime.dll&quot; &quot;C:\Users\Muhy.nuget\packages\microsoft.quantum.development.kit\0.2.1802.1603-preview\lib\netstandard2.0\Microsoft.Quantum.Simulation.Simulators.dll&quot; --outputpath obj\qsharp\src&quot; exited with code -2147450730. [C:\Users\Muhy\Dropbox\Q\Q#-programs\Qtest\quantum\quantum.csproj]
0 Warning(s)
1 Error(s)</p>
<hr />
<p>When I also build the project (<code>dotnet build quantum-dotnet.sln</code> and <code>dotnet build ./host/host.csproj</code>) I get the same errors.</p>
",<q#>,2/13/2022 8:40,24278.0,24278.0,"<p>I see the problem now. The command:</p>
<pre><code>dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates::0.2-*&quot;
</code></pre>
<p>installed version <code>0.2.1802.1603-preview</code>, which is many years old. Our latest version is <code>0.22.187631</code>.</p>
<p>Is there any specific reason you decided to specify a version number when installing the templates package? This should work:</p>
<pre><code>dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates&quot;
</code></pre>
<p>My recommendation is to run:</p>
<pre><code>dotnet new --update-apply
</code></pre>
<p>to update all your project templates. After this, re-create the projects. Let us know if this works.</p>
",2/27/2022 9:17,Errors," The user is encountering errors while setting up a quantum development environment and trying to build a quantum project, specifically related to .NET Core, Q# development kit, and project dependencies.", Errors,,,,Errors,
24107.0,Using qml.AmplitudeEmbedding two times in a circuit raises an error,"<p>I'm trying to use <code>qml.AmplitudeEmbedding()</code> two times in a circuit but it raises an error saying that the device used does not support this feature.</p>
",<programming><quantum-circuit><pennylane>,2/15/2022 17:02,24109.0,24109.0,"<p>This is a current restriction with PennyLane, in that only a single, initial state preparation routine can be used.</p>
<p>However, you can use the <a href=""https://pennylane.readthedocs.io/en/latest/code/api/pennylane.transforms.merge_amplitude_embedding.html"" rel=""nofollow noreferrer""><code>qml.transforms.merge_amplitude_embedding</code></a> transform to merge multiple amplitude embeddings in your quantum function, <strong>as long as they act on different wires</strong>:</p>
<pre><code>dev = qml.device('default.qubit', wires=4)

@qml.qnode(dev)
@qml.transforms.merge_amplitude_embedding
def qfunc():
    qml.CNOT(wires=[0, 1])
    qml.AmplitudeEmbedding([0, 1], wires=2)
    qml.AmplitudeEmbedding([0, 1], wires=3)
    return qml.probs(wires=[0, 1, 2, 3])
</code></pre>
<p>Using the transformation we can join the different amplitude embeddings into a single one:</p>
<pre><code>&gt;&gt;&gt; print(qml.draw(qfunc)())
  0: âââ­Cââââââââââââââââââââââââ­â¤ Probs
  1: âââ°Xâââââââââââââââââââââââââ¤ Probs
  2: âââ­AmplitudeEmbedding(M0)ââââ¤ Probs
  3: âââ°AmplitudeEmbedding(M0)âââ°â¤ Probs
  M0 = [0.+0.j 0.+0.j 0.+0.j 1.+0.j]
</code></pre>
",2/15/2022 17:19, Errors,"The inquiry is related to seeking a solution and explanation for an error in quantum program development, specifically regarding the use of the qml.AmplitudeEmbedding() function, which raises an error related to device support.", Errors,,,, Errors,
24112.0,QuTIP tensor products,"<p>I am referring to the QuTIP package
<a href=""https://qutip.org/"" rel=""nofollow noreferrer"">https://qutip.org/</a></p>
<p>To describe a system of 3 atoms in the ground state, I can crate the wavefunction:
<em>tensor( basis(2,0), basis(2,0), basis(2,0) )</em></p>
<p>Now suppose that I want to write a Python function that implements a system with N atoms in such a tensor product. If N=5, the system will look like:</p>
<p><em>tensor( basis(2,0), basis(2,0), basis(2,0), basis(2,0), basis(2,0) )</em></p>
<p>If N=100, you get the idea. How would I write the tensor product in a general way, for N tensor products?</p>
",<programming><optical-quantum-computing><qutip>,2/15/2022 20:52,24116.0,24116.0,"<p>good question - indeed the qutip API could use some improvements when dealing with tensor products. However, here python comes to the rescue with <a href=""https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/"" rel=""nofollow noreferrer"">argument unpacking</a>. To create a 4 qubit basis state, you can do e.g:</p>
<pre><code>qp.tensor(*[qp.basis(2, 0) for _ in range(4)])
</code></pre>
<p>if you need more complicated arguments, you can build the list upfront and then unpack it, e.g:</p>
<pre><code>args = [destroy(2)] + [qp.basis(2, 0) for _ in range(4)]
qp.tensor(*args)
</code></pre>
<p>just keep in mind that this:</p>
<pre><code>lst = [qp.basis(2, 0)] * 4
</code></pre>
<p>will not work as you probably expect it - it will create a list with 4 references to the same object, not initialize 4 different objects.</p>
<p>Let me know if this helps.</p>
",2/16/2022 8:19,Theoretical,"The inquiry is about a theoretical concept in quantum computing, specifically related to creating a tensor product of quantum states for a variable number of atoms, which involves understanding the mathematical representation of such systems.",Theoretical,,,,Theoretical,
24155.0,How to generate statevector evolution?,"<p>I have created the following 2-qubit circuit in qiskit:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

from qiskit import QuantumCircuit, QuantumRegister, Aer, transpile, assemble
from qiskit.providers.aer import AerSimulator
from qiskit.providers.aer.library import save_statevector

# XX(t) subcircuit
def XX(target_time):
    XX_qr = QuantumRegister(2)
    XX_qc = QuantumCircuit(XX_qr, name='XX')

    XX_qc.ry(np.pi/2,[0,1])
    XX_qc.cnot(0,1)
    XX_qc.rz(2*target_time,1)
    XX_qc.cnot(0,1)
    XX_qc.ry(-np.pi/2,[0,1])
    return XX_qc

# YY(t) subcircuit
def YY(target_time):
    YY_qr = QuantumRegister(2)
    YY_qc = QuantumCircuit(YY_qr, name='YY')

    YY_qc.rx(np.pi/2,[0,1])
    YY_qc.cnot(0,1)
    YY_qc.rz(2*target_time,1)
    YY_qc.cnot(0,1)
    YY_qc.rx(-np.pi/2,[0,1])
    return YY_qc

# ZZ(t) subcircuit
def ZZ(target_time):
    ZZ_qr = QuantumRegister(2)
    ZZ_qc = QuantumCircuit(ZZ_qr, name='ZZ')

    ZZ_qc.cnot(0,1)
    ZZ_qc.rz(2*target_time,1)
    ZZ_qc.cnot(0,1)
    return ZZ_qc

# create ZZ(t)YY(t)XX(t) circuit and prepare in initial state
def quantum_circuit(target_time, num_qubits, initial_state):
    # initialize quantum circuit for 2 qubits
    qr = QuantumRegister(num_qubits)
    qc = QuantumCircuit(qr)
    # initialize circuit
    qc.initialize(initial_state)
    # construct circuit from ZZ(t), YY(t), and XX(t) subcircuits
    for i in range(0, num_qubits - 1):
        qc.append(ZZ(target_time), [qr[i], qr[i+1]])
        qc.append(YY(target_time), [qr[i], qr[i+1]])
        qc.append(XX(target_time), [qr[i], qr[i+1]])
    # measure qubits
    qc.measure_all()
    return qc

# create circuit
qc = quantum_circuit(target_time=0.0, num_qubits=2, initial_state='10')
print(qc)
</code></pre>
<p>I transpile, assemble, and pass this to the Aer statevector_simulator:</p>
<pre><code>backend = Aer.get_backend('statevector_simulator')
qobj = transpile(qc,backend)
job = assemble(qobj)
run_job = backend.run(job)
</code></pre>
<p>When I do this, I get the following error: <code>ERROR: Failed to load qobj: Unable to cast Python instance to C++ type (compile in debug mode for details)</code>.</p>
<p>In this particular circuit, I am initializing it in the |10&gt; state. In the code that I have provided here, I am initializing the state using the <code>QuantumCircuit.initialize()</code> method. However, when I initialize the state to |10&gt; by just adding an <code>x</code> gate to the second qubit, there is no problem. It runs fine.</p>
<p>Ultimately, I am trying to find a way to initialize the circuit in some state, run it at time=0, extract the final state, and then run it at some later time, where the final state is now the initial state. Where I am stuck is initializing the circuit evaluated at t=t0+dt with the final state of the circuit evaluated at t (for example). In essence, I am trying to evaluate unitary time evolution of the state: |psi(t+dt)&gt;=U|psi(t)&gt;.</p>
<p>So... my question is two fold:
1.) Why am I getting this <code>Failed to load qobj: Unable to cast Python instance to C++ type (compile in debug mode for details)</code> error? How can I fix this?
2.) How can I generate this state evolution?</p>
",<qiskit><programming><quantum-state><algorithm><unitarity>,2/18/2022 4:56,24160.0,24160.0,"<blockquote>
<p>1.) Why am I getting this Failed to load qobj: Unable to cast Python instance to C++ type (compile in debug mode for details) error? How can I fix this?</p>
</blockquote>
<p>Initializing a circuit via <code>circuit.initialize()</code> with labels makes the simulation fail. See <a href=""https://github.com/Qiskit/qiskit-terra/issues/7631"" rel=""nofollow noreferrer"">here</a>.</p>
<blockquote>
<p>2.) How can I generate this state evolution?</p>
</blockquote>
<p>Just replace this line</p>
<pre><code>qc = quantum_circuit(target_time=0.0, num_qubits=2, initial_state='10')
</code></pre>
<p>with</p>
<pre><code>qc = quantum_circuit(target_time=0.0, num_qubits=2, initial_state=[0, 0, 1, 0])
</code></pre>
<p>or,</p>
<pre><code>from qiskit.quantum_info import Statevector
qc = quantum_circuit(target_time=0.0, num_qubits=2, initial_state=Statevector.from_label('10'))
</code></pre>
",2/18/2022 12:01,Errors,The question is related to seeking a solution and explanation for an error in quantum program development. The user is encountering an error message related to loading a quantum object (qobj) in Qiskit and is seeking help to fix the issue.,Errors,,,,Errors,
24159.0,Swaps in a uniform superposition,"<p>Starting from a state <span class=""math-container"">$|00\rangle|01\rangle|10\rangle$</span> (from <span class=""math-container"">$0$</span> to <span class=""math-container"">$n$</span> without repetitions), I want to reach an state in which all possible combinations of swaps are in a uniform superposition. I mean:</p>
<p><span class=""math-container"">$\frac{1}{\sqrt{6}}(|00\rangle|01\rangle|10\rangle + |00\rangle|10\rangle|01\rangle + |01\rangle|00\rangle|10\rangle + |01\rangle|10\rangle|00\rangle + |10\rangle|00\rangle|01\rangle + |10\rangle|01\rangle|00\rangle)$</span></p>
<p>In fact, I want to do a general code with for any <span class=""math-container"">$n$</span> and not just <span class=""math-container"">$3$</span> as in the example above. I can do it for cases in which <span class=""math-container"">$n$</span> is a power of <span class=""math-container"">$2$</span> like <span class=""math-container"">$4, 8, 16,$</span> etc. using an ancilla. However, I can do the same for <span class=""math-container"">$n = 3$</span> because I got something like:</p>
<p>00-01-10: 0.125</p>
<p>00-10-01: 0.25</p>
<p>01-00-10: 0.125</p>
<p>01-10-00: 0.25</p>
<p>10-00-01: 0.125</p>
<p>10-01-00: 0.125</p>
<p>(two states are repeated so its probability is higher)</p>
",<qiskit><programming><entanglement-swapping>,2/18/2022 11:50,24161.0,24161.0,"<p>Appendix C in this <a href=""https://arxiv.org/abs/1711.10460"" rel=""nofollow noreferrer"">paper</a> provides an algorithm to do this based on a variant of the <a href=""https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""nofollow noreferrer"">Fisher-Yates shuffle</a>. The paper provides all the details you need to implement the algorithm in easy to follow steps.</p>
",2/18/2022 12:20,Theoretical,"The question pertains to a theoretical concept in quantum computing, specifically about creating a quantum state with a uniform superposition of all possible combinations of swaps, and the user is looking for a general solution for any value of ""n.""",Theoretical,,,,Theoretical,
24260.0,Grover's algorithm for 3SAT problem gives unexpected results,"<p>Based on <a href=""https://qiskit.org/textbook/ch-applications/satisfiability-grover.html"" rel=""nofollow noreferrer"">SAT problem</a> and <a href=""https://qiskit.org/documentation/tutorials/algorithms/06_grover.html"" rel=""nofollow noreferrer"">Grover's algorithm</a>, I've done some experiments. For the below example, I've received unexpected results:</p>
<ol>
<li><p>Input: boolean function:</p>
<pre><code>c example 4
p cnf 3 4
1 -2 -3 0
1 -2 3 0
1 2 -3 0
-1 -2 -3 0
</code></pre>
</li>
<li><p>Truth table of boolean function:</p>
</li>
</ol>
<p><a href=""https://i.stack.imgur.com/ueM8t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ueM8t.png"" alt=""enter image description here"" /></a></p>
<ol start=""3"">
<li>Histogram of results</li>
</ol>
<p><a href=""https://i.stack.imgur.com/QwlmP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QwlmP.png"" alt=""enter image description here"" /></a></p>
<p>According to the truth table, the results should be ['000', '001', '011', '101']. Why does the algorithm not return the expected solutions?</p>
<p>EDIT:
Regarding the first comment. I've noticed that for boolean function:</p>
<pre><code>c example 3
p cnf 3 3
1 -2 -3 0
1 -2 3 0
1 2 -3 0
</code></pre>
<p>We get the correct results. In this example <span class=""math-container"">$M&gt;N/2$</span>.Additionally, I've noticed that the first example is a balanced function and the second one is not. Is it relevant?</p>
",<qiskit><programming><grovers-algorithm><3sat-problem>,2/25/2022 17:10,24264.0,24264.0,"<p>This issue happens because <span class=""math-container"">$M \geq \frac{N}{2}$</span>, where <span class=""math-container"">$M$</span> is the number of solutions and <span class=""math-container"">$N$</span> is the search domain size. For more details see this <a href=""https://quantumcomputing.stackexchange.com/a/15267/9474"">answer</a>.</p>
<p>A workaround is to double the search domain by adding a dummy variable:</p>
<pre><code>c example 4
c Add one to &lt;#vars&gt; and &lt;#clauses&gt;
p cnf 4 5
1 -2 -3 0
1 -2 3 0
1 2 -3 0
-1 -2 -3 0
c Add a clause for the dummy variable
-4 0
</code></pre>
<p>For you second example, 3 out of 5 solutions will be returned if the optimal number of iterations is used (<span class=""math-container"">$\Big\lfloor \frac{\pi}{4} \sqrt{N/M}\Big\rfloor$</span>). You can get all the solutions by changing the number of iterations:</p>
<pre><code>grover = Grover(iterations = 2, quantum_instance=quantum_instance)
</code></pre>
<p>Doing the same for the first example will not work (see the figure in this <a href=""https://quantumcomputing.stackexchange.com/a/21810/9474"">answer</a>). However, doubling search domain should always work.</p>
",2/26/2022 9:50, Theoretical," The question is asking about why Grover's algorithm is not returning the expected solutions for a balanced Boolean function. This is a theoretical question about the algorithm itself, rather than a question about how to use it in practice.", Theoretical,,,, Theoretical,
24295.0,Results are missing for Qiskit runtime program 'sample-expval',"<p>I have ran some circuits using the code for <code>sample-expval</code>, found in the <a href=""https://quantum-computing.ibm.com/services?program=sample-expval"" rel=""nofollow noreferrer"">qiskit docs</a>
While the jobs finished (they appear in my IBM account), when I retrieve some job and try to recover the result with <code>job.result()</code> what I obtain is just quotes: <code>''</code></p>
<p>Here is the code that I ran:</p>
<pre><code>job = provider.runtime.run(program_id='sample-expval',
                       options={'backend_name': 'ibmq_belem'},
                       inputs={'circuits':allcircuits_list[0],
                       'expectation_operators':all_zeros_proj,'shots':10000,
                       'use_measurement_mitigation':True})
</code></pre>
<p><code>allcircuits_list[0]</code> is a list of circuits that I previously defined and <code>all_zeros_proj = {'00': 1}</code></p>
<p>I also tried with the code indicated in the <a href=""https://qiskit.org/documentation/partners/qiskit_runtime/tutorials/sample_expval_program/qiskit_runtime_expval_program.html"" rel=""nofollow noreferrer"">qiskit tutorial</a>
which first defines a function <code>expectation_value_runner</code> that contains the input parameters. After introducing the inputs I ran</p>
<pre><code>backend = provider.get_backend('ibmq_belem') 
job = expectation_value_runner(backend, allcircuits_list, all_zeros_proj)
</code></pre>
<p>In this case I have the same problem. No results are retrieved.</p>
",<qiskit><programming><ibm-q-experience>,2/28/2022 18:56,24333.0,24333.0,"<p>There was an issue with Qiskit Runtime 2 days ago that result data was not being returned. The issue has since been fixed, so it should work now.</p>
",03/02/2022 22:08,Errors,"The question is about an error encountered while trying to retrieve results from a job run using the sample-expval program in Qiskit, which falls under the Errors category",Errors,,,,Errors,
24328.0,Is there a quantum algorithm to find SHA256 collisions?,"<p>As I understand, the Bitcoin network can be seen as a supercomputer looking for SHA256 collisions. It hasn't found one yet (March 2022). Also, in the post-quantum cryptography era, you would be capable of reversing SHA256 hashes.</p>
<p>But in the case of finding hash collisions, is there an algorithm already proposed?</p>
",<programming><algorithm><cryptography>,03/02/2022 20:20,24332.0,24332.0,"<p>The <a href=""https://arxiv.org/abs/quant-ph/9705002"" rel=""nofollow noreferrer"">BHT algorithm</a> finds collisions in a hash with <span class=""math-container"">$N$</span> outputs in around <span class=""math-container"">$\sqrt[3]{N}$</span> evaluations, i.e., around <span class=""math-container"">$2^{85}$</span> for SHA-256. Realistically, that's too slow to be practical.</p>
<p>In principle, it might be possible to do better by exploiting special properties of SHA-256. <a href=""https://eprint.iacr.org/2020/213"" rel=""nofollow noreferrer"">This paper</a> has some quantum attacks on reduced-round versions of some hash functions that are better than the best known classical attacks, but reduced-round attacks don't work on the full-round hashes used in the real world.</p>
<blockquote>
<p>in the post-quantum cryptography era, you would be capable of reversing SHA256 hashes.</p>
</blockquote>
<p>SHA-256 can't be reversed because it's many-to-one. If you rephrase the problem as finding any string with the same hashânot necessarily the one that was originally hashedâthen you can use Grover's algorithm, but it takes around <span class=""math-container"">$\sqrt{N}=2^{128}$</span> hash evaluations.</p>
<p>I think some people imagine that because quantum circuits are reversible, you can run them backwards to invert any function. If you had a circuit that turned <span class=""math-container"">$x$</span> into <span class=""math-container"">$\text{SHA-256}(x)$</span> then you could do that, but no one knows how to make that circuit. They know how to make a circuit that turns <span class=""math-container"">$(x,y)$</span> into <span class=""math-container"">$(x,y\oplus \text{SHA-256}(x))$</span>, but that circuit is its own inverse, so running it backwards doesn't help to invert SHA-256.</p>
",03/02/2022 21:56,Theoretical,"The question is about a theoretical concept in quantum computing, specifically related to the algorithm for finding hash collisions in the context of Bitcoin network and post-quantum cryptography. This involves understanding the principles and algorithms in quantum computing, which falls under the Theoretical category.",Theoretical,,,,Theoretical,
24349.0,cannot find hello_qiskit module,"<p>I'm currently following the &quot;Introduction To Quantum Programming&quot; course of qiskit.</p>
<p>At the beginning of &quot;Visualizing entanglement&quot; chapter :
<a href=""https://learn.qiskit.org/course/introduction/visualizing-entanglement"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/introduction/visualizing-entanglement</a></p>
<p>We have to run this line:
<code>from hello_qiskit import run_puzzle</code></p>
<p>This raises this error :</p>
<blockquote>
<p>ModuleNotFoundError: No module named 'hello_qiskit'</p>
</blockquote>
<p>I cannot find the hello_qiskit module in my anaconda environnement
And if I try to install it with</p>
<p><code>pip install hello_qiskit</code>
I have this error:</p>
<blockquote>
<p>ERROR: Could not find a version that satisfies the requirement
hello_qiskit (from versions: none) ERROR: No
matching distribution found for hello_qiskit</p>
</blockquote>
<p>How can I install this module or is there another way to use the run_puzzle function ?</p>
",<qiskit><programming>,03/03/2022 15:56,24434.0,24434.0,"<p><code>hello_qiskit</code> is just a python file that lives in the Qiskit Textbook Jupyter Notebook system that is used as a short-cut/helper to interact with <code>qiskit_textbook.games.hello_quantum</code>. In <a href=""https://learn.qiskit.org/course/introduction/visualizing-entanglement"" rel=""nofollow noreferrer"">Visualizing Entanglement</a>, if you add</p>
<pre><code>import hello_qiskit
help(hello_qiskit)
</code></pre>
<p>to the first cell, you will find a file <code>/home/jovyan/hello_qiskit.py</code> that contains the <code>run_puzzle</code> method, defined as follows:</p>
<pre><code>from qiskit_textbook.games import hello_quantum

def run_puzzle(j):
    puzzle = hello_quantum.run_game(exercises[j]['initialize'],
                           exercises[j]['success_condition'],
                           exercises[j]['allowed_gates'],
                           exercises[j]['vi'],
                           qubit_names=exercises[j]['qubit_names'],
                           mode=exercises[j]['mode']
                          )
    return puzzle
</code></pre>
<p>This method references a list <code>exercises</code> of dictionaries defining arguments that will be passed to the <code>run_game</code> method. When you pass an <code>int</code> to the <code>run_puzzle</code> method, you are simply indexing the <code>exercises</code> list defined in <code>hello_qiskit.py</code>. For example, <code>run_puzzle(0)</code> accesses <code>exercises[0]</code>, which is defined as</p>
<pre><code>{
    'initialize': [],
    'success_condition': {},
    'allowed_gates': {'0': {'x': 3}, '1': {}, 'both': {}},
    'vi': [[1], True, False],
    'mode': 'line',
    'qubit_names': {'0':'q[0]', '1':'q[1]'}
}
</code></pre>
<p>To see how the <code>run_game</code> method is used, see <a href=""https://qiskit.org/textbook/ch-ex/hello-qiskit.html"" rel=""nofollow noreferrer"">Hello Qiskit Game</a>.</p>
",03/08/2022 16:36,Errors ,"The question is about an error encountered while trying to import a module named hello_qiskit in a quantum programming context, which falls under the Errors category",Tooling,"The question is related to issues with installing and using a specific module or tool in the context of the Qiskit course, specifically the ""hello_qiskit"" module, which is a tool used for the course exercises.",No,121.0,Tooling,"The user is facing issues with installing and using a specific module, 'hello_qiskit', required for the Qiskit course exercises. This falls under the category of tooling, involving the installation and usage of software or libraries for quantum programming."
24391.0,Is there any reasonably efficient way of performing qudit circuit simulations using Stim?,"<p>Is there any reasonably efficient way of performing qudit circuit simulations using Stim? If so, then how much worse would the computational complexity scale?</p>
",<programming><error-correction><stim>,03/06/2022 12:21,24451.0,24451.0,"<p>Stim only speaks qubits, not qudits. All of the supported gates are qubit gates, and all of the internal data structures are for specifically the qubit case.</p>
<p>There are no plans to add native support for qudits to stim.</p>
<p>(So if it's possible it will take the form of mapping qudit stabilizer circuits into qubit stabilizer circuits.)</p>
",03/09/2022 15:35,Theoretical ,"The question is about a theoretical concept in quantum computing, specifically related to the computational complexity of performing qudit circuit simulations using Stim. This involves understanding the principles and algorithms in quantum computing, which falls under the Theoretical category.",Theoretical,,,,Theoretical ,
24396.0,Implementing Noise in Pennylane (using qiskit.aer),"<p>I want to implement noise in Pennylane using qiskit as a plug-in. I found <a href=""https://pennylane.ai/blog/2021/05/how-to-simulate-noise-with-pennylane/"" rel=""nofollow noreferrer"">this</a> tutorial from Pennylane. But, when testing it the bit-flip error seems to have no effect at all.</p>
<p>Here, I made some slight modifications: I take the expectation value of PauliX and can choose 0 or 1 is an initial state.</p>
<pre><code>import qiskit.providers.aer.noise as noise

# create a bit flip error with probability p 
p = 0.9
my_bitflip = noise.pauli_error([('X', p), ('I', 1 - p)])

# create an empty noise model
my_noise_model = noise.NoiseModel()
# attach the error to the hadamard gate 'h'
my_noise_model.add_quantum_error(my_bitflip, ['h'], [0])

dev4 = qml.device('qiskit.aer', wires=1, noise_model = my_noise_model)

@qml.qnode(dev4)
def bitflip_circuit_aer():
    qml.BasisState(np.array([1]),wires=[0])
    qml.Hadamard(0)
    return qml.expval(qml.PauliX(0))

print(bitflip_circuit_aer()) 
</code></pre>
<p>It does not make any difference whether I choose p=0.0 or p=0.9. I always get +1 for initial state 0 and -1 for initial state 1, as if there was no noise at all.</p>
<p>The tutorial is from May 2021. Did something decisive change since then?</p>
",<programming><noise><pennylane>,03/06/2022 13:37,24397.0,24397.0,"<p>If you are starting with <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>Than after <span class=""math-container"">$H$</span> you are in <span class=""math-container"">$|+\rangle=|0\rangle+|1\rangle$</span> state, which is eigenstate of <span class=""math-container"">$X$</span>, with eigenvalue <span class=""math-container"">$+1$</span>.</p>
<p>If <span class=""math-container"">$X$</span> will happen (in case of an error in probability <span class=""math-container"">$p$</span>), the state will not change at all, and no error will happen:</p>
<p><span class=""math-container"">$$X|+\rangle=X|0\rangle+X|1\rangle=|+\rangle$$</span></p>
<p>So the error of <span class=""math-container"">$X$</span> and no error is the same thing, and measuring in <span class=""math-container"">$X$</span> base, will always give you the same measurement value since <span class=""math-container"">$|+\rangle$</span> is eigenstate of <span class=""math-container"">$X$</span>.</p>
<p>The same thing is happening with <span class=""math-container"">$|1\rangle$</span> initial state. Try the math, I can write it too if you like. The only different thing will be a global phase of minus in case of <span class=""math-container"">$X$</span> error, which is not affecting the measurement result.</p>
",03/06/2022 13:43,Errors,The user is trying to implement a feature in Pennylane using Qiskit but is encountering an issue where the bit-flip error seems to have no effect. This falls under the Errors category,Errors,,,,Errors,
24428.0,Qiskit best programming practices - how to speed up qiskit code?,"<p>I am currently doing some experiments using Variational Quantum Eigensolver in molecular dynamics using qiskit, and noticed that the time for execution on real backend is significantly higher than the simulated backend.</p>
<p>I am aware that this is normal, due to the overhead of quantum execution (i.e., resetting the qubits, transforming the circuit into waveforms and so on), and that for the type of instances I am using I cannot expect a speedup.</p>
<p>However, I would like to know if there are some &quot;best practices&quot; to take into account when executing my code on real backends. More precisely, I would like to know: is there a way that allows me to speed up the code, by knowing some architectural details (i.e., the topology and the type of qubits) or ways to prepare my input? Are there operators that are faster than others? Any idea about where I could find this information?</p>
<p>Any suggestion on the topic would be much appreciated.
Thanks for your attention!</p>
<p>Best Regards,</p>
",<qiskit><programming><vqe><speedup><qiskit-runtime>,03/08/2022 09:14,24433.0,24433.0,"<p>In order to speed up the <strong>response</strong> time of real IBM chips you have several options.</p>
<p>First, you can try to reduce the <strong>queue</strong> time by choosing to execute your algorithm on a chip that is not busy, i.e. with a low number of jobs in the queue. This is only a heuristic because other people with a higher priority might submit jobs while you are in the queue and increase your queue time.
In order to pick the backend with the smallest queue:</p>
<pre><code>from qiskit import IBMQ
from qiskit.providers.ibmq import least_busy

IBMQ.load_account()
provider = None  # Replace with your provider
device = least_busy(
    provider.backends(
        filters=lambda x: x.configuration().n_qubits &gt;= 3  # More than 3 qubits
        and not x.configuration().simulator                # Not a simulator
        and x.status().operational == True                 # Operational backend
    )
)
</code></pre>
<p>The issue with queue time optimisation is that we do not know how IBM is computing the priority for each submissions, so it is hard to optimise.</p>
<p>As mentioned in <a href=""https://quantumcomputing.stackexchange.com/a/24429/1386"">another answer</a>, <code>Qiskit Runtime</code> will drastically reduce the overall effect of queue time on your variational algorithm execution time (you do the queue only once instead of potentially hundreds of times).</p>
<p>Now about the actual circuit execution time, you have a lot of levers to improve that.</p>
<p>First, if the backend you are using supports dynamic repetition rate, you can easily have huge gains on a the execution time. An example I performed a few days ago validates this:</p>
<ul>
<li><p>I performed a given experiment using the default <code>rep_delay</code> that was 250Âµs:</p>
<pre><code>backend.configuration().default_rep_delay == 0.00025  # Equality test on float is bad
</code></pre>
</li>
<li><p>I performed the exact same experiment, but this time with <code>rep_delay = 0.00001</code> i.e. 10Âµs.</p>
</li>
</ul>
<p>The experiment with <code>rep_delay == 0.00001</code> executed 5 times faster.</p>
<p>The images below show the differences in execution time:</p>
<p><a href=""https://i.stack.imgur.com/mhl2u.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mhl2u.png"" alt=""default rep_delay to 250Âµs"" /></a>
<a href=""https://i.stack.imgur.com/wx2fJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wx2fJ.png"" alt=""rep_delay adapted to 10Âµs"" /></a></p>
<p>To test if your backend supports dynamic <code>rep_delay</code> have a look at the value of <code>backend.configuration().dynamic_reprate_enabled</code>.
If this is <code>True</code>, you can change the <code>rep_delay</code> when executing your circuits:</p>
<pre><code>backend.run(circuits, rep_delay=0.00001)
execute(circuits, backend, rep_delay=0.00001)
</code></pre>
<p>A few remarks:</p>
<ul>
<li>The <code>rep_delay</code> can theoretically be arbitrarily close to 0, but all your circuits should be executable in the <code>rep_delay</code> time frame, measurements included.</li>
<li>If your <code>rep_delay</code> is too short, you might encounter errors from the backend. If so, I recall that the advice was to increase <code>rep_delay</code>.</li>
<li>In theory, a smaller <code>rep_delay</code> leaves less time to the qubits to come back to their ground state, so you might experience higher SPAM errors when reducing the <code>rep_delay</code>. I am not aware of any study on these points though.</li>
</ul>
",03/08/2022 15:31,Tooling,"The user is asking for specific advice on how to use the Qiskit library to execute variational quantum eigensolver on real quantum computers. This is a question about how to use a specific tool, so it falls under the category of Tooling.",Tooling,,,,Tooling,
24447.0,What does PhISwap gate mean in Cirq?,"<p>I am currently using the Cirq pakage and when drawing the circuit structure, I constantly encountered the <code>PhISwap</code> gate, like in <a href=""https://quantumai.google/openfermion/tutorials/circuits_3_arbitrary_basis_trotter"" rel=""nofollow noreferrer"">here</a>. What does this gate mean?</p>
",<programming><cirq><openfermion>,03/09/2022 13:07,24450.0,24450.0,"<p>In Cirq, the <code>PhasedISwapPowGate</code> (i.e. <code>PhISwap</code>) is a fractional ISWAP conjugated by Z rotations. With phase exponent <span class=""math-container"">$p$</span> and exponent <span class=""math-container"">$t$</span>, it is equivalent to the composition
<span class=""math-container"">$$(\text{Z}^{-p} \otimes \text{Z}^p) \text{ISWAP}^t (\text{Z}^p \otimes \text{Z}^{-p})$$</span>
and is given by the matrix:
<span class=""math-container"">$$
\left(\begin{array}{cccc} 
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; c &amp; i\cdot s\cdot f &amp; 0 \\
0 &amp; i\cdot s \cdot f^* &amp; c &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right)
$$</span>
where:
<span class=""math-container"">$$c = \cos(\pi \cdot t/2)$$</span>
<span class=""math-container"">$$s = \sin(\pi \cdot t/2)$$</span>
<span class=""math-container"">$$f = \exp(2\pi i \cdot p)$$</span>
and star indicates complex conjugate.</p>
<p>The <code>PhasedISwapPowGate</code> is initialized with the following parameters:</p>
<pre><code>phase_exponent: Union[float, sympy.Symbol] = 0.25
exponent: Union[float, sympy.Symbol] = 1.0
</code></pre>
<p>In the circuit diagram, these parameters relate to the string gate representation as:</p>
<pre><code>0: âââPhISwap(phase_exponent)ââââââââââââ
      â
1: âââPhISwap(phase_exponent)^exponentâââ
</code></pre>
<p>These parameters relate to the matrix representation as:</p>
<pre><code>c = np.cos(np.pi * exponent / 2)
s = np.sin(np.pi * exponent / 2)
f = np.exp(2j * np.pi * phase_exponent)
</code></pre>
<p>Source: <a href=""https://github.com/quantumlib/Cirq/blob/48397d66835668c203b121e0935d88a5708502c6/cirq-core/cirq/ops/phased_iswap_gate.py"" rel=""nofollow noreferrer"">phase_iswap_gate.py</a></p>
",03/09/2022 15:31,Theoretical,"The question pertains to understanding the meaning and significance of the ""PhISwap"" gate in the context of quantum circuits. The user is seeking information about the theoretical concept behind this gate, making it fall under the ""Theoretical"" category.",Theoretical,,,,Theoretical,
24467.0,Implementation of .run() methods in google Cirq,"<p>I am developing a sampling algorithm using Fourier analysis of Boolean functions for which I use Google's Cirq to obtain the state vector with .simulate().</p>
<p>I wanted to know what sampling algorithm Google Cirq implements with .sample() so that I can have a better idea of how to benchmark it against my algorithm. I have been looking at the docs and source code of cirq.sim.Simulator (<a href=""https://quantumai.google/reference/python/cirq/sim/Simulator"" rel=""nofollow noreferrer"">https://quantumai.google/reference/python/cirq/sim/Simulator</a>), but I cannot find what sampling algorithm their .run() and .sample() methods use.</p>
",<programming><algorithm><cirq>,03/10/2022 10:58,24492.0,24492.0,"<p><code>cirq.Simulator()</code> uses a statevector simulation algorithm. The resulting statevector is sampled from by first squaring the amplitudes to obtain a probability vector followed by a call to  <a href=""https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.choice.html"" rel=""nofollow noreferrer"">numpy.random.Generator.choice</a> (<a href=""https://github.com/quantumlib/Cirq/blob/d967317cdb0f954e14907f69aaae70fd1f76ff6f/cirq-core/cirq/sim/state_vector.py#L219"" rel=""nofollow noreferrer"">Here's where it happens</a>) on the probability vector to generate the results.</p>
",03/11/2022 21:11,Theoretical,"The question is related to understanding the underlying algorithm used by Google's Cirq library for sampling quantum circuits with the .sample() method. The user is seeking information about the theoretical algorithm behind this sampling method, making it fall under the ""Theoretical"" category.",Theoretical,,,,Theoretical,
24472.0,How to use Cirq to transpile circuit to custom native gate set?,"<p>I am trying to use Cirq to compile arbitrary quantum circuits to custom native gate sets, e.g., to use the Cirq compiler to generate quantum circuits for different quantum computers (IBM, Rigetti, IonQ).</p>
<p>If this was possible, most likely the <code>cirq.optimizers</code> has to be used.</p>
<p>Can someone help me with this?</p>
<p>Thanks in advance!</p>
",<programming><quantum-gate><cirq>,03/10/2022 15:09,24478.0,24478.0,"<p>Cirq's <a href=""https://github.com/quantumlib/Cirq/tree/master/cirq-core/cirq/transformers/target_gatesets"" rel=""nofollow noreferrer"">target_gate_sets</a> will help. For example, a circuit can be compiled to a <code>CZ</code> gateset by calling <code>cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())</code></p>
<p><a href=""https://github.com/quantumlib/Cirq/blob/d967317cdb0f954e14907f69aaae70fd1f76ff6f/cirq-core/cirq/transformers/target_gatesets/compilation_target_gateset.py#L46"" rel=""nofollow noreferrer"">CompilationTargetGateset</a> can be used to define how to compile a circuit to any custom gateset.</p>
",03/10/2022 23:33,Tooling,"The question is asking about how to use the Cirq compiler to generate quantum circuits for different quantum computers, which is a tooling question.",Tooling,,,,Tooling,
24494.0,How to run bundled circuits with a different number of shots per circuit on QISKIT?,"<p>Say I have two basic circuits to run, call them qc1 and qc2 (as in this link: <a href=""https://www.youtube.com/watch?v=xUt4YKQEUco&amp;ab_channel=Qiskit"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=xUt4YKQEUco&amp;ab_channel=Qiskit</a>). On QISKIT I can run them in the same job, to save overhead time, and also spend less time in the queue. Is there any way I can use a different number of shots per circuit?
So for example I can run both circuits with the following code:</p>
<pre><code>qc_list=[qc1,1c2]
job=execute(qc_list,Aer.get_backend('qasm_simulator'),shots=1000)
</code></pre>
<p>However, this runs both circuits with the same number of shots. I tried  to run something like this to use a different number of shots for each circuit:</p>
<pre><code>job=execute(qc_list,Aer.get_backend('qasm_simulator'),shots=[1000,2000])
</code></pre>
<p>But this returns an error saying that shots only takes integers as its argument. Does anyone know how to pass a list of shots alongside a list of circuits?</p>
<p>If not it is not a disaster, I can simply use the maximum number of shots and throw away some results, but this feels very wasteful, so I would rather not do this</p>
",<qiskit><programming>,03/12/2022 01:13,24513.0,24513.0,"<p>It is not possible. As you can see <a href=""https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/execution"" rel=""noreferrer"">here</a>, if you send several circuits on the same job, then the job will execute by iterating over every circuit for each shot, i.e. the first shot will be done for every circuit, then the second shot, then the third, and so on.</p>
",3/14/2022 15:32,API Usage,"The question is asking about how to use the Qiskit API to execute two quantum circuits with different numbers of shots, which is a question about how to use a specific API in quantum programming.",API Usage,,,,API Usage,
24531.0,Will standard programming languages be applicable for quantum computing?,"<p>I'm new to quantum computers and computing, so it's possible my question is pointless or unnecessary ... but what about current programming languages such as Java, C++, Python in terms of quantum computer development?
Will these languages not be applicable or do we need to create new languages optimized for quantum computing?
Thanks in advance for the answer and for any materials on the above subject.</p>
",<programming><algorithm><classical-computing>,3/16/2022 12:42,24533.0,24533.0,"<p>Currently there are a few open source &quot;languages&quot; out there.</p>
<p>Just a bit of context: so in a very hand-wavy way, a programming language on your classical computer (implicitly) translates whatever code you have to a circuit with all the AND, NAND, XOR etc. gates so that your computer can then execute the desired circuit to compute whatever you want to compute.</p>
<p>Although quantum computers can also be thought of working as executing similar kinds of circuits, they have fundamentally different gates and units of information (i.e. qubits instead of bits). And so basically the way we program quantum computers today is by designing quantum circuits manually at a very low-level. This is by no means how quantum computers will be programmed in the future, and the goal is eventually to get to levels of abstractions that are similar to the ones we have in classical computing today (like how we program in python or C++). But this is still an ongoing field of development, which has to go hand-in-hand with the development of the hardware.</p>
<p>So currently, there are a few big open source languages that are packages in python: <a href=""https://qiskit.org/textbook/preface.html"" rel=""nofollow noreferrer"">qiskit</a> (from IBM), <a href=""https://quantumai.google/cirq/tutorials/educators/intro"" rel=""nofollow noreferrer"">cirq</a> (from Google) and <a href=""https://github.com/aws/amazon-braket-examples"" rel=""nofollow noreferrer"">braket</a> (from AWS). Another big language is <a href=""https://docs.microsoft.com/en-us/azure/quantum/overview-what-is-qsharp-and-qdk"" rel=""nofollow noreferrer"">Q#</a> (from Microsoft) that is built upon C#. There are some other ones out there too. But essentially they let you create these circuits manually and send them to quantum computers.</p>
",3/16/2022 13:55, Conceptual,"The question is conceptual in nature and inquires about the applicability of current programming languages such as Java, C++, and Python in the context of quantum computing. It also raises the question of whether new languages optimized for quantum computing are needed.",Conceptual,,,, Conceptual,
24535.0,Is it possible to create a controlled initialize instruction in Qiskit?,"<p>I know it's possible to create custom controlled gates from a circuit, for example,</p>
<pre><code>qc_gate = QuantumCircuit(2)
qc_gate.x(0)
qc_gate.x(1)

gate = qc_gate.to_gate().control(2)
</code></pre>
<p>However, since initialization is not considered a gate operation, one cannot do</p>
<pre><code>qc_gate = QuantumCircuit(2)
qc_gate.initialize[a,b]

gate = qc_gate.to_gate().control(2)
</code></pre>
<p>but instead, one can do</p>
<pre><code>qc_gate = QuantumCircuit(2)
qc_gate.initialize[a,b]

gate = qc_gate.to_instruction()
</code></pre>
<p>This, however, does not allow for control qubits. Is there any way to get around this, to create a quantum instruction that is applied in terms of a set of control qubits?</p>
",<qiskit><programming><quantum-gate>,3/16/2022 14:02,24539.0,24539.0,"<p>You can use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.isometry.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.isometry</code></a> instead of <code>QuantumCircuit.initialize</code> for state preparation.
Like <code>Initialize</code>, <code>Isometry</code> is not a gate so you can't call <code>control()</code> method. But it doesn't use resets internally. So you can use it as follows:</p>
<pre><code>state = [0.5, 0.5, 0.5, 0.5]

qc_iso = QuantumCircuit(2)
qc_iso.isometry(state, [0, 1], [])
controlled_gate = UnitaryGate(Operator(qc_iso)).control()
</code></pre>
<hr />
<p><strong>Update</strong></p>
<p>Qiskit 0.35 introduced a new class <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.StatePreparation.html"" rel=""nofollow noreferrer""><code>StatePreparation</code></a>. This class allows us to prepare a state in the same fashion as <code>Initialize</code> without the reset being automatically applied. So, creating a controlled initialization is now as simple as:</p>
<pre><code>controlled_gate = StatePreparation(state).control()
</code></pre>
",3/16/2022 16:29,Tooling,"The question pertains to the technical aspect of creating custom controlled gates or instructions in quantum circuits using Qiskit. It involves understanding the tooling and capabilities of Qiskit for custom gate operations, making it fall under the ""Tooling"" category.",Tooling,,,,Tooling,
25560.0,Efficient Representation of Qubits on a Digital Simulator,"<p>I was wondering about quantum simulators recently, and I was thinking about how a qubit could be represented on a digital machine. This <a href=""https://stackoverflow.com/questions/4595156/software-simulation-of-a-quantum-computer"">Stack Overflow post</a> seems to say that one will need at least <span class=""math-container"">$a2^n$</span> bits to represent a qubit (albeit partially), where <span class=""math-container"">$n$</span> is the number of qubits represented, and <span class=""math-container"">$a$</span> is the bit size of the complex number used. This has to do with the matrix representation of a qubit. However, I was thinking of a more efficient way of representing a qubit as a point on a Bloch Sphere. This way, a qubit object would only need to store two units of information. For example, in C, this would look like:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define QUBIT_PI (1 &lt;&lt; sizeof(short) * 8 - 1)

typedef struct QUBIT_STRUCT
{
    unsigned short theta;
    unsigned short phi;
} qubit_t;

qubit_t *qubit_from_angles(double theta, double phi)
{
    qubit_t *ret = malloc(sizeof(struct QUBIT_STRUCT));
    qubit_t-&gt;theta = theta / M_PI * QUBIT_PI;
    qubit_t-&gt;phi = phi / M_PI * QUBIT_PI;

    return ret;
}
</code></pre>
<p>and a quantum gate would be like:</p>
<pre><code>qubit_t *qubit_X(qubit_t *qubit)
{
    qubit-&gt;theta = QUBIT_PI - qubit-&gt;theta;
    qubit-&gt;phi = -qubit-&gt;phi;

    return qubit;
}
</code></pre>
<p>Is there anything wrong with storing qubit representations in this manner? Are there any quantum simulators that store qubits like this?</p>
",<programming><simulation><bloch-sphere>,3/18/2022 3:33,25562.0,25562.0,"<p>Be careful to differentiate a qubit from a quantum system. As seen <a href=""https://quantumcomputing.stackexchange.com/a/10122/10454"">here</a>, a qubit can be written as:
<span class=""math-container"">$$|\psi\rangle=\cos\left(\frac{\theta}{2}\right)\begin{pmatrix}1\\0\end{pmatrix}+\mathrm{e}^{\mathrm{i}\varphi}\sin\left(\frac{\theta}{2}\right)\begin{pmatrix}0\\1\end{pmatrix}$$</span>
As such, two real numbers seems to be enough to represent a single qubit.</p>
<h3>But this doesn't feel right.</h3>
<p>What about the following qubit?
<span class=""math-container"">$$|\chi\rangle=\frac{\mathrm{i}}{\sqrt{2}}\begin{pmatrix}1\\0\end{pmatrix}+\frac{\mathrm{i}}{\sqrt{2}}\begin{pmatrix}0\\1\end{pmatrix}$$</span>
As an unitary vector of <span class=""math-container"">$\mathbb{C}^2$</span>, it is a perfectly valid qubit, but still can't be represented using the previous representation. However, we can write it as:
<span class=""math-container"">$$|\chi\rangle=\mathrm{i}\left(\cos\left(\frac{\pi}{4}\right)\begin{pmatrix}1\\0\end{pmatrix}+\sin\left(\frac{\pi}{4}\right)\begin{pmatrix}0\\1\end{pmatrix}\right)$$</span>
The <span class=""math-container"">$\mathrm{i}$</span> factor is <strong>a global phase</strong>, and can be safely removed. Two states equal up to a global phase behaves the exact same way, no matter what your experiment is. Also, if you add another qubit, the global phases will multiply themselves to another global phase. All in all, it seems that <span class=""math-container"">$2n$</span> real numbers are enough to represent an <span class=""math-container"">$n$</span>-qubit system.</p>
<h3>But this doesn't feel right.</h3>
<p>If the previous fact was true, there would be no need for quantum computers at all, let's just simulate them!</p>
<p>The problem is that the previous fact is true only when you don't consider entanglement. For instance, the following <span class=""math-container"">$2$</span>-qubit system:
<span class=""math-container"">$$|\varphi\rangle=\frac{1}{\sqrt{2}}\begin{pmatrix}1\\0\\0\\1\end{pmatrix}$$</span>
As an unitary vector of <span class=""math-container"">$\mathbb{C}^{2^2}$</span>, it is a valid <span class=""math-container"">$2$</span>-qubit system. But what are the individual representations of its qubits? There are a lot of proofs that there is no way to write this system as:
<span class=""math-container"">$$|\varphi\rangle=|\alpha\rangle\otimes|\beta\rangle$$</span>
Thus, the only way to represent this system is to store its <span class=""math-container"">$2^2$</span> components<sup>1.</sup>. More generally, you have no choice but to store the <span class=""math-container"">$2^n$</span> components of a quantum system to perfectly simulate a general quantum algorithm. Each of these components being complex, this adds up to <span class=""math-container"">$a2^n$</span> bytes, where <span class=""math-container"">$a$</span> is the number of bytes needed to represent a complex number (though a small optimization may be applied using the normalization constraint).</p>
<p>The same fact applies to quantum gates: you have no choice but to store the <span class=""math-container"">$4^n$</span> complex components that defines it (though a small optimization may be performed using the unitary constraint).</p>
<h3>Conclusion</h3>
<p>All in all, it is possible to represent qubits the way you've described it. As long as you work with single-qubit state, your approach is valid. In fact, as long as your system is <strong>separable</strong> (that is, it can be written as a tensor product of <span class=""math-container"">$n$</span>-qubits, i.e. there's no entanglement), your approach would work.</p>
<p>But there is no quantum algorithm that provides a speedup that doesn't use entanglement. As such, your only choice is to store all of the complex components of your system.</p>
<hr />
<p><sub>1. It may be possible that this fact is not true, since I think it is possible to efficiently represent and compute with gates from the Clifford group only, which is the case of this state. Point is, a <em>general</em> quantum state must be represented with  its <span class=""math-container"">$2^n$</span> components.</sub></p>
",3/18/2022 9:54,Theoretical ,The user is proposing a theoretical approach to represent qubits more efficiently in a quantum simulator by using points on a Bloch Sphere. This falls under the Theoretical category ,Theoretical ,,,,Theoretical ,
25575.0,Result and IQArray could not be found,"<p>I am following <a href=""https://docs.microsoft.com/en-us/azure/quantum/user-guide/host-programs?tabs=tabid-csharp"" rel=""nofollow noreferrer"">this</a> MS tutorial to add functionality to my Q#/C#host project.</p>
<p>However, I get two errors on my operations:</p>
<pre><code>The type or namespace name 'Result' could not be found (are you missing a using directive or an assembly reference?) [host]csharp(CS0246)

The type or namespace name 'IQArray&lt;&gt;' could not be found (are you missing a using directive or an assembly reference?) [host]csharp(CS0246)
</code></pre>
<p>What am I missing or doing wrong?</p>
<p><a href=""https://i.stack.imgur.com/hyWCp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hyWCp.png"" alt=""enter image description here"" /></a></p>
",<programming><q#>,3/19/2022 14:26,25594.0,25594.0,"<p>I think these two types come from <code>Microsoft.Quantum.Simulation.Core</code> namespace, so if you add <code>using Microsoft.Quantum.Simulation.Core;</code> to the directives in the C# code, it should work.</p>
",3/20/2022 20:21,Tooling,"The question is asking about how to fix two errors related to missing types and namespaces in a Q#/C# host project, which is a tooling question",Tooling,,,,Tooling,
25576.0,Would the interest in building quantum computers decrease if a classical algorithm for factoring all integers in polynomial time is discovered?,"<p>Quoting <a href=""https://en.wikipedia.org/wiki/Integer_factorization#:%7E:text=Difficulty%20and%20complexity%5Bedit,number%20n%20in%20time%3A"" rel=""nofollow noreferrer"">Wikipedia</a>:</p>
<blockquote>
<p>No algorithm has been published that can factor all integers in polynomial time, that is, that can factor a <span class=""math-container"">$b$</span>-bit number <span class=""math-container"">$n$</span> in time <span class=""math-container"">$O(b^k)$</span> for some constant <span class=""math-container"">$k$</span>. Neither the existence nor non-existence of such algorithms has been proved, but it is generally suspected that they do not exist and hence that the problem is not in class P.[3][4] The problem is clearly in class NP, but it is generally suspected that it is not NP-complete, though this has not been proven.[5]</p>
<p>There are published algorithms that are faster than <span class=""math-container"">$O((1 + Îµ)^b)$</span> for all positive <span class=""math-container"">$Îµ$</span>, that is, sub-exponential. As of 2021-03-12, the algorithm with best theoretical asymptotic running time is the general number field sieve (GNFS), first published in 1993,[6] running on a <span class=""math-container"">$b$</span>-bit number <span class=""math-container"">$n$</span> in time:
[...]
For current computers, GNFS is the best published algorithm for large <span class=""math-container"">$n$</span> (more than about 400 bits). For a quantum computer, however, Peter Shor discovered an algorithm in 1994 that solves it in polynomial time.</p>
</blockquote>
<p>However, let's imagine for a moment that someday a classical algorithm for factoring all integers in polynomial time is discovered, would the interest in building quantum computer decrease?</p>
<p>Obviously, integer factorization is far from being the only application for quantum computers (I am thinking about Grover's algorithm, quantum mechanics simulations, etc), but Shor's algorithm has really turbocharged the interest in developing quantum computers.</p>
",<shors-algorithm><classical-computing><factorization>,3/19/2022 16:34,25580.0,25580.0,"<p>This depends on a few factors, excuse the pun. This is already an unlikely scenario, with several associated unlikely variants.</p>
<ol>
<li>Even if Integer Factorization is in P and said algorithm is discovered rather than existentially proved, it may still not be practical to factor for cryptographic purposes if the exponent or constants are too large. In this case, Shor's Algorithm would likely remain of interest for breaking cryptography. Integer Factorization is a form of the more general Hidden Finite Abelian Subgroup problem, known to be in BQP, which also includes the Discrete Logarithm of Diffie-Hellman fame: it is possible this theoretical classical technique may be impractical for factoring but if it could be generalized it may be applicable to other cryptographically-relevant problems in a way that is more practical, at least rendering some systems insecure if not RSA.</li>
<li>It is possible a quantum algorithm may be necessary to make a replacement cryptosystem for RSA, in which case this might actually increase interest in building quantum computers. This is a more speculative scenario: there are cryptographic protocols that require solving NP-Hard problems to crack that appear promising, though average cases may be too easy to crack even if the general problem is hard.</li>
</ol>
<p>I would suspect at the very least the stocks of companies dedicated to quantum computation would crash upon such an announcement. Quantum computation would likely remain of interest in academia, business is what is going to be hit harder. And this ignores the impact RSA being unusable would immediately have, which could have a catastrophic effect on Internet security and society in general in an imagined worst-case scenario.</p>
",3/19/2022 18:48,Theoretical," The question is asking about the impact of a hypothetical classical algorithm for integer factorization in polynomial time on the interest in building quantum computers, which is a theoretical question about the future of quantum computing.",Conceptual,"The question is discussing the implications of a hypothetical scenario on the interest in quantum computing, which falls under understanding the background and limitations of quantum programming.",No,122.0, Theoretical,"The question explores the theoretical implications of a hypothetical classical algorithm for integer factorization on the interest in building quantum computers, which involves speculation about the future of quantum computing and its relevance in light of potential advancements in classical algorithms."
25595.0,Tuning hyperparameters of QSVM,"<p>While implementing QSVM algorithm and I am facing some problems.
I followed this tutorial: <a href=""https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html</a>
While training using the breast cancer dataset, I got a 80% testing success ratio. Can I enhance this ratio by fine tuning the training parameters? and if yes what parameters to edit?
The training takes forever with the full dataset. Is there a way to speed it up while implementing full datasets.</p>
",<qiskit><programming><quantum-state><machine-learning><quantum-enhanced-machine-learning>,3/21/2022 6:31,25607.0,25607.0,"<p>Training a support vector machine (SVM) on <span class=""math-container"">$n$</span> datapoints typically involves solving a constrained minimization problem resembling one of the following:
<span class=""math-container"">\begin{align}
\min&amp; \left(\frac{1}{2}\lVert \mathbf{w}\rVert^2 + C \sum_{i=1}^n \zeta_i \tag{1}\right)\\
\min&amp; \left(\frac{\lambda}{2}\lVert \mathbf{w}\rVert^2 + \sum_{i=1}^n \zeta_i \tag{2}\right)
\end{align}</span></p>
<p>where the minimum is over various parameters that you can find in just about any treatment of the soft margin SVM problem (<a href=""https://en.wikipedia.org/wiki/Support-vector_machine"" rel=""nofollow noreferrer"">Wikipedia</a>, <a href=""https://scikit-learn.org/stable/modules/svm.html"" rel=""nofollow noreferrer"">scikit-learn</a>). The main point is that <span class=""math-container"">$\lambda$</span> is a regularization parameter that increases the penalty for having a small margin (i.e. large <span class=""math-container"">$\lVert \mathbf{w}\rVert$</span>), and that <span class=""math-container"">$C$</span> acts like <span class=""math-container"">$1/\lambda$</span> in most optimizers. By decreasing <span class=""math-container"">$\lambda$</span> (increasing <span class=""math-container"">$C$</span>) you allow for a smaller margin which allows for more overfitting but often sacrifices generalization. Conversely, increasing <span class=""math-container"">$\lambda$</span> (decreasing <span class=""math-container"">$C$</span>) enforces a wide margin, less overfitting by a &quot;complicated&quot; decision boundary, and tends to improve generalization to a test set.</p>
<p>The <code>QSVM</code> has a <code>lambda2</code> hyperparameter that you can tune to observe a tradeoff between overfitting/underfitting and typically you will settle on a good balance using cross validation to maximize expected generalization. I mention the <span class=""math-container"">$C$</span> parameter because it is the (inverse) regularization hyperparameter used by other popular libraries, e.g. <code>scikit-learn</code>.</p>
<p>Otherwise, one will typically tune the feature map being used. In SVMs with classical kernels this is typically just another hyperparameter (e.g. bandwidth for the RBF kernel), but in quantum kernels there's a whole host of properties of the data encoding to change. If you're using the <code>ZZFeatureMap</code>, you'll notice it has keyword arguments <code>reps</code>, <code>entanglement</code>, <code>data_map_func</code> - modifying any/all of these will also change the performance of the QSVM in general, but oftentimes in an unpredictable way, since there's not actually any intuitive connection between the properties of this feature map and its performance on any given dataset besides the contrived &quot;ad hoc&quot; dataset described in that tutorial.</p>
<blockquote>
<p>The training takes forever with the full dataset. Is there a way to speed it up while implementing full datasets.</p>
</blockquote>
<p>Sure, just decrease <code>training_size</code> and <code>test_size</code> when you load the data using the function <code>qiskit.ml.datasets.breast_cancer</code>. Of course you should be careful not to use too small a data sample that's no longer representative of the underlying data, or too small a test set that you can no longer effectively generalize.</p>
",3/21/2022 15:17,Tooling,"The user is seeking guidance on optimizing the performance of the QSVM (Quantum Support Vector Machine) algorithm implemented in Qiskit. They are specifically looking for ways to enhance the testing success ratio and speed up training with full datasets, which falls under the ""Tooling"" category",Tooling,,,,Tooling,
25657.0,How to caculate the inner product of two vectors with Q#,"<p>For example, if <span class=""math-container"">$a$</span> is a row vector, <span class=""math-container"">$b$</span> is a column vector, <em>how to use Q# to calculate the inner product of these two?</em> Which method or operator can be used? Just <span class=""math-container"">$a*b$</span>? Any others?
Really need your help. Thank you very much.</p>
",<programming><q#>,3/25/2022 15:43,25661.0,25661.0,"<p>Q# doesn't have data types to represent row or column vectors, so they'd be represented as just arrays.</p>
<p>You can write a straightforward for loop to iterate through the vectors and accumulate the products of elements <span class=""math-container"">$\sum_{i=0}^{n-1}a_ib_i$</span>:</p>
<pre><code>mutable prod = 0;
for i in 0 .. Length(a) - 1 {
    set prod += a[i] * b[i];
}
</code></pre>
<p>Alternatively, you can calculate their inner product using library functions:</p>
<ol>
<li>Zip the arrays a and b together so that they become an array of tuples: <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arrays.zipped"" rel=""nofollow noreferrer""><code>Zipped(a, b)</code></a>.</li>
<li>Do pairwise multiplication for each tuple in the result: <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arrays.mapped"" rel=""nofollow noreferrer""><code>Mapped(TimesI, Zipped(a, b))</code></a>.</li>
<li>Add up pairwise products: <a href=""https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.arrays.fold"" rel=""nofollow noreferrer""><code>Fold(PlusI, 0, Mapped(TimesI, Zipped(a, b)))</code></a>.</li>
</ol>
<p>With the next release you'll also be able to combine the last two steps in one using lambda expressions: <code>Fold((sum, (ai, bi)) -&gt; sum + ai * bi, 0, Zipped(a, b))</code>.</p>
",3/25/2022 20:32,API Usage,"The user is asking about how to use a specific function or operator in Q# to calculate the inner product of two vectors, which falls under the usage of APIs in quantum programming.",API Usage,,,,API Usage,
25672.0,Remove Inactive Qubits from Qiskit Circuit,"<p>Is there any way to remove unused/inactive qubits from my Qiskit circuit? For example, I have the register <span class=""math-container"">$x0\_float$</span> who has an unused qubit <span class=""math-container"">$x0\_{float}_0$</span> (see image),</p>
<p><a href=""https://i.stack.imgur.com/FAIJn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FAIJn.png"" alt=""Screenshot of Quantum Circuit"" /></a></p>
<p>For context, my code is encoding binary numbers and in my program I rely on the qubit index (the subscript beside the register name) to figure out what gates it needs to apply later on. For some binary numbers, (like bin(0.25) = .01) I only need to apply the X gate to the second qubit in the register.</p>
<p>These inactive qubits are preventing me from executing the circuit on various IBMQ backends due to resource constraints despite technically having the right number of active qubits.</p>
<p>I've already scoured the Qiskit manual for any methods to remove qubits but I have yet to come across anything useful. I was wondering if there is a work-around method that one of you have used in your own work.</p>
<p>Please let me know.</p>
",<qiskit><programming><circuit-construction><quantum-circuit>,3/26/2022 18:56,25679.0,25679.0,"<p>Here is a function to remove the idle wires. However, it has the drawback that you will lose the registers info:</p>
<pre><code>from qiskit.converters import circuit_to_dag, dag_to_circuit
from collections import OrderedDict

def remove_idle_qwires(circ):
    dag = circuit_to_dag(circ)

    idle_wires = list(dag.idle_wires())
    for w in idle_wires:
        dag._remove_idle_wire(w)
        dag.qubits.remove(w)

    dag.qregs = OrderedDict()

    return dag_to_circuit(dag)
</code></pre>
<p>Now, let's create a multi-register circuit with some idle wires and use it to check the solution:</p>
<pre><code>q = QuantumRegister(2, 'q')
a = QuantumRegister(2, 'a')
circ = QuantumCircuit(q, a)
circ.h(q[0])
circ.cx(q[0], a[0])
circ.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/8VdGb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8VdGb.png"" alt=""enter image description here"" /></a></p>
<pre><code>circ2 = remove_idle_qwires(circ)
circ2.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/LPh9i.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LPh9i.png"" alt=""enter image description here"" /></a></p>
",3/27/2022 6:28,Tooling,"The user is seeking information on how to remove unused or inactive qubits from a Qiskit circuit, which is a question related to the usage of the Qiskit tool for quantum circuit design and manipulation. This falls under the ""Tooling"" category ",Tooling,,,,Tooling,
25686.0,"Where can I find the package of ""testing"" when run the Linear Algebra exercise of QuantumKatas?","<p>I want to run the Linear Algebra tutorial exercise of QuantumKatas in vscode. But the package of &quot;testing&quot; can't be found. The package of &quot;qsharp&quot; and &quot;pytest&quot; have been installed. What others can I  do?
<a href=""https://i.stack.imgur.com/EGiBc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EGiBc.png"" alt=""enter image description here"" /></a></p>
",<q#>,3/28/2022 4:04,25695.0,25695.0,"<p>It is defined in the <a href=""https://github.com/microsoft/QuantumKatas/blob/main/tutorials/LinearAlgebra/testing.py"" rel=""nofollow noreferrer""><code>testing.py</code> file</a> in the same folder as the tutorial itself. If you clone the Quantum Katas repository as is and run the tutorial notebook from the folder <code>tutorials/LinearAlgebra</code> directly, Python should be able to find it.</p>
<p>I'm not sure what your local setup looks like, though, since I know this tutorial doesn't have a file <code>liner.py</code> :-) Did you copy the code cells from <code>LinearAlgebra.ipynb</code> into a separate Python file?</p>
",3/28/2022 17:18, Errors,"The user is encountering an error related to a missing package (""testing"") when trying to run a tutorial exercise in QuantumKatas using VSCode. They are seeking a solution to this error, making it fall under the ""Errors"" category.", Errors,,,, Errors,
25699.0,Qiskit PrimitiveOp compose function giving weird output,"<p>I am executing the following code.</p>
<pre><code>[ins] In [1]: from qiskit.opflow.primitive_ops import PrimitiveOp
     ...: from qiskit.quantum_info import Pauli
     ...: import numpy as np
     ...: x = 3.5*np.sqrt(3.0/2)
     ...: print(x)
     ...: annih_op=PrimitiveOp(Pauli('X')) + 1.0j*PrimitiveOp(Pauli('Y'))
     ...: creat_op = PrimitiveOp(Pauli('X')) - 1.0j*PrimitiveOp(Pauli('Y'))
     ...: my_op = x*creat_op.compose(annih_op, front=True)
     ...: print('type(my_op) = ', type(my_op))
     ...: print('my_op)= ', my_op)
</code></pre>
<p>It gives a warning and a very deeply nested numpy array.</p>
<pre><code>    4.286607049870561
&lt;ipython-input-1-583b34f24f0c&gt;:8: VisibleDeprecationWarning: Creating an ndarray from nested sequences exceeding the maximum number of dimensions of 32 is deprecated. If you mean to do this, you must specify 'dtype=object' when creating the ndarray.
  my_op = x*creat_op.compose(annih_op, front=True)
type(my_op) =  &lt;class 'numpy.ndarray'&gt;
my_op)=  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['I'],
                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]






























 [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['Z'],
                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]






























 [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['Z'],
                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]






























 [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['I'],
                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
</code></pre>
<p>But if I set <code>x</code> to be something else for example 2.0, I am getting the expected output and no warning.</p>
<pre><code>[nav] In [2]: from qiskit.opflow.primitive_ops import PrimitiveOp
         ...: from qiskit.quantum_info import Pauli
         ...: import numpy as np
         ...: #x = 3.5*np.sqrt(3.0/2)
         ...: x=2.0
         ...: print(x)
         ...: annih_op=PrimitiveOp(Pauli('X')) + 1.0j*PrimitiveOp(Pauli('Y'))
         ...: creat_op = PrimitiveOp(Pauli('X')) - 1.0j*PrimitiveOp(Pauli('Y'))
         ...: my_op = x*creat_op.compose(annih_op, front=True)
         ...: print('type(my_op) = ', type(my_op))
         ...: print('my_op)= ', my_op)
2.0
type(my_op) =  &lt;class 'qiskit.opflow.primitive_ops.pauli_sum_op.PauliSumOp'&gt;
my_op)=  2.0 * I
+ 2.0 * Z
+ 2.0 * Z
+ 2.0 * I
</code></pre>
<p>Is it a possible bug in Qiskit?</p>
",<qiskit><programming>,3/28/2022 23:26,25704.0,25704.0,"<p>If you checked the type of your coefficient <code>x</code>, you will find that its value is <code>numpy.float64</code>.
And if you checked how multiplication by scalar is implemented in <code>PauliSumOp</code> class <sup>[<a href=""https://qiskit.org/documentation/_modules/qiskit/opflow/primitive_ops/pauli_sum_op.html#PauliSumOp.mul"" rel=""nofollow noreferrer"">1</a>]</sup>, you will notice that only scalars of type <code>int</code>, <code>float</code>, and <code>complex</code> are supported. Otherwise, the multiplication by scalar will be handled by the primitive class (<code>SparsePauliOp</code> in our case) which inherits <code>__rmul__</code> from <code>MultiplyMixin</code><sup>[<a href=""https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/quantum_info/operators/mixins/multiply.py"" rel=""nofollow noreferrer"">2</a>]</sup>. This is where the issue happens.</p>
<p>So, to avoid the issue, just cast your coefficient,</p>
<pre><code>x = float(3.5 * np.sqrt(3.0/2))
</code></pre>
<p>Or change the order of multiplication,</p>
<pre><code>my_op = creat_op.compose(annih_op, front=True) * x
</code></pre>
",3/29/2022 6:59,Errors,"The user is encountering a warning and unexpected output when performing operations with Qiskit, specifically when setting the value of the variable x. They suspect a possible bug in Qiskit and are seeking assistance with this error, making it fall under the ""Errors"" category.", Errors,,,,Errors,
25711.0,Second quantized $S^2$ operator in Qiskit,"<p>Is it possible to obtain easily the second quantized <span class=""math-container"">$S^2$</span> operator in Qiskit, preferably from <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.html"" rel=""nofollow noreferrer"">ElectronicStructureProblem</a>?</p>
<p>I'm obtaining Hamiltonian via <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html#qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops"" rel=""nofollow noreferrer"">second_q_ops()</a> method, accessing property <code>ElectronicEnergy</code>. Is something similar possible to obtain <span class=""math-container"">$S^2$</span>?</p>
<p>I know, that this functionality is easily accessible in <a href=""https://quantumai.google/openfermion"" rel=""nofollow noreferrer"">OpenFermion</a> via <a href=""https://quantumai.google/reference/python/openfermion/hamiltonians/s_squared_operator"" rel=""nofollow noreferrer"">s_squared_operator</a> property.</p>
",<qiskit><programming>,3/30/2022 13:43,25713.0,25713.0,"<p>Yes. In Nature there is the angular momentum operator which is S-squared (built via the <code>AngularMomentum</code> property class). The <code>second_q_ops()</code> link above refers to this as one of the operators which is available in the return.</p>
",3/30/2022 16:06,Conceptual,"The user is inquiring about the possibility of obtaining the second quantized S2 operator in Qiskit, specifically from the ElectronicStructureProblem class. This involves understanding the concept of second quantization in the context of electronic structure problems, making it fall under the ""Conceptual"" category.",Conceptual,,,,Conceptual,
25734.0,How can I visualize a stim circuit?,"<p>Is there any function I can call to visualize a stim circuit?</p>
",<programming><stim>,04/01/2022 03:52,25736.0,25736.0,"<p>Since v1.10, you can use <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.Circuit.diagram"" rel=""nofollow noreferrer""><code>stim.Circuit.diagram</code></a> to visualize the circuit.</p>
<pre><code>import stim

circuit = stim.Circuit(&quot;&quot;&quot;
    QUBIT_COORDS(0, 0) 0
    QUBIT_COORDS(0, 1) 1
    QUBIT_COORDS(1, 0) 2
    QUBIT_COORDS(1, 1) 3
    R 0 1 2 3
    H 0 2
    CNOT 0 1
    CNOT 2 3
    M 0 1 2 3
&quot;&quot;&quot;)

print(circuit.diagram())
</code></pre>
<blockquote>
<pre><code>q0: -QUBIT_COORDS(0,0)-R-H-@-M:rec[0]-
                           |
q1: -QUBIT_COORDS(0,1)-R---X-M:rec[1]-

q2: -QUBIT_COORDS(1,0)-R-H-@-M:rec[2]-
                           |
q3: -QUBIT_COORDS(1,1)-R---X-M:rec[3]-
</code></pre>
</blockquote>
<p>You can also get an SVG image of the timeline:</p>
<pre><code>circuit.to_diagram(type=&quot;timeline-svg&quot;)
</code></pre>
<p>In Jupyter notebooks this SVG will display inline. Otherwise you have to print it to a .svg file then open it.</p>
<blockquote>
<p><a href=""https://i.stack.imgur.com/pHYjf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pHYjf.png"" alt=""enter image description here"" /></a></p>
</blockquote>
<p>or a 3d model, optionally embedded into a viewer that can be opened in a web browser:</p>
<pre><code># for this one you really want to have specified qubit coords
circuit.to_diagram(type=&quot;timeline-3d-html&quot;)
</code></pre>
<blockquote>
<p><a href=""https://i.stack.imgur.com/Tx805.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Tx805.png"" alt=""enter image description here"" /></a></p>
</blockquote>
<p>In Jupyter notebooks this viewer will display inline in the cell output. Otherwise you have to print it to a .html file then open it.</p>
<p>The diagram types that are currently available are:</p>
<pre><code>    timeline-text
    timeline-svg
    timeline-3d
    timeline-3d-html
    match-graph-svg
    match-graph-3d
    match-graph-3d-html
    detector-slice-text
    detector-slice-svg
</code></pre>
<p>You can also use the <code>stimcirq</code> package to convert into a cirq circuit and get diagrams that way (e.g. with the <code>cirq_web</code> package).</p>
",04/01/2022 05:43,Tooling,"The user is inquiring about a specific function or tool in the STIM library that allows for visualizing a circuit, making it a tooling-related question.",Tooling,,,,Tooling,
25745.0,Qiskit: bind parameters to sub-circuit,"<p>I am trying to implement a Hadamard test on a parametrized sub-circuit <span class=""math-container"">$V(\bf{a})$</span>. I create an outer circuit and then append the parametrized <span class=""math-container"">$V(\bf{a})$</span> to it.</p>
<pre><code>def outer_circuit(subcircuit, imaginary=False):

    qc = QuantumCircuit(4, 1)
    qc.append(subcircuit, qc.qubits)
    [...] # operations 
    
    return qc


def subcircuit():
    
    a = ParameterVector('a', 9)
    m, n = Parameter('m'), Parameter('n')
    qc = QuantumCircuit(4, name='V')

    [...] # random operations which use parameters

    return qc
</code></pre>
<p>When I finally contruct the bigger circuit and try to bind the
parameters, I get the following error:</p>
<pre><code>
operator = subcircuit()

test = outer_circuit(operator)

test.bind_parameters({'a': np.random.rand(9)})

&gt;&gt;
CircuitError: 'Cannot bind parameters (a) not present in the circuit.'

</code></pre>
<p><strong>How do I get overcome this problem?</strong></p>
",<qiskit><programming><hadamard>,04/01/2022 10:28,25746.0,25746.0,"<p>When you append a sub-circuit to a larger circuit, the sub-circuit parameters are added to list of circuit parameters.
You can easily check this as follows:</p>
<pre><code>operator = subcircuit()
print(operator.parameters)

test = outer_circuit(operator)
print(test.parameters)
</code></pre>
<p>So, you can bind them as any parameters in the larger circuit.</p>
<p>The issue is that the keys of the <em>parameter dictionary</em> must be the <code>Parameter</code> instances not the <code>Parameter</code> names<sup><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.assign_parameters.html"" rel=""nofollow noreferrer"">[see here]</a></sup>. So, you need to call <code>bind_parameters</code> as follows:</p>
<pre><code>test.bind_parameters({a: np.random.rand(9)})
</code></pre>
<p>Of course to do this the variable <code>a</code> needs to be in the scope when you call <code>bind_parameters</code>. The fastest way to do this in your case - although not recommended - is to make it global:</p>
<pre><code>def subcircuit():
    global a
    a = ParameterVector('a', 9)
    [...]
</code></pre>
",04/01/2022 11:30, Errors,"The user is facing an error related to parameter binding in their quantum circuit code. They are seeking a solution to overcome this problem, which falls under the ""Errors"" category.", Errors,,,, Errors,
25928.0,Qiskit histogram to Seaborn,"<p>I am running certain circuits in the Aer simulators and I need to present them nicely. I prefer to use the options provided by Seaborn. How can I transfer my Aer data, e.g. histograms, to Seaborn?</p>
<p>For example, running the simple circuit:</p>
<pre><code>meas = QuantumCircuit(3, 3)
meas.barrier(range(3))
 
meas.measure(range(3), range(3))


circ.add_register(meas.cregs[0])
qc = circ.compose(meas)

qc.draw()
</code></pre>
<p>and using Aer</p>
<pre><code>backend_sim = Aer.get_backend('qasm_simulator')
job_sim = backend_sim.run(transpile(qc, backend_sim), shots=1024)
result_sim = job_sim.result()
counts = result_sim.get_counts(qc)
from qiskit.visualization import plot_histogram
plot_histogram(counts)
</code></pre>
<p>yields:</p>
<p><a href=""https://i.stack.imgur.com/jDc2q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jDc2q.png"" alt=""enter image description here"" /></a></p>
<p>However, I prefer to use the stylistic options of <a href=""https://seaborn.pydata.org/"" rel=""nofollow noreferrer"">Seaborn</a> instead in order to make nice plots.</p>
",<qiskit><programming>,04/12/2022 09:42,25930.0,25930.0,"<p>The <code>counts</code> variable in your code example is just a dictionary with bit strings for keys and the count of times that bit string was returned from the execution of the circuit. Something like: <code>{&quot;000&quot;: 513, &quot;111&quot;: 467}</code>. If you want to make your own plot with seaborn you can just access the data from the <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Counts.html?highlight=counts#qiskit.result.Counts"" rel=""nofollow noreferrer""><code>Counts</code></a> object directly. For example, something like:</p>
<pre><code>import matplotlib.pyplot as plt
import seaborn

counts = {&quot;000&quot;: 513, &quot;111&quot;: 467}
seaborn.barplot(list(counts.keys()), list(counts.values()))
</code></pre>
<p>yields:</p>
<p><a href=""https://i.stack.imgur.com/IqfjM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IqfjM.png"" alt=""seaborn bar chart"" /></a></p>
<p>That being said <code>plot_histogram</code> function does have some style arguments including for color: <a href=""https://qiskit.org/documentation/stubs/qiskit.visualization.plot_histogram.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.visualization.plot_histogram.html</a> that may enable you to get the output visualization you want from the function.</p>
",04/12/2022 12:05,Tooling,"The user is asking about how to transfer data generated by Qiskit's Aer simulator, specifically histograms, to Seaborn for visualization. This is a question related to using specific tools and libraries for data visualization, making it fall under the ""Tooling"" category.",Tooling,,,,Tooling,
25948.0,Whatâs the proper gate use for the following code? (Python),"<p>I am trying to find a proper way to write a code that will give me the resulting quantum state <span class=""math-container"">$i|10\rangle$</span> using qiskit in Python (using Jupiter notebook). I think I have figured out that the following works:</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from math import pi

qc = QuantumCircuit(2,2)

qc.x(1)
qc.crz(3*pi,1,0)
</code></pre>
<p>which (if I choose to print the state vector) gives me this result:</p>
<pre><code>job = execute(qc, Aer.get_backend(âstatevector_simulatorâ),optimization_level=0)
current_quantum_state = job.result().get_statevector(qc)
print(current_quantum_state)
âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
Statevector([0.00000000e+00+0.j, 0.00000000e+00+0.j, -2.22044605e-16+1.j,
             0.00000000e+00-0.j],
            dims=(2,2))
</code></pre>
<p>Using an X gate first and then a CRZ gate I get the result I want, but I was told that we can get this through just one line (therefore one gate?) and not the last two lines I provided. I looked everywhere through my notes and the Qiskit manual online, but I canât seem to find something that works and I was wondering if someone could direct me to the faster approach to this.</p>
",<programming><quantum-gate>,4/13/2022 15:21,25949.0,25949.0,"<p>Note that <span class=""math-container"">$Y|0\rangle = i|1\rangle$</span> and so the circuit you are looking for is</p>
<p><a href=""https://i.stack.imgur.com/R1Ks9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/R1Ks9.png"" alt=""enter image description here"" /></a></p>
",4/13/2022 15:50,API Usage,The question is asking about how to use the Qiskit API to create a quantum circuit that generates a specific quantum state in a concise way. This is an API usage question.,API Usage,,,,API Usage,
26048.0,Why Qiskit doesn't invert hard coded unitary matrix?,"<p>I was expecting Qiskit to do a upside down version of my unitary as it does for other unitary matrices of CNOT and Toffoli gates given in textbooks : if you convert a toffoli matrix from quantum computing textbooks(target 3rd and ctrl 1st,2nd) you will get an inverted version of it (target as q0 and ctrl as q1,q2).<br />
So I hardcoded a unitary matrix and converted to gate then appended to qc. But the operator returns exactly the same matrix, so I wonder if my unitary is actually upside down but operator just shows flipped output ?</p>
<p>Hard coded matrix :
<a href=""https://i.stack.imgur.com/HBJts.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HBJts.png"" alt=""Hard coded matrix"" /></a>
Operator output :
<a href=""https://i.stack.imgur.com/Rh0hV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rh0hV.png"" alt=""Operator Output"" /></a></p>
<p>Code :</p>
<pre><code>u = QuantumCircuit(qr)
u.unitary(UA, range(qr), label='U')
unitary = u.to_gate()
unitary.name = 'U'
</code></pre>
<p>mpl display :</p>
<pre><code>qc = QuantumCircuit(qr)
qc.append(unitary, range(0, qr))
qc.draw(&quot;mpl&quot;, style='bw')
</code></pre>
<p><a href=""https://i.stack.imgur.com/ZbSZIt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZbSZIt.png"" alt=""mpl display"" /></a></p>
",<qiskit><programming><matrix-representation>,4/19/2022 20:12,26074.0,26074.0,"<p>So I have finally have the time to check up with what I wrote in the comment, and what I commented is indeed the case.</p>
<p>If I passed in the matrix <span class=""math-container"">$U = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \end{pmatrix}$</span> then it does indeed execute the regular <span class=""math-container"">$CNOT$</span> gate <span class=""math-container"">$CNOT_{q_0, q_1}$</span>. You can try it yourself:</p>
<pre><code>from qiskit.quantum_info.operators import Operator
from qiskit import QuantumCircuit, QuantumRegister
import numpy as np
controls = QuantumRegister(2)
circuit = QuantumCircuit(controls)
U = Operator( [
    [1, 0, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0]
])
circuit.unitary(U, [0,1], label='U')
decomp = QuantumCircuit.decompose(circuit) #decompose to well known gates 


      âââââââââââââ     âââââââââââââ
q0_0: â¤ U3(0,0,0) ââââ âââ¤ U3(0,0,0) â
      âââââââââââââ¤âââ´âââââââââââââââ¤
q0_1: â¤ U3(0,0,0) ââ¤ X ââ¤ U3(0,0,0) â
      âââââââââââââââââââââââââââââââ
</code></pre>
",4/20/2022 21:01,API Usage," The user is inquiring about the behavior of Qiskit's API when it comes to converting a hardcoded unitary matrix into a gate and appending it to a quantum circuit. They are seeking clarification on whether the operator's output matches their expectations, making it an API usage question.",Errors,The user is encountering an unexpected behavior when using the Qiskit library to convert a unitary matrix to a gate and append it to a quantum circuit. This falls under the category of Errors as they are seeking help with debugging their code.,No,123.0,API Usage,The user is seeking clarification on the behavior of Qiskit's API when converting a hardcoded unitary matrix into a gate and appending it to a quantum circuit. This focuses on understanding the usage and behavior of Qiskit's functionality.
26097.0,Generating a random 16-digits in a superposition state using Qiskit,"<p>Im trying to create a script using Qiskit for a days but somehow i couldn't seem to get it done!! Im new to QuantumComputing, so pardon me if i don't explain something properly. I need to create a simple script generating perfectly a random 16-digits (e. g 1548796654421354) in a superposition state using Hadamard gate (i think it requires 128 qubits i guess) and measuring them into a classical bits and printing the results different each time. (eg output: 5698744565414654)</p>
<p>Thank you King.</p>
",<qiskit><programming><quantum-gate><quantum-state><algorithm>,4/22/2022 5:51,26101.0,26101.0,"<p>You need <span class=""math-container"">$\lceil d\log_2(10)\rceil$</span> qubits to store a <span class=""math-container"">$d$</span> decimal digits number.</p>
<p>So you can generate a superposition state of binary representation of a 16 decimal digits number using the following circuit:</p>
<pre><code>from qiskit import QuantumRegister, QuantumCircuit, Aer
import numpy as np

num_of_decimal_digits = 16
num_of_qubits = int(np.ceil(num_of_decimal_digits * np.log2(10)))
qr = QuantumRegister(num_of_qubits, 'q')
circ = QuantumCircuit(num_of_qubits)
circ.h(qr)
circ.measure_all()
</code></pre>
<p>And to get the number:</p>
<pre><code>simulator = Aer.get_backend('qasm_simulator')
result = simulator.run(circ, shots = 1).result()
counts = result.get_counts()
bitstring = next(iter(counts))
decimal = int(bitstring, 2)

print('Binary:', bitstring)
print('Decimal:', f'{decimal:016d}')
</code></pre>
<p>Note: You need all these qubits to have a superposition. If you just want to generate a random 16-digits number, you can use a single qubit and run the circuit repeatedly (by setting shots = number of bits) then append the result bits.</p>
",4/22/2022 8:15,Learning,"The user is new to quantum computing and is seeking guidance on how to create a simple script using Qiskit to generate a random 16-digit number in a superposition state and measure it into classical bits. This falls under the ""Learning"" category ",Learning ,,,,Learning,
26098.0,"When using Qiskit's plot_bloch_vector function, how can I set colors for vectors?","<p>I am able to visualize vectors on a bloch sphere using Qiskit as follows:</p>
<pre><code>from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_vector
%matplotlib inline

sv = []
sv.append([0,1,0])
sv.append([0,0,1])
sv.append([1,0,0])

fig = plot_bloch_vector(sv)
fig
</code></pre>
<p>The code above yields the following result (which looks good):</p>
<p><a href=""https://i.stack.imgur.com/2ZkQW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2ZkQW.png"" alt=""enter image description here"" /></a></p>
<p>Now I would like to adjust the colors of each vector. The API of Qiskit seems not to provide any color parameter for <code>plot_bloch_vector</code>. Maybe we can manipulate the <code>fig</code> object directly or find another way to adjust vector colors?</p>
",<qiskit><programming><bloch-sphere>,4/22/2022 6:31,26102.0,26102.0,"<p>A simple way to do that is by using <code>Bloch</code> class<sup><a href=""https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/visualization/bloch.py#L94"" rel=""nofollow noreferrer"">[1]</a></sup> directly which accepts a list of <em>vector colors</em> to cycle through:</p>
<pre><code>from qiskit.visualization.bloch import Bloch

_bloch = Bloch()
_bloch.vector_color = ['red', 'green', 'blue']

sv = []
sv.append([1,0,0])
sv.append([0,1,0])
sv.append([0,0,1])

_bloch.add_vectors(sv)
_bloch.render()
_bloch.fig
</code></pre>
<p>The result:</p>
<p><a href=""https://i.stack.imgur.com/dYMZy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dYMZy.png"" alt=""enter image description here"" /></a></p>
",4/22/2022 10:06,Tooling," The user is inquiring about how to adjust the colors of vectors on a Bloch sphere visualization created using Qiskit. This falls under the ""Tooling"" category ",Tooling,,,,Tooling,
26155.0,Is there any paper about the encoding process in the machine learning API?,"<p>I want to know more details about the encoding process in machine learning. I have read the source code about the &quot;ApproximateInputEncoder&quot; method. It seems like a complex method. So is there any paper or document to explain the mechanism in detail of the encoding process?</p>
",<q#>,4/26/2022 3:31,26156.0,26156.0,"<p>QDK machine learning library is based on the paper <a href=""https://arxiv.org/abs/1804.00633"" rel=""nofollow noreferrer"">'Circuit-centric quantum classifiers', Maria Schuld, Alex Bocharov, Krysta Svore and Nathan Wiebe</a>, I would start looking for details there. Section A &quot;State preparation&quot; mentions preparing the input states and some references for the routines that can be used.</p>
",4/26/2022 3:58,Learning ,"The user is seeking additional learning resources or documentation to understand the mechanism in detail of the encoding process used in machine learning, specifically the ""ApproximateInputEncoder"" method.",Learning ,,,,Learning ,
26233.0,Unable to import split_dataset_to_data_and_labels and map_label_to_class_name in qiskit,"<p>I was using command-:
<code>from qiskit.aqua.utils import split_dataset_to_data_and_labels, map_label_to_class_name</code>
but it was giving error-:</p>
<pre><code>ModuleNotFoundError                       Traceback (most recent call last)
Input In [1], in &lt;cell line: 8&gt;()
      6 from qiskit.circuit.library import ZZFeatureMap
      7 from qiskit_machine_learning.algorithms import QSVC
----&gt; 8 from qiskit.aqua.utils import split_dataset_to_data_and_labels, map_label_to_class_name

ModuleNotFoundError: No module named 'qiskit.aqua'
</code></pre>
<p>I checked <a href=""https://quantumcomputing.stackexchange.com/questions/6662/import-error-no-module-named-qiskit-aqua"">import error :No module named &#39;qiskit_aqua&#39;</a> but it was outdated.</p>
<p>I also checked <a href=""https://qiskit.org/documentation/stable/0.28/aqua_tutorials/Qiskit%20Algorithms%20Migration%20Guide.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.28/aqua_tutorials/Qiskit%20Algorithms%20Migration%20Guide.html</a> but did not found about it.</p>
",<qiskit><programming>,05/01/2022 11:00,26234.0,26234.0,"<p>To fix this issue, required code needs to be copied and applied in python from-: <a href=""https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py</a></p>
<p>This is based on Egretta.Thula's suggestion.</p>
",05/01/2022 12:08,Errors,The question is asking for help with an error message that they are getting when trying to import the qiskit.aqua.utils module., Errors,,,,Errors,
26239.0,split_dataset_to_data_and_labels in qiskit not working correctly,"<p>I am using source code of split_dataset_to_data_and_labels as I am unable to install qiskit-aqua because of error. But in that source code, &quot;keys&quot; is not being identified. I am using qiskit's tutorials as I am learning, and code I wrote from it, is-:</p>
<pre><code>feature_dim = 2
training_dataset_size = 20
testing_dataset_size = 10
shot = 10000
sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
                                                                    test_size=testing_dataset_size,
                                                                    gap=0.3,
                                                                    n=feature_dim,
                                                                    plot_data=True)
datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
print(class_to_label)
</code></pre>
<p>It is giving this error-:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Input In [6], in &lt;cell line: 10&gt;()
      4 shot = 10000
      5 sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
      6                                                                     test_size=testing_dataset_size,
      7                                                                     gap=0.3,
      8                                                                     n=feature_dim,
      9                                                                     plot_data=True)
---&gt; 10 datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
     11 print(class_to_label)

Input In [4], in split_dataset_to_data_and_labels(dataset, class_names)
     22 labels = []
     23 if class_names is None:
---&gt; 24     sorted_classes_name = sorted(list(dataset.keys()))
     25     class_to_label = {k: idx for idx, k in enumerate(sorted_classes_name)}
     26 else:

AttributeError: 'numpy.ndarray' object has no attribute 'keys'
</code></pre>
<p>The link to source code, I am using is <a href=""https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py</a> .
I found at <a href=""https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att"">https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att</a> that flags can be used but it also gives error.</p>
",<qiskit><programming>,05/02/2022 07:46,26246.0,26246.0,"<p>Qiskit Aqua (now deprecated) contains the function <code>ad_hoc_data</code><sup><a href=""https://qiskit.org/documentation/stable/0.19/stubs/qiskit.ml.datasets.ad_hoc_data.html"" rel=""nofollow noreferrer"">[1]</a></sup> which returns
<code>sample_total, training_input, test_input, class_labels</code>. When using it, you need to call <code>split_dataset_to_data_and_labels</code> to split the retuned dataset to data and labels.</p>
<p>On the other hand, Qiskit Machine Learning contains a new version of <code>ad_hoc_data</code><sup><a href=""https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.datasets.ad_hoc_data.html"" rel=""nofollow noreferrer"">[2]</a></sup> whcih returns <code>training_features, training_labels, test_features, test_labels</code>. There is no need to use <code>split_dataset_to_data_and_labels</code> with it.</p>
<p>It looks like you are using functions from old <code>qiskit.ml</code> with functions from new <code>qiskit_machine_learning</code>. You shouldn't.
Try to follow the new Qiskit Machine Learning tutorials (<a href=""https://qiskit.org/documentation/machine-learning/tutorials/index.html"" rel=""nofollow noreferrer"">here</a>) to avoid these errors. The new version of <code>ad_hoc_data</code> is used in <a href=""https://qiskit.org/documentation/machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">this</a> tutorial.</p>
",05/02/2022 14:46, Errors,"The user is encountering an error related to the source code they are using for the split_dataset_to_data_and_labels function. They are seeking help to resolve this error, which falls under the ""Errors"" category", Errors,,,, Errors,
26241.0,Qiskit compute mean expectation value,"<p>I want to calculate the mean expectation value of an PauliSumOp within qiskit after I executed a QAOA Circuit. My approach is the following:</p>
<pre><code># Run and get counts
job=qiskit.execute(circuit,backend=simulator,shots=shots,optimization_level=0)
result = job.result().get_counts()
# Compute average expectation value of the observable H Ising
max_count=0
value=0
for string,count in result.items():
    value+=count*sum([(~StateFn(string)@ op @ StateFn(string)).eval() for op in hamiltonian])
    max_count+=count
expectation=value/max_count
</code></pre>
<p>Is this correct? I am especially concerned if <code>StateFn(Bitstring)</code> is a valid usage of qiskit in terms of <code>StateFn(&quot;0101&quot;)</code>=<span class=""math-container"">$|0101\rangle$</span></p>
",<qiskit><programming><qaoa>,05/02/2022 10:15,26344.0,26344.0,"<p>Yes, <code>StateFn(Bitstring)</code> is a valid usage of qiskit in terms of <code>StateFn(&quot;0101&quot;)</code>=<span class=""math-container"">$\left|0101\right\rangle$</span>. As an example:</p>
<pre><code>&gt;&gt;&gt; from qiskit.opflow import Plus, StateFn
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; print(Plus.to_circuit())
     âââââ
q_0: â¤ H â
     âââââ
&gt;&gt;&gt; v_zero_one = (StateFn(&quot;0&quot;) + StateFn(&quot;1&quot;)) / np.sqrt(2)
&gt;&gt;&gt; print(v_zero_one)
DictStateFn({'0': 1.0, '1': 1.0}) * 0.7071067811865475
&gt;&gt;&gt; np.allclose(Plus.to_matrix(), v_zero_one.to_matrix())
True
</code></pre>
<p>And yes, to me, the rest of your code looks correct for <code>hamiltonian</code> of type <code>PauliSumOp</code>.</p>
",05/10/2022 15:33,Tooling,The question is asking about how to calculate the mean expectation value of a PauliSumOp within Qiskit after executing a QAOA Circuit, Conceptual," The user is inquiring about the correctness of their approach to calculating the mean expectation value of a PauliSumOp in Qiskit. This involves understanding the conceptual aspects of working with qiskit.quantum_info and StateFn, making it a conceptual question.",No,124.0,Conceptual,The user is seeking clarification on the correctness of their approach to calculating the mean expectation value of a PauliSumOp in Qiskit. This involves understanding the conceptual aspects of working with qiskit.quantum_info and StateFn.
26377.0,Iterative quantum phase estimation - real device,"<p>I'm trying to implement the iterative quantum phase estimation on a real (IBM) quantum computer. I'm using the code below. When I run this code on a simulator the results are the expected ones, but when running on a real device the results don't follow any pattern.</p>
<pre><code>import matplotlib.pyplot as plt
# QML
from pennylane import numpy as np
from qiskit import *
from qiskit.visualization import plot_histogram
from qiskit.tools.monitor import job_monitor

shots=32000

# Key with the maximum probability - maior in Portuguese
def maior(dic):
    m=list(dic)[0]
    for n in list(dic):
        if dic[n]&gt;dic[m]:
            m=n
    return m

from key import tok
from qiskit import IBMQ #2
IBMQ.save_account(tok, overwrite=True)

IBMQ.load_account()
provider =IBMQ.get_provider(hub='ibm-q-minho', group='academicprojects', project='quantalab')
backend = provider.get_backend('ibmq_toronto') #4


# ## Iterative Quantum Phase Estimation Algorithm
def get_circuit_phase(t,
        QC,
        clbits,
        qubits,
        ancilla,
        backend=None,
    ):
        mycircuit=QuantumCircuit(2)
        mycircuit.cx(0,1)
        mycircuit.rx(2*t,0)
        mycircuit.rz(2*t,1)
        mycircuit.cx(0,1)
        mycircuit.cy(0,1)
        mycircuit.ry(2*t,0)
        mycircuit.cy(0,1)
        #print(mycircuit.draw())

        # Circuit -&gt; controlled gate
        CU=mycircuit.to_gate().control(1)

        res = []
        # start with the iteration
        phase = -2 * np.pi
        factor = 0
        iterations = 3

        # generate the qubit list on which the Unitary is applied
        qargs = [ancilla]
        for q in qubits:
            qargs.append(q)

        exponent = 2 ** (iterations - 1)
        for it in range(iterations):
            # start
            QC.reset(ancilla)
            QC.h(ancilla)
            # add the inverse rotation
            inv_phase = phase * factor

            QC.p(inv_phase, ancilla)

            # add the controlled Unitary of iteration it
            
            # need to add exponential amount of matrices
            for _ in range(int(exponent)):
                QC = QC.compose(CU, qubits=qargs)
            exponent /= 2

            # add H gate
            QC.h(ancilla)
            QC.measure(ancilla, clbits[it])

            
            if backend == None:  # simulating
                backend=Aer.get_backend(&quot;qasm_simulator&quot;)


            t_qpe = transpile(QC, backend,optimization_level=3)
            job = backend.run(t_qpe, shots=shots)
            job_monitor(job)
       
            counts = job.result().get_counts(QC)

            #  mai is the key with the most probability.
            mai=maior(counts)

            # Save the bit 
            res.append(int(mai[3-it-1]))

            # if bit measured is 1
            if mai[3-it-1] == &quot;1&quot;:
                factor += 1 / 2  # add the phase factor

            factor = factor / 2  # shift each towards one weight right

        # phase has now been stored in the clbits
        # returning its binary representation

        # need to reverse as LSB is stored at the zeroth index and
        # not the last
        res = res[::-1]

        # find decimal phase
        dec = 0
        weight = 1 / 2
        for k in res:
            dec += (weight) * k
            weight /= 2

        return dec


for estado in [-1,1]:
    tau=[]
    phase=[]
    for t in range(0,30,1):
        nq = 3    # number of qubits
        m = 3    # number of classical bits
        q = QuantumRegister(nq,'q')
        c = ClassicalRegister(m,'c')
        qc = QuantumCircuit(q,c)
        qc.h(0)
        qc.initialize(params=[0, 1/np.sqrt(2),estado*1/np.sqrt(2), 0],qubits=[1,2])
        t=t/5
        tau.append(t)
        x=get_circuit_phase(t,
        QC=qc,
        clbits=[0,1,2],
        qubits=[1,2],
        ancilla=[0], backend=backend
    )   
        phase.append(x)
    if estado==-1:
        plt.plot(tau,phase,label=&quot;- state&quot;)   
    if estado==1:
        plt.plot(tau,phase,label=&quot;+ state&quot;)
plt.xlabel(&quot;<span class=""math-container"">$tau$</span>&quot;)
plt.ylabel(&quot;<span class=""math-container"">$theta$</span>&quot;)
plt.legend()
plt.show()
</code></pre>
<p>I hope anyone can help with this issue, my sincere thanks,</p>
<p>Gabriela Oliveira.</p>
",<programming><algorithm><ibm-q-experience><ibm>,5/13/2022 8:32,26426.0,26426.0,"<p>Dynamic circuit capabilities (eg., circuits with control flow) are not yet supported by production IBM hardware. These capabilities will be coming later in 2022 to select devices as per the IBM Quantum Roadmap. For now, you must use a simulator.</p>
",5/16/2022 11:55,Errors,The user is encountering issues with the results when running an iterative quantum phase estimation algorithm on a real IBM quantum computer.,Errors,,,,Errors,
26463.0,How is the ket of a quantum state calculated in this code?,"<p>For the following code</p>
<pre><code>qc = QuantumCircuit(2)
qc.h(1)
qc.cx(1,0)
ket = Statevector(qc)
ket.draw()
</code></pre>
<p>the output will be the following:</p>
<p><code>Statevector([0.70710678+0.j, 0.0+0.j, 0.0+0.j,0.70710678+0.j], dims=(2, 2))'</code></p>
<p>My question is how is this ket state vector calculated?</p>
<p>Diagram for above Quantum circuit is as follow:</p>
<p><a href=""https://i.stack.imgur.com/7tjWN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7tjWN.png"" alt=""enter image description here"" /></a></p>
",<programming><quantum-state><textbook-and-exercises>,5/18/2022 12:47,26465.0,26465.0,"<p>In case the bra-ket notation is new to you, the calculations are fairly basic linear algebra.  Your starting state is the tensor product
<span class=""math-container"">$$(q_0)_{init} \otimes (q_1)_{init} = \vert 0\rangle\otimes\vert 0 \rangle= \begin{bmatrix} 1 \\ 0 \end{bmatrix}\otimes\begin{bmatrix} 1 \\ 0 \end{bmatrix}=\begin{bmatrix} 1 \\ 0 \\0\\0 \end{bmatrix}.$$</span>
The first gate applies the identity operation to <span class=""math-container"">$q_0$</span> and the Hadamard gate to <span class=""math-container"">$q_1$</span>, which looks like
<span class=""math-container"">$$I\otimes H = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \otimes \tfrac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix} = \tfrac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; -1 \end{bmatrix}.$$</span>
The <span class=""math-container"">$CNOT(\text{target}=q_0, \text{control}=q_1)$</span> (note that the target and control are inverted from how you normally see the <span class=""math-container"">$CNOT$</span> operation) can be represented by the matrix
<span class=""math-container"">$$CNOT_{q_0\leftarrow q_1}=\begin{bmatrix} 1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\\0&amp;0&amp;1&amp;0\\0&amp;1&amp;0&amp;0 \end{bmatrix}.$$</span>
The matrix operations representing gates act by left multiplication, so the calculations to achieve the referenced state vector are
<span class=""math-container"">$$\left[CNOT_{q_0\leftarrow q_1}\right]\times\left[I\otimes H\right]\times\left[(q_0)_{init} \otimes (q_1)_{init}\right],$$</span>
which gives
<span class=""math-container"">$$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \times \tfrac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; -1 \end{bmatrix} \times \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix} = \tfrac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 0 \\ 0 \\ 1 \end{bmatrix},$$</span>
as expected.</p>
",5/18/2022 13:47,Conceptual," The question is seeking an explanation of how a specific quantum state vector is calculated for a given quantum circuit. It involves understanding the underlying concepts of quantum programming and state vector calculations, making it a conceptual question.",Theoretical ," The user is asking about the underlying quantum computing concepts that lead to the output of a quantum circuit, which falls under understanding the principles and theories of quantum computing.",No,125.0,Conceptual,The question seeks an explanation of how a specific quantum state vector is calculated for a given quantum circuit. Understanding the underlying concepts of quantum programming and state vector calculations makes it a conceptual question.
26496.0,Performance metrics in QSVM,"<p>I have implemented QSVM on breast cancer dataset using link: &quot;https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html&quot; but unable to compute other metrics such as sensitivity, specificity and F1-score. Only able to compute accuracy.</p>
<p>How can I compute other metrics in QSVM?</p>
",<qiskit><programming><quantum-state><ibm-q-experience><vqe>,5/20/2022 4:37,26525.0,26525.0,"<p>Other metrics, such as accuracy, recall, f1, and confusion matrix, can be calculated in the same way as in classical machine learning. sklearn already contains built-in functions. So, for example, if you want to view the precision, recall, and F1-score, you may use the classification report function from sklearn.metrics:</p>
<p><code>classification_report(test_labels, qsvc.predict(test_features))</code></p>
<p>Here,</p>
<p><code>qsvc</code> is the name of your quantum kernel</p>
<p>In some cases, kernel matrices are used instead of the test_data in that case you can directly put the test_matrix in the predict function to evaluate your model.</p>
",5/22/2022 20:09,API Usage,"The user is asking for guidance on how to use the QSVM API to compute additional metrics, which falls under the usage and integration of APIs in quantum programming",API Usage,,,,API Usage,
26501.0,qiskit qaoa.compute_minimum_eigenvalue,"<p>I am having some trouble running the <code>compute_minimum_eigenvalue</code> method from qiskit's  <code>QAOA</code>: <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.QAOA.compute_minimum_eigenvalue.html#qiskit.algorithms.QAOA.compute_minimum_eigenvalue"" rel=""nofollow noreferrer"">the documentation</a> states that one need to pass <code>H</code> (&quot; <em>Qubit operator of the Observable</em>&quot; as <code>OperatorBase</code>).
My question is, given that I implemented <code>H</code> as <code>QuantumCircuit</code>, how can I convert it to the right format?
Thanks a lot!</p>
",<qiskit><programming><qaoa>,5/20/2022 11:29,26519.0,26519.0,"<p>I had suggested in my comment above how you might do this. <code>Operator</code> is not an opflow <code>OperatorBase</code> (it's a <code>BaseOperator</code> - different type) but can be used to create an opflow <code>MatrixOp</code> which is. Given your code sample above, I did the following based on it, which runs and prints values.</p>
<pre><code>import numpy as np
from qiskit import BasicAer, QuantumCircuit
from qiskit.algorithms import QAOA
from qiskit.algorithms.optimizers import COBYLA
from qiskit.quantum_info.operators import Operator
from qiskit.opflow import MatrixOp

nqubits = 4
H = QuantumCircuit(nqubits)
for i in range(nqubits):
    H.z(i)
    H_op = MatrixOp(Operator(H))
    qaoa = QAOA(optimizer= COBYLA(), reps=1, mixer=H,
                initial_point=np.array([1.0]),
                quantum_instance=BasicAer.get_backend('statevector_simulator'))
    print(qaoa.compute_minimum_eigenvalue(H_op))
</code></pre>
<p><em>Note</em>: you should use an <code>optimizer</code> from the <code>qiskit.algorithms.optimizers</code> package - the <code>qiskit.optimization</code> is part of the now <em>deprecated and unsupported</em> <code>Qiskit Aqua</code>, and that specific module you had used (CobylaOptimizer), in any case, had a different purpose.</p>
",5/21/2022 11:41,API Usage, The user is asking how to convert a QuantumCircuit object into the correct format (OperatorBase) to use it as the observable H in the compute_minimum_eigenvalue method of Qiskit's QAOA (Quantum Approximate Optimization Algorithm). This is a question about the proper API usage in Qiskit.,API Usage,,,,API Usage,
26548.0,How to implement SU(2) rotation with qiskit?,"<p>Before I start, I would like to say sorry for this possibly stupid question of mine.
I just recently got into the topic of quantum computing and try me there.</p>
<p>I'm currently trying to display a <strong>SU(2)</strong> rotation using Qiskit.</p>
<pre><code>from ibm_quantum_widgets import CircuitComposer

from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_bloch_multivector

from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi
import numpy as np
from qiskit.quantum_info.operators import Operator, Pauli



qreg_q = QuantumRegister(1, 'q')
circuit = QuantumCircuit(qreg_q)

clreg = ClassicalRegister(1)

...
</code></pre>
<p>After the implementations, I tried to achieve such a rotation with some matrices.
This is one of them:</p>
<p><a href=""https://i.stack.imgur.com/Nd1mK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Nd1mK.png"" alt=""enter image description here"" /></a></p>
<pre><code>def rn_su2_5(theta, n1,n2,n3):
    #This represents a matrix operator that will evolve() a Statevector by matrix-vector multiplication and will evolve() a DensityMatrix by left and right multiplication
    return Operator([
    [np.cos(theta/2)- 1j*n3*np.sin(theta/2), -1j*(n1-1j*n2)*np.sin(theta/2)],
    [-1j*(n1+1j*n2)*np.sin(theta/2), np.cos(theta/2)+1j*n3*np.sin(theta/2)]
    ],input_dims=(2, 1), output_dims=(2, 1))

print(rn_su2_5(pi,1,1,1))
circuit.unitary(rn_su2_5(pi,1,1,1),0)
</code></pre>
<p>Output:</p>
<pre><code>Operator([[ 6.123234e-17-1.j, -1.000000e+00-1.j],
          [ 1.000000e+00-1.j,  6.123234e-17+1.j]],
         input_dims=(2, 1), output_dims=(2, 1))

**ExtensionError: 'Input matrix is not unitary.'**
</code></pre>
<p>I would be very happy if you could help me with this problem.</p>
<p>Later the rotation should also be visible on a Blochsphere.</p>
<p>If the code is not sufficient, I will submit it later if necessary.</p>
",<qiskit><programming><bloch-sphere><physical-qubit>,5/24/2022 19:07,26572.0,26572.0,"<p>The problem is that the vector <code>n=[n1,n2,n3]</code> must have an magnitude (length) of <span class=""math-container"">$1$</span>, see for example <a href=""https://www.uni-muenster.de/Physik.TP/archive/fileadmin/lehre/teilchen/ws1011/SO3SU2.pdf"" rel=""nofollow noreferrer"">this document</a> (page 8, equation 50).</p>
<p>I implemented a debug line that shows you wether the matrix is unitary or not. When choosing <code>n=[0,0,1]</code> or <code>n=[1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]</code> the matrix becomes unitary.</p>
<pre><code># Matrix taken from
# https://docplayer.org/117986458-Die-symmetriegruppen-so-3-und-su-2.html (p. 11, equation 46)
# https://www.uni-muenster.de/Physik.TP/archive/fileadmin/lehre/teilchen/ws1011/SO3SU2.pdf (p. 8, equation 50)

def rn_su2(theta, n):
    n1 = n[0]
    n2 = n[1]
    n3 = n[2]
    return Operator([
        [np.cos(theta/2) - 1j*n3*np.sin(theta/2), -1j*(n1 - 1j*n2)*np.sin(theta/2)],
        [-1j*(n1 + 1j*n2)*np.sin(theta/2), np.cos(theta/2) + 1j*n3*np.sin(theta/2)]
    ], input_dims=(2, 1), output_dims=(2, 1))

# Magnitude of the vector n must be 1
n = [0,0,1]
n = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]

# Debug: check if the matrix is unitary
mat = np.array(rn_su2(5, n))
# Compute A^dagger.A and see if it is identity matrix
mat = np.conj(mat.T).dot(mat)
print(mat)

# construct the operator
rotated = circuit.unitary(rn_su2(pi, n), 0)
</code></pre>
<p>I checked in the notebook <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow.ipynb"" rel=""nofollow noreferrer"">here at Github</a>.</p>
<p>The rotation by <span class=""math-container"">$\frac{\pi}{4}$</span> around the <span class=""math-container"">$z$</span>-axis can be performed as follows (for this I oriented myself to <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">this lecture note</a>):</p>
<pre><code>rot_angle = pi/4
n = [0, 0, 1]
rot_operator = rn_su2(rot_angle, n)
rot_matrix = np.array(rot_operator)
start_vec = [1, 0, 0]

_bloch = Bloch()
_bloch.vector_color = ['blue', 'red']

sv = []
vec = start_vec
sv.append(vec)

spherical_vec = to_spherical(vec)
Ï = spherical_vec[1]
Î¸ = spherical_vec[2]
print(spherical_vec)

sx = msigma(1)
sy = msigma(2)
sz = msigma(3)
M_q = (np.sin(Î¸)*np.cos(Ï)*sx + np.sin(Î¸)*np.sin(Ï)*sy + np.cos(Î¸)*sz)
U_n = np.eye(2)*np.cos(rot_angle/2) -1j*(n[0]*sx+n[1]*sy+n[2]*sz)*np.sin(rot_angle/2)
M_q_rotated = U_n*M_q*np.matrix(U_n).H
print(M_q_rotated)
cos_Î¸_rotated = float(N(re(M_q_rotated[0,0])))
Î¸_rotated = np.arccos(cos_Î¸_rotated)
print(Î¸_rotated)

#e^(ix) = cos(x) + i*sin(x)
#see https://en.wikipedia.org/wiki/Euler%27s_identity
temp = float(N(re(M_q_rotated[1,0])))
temp = temp/np.sin(Î¸_rotated)
Ï_rotated = np.arccos(temp)
print(Ï_rotated)

vec = np.array(to_cartesian([1, Î¸_rotated, Ï_rotated]))
sv.append(vec)

_bloch.add_vectors(sv)
_bloch.render()
</code></pre>
<p>which looks as follows:</p>
<p><a href=""https://i.stack.imgur.com/CbKHW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CbKHW.png"" alt=""enter image description here"" /></a></p>
<p>Note that in the code above some polishing still need to be done such as exception handling of corner cases (e.g. in trigonometric functions).</p>
",5/26/2022 10:46,Errors,The user is encountering an error related to implementing a rotation using Qiskit and a given matrix operator. ,Errors,,,,Errors,
26573.0,Choosing a different optimizer when running QAOA in qiskit,"<p>I am trying to reproduce the QAOA example from <a href=""https://qiskit.org/textbook/ch-applications/qaoa.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/qaoa.html</a> and learn how to opt for a different optimizer.</p>
<p>The relevant block in the example is (towards the end of the example):</p>
<pre><code>from scipy.optimize import minimize


expectation = get_expectation(G, p=1)

res = minimize(expectation, 
                      [1.0, 1.0], 
                      method='COBYLA')
res
</code></pre>
<p>This effectively calls for COBYLA from scipy. However, in qiskit.algorithms.optimizers we can see a lot of other options: <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html</a></p>
<p>At the moment, for the block of code given above I cannot figure out how to change my optimizer. Say I want to apply ADAM or GradientDescent or SPSA. It is not clear to me how I can do that since just passing the argument 'ADAM' (for example) as below</p>
<pre><code>res = minimize(expectation, 
                          [1.0, 1.0], 
                          method='ADAM')
</code></pre>
<p>give a <code>ValueError: Unknown solver ADAM</code> error. I get the corresponding error when I try other optimizers too.</p>
<p>How can I deal with this?</p>
",<qiskit><programming><optimization><qaoa>,5/26/2022 11:33,26575.0,26575.0,"<p>The <code>optimizers</code> in <code>Qiskit</code> need to be instantiated then you can call their <code>minimize()</code> method. e.g.</p>
<pre><code>from qiskit.algorithms.optimizers import SPSA

opt = SPSA(maxiter=300)
res = opt.minimize(expectation, [1.0, 1.0])
</code></pre>
<p>So instead of the optimizer internally being created via a name passed to the <code>method</code> argument of scipy (where name is one of the optimizers available via scipy) here you create an instance and configure it via the constructor parameters, and use the minimize method on that instance.</p>
",5/26/2022 13:50,Tooling,"The user is asking about how to use a specific function in a quantum programming tool (Qiskits QAOA), specifically how to change the optimizer, which falls under the usage of tools and software in quantum programming..",Tooling,,,,Tooling,
26591.0,Applying an S gate on which two states leaves the state unchanged,"<p>I was going through a guide given by my friend and it had this MCQ which I couldn't get the answer to.</p>
<p><em>Applying an S gate on which two states leaves the state unchanged?</em></p>
<ul>
<li>|0 &gt;</li>
<li>|+ &gt;</li>
<li>|1 &gt;</li>
<li>|- &gt;</li>
<li>|â³ &gt;</li>
</ul>
",<programming><quantum-gate><quantum-state>,5/27/2022 7:46,26592.0,26592.0,"<p>You've got two options:</p>
<ul>
<li>just try applying <span class=""math-container"">$S$</span> to each of the states to see what happens. For example <span class=""math-container"">$S|+\rangle=(|0\rangle+i|1\rangle)/\sqrt{2}$</span>, so the <span class=""math-container"">$|+\rangle$</span> state does change.</li>
<li>note that you're effective asked to find the eigenvectors of <span class=""math-container"">$S$</span>. So write it in matrix form.</li>
</ul>
<p>The only thing you have to be careful of is the sense in which I'm guessing &quot;doesn't change&quot; is meant here. Remember that global phases are irrelevant to quantum states, so one might consider
<span class=""math-container"">$$
S|1\rangle=i|1\rangle\equiv|1\rangle
$$</span>
as being unchanged.</p>
",5/27/2022 8:07, Conceptual,"The question is about the concept of applying an S gate to specific quantum states and understanding which states remain unchanged after the operation. It involves the background and understanding of quantum gates and their effects, making it a conceptual question.", Conceptual,,,, Conceptual,
26623.0,"Within Stim, how to trace back DEM error instructions to Stim circuit faults","<p>If I have a line in a DEM e.g.</p>
<p>error(0.001) D0</p>
<p>is there an easy way to see which circuit faults in the original circuit contributed to that error mechanism?</p>
",<programming><stim>,5/29/2022 21:47,26624.0,26624.0,"<p>Use <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.Circuit.explain_detector_error_model_errors"" rel=""nofollow noreferrer""><code>stim.Circuit.explain_detector_error_model_errors</code></a>, like this:</p>
<pre><code>circuit = ...
dem_errors_to_explain = stim.DetectorErrorModel(&quot;&quot;&quot;
    error(1) D0
&quot;&quot;&quot;)

circuit_errors = circuit.explain_detector_error_model_errors(
    dem_filter=dem_errors_to_explain,
    reduce_to_one_representative_error=True,
)
</code></pre>
<p>The result is a list of <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.ExplainedError"" rel=""nofollow noreferrer""><code>stim.ExplainedError</code></a> objects (in this case the list only has one item, since we only asked to explain one error).</p>
<p>Note that these circuit error describing objects have a lot of fields. The easiest way to understand them is to start by just printing them out and see what's listed. The <code>reduce_to_one_representative_error</code> argument simplifies things by making each explained error only contain the simplest <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.CircuitErrorLocation"" rel=""nofollow noreferrer""><code>stim.CircuitErrorLocation</code></a>, instead of all of them. You'll then get something like:</p>
<pre><code>&gt;&gt;&gt; print(circuit_errors[0])

Explained Error {
    dem_error_terms D0[coords 1,2,3]
    CircuitErrorLocation {
        flipped_pauli_product: Y0[coords 0,0]
        Circuit location stack trace:
            (after 10 TICKs)
            at instruction #3 (DEPOLARIZE1) in the circuit
            at target #1 of the instruction
            resolving to DEPOLARIZE1(0.01) 0[coords 0,0]
    }
}
</code></pre>
<p>Note that if you get something like this:</p>
<pre><code>Explained Error {
    dem_error_terms D0[coords 1,2,3]
    [no single circuit error had these exact symptoms]
}
</code></pre>
<p>you may have accidentally used a version of your circuit that had no noise in it.</p>
",5/29/2022 21:58,Errors,The question is asking about how to identify the circuit faults that contributed to a particular error mechanism in a DEM. This is a type of error analysis.,Errors,,,,Errors,
26666.0,Can someone explain to me what is T gate and tdg like im five?,"<p>I'm newbie to quantum computing, i read about these two gates on IBM quantum computing docs, but I can't seem to understand what is t-gate and tdg or t-dagger, can someone give me a simple explanation about these two gates? Also S-gate if that is possible!</p>
<p>Thank you so much.</p>
",<qiskit><programming><quantum-gate><quantum-state><ibm-q-experience>,06/01/2022 05:31,26668.0,26668.0,"<p><code>tdg</code> is the method used to apply <span class=""math-container"">$T^\dagger$</span> (read T dagger). Thus, there are no differences between these two.</p>
<p>For a quantum gate <span class=""math-container"">$U$</span>, <span class=""math-container"">$U^\dagger$</span> is the inverse of <span class=""math-container"">$U$</span>. That is, if you apply <span class=""math-container"">$U$</span> on a given state <span class=""math-container"">$|\psi\rangle$</span> and then <span class=""math-container"">$U^\dagger$</span>, you will be back in the state <span class=""math-container"">$|\psi\rangle$</span> again.</p>
<p>So now, what is <span class=""math-container"">$T$</span>? Or rather, why do we care about <span class=""math-container"">$T$</span>? You see, there are these gates, <span class=""math-container"">$H$</span>, <span class=""math-container"">$S$</span> and the <span class=""math-container"">$CNOT$</span> using which we can do some things. However, we are quite limited with them, there is no way to construct a Toffoli gate (that is, an <span class=""math-container"">$X$</span> gate controlled on two qubits) using them for instance. However, if we do allow ourselves to use these gates and the <span class=""math-container"">$T$</span> gate, then we can construct any quantum gate we'd like.</p>
<p>The <span class=""math-container"">$S$</span> gate is simply the <span class=""math-container"">$T$</span> gate applied twice: <span class=""math-container"">$T^2=S$</span>.</p>
<p>On a more &quot;math&quot; level, the <span class=""math-container"">$T$</span> gate is the following matrix:
<span class=""math-container"">$$\begin{pmatrix}1&amp;0\\0&amp;\mathrm{e}^{\mathrm{i}\frac\pi4}\end{pmatrix}$$</span>
That is, it applies a phase of <span class=""math-container"">$\frac\pi4$</span> to the <span class=""math-container"">$|1\rangle$</span> state and leaves <span class=""math-container"">$|0\rangle$</span> untouched.</p>
<p>I'm not sure that this is a gate you'll have to deal with often. It does appear a lot in the Quantum Circuits you'll build, but I'm not sure that you'll use it directly when defining your own Quantum Gates. For instance, if you use a Toffoli gate in your circuit, under the hood the gates that will be applied to your three qubits are those:</p>
<p><a href=""https://i.stack.imgur.com/kfXwL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kfXwL.png"" alt=""Toffoli gate"" /></a></p>
<p>Thus, while you will reason without this <span class=""math-container"">$T$</span> gate in most cases, it will be here when decomposing the circuit into the basic gates using which you'll build it.</p>
",06/01/2022 08:01,Learning,"The user is seeking a simple explanation of quantum gates (specifically t-gate, tdg or t-dagger, and S-gate) to enhance their understanding of quantum computing concepts. This falls under the category of learning, as they are looking to acquire knowledge and improve their understanding in the field of quantum computing.",Learning,,,,Learning,
26714.0,Qiskit: Get number of iterations for Iterative Amplitude Estimation,"<p>Trying to count the number of uses of my circuit <span class=""math-container"">$A$</span> in Grover iterate circuit <span class=""math-container"">$Q= -AS_0A^{\dagger}S_x$</span>.</p>
<p>However, Qiskit's amplitude estimation algorithms such as <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.IterativeAmplitudeEstimation.html"" rel=""nofollow noreferrer"">IAE</a> or <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.FasterAmplitudeEstimation.html"" rel=""nofollow noreferrer"">FAE</a>
accept only precision arguments like e.g. confidence of solution, error. I run them like this:</p>
<pre><code>from qiskit.algorithms import IterativeAmplitudeEstimation, EstimationProblem, FasterAmplitudeEstimation

problem = EstimationProblem(state_operation=myqc, objective_qubits=[0])
algorithm = IterativeAmplitudeEstimation(**kwargs)
result = algorithm.estimate(problem)
amplitude = result.estimation
</code></pre>
<p>How can I get the number of total iterations along with the result or at least get the circuit?
Do I need to create my own implementations of the algorithms?</p>
",<qiskit><programming><amplitude-amplification>,06/03/2022 12:58,26999.0,26999.0,"<p>For the number of iterations, you can do</p>
<pre><code>for i,j in enumerate(result_delta._estimate_intervals):
    print(i,np.mean(j))
</code></pre>
<p>For the circuit result, you can try to do <code>result.circuit_results</code>, it might return a Statevector or counts dictionary.<br />
and <code>algorithm.construct_circuit(problem)</code> to check the problem circuit.</p>
<pre><code>#recommend way to view the problem gate
from qiskit import transpile
transpile(ae_delta.construct_circuit(problem),basis_gates = ['ry', 'cx','ccx','x']).draw()
</code></pre>
<p>For any more related coding questions, you can just do something like <code>dir(result)</code> to see its attribute, then check sources code or docs about these attributes for the explanation.</p>
<p>hope it is something you are looking for</p>
",6/22/2022 9:13,Tooling,"The user is seeking guidance on how to extract additional information, specifically the number of total iterations or the circuit, from Qiskit's amplitude estimation algorithms (IterativeAmplitudeEstimation and FasterAmplitudeEstimation)",Tooling,,,,Tooling,
26785.0,I am getting an error like this 'Invalid input data format for Statevector',"<p>I am new at QC. I learn from a course. When I write to this code:</p>
<blockquote>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
q = QuantumRegister (1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q,c)
qc.draw('mpl')

from qiskit.quantum_info import Statevector

psi1 = Statevector(qc)

psi1.draw('latex')
</code></pre>
</blockquote>
<p>I am gettin an error :</p>
<pre><code>&gt; QiskitError                               Traceback (most recent call
&gt; last) &lt;ipython-input-28-eccf64e782f7&gt; in &lt;module&gt;
&gt; ----&gt; 1 psi1 = Statevector(qc)
&gt;       2 psi1.draw('latex')
&gt; 
&gt; C:\ProgramData\Anaconda3\lib\site-packages\qiskit\quantum_info\states\statevector.py
&gt; in __init__(self, data, dims)
&gt;      72             self._data = np.ravel(data.data)
&gt;      73         else:
&gt; ---&gt; 74             raise QiskitError(&quot;Invalid input data format for Statevector&quot;)
&gt;      75         # Check that the input is a numpy vector or column-vector numpy
&gt;      76         # matrix. If it is a column-vector matrix reshape to a vector.
&gt; 
&gt; QiskitError: 'Invalid input data format for Statevector'
</code></pre>
<p>Can you help me?</p>
<p>thanks your time.</p>
",<qiskit><programming><quantum-gate>,06/08/2022 14:07,26790.0,26790.0,"<p>Tips for you to understand error:</p>
<ul>
<li>take a look at qiskit docs, what is the valid data input, learn more about Statevector class<br />
<a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html</a></li>
<li>and from output error<br />
<code>QiskitError: 'Invalid input data format for Statevector'</code><br />
which mean you didn't input the expected data(np.array or list or Statevector or Operator or QuantumCircuit)</li>
<li>check sources code if it make sense, and discuss in StackExchange or slack then report bug to github sources code, if there is any bug.</li>
</ul>
<p>I hope these tips help you though study QC.<br />
also please provide more info about your input for Statevector, if you need any help.</p>
",06/08/2022 18:04, Errors,The user is encountering an error when trying to create a Statevector object from their QuantumCircuit using Qiskit, Errors,,,, Errors,
26882.0,LaTeX package for drawing MBQC patterns,"<p>I'm looking for an appropriate <span class=""math-container"">$\LaTeX$</span> package for drawing measurement-based quantum computing patterns similar to the picture below:</p>
<p><a href=""https://i.stack.imgur.com/hUvoo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hUvoo.png"" alt=""enter image description here"" /></a></p>
<p>Does anyone know of a package which may be most efficient for drawing diagrams like this? Thanks!</p>
",<programming>,6/14/2022 15:26,26887.0,26887.0,"<p>Wouldn't this be more appropriate in the <a href=""https://tex.stackexchange.com/"">LaTeX site</a>? Nevertheless, here's my suggestion using <code>tkz-graph</code>:</p>
<pre><code>\documentclass{article}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{braket}
\usepackage{tkz-graph}

\begin{document}

<span class=""math-container"">\begin{figure}[!htb]
\centering
\begin{tikzpicture}
    \SetVertexNormal[TextColor=red]
    \SetGraphUnit{2}
    \Vertex[L=$\ket{\psi}_1$]{s}
    \node at (s)[above=3ex]{\textcolor{red}{$M(\theta), s_1$}};
    \EA[L=$\ket{+}_2$](s){c}
    \Edge(s)(c)
\end{tikzpicture}
\caption{\label{fig:reference}The \textcolor{red}{$J(-\theta)$}-gate MBQC pattern.}
\end{figure}</span>

\end{document}
</code></pre>
<p><a href=""https://i.stack.imgur.com/eu7TA.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eu7TA.jpg"" alt=""result"" /></a></p>
<p>Using <code>\tikzset</code> to set some parameters only once is certainly possible, but first you can see if the syntax suits your needs.</p>
",6/14/2022 21:13,Tooling,"The question is asking about a LaTeX package for drawing measurement-based quantum computing patterns, which is a tooling question.",Tooling,,,,Tooling,
26899.0,How to convert between little/big-endian unitary forms in Braket?,"<p>As noted in <a href=""https://quantumcomputing.stackexchange.com/a/26829/13991"">this post</a>, the Amazon Braket unitary calculation method <a href=""https://amazon-braket-sdk-python.readthedocs.io/en/latest/_modules/braket/circuits/circuit.html#Circuit.as_unitary"" rel=""nofollow noreferrer"">as_unitary</a> has been deprecated (<a href=""https://github.com/aws/amazon-braket-sdk-python/pull/325"" rel=""nofollow noreferrer"">#325</a>) as it uses little-endian qubit order. The new, big-endian method is <a href=""https://amazon-braket-sdk-python.readthedocs.io/en/latest/_modules/braket/circuits/circuit.html#Circuit.to_unitary"" rel=""nofollow noreferrer"">to_unitary</a>. Here's a code snippet showing the difference in the two forms for a simple bell circuit:</p>
<pre><code>from braket.circuits import Circuit

circuit = Circuit().h(0).cnot(0, 1)

u_little_endian = circuit.as_unitary()  # little-endian method
u_big_endian = circuit.to_unitary()     # big-endian method

print(f&quot;little-endian: \n{u_little_endian}\n&quot;)
print(f&quot;big-endian: \n{u_big_endian}\n&quot;)
</code></pre>
<pre><code>little-endian: 
[[ 0.70710678+0.j  0.70710678+0.j  0.        +0.j  0.        +0.j]
 [ 0.        +0.j  0.        +0.j  0.70710678+0.j -0.70710678+0.j]
 [ 0.        +0.j  0.        +0.j  0.70710678+0.j  0.70710678+0.j]
 [ 0.70710678+0.j -0.70710678+0.j  0.        +0.j  0.        +0.j]]

big-endian: 
[[ 0.70710678+0.j  0.        +0.j  0.70710678+0.j  0.        +0.j]
 [ 0.        +0.j  0.70710678+0.j  0.        +0.j  0.70710678+0.j]
 [ 0.        +0.j  0.70710678+0.j  0.        +0.j -0.70710678+0.j]
 [ 0.70710678+0.j  0.        +0.j -0.70710678+0.j  0.        +0.j]]
</code></pre>
<p>I'm in the process of transitioning some of my own projects to reflect this upgrade, but am also hoping to maintain backward compatibility with the little-endian method. For testing, I'm attempting to create a function that can convert a matrix calculated using the big-endian method to its little-endian &quot;equivalent&quot;, or vice versa. For example, I'm looking to implement a function <code>my_conversion</code> that would satisfy the following:</p>
<pre><code>import numpy as np

u_converted = my_conversion(u_big_endian)
assert np.allclose(u_little_endian, u_converted)
</code></pre>
<p>In my own attempts, I've tried to work backward from the underlying functions, <a href=""https://github.com/aws/amazon-braket-sdk-python/blob/f25a8344ffcf3d0b69841f29b263fc6e37cace4a/src/braket/circuits/unitary_calculation.py#L44"" rel=""nofollow noreferrer"">calculate_unitary</a> and <a href=""https://github.com/aws/amazon-braket-sdk-python/blob/f25a8344ffcf3d0b69841f29b263fc6e37cace4a/src/braket/circuits/unitary_calculation.py#L90"" rel=""nofollow noreferrer"">calculate_unitary_big_endian</a>, however, the procedures used have been somewhat difficult to decipher. Mathematically, <a href=""https://quantumcomputing.stackexchange.com/a/8370/13991"">this post</a> was helpful, but programmatically, I'm still not sure where to start. Maybe such a function already exists in the braket repo for internal use?</p>
",<programming><unitarity><matrix-representation><amazon-braket>,6/15/2022 18:57,26903.0,26903.0,"<p>One intuitive way to do this is to think in terms of tensors.</p>
<p>Suppose you have a 3-qubit state <span class=""math-container"">$\psi$</span>. This is an 8-dimensional vector that you can reshape into a contravariant tensor <span class=""math-container"">$\psi^{ijk}$</span>. Let's assume the qubits in this state are big-endian, following Braket convention.</p>
<p>Now suppose you have a 3-qubit unitary <span class=""math-container"">$U$</span> that you want to apply to <span class=""math-container"">$\psi$</span> to obtain <span class=""math-container"">$U \psi$</span>. Matching up the indices of <span class=""math-container"">$U$</span> with those of <span class=""math-container"">$\psi$</span> according to <a href=""https://en.wikipedia.org/wiki/Einstein_notation"" rel=""nofollow noreferrer"">Einstein convention</a>, you get</p>
<p><span class=""math-container"">$$
(U \psi)^{lmn} = U^{lmn}_{ijk} \psi^{ijk}
$$</span></p>
<p>where the original indices of <span class=""math-container"">$\psi$</span> are matched with the covariant (lower) indices of <span class=""math-container"">$U$</span> and traced out, leaving the indices <span class=""math-container"">$l, m, n$</span>.</p>
<p>So far, everything has been big-endian. What if we want to switch to little-endian qubits? Well, the state <span class=""math-container"">$\psi$</span> needs to have its indices reversed, giving <span class=""math-container"">$\psi^{kji}$</span>. The lower indices of <span class=""math-container"">$U$</span> will then be reversed as well to ensure that the correct entries are multiplied together, and the contravariant (upper) indices need to be reversed so the output state is also little-endian:</p>
<p><span class=""math-container"">$$
(U \psi)^{nml} = U^{nml}_{kji} \psi^{kji}
$$</span></p>
<p>Now, in terms of code, you can get the little-endian <span class=""math-container"">$U^{nml}_{kji}$</span> with <a href=""https://numpy.org/doc/stable/reference/generated/numpy.einsum.html"" rel=""nofollow noreferrer""><code>np.einsum</code></a>; you just have to reshape first:</p>
<pre><code># U is 8 * 8
U_tensor = U.reshape([2] * 6)
little_endian_tensor = np.einsum(U_tensor, [2, 1, 0, 5, 4, 3])
U_little_endian = little_endian_tensor.reshape([8, 8])
</code></pre>
<p>A general function would then be</p>
<pre><code># Circuit is the Braket class
def little_endian_unitary(circ: Circuit) -&gt; np.ndarray:
    qubit_count = circ.qubit_count
    U_tensor = circ.to_unitary().reshape([2] * 2 * qubit_count)
    input = list(reversed(range(qubit_count)))
    output = [i + qubit_count for i in input]
    little_endian_tensor = np.einsum(U_tensor, input + output)
    return little_endian_tensor.reshape([2 ** qubit_count, 2 ** qubit_count])
</code></pre>
",6/16/2022 3:25,Tooling,The user is seeking assistance in creating a function to convert unitary matrices between little-endian and big-endian representations in the context of the Amazon Braket SDK.which is a tooling question.,Tooling,,,,Tooling,
26970.0,How to implement subplots (several blochsphere plots) using qiskit?,"<p>Qiskit seems to use matplotlib for rendering bloch spheres under the hood. Therefore, it would be nice if we could also make use of matplotlib's subplot technique.</p>
<p>I would like to implement subplots, each containing a bloch sphere (with different vectors), like the plot matrix in <a href=""https://matplotlib.org/stable/gallery/lines_bars_and_markers/eventplot_demo.html#sphx-glr-gallery-lines-bars-and-markers-eventplot-demo-py"" rel=""nofollow noreferrer"">this example</a>. I would be very grateful for a short help.</p>
<p>The result should look something like this at the end of the day:</p>
<p><a href=""https://i.stack.imgur.com/UMBo1m.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UMBo1m.jpg"" alt=""enter image description here"" /></a></p>
",<qiskit><programming><bloch-sphere><matrix-representation>,6/20/2022 9:39,26974.0,26974.0,"<p>Function <code>plot_bloch_vector</code> accepts <code>matplotlib.axes.Axes</code> to use for rendering the bloch sphere. So, you can create a <code>figure</code>, add a new <code>Axes</code> for each bloch sphere, then pass it to <code>plot_bloch_vector</code>:</p>
<pre><code>from qiskit.visualization import plot_bloch_vector
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize = [6, 9])

states = [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1],
    [0.6, 0.8, 0],
    [0.6, 0, 0.8],
    [0, 0.6, 0.8],
]

# Values are in fractions of figure width and height:
positions = [
    [0, 0],
    [0.5, 0],
    [0, 0.333],
    [0.5, 0.333],
    [0, 0.667],
    [0.5, 0.667],
]

for m in range(len(states)):
    ax = fig.add_axes([positions[m][0], positions[m][1], 0.5, 0.333], axes_class = Axes3D)
    plot_bloch_vector(states[m], ax = ax)
</code></pre>
<p>The result:</p>
<p><a href=""https://i.stack.imgur.com/BgXTl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BgXTl.png"" alt=""enter image description here"" /></a></p>
",6/20/2022 19:09,Tooling,"The user is looking for assistance in implementing subplots with Bloch spheres in Qiskit, similar to the subplot technique used in matplotlib. which is a tooling question.",Tooling,,,,Tooling,
26986.0,cirq_google library in Python,"<p>I am trying to use the cirq_google library in Python but I receive an error:</p>
<pre><code># from cirq        import Simulator
# !pip install cirq_google 
from cirq_google import XmonSimulator
</code></pre>
<pre><code>ImportError: cannot import name 'XmonSimulator' from 'cirq_google' (unknown location)
</code></pre>
<p>What should I do?</p>
",<programming><cirq>,6/21/2022 13:55,26987.0,26987.0,"<p>The <code>XmonSimulator</code> is no longer supported: <a href=""https://github.com/quantumlib/Cirq/issues/1978"" rel=""nofollow noreferrer"">#1978</a>, <a href=""https://github.com/quantumlib/Cirq/pull/1993"" rel=""nofollow noreferrer"">#1993</a>.</p>
<p>You should instead use <code>cirq.Simulator</code>: <a href=""https://github.com/quantumlib/Cirq/issues/3277#issuecomment-682692431"" rel=""nofollow noreferrer"">#3277</a>.</p>
",6/21/2022 14:22,Errors,The user is encountering an error when trying to import the XmonSimulator from the cirq_google library in Python.,Errors,,,,Errors,
26993.0,How does Fujitsu's digital annealer work?,"<p>I have read Fujitsu's white paper for a brief introduction to their device:
<a href=""http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf"" rel=""nofollow noreferrer"">http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf</a>
As far as I know, Fujitsu's hardware is not quantum-mechanical. They call it a digital annealer inspired by quantum phenomenon. I'm curious about what it actually is, and what kind of algorithm it runs. Is it a classical computer or some specialized annealing device? If the former, what kind of annealing algorithm does it use? As for the latter, I'm not sure whether that kind of device actually exists. (Quantum annealers like the ones D-wave has belongs to this category, but Fujitsu doesn't have those.)</p>
",<classical-computing><annealing><quantum-inspired>,6/22/2022 1:31,26996.0,26996.0,"<p>The first google search gives the research paper by Aramon et al. According to <a href=""https://www.frontiersin.org/articles/10.3389/fphy.2019.00048/full"" rel=""nofollow noreferrer"">the article</a>:</p>
<blockquote>
<p>The Fujitsu Digital Annealer is designed to solve fully connected
quadratic unconstrained binary optimization (QUBO) problems. It is
implemented on application-specific CMOS hardware and currently solves
problems of up to 1,024 variables. The Digital Annealer's algorithm is
currently based on simulated annealing; however, it differs from it in
its utilization of an efficient parallel-trial scheme and a dynamic
escape mechanism. In addition, the Digital Annealer exploits the
massive parallelization that custom application-specific CMOS hardware
allows.</p>
</blockquote>
<p>So basically, it is specialized hardware that runs a variant of the simulated annealing algorithm.</p>
<p>The algorithm is explicitly given in the article as well. <a href=""https://i.stack.imgur.com/RNBqc.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RNBqc.jpg"" alt=""here"" /></a></p>
",6/22/2022 3:46,Conceptual," The question is seeking to understand the nature of Fujitsu's hardware, whether it's classical or specialized annealing, and the algorithms it runs. It's a conceptual question as it's focused on understanding the underlying concepts and technology behind Fujitsu's device in the context of quantum computing.",Conceptual,,,,Conceptual,
27049.0,Why does having two classical registers sometimes only yeild one bit?,"<p>I was running some  qiskit code on qasm_simulator to test something and I realized that, when I have two separate classical registers, sometimes only one bit is generated, and I'm trying to understand why? If you have two meaurements, but send them to only one classical register, the second one overwrites the first in the final output. I would expect that if you have two seperate classical registers, both with be displayed in the output but that doesnt always seems to be the case?</p>
<p>Fore example here is some simple code that demonstrates this:</p>
<pre><code>#Sending two measurements to one classical register yeilds only outputs of one bit. 
circuit.h(qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])
circuit.h(qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])

job = execute(circuit, backend, shots=8192, memory=True)
output=[]
result_list=job.result().get_memory()
for entry in result_list:
    output.append(int(entry))
print(output)

&gt;&gt;&gt; [1, 1, 1, 0, 1, 1, 0, 0, 0,...]
</code></pre>
<pre><code>#Sending two measurements to two different classical register sometimes yeild two bits and sometimes yeilds one. 
circuit.h(qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])
circuit.h(qreg_q[0])
circuit.measure(qreg_q[0], creg_c[1])

job = execute(circuit, backend, shots=8192, memory=True)
output=[]
result_list=job.result().get_memory()
for entry in result_list:
    output.append(int(entry))
print(output)

&gt;&gt;&gt; [0, 10, 11, 11, 11, 10, 10, 1, 11, 11, 10, 11, 0, 11, 1, 10, 0, 11, 0, 10, 10, 1,...]
</code></pre>
",<measurement><classical-computing>,6/24/2022 14:37,27051.0,27051.0,"<p>This happens because your convert the bit-strings to integers.</p>
<pre><code>output.append(int(entry))
</code></pre>
<p>Hence, the leading zeros are removed. If you want to keep the bit-string as it is, don't convert it:</p>
<pre><code>print(job.result().get_memory())
</code></pre>
",6/24/2022 16:12,Errors, The user is encountering an error where their Qiskit code is sometimes only generating one bit of output when they expect two bits. This is an error-related question.,Errors,,,,Errors,
27102.0,"What is the data type ""Unit is Adj"" in Q#?","<p>I came across it as the return type of operations in this paper: <a href=""https://arxiv.org/abs/2204.13835"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2204.13835</a>. It is also used in various places in the Q# documentation.</p>
",<programming><q#>,6/27/2022 10:40,27110.0,27110.0,"<p><code>Unit is Adj</code> is not a data type per se, but rather a combination of two things:</p>
<ol>
<li>Data type <code>Unit</code> that indicates that this operation does not have a return value.</li>
<li>Suffix <code>is Adj</code> that indicates that this operation implements a unitary transformation and has an adjoint specialization (either generated automatically or provided manually in the code, depending on the body of the operation). The operation can also say <code>is Ctl</code> to indicate that it has a controlled specialization, or <code>is Adj+Ctl</code> to indicate that it has both.</li>
</ol>
<p>These suffixes can only occur for operations that return <code>Unit</code> type, so they can look indeed as a fixed code fragment together.</p>
<p>You can find more info about operation specializations in Q# in the <a href=""https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/operationsandfunctions#operation-characteristics"" rel=""nofollow noreferrer"">documentation on operations</a>.</p>
",6/27/2022 16:01,Conceptual,"The user is inquiring about a specific concept or term, the ""Result"" type, which is used in quantum computing and mentioned in a research paper and the Q# documentation. This falls under the conceptual category",Theoretical,"The user is referring to a scientific paper that discusses a specific return type related to quantum computing operations. They are also mentioning the use of this term in Q# documentation, indicating a theoretical aspect of quantum computing, making it suitable for the ""Theoretical"" category, which covers inquiries about theoretical concepts, algorithms, and principles in quantum computing.",No,126.0,Theoretical,"The user mentions a scientific paper discussing a specific return type related to quantum computing operations, indicating a theoretical aspect. Additionally, they refer to its usage in Q# documentation, aligning with inquiries about theoretical concepts and principles in quantum computing."
27239.0,Understanding Paddle Quantum's MBQC simulation,"<p><a href=""https://qml.baidu.com/"" rel=""nofollow noreferrer"">Paddle Quantum</a> have a <a href=""https://qml.baidu.com/tutorials/measurement-based-quantum-computation/mbqc-quick-start-guide.html"" rel=""nofollow noreferrer"">toolkit</a> for simulating measurement-based QC patterns in Python, and I'm having a hard time understanding how this works.</p>
<p>For example, the following code snippet considers the pattern of two qubits joined by an edge. We initialise the two qubits in the state <span class=""math-container"">$|+\rangle |+\rangle$</span>, before applying a measurement on the 1st qubit with respect to the <span class=""math-container"">$\{ |+\rangle, |-\rangle \}$</span> basis:</p>
<pre><code>from paddle import to_tensor
from paddle_quantum.mbqc.simulator import MBQC
from paddle_quantum.mbqc.qobject import State
from paddle_quantum.mbqc.utils import basis

# Define MBQC graph as two vertices joined by an edge
G = [['1','2'], [('1','2')]]
# Initialise MBQC model
mbqc = MBQC()
# Set the graph state
mbqc.set_graph(G)

# Define input state as |+&gt;|+&gt;
input_state = to_tensor([[0.5],[0.5],[0.5],[0.5]], dtype='complex128')
input_state = State(input_state, ['1','2'])
# Set the input state
mbqc.set_input_state(input_state)

# Print initial state
print('Input state:')
print(mbqc.get_quantum_output().vector.numpy())
# Measure qubit 1
mbqc.measure('1', basis('XY', to_tensor(0, dtype='float64')))
# Print measurement outcome and resultant state of qubit 2
print('Measurement outcome of 1st qubit:')
print(mbqc.sum_outcomes(['1']))
print('Post-measurement state:')
print(mbqc.get_quantum_output().vector.numpy())

</code></pre>
<p>As I understand it, the measurement outcome of the first qubit should always be 0, since the first qubit has state <span class=""math-container"">$|+\rangle$</span> and we are measuring in the <span class=""math-container"">$\{ |+\rangle, |-\rangle \}$</span> basis. However, the code above sometimes gives a measurement outcome of 1 in the console:</p>
<pre><code>Input state:
[[0.5+0.j]
 [0.5+0.j]
 [0.5+0.j]
 [0.5+0.j]]
Measurement outcome of 1st qubit:
1
Post-measurement state:
[[0.+0.j]
 [1.+0.j]] 
</code></pre>
<p>Hence, my question is simply: which part of the above simulation am I misunderstanding?</p>
",<programming><measurement>,07/07/2022 11:04,27241.0,27241.0,"<p>Thanks very much for using our MBQC toolkit, and also thanks for your feedback. In the first part of your code, you set the underlying graph of your MBQC algorithm.</p>
<pre><code># Define MBQC graph as two vertices joined by an edge
G = [['1','2'], [('1','2')]]
# Initialise MBQC model
mbqc = MBQC()
# Set the graph state
mbqc.set_graph(G)
</code></pre>
<p>So you have set two vertices and an edge between them. <strong>This edge represents a controlled-Z gate between these qubits.</strong></p>
<p>All the vertices are initially plus states in MBQC by default. But we do allow users to replace it to any given state for flexibility. This is equivalent to specify an input state in the quantum circuit model. In your case, you set these two vertices again to two plus states, which means doing nothing.</p>
<pre><code># Define input state as |+&gt;|+&gt;
input_state = to_tensor([[0.5],[0.5],[0.5],[0.5]], dtype='complex128')
input_state = State(input_state, ['1','2'])
# Set the input state
mbqc.set_input_state(input_state)
</code></pre>
<p>Then you apply X measurement on the first qubit.</p>
<pre><code># Measure qubit 1
mbqc.measure('1', basis('XY', to_tensor(0, dtype='float64')))
</code></pre>
<p>This is equivalent to perform a Z measurement on a bell state 1/sqrt(2) (|00&gt;+|11&gt;) (initialize two plus state, perform a CZ gate and the measure the first qubit in X basis). So you get zero or one with equal probability. If you get outcome 0, the post-measurement state on the second qubit is |0&gt;. If you get outcome 1, the post-measurement state is |1&gt;.</p>
<p><strong>So I guess you miss the CZ gate here. This gate is automatically applied when you measure a qubit.</strong></p>
<p>Also note that once a graph is specified, the computation is completely driven by the measurements. In your code</p>
<pre><code># Print initial state
print('Input state:')
print(mbqc.get_quantum_output().vector.numpy())
</code></pre>
<p>no measurement has been applied yet. So the computation does not get started. The state you print is exactly the input state you set.</p>
<p>Hope everything makes sense now. Let me know if you need more help.</p>
<p>We do hope to make Paddle Quantum better together with the community!</p>
",07/07/2022 12:44,Errors," The user is encountering an error where the measurement outcome of the first qubit is sometimes 1, even though the first qubit is initialized in the state ?+? and the measurement is being performed in the {?+?,???} basis.",Errors,,,,Errors,
27454.0,How are the experiments ordered in a Qiskit Job?,"<p>Using the <a href=""https://qiskit.org/documentation/apidoc/execute.html"" rel=""nofollow noreferrer"">execute function</a>, assuming the parameter <code>experiments</code> is a <code>list[QuantumCircuit]</code>, would each circuit execute on the device in the order specified by the list?</p>
",<qiskit><programming>,7/24/2022 13:04,27471.0,27471.0,"<p>If the parameter <code>experiments</code> is a <code>list[QuantumCircuit]</code>, then the <code>qiskit.execute_function</code> function will run the circuits using a <a href=""https://qiskit.org/documentation/stubs/qiskit.tools.parallel_map.html#qiskit-tools-parallel-map"" rel=""nofollow noreferrer""><em>parallel map</em></a>, and append the results in the returned list <em>in the order they finish</em>.</p>
<p>After the parallel run, you can sort the results list to match the ordering of the input circuits. For an example of how to do so, see <a href=""https://quantumcomputing.stackexchange.com/a/23382/13991"">https://quantumcomputing.stackexchange.com/a/23382/13991</a>.</p>
<p><em>Edit</em>:</p>
<p>Lists of jobs sent to actual IBMQ quantum devices are processed through the parallel map function as well, but appear to be submitted asynchronously. Tracking a run down through the stack, you'll find:</p>
<p><code>IBMQJobManager.run</code> <br />
Â  Â  <span class=""math-container"">${\rightarrow}$</span> <code>ManagedJobSet.run</code> <br />
Â  Â  Â  Â  <span class=""math-container"">${\rightarrow}$</span> <code>ManagedJob.submit</code> <br />
Â  Â  Â  Â  Â  Â  <span class=""math-container"">${\rightarrow}$</span><code>concurrent.futures.ThreadPoolExecutor.submit</code></p>
<p><a href=""https://github.com/Qiskit/qiskit-ibmq-provider/blob/e09ff2e66447b545b8ff62a1120fb31b515f1015/qiskit/providers/ibmq/managed/managedjob.py#L61"" rel=""nofollow noreferrer"">ManagedJob.submit</a> invokes <a href=""https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit"" rel=""nofollow noreferrer"">ThreadPoolExecutor.submit</a> with callable <a href=""https://github.com/Qiskit/qiskit-ibmq-provider/blob/e09ff2e66447b545b8ff62a1120fb31b515f1015/qiskit/providers/ibmq/managed/managedjob.py#L97"" rel=""nofollow noreferrer"">_async_submit</a>:</p>
<pre><code>def _async_submit(
    self,
    circuits: Union[QuantumCircuit, Schedule, List[Union[QuantumCircuit, Schedule]]],
    job_name: str,
    backend: IBMQBackend,
    submit_lock: Lock,
    job_tags: Optional[List[str]] = None,
    **run_config: Dict
) -&gt; None:
    &quot;&quot;&quot;Run circuits asynchronously and populate instance attributes.
    Args:
        circuits: Circuits to run.
        job_name: Name of the job.
        backend: Backend to execute the experiments on.
        submit_lock: Lock used to synchronize job submission.
        job_tags: Tags to be assigned to the job.
        **run_config: Extra arguments used to configure the run.
    &quot;&quot;&quot;
</code></pre>
<p>It doesn't seem to be the case that the order in which circuits are executed necessarily matches the order in which they are specified. However, you should be able to find the mechanism that dicates execution / submission order by following the <a href=""https://github.com/Qiskit/qiskit-ibmq-provider/blob/e09ff2e66447b545b8ff62a1120fb31b515f1015/qiskit/providers/ibmq/managed/ibmqjobmanager.py#L87"" rel=""nofollow noreferrer"">IBMQJobManager.run</a> bread trail that I've started to layout above.</p>
",7/25/2022 15:09,Tooling,"The question is asking about how the execute function in Qiskit works, which is a tooling question",Tooling,,,,Tooling,
27465.0,Is there any way to always output |1> if the measurement has a probability to output 1?,"<p>Let's say I have an oracle that outputs 1 on a specific input (there can be multiple inputs x so that f(x)=1), else it outputs 0.</p>
<p>If there is no such input so that f(x)=1, the quantum state of the output qubit will always be |0&gt;</p>
<p>Is there a way so, that if the output state is not |0&gt;, one can manipulate the qubit state as such that it transforms to |1&gt;?</p>
",<programming><quantum-state>,7/25/2022 10:57,27466.0,27466.0,"<p>Not sure if I got your question exactly, so I reformulate it first. Assume some algorithm produces a state
<span class=""math-container"">$$|\psi\rangle=\alpha |0\rangle+\beta|1\rangle.$$</span>
It seems to me you are asking if there is a procedure to say if <span class=""math-container"">$\beta=0$</span> or not, i.e. if <span class=""math-container"">$|\psi\rangle$</span> is orthogonal to <span class=""math-container"">$|1\rangle$</span> or not. In other words, you want to discriminate two quantum states <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle=|0\rangle$</span>. If you only have a single copy of <span class=""math-container"">$|\psi\rangle$</span> the answer is no, you can not do this with certainty.</p>
<p>Even if you know that the algorithm either produces <span class=""math-container"">$|\phi\rangle=|0\rangle$</span> or <span class=""math-container"">$|\psi\rangle$</span> (with known <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span>) the best you can do is to  tell them apart with with probability <span class=""math-container"">$1-|\langle\psi|\phi\rangle|$</span> <a href=""https://en.wikipedia.org/wiki/POVM#An_example:_unambiguous_quantum_state_discrimination"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/POVM#An_example:_unambiguous_quantum_state_discrimination</a>. Note that when the states are orthogonal <span class=""math-container"">$\langle\psi|\phi\rangle=0$</span> they can be discriminated with certainty.</p>
",7/25/2022 11:19,Conceptual,"The question is asking about a conceptual problem in quantum computing, namely how to manipulate a qubit state to transform it to ?1? given an oracle that outputs 1 on a specific input and 0 otherwise.",Conceptual,,,,Conceptual,
27546.0,CCCRY gate creation,"<p>I'm aware there's a few questions about CCCRY gate composition on here but I still have a few questions. I'm following Frank Zickert's book on qiskit and he has defined a CCRY gate as</p>
<pre><code>def ccry(qc, theta, control1, control2, controlled):
    qc.cry(theta/2, control2, controlled)
    qc.cx(control1, control2)
    qc.cry(-theta/2, control2, controlled)
    qc.cx(control1, control2)
    qc.cry(theta/2, control1, controlled)
</code></pre>
<p>This makes sense to me given the circuit diagram of what's going on:
<a href=""https://i.stack.imgur.com/WAgix.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WAgix.png"" alt=""enter image description here"" /></a></p>
<p>Taking Zickert's approach, could I construct a CCCRY gate? I'm aware I'm now needing 3 control qubits but I'm struggling beyond that. I did also see another answer that used <code>CCCRY = RYGate(a).control(3)</code> but I don't know how to implement that because I haven't been using <code>qc.append()</code>. For those unfamiliar with his book, it's going through the Titanic dataset and using qubits for ML; I wanted to try and add another category which means going from a CCRY gate to a CCCRY gate.</p>
<p>Thank you!</p>
",<qiskit><programming><quantum-gate><circuit-construction>,7/30/2022 15:44,27551.0,27551.0,"<p>Here is how to create and append <span class=""math-container"">$CCCRY(\theta)$</span>:</p>
<pre><code>from numpy import pi
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.circuit.library import RYGate

theta = Parameter('theta')
CCCRY = RYGate(theta).control(3)

circuit = QuantumCircuit(4)
circuit.append(CCCRY, [0,1,2,3])
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/rGi4g.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rGi4g.png"" alt=""CCCRY"" /></a></p>
",7/30/2022 20:52,Conceptual, The user is seeking a conceptual understanding of how to construct a CCCRY gate based on the provided definition of a CCRY gate and is also exploring the possibility of implementing it in the context of a specific book's tutorial. This question pertains to understanding quantum gate composition and circuit construction.,Conceptual,,,,Conceptual,
27611.0,Jupyter Notebook not rendering latex code,"<p>Working through the Qiskit text and came across this bit of coding on the density matrix <a href=""https://learn.qiskit.org/course/quantum-hardware/density-matrix"" rel=""nofollow noreferrer"">page</a>:</p>
<pre><code>psi_AB.draw('latex', prefix='|\\psi_{AB}\\rangle = ')
</code></pre>
<p>which is supposed to produce... <span class=""math-container"">$$|\psi_{AB}\rangle = 1/\sqrt{2}(|00\rangle +|11\rangle)$$</span>  However, it seems that the prefix as a part of the .draw() no longer works to create this output so I am attempting to write the the <span class=""math-container"">$|\psi_{AB}\rangle = $</span> portion just as I have done here.  The problem is that this is not working in Jupyter notebook and I am not sure what I could be doing wrong.</p>
<p>I've tried single and double $'s.I've tried single and double quotations.  I've attempted to use display() and print().  No matter what I try I end up with syntax errors that indicate the dollar signs as the issue or it prints |\psi_{AB}\rangle = without converting to latex.  Any help with this coding issue would be appreciated!</p>
<p><strong>Edit:</strong>
I have run an update on my qiskit and everything now works exactly how it does on the Density matrix page in the qiskit text.  They have errors with the prefix in the Statevector and so do I.  The page is just to emphasize where the code came from.  The real problem is that writing 'DollarSign x=5 DollarSign' in my Jupyter notebook does not change it to the latex <span class=""math-container"">$x=5$</span> as it does here.  Instead I get a syntax error indicating the first dollar sign.  Perhaps there is something I need to import to make this feature work?</p>
<p><strong>Edit 2.0</strong>
Pylatexenc has been properly installed and is up to date.
I've figured out how to get the markdown to work when I wish to simply type text.  I now feel that the error is in the <a href=""https://qiskit.org/documentation/stable/0.35/_modules/qiskit/visualization/state_visualization.html"" rel=""nofollow noreferrer"">source coding</a> for qiskit.quantum_info.Statevector.draw. I believe this function is not correctly creating the prefix because the coding, as seen below, does not allow for prefix as an arguement.</p>
<pre><code>operator_shape = state._op_shape
    # we only use the ket convetion for qubit statevectors
    # this means the operator shape should hve no input dimensions and all output dimensions equal to 2
    is_qubit_statevector = len(operator_shape.dims_r()) == 0 and set(operator_shape.dims_l()) == {2}
    if convention == &quot;ket&quot; and is_qubit_statevector:
        latex_str = _state_to_latex_ket(state._data)
    else:
        latex_str = array_to_latex(state._data, source=True, **args)
    return prefix + latex_str + suffix
</code></pre>
<p>As seen in the excerpt above the _state_to_latex_ket() does not allow for any arguments other than the state data which would be why it continues to give me errors no matter how I type the prefix in!</p>
<p>If I am correct, then this renders my question moot!  Thank you for your help!</p>
",<qiskit><programming><textbook-and-exercises>,08/03/2022 14:22,29013.0,29013.0,"<p>This issue is now resolved as of release <a href=""https://github.com/Qiskit/qiskit-terra/releases/tag/0.22.0"" rel=""nofollow noreferrer"">Qiskit Terra 0.22.0</a>.</p>
<p>See merged <a href=""https://github.com/Qiskit/qiskit-terra/pull/8461"" rel=""nofollow noreferrer"">Fix _state_to_latex_ket prefix kwarg bug #8461</a>.</p>
<p>The Qiskit textbook version has also been updated, so the cell you referenced should now work as expected!</p>
<p><a href=""https://i.stack.imgur.com/CACka.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CACka.png"" alt=""enter image description here"" /></a></p>
",11/16/2022 16:06, Errors,The user is encountering syntax errors while trying to use LaTeX in Jupyter notebook and believes there might be an issue with the source code of the qiskit.quantum_info.Statevector.draw function. , Errors,,,, Errors,
27739.0,How to initialize my circuit with two random complex numbers?,"<p>Working through <a href=""https://learn.qiskit.org/course/ch-labs/lab-3-quantum-measurements"" rel=""nofollow noreferrer"">Lab 3</a> in the Qiskit text, I have been attempting to initialize my one qubit circuit with two random numbers.  My first attempt, as directed, is using <code>.initialize</code> function, but I keep getting an error:'Sum of amplitudes-squared does not equal one.'</p>
<p>My code</p>
<pre><code>qc = QuantumCircuit(1)

#### your code goes here
#Create random initial state
SignChoice=[1,-1]
a=random.choice(SignChoice)*random.random()
b=random.choice(SignChoice)*random.random()
p=complex(a,b)
q=np.sqrt(1-p**2)
initial_state = [p,q]  # Define state |q_0&gt;
qc.initialize(initial_state, 0) # Initialise the 0th qubit in the state `initial_state`
</code></pre>
<p>In attempting to fix this error I have used the code below to see my amplitudes and the sum of their squares and though I can see that rounding may sometimes be an issue, it does often result in exactly 1+0j, which leaves me wondering why it will not initialize!</p>
<pre><code>print(p,q,p**2+q**2)
</code></pre>
<p>My second attempt will be with
<code>random_statevector</code>,
but I have not yet completed it.</p>
",<qiskit><programming><textbook-and-exercises>,08/11/2022 14:56,27742.0,27742.0,"<p>You can do it slightly different and then you will have no error.
Generate 4 random numbers instead of 2, and set <code>q</code> in the same way as <code>p</code>.
Then you can compute the <code>norm</code> of <code>p</code> and <code>q</code> using <code>np.linalg.norm()</code> method and set <code>initial_state</code> to be a list of <code>p</code> and <code>q</code> divided by the norm.</p>
<p>Here's the code fixed:</p>
<pre><code>qc = QuantumCircuit(1)

#### your code goes here
#Create random initial state
SignChoice = [1,-1]

a=random.choice(SignChoice)*random.random()
b=random.choice(SignChoice)*random.random()
c=random.choice(SignChoice)*random.random()
d=random.choice(SignChoice)*random.random()

p=complex(a,b)
q=complex(c,d)
amplitudes = [p,q]
norm = np.linalg.norm(amplitudes)

initial_state = amplitudes/norm  # Define state |q_0&gt;
qc.initialize(initial_state, 0) # Initialise the 0th qubit in the state `initial_state`
</code></pre>
",08/11/2022 15:30,Errors,"The user is getting an error when trying to initialize a qubit with two random numbers using the initialize() function. The error message indicates that the sum of the amplitudes-squared is not equal to one. This is an error-related question, as the user is seeking to resolve an error that they are encountering.",Errors,,,,Errors,
27757.0,Partial Measurement in AWS Braket,"<p>Is there a way to do partial Measurement in AWS Braket? Basically, if I have a circuit with <span class=""math-container"">$N$</span> qubits, can I measure only <span class=""math-container"">$n$</span> qubits out of them with the result type &quot;expectation&quot;?</p>
",<programming><amazon-braket>,08/12/2022 20:39,27759.0,27759.0,"<p>Physically, there is currently no way to perform a partial measurement (on hardware in particular, all qubits are measured); you'll have to slice out the unwanted qubits if you're using raw measurements directly. As for result types, you can definitely measure the expectation of an observable on only a subset of qubits:</p>
<pre><code>from braket.circuits import Circuit, observables
from braket.devices import LocalSimulator

dev = LocalSimulator()
circ = Circuit().h(0).cnot(0, 1).cnot(1, 2).expectation(observables.Z() @ observables.Z(), [0, 2])
dev.run(circ).result().values
</code></pre>
<pre><code>[1.0]
</code></pre>
",08/12/2022 23:04,Tooling,"The question is asking about how to use a specific tool, the AWS Braket SDK, to achieve a specific goal, partially measuring a quantum circuit.",Tooling,,,,Tooling,
27803.0,Is there a tutorial for error mitigation in qiskit that does not use the deprecated ignis?,"<p>Working through the qiskit text I have come accross measurement error mitigation a few times (<a href=""https://learn.qiskit.org/course/quantum-hardware/measurement-error-mitigation"" rel=""nofollow noreferrer"">Measurement Error Mitigation</a>, <a href=""https://learn.qiskit.org/course/ch-labs/lab-3-quantum-measurements"" rel=""nofollow noreferrer"">Lab 3: Quantum Measurment</a>,...].  In the online textbook the coding indicates the use of <code>.ignis</code>, but I understand it has been deprecated and replaced with new modules as described <a href=""https://github.com/Qiskit/qiskit-ignis"" rel=""nofollow noreferrer"">here</a>, but the use of those modules has not yet been adapted within the textbook.</p>
<p>I'm interested in learning how to use this error mitigation, but am not yet knowledgeable enough to figure this out without a tutorial/lesson/introduction of some sort.  Is anyone aware of a document, video, website, ... that could help me learn this content using non-deprecated coding?  Or has anyone completed these modules and is willing to share how it was done in order for me to learn from their example?  Any help or guidance would be appreciated.</p>
",<qiskit><programming><ibm-q-experience><textbook-and-exercises><error-mitigation>,8/16/2022 13:46,31501.0,31501.0,"<p><a href=""https://qiskit.org/ecosystem/experiments/manuals/measurement/readout_mitigation.html"" rel=""nofollow noreferrer"">Here</a> is an up-to-date tutorial on measurement error mitigation using Qiskit experiments module which (partly) replaces Qiskit Ignis.</p>
<p>Furthermore, if you are using Qiskit Runtime primitives, you have now the option of enabling error mitigation very easily using <code>resilience_level</code>. <a href=""https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/error-mitigation.html"" rel=""nofollow noreferrer"">Here</a> is the documentation.</p>
",03/06/2023 05:03,Learning,"The user is seeking learning resources, tutorials, and references to understand how to use measurement error mitigation in Qiskit, especially with the updated modules that have replaced the deprecated .ignis.",Learning,,,,Learning,
27838.0,How to extract per shots measurement result from ionq device using qiskit_braket_provider?,"<p>I'm running a circuit on <code>ionq device</code> using <code>qiskit_braket_provider</code>. I want to extract per shot measurement results. While running on <code>IBMQ backends</code>, it can be accessed by setting <code>memory=True</code> in execute function and then running <code>job.result().get_memory(qc)</code>. I'm trying to similar thing for <code>ionq device</code>, but getting the following error.</p>
<p><strong>Code:</strong></p>
<pre><code>job = ionq.run(tqc,shots=1024,memory=True)
job.status()
job.wait_for_final_state()
result = job.result()
m = job.result().get_memory(tqc)
print(m)
</code></pre>
<p><strong>Error:</strong></p>
<pre><code>---------------------------------------------------------------------------
QiskitError                               Traceback (most recent call last)
Input In [70], in &lt;cell line: 1&gt;()
----&gt; 1 m = job.result().get_memory(tqc)
      2 m

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/result/result.py:217, in Result.get_memory(self, experiment)
    191 def get_memory(self, experiment=None):
    192     &quot;&quot;&quot;Get the sequence of memory states (readouts) for each shot
    193     The data from the experiment is a list of format
    194     ['00000', '01000', '10100', '10100', '11101', '11100', '00101', ..., '01010']
   (...)
    215         QiskitError: if there is no memory data for the circuit.
    216     &quot;&quot;&quot;
--&gt; 217     exp_result = self._get_experiment(experiment)
    218     try:
    219         try:  # header is not available

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/result/result.py:380, in Result._get_experiment(self, key)
    373 exp = [
    374     result
    375     for result in self.results
    376     if getattr(getattr(result, &quot;header&quot;, None), &quot;name&quot;, &quot;&quot;) == key
    377 ]
    379 if len(exp) == 0:
--&gt; 380     raise QiskitError('Data for experiment &quot;%s&quot; could not be found.' % key)
    381 if len(exp) == 1:
    382     exp = exp[0]

QiskitError: 'Data for experiment &quot;circuit-7034&quot; could not be found.'
</code></pre>
<p><em><strong>One more thing</strong></em>, how to extract execution time for job on <code>ionq device</code>? In <code>IBMQ</code> simply <code>job.result().time_taken</code> returns it.</p>
",<qiskit><programming><ibm-q-experience><amazon-braket><ionq>,8/18/2022 8:47,27854.0,27854.0,"<p>From what I can tell, this information isn't available from the provider because the <code>header</code> parameter <a href=""https://github.com/qiskit-community/qiskit-braket-provider/blob/main/qiskit_braket_provider/providers/braket_job.py#L52-L57"" rel=""nofollow noreferrer"">isn't supplied</a> to the <code>ExperimentResult</code> constructor. This might be worth submitting an <a href=""https://github.com/qiskit-community/qiskit-braket-provider/issues"" rel=""nofollow noreferrer"">issue</a> or PR for!</p>
<p>In the meantime, you can get per-shot results by getting the Amazon Braket task result directly:</p>
<pre><code>from braket.aws import AwsQuantumTask
task = AwsQuantumTask(job.job_id())
measurements = task.result().measurements
</code></pre>
",8/18/2022 20:46,Errors, The user is encountering an error while trying to extract per shot measurement results and execution time from a quantum circuit run on an IonQ device using the qiskit_braket_provider,Errors,,,,Errors,
27867.0,Qiskit: Can I run real experiments in QPUs with OOP structured code?,"<p>The question might be naive, but I'm hesitant to design my algorithm in a complex, Object-Oriented scheme (custom classes, objects etc.). My fear is that current frameworks (e.g. ibmq, qiskit-runtime) don't support it.</p>
<p>Is this the case? Can I verify/reject this?</p>
",<qiskit><programming><ibm-q-experience><python>,8/20/2022 11:01,27874.0,27874.0,"<p>You can consider Qiskit as a classical <em>interface</em> between QPU and classical computer. You use classical programming language to prepare quantum circuit. Before sending the circuit to QPU you are still in classical world and you can do anything Python allows - use all other Python libraries, connect to SQL databases or other data sources etc. Even if you call already prepared algorithms from Qiskit libraries you do so classically. Once you call procedure for running the computation on QPU, your algorithm is transpiled to native quantum gates of particular QPU. This is also classical process. Only after that (again classical) electronic set up QPU and run the algorithm in <em>quantum world</em>. After measurement, you receive classical data and you can post-process them in Qiskit, again classically.</p>
<p>To sum up, you can use any programming paradigm supported by Python. From your point of view, everything is done classically and QPU is just a device controlled by your classical program using Qiskit libraries.</p>
",8/21/2022 6:40,API Usage,"The user is asking about the compatibility of complex, Object-Oriented programming schemes with quantum computing frameworks like IBM Q and Qiskit Runtime, which falls under the discussion of how to correctly and effectively use APIs in quantum programming.",Tooling,"The users question is about the compatibility of object-oriented programming with quantum computing frameworks like IBM Q and Qiskit Runtime, which falls under the Tooling category.",No,127.0,API Usage,"The user is specifically asking about the compatibility of Object-Oriented programming schemes with quantum computing frameworks like IBM Q and Qiskit Runtime, which aligns with understanding how to correctly use APIs in quantum programming."
27993.0,Quantum Computing Daily Practice / Quiz platform,"<p>I am looking for a platform where I can solve quizzes and programming / algorithmic challenges related to quantum computation and information.</p>
<p>To be more specific, I am looking for a platform that is analogous to LeetCode, Codeforces, Kaggle, CodePen, etc. but for the domain of quantum computing.</p>
<p>It would be really helpful if someone could direct me toward such a platform. Thanks!</p>
",<programming><algorithm>,8/31/2022 7:45,27995.0,27995.0,"<p>Short answer: Last time I checked, there was not any DAILY-basis automatic training platform for quantum SDK.</p>
<p><a href=""https://qiskit.org/learn/"" rel=""nofollow noreferrer"">Qiskit Learn</a> list a vast array of documentation, including videos and Summer School content. The <a href=""https://qiskit.org/textbook/content/ch-ex/"" rel=""nofollow noreferrer"">Qiskit textbook</a> is an interactive guide on how to use Qiskit, specially if you know already some of the algorithms but do not know how to code them in this language. Qiskit community also makes twice-per-year challenges and a summer school every year where you can train your coding skills.</p>
<p><a href=""https://qworld.net/"" rel=""nofollow noreferrer"">QWorld</a> also organises online schools, that are evaluated on online coding challenges using Qiskit and cirq.</p>
<p>QWorld and Qiskit challenges use an automatic platform that automatically evaluates if your code is right.</p>
<p>Another thing that might need a mention are <a href=""https://docs.microsoft.com/en-us/azure/quantum/tutorial-qdk-intro-to-katas"" rel=""nofollow noreferrer"">quantum katas</a> in Microsoft Q#, which are short exercises (with solutions) that are related to important quantum routines that you should master. Some can be run directly on mybinder.org.</p>
<p>Finally, the <a href=""https://qosf.org/"" rel=""nofollow noreferrer"">Quantum Open Source Foundation</a> (QOSF) has a big list of resources you can check. They also have a mentoring program and monthly challenges if you are up for more regular training. If there is another platform that is closer to what you are looking for, it is definetely listed in <a href=""https://qosf.org/learn_quantum/"" rel=""nofollow noreferrer"">QOSF resource list</a>.</p>
",8/31/2022 12:22,Learning ,"The user is seeking learning resources, specifically a platform for solving quizzes and programming challenges related to quantum computation and information. ",Learning ,,,,Learning ,
28050.0,How does the Active Space Transform work theoretically?,"<p>I have a question about the ActiveSpaceTransformer which is used in vqe calculations for a molecule of LiH in Qiskit. In the documentation the inactive Fock operator is defined.I don't understand why is the inactive Fock operator defined in that way, what is his physical meaning? Then, Why are we substituting the one body integral with the inactive Fock operator in the original hamiltonian?</p>
",<qiskit><programming><hamiltonian-simulation><vqe><chemistry>,09/04/2022 07:38,28060.0,28060.0,"<p>The inactive Fock operator is the outcome of downfolding the inactive orbitals into the active space. This is explained in quite some detail in various quantum chemistry textbooks. A short summary of it can be found in the paper this is linked by the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.transformers.second_quantization.electronic.ActiveSpaceTransformer.html"" rel=""nofollow noreferrer"">ActiveSpaceTransformer documentation page</a>, namely <a href=""https://arxiv.org/abs/2009.01872"" rel=""nofollow noreferrer"">this preprint</a>. You will want to look at section II.A in particular. It also contains further references with lengthier explanations.</p>
",09/05/2022 06:37,Theoretical,"The question pertains to understanding the theoretical aspects of quantum chemistry and VQE calculations, specifically regarding the ActiveSpaceTransformer and the definition of the inactive Fock operator, as well as the substitution of the one-body integral in the original Hamiltonian.",Theoretical,,,,Theoretical,
28123.0,How to represent a statevector in Dirac notation form using Qiskit?,"<p>I am learning from qiskit textbook, and I was wondering how may I get a statevector of the following form:</p>
<p><span class=""math-container"">$$ \frac{\sqrt{2}}{2}|00\rangle + \frac{\sqrt{2}}{2}|10\rangle $$</span></p>
<p>If I run code for this in jupyter notebook then it shows completely different way to visualize this statevector. How can I represent a statevector like this?</p>
",<qiskit><programming><quantum-gate><quantum-state><entanglement>,09/11/2022 04:28,28124.0,28124.0,"<p>Use <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.draw.html"" rel=""noreferrer""><code>draw</code></a> method with <code>output</code> parameter set to <code>latex</code></p>
<pre><code>from qiskit.quantum_info import Statevector
import numpy as np

sv = Statevector([1 / np.sqrt(2), 0, 1 / np.sqrt(2), 0])
sv.draw(output = 'latex')

# Or simply,
# sv.draw('latex')
</code></pre>
",09/11/2022 05:50,Learning,"The user is seeking guidance on how to represent and visualize a specific statevector in Qiskit, as they are following the Qiskit textbook for learning purposes. This question pertains to learning resources and techniques for working with quantum states in Qiskit.",Learning,,,,Learning,
28152.0,Insufficient memory to run circuit using the statevector simulator,"<p>I am a newbie to quantum and have been trying <code>qiskit</code> library for learning quantum computing (in order to explore quantum effects on cryptography). I am basically trying to build Grover Oracle for different symmetric key algorithms. For this I am learning various operations mostly performed by these algos in classical counterparts like <code>XOR</code>, <code>Bit Shift</code>, <code>Addition</code> and <code>Modulo</code> operations etc.</p>
<p>I have created a 4 bit circuit for Full Adder in qiskit and extended it to 8 qbits. But when I am trying it for 12 bits, it raises above error</p>
<pre><code>Simulation failed and returned the following error message:
ERROR:  [Experiment 0] Insufficient memory to run circuit circuit-584 using the statevector simulator. Required memory: 67108864M, max memory: 32712M
QiskitError: 'Data for experiment &quot;circuit-584&quot; could not be found.'
</code></pre>
<p>I have written a simple quantum implementation of Full Adder and this Error arises when I try to measure the result.</p>
<pre><code>length=12

a = QuantumRegister(length)
b = QuantumRegister(length)
s = QuantumRegister(length)
aux = QuantumRegister(length)

cout = QuantumRegister(1)
cin = QuantumRegister(1)


result = ClassicalRegister(length+1)

input1 = 0xa82
input2 = 0x905

circ=QuantumCircuit(a,b,cin,s,cout,result,aux)

Round_constant_XOR(circ,input1,a,length) # Copying input1 to a
Round_constant_XOR(circ,input2,b,length) # Copying input2 to b 

full_adder(circ,a,b,cin,length,s,cout)

#circ.draw(output='mpl')
print(&quot;Operations Completed, now measuring qbits\n&quot;)
for i in range(length):
    circ.measure(s[i],result[i])
circ.measure(cout,result[length])

simulator1 = AerSimulator(method='statevector')
results1 = execute(circ,backend=simulator1).result()
print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
plot_histogram(results1.get_counts(circ))
</code></pre>
<p>Complete Error is</p>
<pre><code>---------------------------------------------------------------------------
QiskitError                               Traceback (most recent call last)
C:\PROGRA~1\KMSpico\temp/ipykernel_12724/2309521244.py in &lt;module&gt;
     31 simulator1 = AerSimulator(method='statevector')
     32 results1 = execute(circ,backend=simulator1).result()
---&gt; 33 print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
     34 plot_histogram(results1.get_counts(circ))

~\anaconda3\lib\site-packages\qiskit\result\result.py in get_counts(self, experiment)
    267         dict_list = []
    268         for key in exp_keys:
--&gt; 269             exp = self._get_experiment(key)
    270             try:
    271                 header = exp.header.to_dict()

~\anaconda3\lib\site-packages\qiskit\result\result.py in _get_experiment(self, key)
    378 
    379             if len(exp) == 0:
--&gt; 380                 raise QiskitError('Data for experiment &quot;%s&quot; could not be found.' % key)
    381             if len(exp) == 1:
    382                 exp = exp[0]
</code></pre>
<p>Does the problem lie in number of qbits simulator is able to handle or anything else. As I eventually want to perform different operations for at least 128 qbits registers in order to simulate practical symmetric algos.</p>
",<qiskit><programming><grovers-algorithm><simulation><oracles>,9/13/2022 6:29,28158.0,28158.0,"<p>I changed the <a href=""https://quantum-computing.ibm.com/services/resources?tab=simulators"" rel=""nofollow noreferrer"">simulator</a> provided by IBM according to my current need (qbits=50)</p>
<pre><code>simulator1 = AerSimulator(method='matrix_product_state')
</code></pre>
<p>It worked.</p>
",9/13/2022 10:19,Errors,The user is getting an error when trying to simulate a 12-qubit circuit using the statevector simulator. This is an error question,Errors,,,,Errors,
28173.0,"get.statevector() error: Failed to load qobj: Duplicate key ""statevector"" in save instruction","<p>I'm building a mini tutorial to introduce the construction of composite systems using qiskit.  While doing so I am demonstrating multiple ways to construct and view the statevector, but I have come across an error which I'm hoping to circumvent.</p>
<p>In the initial cells I have created and displayed a simple two qubit circuit, qc, with Hadamard gates on each qubit.  I then have the following two cells to show two different ways to simulate and display the resulting statevector.</p>
<pre><code>svsim = Aer.get_backend('aer_simulator')
qc.save_statevector()
qobj = assemble(qc)
final_state = svsim.run(qobj).result().get_statevector()

#Now to display it
from qiskit.visualization import array_to_latex
array_to_latex(final_state, prefix=&quot;|\psi^{AB} \\rangle = &quot;)
</code></pre>
<p>The second version is</p>
<pre><code>from qiskit import execute
backend=Aer.get_backend('statevector_simulator')
result=execute(qc,backend).result()
out_state=result.get_statevector()
array_to_latex(out_state, prefix=&quot;|\psi^{AB} \\rangle = &quot;)
</code></pre>
<p>Individually they both work to display an identical statevector, but running them in sequence gives the error: Failed to load qobj: Duplicate key &quot;statevector&quot; in save instruction..  My understanding is that even though my second one does not explicitly use <code>save_statevector()</code>, it still saves it as a part of the source coding.  As a result I then have two statevectors saved and I need to somehow specify which one I am wanting to 'get'?</p>
<p>I've tried specifying an experiment in my second <code>get_statevector()</code> by using <code>experiment=</code> as a parameter, but nothing I've set it equal to has worked.  Any ideas?</p>
<p>Note: I do know that if I simply switch the order of these it will work as the <code>save_statevector()</code> will update to just the one that has been saved preventing the error, but I'm hoping there might be another way to do this either by applying another <code>save_statevector()</code> in the second input cell, or perhaps by somehow specifying the <code>experiment =</code> accurately.</p>
",<qiskit><programming>,9/14/2022 16:35,28174.0,28174.0,"<p>When you call <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.save_statevector.html"" rel=""nofollow noreferrer""><code>save_statevector()</code></a> method to add <code>SaveStatevector</code> instruction to your circuit, you can specify a label. After circuit execution, the <code>Statevector</code> will be saved to <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.data.html"" rel=""nofollow noreferrer""><code>Result.data</code></a> dictionary where the key will be that label. If you don't specify a label, <code>statevector</code> will be used by default.</p>
<p>And when you simulate your circuit using <code>statevector_simulator</code>, the result will be saved, similarly, to <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.data.html"" rel=""nofollow noreferrer""><code>Result.data</code></a> dictionary. The key this time also will be <code>statevector</code>.</p>
<p>Clearly, this will cause an issue if you add <code>SaveStatevector</code> instruction to your circuit then use <code>statevector_simulator</code> to execute it.
A simple workaround is to call <code>save_statevector()</code> with a label:</p>
<pre><code>qc.save_statevector(label = 'sv')
</code></pre>
<p>then retrieve the value using this label:</p>
<pre><code>final_state = svsim.run(qobj).result().data()['sv']
</code></pre>
",9/15/2022 6:25,Errors ,"The user is encountering an error message while trying to display the statevector of a quantum circuit in Qiskit using two different methods, and is seeking solutions and explanations for this issue. ",Errors ,,,,Errors ,
28194.0,AttributeError: 'list' object has no attribute 'values',"<p>While implementing a code, getting the below error:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
&lt;ipython-input-22-d35ba980e0c5&gt; in &lt;module&gt;
     23     optimizer.zero_grad()
     24 
---&gt; 25     output = model(X_tr)
     26     optimizer.zero_grad()
     27     loss = loss_func(output)

~\anaconda3\lib\site-packages\torch\nn\modules\module.py in _call_impl(self, *input, **kwargs)
    887             result = self._slow_forward(*input, **kwargs)
    888         else:
--&gt; 889             result = self.forward(*input, **kwargs)
    890         for hook in itertools.chain(
    891                 _global_forward_hooks.values(),

&lt;ipython-input-20-fe528190183d&gt; in forward(self, x)
     13 
     14     def forward(self,x):
---&gt; 15         h = self.f(x)
     16         return self.g(h)

~\anaconda3\lib\site-packages\torch\nn\modules\module.py in _call_impl(self, *input, **kwargs)
    887             result = self._slow_forward(*input, **kwargs)
    888         else:
--&gt; 889             result = self.forward(*input, **kwargs)
    890         for hook in itertools.chain(
    891                 _global_forward_hooks.values(),

&lt;ipython-input-18-f3b96ecb25f3&gt; in forward(self, x)
     34         x = self.fc(x[:, -1, :])
     35         # out.size() --&gt; 100, 10
---&gt; 36         x = self.hybrid(x)
     37         return T.cat((x, 1 - x), -1)

~\anaconda3\lib\site-packages\torch\nn\modules\module.py in _call_impl(self, *input, **kwargs)
    887             result = self._slow_forward(*input, **kwargs)
    888         else:
--&gt; 889             result = self.forward(*input, **kwargs)
    890         for hook in itertools.chain(
    891                 _global_forward_hooks.values(),

&lt;ipython-input-6-f66b87fe8d6c&gt; in forward(self, input)
     42 
     43     def forward(self, input):
---&gt; 44         return HybridFunction.apply(input, self.quantum_circuit, self.shift)

&lt;ipython-input-6-f66b87fe8d6c&gt; in forward(ctx, input, quantum_circuit, shift)
      8         ctx.quantum_circuit = quantum_circuit
      9 
---&gt; 10         expectation_z = ctx.quantum_circuit.run(input[0].tolist())
     11         result = torch.tensor([expectation_z])
     12         ctx.save_for_backward(input, result)

&lt;ipython-input-4-39b4287471c5&gt; in run(self, thetas)
     30         result = job.result().get_counts()
     31 
---&gt; 32         counts = np.array(list(result.values()))
     33         print('counts', counts)
     34         print('result.values', result.values())

AttributeError: 'list' object has no attribute 'values'
</code></pre>
<p>But the output of result after printing is:</p>
<pre><code>RESULT [{'1': 49, '0': 51}, {'1': 58, '0': 42}, {'1': 48, '0': 52}, {'0': 53, '1': 47}, {'0': 51, '1': 49}, {'0': 51, '1': 49}, {'1': 58, '0': 42}, {'0': 47, '1': 53}, {'1': 54, '0': 46}, {'0': 47, '1': 53}, {'0': 41, '1': 59}, {'0': 52, '1': 48}, {'1': 47, '0': 53}, {'1': 52, '0': 48}, {'0': 52, '1': 48}, {'1': 50, '0': 50}, {'0': 41, '1': 59}, {'1': 54, '0': 46}, {'1': 55, '0': 45}, {'1': 44, '0': 56}, {'1': 61, '0': 39}, {'1': 53, '0': 47}, {'0': 40, '1': 60}, {'1': 59, '0': 41}, {'0': 60, '1': 40}, {'0': 56, '1': 44}, {'1': 46, '0': 54}, {'0': 46, '1': 54}, {'0': 53, '1': 47}, {'1': 52, '0': 48}, {'0': 49, '1': 51}, {'1': 55, '0': 45}, {'1': 51, '0': 49}, {'1': 48, '0': 52}, {'0': 53, '1': 47}, {'0': 56, '1': 44}, {'1': 53, '0': 47}, {'0': 51, '1': 49}, {'0': 45, '1': 55}, {'1': 47, '0': 53}, {'1': 55, '0': 45}]
</code></pre>
",<qiskit><programming><quantum-gate>,9/16/2022 17:00,28195.0,28195.0,"<p><a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.get_counts.html"" rel=""nofollow noreferrer""><code>Result.get_counts()</code></a> method returns a dictionary if the <code>Job</code> contains only one circuit. If, however, your job contains multiple circuits, it will return a list of dictionaries.</p>
<p>To avoid this issue, you will need to either specify the circuit index:</p>
<pre><code># Counts of the first circuit:
result = job.result().get_counts(0)
</code></pre>
<p>or loop over the circuits:</p>
<pre><code>for _dict in job.result().get_counts():
    print(_dict)
</code></pre>
",9/16/2022 18:11,Errors,"The user is getting an AttributeError because the result of their quantum circuit is a list, and lists do not have a values() attribute.",Errors,,,,Errors,
28261.0,ModuleNotFoundError: No module named 'qiskit_aer',"<p>I am trying to perform some noise simulations using the <a href=""https://qiskit.org/documentation/apidoc/aer_provider.html"" rel=""nofollow noreferrer"">Aer Provider</a>. I read through a tutorials <a href=""https://qiskit.org/documentation/apidoc/aer_noise.html#custom-noise-models"" rel=""nofollow noreferrer"">here</a>, but I am not able to really implement the <code>qiskit_aer</code>. When I tried <code>import qiskit_aer.noise as noise</code>, it shows me the error message <code>ModuleNotFoundError: No module named 'qiskit_aer'</code>. I tried <code>pip install qiskit_aer</code> but it returns <code>Requirement already satisfied</code>. How can I implement this module? Thanks!</p>
",<qiskit><programming>,9/22/2022 19:38,28263.0,28263.0,"<p>The namespace <code>qiskit_aer</code> was introduced in 0.11. Try <code>pip install &quot;qiskit-aer&gt;=0.11.0&quot;</code> or <code>pip install -U qiskit-aer</code>.</p>
",9/23/2022 4:59, Errors,The user is encountering an error message stating ModuleNotFoundError: No module named qiskit_aer while trying to import the qiskit_aer module for noise simulations using the Aer Provider in Qiskit, Errors,,,, Errors,
28267.0,get_statevector() not working with Qiskit Aer's statevector simulator,"<p>I'm trying to understand how result.get_statevector() works.</p>
<p>Using BasicAer, the following code gives the result for the statevector:</p>
<p><code>[0.70710678+0.j 0.        +0.j 0.        +0.j 0.70710678+0.j]</code></p>
<p>which is fine.</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer, BasicAer

circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cnot(0, 1)

#simulator = Aer.get_backend('aer_simulator_statevector')
simulator = BasicAer.get_backend('statevector_simulator')

result = simulator.run(transpile(circuit, simulator)).result()

psi = result.get_statevector(circuit)
</code></pre>
<p>But when I try it with the corresponding statevector simulator in Aer,
it gives the error:</p>
<p><code>QiskitError: 'No statevector for experiment'</code></p>
<p>I'm not sure why this is not working.</p>
",<qiskit><programming>,9/24/2022 4:45,28269.0,28269.0,"<p>You should use the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.save_statevector.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.save_statevector()</code></a> method whenever you wish to take a &quot;screenshot&quot; of the system's statevector. This modification of your code would do the job:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer

simulator = Aer.get_backend('aer_simulator_statevector')

circuit = QuantumCircuit(2)
circuit.h(0)
circuit.cnot(0, 1)
circuit.save_statevector()

result = simulator.run(transpile(circuit, simulator)).result()
psi = result.get_statevector(circuit)
</code></pre>
<p>Also note that if you wish to take multuiple &quot;screenshots&quot; of the statevector in different places along the circuit that is possible, while the requirement is to label each shot with a unique name. For example this code:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer

simulator = Aer.get_backend('aer_simulator')

circuit = QuantumCircuit(2)
circuit.h(0)
circuit.save_statevector('psi1')
circuit.cnot(0, 1)
circuit.save_statevector('psi2')

result = simulator.run(transpile(circuit, simulator)).result()
data = result.data()

psi1 = data['psi1']
psi2 = data['psi2']

display(psi1.draw(output = 'latex'))
display(psi2.draw(output = 'latex'))
</code></pre>
<p>Gives this output:
<span class=""math-container"">$$\frac{\sqrt{2}}{2} |00\rangle+\frac{\sqrt{2}}{2} |01\rangle \\ \frac{\sqrt{2}}{2} |00\rangle+\frac{\sqrt{2}}{2} |11\rangle$$</span></p>
<p>One more option (which I personally prefer the most) is using the <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html"" rel=""nofollow noreferrer""><code>Statevector</code></a> class in order to easily take &quot;screenshots&quot; of the system's statevector whenever we desire. The following code produces the same output as the last one:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, Aer
from qiskit.quantum_info import Statevector

simulator = Aer.get_backend('aer_simulator')

circuit = QuantumCircuit(2)
circuit.h(0)
psi1 = Statevector(circuit)
circuit.cnot(0, 1)
psi2 = Statevector(circuit)

display(psi1.draw(output = 'latex'))
display(psi2.draw(output = 'latex'))
</code></pre>
",9/24/2022 6:13, Errors , The user is encountering an error message stating QiskitError: No statevector for experiment while trying to get the statevector of a quantum circuit using the Aer simulator in Qiskit., Errors ,,,, Errors ,
28356.0,ModuleNotFoundError when running Qiskit RNG,"<p>I'm trying to generate random numbers using IBMQ backends with the following code:</p>
<pre><code>pip install qiskit_rng
from qiskit_rng import Generator

IBMQ.load_account()
rng_provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')
backend = rng_provider.backends.ibmq_manila

generator = Generator(backend=backend)
output = generator.sample(num_raw_bits=20001).block_until_ready()
qiskit_raw = output.raw_bits
print(qiskit_raw)
</code></pre>
<p>However, I get the following error:</p>
<pre><code>  Input In [3] in &lt;cell line: 2&gt;
    from qiskit_rng import Generator
  File /opt/conda/lib/python3.8/site-packages/qiskit_rng/__init__.py:52 in &lt;module&gt;
    from .generator import Generator
  File /opt/conda/lib/python3.8/site-packages/qiskit_rng/generator.py:35 in &lt;module&gt;
    from qiskit.providers.basebackend import BaseBackend
ModuleNotFoundError: No module named 'qiskit.providers.basebackend'
</code></pre>
<p>How can I fix this error? My current version of terra is 0.21.2. Also, is there a way to recreate this process? It is my understanding that IBM uses the GHZ (GreenbergerâHorneâZeilinger) states and then measures them with random X- and Y-measurements. I would appreciate if someone can confirm that.</p>
<p>Thank you!</p>
",<qiskit><programming><circuit-construction><quantum-circuit>,9/30/2022 15:46,28358.0,28358.0,"<p>The last <code>qiskit-rng</code> is <a href=""https://pypi.org/project/qiskit-rng/0.2.2/"" rel=""nofollow noreferrer"">0.2.2</a> from January 2021. <strong>It is unmaintained</strong> since then and their <a href=""https://github.com/qiskit-community/qiskit_rng"" rel=""nofollow noreferrer"">github repo is archived</a>. Based on <a href=""https://github.com/qiskit-community/qiskit_rng/blob/master/requirements.txt"" rel=""nofollow noreferrer"">their <code>requirements.txt</code> file</a>:</p>
<pre><code>qiskit-ibmq-provider&gt;=0.10
qiskit-terra&gt;=0.16.2
</code></pre>
<p>You can get exactly these with:</p>
<pre><code>pip install &quot;qiskit-terra==0.16.2&quot;
pip install &quot;qiskit-ibmq-provider~=0.10&quot;
</code></pre>
<p>It should work after that.</p>
",9/30/2022 16:50,Errors,The user is encountering a ModuleNotFoundError: No module named qiskit.providers.basebackend error while trying to import the qiskit_rng module for generating random numbers using IBMQ backends,Errors,,,,Errors,
28366.0,Expectation values of non-local operators in Qiskit,"<p>Is there a convenient way in Qiskit to calculate the expectation value for a non-local operator, i.e. I would like to calculate:</p>
<p><span class=""math-container"">$$ \langle \Psi|O|\Psi \rangle $$</span></p>
<p>More precisely, I would like to calculate the expectation value for an Operator that can be described by the following circuit:</p>
<pre><code>operator_circ = QuantumCircuit(4)
operator_circ.x(0)
operator_circ.cz([1, 1, 2], [2, 3, 3])
</code></pre>
<p>I am currently doing the following to calculate the expectation value:</p>
<pre><code>operator = Operator(operator_circ)
#Where psi is some quantumstate/quantumcircuit
psi.save_expectation_value(operator, range(4))
</code></pre>
<p>But I am afraid, that this is not what I want since when I look into the decomposition of the Operator it consists of some multiplexers that in turn consists of <span class=""math-container"">$CCX$</span> gates and a gate called <code>squ_dg</code>. However, what I would like is to calculate the expectation value w.r.t. the decomposition of the operator circuit into summed weighted local Pauli.</p>
<p>Ideally some function expresses the <span class=""math-container"">$CZ$</span> gate like so:</p>
<p><span class=""math-container"">$$ CZ_{12} = \frac{1}{2} (I_1 \otimes I_2 + I_1 \otimes Z_2 + Z_1 \otimes I_2 - Z_1 \otimes Z_2) $$</span></p>
<p>and then calculates the expectation value over the sums of weighted Paulis on the right hand side.</p>
<p>Or is it the same as just using the afformentioned code? What would be the best practice in Qiskit in this case?</p>
",<qiskit><programming><quantum-state><pauli-gates><non-locality>,10/01/2022 14:52,28374.0,28374.0,"<p>Looking deeper into the source code I found out that any <code>Operator</code> always gets internally transformed into a <code>SparsePauliOp</code>, i.e. a representation of weighted (sparse) Paulis which is exactly what I wanted.</p>
",10/02/2022 14:31,Theoretical,"The user is asking about the theoretical concept of calculating the expectation value for a non-local operator in Qiskit, specifically with respect to the decomposition of the operator circuit into summed weighted local Pauli. This falls under inquiries about theoretical concepts, algorithms, and principles in quantum computing",Theoretical,,,,Theoretical,
28544.0,Printing Stabilizer State of a circuit using Cirq,"<p>How to print the stabilizers for a given circuit using Cirq (just like in Qiskit)?</p>
<p>For example, if I have the following cluster state and make a circuit using Cirq. I give the circuit as input, and I should have the output as: {+XZII, +ZXZI, +IZXZ, +IIZX}</p>
<p><a href=""https://i.stack.imgur.com/S6Jrr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/S6Jrr.png"" alt=""4 node cluster state"" /></a></p>
",<programming><cirq><stabilizer-state>,10/14/2022 5:40,28551.0,28551.0,"<p>This should work, though there might be some better UX on top of it that I'm not aware of.</p>
<pre><code>a,b,c,d = cirq.LineQubit.range(4)

circuit = cirq.Circuit(cirq.H.on_each([a,b,c,d]),
                       cirq.CZ(a,b),
                       cirq.CZ(b,c),
                       cirq.CZ(c,d)
                       )
t = cirq.CliffordTableau(4)
state = cirq.CliffordTableauSimulationState(t, qubits=[a,b,c,d])
for op in circuit.all_operations():
  cirq.act_on(op, state)

print(t)
</code></pre>
",10/15/2022 1:57,Tooling,"The question is about how to use Cirq to print the stabilizers for a given circuit, which is a common task in quantum programming. The questioner is asking for a specific solution to a problem using a specific tool, which is a characteristic of tooling questions.",Tooling,,,,Tooling,
28664.0,Is there code to generate the statevector amplitude histogram for a circuit outside the Composer?,"<p>When using the IBM Composer, in the bottom left of our screen we have access to two histograms.  A theoretical probability histogram and a statevector amplitude histogram.  I'm looking for ways to create these same visualizations outside of the Composer (So in the Lab or other Jupyter Notebook).  I know that for an experimental probability histogram I can measure my qubits using an ideal simulator like the <code>'aer_simulator'</code> and then use <code>plot_histogram</code>, but I have not found anything that would portray the statevector amplitude histogram.</p>
<p>I assume there is code to generate this, and I'm not asking for anything that has not been released or involves proprietary information, but for it to be a part of their constant visualization, I simply assumed there was code to generate it, but I cannot seem to find it!  Thank you for your guidance!</p>
<p>To see which visualization I am referring to scroll down to the Statevector View section of <a href=""https://quantum-computing.ibm.com/lab/docs/iqx/visualizations"" rel=""nofollow noreferrer"">this</a> link.</p>
",<programming><ibm-q-experience>,10/24/2022 18:04,28878.0,28878.0,"<p>In Qiskit, there are two easy ways to get the state vector of a quantum circuit.</p>
<p>The easiest is just</p>
<pre><code>from qiskit.quantum_info import Statevector
Statevector(mycircuit)
</code></pre>
<p>This does not create a histogram of results, but actually keep track of the state vector.</p>
<p>You can also use a simulator, with I think is faster for larger programs.</p>
<pre><code>def get_statevector(circuit):
    sim = Aer.get_backend('aer_simulator')
    circuit.save_statevector()
    result = execute(circuit, sim).result()
    return result.get_statevector()
</code></pre>
<p>The simulator keeps track and dumps the actual statevector, not a histogram.</p>
",11/07/2022 07:17,Tooling,"The question is about how to use specific tools (IBM Composer, Lab, Jupyter Notebook) to create certain visualizations (theoretical probability histogram and statevector amplitude histogram), which falls under the category of Tooling",Tooling,,,,Tooling,
28681.0,How to Switch Toric Code to Surface Code (no using STIM!),"<p>Here is the toric code example which I found from :<a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">https://pymatching.readthedocs.io/en/latest/toric-code-example.html</a></p>
<pre><code>def repetition_code(n):

  row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n)))
  data = np.ones(2*n, dtype=np.uint8)
  return csr_matrix((data, (row_ind, col_ind)))


def toric_code_x_stabilisers(L):
    &quot;&quot;&quot;
    Sparse check matrix for the X stabilisers of a toric code with
    lattice size L, constructed as the hypergraph product of
    two repetition codes.
    &quot;&quot;&quot;
    Hr = repetition_code(L)
    H = hstack(
            [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)],
            dtype=np.uint8
        )
    H.data = H.data % 2
    H.eliminate_zeros()
    return csr_matrix(H)
    
</code></pre>
<p>My problem is I want to switch this code to the surface code but I do not know how.
<strong>I do not want to use STIM</strong>. In surface code, we have x and z stabilizers. I will add also a Z stabilizer function. This is fine but I do not know what will be different in this code to make it a surface code. It seemed to me X stabilizers can stay same. Probably I should change something(which can be boundaries) in the repetition code function, but I do not know how.</p>
<p>Can someone explain to me what I should change and how?
Thanks</p>
",<programming><surface-code><toric-code>,10/25/2022 23:55,28697.0,28697.0,"<p>The code sniplet in your question constructs the toric code as a hypergraph product (HGP) code using the non full-rank matrix of the repetition code : this is an <span class=""math-container"">$n \times n$</span> matrix with rank <span class=""math-container"">$n-1$</span>. If you remove one of the rows (say the last one) then you have a full rank <span class=""math-container"">$n-1 \times n$</span> matrix. If you substitute this matrix for
<span class=""math-container"">$Hr$</span> in the toric code routine, you'll get a surface code instead of toric code.
This paper <a href=""https://arxiv.org/abs/1202.0928"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1202.0928</a> has the details : examples 5 and 6 on page 4.</p>
",10/27/2022 2:46,Theoretical,"The question is about understanding the theoretical differences between the toric code and the surface code, and how to implement these differences in code, which falls under the category of Theoretical.",Theoretical,,,,Theoretical,
28692.0,Histogram does not reflect quantum device results,"<p>I created the following code to run a simple circuit through a quantum device twice.  My purpose was to show the effects of noise with different arrangements of qubits when using ibmq_belem.</p>
<pre><code>#Run circuit with two different qubit layouts
from qiskit import IBMQ, execute
#Load account
provider=IBMQ.load_account()
#Choose device
backend=provider.get_backend('ibmq_belem')
C=[]
for initial_layout in [[0,3],[2,4]]:
    job=execute(circuit, backend, initial_layout=initial_layout).result()
    c=result.get_counts()
    C.append(c)
</code></pre>
<p>followed by
<code>plot_histogram([C[0],C[1]],title=&quot;Comparing Noise&quot;)</code>
to create the histogram which give me ...
<a href=""https://i.stack.imgur.com/eigrz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eigrz.png"" alt=""enter image description here"" /></a></p>
<p>Which does not reflect any of the noise that I see in my results taken directly from IBMQ which shows the first and second runthroughs respectivly as ...
<a href=""https://i.stack.imgur.com/QxRZY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QxRZY.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/9IZLd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9IZLd.png"" alt=""enter image description here"" /></a></p>
<p>These are clearly not the identically perfect versions that my C set seems to have created.  This makes my question; What have I done wrong in coding this that C is not accurately reflecting my counts?</p>
<p><strong>Edit:</strong> I note that it has somehow decided to take the counts from when I ran this circuit on a simulator in a prior cell using the following code.</p>
<pre><code>simulator=Aer.get_backend('aer_simulator')
result=execute(circuit,backend=simulator).result()
plot_histogram(result.get_counts(circuit)) 
</code></pre>
<p>This code had been run before I ever created the set C, so I did not expect it to interfere, but now I'm not sure how to work around this.</p>
",<programming><ibm-q-experience>,10/26/2022 18:20,28694.0,28694.0,"<p>Figured it out!  It was using my result label from the initial coding when I used the simulator and appending that twice to my set C.  So in my code I have now changed <code>c=result.get_counts()</code> to <code>c=job.get_counts()</code> as that was the 'job' I wanted the results from!  And now all is beautiful and full of noise!</p>
",10/26/2022 21:26,Errors,"The question is related to a specific issue or error in the code, where the C variable does not accurately reflect the counts obtained from running the circuit on a quantum device. Additionally, the interference with counts obtained from a prior simulation is causing confusion, which falls under the category of errors",Errors,,,,Errors,
28709.0,Link between binary program output and observable eigenvalue,"<p>A quantum cloud server like from IBM typically returns a string of 0's and 1's such as 0010.</p>
<p>An observable such as <span class=""math-container"">$Z_1 \otimes Z_2 ... \otimes Z_{n}$</span> has two eigenvalues +1 or -1. How do I relate this to the 0010 output? Note that there is no one-to-one correspondence (it is many-to-one).</p>
<p>I recall here that eigenvalues of an operator are the possible results of the measurement.</p>
<p>I started reasoning as follows. The observable in the case of a quantum program (a Projective measurement, see Sec 2.2.5 of Mike and Ike) is given by:</p>
<p><span class=""math-container"">$P = \sum_m m P_m$</span></p>
<p>where <span class=""math-container"">$m$</span> is an integer between <span class=""math-container"">$0$</span> to <span class=""math-container"">$2^n-1$</span> and <span class=""math-container"">$P_m$</span> is the corresponding operator such as |<span class=""math-container"">$0011&gt;&lt;0011|$</span>.</p>
<p>Now, if I think about the register as doing a measurement for the following observable (a Hermitian matrix):</p>
<p><span class=""math-container"">$ Z = Z_0 \otimes Z_1 ... \otimes Z_{n-1}$</span></p>
<p>then the eigenvalues for such an operator are just two in number: <span class=""math-container"">$+1$</span> and <span class=""math-container"">$-1$</span> and hence does not retain the dimensionality information.</p>
<p>Thus I ended up with the conclusion that there is no link: P and Z are two entirely different observables whose eigenvalues cannot be linked (conceptually or mathematically). In particular, P is the right way of mathematically thinking about the register output of a quantum program and not Z.</p>
<p>Am I thinking right? I have a nagging feeling I am missing something here and it might be possible to relate these two pictures.</p>
<p>Many thanks for your time.</p>
<p>(p.s There is another question that preceded this question which can be found here: <a href=""https://quantumcomputing.stackexchange.com/questions/28705/binary-output-of-a-quantum-program-measurement-procedure"">How are measurements done exactly on IBM cloud computers?</a>)</p>
",<programming><physical-realization>,10/28/2022 5:00,28979.0,28979.0,"<p>I want to answer my question regarding the link between <span class=""math-container"">$\sum mP_m$</span> and measuring <span class=""math-container"">$Z_0 \otimes \cdots Z_{n-1}$</span>. The link can be understood from Exercise 10.3 in in Chapter 10 of Mike and Ike. Using a three qubit example, there we show that measuring <span class=""math-container"">$Z_1 \otimes Z_2$</span> followed by <span class=""math-container"">$Z_2 \otimes Z_3$</span> is equivalent to measuring the four projectors <span class=""math-container"">$P_0, P_1, P_2$</span> and <span class=""math-container"">$P_3$</span>.</p>
",11/13/2022 17:22,Conceptual,"The question is about understanding the relationship between the binary output of a quantum program and the eigenvalues of an observable. The questioner is asking about a deep conceptual topic in quantum mechanics, and their reasoning is sound. They correctly conclude that there is no one-to-one correspondence between the two, and that the binary output of a quantum program is more informative than the eigenvalues of the observable.",Theoretical,"The question is asking about the relationship between the eigenvalues of an observable and the output of a projective measurement, which is a theoretical concept in quantum mechanics.. ",No,128.0,Conceptual,"The user's question delves into understanding the conceptual relationship between the binary output of a quantum program and the eigenvalues of an observable. They provide reasoning and seek confirmation about their understanding, making it a conceptual inquiry into quantum mechanics."
28765.0,Pennylane: take qml.state of one function and use it as the initialization for another,"<p><strong>In Pennylane</strong>, I created a function to set the initial parameters of my qubit, and then called qml.state() to return the output. I now want to feed this initialization into another circuit, but I'm not sure how I would go about doing that.</p>
<p>here's what I have:</p>
<p>random_init() initializes a set of qubits to particular states, and then returns qml.state()</p>
<pre><code>@qml.qnode(dev1)
def random_init():
    for i  in range(0, y, 3):
            qml.RX(random_list[i], i//3)
            qml.RY(random_list[i+1], i//3)
            qml.RZ(random_list[i+2], i//3)
    return qml.state()
</code></pre>
<p>I now want to take qml.state() and pass it through another circuit that does computations based on the initial states set by random_init().</p>
<p>Is this possible to do? Furthermore, is there a more effective way to achieve this goal?</p>
<p>Thanks in advance for any help people provide.</p>
",<programming><quantum-state><algorithm><computational-models><pennylane>,10/31/2022 19:31,28768.0,28768.0,"<p>You can totally do this in PennyLane. Check out <a href=""https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html?highlight=qubitstatevector"" rel=""nofollow noreferrer""><code>qml.QubitStateVector</code></a> :)</p>
<pre><code>
import pennylane as qml
from pennylane import numpy as np

dev1 = qml.device(&quot;default.qubit&quot;, wires=1)

@qml.qnode(dev1)
def circuit():
    qml.RX(np.pi/3, wires=0)
    return qml.state()

@qml.qnode(dev1)
def new_circuit(state):
    qml.QubitStateVector(state, wires=0)
    return qml.state()


state = circuit()
print(new_circuit(state))

# Out: [0.8660254+0.j  0.       -0.5j]
</code></pre>
<p>Hope this helps!</p>
",10/31/2022 22:04,API Usage,"The question is about how to use a specific function (qml.state()) in a quantum computing library (Pennylane), and how to pass its output to another circuit, which falls under the category of API usage", Tooling,"The question is asking about how to use the output of a PennyLane QNode as the input to another QNode, which is a question about how to use a quantum computing tool.",No,129.0,Tooling,"The user's inquiry pertains to how to utilize the output of a PennyLane QNode as input for another QNode, which falls under understanding the tool's functionality and usage."
28921.0,Check_matrix in Pymatching and Understanding the Plot,"<p>In the simplest case, let's assume we have distance 2 surface code. The X stabilizers will be: X1X2X3 and X3X4X5 which is shown by the red lines.</p>
<p><a href=""https://i.stack.imgur.com/sj31b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sj31b.png"" alt=""enter image description here"" /></a></p>
<p>So the parity check matrix will be:
<span class=""math-container"">$$
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp;0 &amp;0 \\
0 &amp; 0 &amp; 1  &amp;1 &amp; 1
\end{bmatrix}
$$</span>
Now when I run the code scripts with pymatching to see how it works,</p>
<pre><code>m =Matching()
m.load_from_check_matrix([[1, 1,1,0,0],[0,0,1,1,1]])
plt.show()
</code></pre>
<p>I get the following image as a result. I actually did not understand what this plot means. The empty circle is the boundary. Is it the boundary qubit? Filled circles (in this case 0 and 1) are the stabilizers. But I have just 2 filled circles. Does this mean that one of the filled circle is X1X2X3 and the other filled circle X3X4X5?  I also did not understand the weights, for example why do we have 0 between boundary and the circle-0 and why do we have 3 between boundary and the circle-1? Can someone explain me what this plot represents?
<a href=""https://i.stack.imgur.com/0hNr0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0hNr0.png"" alt=""enter image description here"" /></a></p>
",<programming><surface-code><pymatching>,11/09/2022 05:49,29659.0,29659.0,"<p>The networkX visualizations of the surface codes tend to be a little squished unfortunately. What you are looking at is the same as the image below, just slightly distorted.</p>
<p><a href=""https://i.stack.imgur.com/KysSR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KysSR.png"" alt=""enter image description here"" /></a></p>
<p>This image should be more familiar as the normal unrotated distance 2 surface code graph. All that's happening is that the (1) edge is hidden behind the (0) edge, and the (4) edge behind the (3) edge. Part of the reason for the distortion is pymatching uses a single boundary node for the rough boundaries of the graph. This is why node (2) is depicted differently than the other nodes, it represents the boundary node.</p>
",01/11/2023 15:44,Tooling,"The question is about understanding the output of a specific tool (pymatching) used in quantum programming, specifically how to interpret the plot it generates, which falls under the category of Tooling",Tooling,,,,Tooling,
29007.0,Solve sudoku using Grover's algorithm,"<p><a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#5.-Solving-Sudoku-using-Grover%27s-Algorithm-"" rel=""nofollow noreferrer"">The Qiskit tutorial</a> shows the application of Grover's Algorithm to solve a 2x2 sudoku. However, I don't understand how why its diffuser works as intended. Precisely, why the control bit is on a &quot;variable&quot; qubit (labeled as &quot;v&quot;) rather than on the auxiliary qubit (labeled as &quot;out_0&quot;)?</p>
<pre><code>var_qubits = QuantumRegister(4, name='v')
clause_qubits = QuantumRegister(4, name='c')
output_qubit = QuantumRegister(1, name='out')
cbits = ClassicalRegister(4, name='cbits')
qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def sudoku_oracle(qc, clause_list, clause_qubits):
# Compute clauses
    i = 0
    for clause in clause_list:
       XOR(qc, clause[0], clause[1], clause_qubits[I])
       i += 1

# Flip 'output' bit if all clauses are satisfied
    qc.mct(clause_qubits, output_qubit)

# Uncompute clauses to reset clause-checking bits to 0
    i = 0
    for clause in clause_list:
        XOR(qc, clause[0], clause[1], clause_qubits[I])
        i += 1

sudoku_oracle(qc, clause_list, clause_qubits)
qc.draw()

Define difusser:
def diffuser(nqubits):
    qc = QuantumCircuit(nqubits)
# Apply transformation |s&gt; -&gt; |00..0&gt; (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
# Apply transformation |00..0&gt; -&gt; |11..1&gt; (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit) 
# Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
# Apply transformation |11..1&gt; -&gt; |00..0&gt;
    for qubit in range(nqubits):
       qc.x(qubit)
# Apply transformation |00..0&gt; -&gt; |s&gt;
    for qubit in range(nqubits):
       qc.h(qubit)
# We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = &quot;U<span class=""math-container"">$_s$</span>&quot;
    return U_s

#Put everything together
# Initialize 'out0' in state |-&gt;
qc.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s&gt;
qc.h(var_qubits)
qc.barrier()  # for visual separation

## First Iteration
# Apply our oracle
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

## Second Iteration
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

# Measure the variable qubits
qc.measure(var_qubits, cbits)

qc.draw(fold=-1)
</code></pre>
<p>The whole circuit looks like this:<a href=""https://i.stack.imgur.com/O0XcA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/O0XcA.png"" alt=""enter image description here"" /></a></p>
<p>The diffuser (U_s) looks like this:<a href=""https://i.stack.imgur.com/PfPvt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PfPvt.png"" alt=""enter image description here"" /></a></p>
",<qiskit><programming><grovers-algorithm><applications>,11/16/2022 5:02,29008.0,29008.0,"<p>Two important things to notice:</p>
<ol>
<li><p>Notice that the multi-controlled Toffoli has its target qubit surrounded by H gates.  This means we actually have a multi-controlled Z gate..</p>
</li>
<li><p>A multi-controlled Z gate has the unusual property that it doesn't distinguish between its target qubit and its control qubits.  If you look at:</p>
</li>
</ol>
<pre><code>circ = QuantumCircuit(2)
circ.cz(0, 1)
circ.draw('latex')
</code></pre>
<p>you'd see the printed circuit doesn't even bother distinguishing between the control and the target.</p>
<p>The net effect of the control Z is that it maps <span class=""math-container"">$|1111\rangle$</span> to <span class=""math-container"">$-|1111\rangle$</span>.</p>
<p>Since the entire control-Z is surrounded by a wall of X's on both sides, the total effect of both is that <span class=""math-container"">$|0000\rangle$</span> is mapped to <span class=""math-container"">$-|0000\rangle$</span></p>
<hr />
<p>Update:</p>
<p>I confirmed that Qiskit also prints multi-control Z gates the same way it handles single-control Z gates: no qubit is distinguished as the target.</p>
<pre><code>circ = QuantumCircuit(4)
circ.append(ZGate().control(3), [0, 1, 2, 3])
x = circ.draw('text')

q_0: ââ â
      â 
q_1: ââ â
      â 
q_2: ââ â
      â 
q_3: ââ â
      
</code></pre>
<p>Your confusion is from the fact that the text chose to implement the controlled-Z gate by way of a controlled-X gate.  One of the qubits had to be picked, arbitrarily, to be the target.</p>
",11/16/2022 7:43,Theoretical,"The question is about understanding the theoretical aspects of Grovers Algorithm, specifically the role and functioning of the diffuser in the context of a 2x2 Sudoku problem implemented in Qiskit.",Theoretical,,,,Theoretical,
29174.0,Implement muti-qubit controlled gate with 2 Z/X gates,"<p><a href=""https://www.researchgate.net/publication/326978036_Solving_Sudoku_game_using_a_hybrid_classical-quantum_algorithm"" rel=""nofollow noreferrer"">This paper</a> simulates duality mode to solve sudoku puzzles. The last diagram in the paper (shown below) illustrates multi-qubit controlled gates with two Z/X gates. I wonder if Qiskit can directly implement these gates.</p>
<p><a href=""https://i.stack.imgur.com/DXaIE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DXaIE.png"" alt=""enter image description here"" /></a></p>
",<qiskit><programming><quantum-gate><ibm-q-experience>,11/29/2022 5:27,29178.0,29178.0,"<p>As @FrankYellin mentioned in the comments, this is theoretically equivalent to two <code>MCXGate</code> applied successively (up to some <code>HGate</code> for the <span class=""math-container"">$Z$</span> version).</p>
<p>However, you shouldn't worry about this, a framework's goal is to let it deal with low-level implementation, while you should care about what operation you want to perform. Fundamentally, what you're looking for is a multi-controlled <span class=""math-container"">$XX$</span> gate.</p>
<p>Qiskit has an <code>RXXGate</code>, but this will include an unwanted relative phase. You can create the <span class=""math-container"">$XX$</span> gate like this:</p>
<pre><code>from qiskit import QuantumCircuit

circ = QuantumCircuit(2)
circ.x([0, 1])
xx_gate = circ.to_gate(label=&quot;XXGate&quot;)
</code></pre>
<p>Now that we have our $XX$ gate, we can control it out of other qubits as desired, like so:</p>
<pre><code>from qiskit import QuantumRegister

# Be careful about Qiskit's little-endian convention
controlled_xx_gate = xx_gate.control(7, &quot;MCXXGate&quot;, &quot;0000100&quot;)

alpha = QuantumRegister(4, &quot;alpha&quot;)
beta = QuantumRegister(4, &quot;beta&quot;)
gamma = QuantumRegister(4, &quot;gamma&quot;)

circ = QuantumCircuit(alpha, beta, gamma)
circ.h([alpha[-1], beta[-1], gamma[-1]])

# Using HXH = Z
circ.h([beta[0], gamma[0]])
# Be careful about Qiskit's little-endian convention
circ.append(controlled_xx_gate, [*alpha[:-1], beta[1], beta[-1], gamma[1], gamma[-1], beta[0], gamma[0]])
circ.h([beta[0], gamma[0]])

# Be careful about Qiskit's little-endian convention
circ.append(controlled_xx_gate, [*alpha[:-1], beta[1], beta[-1], gamma[1], gamma[-1], beta[0], gamma[0]])
</code></pre>
<p>The resulting circuit looks like this:</p>
<p><a href=""https://i.stack.imgur.com/QzcZY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QzcZY.png"" alt=""enter image description here"" /></a></p>
",11/29/2022 11:16,Tooling,"The question is about whether Qiskit can directly implement the multi-qubit controlled gates shown in the diagram, which is a question about a specific tool.",Tooling,,,,Tooling,
29205.0,Changing target Quantinuum Processor,"<p>I am trying to go through the Q# tutorial at <a href=""https://learn.microsoft.com/en-us/training/modules/qsharp-create-first-quantum-development-kit/4-random-number-generator"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/training/modules/qsharp-create-first-quantum-development-kit/4-random-number-generator</a> before I get my hands dirty and start writing my own code. But I cannot get off the ground because I am receiving this error:
<em>The callable ResultArrayAsInt requires runtime capabilities which are not supported by the target QuantinuumProcessor.</em>
I have tried changing the &lt;ExecutionTarget&gt; in my .csproj file to different combinations I found in <a href=""https://learn.microsoft.com/en-us/azure/quantum/provider-quantinuum"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/azure/quantum/provider-quantinuum</a> ... but to no avail.
Any help would be appreciated. How do I change my target Quantinuum Processor to one which has the capability to call ResultArrayAsInt?</p>
",<q#><azure-quantum>,12/02/2022 05:31,29221.0,29221.0,"<p>You cannot use <code>ResultArrayAsInt</code> function in any code that runs on cloud targets in Azure Quantum. This MS Learn code sample is designed to be executed only on local simulators.</p>
<p>The function calls another one, <a href=""https://github.com/microsoft/QuantumLibraries/blob/159f76143ab44829ebb10003c56be917cb92884b/Standard/src/Convert/Convert.qs#L102"" rel=""nofollow noreferrer"">BoolArrayAsInt</a>, and ultimately updates a variable based on the values of measurement results. All Azure Quantum targets have either &quot;No Control Flow&quot; profile that requires that the programs return measurement results immediately or &quot;Basic Measurement Feedback&quot; profile that allows to apply gates based on measurement results but not update variables based on them.</p>
<p>To adapt this code to run on Quantinuum, you need to return an array of measurement results directly and write classical host code (for example, in Python) to convert them to an integer in the post-processing stage.</p>
",12/02/2022 17:56,API Usage,"The question is about how to change the target Quantum Processor in Q# to one that supports the ResultArrayAsInt function, which falls under the category of API usage",API Usage,,,,API Usage,
29252.0,How to define a custom gate from a matrix in TKET,"<p>I'm currently learning all about different quantum tools such as qiskit, tket, cirq, Forest SDK and so on. I just want to create a circuit that gets executed given a matrix, because a circuit can be written as a matrix and the other way around. In qiskit, cirq and pyquil (Forest SDK) there is no problem in defining an own gate. I don't find any function in tket which could help with this.</p>
<p>For example I want to define an AND gate. For those who don't know, an AND gate is actually just the CCNOT or CCX Gate. Tket does support the CCX gate but if I want to create maybe an AND Gate with 3 or 4 Qubits (CCCX or CCCCX) Gate the tket framework doesn't help.</p>
<p>Can somebody help me with this? I understand that you can define own gates in Tket but that just include gates that are created from native gates.</p>
",<qiskit><quantum-gate><programming><cirq><pytket>,12/05/2022 14:31,29253.0,29253.0,"<p>You can define custom gates in tket using <code>CustomGateDef</code>. Here the <code>CustomGate</code> is defined using a circuit which implements the desired unitary instead of the  matrix itself. Here is an example for how to do this...</p>
<p><a href=""https://cqcl.github.io/pytket/manual/manual_circuit.html#custom-parameterised-gates"" rel=""nofollow noreferrer"">https://cqcl.github.io/pytket/manual/manual_circuit.html#custom-parameterised-gates</a></p>
<p>If the unitary represents a one, two or three qubit operation it is possible to synthesise a circuit to implement the unitary. See for example <a href=""https://cqcl.github.io/tket/pytket/api/circuit.html#pytket.circuit.Unitary3qBox"" rel=""nofollow noreferrer"">https://cqcl.github.io/tket/pytket/api/circuit.html#pytket.circuit.Unitary3qBox</a></p>
<p>If you're interested in multi-controlled X operations you can add these to your Circuit as a CnX.</p>
<pre><code>from pytket import Circuit, OpType

circ = Circuit(4)
circ.add_gate(OpType.CnX, [0, 1, 2, 3])
</code></pre>
<p>You may also wish to check out the <code>ToffoliBox</code> feature which implements an arbitrary permutation of the computational basis states using X and CnX gates.</p>
<p>There is an example in this section of the user manual if you scroll down. <a href=""https://cqcl.github.io/pytket/manual/manual_circuit.html#boxes"" rel=""nofollow noreferrer"">https://cqcl.github.io/pytket/manual/manual_circuit.html#boxes</a></p>
<p>Hope this is helpful.</p>
",12/05/2022 15:39,Tooling,"The question is about how to use a specific tool (Tket) to define custom gates, including gates with more than two qubits. This is a question about how to use Tket to achieve a specific goal.",Tooling,,,,Tooling,
29328.0,Entangling two non-physically adjacent qubits,"<p>Entanglement can be performed just between two ** adjacent qubits** (e.g. 1 and 2) or even <strong>non-physically adjacent qubits</strong> on the processor architecture can be entangled (e.g. 2 and 6).</p>
<p><a href=""https://i.stack.imgur.com/IRStG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IRStG.png"" alt=""double T-shape coupling map"" /></a></p>
<p>How entangled between non-physically adjacent qubits could happen?</p>
",<qiskit><programming><quantum-state><algorithm><entanglement>,12/11/2022 10:34,29335.0,29335.0,"<p>As <a href=""https://quantumcomputing.stackexchange.com/users/15947/montenero"">@MonteNero</a> mentioned in <a href=""https://quantumcomputing.stackexchange.com/questions/29328/entengling-two-non-physically-connected-qubits#comment38964_29328"">the comment</a>, it is posible to entangle non-adjacent qubits using <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#Swap_gate"" rel=""nofollow noreferrer""><span class=""math-container"">$\mathrm{SWAP}$</span> gates</a>.</p>
<p>In <a href=""https://www.qiskit.org"" rel=""nofollow noreferrer"">Qiskit</a>, there is a transpilation stage called <em>routing</em> that introduce the <span class=""math-container"">$\mathrm{SWAP}$</span> gates for exactly that propose. Taking the example from your question:</p>
<p>The following circuit entangles the qubits <span class=""math-container"">$q_2$</span> and <span class=""math-container"">$q_6$</span>:</p>
<pre><code>from qiskit import QuantumCircuit

circuit = QuantumCircuit(7)
circuit.cx(2,6)
circuit.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/3nVAG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3nVAG.png"" alt=""cnot between q2 and q6"" /></a>
The backend you are suggesting has the shape many of the IBM's Falcon r5.11H, such as <code>ibm_oslo</code></p>
<pre><code>from qiskit.providers.fake_provider import FakeOslo
from qiskit.visualization import plot_gate_map

backend = FakeOslo()
plot_gate_map(backend)
</code></pre>
<p><a href=""https://i.stack.imgur.com/2pniy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2pniy.png"" alt=""oslo coupling map"" /></a></p>
<p>The transpiler will insert the $\mathrm{SWAP}# gates to make possible the entanglement between adjacent qubits.</p>
<pre><code>from qiskit import transpile

transpile(circuit, coupling_map=backend.coupling_map, layout_method='trivial').draw('mpl', with_layout=False)
</code></pre>
<p><a href=""https://i.stack.imgur.com/BwTTw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BwTTw.png"" alt=""transpiled circuit with swap gates"" /></a></p>
<p>Let's analyse this case layer by layer:</p>
<ul>
<li>Layer 1, <span class=""math-container"">$q_1$</span> swaps with <span class=""math-container"">$q_2$</span> and <span class=""math-container"">$q_5$</span> with <span class=""math-container"">$q_6$</span>. Logically speaking, you can see the connectivity map like this now:</li>
</ul>
<p><a href=""https://i.stack.imgur.com/ye7Z7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ye7Z7.png"" alt=""coupling map after layer 1"" /></a></p>
<ul>
<li>Layer 2, <span class=""math-container"">$q_3$</span> swaps with <span class=""math-container"">$q_2$</span>:</li>
</ul>
<p><a href=""https://i.stack.imgur.com/QoxfC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QoxfC.png"" alt=""coupling map after layer 2"" /></a></p>
<p>Now, <span class=""math-container"">$q_6$</span> and <span class=""math-container"">$q_2$</span> are adjacent and the <span class=""math-container"">$\mathrm{CNOT}$</span> gate between them works.</p>
",12/12/2022 09:54,Conceptual,"The question is about how entanglement can occur between non-physically adjacent qubits, which is a deep conceptual topic in quantum mechanics.",Conceptual,,,,Conceptual,
29401.0,Implementing a Gaussian elimination solver for Simon's algorithm's outcome of linear equations,"<p>I'm trying to implement a gaussian elimination solver for the linear equations that are the outcome from simon's algorithm. I implemented two solutions,</p>
<ul>
<li>first: <a href=""https://stackoverflow.com/a/45527097"">https://stackoverflow.com/a/45527097</a></li>
<li>second: <a href=""https://codeforces.com/blog/entry/52270"" rel=""nofollow noreferrer"">https://codeforces.com/blog/entry/52270</a></li>
</ul>
<p>They both work fine for systems which can be reduced to rref (reduced row echelon form), where every non-zero coefficient in a row is the only non-zero.</p>
<p>But neither can handle simple cases like:<br />
Given secret b = 11. Measurements in simon's algorithm: 00 and 11.</p>
<p>The augmented given matrix I put as a param for a solver would be:<br />
|| 1 1 | 0 ||<br />
|| 0 0 | 0 ||<br />
or just (reducing to non trivial equations):<br />
|| 1 1 | 0 ||<br />
I would expect the non trivial solution would be: b0 = 1 and b1 = 1.</p>
<p>Does someone has an idea or an implementation how to handle this cases?
I'm a bit confused because what we are solving here is a special version of a homogeneous system<br />
Ax = 0<br />
If A is non-singular, than it only has one (the trivial zero) solution.
Otherwise it has an infinite number of non-trivial solutions and gaussian elimination doesn't work here.
See: <a href=""https://en.wikipedia.org/wiki/System_of_linear_equations#Homogeneous_systems"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/System_of_linear_equations#Homogeneous_systems</a></p>
<p>But the example I posted above has exactly two solutions (00 and 11). I can only attribute this to the fact that we have a special case here with modulo 2, right?</p>
<p>However, all articles and books I looked into don't show an implementation of how to solve this. And from my inner feeling there are two options left:</p>
<ul>
<li>I'm thinking to complicated</li>
<li>Or it's not solvable with the suggested gaussian-elimination.</li>
</ul>
<p>The latter is underlined by the fact that Google's Cirq uses svd (Singular Value Decomposition) that I don't understand yet.</p>
<p><a href=""https://i.stack.imgur.com/j2VfY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/j2VfY.png"" alt=""enter image description here"" /></a></p>
",<programming><algorithm><simons-algorithm>,12/16/2022 20:41,29407.0,29407.0,"<p>Note that the <span class=""math-container"">$00$</span> measurement is actually unusable: any string <span class=""math-container"">$s$</span> is orthogonal to <span class=""math-container"">$00$</span>, so this doesn't give you a bit of informration on <span class=""math-container"">$s$</span>.</p>
<p>Furthermore, as noted in <a href=""https://quantumcomputing.stackexchange.com/a/2224/10454"">this answer</a>, for a secret of <span class=""math-container"">$n$</span> bits, only <span class=""math-container"">$n-1$</span> equations are to be used. Otherwise, the only solution is <span class=""math-container"">$s=0$</span> if the equations are linearly independent.</p>
<p>In your case, the equations are not linearly independent (because of the <span class=""math-container"">$00$</span> measurement), since <span class=""math-container"">$11\oplus11=00$</span>, which explains why the true solution <span class=""math-container"">$11$</span> is still possible. Note also that the zero vector will always be a solution of the system, since it will always be orthogonal to all the measurements you've got.</p>
<p>Thus, after solving for <span class=""math-container"">$s\neq0$</span> using <span class=""math-container"">$n-1$</span> equations, you ought to verify the hypothesis that <span class=""math-container"">$s\neq0$</span>. This is quite easy: query for <span class=""math-container"">$f(x)$</span> and <span class=""math-container"">$f(x\oplus s)$</span>. If they are equal, then <span class=""math-container"">$s$</span> is necessarily different from <span class=""math-container"">$0$</span>. Otherwise, it means that <span class=""math-container"">$s=0$</span>.</p>
<p>That said, I happen to have coded an implementation in Python some time ago. Note that it is not guarantee to be the fastest possible methods, but it should work.</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

class NotFullRankError(Exception):
    pass

def solve(bitstrings: list[str]) -&gt; str:
    # bitstrings = [np.array([int(x) for x in s], dtype=bool) for s in bitstrings]
    matrix = np.vstack([np.array([int(x) for x in s], dtype=bool) for s in bitstrings])
    
    # Check if there are n - 1 equations and whether the nil vector is among them
    if not matrix.any(axis=1).all() or matrix.shape[0] != matrix.shape[1] - 1:
        raise NotFullRankError()
    
    # Reduce
    for i in range(matrix.shape[0] - 1):
        mask = matrix[i:, i]
        matrix[i:] = np.vstack((matrix[i:][mask], matrix[i:][~mask]))
        matrix[i + 1:i + mask.sum()] ^= matrix[i]
        
        # Check if the equations were linearly independent
        if not matrix.any(axis=1).all():
            raise NotFullRankError()
        
    # Transforming matrix from a ref to a rref
    for i in range(1, matrix.shape[0]):
        index = np.where(matrix[i])[0][0]
        mask = matrix[:i, index]
        matrix[:i][mask] ^= matrix[i]
    
    index = np.where(~np.diag(matrix))[0]
            
    if index.shape[0]:
        index = index[0]
    else:
        index = matrix.shape[1] - 1

    return &quot;&quot;.join(str(x) for x in np.hstack((matrix[:index, index], [1], matrix[index:, index])))
</code></pre>
<p>A quick explanation concerning the following lines:</p>
<pre class=""lang-python prettyprint-override""><code>    index = np.where(~np.diag(matrix))[0]
            
    if index.shape[0]:
        index = index[0]
    else:
        index = matrix.shape[1] - 1

    return np.hstack((matrix[:index, index], [1], matrix[index:, index]))
</code></pre>
<p>Once the matrix is rref, two cases are possible:</p>
<ul>
<li>the diagonal is full of <span class=""math-container"">$1$</span>s, like:
<span class=""math-container"">$$A=\begin{pmatrix}1&amp;0&amp;0&amp;0&amp;1\\0&amp;1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;1\end{pmatrix}$$</span></li>
<li>the diagonal &quot;misses&quot; a step, like:
<span class=""math-container"">$$B=\begin{pmatrix}1&amp;1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;0&amp;1\end{pmatrix}$$</span></li>
</ul>
<p><code>index</code> will represent the index at which the diagonal misses a step, which is <span class=""math-container"">$n-1$</span> for the first case and the first zero on the diagonal for the second one.</p>
<p>Let us consider the second case for now. Note that the last row will always be <span class=""math-container"">$\begin{pmatrix}0&amp;\cdots&amp;0&amp;1\end{pmatrix}$</span>, which implies that the last bit of <span class=""math-container"">$s$</span> must be <span class=""math-container"">$0$</span>. Indeed, we must have <span class=""math-container"">$Bs=\begin{pmatrix}0\\\vdots\\0\end{pmatrix}$</span>, so the last line of the system translates to <span class=""math-container"">$1\cdot s_n=0$</span>. Essentially, this means that you can remove the last row of the matrix, since each of these elements will me multiplied by the last bit of <span class=""math-container"">$s$</span>, which is <span class=""math-container"">$0$</span>. You can then perform the same reasoning, until you're left with a matrix of the first case. Thus, if we show that in the first case, the solution <span class=""math-container"">$s$</span> is given by the last column to which one appends <span class=""math-container"">$1$</span>, this would explain the method (since <code>matrix[index:, index]</code> is a vector full of zeroes).</p>
<p>Now for the first case, since the matrix is rref it means that every row on the matrix contain at most exactly two <span class=""math-container"">$1$</span>s: one on the diagonal and one on the last column. Thus, when writing down <span class=""math-container"">$As=\begin{pmatrix}0\\\vdots\\0\end{pmatrix}$</span>, all of the equations can be written as <span class=""math-container"">$s_i\oplus A_{i,n}\cdot s_n=0$</span>, which implies that <span class=""math-container"">$s_i=A_{i,n}\cdot s_n$</span>. If <span class=""math-container"">$s_n=0$</span>, then this will yield the zero vector, which we don't want. Thus, we impose <span class=""math-container"">$s_n=1$</span>, which then yield <span class=""math-container"">$s_i=A_{i,n}$</span>.</p>
<p>All in all, once the index at which the diagonal misses a step is found, we simply have to take the column corresponding to this index up to that row, add a <span class=""math-container"">$1$</span> and complete with <span class=""math-container"">$0$</span> to find <span class=""math-container"">$s$</span>, which explains the code.</p>
<p>Now, if you want to use this code, here's how you can do it. If you measured <span class=""math-container"">$10010$</span>, <span class=""math-container"">$11010$</span>, <span class=""math-container"">$10110$</span> and <span class=""math-container"">$10001$</span>, you can find the unique non-zero <span class=""math-container"">$s$</span> which is orthogonl to all of these like this:</p>
<pre class=""lang-python prettyprint-override""><code>res = solve([&quot;10010&quot;, &quot;11010&quot;, &quot;10110&quot;, &quot;10001&quot;]) # Compute s
print(res)
</code></pre>
<p>Running it with the list containing only <code>&quot;11&quot;</code> returns <code>&quot;11&quot;</code> as expected.</p>
",12/17/2022 15:32,Conceptual," The question is about how to solve a specific type of homogeneous system of linear equations, which is a deep conceptual topic in linear algebra.",Theoretical,"The question involves a theoretical aspect of solving linear equations resulting from Simon's algorithm, particularly in cases that don't fit the typical Gaussian elimination approach. It also touches upon the use of Singular Value Decomposition (SVD) in solving such problems, making it appropriate for the Theoretical category.",No,130.0,Theoretical,"This is because the question involves a theoretical aspect of solving linear equations resulting from Simon's algorithm, especially in cases that deviate from typical Gaussian elimination. Additionally, it discusses the use of Singular Value Decomposition (SVD) as an alternative method, which aligns with theoretical exploration rather than practical implementation."
29418.0,ctrl_state 'order' of control( ),"<p>I am qurious about the order of ctrl_state</p>
<p>The Quantum Circuit what I expected is this.</p>
<p><a href=""https://i.stack.imgur.com/49OyB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/49OyB.png"" alt=""enter image description here"" /></a></p>
<p>q1 is controled when '0' and q2 and a3 is controled when '1'</p>
<p>So I wirte code that is</p>
<blockquote>
<p>ctrl_state='011'</p>
</blockquote>
<p>But what I got is this. Why I got oposite form like this...
What is the principle of this.</p>
<p><a href=""https://i.stack.imgur.com/vY9rG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vY9rG.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit import*
from qiskit.extensions import UnitaryGate
matrix_V2_2=[[1,0],[0,1]]
Won_gate = UnitaryGate(matrix_V2_2,label='Won').control(num_ctrl_qubits=3, ctrl_state='011')
main_circuit=QuantumCircuit(4,4)
main_circuit.append(Won_gate ,[1,2,3,0])
%matplotlib inline
main_circuit.draw(output='mpl')
</code></pre>
",<qiskit><programming><quantum-gate>,12/19/2022 4:23,29419.0,29419.0,"<p>This is because Qiskit uses <a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow noreferrer"">little-endian</a> bit ordering. That means, in your case <code>ctrl_state</code> should be <span class=""math-container"">$q_3 q_2 q_1$</span>.</p>
<p>You can find more details <a href=""https://quantumcomputing.stackexchange.com/q/8244/9474"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/q/18630/9474"">here</a>.</p>
",12/19/2022 5:20,API Usage,"The question is asking about how to use the ctrl_state argument to the control() method of the UnitaryGate class in Qiskit, which is a question about how to use the Qiskit API.",API Usage,,,,API Usage,
29424.0,How to set different Backend Layouts in TKET and pyQuil (Quil compiler)?,"<p>In Qiskit it is possible to describe a CouplingMap on which a circuit get executed. This helps with testing different Layouts. There are many possibilities in Qiskit on how to do this. Firstly you can create a CouplingMapInstance and then create different shapes from methods (For Example a Line, Grid, Ring,.. Layout). Secondly you can draw circuits by 'hand' and just create a List of the Edges in the Layout.</p>
<p>However i do not find such things in TKet or pyQuil and my question is if I'm missing something here. All three do support Fully Connected Layouts.</p>
<p>I just googled again. It seems like pyQuil does support it in some way.
The QVM in pyquil offers the method get_qc() which returns a quantum machine. It is possible that you give '9q-square-qvm' as an input which returns a quantum machine with 9 Qubits on a square Layout.
Is there a way in pyQuil to customize a Layout like in qiskit?</p>
",<qiskit><programming><pyquil><pytket>,12/19/2022 16:06,29450.0,29450.0,"<p>If I understand your question correctly I think you should look into TKET's architecture module.</p>
<p><a href=""https://cqcl.github.io/tket/pytket/api/architecture.html"" rel=""nofollow noreferrer"">https://cqcl.github.io/tket/pytket/api/architecture.html</a></p>
<p>You can for example define a <code>RingArch</code> or a <code>SquareGrid</code> architecture.</p>
<p>Maybe this jupyter notebook tutorial will be helpful to look at as well.
<a href=""https://github.com/CQCL/pytket/blob/main/examples/mapping_example.ipynb"" rel=""nofollow noreferrer"">https://github.com/CQCL/pytket/blob/main/examples/mapping_example.ipynb</a></p>
",12/21/2022 20:56,Tooling,"The user is seeking information about customizing layouts for quantum circuits in different quantum programming frameworks (Qiskit, TKet, and pyQuil). This relates to the tools and features available in these frameworks.",Tooling,,,,Tooling,
29597.0,How does one convert a truth table to a square permutation matrix?,"<p>Given a classical circuit of <span class=""math-container"">$m$</span> inputs and <span class=""math-container"">$n$</span> outputs, composed of various AND gates, OR gates, NOT gates, etc., a <a href=""https://en.wikipedia.org/wiki/Truth_table"" rel=""nofollow noreferrer"">truth table</a> is a <span class=""math-container"">$2^{m}\times(m+n)$</span>-sized matrix, where, in general, the first <span class=""math-container"">$m$</span> columns encode the binary inputs while the last <span class=""math-container"">$n$</span> columns encode the binary outputs.  When the circuit is reversible and consists of CNOT gates, CCNOT gates, CSWAP gates, etc., we have <span class=""math-container"">$m=n$</span> as the number of inputs is the same as the number of outputs.</p>
<p>However, certain square matrices can also encode the same information as a truth table.  For example, for small enough <span class=""math-container"">$m$</span> <a href=""https://en.wikipedia.org/wiki/Karnaugh_map"" rel=""nofollow noreferrer"">Karnaugh maps</a> can be used to study simplification of such circuits.</p>
<p>When the circuit is reversible, we can also construct a <a href=""https://en.wikipedia.org/wiki/Permutation_matrix"" rel=""nofollow noreferrer"">permutation matrix</a>, which is a square matrix of size <span class=""math-container"">$2^m\times 2^m$</span>, with a single <span class=""math-container"">$1$</span> in each row and each column.  Such matrices are also <a href=""https://en.wikipedia.org/wiki/Unitary_matrix"" rel=""nofollow noreferrer"">unitary</a>, which is a requirement for use in circuit-based quantum computing.  Studying unitary matrices within quantum computing is more useful than studying other matrices such as truth tables, or other square matrices such as Karnaugh maps.</p>
<blockquote>
<p><strong>Given a truth table of a reversible circuit with, say, <span class=""math-container"">$5$</span> inputs and <span class=""math-container"">$5$</span> outputs of size <span class=""math-container"">$2^5\times 10$</span>, how can we construct the corresponding permutation matrix of size <span class=""math-container"">$2^5\times 2^5$</span>?</strong></p>
</blockquote>
<p>What is the general recipe or procedure for translating a truth table to the permutation/unitary matrix?</p>
<hr />
<p><sup> Community Wiki</sup></p>
",<circuit-construction><classical-computing><reversible-computation>,01/06/2023 19:58,29601.0,29601.0,"<p>In the standard convention, a state <span class=""math-container"">$|\psi\rangle$</span> is a column vector and operator <span class=""math-container"">$M$</span> is left multiplied with the state for evolution, i.e <span class=""math-container"">$M|\psi\rangle = |\phi\rangle$</span>.</p>
<p>In this convention, the (row,col)=<span class=""math-container"">$(i,j)$</span> entry of M correspond to (output, input), i.e. if <span class=""math-container"">$\{|b_k\rangle\}$</span> is a basis for the Hilbert space, then <span class=""math-container"">$M_{ij} = \langle b_i|M |b_j\rangle$</span>.</p>
<p>Therefore, to go from truth table to the permutation matrix, you merely have to place 1s in the right location.</p>
<p>Let's consider an example. For the CNOT</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$|00\rangle$</span></td>
<td><span class=""math-container"">$|00\rangle$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$|01\rangle$</span></td>
<td><span class=""math-container"">$|01\rangle$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$|10\rangle$</span></td>
<td><span class=""math-container"">$|11\rangle$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$|11\rangle$</span></td>
<td><span class=""math-container"">$|10\rangle$</span></td>
</tr>
</tbody>
</table>
</div>
<p>The truth table matrix is
<span class=""math-container"">$$
T = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 1 &amp; 0 \\
\end{bmatrix}
$$</span></p>
<p>To create the permutation matrix, we just have to run down the rows of T, and for each row read off the input and output, and place the 1 in the corresponding entry of the permutation matrix.</p>
<p>Let's start with a blank matrix, that will turn into a permutation matrix.
<span class=""math-container"">$$
P = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
$$</span></p>
<p>From the first row of <span class=""math-container"">$T$</span> we learn that (output,input) = (00,00), which tells that the (row,col) = (0,0) must have a 1 in it. (I am going from binary 00 to decimal 0 here)</p>
<p><span class=""math-container"">$$
P = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
$$</span></p>
<p>from the second row of <span class=""math-container"">$T$</span> we learn that (output, input) = (01, 01) = (row, col) = (1,1). Then
<span class=""math-container"">$$
P = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
\end{bmatrix}
$$</span>
Repeating twice more, we learn
<span class=""math-container"">$$
P = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{bmatrix}
$$</span></p>
",01/07/2023 00:14,Theoretical,"The question involves a theoretical concept related to reversible circuits and unitary matrices, specifically how to translate a truth table into a permutation/unitary matrix. It seeks an understanding of the mathematical principles behind this translation.",Theoretical,,,,Theoretical,
29660.0,Using Qiskit State Tomography on Subsystems,"<p>I have a version of the following circuit set up.</p>
<pre><code>from qiskit import QuantumCircuit

circuit=QuantumCircuit(2)
initial_state0=[1/np.sqrt(2),1/np.sqrt(2)]     
circuit.initialize(initial_state0, 0)
initial_state1=[1, 0]
circuit.initialize(initial_state1,1)
circuit.cx(0,1)
</code></pre>
<p>I have seen that I can use StateTomography by coding the following</p>
<pre><code>from qiskit_experiments.library import StateTomography   
from qiskit.providers.aer import Aer
backend = Aer.get_backend('qasm_simulator')

# QST Experiment
qstexp1 = StateTomography(circuit)
qstdata1 = qstexp1.run(backend, seed_simulation=1000).block_for_results()

# Print results
for result in qstdata1.analysis_results():
    print(result)
</code></pre>
<p>By using the coding above I am able to see how this tomography can be used to approximate the state of the entire system with fidelity being a comparison to the state of the circuit, <strong>but my goal</strong> is to use Quantum State Tomography (QST) on only <span class=""math-container"">$q_1$</span> and  use the fidelity to compare this to <span class=""math-container"">$q_0$</span>.</p>
<p>I have seen in the <a href=""https://qiskit.org/documentation/experiments/tutorials/state_tomography.html"" rel=""nofollow noreferrer"">tutorial</a> on Qiskit that I can run the tomography on parallel subsystems, but I'm not sure how to extend this to my goal described above.  Any help would be greatly appreciated!</p>
<p>(Previous edit removed as I resolved that issue independently)</p>
",<qiskit><programming><tomography>,01/11/2023 15:46,29735.0,29735.0,"<p>In the tutorial, tomography on parallel subsystems assumes that subsystems are independent. From your post, I deduce you are interested in something different, i.e., performing tomography of one state after a single circuit has been executed on several qubits. To this purpose, just modify your code using <code>qstexp1 = StateTomography(circuit, measurement_qubits=[1])</code>. In this way, you will obtain the density matrix of <span class=""math-container"">$q_1$</span>. Analytically, such a matrix can be obtained as the partial trace with respect to the density matrix of whole output state -- <span class=""math-container"">$I/2$</span>, in your example. Indeed, your result will be (about) <span class=""math-container"">$I/2$</span>, as expected.</p>
",1/17/2023 7:59,Tooling ," The question pertains to using a specific tool, Quantum State Tomography (QST), in Qiskit, to achieve a particular task related to subsystems and fidelity comparison. It seeks guidance on how to apply the tool effectively in a specific context. ",Tooling ,,,,Tooling ,
29686.0,Qiskit state_fidelity not accepting my Density Matrices,"<p>I'm attempting to use qiskit's <code>state_fidelity(state1, state2, validate=True)</code> but keep getting the following error: QiskitError: 'Input quantum state is not a valid'</p>
<p>In order to use this form I had already read the <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.state_fidelity.html"" rel=""nofollow noreferrer"">documentation</a> to see that state1 and state2 must be either density matrices or statevectors.</p>
<p>As a result I used the <code>qiskit.quantum_info</code> module to generate a density matrix for state1.</p>
<p>For state2 I created the array using numpy importing numbers from state tomography.  (Shown below)</p>
<pre><code>#Turn this into a the density matrix
state2_matrix = (1/2)*np.array([[1+expectation_vals[0], expectation_vals[1]-1j*expectation_vals[2]], [expectation_vals[1]+1j*expectation_vals[2], 1-expectation_vals[0]]])
state2=DensityMatrix(state2_matrix)
</code></pre>
<p>where <code>expectation_vals=[0.004, 1.0, -0.04]</code> comes from my single qubit tomography.</p>
<p><strong>Edit</strong>
This matrix, despite now being created using the Density Matrix class, is still giving me the error that the Input quantum state is not valid.  This leads me to believe that there is some property of density matrices that is not being fulfilled by this matrix.<br />
<span class=""math-container"">$$\begin{bmatrix}
0.502 &amp; \tfrac{1}{2} + 0.02i  \\
 \tfrac{1}{2} - 0.02i &amp; 0.498  \\
 \end{bmatrix}$$</span></p>
<p>I can see it has trace=1, and I found the eigenvalues, using numpy, to be (array([ 1.00040384e+00+0.j, -4.03836916e-04+0.j]).</p>
<p>I now assume that this second eigenvalue is the reason this is not working since Density matrices must be positive semidefinite.  If this is the reason <code>state_fidelity()</code> is not working, then how can this be avoided when using tomography on a single qubit?</p>
<p><strong>Edit 2.0</strong>
In the end I was able to leave <code>validate = True</code>, but I had to renormalize my expectation values in order to do so.  (Pure State)</p>
<p>Thank you all for your help!</p>
",<qiskit><programming><fidelity><tomography>,1/13/2023 20:29,29713.0,29713.0,"<p>When <code>validate=True</code>, the first thing that the <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.state_fidelity.html"" rel=""nofollow noreferrer""><code>state_fidelity</code></a> function does is checking whether both <code>state1</code> and <code>state2</code> are valid quantum states. In particular:</p>
<ul>
<li>if you pass a statevector <span class=""math-container"">$| \psi \rangle$</span>, it checks that <span class=""math-container"">$\langle \psi | \psi \rangle = 1$</span> (unit norm)</li>
<li>if you pass a density matrix <span class=""math-container"">$\rho$</span>, it checks that <span class=""math-container"">$tr(\rho) = 1$</span> and that <span class=""math-container"">$\rho$</span> is positive semidefinite</li>
</ul>
<p>As you already figured out, in your case, <code>state2</code> is a <code>DensityMatrix</code> instance but it's not positive semidefinite and that's why <code>state_fidelity</code> fails.
However, you can compute the fidelity with no errors setting <code>validate=False</code>. Qiskit allows this because, in some cases like maybe yours, you may want to get the fidelity between objects that are not necessarily valid quantum states (e.g. affected by some form of noise).</p>
<p><strong>EDIT</strong>: also, note that <code>state1</code> and <code>state2</code> can simply be numpy arrays or Python lists. So, creating the <code>DensityMatrix</code> from your array is an unnecessary step because the conversion occurs anyway inside the <code>state_fidelity</code> function.</p>
",1/16/2023 15:53, Errors,"The question is related to a specific error message encountered when using the state_fidelity() function in Qiskit with a certain density matrix. It involves seeking a solution and understanding the limitations of the DensityMatrix class, which falls under the category of errors ", Errors,,,, Errors,
29742.0,how to flatten a cirq.Circuit with CircuitOperation,"<p>I have a <code>cirq.Circuit</code> that uses a <code>CircuitOperation</code>, something like:</p>
<pre><code>circuit = cirq.Circuit(cirq.CircuitOperation(cirq.X.on(q), repetitions=5))
</code></pre>
<p>How can I flatten this circuit to remove the CircuitOperation and just have the moments?</p>
",<programming><quantum-circuit><cirq>,1/17/2023 18:14,29746.0,29746.0,"<p>One &quot;hacky&quot; way to do it is to convert it to/from qasm. For example:</p>
<pre><code>import cirq
from cirq.contrib.qasm_import import circuit_from_qasm

q = cirq.NamedQubit(&quot;q&quot;)
circuit = cirq.Circuit(
    cirq.Y(q),
    cirq.CircuitOperation(cirq.FrozenCircuit(cirq.X(q)), repetitions=5),
    cirq.Z(q)
)

circuit_flat = circuit_from_qasm(circuit.to_qasm())

print(circuit)
print(circuit_flat)
</code></pre>
<pre><code>q: âââYâââ[ q: âââXâââ ](loops=5)âââZâââ

q_0: âââYâââXâââXâââXâââXâââXâââZâââ
</code></pre>
<p><strong>EDIT:</strong></p>
<p>A better way is to use <a href=""https://quantumai.google/reference/python/cirq/expand_composite"" rel=""nofollow noreferrer"">cirq.expand_composite</a>:</p>
<blockquote>
<p>A transformer that expands composite operations via <code>cirq.decompose</code>.</p>
<p>For each operation in the circuit, this pass examines if the operation can be decomposed. If it can be, the operation is cleared out and replaced with its decomposition using a fixed insertion strategy.</p>
<p>Transformation is applied using <code>cirq.map_operations_and_unroll</code>, which preserves the moment structure of the input circuit.</p>
</blockquote>
<p>Continuing from the example above:</p>
<pre><code>circuit_flat2 = cirq.expand_composite(circuit)

print(circuit_flat2)
</code></pre>
<pre><code>q: âââYâââXâââXâââXâââXâââXâââZâââ
</code></pre>
",1/17/2023 20:39,API Usage,"The question is about how to use the cirq.flatten() function to flatten a circuit that contains a CircuitOperation, which is a specific API function.",API Usage,,,,API Usage,
29784.0,How to check a given unitary evolution is correct in a real quantum computer in Qiskit?,"<p>For a given unitary, I want to know whether this unitary gate is correctly evolved in the circuit. In the simulator, I can use &quot;statevector&quot; to get the state vector to check the correctness of the evolution.</p>
<p>But I don't know whether such a unitary can still evolve correctly on a real quantum computer. Is there a corresponding way to check its correctness?</p>
<p>In more detail, I give a Hamiltonian H, then I get unitary <code>U=expm(-1t*H)</code>. Then I add this unitary gate to the circuit using<code>qc.unitary(U, [0,1])</code>. So how can I check whether it evolves  correctly in the real quantum computer?</p>
",<qiskit><programming><quantum-gate><quantum-state><unitarity>,1/20/2023 10:24,29785.0,29785.0,"<p>There is no way to get a &quot;<em>perfectly</em> correct&quot; state evolution on a real quantum computer since the hardware is affected by different types of noise (e.g. coherent gate error, state decoherence, etc.) and it is not error-corrected.</p>
<p>What you can do is to first run your quantum circuit implementing the unitary <span class=""math-container"">$U$</span> on a <em>perfect</em> simulator, in order to check it is doing what it is supposed to do, and then set it up to run on your real device. In this case, you can be pretty sure that the deviation between the simulation and the actual execution is due to noise effects only.</p>
",1/20/2023 10:58,API Usage,"The question is about how to use a specific function (qc.unitary) in a quantum computing library (Qiskit) to check the correctness of the evolution of a unitary gate on a real quantum computer, which falls under the category of API usage. ",API Usage,,,,API Usage,
29964.0,"Generating random, but non-uniform state","<p>I would like an algorithm that generates a random state, sampled according to some probability distribution which is not uniform in Hilbert space.  Assume though that I have at my disposal a uniform (i.e. Haar) random state generator. How do I do that?</p>
<p>For concreteness consider the case of a single qubit.</p>
<p>Then a Haar random state is a point on the Bloch sphere which is distributed according to the Haar measure <span class=""math-container"">$d\psi$</span> on the sphere. One way to generate such states on a computer is to create a column vector with real and imaginary parts i.i.d. according to <span class=""math-container"">$\mathcal{N}(0,1)$</span>, then normalize it. This method generalizes to multiple qubits.</p>
<p>But suppose I want to generate states sampled not according to <span class=""math-container"">$d\psi$</span>, but according to
<span class=""math-container"">$$
p( \psi) d\psi = 2 \langle \psi|0\rangle \langle 0|\psi \rangle d\psi,
$$</span>
where <span class=""math-container"">$|0\rangle$</span> is the state corresponding to the North Pole on the Bloch sphere. One can check that <span class=""math-container"">$p(\psi) \geq 0$</span> and <span class=""math-container"">$\int d\psi p(\psi)  = 1$</span> so <span class=""math-container"">$p(\psi$</span>) is a valid probability density function. This distribution, is such that states near the North Pole occur more likely than states near the South Pole.</p>
<p>How would I write a simple program to do this?</p>
<p>Note: this is similar to the standard case of real numbers where if we have a uniform r.n.g. in <span class=""math-container"">$[0,1]$</span> we can use this to generate random numbers sampled from any other arbitrary distribution on the real line, e.g. using Box-Muller, inverse transform, ziggurat, rejection sampling. Presumably some variant of the above methods generalizes, but since the sample space is different I am finding it difficult to think about it.</p>
",<programming><probability><haar-distribution>,02/01/2023 00:58,29969.0,29969.0,"<p>Rejection sampling is a good fit and works without any changes, simply by plugging the desired distribution <span class=""math-container"">$p(\psi)$</span> into the standard algorithm.</p>
<p>Let<span class=""math-container"">$^1$</span> <span class=""math-container"">$M:=\max_{\psi\in\mathbb{CP}^1} p(\psi)$</span>. To sample a pure state <span class=""math-container"">$\psi$</span> from the distribution specified by <span class=""math-container"">$p(\psi)$</span>, do the following:</p>
<ol>
<li>Sample a pure state <span class=""math-container"">$\psi$</span> from the Haar distribution.</li>
<li>Sample a real number <span class=""math-container"">$x$</span> from the uniform distribution over <span class=""math-container"">$[0,M]$</span>.</li>
<li>If <span class=""math-container"">$x&gt;p(\psi)$</span>, go back to 1.</li>
<li>Return <span class=""math-container"">$\psi$</span>.</li>
</ol>
<p>This works for the same reason any rejection sampling works. Essentially, we are sampling uniformly distributed points <span class=""math-container"">$(\psi,x)$</span> from <span class=""math-container"">$\mathbb{CP}^1\times[0,M]$</span>, throwing away the points that are &quot;above the plot of <span class=""math-container"">$p(\psi)$</span>&quot; and keeping the ones &quot;below it&quot;.</p>
<hr />
<p><sup><span class=""math-container"">$^1$</span> The maximum exists, because Bloch sphere <span class=""math-container"">$\mathbb{CP}^1$</span> is compact and <span class=""math-container"">$p(\psi)$</span> is continuous.
</sup></p>
",02/01/2023 08:16,Theoretical,"The question is about understanding the theoretical process of generating a random quantum state sampled according to a non-uniform probability distribution in Hilbert space, which falls under the category of Theoretical",Theoretical,,,,Theoretical,
30090.0,I can't load account on IBM's qiskit,"<p>I do this but it still gives an error for load account</p>
<ul>
<li>IBMQ.delete_account()</li>
<li>IBMQ.active_account()</li>
<li>IBMQ.save_account('myAPI toke ')</li>
<li>IBMQ.save_account('my API toke')</li>
<li>IBMQ.load_account()</li>
</ul>
<p><strong>entire error</strong></p>
<p>HTTPError               Traceback (most recent call last)
C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
277             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 278             response.raise_for_status()
279         except RequestException as ex:</p>
<p>C:\111\lib\site-packages\requests\models.py in raise_for_status(self)
1020         if http_error_msg:
-&gt; 1021             raise HTTPError(http_error_msg, response=self)
1022</p>
<p>HTTPError: 403 Client Error: Forbidden for url: <a href=""https://auth.quantum-computing.ibm.com/api/version"" rel=""nofollow noreferrer"">https://auth.quantum-computing.ibm.com/api/version</a></p>
<p>The above exception was the direct cause of the following exception:</p>
<p>RequestsApiError                          Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_297760\485379158.py in 
----&gt; 1 IBMQ.load_account()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
175         # Explicitly check via a server call, to allow environment auth URLs
176         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 177         version_info = self._check_api_version(credentials)
178
179         # Check the URL is a valid authentication URL.</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
442         version_finder = VersionClient(credentials.base_url,
443                                        **credentials.connection_parameters())
--&gt; 444         return version_finder.version()
445
446     def _initialize_providers(</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
47                 * <code>api-*</code> (str): The versions of each individual API component
48         &quot;&quot;&quot;
---&gt; 49         return self.client_version_finder.version()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
100         &quot;&quot;&quot;
101         url = self.get_url('version')
--&gt; 102         response = self.session.get(url)
103
104         try:</p>
<p>C:\111\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
598
599         kwargs.setdefault(&quot;allow_redirects&quot;, True)
--&gt; 600         return self.request(&quot;GET&quot;, url, **kwargs)
601
602     def options(self, url, **kwargs):</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
298                 self._modify_chained_exception_messages(ex)
299
--&gt; 300             raise RequestsApiError(message, status_code) from ex
301
302         return response</p>
<p><strong>I perform this operation, but again it gives an error for load account</strong></p>
",<qiskit><programming><ibm-q-experience><quantum-circuit><qiskit-runtime>,02/07/2023 06:39,30124.0,30124.0,"<p>I suggest to install the latest version of qiskit and follow the documentation you can find here, about the class IBMProvider: <a href=""https://github.com/Qiskit/qiskit-ibm-provider"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-ibm-provider</a></p>
<p>Here is an example program:</p>
<pre><code># This code works with qiskit 0.41.0

# Import Qiskit
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, QiskitError
from qiskit import execute
from qiskit_ibm_provider import IBMProvider
from qiskit_ibm_provider import least_busy

try:

    # Create a Quantum Register with 2 qubits.
    q = QuantumRegister(2)
    # Create a Classical Register with 2 bits.
    c = ClassicalRegister(2)
    # Create a Quantum Circuit
    qc = QuantumCircuit(q, c)

    vector = [0.5, 0.5, 0.5, 0.5]

    qc.initialize(vector)
    qc.draw()
    # Add a Measure gate to see the state.
    qc.measure(q, c)

    # the following instruction must be used the very first time, then commented
    # IBMProvider.save_account(token='MY_API_TOKEN') 

    # the following instruction is the one you will use always
    provider = IBMProvider()

    # display current supported backends
    print(provider.backends(min_num_qubits=5, simulator=False, operational=True))

    small_devices = provider.backends(min_num_qubits=5, simulator=False, operational=True)
    backend = least_busy(small_devices)
    print(backend)

    #running the job
    job_exp = execute(qc, backend, shots=2048)
    result_exp = job_exp.result()

    # Show the results
    print('Counts: ', result_exp.get_counts(qc))


except QiskitError as ex:
    print('There was an error in the circuit!. Error = {}'.format(ex))
</code></pre>
",02/08/2023 17:38,Errors,"The question is related to a specific error message encountered when using the load_account() function in Qiskit. It involves seeking a solution to this error, which falls under the category of errors",Errors,,,,Errors,
30109.0,Is it possible to automatically rename a job at submission time?,"<p>I would like to find out if there is some way to rename a job automatically, either when the job is first sent to the queue, or later after the fact. I've tried searching through the forum and the documentation to try and find a solution, but nothing that seems to do the trick. The closest I have found is the <code>qobj_id</code> parameter, however, this is depreciated and no longer functions.</p>
<p>Edit: I finally found a (frustratingly easy) solution, see my answer below</p>
",<qiskit><programming>,02/07/2023 20:26,30153.0,30153.0,"<p>I finally managed to find a solution. It actually ended up being so simple, that I think the only way that I had missed it was that I was looking for a solution within <code>backend.run()</code> or <code>execute()</code> and not the job object itself. The solution uses the <code>job.update_name()</code> method and here is a simple implementation of it.</p>
<pre><code>backend = provider.get_backend('ibm_nairobi')

qreg_q = QuantumRegister(1, 'q')
creg_c = ClassicalRegister(1, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.h(qreg_q[0])
circuit.measure(qreg_q[0], creg_c[0])

job = execute(circuit, backend, shots=8192, memory=True)
job.update_name('test_name') #the new job will have the name &quot;test_name&quot;
</code></pre>
",02/10/2023 20:48, API Usage,"The question is about how to rename a job automatically in Qiskit, which is a specific API usage issue.", Tooling,"The user is looking for a way to rename jobs in Qiskit, and they are seeking assistance or information on how to achieve this, which falls under the category of tooling and functionality.",No,131.0,Tooling,"This is because the user is seeking assistance or information on how to achieve a specific task within the Qiskit framework, namely renaming jobs, which falls under the category of tooling and functionality."
30222.0,"Deustch-Jozsa algorithm for a specific problem, doesn't make sense?","<p>I am trying to implement Deustch-Jozsa Algorithm where function f(x) = 0 for even and f(x) = 1 for odd, for a four-bit number. After writing the numbers out I found a pattern as described below
<a href=""https://i.stack.imgur.com/qyrsJ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qyrsJ.jpg"" alt=""enter image description here"" /></a></p>
<p>Therefore as you can see the from the image, all I need to do is add the CNOT gate to the last register so to implement the oracle and here is my circuit that I have written for the same. Here is the circuit and output for the same
<a href=""https://i.stack.imgur.com/c7X1X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c7X1X.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/nbOpT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nbOpT.png"" alt=""enter image description here"" /></a></p>
<p>My question is shouldn't the output be '1111' since this is a balanced function. The number corresponding in the circuit is 2 = '0010' and the output is showcased for the same. I would highly appreciate breakdown. Also the does the circuit implement the oracle where f(x) = 0 is even and for</p>
",<programming><quantum-gate><algorithm><deutsch-jozsa-algorithm>,2/15/2023 13:53,30223.0,30223.0,"<p>Your oracle is correct. The mistake here is that you initialized <span class=""math-container"">$q_1$</span> to <span class=""math-container"">$|1\rangle$</span> instead of the ancilla qubit. So the proper circuit here would be something like <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Measure%22%2C%22Measure%22%2C%22Measure%22%2C%22Measure%22%5D%5D%7D"" rel=""nofollow noreferrer"">this</a>:</p>
<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <a href=""https://i.stack.imgur.com/vMUH0m.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vMUH0m.png"" alt=""enter image description here"" /></a></p>
<p>This would give the state <span class=""math-container"">$|1000\rangle$</span> with probability <span class=""math-container"">$1$</span>, which shows that <span class=""math-container"">$f(x)$</span> is balanced.</p>
<p>For your second question, recall that Deutsch-Jozsa algorithm guarantees that either the final measurement will give <span class=""math-container"">$|0\rangle^{\otimes n}$</span> with probability <span class=""math-container"">$1$</span>, in which case our function is constant, or it will yield some other state, in which case we have a function that's balanced. Our measured state <strong>need not</strong> be <span class=""math-container"">$|1\rangle^{\otimes n}$</span> to deduce that <span class=""math-container"">$f(x)$</span> is balanced.</p>
",2/15/2023 14:58,API Usage,"The question is about the implementation of the Deutsch-Jozsa Algorithm using a quantum computing library, and understanding the output of the implemented circuit, which falls under the category of API usage.",API Usage,,,,API Usage,
30279.0,A quantum circuit to find if 4 given sides can form a rectangle,"<p>I wrote this code that uses a swap test to find if 2 pairs of sides are equal.
First, amplitude encoding the 4 sides on 3 qubits then performing the swap test. I'm not sure where my logic went faulty, especially that I'm not very familiar with the logic of swap test yet.
Here is the code</p>
<pre><code>import math

def is_rectangle(A: int, B: int, C: int, D: int) -&gt; int:
    # Define quantum circuit with 3 qubits and 1 classical bit
    qr = QuantumRegister(3)
    cr = ClassicalRegister(1)
    qc = QuantumCircuit(qr, cr)

    # Encode the input integers into the state of the first 2 qubits using amplitude encoding
    alpha = math.acos(math.sqrt(A/float(A**2 + B**2)))
    beta = math.acos(math.sqrt(B/float(A**2 + B**2)))
    qc.ry(2*alpha, qr[0])
    qc.ry(2*beta, qr[1])

    gamma = math.acos(math.sqrt(C/float(C**2 + D**2)))
    delta = math.acos(math.sqrt(D/float(C**2 + D**2)))
    qc.ry(2*gamma, qr[2])
    qc.ry(2*delta, qr[1])

    # Apply a series of SWAP gates to create the entangled state needed for the swap test
    qc.cx(qr[1], qr[2])
    qc.cx(qr[0], qr[1])
    qc.cx(qr[1], qr[2])
    qc.cx(qr[0], qr[1])
    qc.cx(qr[1], qr[2])

    # Apply the swap test to determine if the input integers satisfy any of the conditions
    qc.h(qr[2])
    qc.cx(qr[2], qr[1])
    qc.h(qr[2])

    # Measure the third qubit and return the measurement result as the output of the function
    qc.measure(qr[2], cr[0])

    # Run the quantum circuit using the Qiskit simulator
    simulator = Aer.get_backend('qasm_simulator')
    result = execute(qc, simulator, shots=1).result()
    counts = result.get_counts()
    if '1' in counts:
        return 1
    else:
        return 0<span class=""math-container"">```</span>
</code></pre>
",<qiskit><quantum-gate><programming><algorithm><quantum-circuit>,2/19/2023 10:00,30289.0,30289.0,"<p>I think you may want to change a few things. I've coded up the experiment like this (which should be easy to port to Qiskit and/or use it to correct your circuit):</p>
<p>First - the function signature, the hopefully identical sides should be <code>a1</code> and <code>a2</code>, as well a <code>b1</code> and <code>b2</code>. For experimentation, use values in the range of 0.0 - 1.0:</p>
<pre><code>def run_experiment(a1: np.complexfloating, a2: np.complexfloating,
                   b1: np.complexfloating, b2: np.complexfloating) -&gt; float:
  &quot;&quot;&quot;Construct swap test circuit and measure.&quot;&quot;&quot;

  # The swap circuit is quite simple:
  #
  # |0&gt; --- H --- o --- H --- Measure
  #               |
  # a1  --------- x ---------
  #               |
  # a2  ----------x ---------
</code></pre>
<p>Create a circuit and a few registers, 1 register for each side (I use 2 registers of size 2 below) as well as 2 ancillas:</p>
<pre><code>  qc = circuit.qc()
  ab = qc.reg(2, 0)
  cd = qc.reg(2, 0)
  anc = qc.reg(2, 0)
</code></pre>
<p>Now encode the length into rotations on each of the 4 qubits corresponding to the 4 sides:</p>
<pre><code>  qc.ry(ab[0], 2 * np.arcsin(a1))
  qc.ry(ab[1], 2 * np.arcsin(a2))
  qc.ry(cd[0], 2 * np.arcsin(b1))
  qc.ry(cd[1], 2 * np.arcsin(b2))
</code></pre>
<p>Now, 2 swap tests (from <code>anc[0]</code> and <code>anc[1]</code> to the qubits corresponding to the sides, bracketed by Hadamards:</p>
<pre><code>  qc.h(anc)
  qc.cswap(anc[0], ab[0], ab[1])
  qc.cswap(anc[1], cd[0], cd[1])
  qc.h(anc)
</code></pre>
<p>Now - measurement. In my infra I can just get the probabilities of the ancillas. If the sides were identical, the corresponding probability will be 1.0. If the sides were, for example, maximally different as 0.0 and 1.0, the probability would be 0.5:</p>
<pre><code>  p0_ab, _ = ops.Measure(qc.psi, anc[0], 0, collapse=False)
  p0_cd, _ = ops.Measure(qc.psi, anc[1], 0, collapse=False)

  print(f'a1: {a1:.3f} a1: {a2:.3f} b1: {b1:.3f} b2: {b2:.3f}')
  print(f'p0_ab: {p0_ab:.2f} p0_cd: {p0_cd:.2f} ')
</code></pre>
<p>And to test:</p>
<pre><code>def main(argv):
  if len(argv) &gt; 1:
    raise app.UsageError('Too many command-line arguments.')

  run_experiment(1.0, 1.0, 0.5, 0.5)

&gt;&gt;
a1: 1.000 a1: 1.000 b1: 0.500 b2: 0.500
p0_ab: 1.00 p0_cd: 1.00 
</code></pre>
<p>Or</p>
<pre><code>  run_experiment(0.5, 0.6, 0.2, 0.6)

&gt;&gt;
a1: 0.500 a1: 0.600 b1: 0.200 b2: 0.600
p0_ab: 0.99 p0_cd: 0.91 
<span class=""math-container"">```</span>
</code></pre>
",2/20/2023 4:52, Errors,The user is seeking solutions and explanations for errors and exceptions in their quantum program development. They have shared a code snippet and are unsure about the logic of the swap test used in it., Errors,,,, Errors,
31507.0,"Is there something wrong with cross-entropy benchmarking, or is it still considered as a reasonable path towards quantum supremacy?","<p>My question is strongly related with <a href=""https://quantumcomputing.stackexchange.com/q/27873/10454"">this one</a>. Google's quantum supremacy claim uses Random Circuit Sampling. The principle is the following one: a realistic noise model for random circuits performed on a noisy quantum computer is the depolarising channel. That is, if <span class=""math-container"">$|\psi\rangle\!\langle\psi|$</span> is the pure state one would have got when applying a random circuit <span class=""math-container"">$C$</span> with a perfect quantum computer, the final state when executing this circuit on a noisy device is the following:
<span class=""math-container"">$$\rho=\lambda|\psi\rangle\!\langle\psi|+\frac{1-\lambda}{2^n}I_{2^n}$$</span>
Using this state, one can compute the Cross-Entropy Benchmarking, which can be seen as a random variable whose expectation is equal to <span class=""math-container"">$\frac{1+\lambda}{2^n}$</span>. It was then believed that sampling from a distribution over the <span class=""math-container"">$n$</span>-bit strings that give a XEB of <span class=""math-container"">$\frac{1+b}{2^n}$</span> for <span class=""math-container"">$b&gt;0$</span> was exponentially hard for a classical computer.</p>
<p>This claim was also strengthened by <a href=""https://arxiv.org/abs/1910.12085v5"" rel=""nofollow noreferrer"">Aaronson and Gunn</a> who, from my understanding, show this very assumption. In a <a href=""https://arxiv.org/pdf/2303.01625.pdf"" rel=""nofollow noreferrer"">very recent paper by Aaronson and Hung</a>, the restate that this problem is hard for a classical computer (once again, from my understanding).</p>
<p>On the other hand, there has been a substantial number of protestations against this claim. IBM states that using another algorithm than the one considered by Google, <a href=""https://www.ibm.com/blogs/research/2019/10/on-quantum-supremacy/"" rel=""nofollow noreferrer"">a supercomputer would have been able to obtain similar results</a>, some papers claim that <a href=""https://arxiv.org/pdf/2103.03074.pdf"" rel=""nofollow noreferrer"">they actually managed to do it using a 60-GPU cluster</a>, which was then <a href=""https://arxiv.org/pdf/2111.03011.pdf"" rel=""nofollow noreferrer"">improved to uncorrelated bitstrings with a 512-GPU cluster</a>, which seems to contradict the aforementioned papers' claims. Finally, Aharonov et al. <a href=""https://arxiv.org/pdf/2211.03999.pdf"" rel=""nofollow noreferrer"">designed a classical algorithm that run in polynomial time and that is able to sample from the distribution of a random circuit applied on a noisy quantum computer</a> (once again, from my understanding). They note however that due to large constant in the algorithm running time, this does not contradict the various supremacy claims that have been made.</p>
<p>How can all these statements be true at the same time? Can the XEB test be easily passed in the <span class=""math-container"">$50-60$</span> qubits regime, or do these algorithms tackle a different problem?</p>
",<classical-computing><quantum-advantage><google-sycamore>,03/06/2023 15:08,31523.0,31523.0,"<p>I think that the original rationale for using the linear cross-entropy (XEB) score as a metric to claim quantum computational supremacy <em>was valid</em>, but we may now be at a point now where the <em>continued use</em> of linear XEB for random circuit sampling on transmon qubit architectures to score and claim quantum advantage is not as justified as it was maybe in 2019, at least for two reasons:</p>
<ol>
<li><p>It was known from the beginning that classical verification of cross-entropy scores scales exponentially with the number of qubits.  This is still true today as it was in 2019.  We still have no way to efficiently verify the output from a set of strings generated by a quantum computer (or, for that matter, by the algorithms of Aharanov <em>et al</em>.) But, with about 60 or so qubits, this was hoped and expected to be in the goldilocks zone of not being too hard verify efficiently nor too easy to be classically spoofed.  If we used much more than that (say, with more than 100 qubits), we cannot even classically calculate the linear XEB score.</p>
</li>
<li><p>Much of the work you mentioned, for example IBM's initial response, required exponential resources not just to verify but also to even generate samples - whereas a quantum computer (even with a dilution refrigerator) would use exponentially fewer resources to generate the samples.  But, what Aharanov <em>et al.</em> showed was that a classical computer could generate noisy samples from random circuit sampling where the resources to generate these samples grow polynomially - even though it takes exponential resources to verify and calculate the score.</p>
</li>
</ol>
<p>There might be a handful of remaining loopholes to consider - for example, if we could keep the depth of our RCS algorithm constant the Aharanov <em>et al.</em> paper might not carry through.  I also don't know the implications of the recent work for Boson Sampling experiments.</p>
<p>Another frustration is that without cross-entropy benchmarking, we don't know the best answer to what other ways do we have to prove that we've gone beyond classical with our computational resources in the NISQ era?  Shor's algorithm is out, as it requires error correction.  Some neat approaches of <a href=""https://www.nature.com/articles/s41567-022-01643-7"" rel=""nofollow noreferrer"">Kahanamoku-Meyer <em>et al.</em></a> might eventually be viable, but there's perhaps a long way to go.</p>
<p>I also like the <a href=""https://arxiv.org/abs/2210.07234"" rel=""nofollow noreferrer"">new results</a> of Chen <em>et al.</em> on the NISQ complexity class, suggesting that there likely still <em>is</em> exponential advantage for some carefully chosen problems even in the presence of noise - but instantiating these problems seems a bit tough now.  For example, the Bernstein-Vazirani problem requires <span class=""math-container"">$O(1)$</span> quantum, but <span class=""math-container"">$O(n)$</span> classical queries (using perfect qubits); this is changed to <span class=""math-container"">$O(\log n)$</span> NISQ queries - still an exponential separation.</p>
",03/07/2023 13:54,Theoretical,"The question is seeking an understanding of the theoretical aspects and debates surrounding quantum supremacy claims, XEB tests, and classical algorithms' abilities to simulate quantum computations, which falls under the ""Theoretical"" category.",Theoretical,,,,Theoretical,
31584.0,Is it possible to brute force the Salsa-20 algorithm with quantum computing in a reasonable amount of time?,"<p>I was recently attacked by the LockBit 3.0 ransomware. I researched it and found this article: <a href=""https://blogs.vmware.com/security/2022/10/lockbit-3-0-also-known-as-lockbit-black.html"" rel=""nofollow noreferrer"">LockBit 3.0 Ransomware Unlocked</a>. It said that &quot;files are encrypted using the Salsa-20 algorithm.&quot; I have the decryption ID and it also explains that &quot;the unencoded first eight bytes of the public key are converted to their hex values and saved to the DECRYPTION_ID.txt file.&quot; I wondered if I could make a program on a classical computer that could somehow brute-force the keys, but I realized that could take years, literally.</p>
<p>I then wondered if using a quantum computer would help. I saw something called the Grover algorithm that I might need to use. Instead of O(N) time, it makes it O(sqrt N) time. Since, I have the decryption ID, I would think the process would be a little shorter, but maybe not by much. After all this, could I brute force this in a reasonable amount of time? If so, how would I go about it with qiskit?</p>
",<qiskit><programming><algorithm><grovers-algorithm>,03/11/2023 06:36,31586.0,31586.0,"<p>I'm sorry to disappoint you, but with the current state of quantum hardware it is not possible to brute force any symmetric algorithm with a non-trivial key size (let alone 128 bits of key size, which is the minimum in Salsa-20).</p>
<p>If you are still curious, <a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#3qubits"" rel=""nofollow noreferrer"">here is a textbook example with 3-bits, implemented in Qiskit</a>.</p>
",03/11/2023 12:09,Tooling , The user is asking about how to use a quantum computing tool (Qiskit) and a specific quantum algorithm (Grovers algorithm) to potentially brute-force decrypt files encrypted by the LockBit 3.0 ransomware,Tooling ,,,,Tooling ,
31633.0,"Where is ""quantum search"" in the complexity hierarchy?","<p>Grover's algorithm is one of the most popular quantum algorithms that solves the problem of &quot;quantum search.&quot; But what is this problem, and what are its characteristics.</p>
<p>When considering other famous problems, like integer factorization, they are organized into complexity classes. Integer factorization, for example, is believed to be in the NP-intermediate class (the class of problems in NP that are not in P or NP-complete). Of course, it isn't a decision problem, so it should actually be in TFNP.</p>
<p>But where in the complexity hierarchy does &quot;quantum search&quot; lie?</p>
",<grovers-algorithm><complexity-theory><classical-computing>,3/13/2023 22:37,31655.0,31655.0,"<p>Grover's algorithm is best thought of as solving an <a href=""https://en.wikipedia.org/wiki/Oracle_machine"" rel=""nofollow noreferrer"">oracle problem</a>, using the square-root of the number of oracle calls that a classical computer would use.</p>
<p>Grover <a href=""https://arxiv.org/abs/quant-ph/9605043"" rel=""nofollow noreferrer"">originally</a> framed the problem as solving an NP problem in the square-root of the time of a classical machine.  For example the oracle could be a particular instance of <a href=""https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"" rel=""nofollow noreferrer"">3-SAT</a>.  If we believe in pretty standard computational complexity conjectures, it's unlikely that there's an algorithm that solves a 3-SAT problem on <span class=""math-container"">$n$</span> bits with less than <span class=""math-container"">$2^{n/{(1+\epsilon})}$</span> queries classically, but Grover's algorithm gives a quantum solution with only <span class=""math-container"">$2^{n/2}$</span> queries.</p>
<p>The question also refers to a &quot;complexity hierarchy&quot;.  Perhaps you meant the <a href=""https://en.wikipedia.org/wiki/Polynomial_hierarchy"" rel=""nofollow noreferrer"">polynomial hierarchy</a>?  I haven't thought about it too much but I guess you could also change the oracle in Grover's algorithm to be somewhere in the polynomial hierarchy - for example, you could ask for a mate-in-<span class=""math-container"">$n$</span> moves in a sufficiently generalized version of Chess - I'm not sure whether or how Grover's speedup would apply to such a problem, though.</p>
",3/14/2023 13:13,Theoretical,"The question is focused on understanding the characteristics and complexity classification of the ""quantum search"" problem, which is a theoretical inquiry about the nature of a quantum algorithm, placing it under the ""Theoretical"" category.",Theoretical,,,,Theoretical,
31642.0,How to apply QFT to the last two qubits of a Qiskit quantum circuit?,"<p>I'm pretty new in Qiskit and quantum circuits. I'm using Qiskit to implement a quantum circuit and I followed this <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html"" rel=""nofollow noreferrer"">tutorial</a> to implement a QFT. The way this QFT was built, it applies QFT in the first <span class=""math-container"">$n$</span> qubits, but what I need is to apply the QFT in the last <span class=""math-container"">$n$</span> qubits. Is there any way to do this?</p>
",<qiskit><programming><algorithm><quantum-fourier-transform>,3/14/2023 6:05,31646.0,31646.0,"<p>In general, to build a Quantum Fourier Transform on an arbitrary number of qubits, you can use the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.QFT.html"" rel=""nofollow noreferrer"">QFT class</a> already implemented in Qiskit.
In particular, to apply it to the last two qubits of your circuit, you can convert the QFT object to a gate and then append it passing the qubits indices.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import QFT

qc = QuantumCircuit(3)
qft = QFT(num_qubits=2).to_gate()
qc.append(qft, qargs=[1, 2])

qc.decompose(reps=2).draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/dg4sl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dg4sl.png"" alt=""enter image description here"" /></a></p>
",3/14/2023 8:28, Tooling ,"The user is asking about how to use Qiskit, a specific quantum computing software, to implement a Quantum Fourier Transform (QFT) on the last n qubits of a quantum circuit. This falls under questions related to tools and software usage in quantum programming.", Tooling ,,,, Tooling ,
31841.0,How to decompose the following circuit using just CX and U3 gate?,"<p>I am trying to decompose the following circuit using just the CX gate and U3 gate.
<a href=""https://i.stack.imgur.com/PVgDG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PVgDG.png"" alt=""enter image description here"" /></a></p>
<p>This is because IBM uses CX and U3 gates as basis states and trying to understand the same. Is there a function that decomposes based on the backend configuration?</p>
",<quantum-gate><programming><quantum-state>,3/26/2023 23:33,31843.0,31843.0,"<p>The basis gate set of IBM quantum devices was <span class=""math-container"">$\{\text{CX}, \text{U3}\}$</span> but this has been changed. The current basis gate set for IBM quantum devices is available in the <a href=""https://quantum-computing.ibm.com/services/resources?tab=systems"" rel=""nofollow noreferrer"">device catalog</a>:</p>
<p><a href=""https://i.stack.imgur.com/dVprW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dVprW.png"" alt=""enter image description here"" /></a></p>
<p>Programmatically, you can get the basis gate set for a backend as follows:</p>
<pre><code>backend.configuration().basis_gates
</code></pre>
<p>And to compile the input circuit to some target backend, use <a href=""https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html"" rel=""nofollow noreferrer""><code>transpile()</code></a> method</p>
<pre><code>transpiled_circuit = transpile(original_circuit, backend=backend)
</code></pre>
<hr />
<p><strong>Update</strong></p>
<p>If all what you want is to expand the gates in your circuit into one- and two-qubit gates you can use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.decompose.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.decompose()</code></a>. By default, <code>decompose()</code> method does a shallow decomposition, that is, decomposes one level only. You can pass <code>reps</code> parameter for iterative decomposition.</p>
<pre><code>decomposed_circuit = original_circuit.decompose(reps=3)
</code></pre>
<p>You can still use <code>transpile()</code> method in this case but instead of passing <code>backend</code> parameter, you specify the basis gate set using <code>basis_gates</code> parameter:</p>
<pre><code>transpiled_circuit = transpile(original_circuit, basis_gates=['cx', 'u'], optimization_level=3)
</code></pre>
<p>In addition to decomposing the gates and transforming them into the gate set you want, <code>transpile</code> will optimize your circuit.</p>
<pre><code>print('Decomposed circuit depth:', decomposed_circuit.depth())
print('Transpiled circuit depth:', transpiled_circuit.depth())
</code></pre>
",3/27/2023 0:11,Tooling,"The user is asking about a function to decompose a quantum circuit into CX and U3 gates, which is a tooling question.",Tooling,,,,Tooling,
31874.0,Qiskit - Approximation of Hamiltonian energy via QPE,"<p>I'm trying to study QPE with the motivation of obtaining eigenvalues of Hamiltonian, i.e. energies of a system. My problem is, that while <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html"" rel=""nofollow noreferrer"">np.linalg.eig</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.minimum_eigensolvers.VQE.html#qiskit.algorithms.minimum_eigensolvers.VQE"" rel=""nofollow noreferrer"">VQE</a> are agreeing on the lowest energy, energy obtained via QPE is completely off.</p>
<p>My Hamiltonian looks like this
<span class=""math-container"">$$
\widehat{H} = -II + 0.3IZ -0.01ZY + 0.1YX
$$</span></p>
<p>and I'd expect its eigenvalues to be (roughly) <code>[-0.39328755, -0.89, -1.11, -1.60671245]</code>. Using VQE I'm obtaining <code>-1.6067123508302064</code>, i.e. the number very close to the lowest eigenvalue.</p>
<p>On the other hand, when I run my QPE code, I'm getting number like <code>-0.392699</code>, not knowing, where is the problem.</p>
<hr />
<h3>My code</h3>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print(eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print(result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=2048)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
<span class=""math-container"">```</span>
</code></pre>
",<qiskit><programming><hamiltonian-simulation><phase-estimation><chemistry>,3/28/2023 16:58,32444.0,32444.0,"<p>Most likely because your initial state has very small overlap with your ground state. You can check by just looking at the eigenvector correspond to the lowest eigenvalue. So change the initial state. I changed it to uniformly superposition state by adding the following line of code right after you defined the <code>measure_circ</code> quantum circuit.</p>
<pre><code>measure_circ.h([-1, -2])
</code></pre>
<p>This seems to give back the right result.</p>
<pre><code>MAX count: ('0110000010', 4605)
Theta value: 0.255859375
QPE-approximated U-eigenvalue: (-0.036807222941358866+0.9993223845883495j)
QPE-approximated H-eigenvalue: -1.607611865704152
</code></pre>
<p>Also remember that you may have to run QPE for some amount of times before you see the ground state energy (lowest eigenvalue). This depends on the overlap between the ground state and the inital state you prepared.</p>
<hr />
<p>Code:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print('NUMPY eig',eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print('VQE eig', result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
measure_circ.h([-1, -2])

qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=10000)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
</code></pre>
",05/04/2023 22:01,Errors,The user is seeking solutions and explanations for errors and exceptions in their quantum program development. They are trying to understand why the Quantum Phase Estimation (QPE) algorithm is not giving the expected results in their code.,Errors,,,,Errors,
31910.0,How does grid or ring (coupling map topology) affect the depth of the circuit?,"<p>Why does different grid maps have different depths, i.e why does a 10x10 grid has more depth than 10x3. Also how does topology affect the depth?</p>
",<quantum-gate><programming><quantum-state>,3/30/2023 3:27,31913.0,31913.0,"<p>Coupling map shape affects circuit depth because a processes that is sometime called <em>routing</em>. If a circuit has a <span class=""math-container"">$CX(0,2)$</span> (a cnot entanglement between qubits 0 and 2), but the coupling map does not connect qubits 0 and 2 directly, the routing process needs to introduce a <span class=""math-container"">$SWAP$</span> gate to allow the entanglement, increasing the depth of the cirucit.</p>
<p>At least in <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a>, <strong>the routing process is a stochastic process</strong>. Transpiling into a 10x10 grid should result in equal or less depth than into a 10x3 grid, because 10x3 is subgraph of 10x10. That is, <strong>on average</strong>. You should run the same process several times with different seeds to explore that, because <a href=""https://en.wikipedia.org/wiki/Law_of_large_numbers"" rel=""nofollow noreferrer"">law of large numbers</a>.</p>
<p>Similarly, a ring of a side that allows it to be included in a grid should be more restrictive. Therefore, on average, the grid should result in a non-deeper circuit.</p>
<p>Here an example:</p>
<pre><code>circuit = QuantumVolume(6, seed=42)
depths3x3 = []
for seed in range(100):
    result = transpile(circuit, coupling_map=CouplingMap.from_grid(3,3), initial_layout=[0,1,2,5,4,3], seed_transpiler=seed)
    depths3x3.append(result.depth())
depths2x3 = []
for seed in range(100):
    result = transpile(circuit, coupling_map=CouplingMap.from_grid(2,3), initial_layout=[0,1,2,5,4,3], seed_transpiler=seed)
    depths2x3.append(result.depth())
print('3x3:', mean(depths3x3))
print('2x3:', mean(depths2x3))
</code></pre>
<p>Notice that specific instances might look contradicting (<code>max(depths3x3)</code> vs <code>min(depths2x3)</code>) but that is the general rule.</p>
<p>Also notice that the fixed the initial layout to be the same. Otherwise, in a bigger grid, the transpiler has more options to allocate the qubits in the circuit, an that might end up in worst results. If both coupling maps have the same size, that is not a problem. Compare here a 2x3-grid and a ring-6:</p>
<pre><code>depths_ring6 = []
for seed in range(100):
    result = transpile(circuit, coupling_map=CouplingMap.from_ring(6), seed_transpiler=seed)
    depths_ring6.append(result.depth())
depths_grid2x3 = []
for seed in range(100):
    result = transpile(circuit, coupling_map=CouplingMap.from_grid(2,3), initial_layout=[0,1,2,5,4,3], seed_transpiler=seed)
    depths_grid2x3.append(result.depth())
print('ring-6:', mean(depths_ring6))
print('grid-2x3:', mean(depths_grid2x3))
</code></pre>
<pre><code>ring-6: 10
grid-2x3: 9.15
</code></pre>
<p>Again, specific instances can be particularly bad (<code>min(depths_ring6)</code> is 10, and <code>max(depths_grid2x3)</code> is 12). But you got the point.</p>
<p>Not every circuit compiler is stochastic. This explanation only applies to stochastic circuit compilers, such as Qiskit.</p>
",3/30/2023 11:55,Conceptual ,The user is asking about the underlying concepts related to grid maps and their depths. They are trying to understand why different grid maps have different depths and how topology affects the depth.Which is coceptual question,Theoretical ,"The user is asking about the theoretical aspects of grid maps in quantum computing, specifically how different grid maps have different depths and how topology affects the depth.",No,132.0,Conceptual,"This is because the user is asking about the underlying concepts related to grid maps and their depths, seeking to understand why different grid maps have different depths and how topology affects the depth. This question focuses on understanding the fundamental concepts rather than theoretical intricacies."
31977.0,Initial and final circuit layout with BQSKit compiler,"<p>The question concerns logical to physical qubit mapping when compiling quantum circuits with <a href=""https://bqskit.lbl.gov/"" rel=""nofollow noreferrer"">BQSKit</a>. In Qiskit, I can specify the <a href=""https://qiskit.org/documentation/apidoc/transpiler.html"" rel=""nofollow noreferrer"">initial layout</a> for the transpilation. It is also possible to retrieve the <a href=""https://github.com/Qiskit/qiskit-terra/pull/9486"" rel=""nofollow noreferrer"">final layout</a>. With Qiskit Transpiler and BQSKit Compiler, the final layout generally differs from the initial layout because the compiler can permute logical qubits. My question is whether I can specify the <code>initial layout</code> and retrieve the <code>final layout</code> with BQSKit.</p>
<p>I found the following way to retrieve the final layout:</p>
<pre><code> 1. Add measurements on all active qubits of a Qiskit circuit.
 2. Compile the circuit with BQSKit.
 3. Translate back to Qiskit and draw.
 4. Read out the mapping from the positions of final measurements. 
 5. Notice that q1 and q2 are permuted at the end.
</code></pre>
<p><a href=""https://i.stack.imgur.com/QImbg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QImbg.png"" alt=""enter image description here"" /></a></p>
<p>However, I am interested in a programmatic solution.</p>
",<programming><quantum-circuit><transpile>,04/04/2023 10:58,31979.0,31979.0,"<p>This is an awesome question about BQSKit. Currently, the off-the-shelf (<code>bqskit.compile</code>) workflows do not provide a mechanism for this besides what you have discovered yourself.</p>
<p>If you would like to force an initial layout, you can design your own workflow that provides a value for the <code>initial_mapping</code> key in the pass's data, then perform routing. You can see the layout passes <a href=""https://github.com/BQSKit/bqskit/tree/master/bqskit/passes/mapping/layout"" rel=""nofollow noreferrer"">here</a> for examples.</p>
<p>If you build a workflow yourself and compile a circuit with it, you can request the <code>initial_mapping</code> and <code>final_mapping</code> data members to get these results programmatically.</p>
<p>If you make a GitHub issue on the BQSKit page requesting easier access here, I am sure the developers will accommodate that quickly.</p>
",04/04/2023 13:00,Tooling,"The user is asking about how to use BQSKit, a specific quantum computing software, to specify the initial layout and retrieve the final layout when compiling quantum circuits. This falls under questions related to tools",Tooling,,,,Tooling,
32013.0,How to assign and manipulate Qiskit's TwoLocal ParameterVector?,"<p>Below is my code in python where i just show Qiskit's TwoLocal variational circuit model.</p>
<pre><code>from qiskit.circuit.library import TwoLocal

n_qubits = 3
n_layers = 2
circuit = TwoLocal(n_qubits, 'ry', 'cx', 'linear', reps=n_layers, insert_barriers=True)

print(&quot;Circuit\n: {}&quot;.format(circuit.decompose().draw()))

</code></pre>
<p>My doubt is: is there any way to describe this ParameterVector <span class=""math-container"">$\theta$</span>? Assigning values to each <span class=""math-container"">$\theta [i]$</span> for example.
I looked in the documentation of this Ansatz but apparently all the methods are for showing the parameters. Not to modify them.</p>
",<qiskit><programming><machine-learning>,04/06/2023 15:05,32017.0,32017.0,"<p>Check out the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.assign_parameters.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.assign_parameters</code></a> method in Qiskit docs.</p>
<p>The simplest way to assign numerical values to each <span class=""math-container"">$\theta[i]$</span> in your parameter vector <span class=""math-container"">$\theta$</span> is to call <code>assign_parameters</code> passing an array-like object (values are bounded to parameters in alphabetical order):</p>
<pre><code>import numpy as np

num_pars = len(circuit.parameters)
values = np.random.rand(num_pars)
new_circuit = circuit.assign_parameters(values)
</code></pre>
",04/06/2023 15:37,Tooling,"The question is about how to modify the parameters of a Qiskit TwoLocal circuit. This is a tooling question, as it involves using a specific software tool (Qiskit) to perform a specific task (parameter modification).",Tooling,,,,Tooling,
32056.0,"Trying to replicate old code, migration guide unhelpful","<p>I am trying to replicate and update some old code that had some aqua imports. Unfortunately the <a href=""https://github.com/Qiskit/qiskit-aqua#migration-guide"" rel=""nofollow noreferrer"">migration guide on github</a> is unhelpful and <a href=""https://qiskit.org/documentation/aqua_tutorials/Qiskit%20Algorithms%20Migration%20Guide.html"" rel=""nofollow noreferrer"">the one it links</a> is broken.
It has the following imports:</p>
<pre><code>from qiskit.aqua import run_algorithm
from qiskit.aqua.input import LinearSystemInput
from qiskit.quantum_info import state_fidelity
from qiskit.aqua.algorithms.classical import ExactLSsolver
</code></pre>
<p>I cannot find information on any of these and would like help with migration.
Thanks!</p>
",<qiskit><programming><algorithm>,04/08/2023 22:18,32062.0,32062.0,"<p>Qiskit Aqua was deprecated just over 2 years ago. The migration guide was published in the main Qiskit docs for some while - you can still find the source, a notebook which you can view, in the Aqua repository <a href=""https://github.com/Qiskit/qiskit-aqua/blob/main/docs/tutorials/Qiskit%20Algorithms%20Migration%20Guide.ipynb"" rel=""nofollow noreferrer"">here</a>.</p>
<p>From the imports above, it seems like the code you are looking at was around linear solvers and HHL. Those imports though look old, even for Aqua, and were related to a declarative way of defining a problem that was removed sometime even before Aqua was finally deprecated.</p>
<p>Linear solvers, including HHL, was moved from Qiskit Aqua to Qiskit Terra. This function is still in the latest released version, but it was deprecated a while ago and will finally be removed in the next release. The code was moved into a separate repository, ahead of this next release, which you will find linked in the <a href=""https://learn.qiskit.org/course/ch-applications/solving-linear-systems-of-equations-using-hhl-and-its-qiskit-implementation"" rel=""nofollow noreferrer"">Qiskit Textbook section on HHL</a> under Qiskit implementation. This HHL is a different implementation, than that which was in Aqua, so I suspect you will more need to redo things based on what you want given the imports/function you show were not even supported in Aqua when it was deprecated.</p>
",04/09/2023 12:36,Tooling,The user is asking for help in migrating their code from Qiskit Aqua to the new Qiskit structure. This falls under questions related to tools,Tooling,,,,Tooling,
32091.0,Can a classical circuit of size $2^k$ be modelled by a quantum circuit of size $k$ or vice versa?,"<p>There is something fundamental I donât understand about quantum computing and hence the following question may be very trivial or stupid for which I apologize in advance.</p>
<p>A boolean function <span class=""math-container"">$f:\{0,1\}^n \to \{0,1\}$</span> has a certain (classical) complexity (say with respect to the basis <span class=""math-container"">$\{and, or, not\}$</span>) which is defined as the smallest number of gates (i.e. the size of the circuit) in a classical circuit using only <span class=""math-container"">$and$</span>, <span class=""math-container"">$or$</span>, and <span class=""math-container"">$not$</span> and which computes <span class=""math-container"">$f$</span>.</p>
<p>Say a quantum circuit computes <span class=""math-container"">$f$</span> if applied to the initial state <span class=""math-container"">$e_{x0^r}$</span> with <span class=""math-container"">$x\in\{0,1\}^n$</span> it ends in a quantum state where the probablility of measuring <span class=""math-container"">$f(x)$</span> is <span class=""math-container"">$\geq \frac{3}{4}$</span>. Moreover, say the quantum circuit complexity is the smallest number of quantum gates (using only some from a basis, say, and letâs also call this the size as well) needed for computing <span class=""math-container"">$f$</span>.</p>
<p>I have two questions:</p>
<ol>
<li><p>If I am not mistaken, I have read/heard at somewhere that one can âobviously emulateâ a quantum circuit of size <span class=""math-container"">$k$</span> by a classical circuit of size <span class=""math-container"">$2^k$</span>. (âEmulatedâ means here that the same boolean function is computed.) Why is this trivial, if it is true? :) Is quantum circuit complexity as defined above at least bounded by the logarithm of the classical circuit complexity?</p>
</li>
<li><p>This question is about âthe other directionâ and as a motivation for quantum circuits it is even more interesting to me: Can a classical circuit of size <span class=""math-container"">$2^k$</span> be emulated by a quantum circuit of size <span class=""math-container"">$k$</span>?</p>
</li>
</ol>
<p>Thank you.</p>
<p>Comment: Perhaps the thing similar to 1 above which was meant by some people is concerning the inputs. But I even donât see how one can encode a general state of <span class=""math-container"">$k$</span> qubits (a unit vector in <span class=""math-container"">$(\mathbb{C}^2)^k)$</span> by using <span class=""math-container"">$2^k$</span> classical bits as the latter can be only zero and one each - let alone the gates. Hence I donât see how one can simulate any quantum circuit using a classical circuit.</p>
",<quantum-gate><circuit-construction><quantum-circuit><classical-computing>,04/11/2023 21:22,32093.0,32093.0,"<p>Before answering let me generalize and formalize your framing a bit, so that I can say things concretely without fussing over details. I believe the heart of your question concerns the power of an exponentially-sized classical circuit vs. a polynomially-sized quantum circuit. But I will also focus on the case where the circuit are exponential only in  <em>depth</em>, and preclude the possibility of exponentially many bits. Thus, we are focused on matters of exponential time, not space. My answers below would need to change otherwise.</p>
<p>Computer scientists like to define complexity classes to classify the difficulty of various computational problems. For example, the class EXP denotes the class of problems classically solvable in exponential time (with a polynomial number of bits, however). Your first question concerns whether the simulation of quantum circuits is in EXP. Indeed, it is, because one can simply perform the appropriate matrix multiplication on a (complex) vector space of dimension <span class=""math-container"">$2^n$</span>. Given exponential time, a classical computer can emulate a quantum computer.</p>
<p>To address question (2), suppose one could emulate a classical circuit of size <span class=""math-container"">$N$</span> with a quantum circuit of size <span class=""math-container"">$O(\log N)$</span>. From the standpoint of complexity theory, this would imply that quantum computers could efficiently solve all problems in EXP. The class of problems that can be efficiently solved on a quantum computer is termed BQP. Thus, we would have EXP <span class=""math-container"">$\subset$</span> BQP. On the other hand, we've already essentially shown above that BQP <span class=""math-container"">$\subset$</span> EXP. We would be forced to conclude that BQP = EXP.</p>
<p>Though we cannot prove (as far as I know) whether this is indeed the case, we should be quite suspicious. Most experts don't believe that BQP contains NP, let alone EXP. This would preclude efficient solutions to the likes of the traveling salesman problem. For a better discussion of this than I can give, see <a href=""https://cstheory.stackexchange.com/questions/6154/consequences-of-sat-in-bqp"">this other post</a>.</p>
<p>To summarize, it would be very, very surprising if quantum computers were as powerful as you describe. I doubt there are many people in the field who believe so.</p>
",04/11/2023 23:25,Theoretical ,"The question delves into the theoretical aspects of quantum computing and its relationship with classical computing, exploring the complexity of quantum circuits and their potential emulation by classical circuits. It raises fundamental questions about the computational capabilities and limits of both quantum and classical circuits, making it a conceptual and theoretical inquiry.",Theoretical ,,,,Theoretical ,
32280.0,What kind of program was Deutsch envisioning to test for the linearity of quantum mechanics?,"<p>I've recently been studying Deutsch's 1985 paper &quot;Quantum theory, the Church-Turing principle and the universal quantum computer&quot; (<a href=""https://www.daviddeutsch.org.uk/wp-content/deutsch85.pdf%5D"" rel=""nofollow noreferrer"">pdf here</a>).  In this he endorses the position that a naÃ¯ve statement of the Church-Turing thesis is in tension with quantum mechanics.  He augments the Church-Turing thesis to consider universal quantum Turing machines (QTM), in lieu of or in addition to the (classical) Turing machines, and suggests a number of ways to use such quantum Turing machines to test various predictions of quantum mechanics.</p>
<p>Deutsch finds it instructive to program his QTM with a high-level programming language. For example, he contends that the following <code>ALGOL</code>-68 code &quot;<em>is</em> a performance of the Einstein-Podolsky-Rosen experiment&quot; (emphasis in original):</p>
<pre><code>BEGIN
   INT n=8*random;                %pick one of eight random rotation matrices%
   BOOL x, y;                     %prepare two qubits%
   x:=y:=FALSE;                   %initialize the qubits to |0&gt;%
   V(8,y);                        %apply a Hadamard matrix to the second qubit%
   x eorab y;                     %perform a CNOT (exclusive OR) operation%
   IF V(n,y)â                      %perform the random rotation on qubit y%
      V(n,x)                      %do the same on qubit x%
      THEN print((&quot;Quantum theory refuted.&quot;))
      ELSE print((&quot;Quantum theory corroborated.&quot;))
   FI
END
</code></pre>
<p>Deutsch ends his paper rather cheekily with a couple of challenges:</p>
<blockquote>
<p>Quantum computers raise interesting problems for the design of programming languages, which I shall not go into here. From what I have said, programs exist that would (in order of increasing difficulty) test the Bell inequality, <strong>test the linearity of quantum dynamics</strong>, and test the Everett interpretation. <strong>I leave it to the reader to write them.</strong>  (Emphasis added).</p>
</blockquote>
<p>In addition to the <code>ALGOL</code> pseudocode for the EPR experiment above, of the three other challenges proposed by Deutsch we regularly program quantum computers to run Bell experiments now, for example with CHSH games.  While, Deutsch's grand vision of combining AI with quantum computers to place a conscious AI in superposition so as to test the Everettian many-worlds hypothesis is manifestly difficult and perhaps reliant on questionable or at least controversial assumptions.</p>
<p><strong>But, what kind of program could test for the (non)linearity of quantum dynamics?</strong></p>
<p>For example, would a failure of quantum phase estimation falsify linearity?  Are there old ideas of, say, Wigner or others, that could be put to the test with a quantum computer succinctly described with a snippet of code or a quantum circuit?</p>
<hr />
<p><sup> As far as I can see, this is the first explicitly written program to perform a purely quantum task. For example as Deutsch notes, Feynman's earlier 1982 talk/paper proposed something that we would now call a <a href=""https://en.wikipedia.org/wiki/Quantum_simulator"" rel=""nofollow noreferrer"">quantum simulator</a> but only briefly described how such a device could be &quot;programmed&quot; with ladder operators, while Feynman's 1985 proposal of a quantum mechanical computer offered reversible circuits for the (classical) <a href=""https://en.wikipedia.org/wiki/Adder_(electronics)"" rel=""nofollow noreferrer"">half- and full-adder</a>.</sup></p>
",<programming><history><church-turing-thesis>,4/23/2023 16:11,32294.0,32294.0,"<p>The obvious test is to tomograph a state evolution that you suspect of being nonlinear. Let <span class=""math-container"">$f$</span> be the evolution such that (up to normalization)
<span class=""math-container"">$$f(|\psi\rangle + |\phi\rangle) \neq f(|\psi\rangle) + f(|\phi\rangle).$$</span>Then you do quantum state tomography on <span class=""math-container"">$f(|\psi\rangle),f(|\phi\rangle)$</span>, and  <span class=""math-container"">$f(|\psi\rangle + |\phi\rangle)$</span>. If they don't respect the equation, bingo, you have falsified the linearity of quantum mechanics, and your Nobel Prize will arrive soon by mail. One possible such <span class=""math-container"">$f$</span> is the cloning function, which cannot exist because of linearity.</p>
<p>Merely failing quantum phase estimation or some other task is not enough, as there are several different ways to cause such a failure while respecting linearity. For example, due to decoherence.</p>
",4/24/2023 8:49,Theoretical, The user is inquiring about theoretical concepts and principles in quantum computing. They are trying to understand how to test for the (non)linearity of quantum dynamics using a quantum program.,Theoretical,,,,Theoretical,
32300.0,Qiskit - order of swap gates,"<p>It seems I don't understand what swap gates actually do. The following code:</p>
<pre><code>import qiskit
import numpy as np
from qiskit.quantum_info.operators import Operator

circuit = qiskit.QuantumCircuit(3)
circuit.swap(0, 1)
circuit.swap(1, 2)
display(circuit.draw(output='mpl'))
display(Operator(circuit).data)
print({x: y for (x, y) in zip(*np.nonzero(Operator(circuit).data))})
</code></pre>
<p>outputs <code>... {0: 0, 1: 2, 2: 4, 3: 6, 4: 1, 5: 3, 6: 5, 7: 7}</code>, meaning that the circuit maps <code>0</code> to <code>0</code>, <code>1</code> to <code>2</code>, <code>2</code> to <code>4</code>, etc.</p>
<p>Some of these outputs are not what I expect. For example, I expected <code>1=001 ----swap(0,1)---&gt; 010 ---swap(1,2)---&gt; 100 = 4</code>, not <code>2</code>.</p>
<p>What do I misunderstand? Some of my experiments seem to indicate that the swaps happen in the reverse order. Another crazy explanation I have is that <code>swap</code> swaps not the values on the wires, but the wires themselves. But there is nothing like this in the <a href=""https://qiskit.org/documentation/stable/0.24/stubs/qiskit.circuit.library.SwapGate.html"" rel=""nofollow noreferrer"">documentation</a>.</p>
<p>Each gate independently (i.e. <strong>only</strong> <code>swap(0, 1)</code> or <strong>only</strong> <code>swap(1, 2)</code>) behaves as I expect, so there is no chance that I confused the order of bits (i.e. big-endian vs little-endian).</p>
<p>Is my usage of <code>Operator</code> wrong? Again, don't see anything about it in <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Operator.html"" rel=""nofollow noreferrer"">documentation</a>.</p>
<p>I'm starting to question my sanity, so any help is appreciated.</p>
",<qiskit><programming>,4/25/2023 1:10,32303.0,32303.0,"<p>You're correct in your expectations: <code>qiskit</code>'s little-endian will indeed send <span class=""math-container"">$|001\rangle$</span> to <span class=""math-container"">$|100\rangle$</span> with your circuit. In fact, this is shown when you display <code>Operator(circuit).data</code>, which gives the following matrix:
<span class=""math-container"">$$\begin{pmatrix}
1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\
0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0\\
0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1
\end{pmatrix}$$</span>
The output you get when inputting <span class=""math-container"">$|001\rangle$</span> into this circuit is given by reading the second <strong>column</strong> of this matrix, which gives <span class=""math-container"">$|100\rangle$</span>. However, <code>np.nonzero</code> will return <code>(x, y)</code> couples such that the <code>x</code>-th <strong>row</strong> and <code>y</code>-th <strong>column</strong> has a non-zero coefficient. Thus, you're essentially reading the transpose of your circuit by doing this. If you replace your last line by:</p>
<pre class=""lang-python prettyprint-override""><code>print({y: x for (x, y) in zip(*np.nonzero(Operator(circuit).data))})
</code></pre>
<p>You obtain <code>{0: 0, 2: 1, 4: 2, 6: 3, 1: 4, 3: 5, 5: 6, 7: 7}</code>, which was what you expected to get. You can also do this if you want the output to be sorted according to the keys:</p>
<pre class=""lang-python prettyprint-override""><code>print(dict(sorted({y: x for (x, y) in zip(*np.nonzero(Operator(circuit).data))}.items())))
</code></pre>
<p>Using which you will obtain <code>{0: 0, 1: 4, 2: 1, 3: 5, 4: 2, 5: 6, 6: 3, 7: 7}</code>.</p>
",4/25/2023 7:13, Errors,"The user is seeking an explanation for the unexpected behavior of swap gates in their code and the incorrect mapping of input states. This falls under the ""Errors"" category ",API Usage," The user is trying to understand the behavior of the swap gate and the Operator function in Qiskit, which are part of Qiskits API. They have provided code and described their expectations and confusion about the output, indicating that this is a question about how to correctly use these parts of the Qiskit API.",No,133.0, API Usage,"This is because the user is trying to understand the behavior of the swap gate and the Operator function in Qiskit, which are part of Qiskits API. They have provided code and described their expectations and confusion about the output, indicating that this is a question about how to correctly use these parts of the Qiskit API."
32505.0,pytket compiler pass to shorten all angles by multiples of 2 pi,"<p>After applying some compiler passes in pytket, I get gates like rx(3.5*pi). Is there a pass that simply shortens the angles by multiples of 2 pi, so that I get rx(1.5*pi) instead?</p>
",<programming><pytket>,05/09/2023 13:42,32533.0,32533.0,"<p>Based on Callums feedback I wrote a function for a CustomPass.</p>
<pre><code>def shorten_rotations(circ: Circuit) -&gt; Circuit:
    circ_prime = Circuit(circ.n_qubits, circ.n_bits)
    for cmd in circ.get_commands():
        if cmd.op.type in (OpType.Rx, OpType.Ry, OpType.Rz):
            params_prime = cmd.op.params
            params_prime[0] = params_prime[0] % 2
            circ_prime.add_gate(cmd.op.type, params_prime, cmd.qubits)
        elif cmd.op.type == OpType.Measure:
            circ_prime.Measure(cmd.qubits[0].index[0], cmd.bits[0].index[0])
        else:
            circ_prime.add_gate(cmd.op.type, cmd.op.params, cmd.qubits)
    return circ_prime
</code></pre>
",05/11/2023 10:04,Tooling,"The question is asking about how to use Pytket to shorten the angles of quantum gates by multiples of 2 pi. This is a tooling question, as it involves using a specific software tool (Pytket) to perform a specific task (angle shortening).",Tooling,,,,Tooling,
32538.0,Can a quantum computer count up by 1 faster than a classical computer?,"<p>Let's say you want to generate all images of size <code>NxN</code>, black/white pixels.<br />
This is equivalent to counting from <code>0 to 2^(N^2)-1</code>.</p>
<p>On a classical computer, this is impossible for even <code>32x32=1024 bits</code>.</p>
<p>Can a quantum computer count up by 1 faster than a classical computer?</p>
",<classical-computing>,05/11/2023 15:20,32539.0,32539.0,"<p>A classical computer takes less than a nanosecond to increment a 64 bit integer.</p>
<p>A superconducting quantum computer takes 10-100 nanoseconds to perform a CNOT gate, the reversible equivalent of a XOR gate. It takes hundreds of CNOT gates, and other gates, to perform a 64 qubit increment. And the result will be quite noisy, because the gates have error rates of around 0.1%.</p>
<p>In my <a href=""https://arxiv.org/abs/1905.09749"" rel=""noreferrer"">paper on factoring</a>, performing a <em>fault tolerant</em> addition under superposition on 2000-qubit registers is estimated to take around 20 milliseconds. That's roughly the time it takes a typical video game to render a whole frame. For 1 addition. On a building sized machine.</p>
<p>So, no, quantum computers are not faster at incrementing. They are in fact thousands of times to billions of times slower at incrementing. They get their advantage by doing fewer operations, not by doing the individual operations faster.</p>
<p><a href=""https://i.stack.imgur.com/c8iyv.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/c8iyv.png"" alt=""enter image description here"" /></a></p>
",05/11/2023 18:07,Theoretical,The user are trying to understand if a quantum computer can perform counting operations faster than a classical computer.,Theoretical,,,,Theoretical,
32684.0,qiskit textbook code throws RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment,"<p>I am trying to run the quantum communication algorithm from qiskit textbook &quot;Entangled States&quot; using my IBM API key, however, it throws the error <code>RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment.</code>. What am I doing wrong? This is my code:</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY])
backend = service.least_busy(simulator=False, operational=True)
print(f'Running on {backend}')

qc_charlie = QuantumCircuit(2,2)

qc_charlie.h(1)
qc_charlie.cx(1,0)


MESSAGE = '01'

qc_alice = QuantumCircuit(2,2)

if MESSAGE[-2]=='1':
    qc_alice.z(1)
if MESSAGE[-1]=='1':
    qc_alice.x(1)

qc_bob = QuantumCircuit(2,2)
# Bob disentangles
qc_bob.cx(1,0)
qc_bob.h(1)
# Then measures
qc_bob.measure([0,1],[0,1])


complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob))
backend.run(complete_qc).result().get_counts()
</code></pre>
<p>I know the API works since I get <code>Running on &lt;IBMBackend('ibmq_belem')&gt;</code> and the circuit is ok as i can see it using <code>qc_charlie.draw()</code>, <code>qc_alice.draw()</code> and <code>qc_bob.draw()</code>.</p>
",<qiskit><programming>,5/22/2023 20:48,32696.0,32696.0,"<p>You need to use a <code>Session</code> object and the <code>Sampler</code></p>
<pre><code>import qiskit
from qiskit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY])
backend = service.least_busy(simulator=False, operational=True)
print(f'Running on {backend.name}')

qc_charlie = QuantumCircuit(2,2)

qc_charlie.h(1)
qc_charlie.cx(1,0)


MESSAGE = '01'

qc_alice = QuantumCircuit(2,2)

if MESSAGE[-2]=='1':
    qc_alice.z(1)
if MESSAGE[-1]=='1':
    qc_alice.x(1)

qc_bob = QuantumCircuit(2,2)
# Bob disentangles
qc_bob.cx(1,0)
qc_bob.h(1)
# Then measures
qc_bob.measure([0,1],[0,1])


complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob))
with Session(backend=backend):
    sampler = Sampler()
    result = sampler.run(complete_qc).result()
print(result.quasi_dists)
</code></pre>
",5/23/2023 20:20,Errors,"The code is trying to call the IBMBackend.run() method, which is not supported in the Qiskit Runtime environment.",Errors,,,,Errors,
32782.0,AttributeError: module 'cirq_google' has no attribute 'Foxtail',"<p>I have installed <code>cirq</code> in my anaconda environment by using the command:
<code>pip install cirq</code></p>
<p>When I ran the code below to print the topology of Google Sycamore device:</p>
<pre><code>import cirq_google
print(cirq_google.Sycamore)
</code></pre>
<p>It gave the following output.</p>
<pre><code>                                             (0, 5)âââ(0, 6)
                                             â        â
                                             â        â
                                    (1, 4)âââ(1, 5)âââ(1, 6)âââ(1, 7)
                                    â        â        â        â
                                    â        â        â        â
                           (2, 3)âââ(2, 4)âââ(2, 5)âââ(2, 6)âââ(2, 7)âââ(2, 8)
                           â        â        â        â        â        â
                           â        â        â        â        â        â
                  (3, 2)âââ(3, 3)âââ(3, 4)âââ(3, 5)âââ(3, 6)âââ(3, 7)âââ(3, 8)âââ(3, 9)
                  â        â        â        â        â        â        â        â
                  â        â        â        â        â        â        â        â
         (4, 1)âââ(4, 2)âââ(4, 3)âââ(4, 4)âââ(4, 5)âââ(4, 6)âââ(4, 7)âââ(4, 8)âââ(4, 9)
         â        â        â        â        â        â        â        â
         â        â        â        â        â        â        â        â
(5, 0)âââ(5, 1)âââ(5, 2)âââ(5, 3)âââ(5, 4)âââ(5, 5)âââ(5, 6)âââ(5, 7)âââ(5, 8)
         â        â        â        â        â        â        â
         â        â        â        â        â        â        â
         (6, 1)âââ(6, 2)âââ(6, 3)âââ(6, 4)âââ(6, 5)âââ(6, 6)âââ(6, 7)
                  â        â        â        â        â
                  â        â        â        â        â
                  (7, 2)âââ(7, 3)âââ(7, 4)âââ(7, 5)âââ(7, 6)
                           â        â        â
                           â        â        â
                           (8, 3)âââ(8, 4)âââ(8, 5)
                                    â
                                    â
                                    (9, 4)
</code></pre>
<p><strong>But</strong> when I tried to run for Google Foxtail device:</p>
<pre><code>print(cirq_google.Foxtail)
</code></pre>
<p>The following error occurs-
<code>AttributeError: module 'cirq_google' has no attribute 'Foxtail'</code></p>
<p>Please help me to solve the issue.</p>
",<programming><cirq>,5/30/2023 7:46,32785.0,32785.0,"<p><code>cirq_google.Foxtail</code> seems to have been deprecated with the <code>XmonDevices</code> as of v0.15.0 in June 2022.</p>
<p>See PR: <a href=""https://github.com/quantumlib/Cirq/pull/5483"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/pull/5483</a></p>
<p>I opened a Cirq issue bringing light to the Foxtail device still being referenced a couple times in their docs: <a href=""https://github.com/quantumlib/Cirq/issues/6111"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/issues/6111</a></p>
",5/30/2023 14:20, Errors,The user is seeking a solution for an error they encountered while trying to access the Foxtail attribute in the cirq_google module in their quantum program. , Tooling,"The question is about troubleshooting an issue related to the cirq_google library in Python, specifically about accessing attributes or functionalities of the library, indicating a need for help with the usage and capabilities of the software tool.",No,134.0,Errors,"The user is seeking a solution for an error they encountered while trying to access the Foxtail attribute in the cirq_google module in their quantum program, indicating an issue with accessing specific attributes or functionalities of the library."
32873.0,How to implement Shor's 9-Qubit-Code in Qiskit?,"<p>I am new to qiskit and currently trying to implement Shor's 9-Qubit_Code. I am trying to orient my code on the example given in the official <a href=""https://qiskit.org/documentation/tutorials/circuits/1_getting_started_with_qiskit.html"" rel=""nofollow noreferrer"">qiskit-tutorial</a> and so far I have the following:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np
import math
from qiskit import *

circuit = QuantumCircuit(9)

circuit.cnot(0, 3)

circuit.cnot(0, 6)

circuit.h(0)
circuit.h(3)
circuit.h(6)

circuit.cnot(0, 1)
circuit.cnot(3, 4)
circuit.cnot(6, 7)

circuit.cnot(0, 2)
circuit.cnot(3, 5)
circuit.cnot(6, 8)

# Insert some error here
circuit.barrier()
circuit.x(0)
circuit.id(1)
circuit.id(2)
circuit.id(3)
circuit.id(4)
circuit.id(5)
circuit.id(6)
circuit.id(7)
circuit.id(8)
circuit.barrier()

circuit.cnot(0, 1)
circuit.cnot(3, 4)
circuit.cnot(6, 7)

circuit.cnot(0, 2)
circuit.cnot(3, 5)
circuit.cnot(6, 8)

circuit.ccx(2, 1, 0)
circuit.ccx(5, 4, 3)
circuit.ccx(8, 7, 6)

circuit.h(0)
circuit.h(3)
circuit.h(6)

circuit.cnot(0, 3)

circuit.cnot(0, 6)

circuit.ccx(8, 3, 0)

circuit.draw(output='mpl')
plt.show()



# Run the quantum circuit on a statevector simulator backend
backend = Aer.get_backend('statevector_simulator')
# Create a Quantum Program for execution
job = backend.run(circuit)
result = job.result()
outputstate = result.get_statevector(circuit, decimals=3)
print(outputstate)
</code></pre>
<p>However, I still need to be able to set the first qubit in an arbitrary state, but I do not know how to do this and I can not find something like that on the tutorials page. Could you please help me?</p>
<p>Remark: This is not supposed to be a &quot;serious&quot; program, it is just for me to get a feel of what is going on.</p>
",<qiskit><programming><error-correction>,06/07/2023 09:45,32917.0,32917.0,"<p>I didn't check all of your code, but this answer addresses the following:</p>
<blockquote>
<p>I still need to be able to set the first qubit in an arbitrary state</p>
</blockquote>
<p>To do this, you can use the <code>quantum_info.random_statevector</code> function to get a random 1-qubit vector (this vector has dimension 2 so that is why we pass the argument <code>2</code> to the function) from the <a href=""https://en.wikipedia.org/wiki/Haar_measure"" rel=""nofollow noreferrer"">uniform Haar measure</a>.</p>
<p>Then, you initialize your first qubit (index 0) to this vector using the <code>QuantumCircuit.initialize</code> method. This method takes as its first argument the vector to initialize to and as its second argument the index of the qubit to initialize.</p>
<pre class=""lang-python prettyprint-override""><code>import qiskit
import numpy as np

sv = qiskit.quantum_info.random_statevector(2)
qc = qiskit.QuantumCircuit(1)
qc.initialize(sv.data, 0)
</code></pre>
<pre><code>   âââââââââââââââââââââââââââââââââââââââââââââââââââ
q: â¤ Initialize(0.95024-0.10594j,-0.067802+0.28499j) â
   âââââââââââââââââââââââââââââââââââââââââââââââââââ
</code></pre>
",06/10/2023 03:42,Learning,"The user is asking for help with a specific task in Qiskit (setting the first qubit in an arbitrary state), and is providing their own code as an example. This suggests that the user is new to Qiskit and is trying to learn how to use it.",Learning,,,,Learning,
33566.0,Displaying the circuit diagram associated to a circuit in Q#+Python,"<p>I am learning the Q# language, and my script is in Python (I am using the online Azure interface).</p>
<p>I created an example quantum circuit on three qubits:</p>
<pre><code>%%qsharp

    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Arrays;
    
    operation AlgoTest() : Result[] {
        use q = Qubit[3];
        mutable resultArray = [Zero, size = 3];
        CNOT(q[1],q[0]);
        H(q[2]);
        H(q[0]);
        S(q[1]);
        I(q[2]);
        CNOT(q[2],q[1]);
        H(q[2]);
        for i in IndexRange(q) {
                    set resultArray w/= i &lt;- M(q[i]);
                }
        return resultArray;
    }
</code></pre>
<p><strong>Is there a simple way to represent the quantum circuit associated to AlgoTest in a standard quantum circuit diagram?</strong></p>
<p>I found these refs (<a href=""https://github.com/microsoft/Quantum/tree/main/samples/runtime/qpic-simulator"" rel=""nofollow noreferrer"">1</a>, <a href=""https://devblogs.microsoft.com/qsharp/quantum-viz-js-a-quantum-circuits-visualization-library/"" rel=""nofollow noreferrer"">2</a>), but they seem to assume the full program is in Q# (while I am using Python+Q#). For instance the command:</p>
<pre><code>%%qsharp
%trace AlgoTest
</code></pre>
<p>Doesn't return me anything.</p>
",<programming><q#>,7/25/2023 16:19,33568.0,33568.0,"<p><code>%trace</code> magic only works in notebooks with Q# kernel (not Python+Q#), and only if they run on a local Jupyter Notebooks setup, not in Azure-hosted notebooks. There's no way to get a circuit plotted when running the code in Azure.</p>
<p><a href=""https://github.com/microsoft/Quantum/tree/main/samples/runtime/qpic-simulator"" rel=""nofollow noreferrer"">qpic sample</a> can be a viable workaround, but it also requires a local setup and it also assumes that the quantum circuit is expressed in Q#.</p>
",7/25/2023 17:39,Tooling," The user is trying to visualize a quantum circuit from their Q# code using Python and Azure, and is having trouble with the tooling involved, which falls under the Tooling category",Tooling,,,,Tooling,
24091.0,Qiskit: Sum of Kraus operators are not equal to identity matrix,"<p>I know that one of the properties of the Kraus Operator is:
<span class=""math-container"">$$\sum_k A_k^\dagger A_k=I\,.$$</span></p>
<p>So, in qiskit, I first converted my array to a super operator, and then I found my Kraus operators. However, the sum of the Kraus operator is not equal to the identity. And I do not know if I found my Kraus operator correctly or not.
Here is my process matrix:</p>
<pre><code>array([[ 1.   ,  0.   ,  0.   ,  0.   ],
       [ 0.001,  0.986,  0.02 ,  0.04 ],
       [ 0.014,  0.01 ,  0.019, -0.957],
       [-0.028, -0.031,  0.949,  0.008]])
</code></pre>
<p>Here is my code:</p>
<pre><code> q_process=qi.SuperOp(process)
 kraus_=qi.Kraus(q_process)
 kraus_
</code></pre>
<p>From <code>kraus_,</code> I put Kraus operators into <code>kraus_list</code> Here is how I found the sum of Kraus operators:</p>
<pre><code>kraus_list = np.array([[[-0.833+0.j,  0.14 +0.j],
         [-0.14 +0.j, -0.821+0.j]],

        [[ 0.134+0.j,  0.812+0.j],
         [-0.806+0.j,  0.139+0.j]],

        [[ 0.14 +0.j, -0.06 +0.j],
         [-0.061+0.j, -0.142+0.j]],

        [[-0.012+0.j, -0.029+0.j],
         [-0.029+0.j,  0.012+0.j]],


       [[-1.168-0.j, -0.026-0.j],
         [ 0.014+0.j, -0.205-0.j]],

        [[ 0.201+0.j, -0.008-0.j],
         [ 0.021+0.j, -1.142-0.j]],

        [[ 0.004+0.j, -0.147-0.j],
         [ 0.16 +0.j,  0.005+0.j]],

        [[ 0.   +0.j, -0.032-0.j],
         [-0.03 -0.j, -0.   -0.j]]])
    sum_of_kraus= np.matmul(kraus_list[0].conj().T,kraus_list[0])+np.matmul(kraus_list[1].conj().T,kraus_list[1])+np.matmul(kraus_list[2].conj().T,kraus_list[2])+np.matmul(kraus_list[3].conj().T,kraus_list[3])+np.matmul(kraus_list[4].conj().T,kraus_list[4])+np.matmul(kraus_list[5].conj().T,kraus_list[5])+np.matmul(kraus_list[6].conj().T,kraus_list[6])+np.matmul(kraus_list[7].conj().T,kraus_list[7])
</code></pre>
<p>Here is the result:</p>
<pre><code>array([[2.843+0.j, 0.009+0.j],
       [0.009+0.j, 2.761+0.j]])
</code></pre>
<p>As it can be seen, it is not equal to identity. Could someone explain to me why I am finding 2.843 instead of 1. Am I doing something wrong in the code?</p>
",<qiskit><programming><kraus-representation>,2/14/2022 14:04,37753.0,37753.0,"<p>Since OP never disclosed their solution let me shed light on what the mistake here was: the process matrix used as input was a Pauli transfer matrix (i.e. representation matrix in the <em>Pauli basis</em>) but <code>qi.SuperOp</code> uses the representation matrix in the <strong>computational basis</strong>. Converting OP's Pauli transfer matrix into the <a href=""https://quantumcomputing.stackexchange.com/a/5816"">superoperator representation</a> yields what the input should have been:</p>
<pre><code>array([[ 0.49 +0.j , -0.0155-0.4745j , -0.0155+0.4745j , 0.482 +0.j   ],
       [ 0.0205 -0.4715j , 0.5025 -0.005j , 0.4835 +0.015j , -0.0195+0.4855j ],
       [ 0.0205 +0.4715j , 0.4835 -0.015j , 0.5025 +0.005j , -0.0195-0.4855j],
       [0.51 +0.j , 0.0155 +0.4745j , 0.0155 -0.4745j , 0.518 +0.j]])
</code></pre>
<p>Note that the code did what it is supposed to do: it interpreted the input as superoperator with respect to vectorization which leads to a map <span class=""math-container"">$\Phi$</span> that is not even completely positive or even Hermitian-preserving anymore. As a result <code>qi.Kraus</code> <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Kraus"" rel=""nofollow noreferrer"">output</a> <em>generalized</em> Kraus operators, i.e. matrices <span class=""math-container"">$A_1,\ldots,A_4,B_1,\ldots,B_4$</span> such that <span class=""math-container"">$\Phi=\sum_{k=1}^4 A_k(\cdot)B_k^\dagger$</span>. Indeed, it is easy to check that the elements of <code>kraus_list</code> satisfy <span class=""math-container"">${\rm superOp}(\Phi)=\sum_{k=1}^4\overline{B_k}\otimes A_k$</span> meaning they are indeed generalized Kraus operators of <span class=""math-container"">$\Phi$</span>.</p>
",04/12/2024 07:12,Conceptual,"The issue user encountering with the sum of Kraus operators not being equal to the identity matrix falls under the conceptual understanding in quantum software engineering. Specifically, it relates to the fundamental concept of Kraus operators and their properties",Conceptual,,,,Conceptual,
26994.0,References for two-local forms in QISKIT,"<p>I am using 'Two local' form of QISKIT as a waveform ansatz in VQE to compute ground state. <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.TwoLocal.html"" rel=""nofollow noreferrer"">QISKIT documentation</a> does not provide references to all the entangling options. Is there any other place where I can find references for different entangling structure: 'Full', 'Linear', 'Circular' etc?</p>
",<qiskit><programming><vqe>,6/22/2022 2:35,26995.0,26995.0,"<p>here you go, for references check:
<a href=""https://github.com/Qiskit/qiskit-terra/issues/8219"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/8219</a></p>
<pre><code>from qiskit.circuit.library import TwoLocal
from qiskit import QuantumCircuit
qubit_num = 3
two_full = TwoLocal(qubit_num, ['ry','rz'], 'cz', 'full', reps=2, insert_barriers=True)
two_linear = TwoLocal(qubit_num, ['ry','rz'], 'cz', 'linear', reps=2, insert_barriers=True)
two_circular = TwoLocal(qubit_num, ['ry','rz'], 'cz', 'circular', reps=2, insert_barriers=True)
two_sca = TwoLocal(qubit_num, ['ry','rz'], 'cz', 'sca', reps=2, insert_barriers=True)

print(&quot;two_full: &quot;)
display(two_full.decompose().draw('mpl'))
print(&quot;two_linear: &quot;)
display(two_linear.decompose().draw('mpl'))
print(&quot;two_circular: &quot;)
display(two_circular.decompose().draw('mpl'))
print(&quot;two_sca: &quot;)
display(two_sca.decompose().draw('mpl'))

</code></pre>
<p><code>'full'</code> entanglement is each qubit is entangled with all the others:
<a href=""https://i.stack.imgur.com/1WPv7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1WPv7.png"" alt=""full"" /></a></p>
<p><code>'linear'</code> entanglement is qubit <span class=""math-container"">$i$</span> entangled with qubit <span class=""math-container"">$i + 1$</span>,for all <span class=""math-container"">$i \in \{0, 1, ... , n - 2\}$</span>, where <span class=""math-container"">$n$</span> is the total number of qubits:
<a href=""https://i.stack.imgur.com/2cOFD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2cOFD.png"" alt=""linear"" /></a></p>
<p><code>'circular'</code> entanglement is linear entanglement but with an additional entanglement of the first and last qubit before the linear part:
<a href=""https://i.stack.imgur.com/QxK5k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QxK5k.png"" alt=""circular"" /></a></p>
<p><code>'sca'</code> (shifted-circular-alternating) entanglement is a generalized and modified version of the proposed circuit 14 in <a href=""https://arxiv.org/abs/1905.10876"" rel=""nofollow noreferrer"">Sim et al.</a>.It consists of circular entanglement where the 'long' entanglement connecting the first with the last qubit is shifted by one each block.  Furthermore the role of control and target
qubits are swapped every block (therefore alternating):
<a href=""https://i.stack.imgur.com/GUABl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GUABl.png"" alt=""sca"" /></a></p>
",6/22/2022 3:28,Conceptual," The users question about finding references for different entangling structures in Qiskits TwoLocal form falls under the conceptual understanding in quantum software engineering. Specifically, it relates to understanding the available options for entanglement strategies and their impact on variational quantum algorithms",Learning,"The question is about seeking additional references or resources to understand the different entangling structures used in the Qiskit 'TwoLocal' ansatz, indicating a need for further educational material on the topic.",No,135.0,Learning," The user is seeking additional references or resources to understand the different entangling structures used in the Qiskit 'TwoLocal' ansatz, indicating a desire to learn more about the topic. This aligns with the Learning category as it involves seeking educational material to enhance understanding."
27940.0,How to use control logic in MCPPhaseGate,"<p>I need help with the MCPhaseGate. I am not able implement the control logic (i.e, the control function)with MCPhase gate similar to the RXgate shown below. It would be great help if someone can help me with it. The line <code>u=u.control(num_ctrl_qubits = k, ctrl_state = bitstring)</code> gives an error</p>
<pre><code>  new_ctrl_state = operation.ctrl_state &lt;&lt; num_ctrl_qubits | ctrl_state
    TypeError: unsupported operand type(s) for |: 'int' and 'str'
</code></pre>
<p>Not sure how to resolve this error?</p>
<pre><code>import math
from qiskit import QuantumCircuit
from qiskit.circuit.library import CPhaseGate
from qiskit.circuit.library.standard_gates.rx import RXGate
from qiskit.circuit.library.standard_gates.p import MCPhaseGate
import matplotlib.pyplot as plt

k = 3
rotations = [math.pi, math.pi/2, math.pi/3, math.pi/4]

qcd = QuantumCircuit(5)
count = 0
for theta in rotations:
    binary = bin(count)[2:]
    print(binary)
    bitstring = ('0' * (k - len(binary))) + binary
    print(bitstring)
    u = RXGate(theta = theta).control(num_ctrl_qubits = k, ctrl_state = bitstring)
    qcd.append(u, qargs = [i for i in range(k+1)])
    count += 1

count1=0
for theta in rotations:
    binary = bin(count)[2:]
    bitstring = ('0' * (k - len(binary))) + binary
    print(bitstring)
    u = MCPhaseGate(lam=theta, num_ctrl_qubits=k)
    # u=u.control(num_ctrl_qubits = k, ctrl_state = bitstring)   ## Here is the Problem
    qcd.append(u, qargs=[i for i in range(k + 1)])
    count1 += 1

qcd.draw(output=&quot;mpl&quot;)
plt.show()
</code></pre>
<p><a href=""https://i.stack.imgur.com/qvpAr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qvpAr.png"" alt=""enter image description here"" /></a></p>
<p><strong>Edit</strong></p>
<p>I want to know exactly where to use the phase gate.
I am planning to use it for the below circuit. Please advise whether I am using it at correct place.
<a href=""https://i.stack.imgur.com/vmcdS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vmcdS.png"" alt=""enter image description here"" /></a></p>
",<qiskit><programming>,8/25/2022 21:20,27943.0,27943.0,"<p>2 problems needed to be fixed:</p>
<ol>
<li><p>Thereâs a typo in the second loop. Change <code>count</code> to <code>count1</code> in the row <code>binary = bin(count)[2:]</code>.</p>
</li>
<li><p><strong>The problem:</strong> It looks like you are doing a double job with the controlled operations in the second loop. In the row <code>u = MCPhaseGate(lam=theta, num_ctrl_qubits=k)</code> you set <code>u</code> as a <code>MCPhaseGate</code> which is already a controlled gate (that corresponds to the 4 <code>mcp</code> gates we see in the circuit diagram). Then in the row after: <code>u=u.control(num_ctrl_qubits = k, ctrl_state = bitstring)</code>, you try to use the <code>control</code> method upon <code>u</code> again, that doesnât make sense.
<strong>A solution:</strong> use <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseGate.html"" rel=""nofollow noreferrer""><code>PhaseGate</code></a> instead, in a similar fashion as in the first loop: <code>u = PhaseGate(theta = theta).control(num_ctrl_qubits = k, ctrl_state = bitstring)</code>.</p>
</li>
</ol>
",8/26/2022 1:02,Conceptual,"The users question about implementing the control logic for the MCPhaseGate and resolving an error related to the control state falls under the conceptual understanding in quantum software engineering. Specifically, it relates to understanding how to correctly apply control gates and troubleshoot issues in quantum circuits.",Conceptual,,,,Conceptual,
28255.0,"Difference between run, measure, transpile, execute?","<p>quite new to quantum computing and I have to do a small presentation on quantum gates using python code(notebook).Also, please review the small code I have written for its correctness. I have some questions also as below:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np
from math import pi
from qiskit.quantum_info import Statevector
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, transpile
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity
from qiskit import BasicAer
from qiskit.visualization import plot_bloch_multivector

backend = BasicAer.get_backend('unitary_simulator')
qc = QuantumCircuit(q)
qc.u(pi/2,pi/4,pi/8,q)            
qc.draw(output='mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/4ky6f.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4ky6f.png"" alt=""enter image description here"" /></a></p>
<p><strong>U gate has a lambda argument. What does it mean by lambda and what effect it have on the bloch sphere?</strong></p>
<pre><code>state = Statevector(qc)
plot_bloch_multivector(state) # argument is a statevector
</code></pre>
<p><strong>What is this Statevector function? I am not getting it at all.</strong>
<strong>Also, is the bloch sphere showing the effect different angles applied to the gate and state achieved due to effect of lambda, theta and phi? How to know the effect of lambda?</strong></p>
<p><a href=""https://i.stack.imgur.com/ipZIk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ipZIk.png"" alt=""enter image description here"" /></a></p>
<pre><code>transpiled_circuit= transpile(qc, backend)
transpiled_circuit.draw(output= &quot;mpl&quot;)
</code></pre>
<p><a href=""https://i.stack.imgur.com/qjDIw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qjDIw.png"" alt=""enter image description here"" /></a>
What is the effect of transpile  function? Does it break the gate into its individual components? Not able to understand its effect?</p>
<pre><code>job = backend.run(transpiled_circuit)
job.result().get_unitary(qc, decimals=3)
</code></pre>
<p><a href=""https://i.stack.imgur.com/MWsEJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MWsEJ.png"" alt=""enter image description here"" /></a></p>
<p><strong>What is the function of run? Also, what is the get_unitary giving? Is this get_unitary same as statevector(discussed above)?</strong></p>
<p><strong>Now, I donot know where to put the measure, execute and how to see the histogram and the counts?</strong>
Also, in this example, I am using &quot;unitary simulator&quot;. Is this simulator same as qasm simulator?
Thank you in advance for resolving me doubts.</p>
",<qiskit><programming>,9/22/2022 3:02,28260.0,28260.0,"<p>So many questions in your question!  Not sure I'll be able to answer them all, but I'll hopefully get you started!</p>
<p><strong>1)U gate has a lambda argument. What does it mean by lambda and what effect it have on the bloch sphere?</strong>
<a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.UGate.html"" rel=""nofollow noreferrer"">This</a> is a link to the documentation for the gate that you used.  From this I can see that the their u gate is the universal gate that uses three sequential rotations (Rz,Ry and Rz) to to change the state.  The lamda you are referring to is that final rotation around z.
For additional information on the u gate, see <a href=""https://quantumcomputing.stackexchange.com/questions/9668/what-is-the-lambda-parameter-in-the-u3-gate-used-for"">this</a> SE post.</p>
<p><strong>2)What is this Statevector function? I am not getting it at all. Also, is the bloch sphere showing the effect different angles applied to the gate and state achieved due to effect of lambda, theta and phi? How to know the effect of lambda?</strong>
Yes, your Bloch vector should show the resulting state after putting your state, <span class=""math-container"">$|0\rangle$</span>, through the u gate with your given rotation angles of <span class=""math-container"">$\pi/2$</span>, <span class=""math-container"">$\pi/4$</span>, and <span class=""math-container"">$\pi/8$</span>.  The <span class=""math-container"">$\theta$</span> relates to the rotation around y axis, the <span class=""math-container"">$\phi$</span> and <span class=""math-container"">$\lambda$</span> are around the z axis</p>
<p>As for the statevector function, what it does was it took the output of your circuit and converted it into a statevector which you have then displayed on the Bloch Sphere.  You could also display it in Dirac notation using <code>state.draw()</code> in another cell.</p>
<p><strong>3)What is the effect of transpile function? Does it break the gate into its individual components? Not able to understand its effect?</strong>
Transpile is a function that is used to convert the circuit you have built, to one readable by actual quantum computers at IBMQ.  Every time a complex circuit is transpiled it may be done slightly differently.  This is not an effect you tend to see, but if you get to the point where you are worried about circuit depth, then the different transpile results become important.</p>
<p><strong>4)What is the function of run? Also, what is the get_unitary giving? Is this get_unitary same as statevector(discussed above)?</strong>
<code>.run</code> tells the backend to actually run the circuit rather than just looking at it.  (You are no longer building it, you want to run it to see the result)  Find more information on <code>.run</code> <a href=""https://qiskit.org/textbook/ch-appendix/qiskit.html"" rel=""nofollow noreferrer"">here</a></p>
<p><code>get_unitary</code> will output the matrix that evolved your statevector. Click <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.get_unitary.html"" rel=""nofollow noreferrer"">here</a> for the documentation.</p>
<p><strong>5)Now, I do not know where to put the measure, execute and how to see the histogram and the counts? Also, in this example, I am using &quot;unitary simulator&quot;. Is this simulator same as qasm simulator? Thank you in advance for resolving me doubts.</strong>
Measure will go at the end of your circuit. You then use <code>.execute</code> the same way you used <code>.run</code> only you will execute your circuit on a different backend, as the unitary simulator is used for generating unitaries, while the qasm_simulator can simulate the measurement.  After you have executed your function you will need to <code>get_counts`` in order to </code>plot_histogram```
I'm deliberately not showing you what this code would look like in full, because I beleive that is probably a part of the assignment, but I will say that if you look at <a href=""https://qiskit.org/documentation/tutorials/circuits/01_circuit_basics.html#:%7E:text=The%20fundamental%20unit%20of%20Qiskit,run%20them%20on%20different%20backends."" rel=""nofollow noreferrer"">this</a> Qiskit tutorial page, you should be able to find some examples that may help you.</p>
<p>Best of luck!</p>
",9/22/2022 19:00,Conceptual,"The users questions about the U gate, Statevector function, Bloch sphere visualization, transpile function, and the run function fall under the conceptual understanding in quantum software engineering. Specifically, they relate to understanding gate parameters, state representations, circuit compilation, and simulation methods in quantum computing.",Conceptual,,,,Conceptual,
28282.0,I was solving matrix of beam splitter in python but got stuck in understanding the library,"<p>What does this command physically mean?</p>
<pre><code>block_diag([[1]], BSunitaries[2], [[1]])
</code></pre>
<p>Can any one tell me in matrix form?</p>
<p><a href=""https://strawberryfields.ai/photonics/demos/run_boson_sampling.html#id16"" rel=""nofollow noreferrer"">Source</a></p>
",<optical-quantum-computing><boson-sampling><programming><strawberryfields>,9/26/2022 5:52,28288.0,28288.0,"<p>A beamsplitter gates takes two parameters, and acts on two modes. The matrix that represents the gate is a 2x2 unitary. In this line you're calculating the unitary for the second 'column' in the circuit, which has a single beamsplitter. I've marked it in this image in blue: <a href=""https://i.stack.imgur.com/x6R6y.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/x6R6y.png"" alt=""circuit"" /></a></p>
<p>In order to be able to multiply the unitaries for all of the columns together, they all need to be 4x4 so we first need to find the 2x2 unitary for the beamsplitter and then turn it into a 4x4 unitary.</p>
<p><code>BSunitaries</code> contains the unitaries for each of the beamsplitters so you first extract the information for this specific unitary by using <code>BSunitaries[2]</code>.</p>
<p><a href=""https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.block_diag.html"" rel=""nofollow noreferrer"">block_diag</a> creates a block diagonal matrix because you need <code>UBS2</code> to be a 4x4 unitary so <code>block_diag([[1]], BSunitaries[2], [[1]])</code> is basically adding a '1' in the top left and a '1' in the bottom right. If you <code>print(block_diag([[1]], [[2,3],[4,5]], [[1]]))</code> you'll get an idea of how this looks.</p>
<p>Catalina from Xanadu</p>
",9/26/2022 15:35,Conceptual,"The users question about the block_diag command and its physical meaning falls under the conceptual understanding in quantum software engineering. Specifically, it relates to understanding how to create a block diagonal matrix from provided arrays and its significance in quantum computing.",Conceptual,,,,Conceptual,
28777.0,Using qiskit on mutiple cores,"<p>I would like to be able to set the number of cores the <code>AerSimulator</code> should be running. For now I've tried</p>
<pre><code>backend = AerSimulator()
backend.set_options(max_parallel_threads=params['ncores'])
</code></pre>
<p>where <code>params['ncores']</code> is an <code>int</code> with the number of cores the simulator should run on.
I would expect that changing it from 1 to 4 the run time would change, but this is not the case. Can anyone point to what I'm doing wrong?</p>
",<qiskit><programming>,11/01/2022 14:23,28787.0,28787.0,"<p>Although <code>max_parallel_threads</code>sets the maximum number of CPU cores used by OpenMP for parallelization during execution of an experiment, there are other factors that affect the amount of parallelization that will actually occur. Most notably, your circuit must have at least 14 qubits. You can control this value using <code>statevector_parallel_threshold</code> <a href=""https://qiskit.org/documentation/stubs/qiskit_aer.AerSimulator.html"" rel=""nofollow noreferrer""><code>AerSimulator</code></a>'s option.</p>
<hr />
<p>The following example demonstrates how to take advantage of having multiple cores. Let's create 200 circuits:</p>
<pre><code>from qiskit.circuit.random import random_circuit

num_circuits = 200
num_qubits = 20
depth = 30

circuits = []
for n in range(num_circuits):
    circuits.append(random_circuit(num_qubits, depth, max_operands = 2, measure = True))
</code></pre>
<p>Then we transpile them:</p>
<pre><code>from qiskit import transpile
from qiskit_aer import AerSimulator

backend = AerSimulator(method = 'statevector')

tr_circuits = transpile(circuits, backend = backend)
</code></pre>
<p>Now, we configure the backend for parallelization and run the circuits:</p>
<pre><code>backend.set_options(
    max_parallel_threads = 0,
    max_parallel_experiments = 0,
    max_parallel_shots = 1,
    statevector_parallel_threshold = 16
)

result = backend.run(tr_circuits).result()
counts = result.get_counts()
</code></pre>
<p>Note that:</p>
<ul>
<li><code>max_parallel_threads</code> equal 0 means use all the CPU cores.</li>
<li><code>max_parallel_experiments</code> equal 0 means maximum number of experiments that may be executed in parallel equals <code>max_parallel_threads</code> value.</li>
<li><code>max_parallel_shots</code> equal 1 means disable parallel shot execution.</li>
<li><code>statevector_parallel_threshold</code> equal 16 (default) means that number of qubits in the circuit must be greater than 16 to enable parallelization for matrix multiplication during execution. Note that enabling parallelization to small circuits can reduce performance.</li>
</ul>
",11/02/2022 05:57,Conceptual,"The users question about setting the number of cores for the AerSimulator and its impact on runtime falls under the conceptual understanding in quantum software engineering. Specifically, it relates to understanding how to configure parallelization options for the simulator and the expected behavior based on the specified number of cores",Conceptual,,,,Conceptual,
29522.0,Qiskit comparing circuit to desired one,"<p>I am working on a simple program using <strong>Qiskit</strong> in <strong>python</strong> in which the programs are using evolutionarily algorithms to search for a desired circuit.
I need to compare the generated circuits with desired one but I don't know how?
I know that there is no truth table for quantum circuits. But for example I need to check if a circuit is working true as an <strong>adder</strong> or not.
How to do this in Qiskit?</p>
",<qiskit><programming>,12/31/2022 18:38,29524.0,29524.0,"<p>I believe the trick will be to compare the resulting state vectors. Start with your desired circuit, simulate it, and read out the state vector. Then try your auto-generated circuit, run it as well, and read out that state vector. If the parts of the state vector that represent the result match - bingo, your generated circuit is working (always advisable to test it on all possible inputs).</p>
<p>For example, if you want to add 3 + 5 in a <span class=""math-container"">$n$</span> qubit representation, the circuit likely does something like representing the inputs with (for example) two registers with 5 qubits each (with an additional qubit each to account for carry in the result), eg.:
<span class=""math-container"">$$
a = |000011\rangle \\
b = |000101\rangle
$$</span>
The adder circuit must also reserve an <span class=""math-container"">$n+1$</span>-register for the result (the <span class=""math-container"">$+1$</span> is again required to account for a potential carry). If you read out the result register and look for the sub-state with the highest probability, you can check whether the result has been computed correctly as:
<span class=""math-container"">$$
{\tt result} = |001000\rangle
$$</span></p>
<p><a href=""https://quantumcomputing.stackexchange.com/a/23470/11582"">This</a> post shows how to get the state vector from Qiskit. I'm not sure whether you are doing addition in the Fourier domain but to simulate a classic adder, I put a trivial implementation (not using Qiskit) of a 1-bit full adder <a href=""https://github.com/qcc4cp/qcc/blob/main/src/arith_classic.py"" rel=""nofollow noreferrer"">here</a>.</p>
",12/31/2022 19:33,Conceptual ,"The users question about comparing generated quantum circuits with a desired one falls under the conceptual understanding in quantum software engineering. Specifically, it relates to understanding how to verify the correctness of a quantum circuit, such as checking if it functions correctly as an adder.", Theoretical,"The question involves understanding how to verify the functionality of a quantum circuit, which is a fundamental theoretical concept in quantum computing, specifically how to compare a generated quantum circuit to a desired one like an adder.",No,136.0,Conceptual,"The user's question pertains to understanding how to compare generated quantum circuits with a desired one, such as verifying if a circuit functions correctly as an adder. This aligns with the conceptual understanding in quantum software engineering as it involves understanding how to verify the correctness of quantum circuits."
30100.0,Installing azure-quantum with qiskit dependences,"<p>I'm trying to install azure-quantum package with qiskit integration.</p>
<p>Following the azure tutorial (<a href=""https://pypi.org/project/azure-quantum/"" rel=""nofollow noreferrer"">https://pypi.org/project/azure-quantum/</a>) they say to use:</p>
<blockquote>
<p>pip install --upgrade azure-quantum[qiskit]</p>
</blockquote>
<p>in an environment with python 3.9 or higher and pip v.19.2 or higher.</p>
<p>I'm trying to install azure-quantum[qiskit] in a Conda environment equipped with python 3.9.16 and pip 22.3.1.</p>
<p>However, installing just azure-quantum with:</p>
<blockquote>
<p>pip install --upgrade azure-quantum</p>
</blockquote>
<p>works fine, while if I specify the qiskit tag I get:</p>
<blockquote>
<p>zsh: no matches found: azure-quantum[qiskit]</p>
</blockquote>
<p>Any hint to solve the issue?</p>
",<qiskit><programming><azure-quantum>,02/07/2023 14:33,30101.0,30101.0,"<p>If you're on macOS the default shell <code>zsh</code> treats <code>[</code> <code>]</code> as regex instead of a string. To workaround this you can either escape the <code>[</code> and <code>]</code> or put quotes around it. In other words do this instead:</p>
<pre><code>pip install --upgrade &quot;azure-quantum[qiskit]&quot;
</code></pre>
<p>or</p>
<pre><code>pip install --upgrade azure-quantum\[qiskit\]
</code></pre>
",02/07/2023 14:42,Tooling," The user is encountering an issue related to installing the azure-quantum[qiskit] package, which falls under the category of tooling in quantum programming. They are seeking guidance on resolving the installation problem",Tooling,,,,Tooling,
30372.0,qiskit save circuit with free parameters,"<p>Is there a way to save an instance of qiskit's <code>QuantumCircuit</code> in some format when the circuit has still some free parameters to be evaluated? I have tried using the qasm format but it seems it does not tolerate non-evaluated parameters.</p>
",<qiskit><programming>,2/25/2023 8:41,30373.0,30373.0,"<p>Yes, there is - <a href=""https://qiskit.org/documentation/apidoc/qpy.html"" rel=""nofollow noreferrer"">QPY serialization</a>. It is useful for the case you have depicted but also for many other cases where the QASM format imposes restrictions.</p>
<p><strong>An example:</strong></p>
<p>Creating the circuit and dumping it to a <code>qpy</code> file:</p>
<pre><code>from qiskit import QuantumCircuit, qpy
from qiskit.circuit import Parameter

theta = Parameter(&quot;<span class=""math-container"">$\Theta$</span>&quot;)
qc = QuantumCircuit(1)
qc.ry(theta, 0)

with open(&quot;qc.qpy&quot;, &quot;wb&quot;) as qpy_file_write:
    qpy.dump(qc, qpy_file_write)
</code></pre>
<p>Loading the circuit and assigning a value to <span class=""math-container"">$\theta$</span>:</p>
<pre><code>import numpy as np
from qiskit import qpy

with open(&quot;qc.qpy&quot;, &quot;rb&quot;) as qpy_file_read:
    qc_loaded = qpy.load(qpy_file_read)[0]

qc_loaded = qc_loaded.bind_parameters([np.pi/2])
qc_loaded.draw(&quot;mpl&quot;)
</code></pre>
<p>Displays:</p>
<p><a href=""https://i.stack.imgur.com/Az02i.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Az02i.png"" alt=""enter image description here"" /></a></p>
",2/25/2023 9:05,Tooling,"The users question pertains to saving a QuantumCircuit instance with free parameters, which falls under the category of tooling in quantum programming. They are seeking guidance on how to handle non-evaluated parameters when saving the circuit",Tooling,,,,Tooling,
31446.0,Create circuit from qiskit json format,"<p>When you run a job on an IBM device you can download a json file which contains among other things the description of the circuit. Is there a simple way in qiskit to create a QuantumCircuit object from this file without writing your own parser?</p>
<p>Below is an example for the content of this file.</p>
<pre><code>{&quot;config&quot;: {&quot;n_qubits&quot;: 5, &quot;memory_slots&quot;: 3}, &quot;header&quot;: {&quot;qubit_labels&quot;: [[&quot;q&quot;, 0], [&quot;q&quot;, 1], [&quot;q&quot;, 2], [&quot;q&quot;, 3], [&quot;q&quot;, 4]], &quot;n_qubits&quot;: 5, &quot;qreg_sizes&quot;: [[&quot;q&quot;, 5]], &quot;clbit_labels&quot;: [[&quot;meas&quot;, 0], [&quot;meas&quot;, 1], [&quot;meas&quot;, 2]], &quot;memory_slots&quot;: 3, &quot;creg_sizes&quot;: [[&quot;meas&quot;, 3]], &quot;name&quot;: &quot;circuit-103&quot;, &quot;global_phase&quot;: 2.356194490192345, &quot;metadata&quot;: {}}, &quot;instructions&quot;: [{&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;sx&quot;, &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966],...
</code></pre>
",<qiskit><quantum-circuit><programming>,03/02/2023 10:58,31448.0,31448.0,"<p>The format that the IBM Quantum API is currently using is Qobj (or Quantum object) which is documented here: <a href=""https://arxiv.org/abs/1809.03452"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1809.03452</a> and the current schema definitions for it are located here: <a href=""https://github.com/Qiskit/ibm-quantum-schemas"" rel=""nofollow noreferrer"">https://github.com/Qiskit/ibm-quantum-schemas</a></p>
<p>That's just the background information on the format though, to answer the details of your question, Qiskit supports loading this and creating a circuit from a Qobj payload via its <a href=""https://qiskit.org/documentation/stubs/qiskit.qobj.Qobj.html"" rel=""nofollow noreferrer""><code>Qobj</code></a> class and the <a href=""https://qiskit.org/documentation/stubs/qiskit.assembler.disassemble.html"" rel=""nofollow noreferrer""><code>disassemble()</code></a> function. Assuming you have a local file <code>job.json</code> the basic workflow would be something like:</p>
<pre><code>import json

from qiskit.assembler.disassemble import disassemble
from qiskit.qobj import QasmQobj

with open('job.json') as fd:
    qobj_dict = json.load(fd)
qobj = QasmQobj.from_dict(qobj_dict)
circuits, run_config, headers = disassemble(qobj)
</code></pre>
<p>Where <code>circuits</code> is the list of <code>QuantumCircuit</code> objects equivalent to what's in the qobj (a qobj can contain more than one circuit).</p>
<p><code>run_config</code> and <code>headers</code> are dictionaries containing the configuration and metadata contained in the qobj.</p>
",03/02/2023 12:58,Tooling ,"The users question pertains to creating a QuantumCircuit object from a JSON file containing circuit description, which falls under the category of tooling in quantum programming. They are seeking guidance on how to load and construct a circuit from the provided JSON format",Tooling ,,,,Tooling ,
31481.0,How to remove gates added in the quantum circuit?,"<p><a href=""https://i.stack.imgur.com/3g429.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3g429.png"" alt=""Messed up circuit"" /></a></p>
<p>I am new to Qiskit and was learning Quantum teleportation circuit on youtube. I unknowingly executed a cell while trying to modify the circuit draw style which added the unnecessary gates. How can I remove them?</p>
<pre><code>circuit.h(1)
circuit.cnot(1, 2)
circuit.draw(output=&quot;mpl&quot;)
</code></pre>
<p>This was the cell which I executed again.
I want to remove the gates after the second hadamard.</p>
",<qiskit><quantum-gate><quantum-circuit><programming>,03/04/2023 12:17,31497.0,31497.0,"<p>For your case, indeed, <a href=""https://quantumcomputing.stackexchange.com/questions/31481/how-to-remove-gates-added-in-the-quantum-circuit#comment41622_31481"">rerun the cell in the best solution</a>.</p>
<p>Here, a general solution for situation when that is not possible. Say you have the following circuit and you would like to remove the first <code>CNOT</code>:</p>
<p><a href=""https://i.stack.imgur.com/JJprL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JJprL.png"" alt=""A circuit with X in 0, a barrier, H 1, CX 1 2, and CX 0, 1 "" /></a></p>
<p>In <code>QuantumCircuit.data</code>, there is a list of the instructions in the circuit. You can pretty-print-ish like this:</p>
<pre class=""lang-python prettyprint-override""><code>for index, instruction in enumerate(circuit.data):
    print(index, instruction.operation.name, [ circuit.find_bit(q).index for q in instruction.qubits])
</code></pre>
<pre><code>0 x [0]
1 barrier [0, 1, 2]
2 h [1]
3 cx [1, 2]
4 cx [0, 1]
</code></pre>
<p>You can directly remove an instructions by removing the entry in the <code>data</code> structure:</p>
<pre><code>del circuit.data[3]
</code></pre>
<p>Resulting in the following circuit:</p>
<p><a href=""https://i.stack.imgur.com/7gaBU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7gaBU.png"" alt=""A circuit with X in 0, a barrier, H 1, and CX 0, 1 "" /></a></p>
",03/05/2023 17:10,Tooling,"The question concerns removing unnecessary gates from a quantum circuit created in Qiskit. This involves manipulating the circuit object using Qiskit's functionalities to achieve the desired circuit structure, which falls under the tooling category specifically circuit manipulation.", Errors," The question involves dealing with an error in the quantum circuit code where unnecessary gates were added due to repeated execution of a cell, and the user needs assistance in correcting this mistake.",No,137.0,Tooling," The user's question involves manipulating a quantum circuit object in Qiskit to remove unnecessary gates added due to repeated cell execution, which falls under the tooling category as it pertains to circuit manipulation within a specific quantum programming framework."
31536.0,Generalizing a brick-wall circuit acting on qubits to acting on qudits,"<p>Recently, I have been creating a &quot;brick layer&quot; circuit of random unitary gates (each acting on 2 qubits) which acts on a n qubit register using cirq. A typical circuit looks like this.</p>
<p><a href=""https://i.stack.imgur.com/DLGrJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DLGrJ.png"" alt=""enter image description here"" /></a></p>
<p>(Where a top and bottom label symbolises one gate).</p>
<p>The code used to reproduce it is here.
<a href=""https://colab.research.google.com/drive/1Rs3knKOJV8CddSQLzl1HgO1L-GR7sfbK?usp=sharing"" rel=""nofollow noreferrer"">https://colab.research.google.com/drive/1Rs3knKOJV8CddSQLzl1HgO1L-GR7sfbK?usp=sharing</a></p>
<p>I wish to extrapolate my model to n qudits as opposed to qubits. I have been successful in applying this to qutrits. The code for this is below.</p>
<p><a href=""https://colab.research.google.com/drive/13xz7PP7WZ676-PSpg06U_QmRdg4kRXDr?usp=sharing"" rel=""nofollow noreferrer"">https://colab.research.google.com/drive/13xz7PP7WZ676-PSpg06U_QmRdg4kRXDr?usp=sharing</a></p>
<p>However, when I try to do this for some general qudit register. I always land up with a type error.</p>
<p><a href=""https://i.stack.imgur.com/jzTLd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jzTLd.png"" alt=""enter image description here"" /></a></p>
<p>See the code below (which is very similar to the others)</p>
<p><a href=""https://colab.research.google.com/drive/1Ij0ZdNixv5krCIBa5-esKq92KpGzBo9Z?usp=sharing"" rel=""nofollow noreferrer"">https://colab.research.google.com/drive/1Ij0ZdNixv5krCIBa5-esKq92KpGzBo9Z?usp=sharing</a></p>
<p>Does anybody know how to fix this error? Help would be greatly appreciated :) I reckoned as it was easy to get the code working for qutrits it shouldn't be so hard to get it working for any general qudit register.</p>
<p>Cheers,
Luke</p>
",<cirq><random-quantum-circuit><programming>,03/08/2023 10:33,31539.0,31539.0,"<p>Try these changes to your code:</p>
<pre><code>class QuditPlusGate(cirq.Gate):
  def __init__(self, dimension):
    self._p = dimension
  def _qid_shape_(self):
    return (self._p, self._p)
  ...
  # the rest of your code
</code></pre>
<pre><code>def quditopsmoment0(n,p):
  qudits = qudit_register(n,p)
  u_gate = QuditPlusGate(p)
  listofqops0 = []
  i = 0
  while i &lt; n/2:
    listofqops0.append(u_gate.on(qudits[2*i],qudits[2*i + 1]))
    i = i + 1
  else:
    return listofqops0
</code></pre>
<pre><code>quditopsmoment0(2,2)
</code></pre>
<p>Passing the dimension as an argument when initializing the <code>QuditPlusGate</code> class allows eliminating the extra argument you had for the <code>_qid_shape_</code> method to match the method it was overriding. That seemed to fix it for me.</p>
",03/08/2023 19:23,Tooling, The question deals with constructing a specific quantum circuit design using Cirq. The user aims to create a circuit with random unitary gates acting on multiple qudits and is encountering errors when extending the code to general qudit registers. This falls under tooling specifically circuit building as it involves manipulating circuits using Cirq functionalities.,Tooling,,,,Tooling,
31639.0,QuTip newbie need to understand .reshape(),"<p>I am a quantum physics researcher but till now I have been using Mathematica symbolic language for solving quantum problems. I wanted to develop numerical skills as well so I just started to learn QuTip. I am ok at Python and need help occasionally with some concepts. So here is where I am stuck right now:</p>
<pre><code>def sim_transform(old1, old2, new1, new2): 
#Form the similarity transform from one basis to another.
# Calculate the relevant inner products:
a = new1.dag()*old1 
b = new1.dag()*old2 
c = new2.dag()*old1 
d = new2.dag()*old2 

# extract values from these Qobj inner # product results, reshape to 2 by 2, and # form a new Qobj matrix: 
s = [i.data[0,0] for i in [a,b,c,d]]
return Qobj(array(s).reshape(2,2))
</code></pre>
<p>In the above function, can someone please explain to me what do last two lines do? I don't understand what data, i.data, array(s).reshape(2,2) do.
Thank you in advance.</p>
",<qutip><programming>,3/14/2023 2:19,31659.0,31659.0,"<p>This expression</p>
<pre><code>s = [i.data[0,0] for i in [a,b,c,d]]
</code></pre>
<p>is a standard Python loop comprehension iterating over the set <code>[a, b, c, d]</code> (which represent the variables (arrays?) above). It appears to generate a list containing the elements <code>[0,0]</code> from each of the arrays <code>a, b, c, d</code>.</p>
<p>I suspect that the <code>reshape</code> is modelled after numpy's reshape (<a href=""https://numpy.org/doc/stable/reference/generated/numpy.reshape.html"" rel=""nofollow noreferrer"">link</a>). In the example, a <span class=""math-container"">$1 \times 4$</span> vector is being converted to a <span class=""math-container"">$2 \times 2$</span> matrix:
<span class=""math-container"">$$
  [ a, b, c, d ] \rightarrow \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix} $$</span></p>
",3/14/2023 20:06,Theoretical," The users question involves understanding the purpose and functionality of specific lines of code related to a similarity transform in QuTiP. This falls under the category of theoretical concepts in quantum programming, as it pertains to the mathematical foundations and principles behind the code snippet provided.",Theoretical,,,,Theoretical,
32000.0,Cosmetic appearances of multi-controlled Z gate in MCMT Qiskit,"<p>Using from qiskit.circuit.library I can import MCMT to create short-hand multi controlled gates,
e.g.</p>
<pre><code>from qiskit.circuit.library import MCMT
c3z = MCMT('z', num_ctrl_qubits=3, num_target_qubits=1) #define the 3-controlled z gate a.k.a. cccz gate
c3z.decompose().draw(output='mpl')
</code></pre>
<p>upon running the code you see the decomposed c3z gate:
<a href=""https://i.stack.imgur.com/ydUJc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ydUJc.png"" alt=""enter image description here"" /></a></p>
<p>if you append this gate to a quantum circuit,</p>
<pre><code>from qiskit import QuantumCircuit
circ.clear()
circ = QuantumCircuit(4)
circ.append(c3z,[0,1,2,3])
circ.draw('mpl')

</code></pre>
<p>you see the following:</p>
<p><a href=""https://i.stack.imgur.com/DEJqZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DEJqZ.png"" alt=""enter image description here"" /></a></p>
<p>2 questions:</p>
<p>1.) If I add the line</p>
<pre><code>circ.decompose(c3z)
</code></pre>
<p>(see <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.decompose.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.decompose.html</a>) to the above then the code becomes</p>
<pre><code>from qiskit import QuantumCircuit
circ.clear()
circ = QuantumCircuit(4)
circ.append(c3z,[0,1,2,3])
circ.decompose(c3z)
circ.draw('mpl')

</code></pre>
<p>And I'd expect the output to resemble the first image, not the second. However the circuit is not decomposed by adding this line and I just see the purple rectangle instead.</p>
<p>2.)
The cz/ccz gates in Qiskit have a nice appearance:</p>
<pre><code>circ.clear()
circ = QuantumCircuit(4)
circ.cz(0,1)
circ.ccz(0,1,2)
circ.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/mJWzC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mJWzC.png"" alt=""enter image description here"" /></a></p>
<p>is there any way to get my c3z gate to follow this trend and look neat and tidy?
Many thanks.</p>
",<qiskit><programming>,04/05/2023 16:56,32003.0,32003.0,"<p>I don't think this is possible if you use the <code>MCMT</code> class to create your custom gate. However, if you start from a simple <code>ZGate</code> and transform it into your multi-controlled <code>c3z</code> gate by the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.Gate.control.html"" rel=""nofollow noreferrer""><code>Gate.control</code></a> method, then the circuit should be finally drawn as you wish:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import ZGate

circ = QuantumCircuit(4)
c3z = ZGate().control(num_ctrl_qubits=3, ctrl_state='111')
circ.append(c3z, [0,1,2,3])

circ.draw('mpl')
</code></pre>
<p><a href=""https://i.stack.imgur.com/6ZJhb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6ZJhb.png"" alt=""enter image description here"" /></a></p>
",04/05/2023 17:50,Tooling,"This question pertains to the use of Qiskit, a specialized software tool for quantum computing, specifically focusing on the creation and visualization of multi-controlled gates in a quantum circuit. It involves practical implementation details and issues with the software's functionality and visual representation.",Tooling,,,,Tooling,
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"<p>So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system?</p>
<p>Below you can see the code idea:</p>
<pre><code>q1 = QuantumCircuit(2)
q1.save_statevector() # Save initial state
q1.h(0)
q1.save_statevector() # Save state after Hadamard
q1.cx(0, 1)
q1.save_statevector() # Save state after CNOT (also a final state)
job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024)
statevectors = job.result().get_statevector()
</code></pre>
<p>However, if I were to try and run this, an error occurs upon reaching <code>execute</code> command.
If anyone can provide any insight on this, I would be very grateful.</p>
",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"<p>You can also obtain the states at any point during circuit construction using <code>Statevector</code>, the class from Qiskit's quantum_info module as follows.</p>
<p>First, import the <code>Statevector</code> class,</p>
<pre><code>from qiskit.quantum_info import Statevector
</code></pre>
<p>And for your example, the code below will produce all the intermediate states that you want.</p>
<pre><code>qc = QuantumCircuit(2)
st0 = Statevector.from_instruction(qc) 
qc.h(0)
st1 = Statevector.from_instruction(qc)
qc.cnot(0, 1)
st2 = Statevector.from_instruction(qc)

print(st0)
print(st1)
print(st2)


Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
        dims=(2, 2))
Statevector([0.70710678+0.j, 0.70710678+0.j, 0.             +0.j,
         0.        +0.j],
        dims=(2, 2))
Statevector([0.70710678+0.j, 0.        +0.j, 0.        +0.j,
         0.70710678+0.j],
        dims=(2, 2))
</code></pre>
",8/25/2021 13:41,Tooling,"This question is about using Qiskit, a specialized quantum software tool, to save and retrieve intermediate state vectors in a quantum circuit. It focuses on the practical application of Qiskit's features for debugging and analyzing quantum circuits.",Tooling,,,,Tooling,
33599.0,Cannot Download TensorFlow Quantum,"<p>Hey Quantum Computing community,</p>
<p>I cannot get TensorFlow Quantum to work even though I am using</p>
<p><code>pip install tensorflow-quantum</code></p>
<p>I have TensorFlow already on Visual Studio Code, and I know it is a prerequisite for being able to download TensorFlow Quantum. I even tried going down a level of TensorFlow (I think it is called downgrading), but unfortunately, my Visual Studio Code terminal does not recognize it.</p>
<p>Thank You!</p>
<p>Update: Including image down below:<a href=""https://i.stack.imgur.com/8QIyM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8QIyM.png"" alt=""What I tried doing"" /></a></p>
",<programming><tfq>,7/28/2023 3:22,33656.0,33656.0,"<p>I think the issue is that you're on a windows machine. Based on the files present on pypi ( <a href=""https://pypi.org/project/tensorflow-quantum/0.7.2/#files"" rel=""nofollow noreferrer"">https://pypi.org/project/tensorflow-quantum/0.7.2/#files</a> ), there's only linux and osx distributions of the wheel.</p>
<p>I think this means you'll have to use it <a href=""https://colab.sandbox.google.com/github/tensorflow/quantum/blob/master/docs/tutorials/hello_many_worlds.ipynb"" rel=""nofollow noreferrer"">via collab</a>, or switch to a non-windows computer.</p>
",08/02/2023 06:07, Tooling,"This question involves troubleshooting the installation and setup of TensorFlow Quantum, a specialized tool for quantum machine learning. It addresses practical issues related to software dependencies and environment configuration in quantum software development.", Errors,"The question involves troubleshooting an issue with installing and using TensorFlow Quantum in Visual Studio Code, which pertains to resolving installation or configuration errors in the software environment.",No,138.0,Tooling,"The user's question is primarily about troubleshooting the installation and setup of TensorFlow Quantum in Visual Studio Code, which involves resolving practical issues related to software dependencies and environment configuration in quantum software development, fitting under the tooling category."
33621.0,What are the theoretical minimum times for quantum and classical logic gates?,"<p>I'm interested in better understanding the ultimate limits on how fast quantum and classical logic gates can be performed. Based on principles like the time-energy uncertainty relationship, there should be minimum times required to enact state changes and operations.</p>
<p>I'd be interested in a high-level conceptual explanation and pointers to good review papers on this topic. The goal is to better understand these ultimate limits on computational speed at a qualitative level.</p>
<p>Any insights would be greatly appreciated.</p>
",<quantum-gate><programming><quantum-state><speedup>,7/30/2023 6:57,33629.0,33629.0,"<p>There's something called the <a href=""https://en.wikipedia.org/wiki/Margolus%E2%80%93Levitin_theorem"" rel=""nofollow noreferrer"">Margolus-Levitin Theorem</a>. Roughly speaking, this says that the time required to transition between two orthogonal states using a transition of strength <span class=""math-container"">$E$</span> is
<span class=""math-container"">$$
\delta t=\frac{\pi}{2E}.
$$</span>
So you could very reasonably take this as a limit on each logic gate, and <span class=""math-container"">$E$</span> is some parameter that you can play with (there will be physical limits, but not much in the way of <em>a priori</em> limits, to my knowledge.</p>
<p>If you want to go <em>really</em> fundamental, you could make the following estimate:</p>
<ul>
<li>what is we make 1 bit of information as small as possible? The limit is that if you made it too small, it would turn into a black hole. How big is that? There's something called the BekensteinâHawking entropy, which relates the entropy (i.e. information storage) to the area of the black hole. Assume it's a sphere, and you have a minimum size of a bit.</li>
<li>If you're going to compute with that bit, you at least need time for light to travel across the bit. This gives you a minium time for a logic operation. (It's crazy small!)</li>
</ul>
",7/31/2023 6:37, Theoretical,"This question seeks a conceptual understanding of the fundamental physical limits on the speed of quantum and classical logic gates, which are based on principles of quantum mechanics. It involves theoretical aspects such as the time-energy uncertainty relationship and other fundamental physical constraints on computational speed.", Theoretical,,,, Theoretical,
33991.0,Python code for D-Wave Annealer,"<p>In the below screenshot, I am aware of resolving the issue by reducing <code>num_reads</code> as the annealing time is exceeding my allowance. Although it works, my question with this error is different.</p>
<p><a href=""https://i.stack.imgur.com/iDxz4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iDxz4.png"" alt=""enter image description here"" /></a>
<a href=""https://i.stack.imgur.com/nwMso.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nwMso.png"" alt=""enter image description here"" /></a></p>
<p>The error says that the problem cannot be submitted while I am trying to access the value of the variable <code>sample_set</code>.
I expected the error to have occurred while executing:</p>
<pre><code>sample_set = sampler.sample(bqm, num_reads=10000)
</code></pre>
<p>It seems like the problem is being submitted while I access the variable <code>sample_set</code>.</p>
<p>So, my question is, when do the following things happen in the code?</p>
<ul>
<li>problem submission</li>
<li>mapping of logical to physical qubits</li>
<li>annealer solving the problem</li>
</ul>
<p>Thanks in advance!!</p>
",<optimization><d-wave><annealing><adiabatic-model><programming>,8/31/2023 0:32,34874.0,34874.0,"<p>Well, I received an answer in the D-Wave community.</p>
<p><a href=""https://support.dwavesys.com/hc/en-us/community/posts/17281010426519-When-is-the-problem-submitted-w-r-t-the-code-"" rel=""nofollow noreferrer"">https://support.dwavesys.com/hc/en-us/community/posts/17281010426519-When-is-the-problem-submitted-w-r-t-the-code-</a></p>
",11/16/2023 13:22, Tooling,"This question deals with the practical usage of a quantum annealer, focusing on the timing and process of problem submission, qubit mapping, and problem-solving within a specific quantum software framework. It addresses the operational aspects of using quantum computing tools and the underlying workflow.", Tooling,,,, Tooling,
33993.0,Problems trying to plot the classical Fisher information with Pennylane,"<p>I'm working with pennylane. My goal is to plot CFI(Classical Fisher Information)with following quantum state.
<a href=""https://i.stack.imgur.com/te2bC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/te2bC.png"" alt=""enter image description here"" /></a></p>
<p>With the above equation I set gamma as 0. Then It becomes:
<a href=""https://i.stack.imgur.com/RRxVX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RRxVX.png"" alt=""enter image description here"" /></a></p>
<p>If gamma is not equal to zero, it needs to be normalized like: sqrt(coeff_0_state^2 + coeff_1_state^2)</p>
<p>So, I expect to get following plot.
<a href=""https://i.stack.imgur.com/CoyxF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CoyxF.png"" alt=""enter image description here"" /></a></p>
<p>The red line is the correct result when gamma = 0</p>
<p>But I got following
<a href=""https://i.stack.imgur.com/YCYRW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YCYRW.png"" alt=""enter image description here"" /></a></p>
<p>With the following code:</p>
<pre><code>import pennylane as qml
import scipy as sp
from pennylane import numpy as np
from pennylane import math as m
import matplotlib.pyplot as plt


# Variable for plot
N = 1000
tau_CFI = np.linspace(-0.001, 3.0, N)


# == Generate coeff ==
def With_norm(theta, gamma):
    coeff = np.array([ ((1+np.exp(-1.j * theta))/2) * (np.sqrt(1-gamma)) , (1-np.exp(-1.j * theta))/2 ]) / (1-gamma * (np.cos(theta)**2) ) 
    
    norm = np.linalg.norm(coeff)
    # norm_sp = sp.linalg.norm(coeff)
    # norm_new = qml.math.sqrt(qml.math.real(coeff[0])**2 + qml.math.imag(coeff[0])**2 + qml.math.real(coeff[1])**2 + qml.math.imag(coeff[1])**2)
    
    # print(norm_new == norm)
    # return norm
    return coeff / norm


def Without_norm(theta):
    gamma = 0
    coeff = np.array([ ((1+np.exp(-1.j * theta))/2) * (np.sqrt(1-gamma)) , (1-np.exp(-1.j * theta))/2 ]) / (1-gamma * (np.cos(theta)**2) )
    
    norm_new = qml.math.sqrt(qml.math.real(coeff[0])**2 + qml.math.imag(coeff[0])**2 + qml.math.real(coeff[1])**2 + qml.math.imag(coeff[1])**2)
    # norm = np.linalg.norm(coeff)
    norm = 1
    
    return coeff / norm


# With_norm(np.pi,0)

# == Generate Q_node ==

dev_with_norm = qml.device('default.qubit', wires = 1)
@qml.qnode(dev_with_norm)
def circuit_with_norm(theta):
    
    qml.QubitStateVector(With_norm(theta, 0), wires=range(1))

    
    return qml.probs()
    # return qml.density_matrix(wires=0)
    
    
dev_without = qml.device('default.qubit', wires = 1)
@qml.qnode(dev_without)
def circuit_without(theta):
    
    qml.QubitStateVector(Without_norm(theta), wires=range(1))

    
    return qml.probs()
    # return qml.density_matrix(wires=0)
    
# circuit_without(np.pi/2)

# == Compare with CFI plot ==
N = 1000
tau_CFI = np.linspace(-0.001, 3.0, N)

CFI_without = np.zeros(N)
CFI_with = np.zeros(N)

for i in range(len(tau_CFI)):
    CFI_with[i] = qml.qinfo.classical_fisher(circuit_with_norm)(tau_CFI[i])
    CFI_without[i] = qml.qinfo.classical_fisher(circuit_without)(tau_CFI[i])

plt.subplot(211)
plt.plot(tau_CFI, CFI_with)
plt.title('With normalized')
plt.xlabel('Time')
plt.ylabel('Probability_0_state')
# plt.legend()
plt.grid()


print('== print out CFI ==')
plt.subplot(212)
plt.plot(tau_CFI, CFI_without)
plt.title('Without normalized')
plt.xlabel('Time')
plt.ylabel('Probability_0_state')
plt.grid()

</code></pre>
<p>'With_normalized' I calculate the state vector coefficient with 'np.linalg.norm' for normalization. And 'Without_normalized' I normalized the coefficient just by dividing with constant 1.</p>
<p>Since gamma = 0 they should be made the same result. But I don't know why the result of the CFI which is normalized by 'np.linalg.norm' shows different.(It should be constant 1)</p>
<p>Thanks in advance.</p>
",<programming><quantum-state><pennylane><quantum-fisher-information>,8/31/2023 6:12,34001.0,34001.0,"<p>There seems to be a bug in <code>classical_fisher</code> in combination with <code>np.linalg.norm</code>. I opened an issue <a href=""https://github.com/PennyLaneAI/pennylane/issues/4560"" rel=""nofollow noreferrer"">here</a>, should be resolved soon (fingers crossed). For the meantime I suggest you use <code>np.sqrt(np.sum(np.abs(coeffs)**2))</code>, this works as expected.</p>
",8/31/2023 15:23,Tooling,"This question involves using the PennyLane library to calculate and plot the Classical Fisher Information (CFI) for a given quantum state, focusing on practical issues related to state vector normalization and its impact on computational results. It addresses the application of specific quantum computing tools and software to achieve accurate results.",Tooling,,,,Tooling,
34065.0,Create qnode with density matrix on pennylane,"<p>I'm using pennylane.</p>
<p>What I want to do is</p>
<ol>
<li>Create a <code>qnode</code> with the 2*2 density matrix of a single qubit one. It has the parameter as phi</li>
</ol>
<ul>
<li>Given density matrix:
<span class=""math-container"">$$\frac{1}{\gamma\cos(\varphi)+(\gamma-2)\mathrm{e}^{\frac{t}{t_2}}}\begin{pmatrix}(\gamma-1)\left(\mathrm{e}^{\frac{t}{t_2}}+\cos(\varphi)\right)&amp;\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)\\-\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)&amp;\cos(\varphi)-\mathrm{e}^{\frac{t}{t_2}}\end{pmatrix}$$</span></li>
</ul>
<ol start=""2"">
<li>Pass is to <code>qml.qinfo.classical_fisher()</code>. I want to calculate classical fisher information respect to phi.</li>
</ol>
<p>But the problem is that when I create qnode with density matrix and pass it to <code>qml.qinfo.classical_fisher()</code> it shows the following error:</p>
<pre><code>DeviceError: Gate QubitDensityMatrix not supported on device default.qubit.autograd
</code></pre>
<p>Is there any possible method to define a <code>qnode</code> with a custom density matrix available to use with autograd?</p>
<p>I tried to convert it to a state vector but since the density matrix is a mixed state it can't be converted to state vector.</p>
<p>Here is my code:</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np

t1, t2, gamma = 1, 1, 0.5

# Define the density matrix
def rho_ps(phi):
    density_matrix_ps = np.array([
        [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)],
        [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2))

    return density_matrix_ps

n_wires = 1
dev = qml.device(&quot;default.qubit&quot;, wires=n_wires)

# Define the qnode with density matrix
@qml.qnode(dev)
def circ(params):
    density_matrix = rho_ps(params)
    qml.QubitDensityMatrix(density_matrix, wires=0)  # Initialize the qubit with the density matrix

    return qml.expval(qml.PauliZ(0))

# Generate parameters used in classical fisher information
params = np.array([np.pi])
CFIM = qml.qinfo.classical_fisher(circ)

print(CFIM)
<span class=""math-container"">```</span>
</code></pre>
",<density-matrix><pennylane><programming><quantum-fisher-information>,09/07/2023 08:53,34095.0,34095.0,"<p>My previous answer mistakenly read <code>quantum_fisher</code> instead of <code>classical_fisher</code>. It is actually possible to compute the latter with mixed states, but not the former.</p>
<p>It seems that there are three problems in your code:</p>
<ul>
<li>The device you use should be <code>default.mixed</code>, since the density matrix you care about is mixed.</li>
<li><code>params</code> should be differentiable, and should thus be created with <code>requires_grad=True</code></li>
<li><code>CFIM</code> must be called on <code>params</code>, as it's a function</li>
</ul>
<p>All in all, the following code gives you what you want (If I'm not mistaken):</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np

t1, t2, gamma = 1, 1, 0.5

# Define the density matrix
def rho_ps(phi):
    density_matrix_ps = np.array([
        [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)],
        [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2))

    return density_matrix_ps

dev = qml.device(&quot;default.mixed&quot;, wires=[0])

@qml.qnode(dev)
def circ(params):
    density_matrix = rho_ps(params)
    qml.QubitDensityMatrix(density_matrix, wires=0)

    return qml.expval(qml.PauliZ(0))

params = np.array([np.pi], requires_grad=True)
CFIM = qml.qinfo.transforms.classical_fisher(circ)
print(CFIM(params))
</code></pre>
",09/09/2023 10:08, Tooling," This question involves using the PennyLane library to calculate the Classical Fisher Information for a given quantum state represented as a density matrix, focusing on the practical challenges of implementing this with specific functions and devices within the tool. It addresses issues related to the compatibility of PennyLane's features and the operational aspects of defining and manipulating quantum states in the software.", Tooling,,,, Tooling,
34328.0,DeprecationWarning: Back-references to from Bit instances to their containing Registers have been deprecated,"<p>I have the following code</p>
<pre><code>for instruction, qargs, cargs in qc.data:
    qbit: qiskit.circuit.Qubit = qargs[0]
    print(qbit.register)
    print(qbit.index)
</code></pre>
<p>the last 2 lines give me a warning:</p>
<blockquote>
<p>DeprecationWarning: Back-references to from Bit instances to their
containing Registers have been deprecated. Instead, inspect Registers
to find their contained Bits.</p>
</blockquote>
<p>How can I read them to avoid the warning?</p>
",<qiskit><programming>,10/01/2023 16:44,34329.0,34329.0,"<p>The correct way to retrieve the index of a bit within a circuit, and any registers in that circuit the bit is contained within is to call <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.find_bit"" rel=""nofollow noreferrer""><code>QuantumCircuit.find_bit()</code></a> as follows:</p>
<pre><code>for instruction, qargs, cargs in qc.data:
    qbit: Qubit = qargs[0]
    bit_location = qc.find_bit(qbit)
    print(bit_location.index)
    print(bit_location.registers[0])
</code></pre>
",10/01/2023 18:23,Tooling,"This question pertains to using Qiskit, a quantum computing software tool, and addresses how to avoid deprecation warnings when accessing qubit information. It involves understanding and applying the correct methods and practices within the Qiskit framework to manage quantum circuit data.", Errors," The question pertains to resolving a deprecation warning in code, which involves understanding and correcting the usage of the Qiskit library to avoid deprecated practices.",No,139.0, Errors,"The question involves addressing and resolving a specific deprecation warning in the user's code, indicating a need to correct deprecated practices within the Qiskit framework, fitting under the Errors category."
34468.0,How to collapse the subcircuits in a QuantumCircuit?,"<p>Suppose I have a <code>QuantumCircuit</code> object named <code>FC</code>, which explicitly contains the identity gate, and convert it into a gate using <code>.to_instruction()</code>:</p>
<p><code>gate = FC.to_instruction()</code></p>
<p>and I use this to create a bigger <code>QuantumCircuit</code> object named <code>circuit</code>, which looks like this:</p>
<p><a href=""https://i.stack.imgur.com/WH4uZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WH4uZ.png"" alt=""enter image description here"" /></a></p>
<p>Now, when I iterate over the elements of the <code>circuit</code>, using this code:</p>
<pre><code>for instruction, qarg, carg in circuit:
    print(instruction)
</code></pre>
<p>I get this:</p>
<pre><code>Instruction(name='gate', num_qubits=3, num_clbits=0, params=[])
Instruction(name='gate', num_qubits=3, num_clbits=0, params=[])

</code></pre>
<p>However, <code>gate</code> itself is made up of its constituent elements, which don't show up in the above list. How do I &quot;collapse&quot; the circuit, so that I can iterate over all the components present in <code>circuit</code>, rather than just <code>gate</code>? One way you can go about doing this is to transpile the circuit like this:</p>
<pre><code>from qiskit import Aer, transpile

simulator = Aer.get_backend('aer_simulator')
circ = transpile(circ, simulator)
</code></pre>
<p>and iterate over <code>circ</code>, but when I do that, the identity gate does not show up.</p>
",<programming><qiskit>,10/13/2023 20:41,34469.0,34469.0,"<p>You can achieve that by calling <code>QuantumCircuit</code>'s <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.decompose"" rel=""nofollow noreferrer""><code>decompose()</code></a> method as follows:</p>
<pre><code>for instruction, qarg, carg in circuit.decompose():
    print(instruction)
</code></pre>
<p>Another option is to add <code>FC</code> to your circuit using <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.compose"" rel=""nofollow noreferrer""><code>compose</code></a> method intead of <code>append</code>:</p>
<pre><code>circuit = circuit.compose(FC, [0, 1, 2])
</code></pre>
<p>Note that you should use <code>FC</code> directly without converting it into a gate.</p>
",10/14/2023 6:28,Tooling,"This question involves working with Qiskit to manage and manipulate quantum circuits, focusing on how to ""collapse"" a composite gate into its constituent operations for iteration purposes. It addresses the practical aspects of circuit manipulation and inspection within the Qiskit framework.",Tooling,,,,Tooling,
34536.0,Set the initial state of the QuantumCircuit using the Statevector object,"<p>Suppose we have a 4-qubit quantum state <code>state</code> which is a Statevector object:</p>
<pre><code>&gt;&gt;&gt; type(state)
qiskit.quantum_info.states.statevector.Statevector
</code></pre>
<p>I would like to initialize a 6-qubit <code>QuantumCircuit</code>, such that registers 0, 1, 3, 4 are initialized in <code>state</code>, something like this:</p>
<pre><code>qc = QuantumCircuit(6)
qc.initialize(state, [0, 1, 3, 4])
</code></pre>
<p>Now, the <code>initialize</code> method takes a list of complex amplitudes as an input. However, is there a way to feed it <code>state</code> directly, without converting it into a list?</p>
",<qiskit><programming>,10/19/2023 21:39,34537.0,34537.0,"<p>You can do this with <code>QuantumCircuit.prepare_state</code> or <code>QuantumCircuit.initialize</code>.</p>
<p>I'll show a simple example.</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

state = Statevector.from_label(&quot;+-rl&quot;)
qc = QuantumCircuit(4)
qc.prepare_state(state, [0, 1, 2, 3])
</code></pre>
<p>Here I've constructed my <code>Statevector</code> object using <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html#qiskit.quantum_info.Statevector.from_label"" rel=""nofollow noreferrer"">Statevector.from_label</a> but you should be able to construct it however you like and plug it into <code>QuantumCircuit.prepare_state</code>.</p>
<p><code>QuantumCircuit.initialize</code> resets all qubits to the <span class=""math-container"">$|0\rangle$</span> state before state preparation.</p>
<p><code>QuantumCircuit.prepare_state</code> does not add resets.</p>
",10/19/2023 21:54,Tooling,"This question involves working with Qiskit to initialize a quantum circuit with a given quantum state, focusing on the practical aspect of directly using a Statevector object without converting it into a list of complex amplitudes. It addresses the functionality and usage of Qiskit's quantum circuit initialization methods.",Tooling,,,,Tooling,
34599.0,Converting a dictionary to a statevector in Qiskit,"<p>Suppose we have a dictionary of computational basis states and their amplitudes:</p>
<p><code>{'01':0.5, '10':0.5, '11':0.5, '00':0.5}</code></p>
<p>How do I convert this (or any arbitrary dictionary) into a <code>Statevector</code> object? In this case the statevector should be is</p>
<p><span class=""math-container"">$$
| \psi \rangle = \frac{|00 \rangle + |01 \rangle + |10 \rangle + |11 \rangle}{2}
$$</span></p>
",<qiskit><programming>,10/25/2023 15:40,34602.0,34602.0,"<p>I don't think there a built-in functionality for this in Qiskit.
However, it is easy to implement. The below code snippet shows how to do that:</p>
<pre><code>from qiskit.quantum_info import Statevector
import numpy as np

_state = {'01':0.5, '10':0.5, '11':0.5, '00':0.5}

# Convert dictionary into array:
num_qubits = len(next(iter(_state)))
data = np.zeros(2 ** num_qubits)

for key in _state:
    data[int(key, 2)] = _state[key]

psi = Statevector(data)

# Check:
psi.draw('latex')
</code></pre>
<p>Note that, it is not a production-quality code. For example, there is an implicit assumption that all the dictionary keys have the same length.</p>
",10/25/2023 15:58,Tooling," This question involves manipulating quantum states using Qiskit, specifically converting a dictionary of computational basis states and their amplitudes into a Statevector object. It addresses the practical aspect of data manipulation and conversion within the Qiskit framework.",Tooling,,,,Tooling,
34656.0,What does Quantum Circuit Wires and Separated mean?,"<p>From <a href=""https://www.sciencedirect.com/topics/computer-science/quantum-circuit"" rel=""nofollow noreferrer""><em>Quantum Circuits</em></a>, there are two statements that are not clear.</p>
<p><em>Quantum Circuits
Quantum circuits are collections of quantum gates interconnected by quantum wires. The actual structure of a quantum circuit, the number and the types of gates, as well as the interconnection scheme are dictated by the unitary transformation, U, carried out by the circuit. Though in our description of quantum circuits we use the concepts input and output registers of qubits, we should be aware that physically, the input and the output of a quantum circuit are not separated as their classical counterparts are; this convention allows us to describe the effect of unitary transformation carried out by the circuit in a more coherent fashion. In all descriptions of quantum circuits in addition to gates, we see quantum wires that move qubits and allow us to compose more complex circuits from simpler ones that, in turn, are composed of quantum gates. We compose components by connecting the output of one to the input of another; we also compose operations when the results of an operation are used as input to another. The composition does not affect the quantum states. The quantum wires do not perform any transformations in a computational sense; sometimes we can view them as transformations carried out by the Pauli identity operator âI.</em></p>
<p>What does</p>
<ol>
<li><p>&quot;the <em><strong>output of a quantum circuit are not separated as their classical counterparts are</strong></em>; &quot; mean? What does it mean are not separated as their classical counterparts? In classical, we have transistors acting as gates - so aren't those connected too?</p>
</li>
<li><p>&quot;we see <em><strong>quantum wires that move qubits</strong></em> and allow us to compose more complex circuits from simpler ones that, in turn, are composed of quantum gates&quot; mean. What are these wires physically in a quantum computer? I understand that we read quantum circuits from left to right and that they are unitary transformations. Are the wires just a way to show this flow is from left-to-right?</p>
</li>
</ol>
",<quantum-gate><quantum-circuit><classical-computing>,10/30/2023 20:49,34664.0,34664.0,"<p>For most qubit modalities quantum <em>wires</em> are best thought of as time while quantum <em>gates</em> are best thought of as electromagnetic pulses applied to individual qubits. This is in contrast to classical gates, where classical wires are etchings of metal inside a substrate while classical gates are, as you say, transistors arranged in series and/or in parallel.</p>
<p>Take, for example, a NOT gate (which negates a bit).  Classically this is instantiated with an etching of an input wire <span class=""math-container"">$a$</span>, forked to go into a PMOS transistor in series with an NMOS transistor, with the output wire <span class=""math-container"">$\bar a$</span> at that point of connection. We can separately probe the input wire <span class=""math-container"">$a$</span> independently from the output wire <span class=""math-container"">$\bar a$</span>.</p>
<p>But this is in contrast with a Pauli <span class=""math-container"">$X$</span> gate (which similarly negates a qubit).  To apply the <span class=""math-container"">$X$</span> gate to a qubit <span class=""math-container"">$|\psi\rangle$</span> at a particular depth of your circuit, you wait until the depth of note and then you apply an electromagnetic pulse (e.g., a laser) to your qubit as <span class=""math-container"">$X|\psi\rangle$</span>.  But the input wire is just time up to the <span class=""math-container"">$X$</span> gate, which can't be separately probed independently of the output wire.</p>
<p>I also really like the analogy that quantum circuits are akin to musical writing.  Time marches left to right; the single notes and chords correspond to single-qubit gates and multi-qubit gates, respectively, and there's no feedback or fan-out/fan-in.  Whereas a classical circuit has such fan-in and fan-out, and often utilizes feedback - for example to design flip-flops, a quantum circuit cannot effectuate the same kind of feedback.</p>
",10/31/2023 12:03, Conceptual,"This question delves into understanding the conceptual aspects of quantum circuits, specifically addressing the nature of quantum wires and their role in composing quantum circuits. It seeks clarification on the abstract concepts presented in the description of quantum circuits rather than practical implementation details.", Conceptual,,,, Conceptual,
34693.0,Consecutive phased X rotation gates simplification,"<p>I have two consecutive phased X rotation (see cirq <a href=""https://quantumai.google/reference/python/cirq/PhasedXPowGate"" rel=""nofollow noreferrer"">PhasedXPowGate</a> gate definition), how to find both t' and p' angles (according to previoux cirq definition) so that two consecutive PhasedXPowGate are simplified in one PhasedXPowGate gate with these t' and p' angles ?</p>
<p>In other words, I'm searching t' and p' so that PhasedXPowGate(t', p') = PhasedXPowGate(t1, p1)*PhasedXPowGate(t2, p2)</p>
<p>Thank you.</p>
",<programming><gate-synthesis>,11/02/2023 16:11,34699.0,34699.0,"<p>For reference, in Cirq, the <code>PhasedXPowGate(p,t)</code> is defined as:
<span class=""math-container"">$$Z^pX^tZ^{-p},$$</span>
where <span class=""math-container"">$t$</span>,<span class=""math-container"">$p\in\mathbb{R}$</span>, and <span class=""math-container"">$X$</span>,<span class=""math-container"">$Z$</span> are the Pauli X and Z operators.</p>
<p>The product of two of these gates would be:</p>
<p><span class=""math-container"">$$Z^{p_1}X^{t_1}Z^{-{p_1}}Z^{p_2}X^{t_2}Z^{-{p_2}},$$</span></p>
<p>My first guess seeing the structure of the gate was to think about commutation relations of the Pauli matrices, i.e. <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> anti-commute. However, this relation doesn't hold for any choice of <span class=""math-container"">$p$</span> and <span class=""math-container"">$t$</span>. There is no guarantee that you can find a closed form expression that satisfies the following equation
<span class=""math-container"">$$X^{a}Z^{b}=\alpha Z^{a'}X^{b'},$$</span>
which in turn makes it impossible to find a set of <span class=""math-container"">$t'$</span>,<span class=""math-container"">$p'$</span> that satisfy your equation:
<span class=""math-container"">$$Z^{p'}X^{t'}Z^{-{p'}} = Z^{p_1}X^{t_1}Z^{-{p_1}}Z^{p_2}X^{t_2}Z^{-{p_2}}$$</span></p>
<p>This can also be understood intuitively if you use the Bloch sphere representation. You can visualize this <code>PhasedXPowGate(p,t)</code> as an rotation on the XY-plane, with <span class=""math-container"">$p$</span> determines the axis in the XY-plane about which a rotation of amount determined by <span class=""math-container"">$t$</span> occurs.</p>
<p>If you think of it as XY-rotations, and assuming <span class=""math-container"">$p_1$</span> and <span class=""math-container"">$p_2$</span> do not hold some relation, the two rotations are made along different axes on the XY-plane and therefore the total operation may not be described by a rotation on the XY-plan anymore, making your equation impossible to solve.</p>
",11/03/2023 09:10,Conceptual,This question involves understanding the conceptual relationship between consecutive PhasedXPowGate gates in Cirq and finding the appropriate parameters to simplify them into a single gate. It focuses on the theoretical understanding of gate composition and parameterization rather than practical implementation details.,Conceptual,,,,Conceptual,
34747.0,Phase shift on qiskit quantum teleportation simulation,"<p>I wonder in Qiskit why the phase shift occurred in my simulation and how I can turn it off.
I posted another question regarding the same simulation <a href=""https://quantumcomputing.stackexchange.com/questions/34729/quantum-teleportation-simulation-in-a-different-way"">here</a>, and while I tried to solve this on my own, I found that the phase shift disrupted my quantum teleportation simulation.
<strong>FYI</strong>: This simulation is running quantum teleportation by parts so we can communicate through the terminal.
Now, I'll describe my code and what's the problem with screenshots.</p>
<ol>
<li>Alice generates a random state</li>
</ol>
<pre class=""lang-python prettyprint-override""><code>import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, BasicAer, IBMQ
from qiskit import Aer
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit import *
import matplotlib.pyplot as plt
from qiskit.visualization import plot_histogram
from qiskit.extensions import Initialize
from qiskit.quantum_info import Statevector, random_statevector
#randome statevector generated from |0&gt; state.
def random_state(nqubits):
    &quot;&quot;&quot;Creates a random nqubit state vector&quot;&quot;&quot;
    from numpy import append, array, sqrt
    from numpy.random import random
    real_parts = array([])
    im_parts = array([])
    for amplitude in range(2**nqubits):
        real_parts = append(real_parts, (random()*2)-1)
        im_parts = append(im_parts, (random()*2)-1)
    # Combine into list of complex numbers:
    amps = real_parts + 1j*im_parts
    # Normalise
    magnitude_squared = 0
    for a in amps:
        magnitude_squared += abs(a)**2
    amps /= sqrt(magnitude_squared)
    return amps
psi = random_state(1)
# Initialize the state to be teleported
init_gate = Initialize(psi)
</code></pre>
<p>And since this is an initialized object, I put this qubit into the quantum circuit to get the state vector.</p>
<pre class=""lang-python prettyprint-override""><code>#quantum circuit for getting statevector from initialize objects.
qc_init = QuantumCircuit(1,global_phase=0)
#Check initial random state
print(&quot;initial random state&quot;)
print(init_gate)
qc_init.append(init_gate, [0])
print(qc_init)
compiled_circuit_init = transpile(qc_init, Aer.get_backend('statevector_simulator'))
simulator_init = Aer.get_backend('statevector_simulator')
result_init = simulator_init.run(compiled_circuit_init).result()
init_statevector = result_init.get_statevector()
</code></pre>
<p>The result is same as the below:
<a href=""https://i.stack.imgur.com/PUHDF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PUHDF.png"" alt=""random qubit generation result"" /></a></p>
<ol start=""2"">
<li>Alice teleport through Bell state
I created 3-compound qubit system using tensor product as below.</li>
</ol>
<pre class=""lang-python prettyprint-override""><code>#use evolve to change Initialize method to Statevector.
statevector_bell = Statevector.from_label('00')
# Combine the individual statevectors using tensor product
compound_statevector = init_statevector.tensor(statevector_bell)
print(&quot;tensor product result\n&quot;)
print(compound_statevector.data)
</code></pre>
<p>The compound qubit system is the same as below:
<a href=""https://i.stack.imgur.com/xYemo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xYemo.png"" alt=""compound qubit system"" /></a></p>
<p>And then, by using a standard quantum teleportation circuit, I proceed with quantum teleportation.</p>
<pre class=""lang-python prettyprint-override""><code>#qc is stage1. generate Bell state and operate in Alice's side
qc = QuantumCircuit(3, 2,global_phase=0)
# Prepare an entangled Bell pair between Alice and Bob
qc.h(1)
qc.cx(1, 2)
qc.barrier()
# Entangle the state to be teleported with Alice's qubit
qc.cx(0, 1)
qc.h(0)

#evolve compound statevector through evolve method.
compound_statevector = compound_statevector.evolve(qc)
print(qc)
print(&quot;result\n&quot;)
print(compound_statevector.data)
</code></pre>
<p>Then I got below output.
<a href=""https://i.stack.imgur.com/1tl2P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1tl2P.png"" alt=""stage1"" /></a></p>
<ol start=""3"">
<li><strong>Next,I put this compound state vector using the initialize method and measured Allice's part</strong></li>
</ol>
<pre class=""lang-python prettyprint-override""><code>#qc1 is stage2. measure Alice's side
qc1 = QuantumCircuit(3,2,global_phase=0)
# Measurement on Alice's qubits
qc1.initialize(compound_statevector,[0,1,2])
qc1.measure([0, 1], [0, 1])
# Print the circuit and execute to obtain Alice's measurement result
print(&quot;Measurement outcomes for Alice's qubits:&quot;)
print(qc1)

simulator = BasicAer.get_backend('statevector_simulator')
job_alice = execute(qc1, simulator, shots=1)
result_alice = job_alice.result()
statevector_alice = result_alice.get_statevector()
print(statevector_alice)
alice_measurement_result = list(result_alice.get_counts(qc1).keys())[0]

# Display Alice's measurement result and wait for user input
print(&quot;Alice's measured information:&quot;, alice_measurement_result)
input(&quot;Press Enter to continue and apply corrections to Bob's qubit&quot;)
</code></pre>
<p>The output will be the same as below.
<a href=""https://i.stack.imgur.com/N4LIg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/N4LIg.png"" alt=""Alice's measurement"" /></a>
<em><strong>As we can see, we got the same information bit except the phase shift.</strong></em>
So I expected that when we apply appropriate quantum operation, we could get the same initial 3-quantum system which is the same as
[-0.06990825-0.44371049j  0.        -0.j          0.        -0.j
0.        -0.j          0.61540968+0.64769187j  0.        +0.j
0.        +0.j          0.        +0.j        ]</p>
<ol start=""4"">
<li>However, when we implement the below code, we still have a phase shift.</li>
</ol>
<pre class=""lang-python prettyprint-override""><code>#qc2 is stage3. Bob implement operation.
qc2 = QuantumCircuit(3, 1,global_phase=0)
#typing measured output and feed into bob's quantum circuit will be implemented.

qc2.initialize(statevector_alice, [0,1,2])
# Apply corrections to Bob's qubit based on Alice's measurement result
if alice_measurement_result[0] == '1':
    qc2.z(2)
if alice_measurement_result[1] == '1':
    qc2.x(2)
print(&quot;Complete Quantum Circuit:&quot;)
print(qc2)
job_bob = execute(qc2, simulator, shots=1)
result_bob = job_bob.result()
statevector_bob = result_bob.get_statevector()
print(&quot;Measurement outcomes for Bob's qubit:&quot;)
print(statevector_bob)
</code></pre>
<p><a href=""https://i.stack.imgur.com/gYItJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gYItJ.png"" alt=""bob's measurement"" /></a>
I know that in real, Bob also has to measure his qubit, but in a simulation, we want to get the same compound state vector as our input.
Also, I know that there is no need to run quantum teleportation simulation by parts like this, and it won't work in IBM Quantum, but for our purpose, running well in our local computer on the Qiskit is enough.</p>
<p>First, I thought that the global phase was the reason, so I put &quot;global_phase=0&quot; to make sure even I knew that the default value is 0 for the global phase.</p>
<p>After that, I'm still now sure what's the problem.
We could see that the initial information reside in part 3 except the phase shift, and we couldn't change the phase shift appropriately.</p>
<p>Is there a misunderstanding from me regarding quantum teleportation?
Please let me know if you have any concerns.
Thank you for taking the time to read all of this.</p>
",<qiskit><programming><quantum-state><simulation><teleportation>,11/07/2023 04:32,34749.0,34749.0,"<p>Qiskit uses little-endian bit ordering (see <a href=""https://quantumcomputing.stackexchange.com/a/8370/9474"">this answer</a> for details). It seems that you didn't take that into consideration in  some places in your code.
For example, to tensor product <code>init_statevector</code> with <code>statevector_bell</code> such that <code>init_statevector</code> is the first qubit you should use:</p>
<pre><code>compound_statevector = statevector_bell.tensor(init_statevector)
</code></pre>
<p>instead of</p>
<pre><code>compound_statevector = init_statevector.tensor(statevector_bell)
</code></pre>
<p>You may need to review all your code to make sure there are no other issues related to bit ordering.</p>
<p>Also, you should switch <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> gates while applying the correction.</p>
",11/07/2023 05:59,Errors,"The user is encountering unexpected phase shifts in their quantum teleportation simulation in Qiskit and is seeking assistance in understanding and resolving the issue. They have provided detailed code, screenshots, and explanations, indicating a debugging scenario where they are troubleshooting an unexpected behavior in their simulation.",Theoretical,"The question involves an inquiry into the theoretical aspects of quantum teleportation, specifically regarding the phase shift observed during simulation and how to address it. It delves into the understanding of quantum teleportation algorithms and principles rather than practical tool usage or learning resources.",No,140.0,Errors,"The user is encountering unexpected phase shifts in their quantum teleportation simulation in Qiskit and is seeking assistance in understanding and resolving the issue. They have provided detailed code, screenshots, and explanations, indicating a debugging scenario where they are troubleshooting an unexpected behavior in their simulation."
34771.0,Why are quantum computing networks so far behind classical methods?,"<p>I'm new to quantum computing, and computing in general, but it seems like quantum computing networks are really lagging behind what we have achieved with classical networks. I know that there are limitations, such as the need for quantum repeaters, as quantum information can not be cloned, but I have also seen that designs for such repeaters have been created. I was wondering why, if these limitations can be surpassed, has no global quantum computing network been created?</p>
",<classical-computing><quantum-networks>,11/08/2023 22:07,34799.0,34799.0,"<p>Quantum communication is a field where theory is far beyond experiment. Entanglement theory lies at the heart of computational complexity and entanglement is what really separates quantum mechanics from classical physics. To create a highly entangled state and keep it free from noise is the main problem of building a quantum computer and also of building a quantum network. Given that most quantum networks are represented by a graph state which is also a resource for universal quantum computation your question is equal to &quot;Why cannot we build a decent fault tolerant quantum computer while we can build classical computers with billions of bits?&quot;
The problem is error correction again and it is far easier to error correct qubits in a quantum computer where you have all qubits lying close to each other when compared to a highly entangled graph state where you need to keep entanglement in the presence of thermal noise while sending the individual qubits over long distances.</p>
",11/10/2023 18:03,Conceptual,"The question delves into the conceptual understanding of why a global quantum computing network hasn't been created despite advancements in quantum repeater designs. It seeks to understand the underlying limitations and challenges that prevent the establishment of such a network, which falls under the conceptual category of discussions about the background and limitations of quantum computing.",Conceptual,,,,Conceptual,
34860.0,How to measure in $\sigma_x$ basis in Qiskit?,"<p>As we know, Qiskit can give us the results of our measurements in computational or, better to say, <span class=""math-container"">$\sigma_z$</span> basis. However, I am courageous about measuring the qubit in, for instance, <span class=""math-container"">$\sigma_x$</span> basis. In <span class=""math-container"">$\sigma_x$</span> basis, we have to projective measurements such that <span class=""math-container"">$|+\rangle$</span> and <span class=""math-container"">$|-\rangle$</span>. Here, how can we realize that we have measured the state of the qubit in either <span class=""math-container"">$|+\rangle$</span> or <span class=""math-container"">$|-\rangle$</span>?</p>
",<qiskit><programming><quantum-algorithms>,11/15/2023 17:25,34863.0,34863.0,"<p>It's a bit long for a comment but my goal is to explain that the answer linked as duplicate does indeed answer your question.</p>
<p>The <code>measure</code> operation of qiskit measures in the computational basis, there's no way around that (though <a href=""https://github.com/Qiskit/qiskit/pull/9269"" rel=""nofollow noreferrer"">it may change in the future</a>).</p>
<p>However, it is possible to simulate a measurement in the <span class=""math-container"">$X$</span>-basis using a measurement in the computational basis. To keep things simple, I'll stick to single qubit pure states here, but the reasoning is identical for more qubits and mixed states.</p>
<p>When measuring a state <span class=""math-container"">$|\psi\rangle=\alpha|0\rangle+\beta|0\rangle$</span> in the computational basis, we measure <span class=""math-container"">$|0\rangle$</span> with probability <span class=""math-container"">$|\alpha|^2$</span>, and <span class=""math-container"">$|1\rangle$</span> with probability <span class=""math-container"">$|\beta|^2$</span>.</p>
<p>When measuring the aforementioned state in the computational basis, we measure <span class=""math-container"">$|+\rangle$</span> with probability <span class=""math-container"">$$|\langle+|\psi\rangle|^2=\frac{|\alpha+\beta|^2}{2}$$</span> and <span class=""math-container"">$|1\rangle$</span> with probability <span class=""math-container"">$$|\langle-|\psi\rangle|^2=\frac{|\alpha-\beta|^2}{2}$$</span></p>
<p>Now, suppose we apply an Hadamard gate on <span class=""math-container"">$|\psi\rangle$</span>, we end up with:
<span class=""math-container"">$$H|\psi\rangle=\frac{\alpha+\beta}{\sqrt{2}}|0\rangle+\frac{\alpha-\beta}{\sqrt{2}}|1\rangle$$</span></p>
<p>Thus, if we now measure the state in the computational basis, we will measure <span class=""math-container"">$|0\rangle$</span> with probability <span class=""math-container"">$|\langle+|\psi\rangle|^2$</span> and <span class=""math-container"">$|1\rangle$</span> with probability <span class=""math-container"">$|\langle-|\psi\rangle|^2$</span>. Thus, if we finally apply an Hadamard gate after having measured, we would have perfectly simulated a measurement in the <span class=""math-container"">$X$</span>-basis using a measurement in the computational basis.</p>
<hr />
<p>More generally, for an arbitrary number of qubits, when you want to measure in a given basis, it will always be possible to write this basis as <span class=""math-container"">$(U|i\rangle)_i$</span>. If you apply <span class=""math-container"">$U^\dagger$</span> to <span class=""math-container"">$|\psi\rangle$</span> and measure in the computational basis, you will measure <span class=""math-container"">$|i\rangle$</span> with probability:
<span class=""math-container"">$$\left|\langle i|U^\dagger|\psi\rangle\right|^2$$</span>
Which is exactly the probability to measure <span class=""math-container"">$U|i\rangle$</span> if we measure in the <span class=""math-container"">$(U|i\rangle)_i$</span> basis. You then simply need to apply <span class=""math-container"">$U$</span> to simulate a measurement in this basis using one in the computational basis.</p>
",11/15/2023 23:10,Conceptual,"The question seeks to understand the conceptual aspect of measuring qubits in the ?+??+? or ??? basis instead of the standard computational basis. It delves into the underlying principles of quantum measurement and basis transformations, which fall under the conceptual category of quantum programming.",Conceptual,,,,Conceptual,
34896.0,If_test() - Dynamic Circuits in qiskit,"<p>I am trying to run a dynamic circuit by having mid-measurement in my code as follows:</p>
<pre><code>from qiskit import *
from math import *
from qiskit.providers.fake_provider import FakeJakarta

backend = FakeJakarta()

q0 = QuantumRegister(1)
q1 = QuantumRegister(1)
c  = ClassicalRegister(2)
qc = QuantumCircuit(q0, q1, c)
result_ = []
for i in range(2):
    qc.ry(2*pi/3, q0)
    qc.cx(q0, q1)
    qc.h(q1)
    qc.measure(q1, c[i])
    with qc.if_test((c[i], 0)) as _else:
        result_.append(0)
    with _else:
        result_.append(1)
job = backend.run(qc)
print(result_)
</code></pre>
<p>As it is obvious we must have a result like [0, 1, 0]. However, the list that I receive always is [0, 1, 0, 1]. Does anyone know how to solve this matter?</p>
",<qiskit><quantum-gate><programming>,11/17/2023 17:33,34900.0,34900.0,"<p>It appears there's a misunderstanding regarding the use of <code>if_test</code> and <code>_else</code> constructs in your code. In Qiskit, these constructs are for adding conditional quantum operations to the circuit based on classical register states, not for controlling the flow of Python code execution. Consequently, in your loop, both <code>result_.append(0)</code> and <code>result_.append(1)</code> are executed in each iteration, leading to a list that's twice as long as expected. Also, you should only expect a list of length two as your result (not three), as you are measuring with classical bit <code>c[0]</code> in the first iteration, and <code>c[1]</code> in the second iteration.</p>
<p>Here's a (potential) version of your code that gathers measurement data from each iteration (if I am correct in interpreting this you want to do):</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit import *
from math import *
from qiskit.providers.fake_provider import FakeJakarta

backend = FakeJakarta()

q0 = QuantumRegister(1)
q1 = QuantumRegister(1)
c  = ClassicalRegister(2)
qc = QuantumCircuit(q0, q1, c)

results = []

for i in range(2):
    qc.ry(2*pi/3, q0)
    qc.cx(q0, q1)
    qc.h(q1)
    qc.measure(q1, c[i])
    job = backend.run(qc, shots=1)
    result = job.result().get_counts(qc)
    results.append(result)

print(results)
</code></pre>
",11/18/2023 13:49,Errors,"The question involves seeking a solution to unexpected behavior in the code, where the expected result does not match the actual output. It pertains to identifying and resolving an issue with the circuit implementation, which falls under the Errors category in quantum programming.",Errors,,,,Errors,
35088.0,Implementing a Quantum Recurrent Neural Network,"<p>I want to implement a Quantum Recurrent Neural Network and use it for time series forecasting.
As a starting point, I chose to implement it using the architecture given in this paper: <a href=""https://arxiv.org/pdf/2302.03244.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2302.03244.pdf</a>. I already got some basic implementation, but I don't know how to continue implementing the forward part.
I'm not 100% sure if the implementation I already did is correct in any way, but I do hope so. If you do see any errors or have any suggestions, in which way I should continue with my implementation, I'd be thankful for every help.</p>
<p>Thank you all in advance.</p>
<p>Here is the code I already implemented:</p>
<pre><code>import torch
import torch.nn as nn
import numpy as np
import pennylane as qml

class QRNN(nn.module):

    def __init__(
        self,
        input_size,
        hidden_size,
        n_qubits = 5,
        n_qlayers = 1,
        batch_first=True,
        backend = &quot;default.qubit&quot;
    ):
        
        super(QRNN, self).__init__()
        self.n_inputs = input_size
        self.hidden_size = hidden_size
        self.concat_size = self.n_inputs + self.hidden_size
        self.n_qubits = n_qubits
        self.n_qlayers = n_qlayers
        self.backend = backend

        self.wires = [f&quot;wire_{i}&quot; for i in range(self.n_qubits)]
        self.dev = qml.device(self.backend, wires = self.wires)

        def _layer_qrnn_block(W):
            def layer(W):

                qml.RX(W[0,0], wires = 0)
                qml.RZ(W[0,1], wires = 0)
                qml.RX(W[0,2], wires = 0)

                qml.RX(W[1,0], wires = 1)
                qml.RZ(W[1,1], wires = 1)
                qml.RX(W[1,2], wires = 1)

                qml.RX(W[2,0], wires = 2)
                qml.RZ(W[2,1], wires = 2)
                qml.RX(W[2,2], wires = 2)

                qml.RX(W[3,0], wires = 3)
                qml.RZ(W[3,1], wires = 3)
                qml.RX(W[3,2], wires = 3)

                qml.RX(W[4,0], wires = 4)
                qml.RZ(W[4,1], wires = 4)
                qml.RX(W[4,2], wires = 4)

                qml.RX(W[5,0], wires = 5)
                qml.RZ(W[5,1], wires = 5)
                qml.RX(W[5,2], wires = 5)

                qml.CNOT(wires = [0,1])
                qml.RZ(W[1,0], wires = 1)
                qml.CNOT(wires = [0,1])

                qml.CNOT(wires = [1,2])
                qml.RZ(W[2,0], wires = 2)
                qml.CNOT(wires = [1,2])

                qml.CNOT(wires = [2,3])
                qml.RZ(W[3,0], wires = 3)
                qml.CNOT(wires = [2,3])

                qml.CNOT(wires = [3,4])
                qml.RZ(W[4,0], wires = 4)
                qml.CNOT(wires = [3,4])

                qml.CNOT(wires = [4,5])
                qml.RZ(W[5,0], wires = 5)
                qml.CNOT(wires = [4,5])

                qml.CNOT(wires = [5,0])
                qml.RZ(W[0,0], wires = 0)
                qml.CNOT(wires = [5,0])

        def _circuit_qrnn_block(inputs, weights):
            qml.AngleEmbedding(inputs, self.wires)

            for W in weights:
                _layer_qrnn_block(W)

            return [qml.expval(qml.PauliZ(wires = w)) for w in self.wires]
        
        self.qlayer_circuit = qml.QNode(_circuit_qrnn_block, self.dev, interface = &quot;torch&quot;)

        weights_shapes = {&quot;weights&quot;: (n_qlayers, n_qubits)}
        print(f&quot;weight_shapes = (n_qlayers, n_qubits) = ({n_qlayers}, {n_qubits})&quot;)

        self.clayer_in = torch.nn.Linear(self.concat_size, n_qubits)
        self.VQC = {
            'circuit': qml.qnn.TorchLayer(self.qlayer_circuit, weights_shapes)
        }
        self.clayer_out = torch.nn.Linear(self.n_qubits, self.hidden_size)

    def forward(self, x):
</code></pre>
",<programming><quantum-algorithms><pennylane>,12/04/2023 15:10,35620.0,35620.0,"<p>Your implementation of a Quantum Recurrent Neural Network (QRNN) using PyTorch and PennyLane is a good start but needs some adjustments and completion. Let's go through the code to identify areas for improvement and complete the <code>forward</code> method:</p>
<ol>
<li><p>Class Inheritance:</p>
<ul>
<li>The class <code>QRNN</code> should inherit from <code>nn.Module</code>, not <code>nn.module</code>. Python is case-sensitive, so this needs to be corrected.</li>
</ul>
</li>
<li><p>Quantum Circuit Definition:</p>
<ul>
<li>The definition of the quantum circuit inside <code>_layer_qrnn_block</code> seems hardcoded for a specific number of qubits. This could be made more flexible to work with any number of qubits by iterating over them.</li>
<li>The use of the CNOT gates to create entanglement is a good approach, but the hardcoded indices might lead to issues if the number of qubits (<code>n_qubits</code>) is changed. A more dynamic approach would be beneficial.</li>
</ul>
</li>
<li><p>Weight Shape</p>
<ul>
<li>The <code>weights_shapes</code> definition is somewhat unclear. It is currently defined as <code>{&quot;weights&quot;: (n_qlayers, n_qubits)}</code>. However, this might not correctly represent the weight matrix needed for your quantum layers. Each layer typically needs a weight matrix of shape <code>(n_qubits, 3)</code> for the RX and RZ rotations.</li>
</ul>
</li>
<li><p>Quantum Layer:</p>
<ul>
<li>The quantum layer (<code>self.VQC['circuit']</code>) is defined correctly as a <code>qml.qnn.TorchLayer</code>. This allows it to be integrated into the PyTorch model seamlessly.</li>
</ul>
</li>
<li><p>Forward Method:</p>
<ul>
<li>The <code>forward</code> method is incomplete. It should take an input <code>x</code> and a hidden state <code>h</code> (initially set to zeros or some initial value), concatenate them, and then pass through the classical layer, quantum layer, and another classical layer to produce the output and the new hidden state.</li>
</ul>
</li>
</ol>
<p>Here's a completion and correction of your <code>forward</code> method:</p>
<p>def forward(self, x, h=None):
# Initialize hidden state if not provided
if h is None:
h = torch.zeros(self.hidden_size)</p>
<pre><code># Concatenate input and hidden state
combined = torch.cat((x, h), dim=1)

# Pass through the classical layer
combined = self.clayer_in(combined)

# Apply the quantum circuit layer
q_out = self.VQC['circuit'](combined)

# Output layer
out = self.clayer_out(q_out)

# Update the hidden state
new_h = out

return out, new_h
</code></pre>
<p>In this <code>forward</code> method, we assume that the input <code>x</code> and the hidden state <code>h</code> are compatible with the dimensions expected by <code>self.clayer_in</code>. The method processes the input and hidden state through the QRNN layer and returns the output and the updated hidden state.</p>
<p>Remember, the QRNN model's efficacy depends on the specific task and data it's being applied to, so you may need to adjust the architecture and parameters according to your specific use case.</p>
",1/27/2024 10:02,Conceptual,"The question involves implementing a quantum recurrent neural network (QRNN) based on a paper's architecture, which requires a conceptual understanding of both quantum computing and neural networks. The focus is on understanding the architecture and how to proceed with the implementation, rather than debugging or technical details, placing it in the Conceptual category.",Conceptual,,,,Conceptual,
35250.0,Decoding algorithms for qLDPC codes,"<p>Is there any open source decoding algorithm implementation for qLDPC codes under circuit-based noise model?</p>
<p>From the paper <a href=""https://arxiv.org/abs/2308.07915"" rel=""nofollow noreferrer"">arXiv:2308.07915</a>, I know that it is possible to adapt BP-OSD to circuit-based noise model, but I am struggling to follow the reasoning in that paper and finding any similar open source implementation.</p>
",<programming><error-correction><resource-request>,12/19/2023 13:39,35256.0,35256.0,"<p>The new version of the LDPC package that is currently under development, in the LDPC_V2 branch on LDPC's github repo, contains a Sinter BPOSD decoder.</p>
<p>This file contains an example of how to use it:
<a href=""https://github.com/quantumgizmos/ldpc/blob/ldpc_v2/examples/sinter_example.py"" rel=""nofollow noreferrer"">https://github.com/quantumgizmos/ldpc/blob/ldpc_v2/examples/sinter_example.py</a></p>
<p>Let me know if you have more questions.</p>
",12/20/2023 11:50,API Usage,"The question seeks information about open-source implementations of decoding algorithms for quantum LDPC codes under a circuit-based noise model. This involves understanding and utilizing existing APIs or libraries for quantum error correction, placing it in the API Usage category.", Tooling,"The question pertains to finding an open-source implementation of a decoding algorithm for qLDPC codes under a circuit-based noise model, which falls under the category of tools and software usage in quantum programming.",No,141.0,Tooling,The user is specifically asking for open-source implementations of decoding algorithms for quantum LDPC codes under a circuit-based noise model. This falls under the category of tooling as it involves finding and utilizing specific software tools or libraries for quantum error correction in a circuit-based noise model.
35457.0,How is controlled constant addition implemented for binary polynomials?,"<p>So, currently I am going through the paper <a href=""https://tches.iacr.org/index.php/TCHES/article/view/8741"" rel=""nofollow noreferrer"">Concrete Quantum Cryptanalysis of Binary Elliptic Curves</a>. The section on point addition mentions that for adding two points <span class=""math-container"">$P_1$</span> and <span class=""math-container"">$P_2$</span>, they assume that <span class=""math-container"">$P_2$</span> is a fixed (non-quantum) point. Moreover, they assume a generic case where <span class=""math-container"">$P_1 \ne P_2 \ne O$</span>, <span class=""math-container"">$P_1 \ne -P_2$</span>. On studying another <a href=""http://arxiv.org/abs/quant-ph/0407095v1"" rel=""nofollow noreferrer"">paper</a>, I found that these are mostly valid assumptions to make.</p>
<p><a href=""https://i.stack.imgur.com/ud42I.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ud42I.png"" alt=""Implementing Point Addition"" /></a></p>
<p>My issue is with the <code>const_ADD</code> function they mention. I can see that the function basically adds a quantum and a fixed (non-quantum) polynomial, but there are no implementation details for it.</p>
<p>In addition, while performing the <code>ctrl_const_ADD</code> on line <span class=""math-container"">$(2)$</span>, they multiply a qubit <span class=""math-container"">$q$</span> with a fixed polynomial <span class=""math-container"">$y_2$</span>. There are no hints given as to how that can be implemented either.</p>
<p>If anyone has an idea of how to implement these in practice, please do guide me. Thanks!</p>
",<programming><quantum-algorithms><cryptography>,01/12/2024 06:56,35459.0,35459.0,"<p>This kind of thing would typically falls under the &quot;we know we can do it, but we won't go into the actual implementation&quot; practice. Adding a known, constant polynomial to another one is something that can be described classically. Once that's done, we convert this procedure into a quantum circuit and voilÃ .</p>
<p>Expliciting the implementation requires to describe the way our data is encoded, the algorithm we use, etc...</p>
<p>Fortunately here, if I'm not mistaken, <code>const_ADD</code> is quite a simple operation. A binary polynomial is represented as a bitstring, and an addition between two of these polynomials is simply an XOR between their respective bitstrings. Thus, implementing <code>const_ADD(x, x_2)</code> is simply done by applying <span class=""math-container"">$X$</span> gates on qubit number <span class=""math-container"">$i$</span> if the corresponding bit in <span class=""math-container"">$x_2$</span>'s bitstring is set.</p>
<p>The multiplication would be a bit more involved, since there are (IIRC) more efficient algorithms to do so than the naive method. However, you could still do just like for the addition: translate this to an operation on the bitstrings and apply the corresponding gates.</p>
",01/12/2024 08:54,Conceptual,"The question involves understanding the implementation details of cryptographic operations described in a research paper, particularly focusing on the practical implementation of point addition and multiplication operations in quantum cryptography. This falls under the Conceptual category as it pertains to understanding the underlying concepts and implementations rather than specific tools or errors.",Conceptual,,,,Conceptual,
35470.0,How to avoid azure-quantum ionq simulator computing a probability distribution of exponential size?,"<p>I am running a 3-qubit simulation using <code>ionq.simulator</code> in azure-quantum. When I send the task, I get the result from one shot + probability distribution that includes all the possible 8 bitstrings. I am not interested in getting a probability distribution, just the result from 1 shot. This is a big problem when I try to do 29-qubit simulation, because I cannot even retrieve the results from Azure; the results are 12GB!</p>
<p>Here is the 3 qubit example:</p>
<pre class=""lang-python prettyprint-override""><code>from azure.quantum.qiskit import AzureQuantumProvider
from azure.quantum import Workspace
from qiskit import QuantumCircuit

workspace = Workspace(resource_id = &quot;&quot;, location = &quot;&quot;)
provider = AzureQuantumProvider(workspace)

circuit = QuantumCircuit(3, 3)
circuit.name = &quot;Qiskit Sample - 3-qubit GHZ circuit&quot;
circuit.h(0)
circuit.cx(0, 1)
circuit.cx(1, 2)
circuit.measure([0, 1, 2], [0, 1, 2])

device = provider.get_backend(&quot;ionq.simulator&quot;)
job = device.run(circuit, shots=1)
res = job.result()
</code></pre>
<p>The results are:</p>
<pre class=""lang-python prettyprint-override""><code>Result(backend_name='ionq.simulator', backend_version='1', qobj_id='Qiskit Sample - 3-qubit GHZ circuit', job_id='...', success=True, results=[ExperimentResult(shots=1, success=True, meas_level=2, data=ExperimentResultData(counts={'000': 1}, probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5})), header=QobjExperimentHeader(qiskit='True', name='Qiskit Sample - 3-qubit GHZ circuit', num_qubits='3', metadata={}, meas_map='[0, 1, 2]'))], date=None, status=None, header=None, error_data=None)
</code></pre>
<p>The troublesome element for me is <code>probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5})</code> since it grows exponentially with system size for an arbitrary circuit.</p>
<p>Then, my question is, how do I avoid Azure computing the probability distribution? Which includes <span class=""math-container"">$2^n$</span> elements, with <span class=""math-container"">$n$</span> being the number of qubits.</p>
",<programming><azure-quantum><ionq>,1/13/2024 0:25,35540.0,35540.0,"<p>This is currently unsupported scenario in Azure Quantum. Right now, you always get the complete job results back, which include the probability distribution.</p>
<p>(I forwarded your question to the dev team, I think it's an interesting use case to consider.)</p>
",1/19/2024 20:28,Tooling,"The question pertains to the usage of a specific quantum computing tool, Azure Quantum, and involves how to configure the tool to retrieve only the result from a single shot of a quantum simulation, rather than the entire probability distribution, which is a tool-related issue.",Tooling,,,,Tooling,
35624.0,Implementing error correction (from physical qubit point of view),"<p>I have worked with physical qubits, and I am fairly familiar with gates and sequences from initialisation to readout. I don't know much about error correction, and I love to learn how error correction codes are implemented on real hardware. I have seen in different posts or blogs that people use quantum circuits (or probably other methods which I am not aware of) to show error correction. I am wondering if there is any (python) library or other forms of references that showed how to implement it on real hardware, using gates and sequences.</p>
<p>I know that error correcting codes require logical qubits, but I don't know how few physical qubits form a logical qubit in experiment (I guess this part of my question is highly platform dependant). I don't know if there is any free resources that help me to have a better understanding on this.</p>
<p>If there is any paper that did a good job in implementing error correction step by step, I'd be thankful if you share it here.</p>
",<quantum-gate><programming><error-correction><resource-request><logical-gates>,1/27/2024 18:50,35626.0,35626.0,"<p>Youâre right that you need logical qubits, and theyâre structured according to a topological object known as a surface code. There are many papers by Dr. Austin Fowler covering this topic, and hereâs one example: <a href=""https://arxiv.org/pdf/1202.6111.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1202.6111.pdf</a></p>
<p>Essentially, any qubit error is an X or Z error, and their respective matrices anticommute, which leads to the alternating structure of the surface code (comprising X and Z stabilizer circuits)</p>
<p>The Stim package by Craig Gidney implements tools for building quantum error correction circuits as well.</p>
",1/28/2024 9:24,Learning,"The question is seeking learning resources and references, specifically for understanding and implementing quantum error correction codes on real hardware, as well as looking for comprehensive educational materials like papers or libraries to enhance their knowledge on the topic.",Learning,,,,Learning,
35765.0,Efficient expectation value of a local operator,"<p>I want to numerically compute something of the form
<span class=""math-container"">$x=\langle\psi| A\otimes I |\psi\rangle$</span> where <span class=""math-container"">$I$</span> is the identity.</p>
<p>Of course I can construct <span class=""math-container"">$A\otimes I$</span> and take the inner product, but I would like to save memory and compute <span class=""math-container"">$x$</span> without having to construct this large operator.</p>
<p>What would be an efficient way to compute <span class=""math-container"">$x$</span> using simple <code>numpy</code> operations (<code>reshape</code>, <code>einsum</code>, <code>trace</code> etc) and without constructing the whole <span class=""math-container"">$ A\otimes I$</span> operator?</p>
",<programming>,02/08/2024 20:25,35767.0,35767.0,"<p>I don't know if it's the fastest, but you can use the following subroutine for applying an operation to a subsystem of your state. This code will take an operation that's the correct shape for acting on a subsystem of <span class=""math-container"">$|\psi\rangle$</span> and apply it to that subsystem without having to tensor up to the size of the state space that <span class=""math-container"">$|\psi\rangle$</span> lives in:</p>
<pre class=""lang-python prettyprint-override""><code>def mul_on_subsystem(op, state, target_subsystem):
    # `state` has a tensor shape, e.g. (dim_A, dim_B, dim_C)

    # make sure `op` is correctly shaped to be applied to the target subsystem!
    target_dim = state.shape[target_subsystem]
    assert op.shape == (target_dim, target_dim)

    # (1) tensordot op onto the target axis of the state
    # this applies axis 1 of `op` to the target axis of `state`
    out = np.tensordot(op, state, axes=([1], [target_subsystem])) 

    # (2) rearrange the axes that get scrambled by tensordot
    out = np.moveaxis(out, 0, target_subsystem)
    return out
</code></pre>
<p>Once you've applied <span class=""math-container"">$A$</span> to <span class=""math-container"">$|\psi\rangle$</span> in the way you like, you can compute the inner product in the obvious way,</p>
<pre class=""lang-python prettyprint-override""><code>np.dot(state.conj().flatten(), mul_on_subsystem(local_operation, state, target_subsystem).flatten())
</code></pre>
<p>This technique also generalizes nicely to density operators, albeit with some very annoying shuffling of axes.</p>
<hr />
<h3>Timing/validation/sample code:</h3>
<pre class=""lang-python prettyprint-override""><code># declare your subsystem sizes; these are &quot;2&quot; if its qubits...
dim_a = 25 # axis 0
dim_b = 25 # axis 1
dim_c = 35 # axis 2

# reshape your state to get it into tensor form (dim_a, dim_b, dim_c)
state = np.random.rand(dim_a, dim_b, dim_c)
state = state / np.linalg.norm(state)

operation_A = np.random.rand(dim_a, dim_a)
operation_B = np.random.rand(dim_b, dim_b)
operation_C = np.random.rand(dim_c, dim_c)

# being generous and not including the time to construct the tensored operation
AII = np.kron(operation_A, np.kron(np.eye(dim_b), np.eye(dim_c)))
IBI = np.kron(np.eye(dim_a), np.kron(operation_B, np.eye(dim_c)))
IIC = np.kron(np.eye(dim_a), np.kron(np.eye(dim_b), operation_C))

for i in range(3):
    # using mul_on_subsystem
    local_operation = [operation_A, operation_B, operation_C][i]
    t0 = time.time()
    fast = mul_on_subsystem(local_operation, state, i)
    time_fast = time.time() - t0

    # using tensored-up matrices
    tensored_operation = [AII, IBI, IIC][i]
    t0 = time.time()
    slow = np.dot(tensored_operation, state.flatten())
    time_slow = time.time() - t0

    system = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;][i]
    print(f&quot;system {system} fast: {time_fast:.5f} s, slow: {time_slow:.5f} s&quot;)
    np.testing.assert_allclose(fast.flatten(), slow)
</code></pre>
<p>Output on my laptop</p>
<pre class=""lang-python prettyprint-override""><code>system A fast: 0.02700 s, slow: 0.47000 s
system B fast: 0.00100 s, slow: 0.21201 s
system C fast: 0.00000 s, slow: 0.32400 s
</code></pre>
",02/08/2024 21:15, Theoretical,"The question is focused on a theoretical concept in quantum computing, specifically the efficient computation of an inner product involving a tensor product without constructing the large operator, and it involves the use of mathematical operations and numpy for an efficient solution.", Theoretical,,,, Theoretical,
35768.0,How to compare the output of statevector_simulator and qasm_simulator in Qiskit,"<p>I am stuck with a very difficult problem.
Suppose, I execute a circuit on <code>statevector_simulator</code>, and I get all the values negative. Suppose, now i execute the same circuit on <code>qasm_simulator</code>. I will surely get positive coefficients, because here I will do the square root of the probabilities and probabilities are always positive.
Now how should I check the equivalence or correctness?</p>
<p><strong>Edit</strong>
To make my question more clear, am running a small two qubit circuit using qasm simulator and statevector simulator. You will see that results are different and I am not sure how to compare their results.</p>
<p><strong>Qasm_Simulator</strong></p>
<pre><code> from qiskit import QuantumCircuit, execute
    from qiskit import IBMQ
    from qiskit import Aer
    
    import numpy as np
    import matplotlib.pyplot as plt
    
    IBMQ.load_account()
    
    simulator_used = 'qasm_simulator'
    
    circuit = QuantumCircuit(2,2) 
    data = np.array([-0.5, -0.2, -0.2, -0.6])
    norm_data = np.linalg.norm(data)
    normalized_data = data/ norm_data
    circuit.initialize(normalized_data, [0,1])
    circuit.h(0)
    
    circuit.cx(0,1)
    circuit.x(0)
    circuit.rx(-np.pi/10, 0)
    circuit.ry(-np.pi/20, 1)
    
    
    circuit.measure([0,1],[0,1])
    
    print(circuit)
    
    simulator = Aer.get_backend(simulator_used)
    
    job = execute(circuit, simulator, shots=10000)
    
    result = job.result()

counts = result.get_counts(circuit)

final_result = []

for key in counts:
    final_result.append(np.sqrt(counts[key]/10000))

print(final_result)
</code></pre>
<p>The result is:</p>
<pre><code>  IBMQ.load_account()
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ         âââââ    ââââââââââââââââ
q_0: â¤0                                                 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) ââ¤Mâ
     â  Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´ââââââââââ¬ââ¬âââââââ¥â
q_1: â¤1                                                 âââââââ¤ X ââ¤ Ry(-Ï/20) âââââââ¤Mââââââââ«â
     ââââââââââââââââââââââââââââââââââââââââââââââââââââ     ââââââââââââââââââ     ââ¥â      â 
c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©ââââââââ©â
                                                                                      1       0 
    [0.6433506042586733, 0.6260990336999411, 0.30016662039607267, 0.322490309931942]
</code></pre>
<p><strong>Statevector_Simulator</strong></p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.compiler import transpile
from qiskit import IBMQ
from qiskit import Aer

import numpy as np

import matplotlib.pyplot as plt


IBMQ.load_account()

simulator_used = &quot;statevector_simulator&quot;
circuit = QuantumCircuit(2,2) 
data = np.array([-0.5, -0.2, -0.2, -0.6])
norm_data = np.linalg.norm(data)
normalized_data = data/ norm_data

circuit.initialize(normalized_data, [0,1])

circuit.h(0)

circuit.cx(0,1)
circuit.x(0)

circuit.rx(-np.pi/10, 0)
circuit.ry(-np.pi/20, 1)
print(circuit)

simulator = Aer.get_backend(simulator_used)

result = simulator.run(transpile(circuit, simulator)).result()

output_complex = result.get_statevector(circuit)
output_real = np.array(np.real(output_complex))

print(&quot;The output real =&quot;, output_real)
</code></pre>
<p>The result is:</p>
<pre><code>IBMQ.load_account()
     âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ         âââââ    âââââââââââââ
q_0: â¤0                                                 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) â
     â  Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´âââââââââââââââââ
q_1: â¤1                                                 âââââââ¤ X ââ¤ Ry(-Ï/20) ââââââââââââââ
     ââââââââââââââââââââââââââââââââââââââââââââââââââââ     ââââââââââââââââââ             
c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ
 
The output real = [ 0.31548377 -0.63950225 -0.27784191 -0.62437088]
</code></pre>
<p>It would be great if someone can help me in resolving my problem.</p>
",<qiskit><programming><quantum-state>,02/08/2024 23:25,35895.0,35895.0,"<p>Your problem is the line</p>
<pre><code>output_real = np.array(np.real(output_complex))
</code></pre>
<p>You should not be looking at <code>output_real</code>. In order to compare the results of these two simulations, you should instead be looking at the norm of the complex entries of <code>output_complex</code>. You will see that these norms are very close to the values in <code>final_result</code> (the values won't be exactly equal because of randomness in the simulation).</p>
<p>Also be careful about the order of the entries in <code>final_result</code>. They should be ordered according to <code>'00'</code>, <code>'01'</code>, <code>'10'</code>, <code>'11'</code>, but <code>counts</code> is not always returned in that order.</p>
<p>Here is a slim version of your code which gives the expected result</p>
<pre><code>from qiskit import QuantumCircuit, execute
from qiskit import Aer
from numpy import pi, array, sqrt
from numpy.linalg import norm

data = array([-0.5, -0.2, -0.2, -0.6])
norm_data = norm(data)
normalized_data = data / norm_data

qasm_sim = Aer.get_backend('qasm_simulator')
statevector_sim = Aer.get_backend('statevector_simulator')

def create_qc():
    qc = QuantumCircuit(2) 
    qc.initialize(normalized_data, [0,1])
    qc.h(0)
    qc.cx(0,1)
    qc.x(0)
    qc.rx(-pi/10, 0)
    qc.ry(-pi/20, 1)
    return qc

# qasm simulator
qc = create_qc()
qc.measure_all()

result = execute(qc, qasm_sim, shots=10000).result()
counts = result.get_counts()

print('qasm simulator:',
    [
        sqrt(counts['00'] / 10000),
        sqrt(counts['01'] / 10000),
        sqrt(counts['10'] / 10000),
        sqrt(counts['11'] / 10000)
    ]
)

# statevector simulator
qc = create_qc()

result = execute(qc, statevector_sim).result()
v = result.get_statevector()

print('statevector simulator',
 [
     norm(v[0]),
     norm(v[1]),
     norm(v[2]),
     norm(v[3])
 ]
)
</code></pre>
<p>A sample output is</p>
<pre><code>qasm simulator: [0.3377869150810907, 0.6431174076325411, 0.29274562336608895, 0.6217716622683925]
statevector simulator [0.33134439021006384, 0.6414514034928228, 0.29491606277662025, 0.6259197296377109]
</code></pre>
",2/21/2024 8:18,Theoretical,"The question involves comparing results from different quantum simulators and understanding the mathematical equivalence of outcomes, which involves theoretical knowledge of quantum mechanics and probability, as well as an understanding of the underlying principles of quantum computing.",Errors," The question revolves around a discrepancy in simulation results obtained from different simulators (statevector_simulator and qasm_simulator), indicating potential errors or inconsistencies in the simulation process or circuit implementation.",No,142.0,Errors,"The user is encountering a discrepancy in simulation results obtained from different quantum simulators (statevector_simulator and qasm_simulator), indicating potential errors or inconsistencies in the simulation process or circuit implementation. This falls under the Errors category as it involves troubleshooting and resolving issues related to the simulation or implementation of quantum circuits."
35821.0,I would like to understand the meaning of applying permutation to a unitary matrix,"<p><span class=""math-container"">$$U = \frac{1}{2}
 \begin{pmatrix}
  -1 &amp; -1 &amp; 1 &amp; 1 \\\\
  1 &amp; -1 &amp; 1 &amp; -1 \\\\
  1 &amp; -1 &amp; -1 &amp; 1 \\\\
  1 &amp; -1 &amp; 1 &amp; 1
 \end{pmatrix}$$</span></p>
<p><span class=""math-container"">$$P = \frac{1}{2}
 \begin{pmatrix}
  1 &amp; -1 &amp; -1 &amp; 1 \\\\
  1 &amp; -1 &amp; 1 &amp; -1 \\\\
  -1 &amp; -1 &amp; 1 &amp; 1 \\\\
  1 &amp; -1 &amp; 1 &amp; 1
 \end{pmatrix}$$</span></p>
<p>P matrix is a matrix obtained by swapping the 1st and 3rd columns of the U matrix.</p>
<p>Subsequently, I used Qiskit to apply U and P to a quantum circuit and observed the state vector.</p>
<pre class=""lang-python prettyprint-override""><code>%matploblib inline
import numpy as np
from qiskit import QuantumCircuit
from qiskit.extensions import *
from qiskit.quantum_info import Statevector

U = (1/*2) * np.array([
    [-1, -1, 1, 1],
    [1, -1, 1, -1],
    [1, -1, -1, 1],
    [1, -1, 1, 1]])
P = (1/*2) * np.array([
    [1, -1, -1, 1],
    [1, -1, 1, -1],
    [-1, -1, 1, 1],
    [1, -1, 1, 1]])

gate = UnitaryGate(U)

circuit = QuantumCircuit(2, 2)
circuit.append(gate, [0, 1])

ket = Statevector(circuit)
ket.draw('latex')
</code></pre>
<p>This is the resulting state vector obtained by applying U and P, while varying the initial state.
<a href=""https://i.stack.imgur.com/i3x81.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/i3x81.png"" alt=""enter image description here"" /></a></p>
<p>As can be seen in the table above, the state vectors of U and P swap with each other when the initial vectors are |00&gt; and |10&gt;. However, I have realized that this is related to swapping the 1st and 3rd columns of U to create P, but I am not currently able to provide an accurate explanation for the reasons and interpretation of the results.</p>
",<qiskit><quantum-gate><quantum-state><programming><unitarity>,2/14/2024 8:14,35822.0,35822.0,"<p>You have to review the definition of the matrix representation of an operator in a given basis:
If the matrix <span class=""math-container"">$U$</span> is the representation of some operator <span class=""math-container"">$u$</span> in the basis <span class=""math-container"">$\{|00\rangle,|01\rangle,|10\rangle,|11\rangle\}$</span>, it means that the first column of <span class=""math-container"">$U$</span> contains the coordinates of <span class=""math-container"">$u(|00\rangle)$</span> in that basis, the second column is <span class=""math-container"">$u(|01\rangle)$</span> and so on:</p>
<p><span class=""math-container"">$\begin{array}{cc}
    \begin{array}{cccc}\phantom{2} \text{$ \tiny   u(|00\rangle)$} &amp; \text{$\tiny u(|01\rangle)$} &amp; \text{$\tiny u(|10\rangle)$} &amp; \text{$ \tiny u(|11\rangle)$} \\
   \end{array}
   &amp;\\
\frac{1}{2}\begin{bmatrix}
\phantom{2}-1\phantom{2} &amp; \phantom{}-1\phantom{}&amp; \phantom{2}1\phantom{2}&amp;\phantom{2}1\phantom{2}\\
1 &amp; -1 &amp; 1&amp; -1\\
1 &amp; -1&amp; -1&amp;1\\
1 &amp; -1 &amp; 1&amp; 1\\
\end{bmatrix}%
%
&amp;\begin{array}{l}
          \left.\vphantom{\begin{bmatrix} 0\\
\end{bmatrix}}\right. \text{$\tiny |00\rangle$}\\ 
\left.\vphantom{\begin{bmatrix} 0\\
\end{bmatrix}}\right. \text{$\tiny |01\rangle$}\\ 
\left.\vphantom{\begin{bmatrix} 0\\
        \end{bmatrix}}\right. \text{$\tiny |10\rangle$}\\
        \left.\vphantom{\begin{bmatrix} 0\\
        \end{bmatrix}}\right. \text{$\tiny |11\rangle$}\\
        \end{array}   \\
\end{array}$</span></p>
<p>So if you swap the 1st and 3rd columns, you swap <span class=""math-container"">$u(|00\rangle)$</span> and <span class=""math-container"">$u(|10\rangle)$</span>, the others are left untouched.</p>
<p>(I used your operator <span class=""math-container"">$U$</span> in my answer but you should be aware it is not unitary)</p>
",2/14/2024 11:14,Theoretical,"The question involves analyzing the effects of applying unitary matrices on quantum states and interpreting the resulting state vectors, which requires an understanding of quantum mechanics, linear algebra, and the principles of quantum computing.",Theoretical,,,,Theoretical,
35930.0,Microsoft Classic QDK simulator,"<p>Is it possible to change the simulator used by the Classic QDK with Python simulation ?
It's reported that Classic QDK supports several simulators (sparse, full-state...). Which one is used when called from Python environment, and is it possible to change it?</p>
<p>I have a simulation which doesn't run because of large number of qubits instantiated (from 25 up to 61). The simulation with C# .NET runs perfectly. But when I use a Python host program, the simulation is simply blocked at qubit instantiation.</p>
<p>So I suppose that C# .NET host uses sparse simulator, while Python uses full-state.</p>
",<programming><simulation><q#>,2/23/2024 15:16,35932.0,35932.0,"<p>There are no default simulators chosen either in .NET or in Python, you always specify them explicitly.</p>
<p>In C#, you use different classes for different simulators: <code>QuantumSimulator</code> for full state simulator, <code>SparseSimulator</code> for sparse simulator.</p>
<p>In Python, you switch the command you use to run Q# operation to use different simulators: <code>.simulate()</code> uses full state simulator, and <code>.simulate_sparse()</code> uses sparse simulator.</p>
",2/23/2024 16:45,Tooling," The question is specifically about using and configuring different simulators (tools) within the Quantum Development Kit (QDK) from different programming environments, which falls under the category of software usage and configuration in quantum programming.",Tooling,,,,Tooling,
37083.0,How should large quantum computers use Clifford simulators like Stim?,"<p>High-level architecture question:</p>
<p>When we have the ability to do useful quantum computations with plenty of qubits, error correction and fault tolerance, do Clifford simulators still have a role to play? Can a quantum computer still delegate Clifford gate computations to a classical device and only perform those gates that cannot be efficiently classically simulated?</p>
<p>Or are these simulators just a way for us to test error correction and other Clifford-only operations and would not help reduce the resource requirements for an actual quantum computation?</p>
",<stim><clifford-group><classical-computing>,03/04/2024 20:25,37085.0,37085.0,"<p>There are potential uses for Clifford simulation even with a large scale quantum computer available. To help it run more smoothly.</p>
<p>For example, in <a href=""https://arxiv.org/abs/1808.02892"" rel=""nofollow noreferrer"">Daniel Litinsky's &quot;game of surface codes&quot; paper</a>, the quantum computer doesn't do the Clifford gates. Instead, the classical computer tracks a Clifford frame and rewrites T gates and measurement gates to apply to large Pauli products determined by the Cliffords. The Clifford tracking is essentially identical to stabilizer simulation.</p>
<p>Backdated Pauli corrections <a href=""https://arxiv.org/abs/1905.08916"" rel=""nofollow noreferrer"">for delayed choice gates</a> are also applied in the present by using stabilizer simulation to advance them through the intervening Clifford gates. This is core to AutoMagic states decoupling where the correction occurs from where the non-Clifford gate is applied.</p>
<p>Just understanding how errors flow through the circuit requires a bit of stabilizer simulation (though with only one Pauli string instead of many).</p>
",03/05/2024 00:32,Conceptual,"The question explores the role and future relevance of Clifford simulators in the context of advanced quantum computing with error correction and fault tolerance, addressing underlying concepts and potential applications rather than specific tools or errors.",Conceptual,,,,Conceptual,
37220.0,IBMProvider.load_account() AttributeError: type object 'IBMProvider' has no attribute 'load_account',"<p>I am trying to resolve the below deprecation warnings I am getting while using IBMQ framework.</p>
<pre><code>DeprecationWarning: The qiskit.IBMQ entrypoint and the qiskit-ibmq-provider package (accessible from 'qiskit.providers.ibmq`) are deprecated and will be removed 
in a future release. Instead you should use the qiskit-ibm-provider package which is accessible from 'qiskit_ibm_provider'. You can install it with 'pip install qiskit_ibm_provider'. Just replace 'qiskit.IBMQ' with 'qiskit_ibm_provider.
IBMProvider'
</code></pre>
<p>My earlier code was:</p>
<pre><code>from qiskit import IBMQ
IBMQ.save_account('key', overwrite=True)
IBMQ.load_account()
</code></pre>
<p>Now, I have changed it below:</p>
<pre><code>from qiskit_ibm_provider import IBMProvider
IBMProvider.save_account('key', overwrite=True)
IBMProvider.load_account()
</code></pre>
<p>But now I am getting the error:</p>
<pre><code> IBMProvider.load_account()
AttributeError: type object 'IBMProvider' has no attribute 'load_account'.
</code></pre>
<p>It would be great if I can be helped on this.</p>
",<programming><ibm-q-experience><ibm-quantum-devices>,03/12/2024 20:33,37225.0,37225.0,"<p>According to the official documentation<sup>[<a href=""https://docs.quantum.ibm.com/api/qiskit-ibm-provider/qiskit_ibm_provider.IBMProvider"" rel=""nofollow noreferrer"">1</a>]</sup>:</p>
<blockquote>
<p>Once credentials are saved you can simply instantiate the provider like below to load the saved account and default project:</p>
</blockquote>
<pre><code>from qiskit_ibm_provider import IBMProvider
provider = IBMProvider()
</code></pre>
<p>So, there is no need to call <code>load_account()</code></p>
",3/13/2024 0:22,Errors,"The user is seeking help to resolve a specific deprecation warning and subsequent error encountered while using the IBMQ framework, which involves debugging and understanding error messages in their quantum program development.",Errors,,,,Errors,
37300.0,Qiskit code works even without measure_all() with qasm_simulator,"<p>I am need help in understanding about the <code>measure_all()</code> of the qiskit.
The below code is correct even though <code>measure_all()</code> is not being used.</p>
<pre><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)

backend = Aer.get_backend(&quot;qasm_simulator&quot;)


job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
<p>It would be great if someone can explain about the <code>measure_all()</code> concept, where to use it and where not to use it?</p>
",<qiskit><programming>,3/17/2024 7:55,37310.0,37310.0,"<p>You are noticing that measurement behavior is different in different versions of Qiskit. In <code>qiskit==0.33.1</code>, we have the following behavior:</p>
<pre class=""lang-python prettyprint-override""><code>import qiskit
print(qiskit.__qiskit_version__)
</code></pre>
<pre><code>{'qiskit-terra': '0.19.1', 'qiskit-aer': '0.9.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.2', 'qiskit-aqua': '0.9.5', 'qiskit': '0.33.1', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
<pre><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)

backend = Aer.get_backend(&quot;qasm_simulator&quot;)


job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
<pre><code>{'000': 100000}
</code></pre>
<p>But in the next update <code>qiskit==0.34.0</code> there is an error:</p>
<pre class=""lang-python prettyprint-override""><code>import qiskit
print(qiskit.__qiskit_version__)
</code></pre>
<pre><code>{'qiskit-terra': '0.19.1', 'qiskit-aer': '0.10.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.3', 'qiskit-aqua': '0.9.5', 'qiskit': '0.34.0', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
<pre><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)

backend = Aer.get_backend(&quot;qasm_simulator&quot;)


job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
<pre><code>QiskitError: 'No counts for experiment &quot;&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x1550e7790&gt;&quot;'
</code></pre>
<p>So your issue is not with the <code>measure_all()</code> concept per say, but rather you just need to keep notes of the versions in which these changes take place.</p>
<p><strong>Clarification:</strong> It should also be noted that in the <code>qiskit==0.33.1</code> case, the output <code>{'000': 100000}</code> is reflecting the fact that no measurements have been loaded in to the classical bits (so the values all remain zero). If a measurement statement is included, then this circuit will have GHZ state measurement statistics:</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)
circ.measure(range(3), range(3)) # actually measure the circuit

backend = Aer.get_backend(&quot;qasm_simulator&quot;)


job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
<pre><code>{'000': 50094, '111': 49906}
</code></pre>
",3/17/2024 19:55, Tooling,"The user is asking for an explanation of the measure_all() function in Qiskit, which pertains to the usage of a specific tool in quantum programming, and seeks guidance on when and how to properly utilize this function",Conceptual," The question seeks an explanation of the conceptual understanding behind the measure_all() function in Qiskit, its usage scenarios, and when it's unnecessary, indicating a desire to grasp high-level concepts and best practices in quantum circuit design",No,143.0,Conceptual,"The user is seeking an explanation of the conceptual understanding behind the measure_all() function in Qiskit, its usage scenarios, and when it's unnecessary. This indicates a desire to grasp high-level concepts and best practices in quantum circuit design rather than just specific tool usage."
37309.0,vqe.compute_minimum_eigenvalue API of qiskit produces different eigenstate results for statevector_simulator ands qasm_simulator,"<p>I am trying to understand the usage of <code>vqe.compute_minimum_eigenvalue</code>  API of qiskit for the statevector_simulator and qasm_simulator. I am only interested in the <code>eigenstate</code> and <code>eigenvalue</code>.
When I run the below code for <code>statevector_simulator</code>, I get the below as shown below:</p>
<pre><code>backend = Aer.get_backend(&quot;statevector_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is:</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1352,
    'eigenstate': array([0.01715463+0.42191317j, 0.02261512+0.55615892j,
       0.02288142+0.56255103j, 0.01794385+0.44109138j]),
    'eigenvalue': (1.2502114e-10+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(Î¸[3]): 1.8871963979619928,
                              ParameterVectorElement(Î¸[0]): 3.4198843373829284,
                              ParameterVectorElement(Î¸[2]): 4.2904615454665835,
                              ParameterVectorElement(Î¸[1]): 0.8448563317717608,
                              ParameterVectorElement(Î¸[4]): 3.448308970824199,
                              ParameterVectorElement(Î¸[5]): 3.5108928973122078,
                              ParameterVectorElement(Î¸[6]): 4.155936156778078,
                              ParameterVectorElement(Î¸[7]): 5.828853129364108,
                              ParameterVectorElement(Î¸[8]): 2.717512248330424,
                              ParameterVectorElement(Î¸[9]): 1.1104402869985177,
                              ParameterVectorElement(Î¸[10]): 0.35997873578438755,
                              ParameterVectorElement(Î¸[11]): 5.383757228721264,
                              ParameterVectorElement(Î¸[12]): 2.2265588674752292,
                              ParameterVectorElement(Î¸[13]): -0.524391503109095,
                              ParameterVectorElement(Î¸[14]): 2.721212459791864,
                              ParameterVectorElement(Î¸[15]): 1.584924993236795,
                              ParameterVectorElement(Î¸[16]): -0.49539861026959436,
                              ParameterVectorElement(Î¸[17]): 4.162724464416642,
                              ParameterVectorElement(Î¸[18]): 3.6325193273490144,
                              ParameterVectorElement(Î¸[19]): 6.662136048337769},
    'optimal_point': array([ 3.41988434,  0.84485633,  4.29046155,  1.8871964 ,  3.44830897,
        3.5108929 ,  4.15593616,  5.82885313,  2.71751225,  1.11044029,
        0.35997874,  5.38375723,  2.22655887, -0.5243915 ,  2.72121246,
        1.58492499, -0.49539861,  4.16272446,  3.63251933,  6.66213605]),
    'optimal_value': 1.2502114e-10,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 52.66859722137451}
</code></pre>
<p>But when I run the code for qasm_simulator, I get the results as below:</p>
<pre><code>backend = Aer.get_backend(&quot;qasm_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1000000
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1,
    'eigenstate': {   '00': 0.13272528018429647,
                      '01': 0.3030214513858714,
                      '10': 0.7196895163888384,
                      '11': 0.610417070534565},
    'eigenvalue': (5.67387294600939+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(Î¸[2]): 4.224454970398236,
                              ParameterVectorElement(Î¸[0]): 5.863937784019204,
                              ParameterVectorElement(Î¸[1]): 3.4455864378670014,
                              ParameterVectorElement(Î¸[4]): 0.506017439486799,
                              ParameterVectorElement(Î¸[3]): 2.3690675120103775,
                              ParameterVectorElement(Î¸[5]): 4.79940129981895,
                              ParameterVectorElement(Î¸[6]): 0.09967770119784523,
                              ParameterVectorElement(Î¸[7]): 1.8225430500149276,
                              ParameterVectorElement(Î¸[8]): 1.1087175676599133,
                              ParameterVectorElement(Î¸[9]): 2.650606283797435,
                              ParameterVectorElement(Î¸[10]): 1.932734623597688,
                              ParameterVectorElement(Î¸[11]): 4.6581354731326785,
                              ParameterVectorElement(Î¸[12]): 5.42013877739097,
                              ParameterVectorElement(Î¸[13]): 5.232441413652715,
                              ParameterVectorElement(Î¸[14]): 0.2577507460800755,
                              ParameterVectorElement(Î¸[15]): 3.8652580750273775,
                              ParameterVectorElement(Î¸[16]): 3.133086142322153,
                              ParameterVectorElement(Î¸[17]): 5.98592177389689,
                              ParameterVectorElement(Î¸[18]): 2.0935707919171658,
                              ParameterVectorElement(Î¸[19]): 0.40662390687216604},
    'optimal_point': array([5.86393778, 3.44558644, 4.22445497, 2.36906751, 0.50601744,
       4.7994013 , 0.0996777 , 1.82254305, 1.10871757, 2.65060628,
       1.93273462, 4.65813547, 5.42013878, 5.23244141, 0.25775075,
       3.86525808, 3.13308614, 5.98592177, 2.09357079, 0.40662391]),
    'optimal_value': 5.67387294600939,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 163.65113639831543}
</code></pre>
<p>What I understand looking at <code>statevector</code> values is that they are coefficients, but these values are not unifying (they are completely different results). I am not able to understand the reason? Is I am doing something wrong? Please guide me. Thank for great help.</p>
",<qiskit><programming><vqe>,3/17/2024 18:32,37312.0,37312.0,"<p>Using <code>statevector simulator</code> will give an ideal result for the computation of the operator expectation value. As the state (ansatz) is varied the value computed for any given point will always be the same. This is not the case with the <code>qasm simulator</code>, which samples (shots number of times) from that ideal result for the counts it gives back. The samples are random so the counts can change and this means the expectation value computed can change. You are using a large number of shots but even so, at any given point, the value will still vary. What optimizer are you using - if its a gradient based one like <code>SLSQP</code> small changes can throw it when it tries to compute a gradient at the local point where by default it uses finite difference with a small <code>eps</code> (epsilon) value where it computes the values around the point. You can try a gradient free optimizer like <code>COBYLA</code>, or <code>SPSA</code> which was designed to work in noisy conditions.</p>
",3/17/2024 21:05,Tooling,"The user is inquiring about the usage and results of the vqe.compute_minimum_eigenvalue API in Qiskit with different simulators, seeking to understand the discrepancies in the output, which pertains to the usage and functionality of a specific quantum programming tool.",Tooling,,,,Tooling,
37314.0,Using Noise Model of a real hardware on qiskit simulators,"<p>I am trying to understand how to use the noise model of real hardware. Below is the part of the code I have written with the help of sample codes from these links:</p>
<p>qiskit.github.io/qiskit-aer/apidocs/aer_noise.html</p>
<p>qiskit-community.github.io/qiskit-algorithms/tutorials/â¦</p>
<p>qiskit.github.io/qiskit-aer/tutorials/index.html</p>
<p>I have a lot of questions which I still not able to understand.
What is <code>depolarizing_error</code> ? Are we adding somekind of error to the existing errors of <code>ibm_cairo</code> ? I have added some gates to the API <code>add_all_qubit_quantum_error</code>?How can I know what all gates I have in my quantum circuit? Can I use <code>qasm_simulator</code> instead of <code>AerSimulator</code>. If possible then how?</p>
<pre><code>    prob_1 = 0.001  # 1-qubit gate
    prob_2 = 0.01   # 2-qubit gate
    
    # Depolarizing quantum errors
    error_1 = noise.depolarizing_error(prob_1, 1) # I think, one means here 1 qubit
    error_2 = noise.depolarizing_error(prob_2, 2) # I think, two means here 2 qubit
    
    # Add errors to noise model
    noise_model = noise.NoiseModel()
    
    noise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3','x','y','z','h','s','t'])  
    
    noise_model.add_all_qubit_quantum_error(error_2, ['cx','cy','cz', 'swap'])
    
    
    # Get basis gates from noise model
    basis_gates = noise_model.basis_gates
    
    # provider = IBMQ.load_account()
    provider = IBMQ.get_provider(hub=' ', group=' ', project=' ')
    backend_cairo = provider.get_backend('ibm_cairo')
    
    
    noise_model = NoiseModel.from_backend(backend_cairo)
    
    # Get coupling map from backend
    coupling_map = backend_cairo.configuration().coupling_map
    # Perform a noise simulation
    backend = AerSimulator(noise_model=noise_model,
                        coupling_map=coupling_map,
    
                        basis_gates=basis_gates)
    transpiled_circuit = transpile(qc_combine, backend)
    result = backend.run(transpiled_circuit, shots= self.shots_done).result()
</code></pre>
<p><strong>Edit</strong>
If the modify the code as below, then how backend getting the NoiseModel. Please review.</p>
<pre><code>provider = IBMQ.get_provider(hub=' ', group=' ', project=' ')
backend_cairo = provider.get_backend('ibm_cairo')
                                  
noise_model = NoiseModel.from_backend(backend_cairo)
backend = AerSimulator.from_backend(backend_cairo)
</code></pre>
",<qiskit><programming><noise>,3/17/2024 21:53,37322.0,37322.0,"<p>If all what you want is to derive a noise model from the properties of a real quantum device, then you just need to use <a href=""https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html#qiskit_aer.noise.NoiseModel.from_backend"" rel=""nofollow noreferrer""><code>NoiseModel.from_backend()</code></a> method:</p>
<pre class=""lang-python prettyprint-override""><code>noise_model = NoiseModel.from_backend(backend_cairo)
</code></pre>
<p>Methods like <code>add_all_qubit_quantum_error()</code> are needed if you want to build your own custom noise model.</p>
<p>If, however, you want your simulator to mimic the other real device properties like coupling map and basis gateset in addition to the noise model, then you can call <a href=""https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.AerSimulator.html#qiskit_aer.AerSimulator.from_backend"" rel=""nofollow noreferrer""><code>AerSimulator.from_backend()</code></a></p>
<pre class=""lang-python prettyprint-override""><code>simulator = AerSimulator.from_backend(backend)
</code></pre>
",3/18/2024 8:05,Tooling,"This code segment deals with utilizing the noise model of real quantum hardware, demonstrating the use of Qiskit Aer for noise simulation and IBM Quantum Experience for accessing real hardware. It involves the implementation of specialized software tools and frameworks (such as Qiskit) for developing and simulating quantum algorithms, falling under the category of tooling in quantum software engineering.",Tooling,,,,Tooling,
37342.0,TranspilerError: 'Number of qubits (40) in QAOA is greater than maximum (30) in the coupling_map',"<p>Hi Ive been trying to solve a custom PO problem using QAOA and I ran into this particular error. As per my understanding,this is due to the limitation of the simulation hardware. But as per the documentation the new QAOA package does not support to inject a quantum instance (<code>from qiskit_algorithms import  QAOA</code>) but the old implementation did. (<code>from qiskit.algorithms import  QAOA</code>). Given below is my code implementation. Can someone help me fix this issue.</p>
<pre><code>from qiskit_algorithms import  QAOA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_algorithms.optimizers import COBYLA
from qiskit_aer.primitives import Sampler


qp = from_docplex_mp(mdl)
print(qp.export_as_lp_string())
cobyla = COBYLA()
cobyla.set_options(maxiter=250)
qaoa_mes = QAOA(sampler=Sampler(), optimizer=cobyla, reps=1)
qaoa = MinimumEigenOptimizer(qaoa_mes)
result = qaoa.solve(qp)
</code></pre>
<p>Ive tried getting the backend using</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;TOKEN&quot;)
backend = service.least_busy(operational=True, simulator=False)
</code></pre>
<p>but there isnt a specific method to provide that to the QAOA.</p>
",<qiskit><programming><quantum-algorithms><qaoa><ibm-quantum-devices>,3/19/2024 1:31,37344.0,37344.0,"<p>The error is because the number of qubits in the hardware you are selecting, is less than what your QAOA circuit has (in this case 40). All you have to do is change the backend importing code, and assert that you want a backend with at least this many qubits. You can do this via</p>
<pre class=""lang-python prettyprint-override""><code>least_busy(min_num_qubits=None, instance=None, filters=None, **kwargs)
</code></pre>
<p>or in your code, you have to do the following:</p>
<pre class=""lang-python prettyprint-override""><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;TOKEN&quot;)
backend = service.least_busy(min_num_qubits = 40,operational=True, simulator=False)
</code></pre>
<p>For updated QAOA implementation, follow <a href=""https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm"" rel=""nofollow noreferrer"">this</a></p>
<p>The backend is assigned in the <code>sampler</code> and <code>estimator</code> using <code>options</code>, like this:</p>
<pre class=""lang-python prettyprint-override""><code># To run on local simulator:
#   1. Use the Estimator from qiskit.primitives instead.
#   2. Remove the Session context manager below.

options = Options()
options.transpilation.skip_transpilation = True
options.execution.shots = 10000

session = Session(backend=backend)

estimator = Estimator(session=session, options={&quot;shots&quot;: int(1e4)})
sampler = Sampler(session=session, options={&quot;shots&quot;: int(1e4)})
</code></pre>
<h2>Recent Implementation</h2>
<p>As per your recent comments, that error can be rectified by doing follows:</p>
<p>I'm following your code till this line:</p>
<pre class=""lang-python prettyprint-override""><code>print(qp.export_as_lp_string())
</code></pre>
<p>Selecting the backend and importing</p>
<pre class=""lang-python prettyprint-override""><code># General imports
import numpy as np
import warnings

warnings.filterwarnings(&quot;ignore&quot;)

# Pre-defined ansatz circuit, operator class and visualization tools
from qiskit.circuit.library import QAOAAnsatz
from qiskit.quantum_info import SparsePauliOp
from qiskit.visualization import plot_distribution

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, Session
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_ibm_runtime import SamplerV2 as Sampler

# SciPy minimizer routine
from scipy.optimize import minimize

# rustworkx graph library
import rustworkx as rx
from rustworkx.visualization import mpl_draw


# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(min_num_qubits=40,operational=True, simulator=False)
backend.name
</code></pre>
<p>Since you are using a QAOA function, I'll write how it is done in the updated version:</p>
<h2>Convert QUBO to a SparsePauliOp</h2>
<pre class=""lang-python prettyprint-override""><code>op,offset = qp.to_ising()
print(&quot;offset: {}&quot;.format(offset))
print(&quot;operator:&quot;)
print(op)
</code></pre>
<h2>Make a QAOA Ansatz</h2>
<pre class=""lang-python prettyprint-override""><code>from qiskit.circuit.library import QAOAAnsatz
ansatz = QAOAAnsatz(op, reps=2)

ansatz.decompose(reps=3).draw(output=&quot;mpl&quot;, style=&quot;iqp&quot;)
</code></pre>
<h2>Optimize problem for quantum execution</h2>
<pre class=""lang-python prettyprint-override""><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

ansatz_isa = pm.run(ansatz)
ansatz_isa.draw(output=&quot;mpl&quot;, idle_wires=False, style=&quot;iqp&quot;)
</code></pre>
<h2>Observables</h2>
<pre class=""lang-python prettyprint-override""><code>hamiltonian_isa = op.apply_layout(ansatz_isa.layout)
hamiltonian_isa
</code></pre>
<h2>Execute</h2>
<pre class=""lang-python prettyprint-override""><code>def cost_func(params, ansatz, hamiltonian, estimator):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters
        ansatz (QuantumCircuit): Parameterized ansatz circuit
        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian
        estimator (EstimatorV2): Estimator primitive instance

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    pub = (ansatz, [hamiltonian], [params])
    result = estimator.run(pubs=[pub]).result()
    cost = result[0].data.evs[0]

    return cost
</code></pre>
<h2>Quantum Backend</h2>
<pre class=""lang-python prettyprint-override""><code># To run on local simulator:
#   1. Use the StatevectorEstimator from qiskit.primitives instead.
#   2. Remove the Session instantiation below.
session = Session(backend=backend)

# Configure estimator
estimator = Estimator(session=session)
estimator.options.default_shots = 10_000
estimator.options.dynamical_decoupling.enable = True

# Configure sampler
sampler = Sampler(session=session)
sampler.options.default_shots = 10_000
sampler.options.dynamical_decoupling.enable = True
</code></pre>
<h2>Initial Parameters</h2>
<pre class=""lang-python prettyprint-override""><code>x0 = 2 * np.pi * np.random.rand(ansatz_isa.num_parameters)
</code></pre>
<p>and minimization</p>
<pre class=""lang-python prettyprint-override""><code>res = minimize(cost_func, x0, args=(ansatz_isa, hamiltonian_isa, estimator), method=&quot;COBYLA&quot;)
res
</code></pre>
<h2>Post Process</h2>
<pre class=""lang-python prettyprint-override""><code># Assign solution parameters to ansatz
qc = ansatz.assign_parameters(res.x)
# Add measurements to our circuit
qc.measure_all()
qc_isa = pm.run(qc)
qc_isa.draw(output=&quot;mpl&quot;, idle_wires=False, style=&quot;iqp&quot;)
</code></pre>
<pre class=""lang-python prettyprint-override""><code>result = sampler.run([qc_isa]).result()
samp_dist = result[0].data.meas.get_counts()
# Close the session since we are now done with it
session.close()
</code></pre>
<p>and if your problem instance is small, you can view it as well</p>
<pre class=""lang-python prettyprint-override""><code>plot_distribution(samp_dist, figsize=(15, 5))
</code></pre>
<h3>System Versions</h3>
<p>Python: 3.11.7
Qiskit: 1.0.2</p>
<p>and the all the other Qiskit dependencies in their latest version as of today.</p>
",3/19/2024 4:28, Tooling,"This falls under the tooling category as it involves the usage of quantum algorithms (QAOA) within the Qiskit framework to solve a combinatorial optimization problem, highlighting the utilization of specialized software tools for quantum algorithm development and optimization.", Errors," The question addresses an issue encountered while attempting to implement a custom optimization problem using QAOA in Qiskit, specifically concerning the limitation of the simulation hardware and the unavailability of certain functionalities in the new Qiskit version compared to the older one, indicating a problem-solving inquiry related to resolving errors and understanding differences in software versions.",No,144.0,Errors,"The user is encountering an error while trying to implement a custom optimization problem using QAOA in Qiskit, specifically related to the limitation of the simulation hardware and the unavailability of certain functionalities in the new Qiskit version compared to the older one. They are seeking assistance in fixing this issue, which aligns with the category of addressing errors and resolving software version differences."
37348.0,What is wrong with my quantum grover's algorithm?,"<p>I am trying to create Grover's algorithm in quantum programming with Qiskit to find the target binary string <code>010</code>.</p>
<p>This is my process :</p>
<ol>
<li><p>Apply a Hadamard gate to 4 qubits (3 for the binary string and 1 for the target qubit)</p>
</li>
<li><p>I create a circuit for the oracle. I use <span class=""math-container"">$X$</span> gates to flip the 1st and 3rd input qubits - meaning only when they are 0 will they become 1. Following this, I used a <span class=""math-container"">$CX$</span> gate with all 3 input qubits as control and the target qubit as the target. This means it should flip the target when the 3 input qubits are one, only possible if it's my target string <code>010</code></p>
</li>
<li><p>I created a grover diffusion circuit</p>
</li>
<li><p>I applied the oracle and grover diffusion iteratively creating a circuit.</p>
</li>
<li><p>I created a circuit designed to measure the first 3 qubits.</p>
</li>
<li><p>I made a graph counting the results.</p>
</li>
</ol>
<p>When I tried a similar algorithm with 2 qubits, I got <code>11</code> only in my counts graph. I haven't been able to do that with 3-qubit strings like <code>010</code>. I tried changing iterations and experimenting with how gates like the <code>cz([0,1,2])</code> are applied by making it 3 individual (<code>cz(0,2)</code>...etc). I feel like there's something wrong logically.</p>
<p>Any help is appreciated.</p>
<pre><code>qc = QuantumCircuit(4)

qc.h(range(4))

num_iterations = 16 # Set the number of iterations

# Oracle for marking |01â© state
oracle = QuantumCircuit(4)
oracle.x(0)
oracle.x(2)
oracle.cx([0,1,2],3)

oracle.x(0)
oracle.x(2)

# Grover diffusion operator
grover_diffusion = QuantumCircuit(4)
grover_diffusion.h(range(4))
grover_diffusion.z(3)
grover_diffusion.cz([0,1,2],3)
grover_diffusion.h(range(3))

# Apply the oracle and Grover diffusion iteratively
for _ in range(num_iterations):
    qc.compose(oracle, inplace=True)
    
    # Apply the Grover diffusion operator
    qc.compose(grover_diffusion, inplace=True)

    
sv_sim = Aer.get_backend('statevector_simulator')
result = sv_sim.run(qc).result()
statevec = result.get_statevector()
from qiskit.visualization import array_to_latex
array_to_latex(statevec, prefix=&quot;|\\psi\\rangle =&quot;)

#Measure circuit
measurer = QuantumCircuit(4,3)
measurer.measure([0,1,2],[0,1,2])

qc.compose(measurer, inplace=True)

# Measure the qubits
#qc.measure([0,1,2],[0,1,2])

qasm_sim = Aer.get_backend('qasm_simulator')
result = qasm_sim.run(qc).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
",<qiskit><programming><quantum-algorithms><grovers-algorithm>,3/19/2024 8:34,37363.0,37363.0,"<p>There are several mistakes in your code:</p>
<ul>
<li>You incorrectly assume that <code>qc.cx([0, 1, 2], 3)</code> is an <span class=""math-container"">$X$</span> gate on the fourth qubit controlled off the first three ones, but it's not. Instead, it's three <span class=""math-container"">$\mathsf{C}-X$</span> gates, with the fourth qubit being their target and their control qubit being one of the first three. This mistake is present in both <code>oracle</code> and <code>grover_diffusion</code>.</li>
<li>The optimal number of iterations in Grover's algorithm depends only on the number of solutions (here, 1) and the number of qubits (here, 3). The number of iterations with a single solution using <span class=""math-container"">$n$</span> qubits is given by:
<span class=""math-container"">$$N=\left\lfloor\frac{\pi}{4}\sqrt{2^n}\right\rfloor$$</span></li>
<li>You apply the diffusion operator on the fourth qubit, which is supposed to stay in the <span class=""math-container"">$|-\rangle$</span> state to use it for phase kickback.</li>
<li>The diffusion operator is supposed to be a layer of <span class=""math-container"">$H$</span> gates followed by a layer of <span class=""math-container"">$X$</span> gates, followed by a multi-controlled-<span class=""math-container"">$Z$</span>, followed by a layer of <span class=""math-container"">$X$</span> gates, followed by a layer of <span class=""math-container"">$H$</span> gates. Here, you're missing the <span class=""math-container"">$X$</span> gates layers.</li>
</ul>
<p>All in all, we end up with the following code:</p>
<pre class=""lang-python prettyprint-override""><code>from math import pi, sqrt

from qiskit import QuantumCircuit
from qiskit_aer import Aer
from qiskit.visualization import plot_histogram

qc = QuantumCircuit(4)

qc.h(range(4))
# Fourth qubit in |-&gt; state
qc.z(3)

num_iterations = int(pi * sqrt(2 ** 3) / 4) # Set the number of iterations

# Oracle for marking |01â© state
oracle = QuantumCircuit(4)
oracle.x(0)
oracle.x(2)
oracle.mcx([0,1,2], 3)

oracle.x(0)
oracle.x(2)

# Grover diffusion operator
# We still make it acting on 4 qubits so that we don't change the rest of the code, but
# we're leaving the fourth qubit alone.
grover_diffusion = QuantumCircuit(4)
grover_diffusion.h(range(3))
grover_diffusion.x(range(3))
# For some reason Aer doesn't like the ccz gate, so we build one from a ccx using the Z = HXH relation
# grover_diffusion.ccz(0, 1, 2)
grover_diffusion.h(2)
grover_diffusion.ccx(0, 1, 2)
grover_diffusion.h(2)
grover_diffusion.x(range(3))
grover_diffusion.h(range(3))

# Apply the oracle and Grover diffusion iteratively
for _ in range(num_iterations):
    qc.compose(oracle, inplace=True)
    
    # Apply the Grover diffusion operator
    qc.compose(grover_diffusion, inplace=True)

    
sv_sim = Aer.get_backend('statevector_simulator')
result = sv_sim.run(qc).result()
statevec = result.get_statevector()
from qiskit.visualization import array_to_latex
array_to_latex(statevec, prefix=&quot;|\\psi\\rangle =&quot;)

#Measure circuit
measurer = QuantumCircuit(4,3)
measurer.measure([0,1,2],[0,1,2])

qc.compose(measurer, inplace=True)

# Measure the qubits
#qc.measure([0,1,2],[0,1,2])

qasm_sim = Aer.get_backend('qasm_simulator')
result = qasm_sim.run(qc).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p>which then plots this result:
<a href=""https://i.stack.imgur.com/GvqXp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GvqXp.png"" alt=""Histogram of results clearly showing the marked state"" /></a></p>
",3/19/2024 20:09,Learning,"This falls under the learning category as the user is attempting to implement Grover's algorithm in quantum programming with Qiskit, demonstrating an active effort to acquire knowledge about quantum algorithms and quantum programming languages.",Learning,,,,Learning,
37384.0,QuTiP ptrace function results do not recreate original composite system,"<p>I have a qutip density matrix <code>fullsystem</code> for a system composed of two quantum systems with <code>dims = [[n, n], [n, n]], shape = (n**2, n**2)</code>. It's my understanding that if I wanted the density matrix of each system separately, I could do</p>
<pre class=""lang-python prettyprint-override""><code>subsystem1 = fullsystem.ptrace(0)
subsystem2 = fullsystem.ptrace(1)
</code></pre>
<p>Should I not be able to get <code>fullsystem</code> back by doing <code>tensor(subsystem1, subsystem2)</code>? This is not working for me <code>(fullsystem == tensor(subsystem1, subsystem2)</code> gives False), they are close but significantly more different than I'd expect. I have tried <code>tensor(susbsystem1.unit(), subsystem2.unit())</code> as well.</p>
<p>Am I just not understanding how I should be using <code>ptrace</code>? Are there certain assumptions about <code>fullsystem</code> that I need to take into account beyond knowing the two subsystem composition given by <code>dims</code>?</p>
",<programming><linear-algebra><qutip>,3/20/2024 22:54,37387.0,37387.0,"<p>This would only work if <code>fullsystem</code> is a product state.</p>
<p>Let <span class=""math-container"">$\rho$</span> be your full system. For example, say</p>
<p><span class=""math-container"">$$\rho = |011\rangle\langle011|\,.\tag{1}$$</span></p>
<p>Now,</p>
<p><span class=""math-container"">$$\rho_1 = \text{Tr}_{23}\big[\rho\big] = |0\rangle\langle0|\,,\tag{2.1}$$</span>
<span class=""math-container"">$$\rho_{23} = \text{Tr}_{1}\big[\rho\big] = |11\rangle\langle11|\,.\tag{2.2}$$</span></p>
<p>So in this case, <span class=""math-container"">$$\rho = \rho_1 \otimes \rho_{23}\,,\tag{3}$$</span>
is true. However, this will not be true if your <span class=""math-container"">$\rho$</span> has entanglement.</p>
<hr />
<p>Let's perform the same analysis programatically using <code>QuTiP</code>.</p>
<p>Creating <span class=""math-container"">$\rho$</span>:</p>
<pre class=""lang-python prettyprint-override""><code># Define basis states for 3 qubits
q0 = basis(2, 0)  # |0â©
q1 = basis(2, 1)  # |1â©
psi = tensor(q0, q1, q1) # Example 3-qubit state: |0â© â |1â© â |1â©

# Creating a density matrix from the state |0â© â |1â© â |1â©
rho = psi * psi.dag()
# Print the density matrix
print(&quot;Density Matrix:&quot;)
print(rho)
</code></pre>
<p>This gives output:</p>
<pre><code>Density Matrix:
Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True
Qobj data =
[[0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0.]]
</code></pre>
<p>Now, taking the partial trace and computing <span class=""math-container"">$\rho_1$</span> and <span class=""math-container"">$\rho_{23}$</span>:</p>
<pre class=""lang-python prettyprint-override""><code># Performing partial trace for the first qubit
rho_1 = ptrace(rho, [0])
print(&quot;\nPartial Trace for the first qubit:&quot;)
print(rho_1)


# Performing partial trace for the second and third qubit
rho_23 = ptrace(rho, [1, 2])
print(&quot;\nPartial Trace for the second and third qubit:&quot;)
print(rho_23)
</code></pre>
<p>This gives output:</p>
<pre><code>Partial Trace for the first qubit:
Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True
Qobj data =
[[1. 0.]
 [0. 0.]]

Partial Trace for the second and third qubit:
Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True
Qobj data =
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 1.]]
</code></pre>
<p>And now, let's check if Eq.<span class=""math-container"">$(\text{3})$</span> holds true or not.</p>
<pre class=""lang-python prettyprint-override""><code>rho == tensor(rho_1, rho_23)
</code></pre>
<p>This gives output:</p>
<pre><code>True
</code></pre>
",3/21/2024 4:35,Theoretical,"This falls under the theoretical category as it pertains to understanding the mathematical operations and properties of quantum systems, specifically in the context of density matrices and tensor products, which are fundamental concepts in quantum mechanics.",Theoretical,,,,Theoretical,
37405.0,QiskitBackendNotFoundError - Unable to run the backend using BackendEstimator primitive,"<p>I am trying to run a small quantum circuit and generate the expectation value of an observable using the <code>BackendEstimator</code> primitive by incorporating the noise model from <code>Fake20QV1</code> backend. Below is a snippet of the code.</p>
<pre><code>qc = QuantumCircuit(3,3)
qc.x(0)
qc.x(1)
qc.h(2)
qc.x(2)

qc.measure(range(3), range(3))
observable = SparsePauliOp(&quot;ZZZ&quot;)
#qc.draw('mpl')
</code></pre>
<pre><code># Get the noise model of Fake20VQ1
backend_fake = Fake20QV1()
noise_model = noise.NoiseModel.from_backend(backend_fake)

# Get coupling map from backend
coupling_map = backend_fake.configuration().coupling_map

# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Perform a noisy simulation
backend = AerSimulator(noise_model=noise_model,
                       coupling_map=coupling_map,
                       basis_gates=basis_gates, shots=1024)
transpiled_circuit = transpile(qc, backend)
result = backend.run(transpiled_circuit).result()
</code></pre>
<p>Now, there are two ways in which I tried to run the circuit :</p>
<p>Alternative #1</p>
<pre><code>counts = result.get_counts(0)
expectation_value = sampled_expectation_value(counts, observable)
plot_histogram(counts)
expectation_value
</code></pre>
<p>Runs successfully and gives the expected outputs.</p>
<p>Alternative #2 (using BackendSampler and BackendEstimator)</p>
<pre><code>with Session(backend=backend_fake):
    sampler = BackendSampler()
    estimator = BackendEstimator()
    result1 = sampler.run(qc).result()
    print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;)

    result2 = estimator.run(qc, observable).result()
    print(f&quot;EV : {result2.values[0]}&quot;)
</code></pre>
<p>Generates <strong>QiskitBackendNotFoundError: 'No backend matches the criteria.'</strong></p>
<pre><code>File ~/anaconda3/envs/qem/lib/python3.12/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:779, in QiskitRuntimeService.backend(self, name, instance)
    763 &quot;&quot;&quot;Return a single backend matching the specified filtering.
    764 
    765 Args:
   (...)
    776     QiskitBackendNotFoundError: if no backend could be found.
    777 &quot;&quot;&quot;
    778 # pylint: disable=arguments-differ, line-too-long
--&gt; 779 backends = self.backends(name, instance=instance)
    780 if not backends:
    781     cloud_msg_url = &quot;&quot;
...
--&gt; 539         raise QiskitBackendNotFoundError(&quot;No backend matches the criteria.&quot;)
    540     if not self._backends[name] or instance_filter != self._backends[name]._instance:
    541         self._set_backend_config(name)

QiskitBackendNotFoundError: 'No backend matches the criteria.'
</code></pre>
",<qiskit><programming><ibm-quantum-devices>,3/22/2024 5:33,37407.0,37407.0,"<p>Since Qiskit has been updated, many things have been moved here and there, also the noise model fake backends that you are using. This is how you should run it in accordance with the recently updated Qiskit package.</p>
<h1>Necessary Imports</h1>
<pre class=""lang-python prettyprint-override""><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator
from qiskit_ibm_runtime.fake_provider import FakeVigo  # fake noisy backends are moved to ibm_runtime, do pip install qiskit-ibm-runtime before
from qiskit import transpile
from qiskit.result import sampled_expectation_value
from qiskit.visualization import plot_histogram
from qiskit.primitives import BackendEstimator, BackendSampler
</code></pre>
<h1>Making the Quantum Circuit</h1>
<pre class=""lang-python prettyprint-override""><code>qc = QuantumCircuit(3,3)
qc.x(0)
qc.x(1)
qc.h(2)
qc.x(2)

qc.measure(range(3), range(3))
observable = SparsePauliOp(&quot;ZZZ&quot;)
qc.draw('mpl',style=&quot;iqp&quot;)
</code></pre>
<h1>Selecting the Noisy Backend and transpiling</h1>
<pre class=""lang-python prettyprint-override""><code>device_backend = FakeVigo()
sim_vigo = AerSimulator.from_backend(device_backend)
transpiled_circuit = transpile(qc, sim_vigo)  # this step is necessary
</code></pre>
<h1>Running a Noisy Simulation</h1>
<pre class=""lang-python prettyprint-override""><code>result = sim_vigo.run(transpiled_circuit).result()
counts = result.get_counts(0)
expectation_value = sampled_expectation_value(counts, observable)

expectation_value
</code></pre>
<p>or getting the plot:</p>
<pre class=""lang-python prettyprint-override""><code>plot_histogram(counts)
</code></pre>
<h1>Alternative Method</h1>
<pre class=""lang-python prettyprint-override""><code>sampler = BackendSampler(backend=sim_vigo)
estimator = BackendEstimator(backend=sim_vigo)
result1 = sampler.run(qc).result()
print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;)

result2 = estimator.run(qc, observable).result()
print(f&quot;EV : {result2.values[0]}&quot;)
</code></pre>
<p>You have to specify the backend in the argument of <code>BackendSampler</code> and <code>BackendEstimator</code>. This code will run.</p>
",3/22/2024 7:00,Tooling,"This falls under the tooling category as it involves the utilization of Qiskit's BackendSampler and BackendEstimator primitives, demonstrating the use of specialized software tools for quantum circuit simulation and expectation value estimation, with a specific focus on incorporating noise models from a given backend.",Tooling,,,,Tooling,
37436.0,Quantum Circuit evaluation Qiskit vs. AWS Braket SDK,"<p>I am examining a simple circuit using both Qiskit and the AWS Braket SDK (Python).  The circuit is very simple.</p>
<pre><code>T  : |0|1|
          
q0 : -C-C-
      | | 
q1 : -Z-|-
        | 
q2 : ---Z-
</code></pre>
<p>I trying to find the equivalent unitary operator for this circuit.  I get different answers from Qiskit and AWS Braket SDK and I don't know why.</p>
<p>Here is my Qiskit code:</p>
<pre><code>from qiskit import *
qr = QuantumRegister(3, 'q')
cr = ClassicalRegister(0, 'c')
circuit = QuantumCircuit(qr, cr)
circuit.cz(qr[0], qr[1])
circuit.cz(qr[0], qr[2])

simulator = Aer.get_backend('unitary_simulator')
result = execute(circuit, backend = simulator).result() 
matprint(result.get_unitary().data)

def matprint(mat, fmt=&quot;g&quot;):
    col_maxes = [max([len((&quot;{:&quot;+fmt+&quot;}&quot;).format(x)) for x in col]) for col in mat.T]
    for x in mat:
        for i, y in enumerate(x):
            print((&quot;{:&quot;+str(col_maxes[i])+fmt+&quot;}&quot;).format(y), end=&quot;  &quot;)
        print(&quot;&quot;)
</code></pre>
<p>The Qiskit result is:</p>
<pre><code> 1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   1+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   1+0j   0+0j  
 0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   1-0j  
</code></pre>
<p>This is what I expected from my hand-calculations.  However, when using AWS Braket SDK I get something different.  The Braket code:</p>
<pre><code>from braket.circuits import Circuit
db=Circuit().cz(0,1).cz(0,2)
print(db.to_unitary())
</code></pre>
<p>The result is:</p>
<pre><code>[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]
</code></pre>
<p>I believe the Qiskit answer is correct because it is consistent with &quot;I kron CZ&quot; for the first operation.  If I do &quot;CZ kron I&quot; for the first operation I get the Braket answer.</p>
<p>I am new to quantum computing and would find an explanation valuable.</p>
",<qiskit><quantum-gate><programming><amazon-braket>,3/24/2024 21:17,37437.0,37437.0,"<p>The reason for the difference is that Qiskit and Braket use different endianness for their qubits; Qiskit is little endian:
<span class=""math-container"">$$
| q_{n - 1} \ldots q_2 q_1 q_0 \rangle
$$</span>
while Braket is big-endian:
<span class=""math-container"">$$
| q_0 q_1 q_2 \ldots q_{n - 1} \rangle
$$</span>
You can show this by reversing the endianness of the Qiskit unitary:</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit.quantum_info import Operator
Operator(circuit).reverse_qargs().to_matrix()
</code></pre>
",3/24/2024 21:54,Theoretical,"This falls under the theoretical category as it involves comparing the results of quantum circuit simulations between different quantum computing frameworks (Qiskit and AWS Braket SDK), highlighting the discrepancies in the generated unitary operators and seeking an explanation for the observed differences based on the underlying mathematical operations and conventions.",Theoretical,,,,Theoretical,
37455.0,Appending a gate to a Stim circuit in C++,"<p>I am trying to use Stim in C++. Until now, most functionality worked as expected. However, I recently tried to construct a Stim circuit in C++ and pass it to Python via <code>pybind11</code>, and this causes a weird behavior. For example, with my function:</p>
<pre class=""lang-cpp prettyprint-override""><code>void circuit_append(
        stim::Circuit &amp;self,
        const std::string &amp;gate_name,
        const std::vector&lt;uint32_t&gt; &amp;targets,
        const std::vector&lt;double&gt; &amp;args,
        bool backwards_compat) {    

        if (backwards_compat &amp;&amp; stim::GATE_DATA.at(gate_name).arg_count == 1) {
            // If the gate expects exactly one argument but none provided, use a default value.
            if (args.empty()) {
                self.safe_append_ua(gate_name, targets, 0.0);
            } else if (args.size() == 1) {
                self.safe_append_ua(gate_name, targets, args[0]);
            } else {
                throw std::invalid_argument(&quot;Gate expects exactly one argument.&quot;);
            }
        } else {
            // For gates that do not specifically require backwards compatibility handling or
            // can accept multiple arguments.
            if (args.size() == 1) {
                // If only one argument is provided, you could still use safe_append_ua for consistency.
                self.safe_append_ua(gate_name, targets, args[0]);
            } else {
                // Use safe_append_u for gates with multiple arguments or no arguments at all.
                self.safe_append_u(gate_name, targets, args);
            }
        }
    }
</code></pre>
<p>It checks the conditions for the wrong gates regarding the args etc. For example, trying to do:</p>
<p><code>append_custom(circuit, &quot;DEPOLARIZE1&quot;, [1], [0.1])</code></p>
<p>corresponding to a &quot;DEPOLARIZE1&quot; channel on qubit 0 with 0.1 as the error probability it will throw:</p>
<p><code>ValueError: Gate H_YZ was given 1 parens arguments (0.1) but takes 0 parens arguments.</code></p>
<p>Does anyone know how to solve this issue?</p>
",<programming><circuit-construction><stim>,3/25/2024 17:48,37458.0,37458.0,"<p>My best guess is that you're interacting different versions of the C++ code, and they disagree on the indexing of the <code>GateType</code> enum (since this has not been kept consistent over time). If anything, you're lucky this manifested in such a simple way, since there are many many other ways in which binary compatibility is broken from version to version (e.g. adding/removing/reordering fields in structs).</p>
<p>A simple way to test this is to see if the problem goes away if you ensure the source you are building from matches the version of the stim wheel that you have installed. For example, if you have the v1.13.0 wheel installed (use <code>print(stim.__version__)</code> to get the wheel's version), then you should be building from <a href=""https://github.com/quantumlib/Stim/releases/tag/v1.13.0"" rel=""nofollow noreferrer"">tag <code>v1.13.0</code></a> (which is <a href=""https://github.com/quantumlib/Stim/commit/b01e42391583d03db4266b387d907eda1d7ae488"" rel=""nofollow noreferrer"">commit <code>b01e42391583d03db4266b387d907eda1d7ae488</code></a>). Alternatively, build your own version of the wheel from the same version of the source code you are mucking around with (IMO the easiest way is <a href=""https://github.com/quantumlib/Stim/blob/main/doc/developer_documentation.md#pypackage.stim.bazel"" rel=""nofollow noreferrer"">the bazel method</a>).</p>
<p>A simple workaround, for passing a circuit between versions of stim that are not guaranteed to be binary compatible, is to serialize to a string and parse the string. For example:</p>
<pre class=""lang-cpp prettyprint-override""><code>pybind11::object wrap_circuit(const stim::Circuit &amp;circuit) {
    pybind11::object serialized = pybind11::cast(circuit.str());
    pybind11::object python_circuit_class = pybind11::module_::import(&quot;stim&quot;).attr(&quot;Circuit&quot;);
    return python_circuit_class(serialized);
}

stim::Circuit unwrap_circuit(const pybind11::object &amp;circuit) {
    std::string contents = pybind11::cast&lt;std::string&gt;(pybind11::str(circuit));
    return stim::Circuit(contents.data());
}
</code></pre>
<p>This workaround is why pymatching can take circuits and detector error models despite being built with binary linking to a version of stim that may disagree with the version in the wheel the user has installed.</p>
",3/25/2024 23:47,Tooling,"This falls under the tooling category as it involves the development and integration of a C++ library (Stim) with Python using pybind11, demonstrating the utilization of specialized software tools for interoperability between different programming languages and frameworks.",Errors,"This question falls under the Errors category because it involves seeking a solution to a specific issue encountered during the development process, namely the incorrect handling of gate arguments in the Stim C++ library when constructing circuits and passing them to Python using pybind11.",No,145.0,Errors,"The user is encountering an issue with the handling of gate arguments in the Stim C++ library, leading to incorrect behavior when constructing circuits and passing them to Python via pybind11. They are seeking assistance in solving this specific issue, which aligns with the category of addressing errors in software development."
37524.0,How to create custom fake backend?,"<p>Right now I'm trying to figure out how to create custom fake backends using qiskit with data we are retrieving from our real backends in the laboratory.<br />
As I understand, the best way to create one is to use <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2"" rel=""nofollow noreferrer""><code>GenericBackendV2</code></a>.</p>
<p>Documentations says, that we can specify:</p>
<ul>
<li>Number of qubits</li>
<li>List of basis gate names</li>
<li>Coupling map for the backend</li>
<li>Instruction calibration settings</li>
</ul>
<p>But what about other characteristics? For instance, I want to set T1 / T2 times or each qubit's frequency and maybe even some measurement errors.</p>
<p>Documentations says:</p>
<blockquote>
<p>The remainder of the backend properties are generated by randomly
sampling from default ranges extracted from historical IBM backend
data.</p>
</blockquote>
<p>But can I somehow set it manually?</p>
",<qiskit><programming>,3/29/2024 8:32,37585.0,37585.0,"<p>For setting T1/T2 times, measurement error, and other errors (like reset errors etc.) you can make a custom noise model by using the <code>NoiseModel()</code> function from the <code>qiskit_aer.noise</code> module.</p>
<p>Here is a high-level overview of how you can achieve this:</p>
<ol>
<li><p>To use this function, you first define what errors you want to model and on what gates you want to apply this errors.</p>
</li>
<li><p>Then you add these errors to a noise model, and here you get to pick if you want to apply the noise models to all the qubits or just some specific qubits.</p>
</li>
<li><p>After doing this, you can use your noise model in the <code>AerSimulator()</code> to simulate your circuit on the simulator or you can specify your custom backend to transpile and run your circuit.</p>
</li>
</ol>
<p><a href=""https://docs.quantum.ibm.com/verify/building_noise_models#build-noise-models"" rel=""nofollow noreferrer"">Here is the link</a> to the documentation for building noise models.
Hope this helps!</p>
",04/03/2024 00:58,Tooling,"This falls under the tooling category as it pertains to the customization and configuration of fake quantum backends using Qiskit, highlighting the utilization of specialized software tools for simulating and emulating quantum hardware characteristics for research and development purposes.",Tooling,,,,Tooling,
37533.0,How to run PegasosQSVC in quantum backend or simulator?,"<p>I am making my classification project in quantum machine learning, currently trying to run PegasosQSVC in backend! The code runs normally in my environment however when I connect to backend using <code>provider.get_backend()</code> from <code>QiskitRuntimeService()</code> and try to run it on backend it shows different errors, the first error is that I can't run my code on a simulator when I chose a simulator backend, the other one is the error I show in this question. My code is as follows :</p>
<pre><code># importing feature map 
from qiskit.circuit.library import ZFeatureMap 

# define feature map to be used in the algorithm 
featuremap = ZFeatureMap(feature_dimension=num_qubits, reps = 3) 

# transpile the featuremap to make compatible with the backend topology 

from qiskit.compiler.transpiler import transpile
transpiled_featuremap = transpile(circuits=featuremap, backend=backend) 

# set the session in which we will run the circuits 
from qiskit_ibm_runtime import Session, Sampler

with Session(service= service, backend=backend) as session:
    sampler = Sampler(session=session, backend=backend) 

# set the fidelity parameter 
from qiskit_algorithms.state_fidelities import ComputeUncompute

fidelity = ComputeUncompute(sampler=sampler) 

# setting the kernel 
from qiskit_machine_learning.kernels import FidelityQuantumKernel 

qkernel = FidelityQuantumKernel(feature_map=transpiled_featuremap, fidelity=fidelity)  

# fitting the classifier 
from qiskit_machine_learning.algorithms import PegasosQSVC 
pegasos = PegasosQSVC(quantum_kernel=qkernel, C = C, num_steps=tau)

pegasos.fit(train_features,train_labels) 

pegasos_score = pegasos.score(test_features,test_labels) 

print(f&quot;Pegasosqsvc classification test score: {pegasos_score*100}&quot;)
</code></pre>
<p>When I run this code I get the following error:</p>
<pre><code>The instruction sxdg on qubits (1,) is not supported by the target system. Circuits that do not match the target hardware definition are no longer supported after March 4, 2024. See the transpilation documentation (https://docs.quantum.ibm.com/transpile) for instructions to transform circuits and the primitive examples (https://docs.quantum.ibm.com/run/primitives-examples) to see this coupled with operator transformations. 
</code></pre>
<p>What can I do to solve this issue?</p>
",<qiskit><programming><quantum-enhanced-machine-learning><qiskit-runtime>,3/29/2024 17:44,37534.0,37534.0,"<p><code>ComputeUncompute</code>composes the circuit with its inverse() and this ends up not conforming to the ISA requirement. There is an <a href=""https://github.com/qiskit-community/qiskit-algorithms/issues/165"" rel=""nofollow noreferrer"">issue</a> in Qiskit Algorithms specifically about that as well a more general issue around Qiskit Algorithms and ISA circuits. With the code as-is I do not know a solution - if you consider modifying some code then a workaround would be to take a local copy of ComputeUncompute and modify it to transpile the circuit it uses (ie the circuit1 + circuit2.inverse()) for some given backend.</p>
<p>It should however still run on local Aer simulator if you use the Sampler from Aer.</p>
",3/29/2024 18:49,Tooling,"This falls under the tooling category as it involves the utilization of Qiskit and related tools (such as Qiskit Runtime Service) for running quantum machine learning algorithms, highlighting the challenges in adapting the code to backend-specific constraints and errors encountered during the execution process.",Tooling,,,,Tooling,
37535.0,Python package for quantum computations based on symbolic variables,"<p>I am searching for a quantum package in Python that can enable me to calculate, for example, a density matrix symbolically and display the results in variable form rather than numerically. I am aware of <code>QuTiP</code>, but it is primarily designed for numerical applications.</p>
",<programming><resource-request><qutip>,3/29/2024 18:51,37536.0,37536.0,"<p>Take a look at <a href=""https://github.com/SimoneGasperini/qiskit-symb"" rel=""nofollow noreferrer""><code>qiskit-symb</code></a>, which is a Python package.</p>
<p>You may also take a look this, which is not a Python package, but you might find it helpful: <a href=""https://www.wolfram.com/quantum-computation-framework/"" rel=""nofollow noreferrer"">Wolfram Quantum Framework</a> provide-</p>
<ul>
<li><a href=""https://resources.wolframcloud.com/ExampleRepository/resources/Symbolic-computation-for-quantum-states/"" rel=""nofollow noreferrer"">Symbolic computation for quantum states</a></li>
<li><a href=""https://resources.wolframcloud.com/ExampleRepository/resources/Symbolic-computation-for-quantum-circuits/"" rel=""nofollow noreferrer"">Symbolic computation for quantum circuits</a></li>
<li><a href=""https://resources.wolframcloud.com/ExampleRepository/resources/Symbolic-evolution-of-a-quantum-state/"" rel=""nofollow noreferrer"">Symbolic evolution of a quantum state</a></li>
</ul>
",3/29/2024 21:33,Tooling,"This falls under the tooling category as it involves seeking a specific quantum package in Python for symbolic calculations and variable display of density matrices, highlighting the utilization of specialized software tools for quantum computing tasks with specific requirements beyond numerical applications.",Tooling,,,,Tooling,
37639.0,Strange non-normal distribution histogram when applying Hadamard gate in a loop,"<p>Recently I have explored <code>Q#</code> quantum programming language. My basic test was this,- for 10000 times in a loop reset qubit to <code>|0&gt;</code>, then apply Hadamard gate, measure qubit state and aggregate <code>(|0&gt;,|1&gt;)</code> average probability tuple. Then I repeat this experiment for 10 000 &quot;shots&quot; for drawing experiment histogram in VScode.</p>
<p>For the reference, my full Q# test code :</p>
<pre><code>namespace Experiment {
    open Microsoft.Quantum.Convert;

    @EntryPoint()
    operation test(): (Double, Double) {
        use q = Qubit();

        mutable wasZero = 0.0;
        let trials = 10000;
        for index in 1 .. trials {
            // Init to |0&gt; state
            Reset(q);
            // Apply Hadamard gate
            H(q);
            // Aggregate statistics
            let r = M(q);
            if (r==Zero) {
                set wasZero +=1.0;
            }
        }

        // &quot;Free&quot; alocated qubit before exiting from program
        Reset(q);
        // From statistics calculate average state vector after transformation
        let avgState = (    wasZero/IntAsDouble(trials), 
                        1.0-wasZero/IntAsDouble(trials)
                       ); 
        return avgState;
    }

}
</code></pre>
<p>What I get is this :</p>
<p><a href=""https://i.stack.imgur.com/1atQX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1atQX.png"" alt=""enter image description here"" /></a></p>
<p>I would expect to get a normal distribution with maximum at <code>(1/2,1/2)</code>, but instead what I saw is darker stripes, (inside supposed to be a Gaussian curve),- marked with yellow arrows in histogram.</p>
<p><strong>Question</strong>,- What is the cause of these periodic Gaussian &quot;abnormalities&quot; ? Is this some random number generator issues (I run this locally in VScode studio in quantum simulator), or simply graphics/rendering issue not related to quantum simulator ?</p>
<p>Thanks.</p>
",<programming><q#><hadamard>,04/05/2024 14:28,37640.0,37640.0,"<p>It is hard to tell exactly what are the arrows pointing at. I assume you are not refering to the vertical statistical disturbance that adds some noise to the expected Gaussian curve (increasing the number of shots will get you closer to a smooth curve).</p>
<p>My guess is that it is a rendering problem. Maybe your histogram bars have a slightly darker outline and overlap each other causing something analogous to a <a href=""https://en.wikipedia.org/wiki/Moir%C3%A9_pattern"" rel=""nofollow noreferrer"">MoirÃ© pattern</a>. Does changing the zoom level of the histogram change to periodicity of the darker stripes?</p>
<p>Your picture is just an histogram that aggregates numerical values from a list. You can try exporting this list and plot it as an histogram with a different plotting system than the one of VSCode to confirm it is indeed a rendering problem.</p>
",04/05/2024 14:59,Errors,"It seeks an explanation for an unexpected behavior observed during the execution of a quantum program, specifically regarding the periodic Gaussian abnormalities in the histogram visualization.",Errors,,,,Errors,
37673.0,Why do the same circult yields very different results from different IBM backends?,"<p>I was running the IBM qiskit <a href=""https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.EstimatorV2"" rel=""nofollow noreferrer"">sample code</a> and noticed that the results vary on different backends. I thought it was quantum noise, so I repeated the same calculation on many different backends and got this figure:</p>
<p><a href=""https://i.stack.imgur.com/I79UI.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/I79UI.jpg"" alt=""enter image description here"" /></a></p>
<p>The results are very consistent within the same backend but vary quite a bit between backends, particularly on <code>fake_manila</code>, <code>fake_kyoto</code>, and <code>ibm_kyoto</code>. So, the cause does not seem to be quantum noise.</p>
<p>BTW, The <em>theoretical</em> result (from matrix multiplication) is shown on the right most point as <span class=""math-container"">$\langle v|H|v\rangle$</span>.</p>
<p>Did I do something wrong?</p>
<p>Here is my code:</p>
<pre><code>from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import Session, EstimatorV2 as Estimator

from qiskit_ibm_runtime.fake_provider import (FakeAlgiers, FakeAthensV2, FakeBelemV2, FakeManilaV2,
                                              FakeAuckland, FakeBrisbane, FakeOsaka, FakeKyoto)
from qiskit.quantum_info import Statevector
import numpy as np

psi = RealAmplitudes(num_qubits=2, reps=2)
theta = [0, 1, 1, 2, 3, 5]

hamiltonian = SparsePauliOp.from_list([(&quot;II&quot;, 1), (&quot;IZ&quot;, 2), (&quot;XI&quot;, 3)])

service = QiskitRuntimeService()
fake_backends = [FakeAlgiers(), FakeAthensV2(), FakeBelemV2(), FakeManilaV2(), FakeAuckland(),
                 FakeBrisbane(), FakeOsaka(), FakeKyoto()] 
real_backends = service.backends(simulator=False, operational=True)
all_backends = real_backends

results = {}  # keep track all the results
repeats = 10
for backend in fake_backends:
    pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
    isa_psi = pm.run(psi)
    isa_observables = hamiltonian.apply_layout(isa_psi.layout)

    estimator = Estimator(backend=backend)
    values = results.get(backend.name, [])
    for r in range(repeats):
        job = estimator.run([(isa_psi, isa_observables, [theta])])
        pub_result = job.result()[0]
        print(f&quot;Expected values from {backend.name}: {pub_result.data.evs}&quot;)
        values.append(pub_result.data.evs)
    results[backend.name] = values

repeats = 3
for backend in real_backends:
    pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
    isa_psi = pm.run(psi)
    isa_observables = hamiltonian.apply_layout(isa_psi.layout)

    with Session(service=service, backend=backend):
        estimator = Estimator(backend=backend)
        values = results.get(backend.name, [])
        for r in range(repeats):
            job = estimator.run([(isa_psi, isa_observables, [theta])])
            pub_result = job.result()[0]
            print(f&quot;Expected values from {backend.name}: {pub_result.data.evs}&quot;)
            values.append(pub_result.data.evs)
        results[backend.name] = values

# compute &lt;psi|H|psi&gt; using matrices
statevector = Statevector(psi.assign_parameters(theta))
v = np.matrix(statevector.data).transpose()
h = hamiltonian.to_matrix()
results['&lt;v|H|v&gt;'] = v.getH() @  h @ v
print(f&quot;&lt;v|H|v&gt; = {v.getH() @  h @ v}&quot;)
</code></pre>
",<qiskit><programming><qiskit-runtime>,04/07/2024 13:27,37675.0,37675.0,"<p>The problem is caused by a different type of noise each QPU suffers from. Nowadays, it is even not easy to produce two completely same qubits, not to mention two identical QPUs.</p>
<p>Please, have a look at calibration data in IBM Q portal. You can see that for example T1 and T2 times vary widely both for particular QPU and also among them.</p>
<p>These discrepancies in quality of qubits cause that one circuit runs differently on different backends.</p>
",04/07/2024 16:09,API Usage,"The question involves using the Qiskit IBM Runtime API (specifically the EstimatorV2) to perform calculations on different backends, and the issue arises from the variations observed in the results obtained from different backends. This falls under API usage as it pertains to the utilization and behavior of the Qiskit IBM Runtime API.",Errors,"This question falls under the Errors category because it pertains to the inconsistent results obtained when running the IBM Qiskit sample code on different backends, indicating a potential issue or discrepancy in the code or underlying framework.",No,146.0,Errors,"The user is encountering inconsistent results when running IBM Qiskit sample code on different backends, indicating a potential issue or discrepancy in the code or underlying framework. They seek assistance in understanding why the results vary between backends, suggesting an error or inconsistency in the implementation."
37723.0,What does Qiskit AerSimulator(memory=True) do?,"<p>I followed <a href=""https://learning.quantum.ibm.com/course/fundamentals-of-quantum-algorithms/quantum-query-algorithms"" rel=""nofollow noreferrer"">this Qiskit course</a> through Deutsch's algorithm and all seems clear to me except the use of the optional parameter <code>memory=true</code> when making the call to <code>AerSimulator().run(...)</code>.</p>
<p>The context of this call is as follows:</p>
<pre><code>def deutsch_algorithm(function: QuantumCircuit):
    &quot;&quot;&quot;
    Determine if a Deutsch function is constant or balanced.
    &quot;&quot;&quot;
    qc = compile_circuit(function)

    result = AerSimulator().run(qc, shots=1, memory=True).result()
    measurements = result.get_memory()
    if measurements[0] == &quot;0&quot;:
        return &quot;constant&quot;
    return &quot;balanced&quot;
</code></pre>
<p>The documentation for <a href=""https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.AerSimulator.html"" rel=""nofollow noreferrer""><code>AerSimulator</code></a> does not seem to cover this parameter, since there are so many backed options that most are briefly mentioned and the details are unavailable.
My assumption is that this parameter enables the collection of classical bits from measurements, but I would like to know for certain what happens here.</p>
",<qiskit><programming>,04/09/2024 16:30,37724.0,37724.0,"<p>The parameter <code>memory</code> is used to record and return the measurement outcomes for each shot of the simulation. When you set <code>memory=True</code>, it tells the simulator to save the measurement result from each shot as a separate item in a list.</p>
<p>For example, you can set <code>memory=True</code> and then retrieve the data from memory like so:</p>
<pre><code># Run and get memory
result = simulator.run(circ, shots=10, memory=True).result()
memory = result.get_memory(circ)
print(memory)
</code></pre>
<p>This will print out the list of measurement results, e.g., <code>['11', '00', '11',...,'11']</code>.</p>
<p>See this <a href=""https://qiskit.github.io/qiskit-aer/tutorials/1_aersimulator.html"" rel=""noreferrer"">documentation</a> for a complete example.</p>
",04/09/2024 19:19,API Usage,"The question pertains to understanding the usage of a specific parameter (memory) in the Qiskit AerSimulator API when running quantum circuits, which falls under the category of API usage as it involves understanding the functionality and usage of a particular parameter in the Qiskit AerSimulator API.",API Usage,,,,API Usage,
37736.0,How do I extract information from stim.PauliString?,"<p>Suppose I have <code>stim.PauliString(&quot;+Z_Z_ZZ__&quot;)</code>. I want to extract its data information in Python: either as a string <code>&quot;+Z_Z_ZZ__&quot;</code> or some binary vector.</p>
<p>How should I do this?</p>
",<programming><stim>,04/10/2024 16:26,37737.0,37737.0,"<p>You can use <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.PauliString.to_numpy"" rel=""nofollow noreferrer""><code>stim.PauliString.to_numpy</code></a> to extract the XZ-encoded Pauli information from a pauli string as numpy arrays, and <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.PauliString.sign"" rel=""nofollow noreferrer""><code>stim.PauliString.sign</code></a> to get the sign.</p>
<p>For large Pauli strings, you can use <code>stim.PauliString.to_numpy(bit_packed=True)</code> to get an output that's 8x smaller. For sparse Pauli strings, you can use <a href=""https://github.com/quantumlib/Stim/blob/main/doc/python_api_reference_vDev.md#stim.PauliString.pauli_indices"" rel=""nofollow noreferrer""><code>stim.PauliString.pauli_indices</code></a> to get a result that skips over identity terms.</p>
<pre class=""lang-python prettyprint-override""><code>import stim
p = stim.PauliString(&quot;+Z_Z_ZZ__XYZ&quot;)
xs, zs = p.to_numpy()
print(&quot;xs&quot;, xs)
print(&quot;zs&quot;, zs)
print(&quot;sign&quot;, p.sign)
# Prints:
# xs [False False False False False False False False  True  True False]
# zs [ True False  True False  True  True False False False  True  True]
# sign (1+0j)
</code></pre>
<pre class=""lang-python prettyprint-override""><code>packed_xs, packed_zs = p.to_numpy(bit_packed=True)
print(&quot;packed_xs&quot;, packed_xs)
print(&quot;packed_zs&quot;, packed_zs)
print(&quot;bin(packed_xs)&quot;, ' '.join(bin(e)[2:].rjust(8, '0')[::-1] for e in packed_xs))
print(&quot;bin(packed_zs)&quot;, ' '.join(bin(e)[2:].rjust(8, '0')[::-1] for e in packed_zs))
# Prints:
# packed_xs [0 3]
# packed_zs [53  6]
# bin(packed_xs) 00000000 11000000
# bin(packed_zs) 10101100 01100000
</code></pre>
<pre class=""lang-python prettyprint-override""><code>print(&quot;xyz_indices&quot;, p.pauli_indices())
print(&quot;x_indices&quot;, p.pauli_indices('X'))
print(&quot;y_indices&quot;, p.pauli_indices('Y'))
print(&quot;xz_indices&quot;, p.pauli_indices('XZ'))
# Prints:
# xyz_indices [0, 2, 4, 5, 8, 9, 10]
# x_indices [8]
# y_indices [9]
# xz_indices [0, 2, 4, 5, 8, 10]
</code></pre>
",04/10/2024 16:26,API Usage,"The question involves extracting data information from a Stim object in Python, which pertains to understanding how to use the Stim API to access and manipulate data within a PauliString object.",API Usage,,,,API Usage,
37858.0,Quantum Computing - via Qiskit - error 403,"<p>A year ago, I registered in the IBM Quantum Computing app, which provides access to quantum computers and to simulators. I got an API key, and was able to run some programs.</p>
<p>However, lately, I try to log in in my account and the system answers me with the same page, and I am not able to get another/the same API key. In fact, when I run the programs I run a year ago, using the API key that I then got, the program replies with:</p>
<pre><code>qiskit_ibm_runtime.api.exceptions.RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME., Error code: 3485.'
</code></pre>
<p>I tried to contact IBM, but they have not been replying...</p>
<p>Any idea?</p>
<p>By the way: I use python 3.11 and qiskit 0.43.0.</p>
<p>The program:</p>
<pre><code># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from IPython.display import display
from qiskit.visualization import *

# Loading your IBM Quantum account(s)
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) # the error occurs here!

...

<span class=""math-container"">```</span>
</code></pre>
",<qiskit><programming><ibm-quantum-devices>,4/18/2024 11:17,37881.0,37881.0,"<p>Try logging in to IBMQ account on the <a href=""https://quantum.ibm.com/"" rel=""nofollow noreferrer"">webpage</a>. If you are able to do this, copy the API token shown in the top right.</p>
<p>Then make use of the code mentioned in <a href=""https://quantumcomputing.stackexchange.com/questions/23639/how-can-i-save-ibm-quantum-api-token-to-local-environment/35456#35456"">this answer</a>,this is the updated code for the latest version of qiskit and will help you use IBMQ from your local device.</p>
<p>If the error still persists, read the complete error message, like in <a href=""https://quantumcomputing.stackexchange.com/questions/16128/ibmq-load-account-fails-with-403-client-error"">this answer</a>, your reason might be there.</p>
",4/19/2024 8:01,Errors,"The question involves seeking a solution for an error encountered while trying to access the IBM Quantum Computing app, specifically encountering a ""403 Client Error: Forbidden"" message.",Errors,,,,Errors,
37882.0,Classical computation required in Shor's algorithm: are they heavy?,"<p>A quantum computer also requires to perform classical computations.</p>
<p>I would like to know if to implement Shor's algorithm, there is a heavy classical computation cost (i.e. that would require a supercomputer).</p>
<p><strong>I exclude the computation costs required by quantum error-correction, and the classical cost required to pre-compile the circuit.</strong> I would like to know the classical computation cost while the quantum algorithm is running (maybe there are classical computation to do in parallel of the quantum gates implementations).</p>
<p>For instance, in <a href=""https://arxiv.org/abs/quant-ph/9806084"" rel=""nofollow noreferrer"">Zalka's</a> or <a href=""https://quantum-journal.org/papers/q-2021-04-15-433/"" rel=""nofollow noreferrer"">Gidney's</a> implementation: do we need a classical supercomputer or would a laptop suffice for the job?</p>
",<quantum-algorithms><shors-algorithm><classical-computing>,4/19/2024 10:12,37883.0,37883.0,"<p>My guess is that a laptop would be sufficient for computing the lookup tables and delayed choice fixups and various other things-that-aren't-error-correction on the fly. There's tens of microseconds from Toffoli to Toffoli, and that's a lot of time for a computer. But... I fundamentally have to disagree with your question's framing, because it's a complete disaster of a mistake to ignore the cost of error correction.</p>
<p>Each surface code logical qubit would be generating around a gigabit of syndrome data per second. That's easily enough data to keep a CPU core busy decoding the errors. But there are ten thousand logical qubits of space. So, back of the envelope, you need ten thousand CPU cores running alongside the quantum computer, just to error correct the logical qubits.</p>
<p>Modern super computers have millions of CPU cores. So you need an amount of classical compute that's roughly 1% of a modern super computer. The laptop is totally negligible in comparison.</p>
",4/19/2024 11:46,Conceptual," The question seeks clarification on the classical computation requirements of implementing Shor's algorithm, excluding pre-compilation and error-correction tasks, which falls under the conceptual understanding of the algorithm's computational complexity.",Conceptual,,,,Conceptual,
38046.0,Error when binding parameters to a quantum circuit,"<p>When I try to run the circuit below:</p>
<pre><code>from qiskit.circuit.library import TwoLocal 
from math import pi

reference_circuit = TwoLocal(2, &quot;rx&quot;, &quot;cz&quot;, entanglement=&quot;linear&quot;, reps=1) theta_list = [pi / 2, pi / 3, pi / 3, pi / 2]

reference_circuit = reference_circuit.bind_parameters(theta_list)

reference_circuit.decompose().draw(&quot;mpl&quot;)
</code></pre>
<p>I get an error that says: <code>'TwoLocal' object has no attribute 'bind_parameters'</code>. This code was working perfectly fine sometime ago but now it keeps throwing error.</p>
",<qiskit><programming>,4/30/2024 2:49,38048.0,38048.0,"<p>You are getting that error because you are trying to run qiskit code written in <code>qiskit&lt;=0.46</code> in an environment that runs <code>qiskit&gt;=1.0.0</code>. To fix this issue instead of using <code>bind_parameters()</code> use the new function <code>assign_parameters()</code>. So your code will look like:</p>
<pre><code>from qiskit.circuit.library import TwoLocal 
from math import pi

reference_circuit = TwoLocal(2, &quot;rx&quot;, &quot;cz&quot;, entanglement=&quot;linear&quot;, reps=1) 
theta_list = [pi / 2, pi / 3, pi / 3, pi / 2]

reference_circuit = reference_circuit.assign_parameters(theta_list)

reference_circuit.decompose().draw(&quot;mpl&quot;)
</code></pre>
<p>For more information on the changes when migrating from <code>qiskit&lt;=0.46</code> to <code>qiskit&gt;=1.0.0</code> can be found <a href=""https://docs.quantum.ibm.com/api/migration-guides/qiskit-1.0-features"" rel=""nofollow noreferrer"">here</a></p>
",4/30/2024 4:23, Errors," The question seeks an explanation for an error encountered while running code, specifically regarding the absence of the bind_parameters attribute in the TwoLocal object, indicating a potential issue with the Qiskit library or changes in its implementation.", Errors,,,, Errors,
38051.0,How to implement a depolarizing noise channel for qutrits using cirq?,"<p>Anyone have any idea how I can implement a depolarizing noise channel for qutrits using cirq? Say using the kraus operators within a class inheriting from cirq.Gate or so?</p>
",<quantum-state><programming><cirq>,4/30/2024 10:59,38063.0,38063.0,"<p>The depolarizing channel can be represented as a probabilistic mixture of unitaries. You can represent mixtures in Cirq by implementing the <code>_mixture_</code> and <code>_has_mixture_</code> magic methods on a class.</p>
<p>I'm following <a href=""https://arxiv.org/pdf/1101.3986"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1101.3986</a> for the Kraus operators (which are unitary):</p>
<p><a href=""https://i.sstatic.net/pB2cA3tf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pB2cA3tf.png"" alt=""enter image description here"" /></a></p>
<p>I reimplemented the <a href=""https://github.com/quantumlib/Cirq/blob/v1.3.0/cirq-core/cirq/ops/common_channels.py#L250"" rel=""nofollow noreferrer""><code>DepolarizingChannel</code></a> but only for a single qutrit as an example:</p>
<pre class=""lang-python prettyprint-override""><code>
SHIFT = np.array([[0,1,0],
              [0,0,1],
              [1,0,0]])
Ï = np.exp(1j * 2/3 * np.pi)
CLOCK = np.array([[1,0,0],
              [0,Ï,0],
              [0,0,Ï**2]])

class QutritDepolarizingChannel(cirq.Gate):
    r&quot;&quot;&quot;A channel that depolarizes one qutrit.
    &quot;&quot;&quot;

    def __init__(self, p: float) -&gt; None:
        &quot;&quot;&quot;Constructs a depolarization channel on a qutrit.

        Args:
            p: The probability that one of the shift/clock matrices is applied. Each of
                the 8 shift/clock gates is applied independently with probability
                <span class=""math-container"">$p / 8$</span>.
            n_qubits: the number of qubits.

        Raises:
            ValueError: if p is not a valid probability.
        &quot;&quot;&quot;

        error_probabilities = {}

        p_depol = p / 8
        p_identity = 1.0 - p
        for gate_pows in itertools.product(range(3), range(3)):          
            if gate_pows == (0,0):
                error_probabilities[gate_pows] = p_identity
            else:
                error_probabilities[gate_pows] = p_depol
        self.error_probabilities = error_probabilities
        self._p = p        

    def _qid_shape_(self):
        return (3,) 

    def _mixture_(self) -&gt; Sequence[Tuple[float, np.ndarray]]:
        op = lambda shift_pow, clock_pow: np.linalg.matrix_power(SHIFT, shift_pow) @ np.linalg.matrix_power(CLOCK, clock_pow)
        return [(self.error_probabilities[(shift_pow, clock_pow)], op(shift_pow, clock_pow))
                for (shift_pow, clock_pow) in self.error_probabilities.keys()]

    def _has_mixture_(self) -&gt; bool:
        return True

    def _value_equality_values_(self):
        return self._p
    
    def _circuit_diagram_info_(self, args):        
        if args.precision is not None:
            return (f&quot;D3({self._p:.{args.precision}g})&quot;,)
        else:
            return (f&quot;D3({self._p})&quot;,)        
        return result

    @property
    def p(self) -&gt; float:
        &quot;&quot;&quot;The probability that one of the qutrit gates is applied.

        Each of the 8 Pauli gates is applied independently with probability
        <span class=""math-container"">$p / 8$</span>.
        &quot;&quot;&quot;
        return self._p

    @property
    def n_qubits(self) -&gt; int:
        &quot;&quot;&quot;The number of qubits&quot;&quot;&quot;
        return 1
</code></pre>
<p>Then you can use it as any other channel/gate:</p>
<pre class=""lang-python prettyprint-override""><code>t = cirq.NamedQid(&quot;my qutrit&quot;, 3)
c = cirq.Circuit(QutritDepolarizingChannel(0.12)(t), cirq.measure(t))
print(c)
cirq.DensityMatrixSimulator().run(c, repetitions=100)
</code></pre>
<p>Results in:</p>
<pre><code>my qutrit (d=3): âââD3(0.12)âââMâââ
my qutrit (d=3)=0000000000000000100000000100010000000020000000000000000000000000000000000000000000000000000000000100
</code></pre>
<p>colab: <a href=""https://colab.research.google.com/drive/1l8v3YAOxCtDP3Ccxgv5wbGfRRqnLbgIp#scrollTo=EqkzGHaul-N7"" rel=""nofollow noreferrer"">https://colab.research.google.com/drive/1l8v3YAOxCtDP3Ccxgv5wbGfRRqnLbgIp#scrollTo=EqkzGHaul-N7</a></p>
",4/30/2024 16:00,API Usage," The question is seeking guidance on how to utilize a specific feature (depolarizing noise channel) within a quantum programming framework (Cirq), which falls under API usage as it involves utilizing the functionality provided by the Cirq library to implement a noise channel.",API Usage,,,,API Usage,
38093.0,Quantum circuit not showing when using qiskit with pycharm,"<p>I am trying to run below code in PyCharm:</p>
<pre><code>from qiskit.circuit.library import MCXGate, HGate 
from qiskit import QuantumCircuit

circuit = QuantumCircuit(4)

circuit.append(HGate(), [0]) 
circuit.append(MCXGate(3), [0,1,2,3])

circuit.draw('mpl')
</code></pre>
<p>But I don't see any output circuit. The plot window flashes for a bit but it immediately closes itself. If I use inline figures then I can get the circuit diagram but I want the interactive version. Can someone please help me with this issue. I have always used PyCharm for my other projects so I don't really want to change to another IDE.</p>
",<qiskit><programming>,05/02/2024 01:39,38094.0,38094.0,"<p>By default, <code>qiskit</code> draws the quantum circuit for inline visualization (because inline figures are typlically used with jupyter lab). To fix this issue, you need to explicitly use <code>.show()</code> method from <code>matplotlib.pyplot</code> if you are creating the figure from an IDE. So, your code will look something like this:</p>
<pre><code>from qiskit.circuit.library import MCXGate, HGate
from qiskit import QuantumCircuit
import matplotlib.pyplot as plt

circuit = QuantumCircuit(4)

circuit.append(HGate(), [0])
circuit.append(MCXGate(3), [0,1,2,3])

circuit.draw('mpl')
plt.show()    # Add this line
</code></pre>
<p>Hope this helps!</p>
",05/02/2024 02:38,Tooling,"The question is related to using a specific tool (PyCharm) to visualize quantum circuits generated with Qiskit, seeking assistance on resolving an issue with displaying interactive circuit diagrams within the IDE.",Tooling,,,,Tooling,
38129.0,Showing the Toffoli gate can be constructed from one-qubit gates using computer matrix multiplication,"<p><a href=""https://i.sstatic.net/wETHjSY8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wETHjSY8.png"" alt=""enter image description here"" /></a></p>
<p>I need help coming up with the code that I can use in a computer algebra system like Sage, Python, or Mathematica that can evaluate the circuit.</p>
<p>I am not a programmer and used ChatGPT to try to help me create the code. However, I believe these are incorrect because they do not evaluate.</p>
<p>Here is what ChatGPT came up with in Mathematica:</p>
<pre><code>TensorProduct[(1/Sqrt[2]){{1, 1}, {1, -1}}, IdentityMatrix[2], IdentityMatrix[2]] . 

TensorProduct[{{1, 0}, {0, e^(-i*pi/4)}}, IdentityMatrix[2], IdentityMatrix[2]] .

TensorProduct[{{1, 0}, {0, e^(i*pi/4)}}, IdentityMatrix[2], IdentityMatrix[2]] . 

TensorProduct[{{1, 0}, {0, e^(-i*pi/4)}}, IdentityMatrix[2], IdentityMatrix[2]] . 

TensorProduct[{{1, 0}, {0, e^(i*pi/4)}}, {{1, 0}, {0, e^(-i*pi/4)}}, IdentityMatrix[2]] .

TensorProduct[(1/Sqrt[2]){{1, 1}, {1, -1}}, IdentityMatrix[2], IdentityMatrix[2]] . 

TensorProduct[IdentityMatrix[2], {{1, 0}, {0, e^(-i*pi/4)}}, IdentityMatrix[2]] . 

TensorProduct[IdentityMatrix[2], {{1, 0}, {0, -1}}, {{1, 0}, {0, e^(i*pi/4)}}]
</code></pre>
<p>Here is what ChatGPT came up with in Sage/Python:</p>
<pre><code>from sage.matrix.constructor import matrix
from sage.symbolic.constants import pi
from sage.functions.trig import exp

# Define matrices
A = (1/sqrt(2)) * matrix([[1, 1], [1, -1]])
B = matrix.identity(2)

# Compute the result of the sequential matrix products
result = A.tensor_product(B).tensor_product(B) * \
     matrix([[1, 0], [0, exp(-I*pi/4)]]) \
     * matrix([[1, 0], [0, exp(I*pi/4)]]) \
     * matrix([[1, 0], [0, exp(-I*pi/4)]]) \
     * matrix([[1, 0], [0, exp(I*pi/4)]]) \
     * matrix([[1, 0], [0, exp(-I*pi/4)]]) \
     * A.tensor_product(B).tensor_product(B) \
     * B.tensor_product(matrix([[1, 0], [0, exp(-I*pi/4)]])) \
     * B.tensor_product(matrix([[1, 0], [0, -1]])) \
     * matrix([[1, 0], [0, exp(I*pi/4)]])

# Display the result
print(result)
</code></pre>
",<programming><circuit-construction><quantum-circuit><toffoli-gate>,05/03/2024 18:07,38130.0,38130.0,"<p>The main problem is that ChatGPT completely ignores CNOT gates in both cases (and <span class=""math-container"">$S$</span> gate as well). What is more, you need not only CNOT for two adjacent qubits but also CNOT for non-adjacent qubits. How to construct a matrix for controlled gates with non-adjacent qubits is described in my other answer <a href=""https://quantumcomputing.stackexchange.com/questions/17650/tool-to-verify-cnot-or-any-interacting-2-qubit-gate/17664"">here</a>. In the answer, I also provided matrix for CNOT acting on first and last qubit in your circuit.</p>
<p>But back to the code you are looking for. Below is the code for MatLab (or Octave). You can easily rewrite it to any other language. You can inspire by answer by ChatGPT in your question but replace matrices with correct ones. Note that function <code>kron</code> stands for tensor (Kronecker) product.</p>
<p>Please note that my code is for upside-down Toffoli, i.e. a target qubit is the lowest one (see a schematic <a href=""https://cs.stackexchange.com/questions/69725/understanding-implemetation-of-the-toffoli-gate-using-other-gates"">here</a>). If you run it, in variable <code>TOF</code>, there is this matrix:
<span class=""math-container"">$$
\begin{pmatrix}
   1  &amp; 0  &amp; 0 &amp;  0 &amp;  0 &amp;  0 &amp;  0 &amp;  0\\
   0  &amp; 1  &amp; 0 &amp;  0 &amp;  0 &amp;  0 &amp;  0 &amp;  0\\
   0  &amp; 0  &amp; 1 &amp;  0 &amp;  0 &amp;  0 &amp;  0 &amp;  0\\
   0  &amp; 0  &amp; 0 &amp;  1 &amp;  0 &amp;  0 &amp;  0 &amp;  0\\
   0  &amp; 0  &amp; 0 &amp;  0 &amp;  1 &amp;  0 &amp;  0 &amp;  0\\
   0  &amp; 0  &amp; 0 &amp;  0 &amp;  0 &amp;  1 &amp;  0 &amp;  0\\
   0  &amp; 0  &amp; 0 &amp;  0 &amp;  0 &amp;  0 &amp;  0 &amp;  1\\
   0  &amp; 0  &amp; 0 &amp;  0 &amp;  0 &amp;  0 &amp;  1 &amp;  0\\
\end{pmatrix},
$$</span>
which is clearly Toffoli gate.</p>
<p>So, here is the code:</p>
<pre class=""lang-matlab prettyprint-override""><code>%define gates
ID = eye(2); %identity operator
H = (1/sqrt(2))*[1 1; 1 -1]; %Hadamard
S = [1 0; 0 exp(i*pi/2)]; %S gate
T = [1 0; 0 exp(i*pi/4)]; %T gate
Tdag = [1 0; 0 exp(-i*pi/4)]; %inverse of T gate
X = [0 1; 1 0]; %Pauli X - negation
CNOT_12 = [eye(2) zeros(2); zeros(2) X]; %CNOT on adjacent qubits
CNOT_13 = [eye(4) zeros(4); zeros(4) kron(eye(2), X)]; %CNOT between first and last qubits

%construct Toffoli gate
TOF = kron(kron(ID,ID),H);
TOF = kron(ID, CNOT_12) * TOF;
TOF = kron(kron(ID,ID),Tdag) * TOF;
TOF = CNOT_13 * TOF;

TOF = kron(kron(ID,ID),T) * TOF;
TOF = kron(ID, CNOT_12) * TOF;
TOF = kron(kron(ID,ID),Tdag) * TOF;
TOF = CNOT_13 * TOF;

TOF = kron(kron(ID,Tdag),T)*TOF;
TOF = kron(CNOT_12,H) * TOF;
TOF = kron(kron(ID,Tdag),ID)*TOF;
TOF = kron(CNOT_12,ID) * TOF;
TOF = kron(kron(T,S),ID)*TOF;

TOF %print matrix stored in variable TOF
</code></pre>
",05/03/2024 18:53, Errors,"The user is encountering errors in implementing the code provided by ChatGPT to evaluate a quantum circuit in computer algebra systems like Sage, Python, or Mathematica. They seek assistance in rectifying these errors.",Conceptual,"This question falls under the Conceptual category because it seeks help in understanding how to evaluate a quantum circuit using computer algebra systems like Sage, Python, or Mathematica, indicating a conceptual understanding of quantum circuit evaluation",No,147.0, Errors,"The user is encountering errors in implementing the provided code snippets in Mathematica and Sage/Python to evaluate a quantum circuit in computer algebra systems. They seek assistance in rectifying these errors, indicating a problem-solving inquiry related to resolving errors in code implementation."
38132.0,weird negative sign in a state vector in qiskit,"<p>I run the following simple code in qiskit, which get statevector of a quantum circuit.</p>
<pre><code>qc = QuantumCircuit(3)
qc.initialize(
    [
        0.0 + 0.0j,
        sqrt(1 / 3) + 0.0j,
        0.0 + 0.0j,
        0.0 + 0.0j,
        0.0 + 0.0j,
        0.0 + 0.0j,
        0.0 + 0.0j,
        sqrt(2 / 3) + 0.0j,
    ]
)
qc.cry(pi / 2, 1, 0) # (theta, controlled bit, target bit)

print(Statevector(qc))
</code></pre>
<p>The output is the following:</p>
<pre><code>Statevector([ 0.        +0.j,  0.57735027+0.j,  0.        +0.j,
              0.        +0.j,  0.        +0.j,  0.        +0.j,
             -0.57735027+0.j,  0.57735027+0.j],
            dims=(2, 2, 2))
</code></pre>
<p>I expected that the sign of |011&gt; = |6&gt; is plus, however it seems minus....</p>
<p>Am I wrong? or What is the problem here?
Thank you in advance!</p>
",<qiskit><quantum-state><programming>,05/03/2024 20:19,38138.0,38138.0,"<p>We start with the state, <span class=""math-container"">$$\sqrt{1/3}|001\rangle + \sqrt{2/3}|111\rangle$$</span></p>
<p>Then apply <span class=""math-container"">$R_y(\pi/2)$</span> to the first qubit controlled by the second qubit. By linearity, we can calculate the impact of applying this gate to each basis state individually.</p>
<p>The basis state <span class=""math-container"">$|001\rangle$</span> will not impacted since the second qubit in state <span class=""math-container"">$|0\rangle$</span>. On the other hand, the basis state <span class=""math-container"">$|111\rangle$</span> will be impacted.</p>
<p>We have,
<span class=""math-container"">$$
R_y(\theta) = \left( {\begin{array}{*{20}{c}} \cos(\theta/2)&amp;-\sin(\theta/2) \\ \sin(\theta/2)&amp;\cos(\theta/2) \end{array}} \right)
$$</span></p>
<p>Multiply the state of the first qubit by this matrix when <span class=""math-container"">$\theta = \frac{\pi}{2}$</span>,</p>
<p><span class=""math-container"">$$\left( {\begin{array}{*{20}{c}} \frac{1}{\sqrt{2}}&amp;\frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}} \end{array}} \right) \left( {\begin{array}{*{20}{c}} 0 \\ 1 \end{array}} \right) = \left( {\begin{array}{*{20}{c}} \frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{array}} \right)$$</span></p>
<p>So, the final state will be,
<span class=""math-container"">$$\frac{\sqrt{3}}{3} |001\rangle- \frac{\sqrt{3}}{3} |110\rangle+\frac{\sqrt{3}}{3} |111\rangle$$</span></p>
",05/04/2024 06:08, Errors,The user is encountering unexpected results in the statevector obtained from a quantum circuit in Qiskit. They expect the sign of a specific state to be positive but observe it as negative. They seek clarification on whether their expectation is incorrect or if there is a problem with their code., Errors,,,, Errors,
38255.0,How to correctly compute expectation value in QAOA?,"<p>In QAOA after prepating <span class=""math-container"">$|\psi(\gamma, \beta) \rangle$</span>, expectation value <span class=""math-container"">$\langle \psi(\gamma, \beta)|H_c|\psi(\gamma, \beta) \rangle$</span> is computed. In tutorials, I see two approaches to this calculation.
The first is to calculate the expectation of an observable <span class=""math-container"">$H_c$</span>, as in <a href=""https://pennylane.ai/qml/demos/tutorial_qaoa_maxcut/"" rel=""nofollow noreferrer"">this demo</a>, which I imagine adds some CNOT gates, because measurement in <span class=""math-container"">$Z \otimes Z$</span> is accomplished by CNOT, as shown <a href=""https://learn.microsoft.com/en-us/azure/quantum/concepts-pauli-measurements"" rel=""nofollow noreferrer"">here</a>. My code for this approach is as follows, using Pennylane (I am using the Ising model):</p>
<pre class=""lang-python prettyprint-override""><code>def construct_cost_hamiltonian(h, J):
    coeffs = []
    obs = []

    # Add terms for individual variables
    for k, v in h.items():
        coeffs.append(v)
        obs.append(qml.PauliZ(k))

    # Add terms for interactions between variables
    for k, v in J.items():
        coeffs.append(v)
        obs.append(qml.PauliZ(k[0]) @ qml.PauliZ(k[1]))
    return qml.Hamiltonian(coeffs, obs)

cost_h = construct_cost_hamiltonian(h, J)

@qml.qnode(dev)
def cost_function(params):
    if len(params.shape) &lt; 2:
        params = np.split(params, 2)
    qaoa_circuit(params[0], params[1], h, J)
    return qml.expval(cost_h)
</code></pre>
<p>The second approach is to measure bitstrings, map them to <span class=""math-container"">$-1,1$</span> and compute the average of <span class=""math-container"">$x^T H_c x$</span>, which makes sense since we get the final result just by measuring, and <span class=""math-container"">$x^T H_c x$</span> is our objective. This approach was used in <a href=""https://github.com/amazon-braket/amazon-braket-examples/blob/main/examples/hybrid_quantum_algorithms/QAOA/QAOA_braket.ipynb"" rel=""nofollow noreferrer"">this demo</a>. My implementation as follows:</p>
<pre class=""lang-python prettyprint-override""><code>@qml.qnode(dev)
def samples_circuit(params):
    if len(params.shape) &lt; 2:
        params = np.split(params, 2)
    qaoa_circuit(params[0], params[1], h, J)
    return qml.sample()

samples = samples_circuit(params)

H = np.zeros((number_of_variables, number_of_variables))
for i in range(0, number_of_variables):
    H[i, i] = h[(i,)]
    for j in range(i+1, number_of_variables):
        H[i, j] = J[i, j]

expect_val = 0
for sample in samples:
    sample_ising = -2*sample + 1
    expect_val += sample_ising.T @ H @ sample_ising
expect_val /= samples.shape[0]
</code></pre>
<p>And these two approaches (in my code) give drastically different results with the same parameters. So what approach is correct? Or what is my mistake?</p>
",<programming><quantum-algorithms><qaoa><pennylane>,05/11/2024 23:48,38289.0,38289.0,"<p>My mistake is that I compute <span class=""math-container"">$x^T H_c x$</span> instead of <span class=""math-container"">$xh + x^T J x$</span>, since if I put <span class=""math-container"">$h$</span> terms on the diagonal of <span class=""math-container"">$H_c$</span>, all coefficients of <span class=""math-container"">$h_i$</span> would be equal to one regardless of <span class=""math-container"">$x_i=1$</span> or <span class=""math-container"">$x_i=-1$</span>, because of squaring. Corrected code:</p>
<pre class=""lang-python prettyprint-override""><code>h_vector = np.zeros((number_of_variables))
J_matrix = np.zeros((number_of_variables, number_of_variables))
for i in range(0, number_of_variables):
    h_vector[i] = h[(i,)]
    for j in range(i+1, number_of_variables):
        J_matrix[i, j] = J[i, j]

expect_val = 0
for sample in samples:
    sample_ising = -2*sample + 1
    expect_val += h_vector @ sample_ising + sample_ising @ J_matrix @ sample_ising
expect_val /= samples.shape[0]
</code></pre>
<p>Now both approaches give similar numerical results. But I'm still not 100% sure that they are equivalent theoretically.</p>
",5/14/2024 10:56, Errors,The user is encountering discrepancies in results between two different approaches for computing the expectation value in QAOA. They seek clarification on which approach is correct or where their mistake lies., Errors,,,, Errors,
18157.0,How efficient is Qiskit's unitary decomposition?,"<p>In Qiskit's extension package we have the <code>UnitaryGate</code> module that you can initialize using a unitary matrix and then add it to your circuit. How efficiently is this decomposition done under the hood?</p>
<p>Also, if I wanted to do the decomposition myself, what's the best way of doing so?</p>
",<programming><qiskit><quantum-gate><unitarity><universal-gates>,6/27/2021 19:32,18160.0,18160.0,"<p>For 2x2 unitary, it is just a <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.U3Gate.html"" rel=""nofollow noreferrer"">U3-gate</a>.</p>
<p>For 4x4 unitary, <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.TwoQubitBasisDecomposer.html"" rel=""nofollow noreferrer""><code>TwoQubitBasisDecomposer</code></a> is used. <code>TwoQubitBasisDecomposer</code> implements KAK decomposition method described in <a href=""https://arxiv.org/abs/0806.4015"" rel=""nofollow noreferrer"">arXiv:0806.4015</a> by Drury and Love. This method uses optimal number of CNOT gates.</p>
<p>For larger unitaries, <a href=""https://qiskit.org/documentation/_modules/qiskit/extensions/quantum_initializer/isometry.html"" rel=""nofollow noreferrer""><code>Isometry</code></a> class is used. This class implements the method introduced by Iten et al. in <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">arXiv:1501.06911</a>. This method achieves the theoretical lower bound on the number of used CNOT gates.</p>
<hr />
<p><strong>Update</strong>: In Qiskit version 0.37 a new module <code>qiskit.quantum_info.synthesis.qsd</code> is added to apply Quantum Shannon Decomposition of arbitrary unitaries. This functionality replaces the previous isometry-based approach.</p>
<p>The Quantum Shannon Decomposition (<a href=""https://arxiv.org/abs/quant-ph/0406176"" rel=""nofollow noreferrer"">arXiv:quant-ph/0406176</a>) uses about half the CNOT gates as the isometry implementation when decomposing unitary matrices of greater than two qubits.</p>
",6/28/2021 7:57,API Usage,The user is inquiring about the efficiency of the decomposition process used by Qiskit's UnitaryGate module and how to perform the decomposition manually. This falls under API Usage as it pertains to understanding and utilizing specific features of the Qiskit API., Conceptual,"This question falls under the Conceptual category because it seeks understanding about the internal workings of a specific feature in Qiskit (UnitaryGate module) and the best practices for manually decomposing unitary matrices, indicating a conceptual inquiry into the underlying mechanisms rather than practical implementation details or errors.",No,148.0,Conceptual,"The user is seeking to understand the efficiency of Qiskit's UnitaryGate decomposition and the best way to perform such a decomposition manually. This indicates a conceptual inquiry into the underlying mechanisms and best practices, rather than focusing on practical implementation or error resolution."
