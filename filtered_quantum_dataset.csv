QuestionId,QuestionTitle,QuestionBody,QuestionTags,QuestionDate,AcceptedAnswerId,AnswerId,Answer Body,AnswerDate
3163234.0,"Does anyone know what ""Quantum Computing"" is?","In physics, its the ability for particles to exist in multiple/parallel dynamic states at a particular point in time. In computing, would it be the ability of a data bit to equal 1 or 0 at the same time, a third value like NULL[unknown] or multiple values?.. How can this technology be applied to: computer processors, programming, security, etc.?.. Has anyone built a practical quantum computer or developed a quantum programming language where, for example, the program code dynamically changes or is autonomous?",<language-agnostic><quantum-computing>,07/02/2010 04:28,3175933.0,3175933.0,"I have done research in quantum computing, and here is what I hope is an informed answer. It is often said that qubits as you see them in a quantum computer can exist in a ""superposition"" of 0 and 1. This is true, but in a more subtle way than you might first guess. Even with a classical computer with randomness, a bit can exist in a superposition of 0 and 1, in the sense that it is 0 with some probability and 1 with some probability. Just as when you roll a die and don't look at the outcome, or receive e-mail that you haven't yet read, you can view its state as a superposition of the possibilities. Now, this may sound like just flim-flam, but the fact is that this type of superposition is a kind of parallelism and that algorithms that make use of it can be faster than other algorithms. It is called randomized computation, and instead of superposition you can say that the bit is in a probabilistic state. The difference between that and a qubit is that a qubit can have a fat set of possible superpositions with more properties. The set of probabilistic states of an ordinary bit is a line segment, because all there is a probability of 0 or 1. The set of states of a qubit is a round 3-dimensional ball. Now, probabilistic bit strings are more complicated and more interesting than just individual probabilistic bits, and the same is true of strings of qubits. If you can make qubits like this, then actually some computational tasks wouldn't be any easier than before, just as randomized algorithms don't help with all problems. But some computational problems, for example factoring numbers, have new quantum algorithms that are much faster than any known classical algorithm. It is not a matter of clock speed or Moore's law, because the first useful qubits could be fairly slow and expensive. It is only sort-of parallel computation, just as an algorithm that makes random choices is only in weak sense making all choices in parallel. But it is ""randomized algorithms on steroids""; that's my favorite summary for outsiders. Now the bad news. In order for a classical bit to be in a superposition, it has be a random choice that is secret from you. Once you look a flipped coin, the coin ""collapses"" to either heads for sure or tails for sure. The difference between that and a qubit is that in order for a qubit to work as one, its state has to be secret from the rest of the physical universe, not just from you. It has to be secret from wisps of air, from nearby atoms, etc. On the other hand, for qubits to be useful for a quantum computer, there has to be a way to manipulate them while keeping their state a secret. Otherwise its quantum randomness or quantum coherence is wrecked. Making qubits at all isn't easy, but it is done routinely. Making qubits that you can manipulate with quantum gates, without revealing what is in them to the physical environment, is incredibly difficult. People don't know how to do that except in very limited toy demonstrations. But if they could do it well enough to make quantum computers, then some hard computational problems would be much easier for these computers. Others wouldn't be easier at all, and great deal is unknown about which ones can be accelerated and by how much. It would definitely have various effects on cryptography; it would break the widely used forms of public-key cryptography. But other kinds of public-key cryptography have been proposed that could be okay. Moreover quantum computing is related to the quantum key distribution technique which looks very safe, and secret-key cryptography would almost certainly still be fairly safe.",07/04/2010 19:24
7118933.0,Need an explanation for a quantum model,"When I am reading chapter 10 of Dasgupta I faced a paragraph that I can't understand: An electron can be in a ground state or in an excited state. In the Dirac notation used in quantum physics, these are denoted 0 and 1. But the superposition principle says that, in fact, the electron is in a state that is a linear combination of these two: a0|0> + a1|1>. This would make immediate sense if the a's were probabilities, nonnegative real numbers adding to 1. But the superposition principle insists that they can be arbitrary complex numbers, as long as the squares of their norms add up to 1! Can someone describe me last 3 lines?",<algorithm><quantum-computing>,8/19/2011 8:33,7119177.0,7119177.0,"I think the author is trying to point out a difference between the quantum model and the standard assumptions you might have about probabilities. Suppose, for example, that the electron is either up or down. In a deterministic universe, it would either be 100% up or 100% down. If we assumed that the electron probabilistically chose to be either up or down with some probabilities, then we might say that, for example, the electron was 50% up and 50% down. When using bra-ket notation for the above, you might be tempted to say that we would say that the particle is 90% up by writing 0.5 |up&gt; + 0.5|down&gt; The intuition being that the electron is simultaneously 50% up and 50% down. However, this would be incorrect. When dealing with quantum states, the configuration of a particle is related to something called the wavefunction, and it is the square of the wavefunction that determines probabilities, not the wavefunction itself. Thus if we wanted to write out a quantum state where a particle has a 50% chance of being up and a 50% chance of being down, we'd represent that as 0.707 |up> + 0.707 |down> Since 0.707 is about the square root of 0.5, so if we square the coefficients assigned to up and down we get back the classical probabilities. As long as the squares of the coefficients sum to one, the coefficients are legal since their square gives back a probability distribution. Of course, it's actually a bit trickier than this. The coefficients in quantum states can be complex numbers as well. For example, this is a perfectly legal quantum configuration: (0.707 + 0.707i) |up&gt; + 0 |down&gt; Here, the coefficient for up is a complex number. To get the probability of seeing up, we compute the complex conjugate of the coefficient: (0.707 + 0.707i)(0.707 - 0.707i) = (0.5 + 0.5) = 1 So in this case the probability of seeing up is 1 and the probability of seeing down is 0^2 = 0. Since this sums to one, this is a valid quantum state. To summarize: a probability distribution is a way of assigning real-valued weights to outcomes so that the weights sum to one. A quantum state is a way of assigning complex-valued weights to outcomes so that the sum of the product of each coefficient with it's complex conjugate is one. Phew! Haven't had to think about that in a while! Hope this helps!",8/19/2011 8:54
9672369.0,floor and ceil from QCL (Quantum Computer Language),"I'm working on QCL and some questions came up about internal functions. I'd like to know what the operators floor(something) and ceil(something) are. I know they are related to math operations, but what do they do exactly?",<operators><quantum-computing><qcl>,03/12/2012 18:04,9672397.0,9672397.0,"Floor removes the decimal point, ceil turns the decimal part into .9999 repeating if it's already there (which is the same as a whole number). So floor(4.6) loses the .6, ceil(4.6) becomes 4.9999... or 5. Also, ceil(5.0) will return 5, as the decimal part is 0.",03/12/2012 18:06
9894420.0,"Operator ""measure"" in QCL (Quantum Computing Language)","It's been a while since I got into QCL but I ran into some difficulties by trying to figure out the functioning of measure regX or measure regX,m. What does this do on the quantum registers? And the m integer?",<quantum-computing><qcl>,3/27/2012 17:17,9926184.0,9926184.0,"In Bernhard's Ãmer PhD thesis Structured Quantum Programming, in Appendix A.3.1.4 clearly states that measure regX -- performs measurement on register regX and measure regX,m -- performs measurement on register regX and writes the result of the measurement to classical variable m. If you do not understand the model behind quantum measurement it is difficult to fully understand what QCL does. But roughly speaking measurement chooses randomly one of the basis quantum states which spans the quantum superposition in which regX is and writes it to variable m.",3/29/2012 13:20
12567514.0,Quantum computers and algorithm performance,"I have a question. Gradually quantum computers will emerge someday. So, nowadays making algorithm efficient is important; I mean, making it optimal to run as fast as possible. But once quantum PC emerges does the algorithm performance improvements are still important? Cheers",<algorithm><quantum-computing>,9/24/2012 14:52,12567721.0,12567721.0,"Quantum algorithms have the possibility of searching a complete number space for an answer in one go, that much is true. However, the algorithm you choose will still determine how many of these steps are needed, and whether you can pack the whole space with useful inputs.",9/24/2012 15:02
13774439.0,Generalization of the Deutsch algorithm,"This problem concerns a straightforward generalization of the Deutsch problem discussed for functions with more than one bit as input. This time, we have a Boolean function f that takes a 4-bit number as input and outputs 0 or 1, i.e., f:{0,1}4â{0,1}. Thus, an input to f is one of 16 possible 4 bit binary numbers: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111. We are also told that f is one of the following two types: either f is a constant function, i.e., f(x) is the same for all 16 possible values of the input x, or f is a balanced function, i.e., f(x) is 0 for exactly 8 of the possible 16 inputs and f(x) is 1 for the remaining 8 of the possible 16 inputs. we are allowed to do is to use the circuit for f as a ""black box"" by giving an input x to the circuit for f and observing the output f(x). This is called a ""query"" operation. Show that a classical probabilistic algorithm can determine if f is balanced or constant with probability at least 2/3 by using 2 queries. Hint: (Obviously, we cannot do this using a deterministic algorithm. Unless the deterministic algorithm sees the output for at least 9 input values, there is no way for it to find out if the function is balanced or constant). Think about picking the two inputs uniformly and randomly from the set of 16 possible inputs. Your final result could depend probabilistically on the result of these two queries.",<algorithm><probability><quantum-computing>,12/08/2012 04:20,13775208.0,13775208.0,"EDIT: I had calculated some of my probabilities wrongly. Also I've now mentioned that we need to randomly pick 2 distinct inputs for the function f in order to guarantee that, if f is balanced, then we know the probabilities of seeing the various possible outcomes. The fact that the prior probability of the function being constant is not known makes this question harder, because it means we can't directly calculate the probability of success for any algorithm. We will, however, be able to calculate bounds on this probability. I propose the following probabilistic algorithm: Pick two distinct 4-bit values at random, and supply each to the function f. If 0,0 or 1,1 is seen, output ""constant"" with probability 2/3 and ""balanced"" with probability 1/3. Otherwise (if 0,1 or 1,0 is seen), always report ""balanced"". Let's start by looking at something we can actually calculate: conditional probabilities. ""What is P(correct|constant), namely the probability that our algorithm gives the correct answer given that f is constant?"" When f is constant, our algorithm reports the right answer 2/3 of the time. ""What is P(correct|balanced), namely the probability that our algorithm gives the correct answer given that f is balanced?"" When f is balanced, the probability of seeing 0,1 or 1,0 is 2*(8/16 * 8/15) = 8/15, in which case the correct answer will definitely be output. In the remaining 7/15 of cases -- i.e. those in which 0,0 or 1,1 is seen -- the correct answer will be output 1/3 of the time, so the total proportion of correct outputs will be 8/15 * 1 + 7/15 * 1/3 = 31/45 = 2/3 + 1/45 â 0.6889. Now suppose that the prior probability of the function being constant is p. Then the probability that the algorithm gives the correct answer is pCorrect(p) = p*P(correct|constant) + (1-p)*P(correct|balanced). Given that 0 &lt;= p &lt;= 1, pCorrect(p) must be at least min(P(correct|constant), P(correct|balanced)), and at most max(P(correct|constant), P(correct|balanced)). The minimum of 2/3 and 31/45 is 2/3, thus pCorrect is bounded from below at 2/3, for any prior probability of the function being constant. (It might help to think of p as a ""mixing lever"" that controls how much of each term to include. If p = 0 or p = 1, then we effectively just have P(correct|balanced) or P(correct|constant), respectively, and for any in-between value of p, we will have an in-between total.)",12/08/2012 06:41
32037970.0,From an application programmer's perspective - Can Functional Programming be used to program Quantum Computers?,"I'm not an expert in Functional Programming (FP). In fact, I just started learning it. So, here is the real question: Since, FP is derived from Mathematics and not from von. Neumann machine, can this programming style/paradigm be used to program Quantum Computers? This is more from an application programmer's perspective since low-level machine instructions may be completely different.",<functional-programming><quantum-computing>,8/16/2015 17:27,32038459.0,32038459.0,"No. Functional programs still perform classical computation. The functional style as we currently define it has nothing resembling superposition, quantum mechanical gates, or interference. While it is possible to transport the general idea of higher-order and first-class functions into the realm of quantum computation (and people are researching that right now), just as there are quantum Turing machines, as far as I can tell the results are as different from classical functional programming as quantum algorithms are from classical algorithms. For example, in QML if ... then ... else ... is removed in favor of a similar conditional where the condition is a qbit and the result is a superposition of the then and else values. Now, of course quantum computers are Turing-complete and could, in theory, execute any classical algorithm. But why on earth would you do that? We already have classical computers, and they are (and will always be) much more efficient at executing classical computations. The only reason to program a quantum computer is to make it run an algorithm that exploits in a nontrivial way the weirdness of quantum effects. To even express that, one needs a very different language regardless of the level of abstraction at which you work.",8/16/2015 18:24
41831217.0,Qutip commutation relations,"What is the reason the commutation relation fails on the last state N=7 M=6 commutator(position(N),momentum(N))*basis(N,M)==1.0j*basis(N,M) and similarly for the create and destroy commutator?",<python><qutip>,1/24/2017 14:51,41842383.0,41842383.0,"Because you are in a truncated Hilbert space, and your excitation is in the upmost level. Thus a creation operator promotes you out of the Hilbert space.",1/25/2017 2:22
43893163.0,Python â ImportError: cannot import name X,"Iâm trying to run a single python script â which has worked in the past â using a couple modules. Some Googling suggested circular dependencies however that is only relevant for two files importing modules that depend on one another. It seems to boil down to scalarmath not being found but I don't know why. My code is just simple functions defs for calculations and then calling those functions (all in one file). The output of my IDE is: C:\Users\sg15\AppData\Local\Continuum\Anaconda2\python.exe ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py"" Traceback (most recent call last): File ""P:/Solid State QT/NSMM/simulations/InteractionsOfTLF.py"", line 13, in &lt;module&gt; import matplotlib.pyplot as plt File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\__init__.py"", line 122, in &lt;module&gt; from matplotlib.cbook import is_string_like, mplDeprecation, dedent, get_label File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\matplotlib\cbook.py"", line 33, in &lt;module&gt; import numpy as np File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\__init__.py"", line 185, in &lt;module&gt; from . import add_newdocs File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\add_newdocs.py"", line 13, in &lt;module&gt; from numpy.lib import add_newdoc File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\__init__.py"", line 8, in &lt;module&gt; from .type_check import * File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\lib\type_check.py"", line 11, in &lt;module&gt; import numpy.core.numeric as _nx File ""C:\Users\sg15\AppData\Local\Continuum\Anaconda2\lib\site-packages\numpy\core\__init__.py"", line 20, in &lt;module&gt; from . import scalarmath ImportError: cannot import name scalarmath Process finished with exit code 1",<python><windows><numpy><anaconda><qutip>,05/10/2017 12:56,43917952.0,43917952.0,"It turns out the solution was a classic uninstall reinstall jobby. It seemed that the packages became incompatible with a recent Windows update or an update to the packages themselves. Steps to fix (in case you need them): 1) Run python in a separate program, and try to import a library e.g. import numpy. You should still see the output error message in the image that was shown in the question. This indicates that it is not a local problem to our code. Close that python program/console/whatever. 2) Open command prompt (cmd) and run conda (command: conda). Then run the commands conda install numpy and conda install matplotlib. Click yes [y] to any options that are presented. These commands depend on which libraries were causing you trouble, of course. 3) In your python IDE's console, import the libraries again i.e. import numpy and import matplotlib. Run your code and you it should build just fine (providing you have no other bugs) Note: You may have to uninstall the offending libraries giving you trouble in your conda environment in the Anaconda Navigator. To do this, select your conda environment (mine was called qutip) and remove the troublesome packages. They were matplotlib and numpy in this case.",05/11/2017 14:14
47710012.0,"A book that contains, Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm","I am looking for a book that contains descriptions of the topics: Shor's algorithm, McEliece cryptosystem, Lattice-based cryptography, Discrete logarithm; and possibly others. Does anyone know a single book or a few that would contain there topics?",<algorithm><encryption><cryptography><quantum-computing>,12/08/2017 07:57,47710199.0,47710199.0,"There is ""Post-Quantum Cryptography"" published by Daniel J. Bernstein. The book is more of a general overview and doesn't go that far into details. It contains sections about lattice based, hash based and code based cryptography. Shor's algorithm as well as discrete logarithm aren't handled in depth, but there is a general overview. I think the best way to get into the details is by studying the respective scientific papers.",12/08/2017 08:13
48303829.0,"Loop in python which appends answers to a list, I want to then create new list from this","This is the part of my code which works fine; #taking time average average= sum(result.expect[0])/len(t) averagelist=[] averagelist.append([num-Delta, average]) print(averagelist) Giving output; [[-50, 0.99994894092412567]] [[-45, 0.9999371327219414]] [[-40, 0.99992064521708557]] [[-35, 0.99989662709502258]] [[-30, 0.99985966374414359]] [[-25, 0.99979843838324323]] [[-20, 0.99968609192147129]] [[-15, 0.99944283644552467]] [[-10, 0.99874864586107459]] [[-5, 0.99499296595818931]] [[0, 0.50250021597634276]] Now I want to be able to make a new list x= -50,-45,-40 etc and new list y= 0.999..., 0.999..., 0.999... etc Is there a simple way to do this? (I have also tried the extend as oppose to append function, and this gives me the same initial output but with one square bracket not two.)",<python><list><append><qutip>,1/17/2018 14:49,48303900.0,48303900.0,You could use this : list_x = [i[0] for i in averagelist] list_y = [i[1] for i in averagelist],1/17/2018 14:53
48453676.0,Python Multiprocessing Error with IBM API (Q Experience),"I'm trying to use the IBM Q Experience API and I installed the library and wrote a quick test code. At first, it couldn't find the module. Then, I added the whole sys thing. Admittedly, I just copied that from a stackoverflow post so that may be the problem. Anyways, I got ""RunTime Error"" which leads to the python multiprocessing lib. The IBM Q doesn't have a big community, so I couldn't find anything after researching a little while. I'm completely unfamiliar with multiprocessing, threading, etc, so I imagine just seeing the code and error will be better than anything I can do to explain. Thanks in advance. import sys sys.path.append(""../../"") from qiskit import QuantumProgram #visualization from tools.visualization import plot_histogram #set up registers qp = QuantumProgram() q = qp.create_quantum_register(""q"", 3) c = qp.create_classical_register(""c"", 3) #define our circuit threeQ = qp.create_circuit(""threeQ"", [q], [c]) threeQ.measure(q[0], c[0]) threeQ.measure(q[1], c[1]) threeQ.measure(q[2], c[2]) #run result = qp.execute([""threeQ""]) #plot plot_histogram(result.get_counts(""threeQ"")) The error I get (sorry, it's long): Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path pkg_name=pkg_name, script_name=fname) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code mod_name, mod_spec, pkg_name, script_name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code exec(code, run_globals) File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt; print(qp.execute([""threeQ""])) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute result = self.run(qobj, wait=wait, timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal job_processor.submit() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit future = executor.submit(run_backend, q_job) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit self._start_queue_management_thread() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread self._adjust_process_count() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count p.start() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start self._popen = self._Popen(self) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen return _default_context.get_context().Process._Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen return Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__ prep_data = spawn.get_preparation_data(process_obj._name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data _check_not_importing_main() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main is not going to be frozen to produce an executable.''') RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() ... The ""freeze_support()"" line can be omitted if the program is not going to be frozen to produce an executable. Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path pkg_name=pkg_name, script_name=fname) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 96, in _run_module_code mod_name, mod_spec, pkg_name, script_name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 85, in _run_code exec(code, run_globals) File ""C:\Users\Everybody\firstquantum.py"", line 21, in &lt;module&gt; print(qp.execute([""threeQ""])) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1413, in execute result = self.run(qobj, wait=wait, timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1232, in run timeout=timeout) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_quantumprogram.py"", line 1315, in _run_internal job_processor.submit() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\site-packages\qiskit\_jobprocessor.py"", line 118, in submit future = executor.submit(run_backend, q_job) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 454, in submit self._start_queue_management_thread() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 415, in _start_queue_management_thread self._adjust_process_count() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\concurrent\futures\process.py"", line 434, in _adjust_process_count p.start() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\process.py"", line 105, in start self._popen = self._Popen(self) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 212, in _Popen return _default_context.get_context().Process._Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py"", line 313, in _Popen return Popen(process_obj) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\popen_spawn_win32.py"", line 34, in __init__ prep_data = spawn.get_preparation_data(process_obj._name) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 144, in get_preparation_data _check_not_importing_main() File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 137, in _check_not_importing_main is not going to be frozen to produce an executable.''') RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() ... The ""freeze_support()"" line can be omitted if the program is not going to be frozen to produce an executable. Traceback (most recent call last): File ""&lt;string&gt;"", line 1, in &lt;module&gt; File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 106, in spawn_main exitcode = _main(fd) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 115, in _main prepare(preparation_data) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 226, in prepare _fixup_main_from_path(data['init_main_from_path']) File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\multiprocessing\spawn.py"", line 278, in _fixup_main_from_path run_name=""__mp_main__"") File ""C:\Users\Everybody\AppData\Local\Programs\Python\Python35\lib\runpy.py"", line 254, in run_path ERROR",<windows><multiprocessing><runtime-error><quantum-computing><qiskit>,1/25/2018 23:38,48471003.0,48471003.0,"This is a general issue with multi-threading in Python on Windows. The solution is to put your top-level code in an if __name__ == ""__main__"" block, as in: if __name__ == '__main__': &lt;your code here&gt; Hope that helps!",1/26/2018 23:28
49061751.0,Challenges in Enabling Practical-Scale Quantum Computing?,This question will be useful to many. Can we collate a list of challenges in enabling Practical-Scale Quantum Computing? Nathan Aw,<quantum-computing>,03/02/2018 02:13,49329850.0,49329850.0,The challenges are dependent on the physical architecture. Pick a physical implementation and look for which of the DiVincenzo's criterias are missing. These would be the chosen architecture's challenges.,3/16/2018 21:34
49579153.0,Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll',"Getting Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll' error while trying to validate my Q# environment by running the teleport sample program. dotnet build dotnet run platform windows 7 64 bit with AVX enabled. vscode with .NET Core SDK 2.0 Unhandled Exception: System.DllNotFoundException: Unable to load DLL 'Microsoft.Quantum.Simulator.Runtime.dll': The specified module could not be found. (Exception from HRESULT: 0x8007007E) at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator.Init() at Microsoft.Quantum.Simulation.Simulators.QuantumSimulator..ctor(Boolean throwOnReleasingQubitsNotInZeroState, Nullable`1 randomNumberGeneratorSeed, Boolean disableBorrowing) at Microsoft.Quantum.Examples.Teleportation.Program.Main(String[] args) in C:\opt\workspace\quantum\Quantum\Samples\Teleportation\Program.cs:line 13",<c#><.net><visual-studio-code><quantum-computing><q#>,3/30/2018 17:59,49579176.0,49579176.0,"copy the Microsoft.Quantum.Simulator.Runtime.dll from C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\runtimes\win10-x64 to C:\Users\{user}\.nuget\packages\microsoft.quantum.development.kit\0.2.1802.2202-preview\lib\netstandard2.0. Although I have not tested this with the older Microsoft Quantum Development Kit version, there seems to be problem with the 0.2.1802.2202 version. Make sure to check if AVX is avaialble, you can use CPU-Z tool to check that in instructions section. then run dotnet run which should result in the Round 0: Sent False, got False. Teleportation successful!! Round 1: Sent True, got True. Teleportation successful!! Round 2: Sent False, got False. Teleportation successful!! Round 3: Sent False, got False. Teleportation successful!! Round 4: Sent False, got False. Teleportation successful!! Round 5: Sent False, got False. Teleportation successful!! Round 6: Sent False, got False. Teleportation successful!! Round 7: Sent True, got True. Teleportation successful!! Press Enter to continue...",3/30/2018 18:01
51118102.0,Find the length of the array that was passed to you in Q#,I have an operation as follows to which the driver needs to send an array of qubits. operation myOp(qubits: Qubit[]) : () { // uses elements from the qubit array } How do I find the length of this array from within the code?,<arrays><variable-length-array><q#><qubit>,6/30/2018 20:03,51120499.0,51120499.0,let n = Length(qubits) This will store the length in the variable n. Also n is a constant which can't be changed. If for any reason you want a mutable variable n then mutable n = Length(qubits) which can be changed. Now you can iterate through the array using a for loop (works for both constant or mutable n) for(index in 0 .. (n-1)) { //process the element qubits[index] },07/01/2018 04:51
51120653.0,Higher order versions of basic gates Q#,"Is there a higher order H-gate in Q# language? For example, if I want to apply Hadamard gate to an array(combined state) of 3 qubits. Is there a way to generate a tensor product version of H-gate or other gates?",<quantum-computing><q#>,07/01/2018 05:26,51140401.0,51140401.0,"One way to think of it is to think of the unitary operator H = |+â©â¨0| + |ââ©â¨1| and the quantum operation H separately. Taking this view, the unitary H is how we simulate the effect of applying the operation H on an ideal quantum processor. The quantum operation ApplyToEach(H, _) is then represented by the unitary operator H â H â â¯ â H in precisely the same way that H is represented by H. One consequence of this mental model is that the tensor product is defined between unitary operators and not between quantum operations. Rather, the ideal action of quantum operations acting on distinct qubits is represented by the tensor product of the unitary representations of each individual operation.",07/02/2018 16:35
51137397.0,Effect of S-gate on one qubit of a combined(maybe entangled) state of 3 qubits,"Suppose I have a register(qs) of 3 qubits (first 2 being used solely for control, the last one is the input) . The first two control qubits are in the |+&gt; state and the state of the 3rd input is unknown. Let it be a|0&gt; + b|1&gt;. Now I apply CCNOT(qs[0],qs[1],qs[2]) so their combined state becomes 0.5(a,b,a,b,a,b,b,a) in Transposed matrix form [Please correct if I'm wrong here] . Now I apply S-gate to the 3rd qubit which transforms |1&gt; -&gt; i|1&gt; . I am unable to guess the state of the combined state of 'qs' now. What I thought: One logic is to multiply every state by 'i' if it has the form|XY1&gt; so the combined state becomes 0.5(a,ib,a,ib,a,ib,b,ia) [Transposed] Another logic is to find tensor product of (I x I x S) since I'm not changing the first 2 qubits. Performing this yields a different result which is 0.5(a,b,a,b,ia,ib,ib,ia) [Transposed] [Again, correct me if I'm wrong]. Which is the correct output after passing through S-gate (if any) ?",<quantum-computing><q#><qubit>,07/02/2018 13:30,51141626.0,51141626.0,"The first two qubits can't start in |+> state, since |+> is a single-qubit state. I assume that the starting state of the first two qubits in the register is 0.5 (|00&gt; + |01&gt; + |10&gt; + |11&gt;). Both approaches are correct, because they are different ways to represent the same transformation. The first answer 0.5(a,ib,a,ib,a,ib,b,ia) [Transposed] is correct. Your second answer 0.5(a,b,a,b,ia,ib,ib,ia) [Transposed] seems to be obtained by multiplying by S x I x I, i.e., applying S gate on the first qubit instead of the third one. The tensor product I x I x S can be calculated as tensor product of I x I (which is just a 4x4 identity matrix) and S. The result is an 8x8 matrix which consists of 16 copies of S matrix, multiplied by corresponding elements of I x I: 1 0 | 0 0 | 0 0 | 0 0 0 i | 0 0 | 0 0 | 0 0 - - - - - - - - 0 0 | 1 0 | 0 0 | 0 0 0 0 | 0 i | 0 0 | 0 0 - - - - - - - - 0 0 | 0 0 | 1 0 | 0 0 0 0 | 0 0 | 0 i | 0 0 - - - - - - - - 0 0 | 0 0 | 0 0 | 1 0 0 0 | 0 0 | 0 0 | 0 i If you multiply the state of the qubits by this matrix, you'll get the same answer as in the first approach.",07/02/2018 18:09
51774989.0,Q# versus LIQUi|>,"Is Q# meant to be a LIQUiD replacement? It's unclear from the website that's this is true, but I haven't heard anything about LIQUiD since the announcement of Q#. There seems to be a large set of tools in LIQUiD that are not available in Q#, so are these meant to be linked together via .NET? In particular, I am interested in the circuit class and optimizations for QECC in LIQUiD.",<q#>,08/09/2018 20:04,51775417.0,51775417.0,"LiQUi|> (which I'll write Liquid from now on :-)) and Q# have different goals. Liquid is an F#-based platform for simulating quantum circuits. It provides a lot of handy tools and features, like the QECC and noise modelling components you mention. It provides full access to (and manipulation of, if desired) the quantum state, so you can simulate things with Liquid that you could never do on a real quantum system. Finally, Liquid includes some highly-optimized capabilities for simulating Hamiltonian simulations that do a bunch of linear algebra tricks that are not available on a real quantum system. Q# is a high-level language for coding quantum algorithms. Its goal is to let you easily code large quantum applications that would eventually be run on a large quantum system (hundreds of logical, error-corrected qubits). It does support simulation, but as a debugging aid. Put another way, Q# isn't primarily a language for programming quantum simulations, even though that's the way it's used today because of the low availability of large-scale quantum systems. Liquid is still alive. If your focus is on simulation, Liquid is a great choice: you can get direct access to the innards of the simulator, but still code at a high level. Q# is active and growing. While the focus is on actual execution, the Quantum Development Kit already includes both a full state vector simulator and a resource-estimating simulator (the trace simulator). I wouldn't be too surprised if more debugging features, including simulation, are on the way; for instance, the June release added the DumpMachine and DumpRegister operations to allow debugging access to the full state vector.",08/09/2018 20:37
52317000.0,"How to reshape a 2d numpy.array or Qobj into dims=[[2,2],[2,2]]","Numpy example below Goal: QuTiP object The goal of my request is to add two quantum state objects of type Qobj (density matrices) as in the following example of a Werner state (to give it some physical meaning). import qutip as q r = .5 state = r * q.ket2dm(q.ghz_state(2)) + (1-r) * q.maximally_mixed_dm(4) The error message is TypeError: Incompatible quantum object dimensions So one could go to the lower dimensional state but then we loose the relevant dimension properties to proceed with the state: state = r * q.ket2dm(q.ghz_state(2)).data.toarray() + (1-r) * q.maximally_mixed_dm(4) My attempts like q.Qobj(q.maximally_mixed_dm(4).data.toarray().reshape([[2,2],[2,2]])) all failed as reshape does not handle lists of lists. The inverse going from dimensions [[2,2],[2,2]] down to [4,4] is not a miracle using reshape or as shown by the conversion to an array. But is the inverse implemented in either numpy nor qutip? Edit: For people familiar with numpy How do you reshape a 2d array (e.g. here 4x4) in to a (2x2)x(2x2) one? The built in function of numpy seems to dislike my requested example. It does not accept lists of lists as shown here: import numpy as np state = np.identity(4).reshape([[2,2],[2,2]]) I was surprised that no one ever asked this question before!",<python><reshape><qutip>,9/13/2018 15:28,52318325.0,52318325.0,"You are using reshape in the wrong way. It takes a tuple of the dimensions as an argument (see the docs) and not a tuple of tuples or list of lists with the dimensions as elements - how should that work? I think you are mixing the depth of your list of lists with the dimensionality (which are expected to be the numeric entries of the tuple). I am not sure what exactly you wanna end up with but I guess one of the following: state = np.identity(4).reshape((2,2,2,2)) state = np.identity(4).reshape((4,2,2)) state = np.identity(4).reshape((2,2,4))",9/13/2018 16:49
52701261.0,Qiskit NameError: name 'q0' is not defined,"I wrote the following code to implement the Grover's algorithm using 3-qubits. from qiskit import* from qiskit.tools.visualization import* list = [q0,q1,q2] def ccz(qci,q0,q1,q2): qci.h(q2) qci.ccx(q0,q1,q2) qci.h(q2) def grover(qci,q0,q1,q2): ccz(qci,q0,q1,q2) for i in range(list): qci.h(i) qci.x(i) ccz(qci,q0,q1,q2) for i in range(list): qci.x(i) qci.h(i) bn = 3 q = QuantumRegister(bn) c = ClassicalRegister(bn) qc = QuantumCircuit(q,c) for i in range(bn): qc.h(q[i]) grover(qc,q[0],q[1],q[2]) for i in range(bn): qc.measure(q[bn-i-1],c[i]) r = execute(qc,""local_qasm_simulator"").result() rc = r.get_counts() print(rc) plot_histogram(rc) But I got the error below. Why did my Jupyter notebook care only about ""q0"", not other elements in the list? How can I fix this? NameError: name 'q0' is not defined",<python-3.x><qiskit>,10/08/2018 11:27,53456577.0,53456577.0,"It gives you error about q0 because this is the first unknown variable that it encounters. Then it dies. There is improper flow in your program. You try to define the variable list: you try to build it from the variables that are not defined yet, you make it global and try to operate somehow in the functions, where you pass also pass variables as parameters, this name list is not a good choice as it's a python built-in name. Try this one: from qiskit import * from qiskit.tools.visualization import * def ccz(qci, q0, q1, q2): qci.h(q2) qci.ccx(q0, q1, q2) qci.h(q2) def grover(qci, q0, q1, q2): ccz(qci, q0, q1, q2) for i in [q0, q1, q2]: qci.h(i) qci.x(i) ccz(qci, q0, q1, q2) for i in [q0, q1, q2]: qci.x(i) qci.h(i) bn = 3 q = QuantumRegister(bn) c = ClassicalRegister(bn) qc = QuantumCircuit(q, c) for i in range(bn): qc.h(q[i]) grover(qc, q[0], q[1], q[2]) for i in range(bn): qc.measure(q[bn - i - 1], c[i]) r = execute(qc, ""local_qasm_simulator"").result() rc = r.get_counts() print(rc) plot_histogram(rc)",11/24/2018 8:45
53189971.0,QDK file not found error in LiH Simulation,"I am on MacOS. While ""dotnet run"" on unmodified version of ""LithiumHydrideGUI"" I am getting the following unhandled exception as File Not Found for 'Quantum-release-v0.3.1810/Chemistry/LithiumHydrideGUI/..\IntegralData\YAML\LiHData\integrals_lih_sto-3g_0.800.nw.out.yaml'. I do see that the file is very much present in the directory one level up that is at ""Chemistry"" folder. Please let me know how to fix this.",<quantum-computing>,11/07/2018 13:00,53326334.0,53326334.0,"You need to switch the direction of the slashes from ""\"" to ""/"". You will find the line for this in the ""Program"" file.",11/15/2018 19:05
53273082.0,IndexError: list index out of range (Bloch sphere),"I'm trying to build something called a Bloch Sphere, which is the 3-D representation of single quantum bit. Currently, I'm creating a function that develops animation along the x-axis and here is the code that I've written. def x_animation(self): #Y and Z are inputs from users Y1 = self.Y*(-1) Z1 = self.Z*(-1) #number of dots which consists animation length = 10 for i in range(length+1): # an array of X,Y,Z coordinates of 10 dots xgate= [] xgate_y = np.linspace(self.Y,Y1,length+1) xgate_z = np.linspace(self.Z,Z1,length+1) xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)]) plot(xgate[i][0],xgate[i][1],xgate[i][2]) However, I got the error below. IndexError Traceback (most recent call last) &lt;ipython-input-5-f56aa4b3a487&gt; in &lt;module&gt;() ----&gt; 1 q.x_animation() &lt;ipython-input-3-f74dcce093d4&gt; in x_animation(self) 57 xgate_z = np.linspace(self.Z,Z1,length+1) 58 xgate.append([self.X,round(xgate_y[i],1),round(xgate_z[i],1)]) ---&gt; 59 plot(xgate[i][0],xgate[i][1],xgate[i][2]) 60 61 def x_gate(self): IndexError: list index out of range I would appreciate it if anyone help me with solving this problem.",<python-3.x><quantum-computing>,11/13/2018 2:51,53293161.0,53293161.0,"Your code initializes the list xgate to an empty list on each iteration, and then it appends one element to it, thus xgate never has more than one element in it by the time plot is called. But plot tries to access i-th element of xgate, which will succeed on the first iteration and fail on the second one (once i=1). You should be able to fix this by moving list initialization xgate = [] outside of the loop, so that it would actually accumulate the elements. (I'm not sure initialization of xgate_y and xgate_z should be in the loop either, but those are not accumulated and should not cause this kind of an issue.)",11/14/2018 4:23
53925337.0,Q# Intellisense Errors,"I can build my Q# projects fine, but VS 2017 (v. 15.9.4) has the Intellisense errors code QS6103 of ""No namespace with that name exists."" for my first two ""open"" statements shown below. I have tried with both the ""0.3.1811.1501"" and ""0.3.1811.2802"" versions of the SDK and Canon. namespace Quantum.QSharpApplication1 { open Microsoft.Quantum.Primitive; open Microsoft.Quantum.Canon; operation HelloQ () : Unit { Message(""Hello quantum world!""); } }",<visual-studio><visual-studio-2017><q#>,12/25/2018 20:09,53926530.0,53926530.0,"What version of .NET Core do you have installed? (You can check using dotnet --version) I ran into similar problems with Q# IntelliSense not recognizing library namespaces, with .NET Core 2.1.500 and 2.1.403, but with 2.1.402 it works fine. I had to uninstall the higher versions though.",12/26/2018 0:34
54074951.0,how to select unique elements of a list in q#?,"I'm new to q# programming. I have a number list: 1 3 2 3 2 4 5 2 3 6 4 2 1 6 3 2 1 Now, I want to generate unique set of numbers in Q programming language where final output must be: 1 2 3 4 5 6",<list><q#>,01/07/2019 13:02,54083864.0,54083864.0,"There is no library method for this in Q#, so you'd have to implement it yourself. If the range of the possible numbers is small (up to N), you can allocate an extra array of N elements and mark all the numbers that occur in the input array. Otherwise you can sort the input array and return all numbers which differ from the one right before them and right after them. That being said, I wonder why do you need to do this in Q#? Q# is a domain-specific language, so a lot of things which are one or two library calls in general-purpose languages can be rather inconvenient to do in Q#. It is typically much easier to do them in C# or F# driver and pass the result to Q# code as a parameter.",01/08/2019 00:45
54910144.0,Why is the return type Unit used to describe operations that have no return value in Q#; as opposed to void or none?,"Why did Microsoft, when creating Q#, decide to use the keyword Unit instead of void or none, to describe methods that have no return value? Is there a reason for this, or did Microsoft just want to do something different?",<q#>,2/27/2019 16:31,54910622.0,54910622.0,"Functions and operations in Q# are always tuple-in tuple-out. Together with singletonâtuple equivalence (the principle that 'T and ('T) are the exact same type), this lets Q# represent things uniformly, with every function and operation taking exactly one input and returning exactly one output, each of which are tuples. One consequence of this approach that we can write a function like Composed&lt;'T, 'U, 'V&gt;(inner : ('T -&gt; 'U), outer : ('U -&gt; 'V)) : ('T -&gt; 'V), confident that we can pass any function as inner, without thinking about how many arguments it takes. For this design to be consistent, we need that a function or operation that ""returns nothing"" returns an empty tuple rather than no value at all. In many functional languages (including F#), the type of the empty tuple is called unit or Unit, following traditional notation in type theory. In Q#, we decided to follow that tradition to clarify the distinction between the value () and the type Unit.",2/27/2019 16:53
55777679.0,How does CLR compile Q# code that uses or does not make use of qubits?,"If a Q# operation does not use qubits or quatum specific gates, will then the CLR generate bytecode that will be executed by the CPU and not the QPU(quantum processor)?",<clr><q#><qubit>,4/20/2019 20:58,56045697.0,56045697.0,"Yes, exactly. The Q# compiler translates the purely classical parts of your code into C#, which gets compiled (by the C# compiler) into standard .NET MSIL, JITed by the .NET Core runtime, and executed on a normal CPU.",05/08/2019 17:00
57198794.0,How to install Qiskit with only Jupyter Notebook?,I want to use Jupyter Notebook without installing Anaconda on Ubuntu 18.04. I do not want to use any virtual environment. What can I do to install Qiskit? I have tried to install Qiskit with pip3. pip3 install qiskit This shows the following message Segmentation fault (core dumped) But if I try to import qiskit from terminal with this shows no error. But when I try to import qiskit from Jupyter Notebook it says that there is not module named qiskit Any suggestion to solve this problem?,<python><jupyter-notebook><qiskit>,7/25/2019 9:35,57199513.0,57199513.0,You have different python installations. Install qiskit in the python installation pointed by jupyter. Use below from jupyter notebook !pip3 install qiskit,7/25/2019 10:12
57819419.0,How to install and import Qiskit_aqua?,I want to run SVM algorithm using Qiskit. For this purpose I need to import some packages from qiskit_aqua.utils. I am writing my code on Google Colaboratory. But while trying to import this package it shows me the following error. ModuleNotFoundError: No module named 'qiskit_aqua' I have tried to import every thing from Qiskit. But no changes have come. Here is my code. !pip install qiskit from qiskit import * from qiskit_aqua.utils import split_dataset_to_data_and_labels from qiskit_aqua.input import get_input_instance from qiskit_aqua import run_algorithm I even tried to import Aer using this command. But still it is of no use. Help me finding the solution. !pip install qiskit from qiskit import Aer from qiskit_aqua.utils import split_dataset_to_data_and_labels from qiskit_aqua.input import get_input_instance from qiskit_aqua import run_algorithm,<python><qiskit>,09/06/2019 09:35,57819651.0,57819651.0,"Aqua is a subpackage of Qiskit, so you need to use . instead of _. Your imports therefore should be from qiskit import Aer from qiskit.aqua.utils import split_dataset_to_data_and_labels from qiskit.aqua.input import get_input_instance from qiskit.aqua import run_algorithm",09/06/2019 09:50
57832016.0,How to make a gate which generates |0> or |1> based on a parameter?,"I would like to make a single-qubit gate which gives |0> or |1> with reference to a parameter. For example, I set a parameter theta in range of 0 to 2Ï. When theta is in range of 0 to Ï, the gate returns |0> and when theta is in range of Ï to 2Ï, the gate returns |1>. I am in the environment as follows: Qiskit: 0.12.0 Python 3.7.3 .",<quantum-computing><qiskit>,09/07/2019 08:28,57833040.0,57833040.0,"Quantum gates don't ""return"" a state, they transform a qubit state into another one. A singe-qubit quantum gate is represented as a 2x2 unitary matrix, and the way it transforms the qubit state is represented as matrix multiplication of this matrix and a vector of length 2 which represents the input state. So the closest to the thing you're trying to do is a gate which transforms an arbitrary input state to |0â© or to |1â© depending on the value of the parameter. Quantum gates also have to be reversible, i.e. you need to be able to undo the transformation. The transformation you described makes it impossible, since multiple inputs are mapped to the same output, and you can not recover the input state from the result. Non-reversible transformations are done not using gates but using measurements. If you need to collapse the input qubit to |0â© or |1â© depending on a parameter, you can measure it, and depending on the measurement result and the state you need, apply an X gate to the qubit. I.e., if the qubit was measured in the |0â© state and you need a |1â© (or vice versa), apply X gate, otherwise don't apply it.",09/07/2019 11:00
58017525.0,Unexpected keyword argument 'noise_model',"The following code throws an error. Based on some issues that I read on qiskit github, it seems that it has something do with run configs vs. compile configs but I could not find any other info that will help me resolve this issue. from qiskit import QuantumCircuit, IBMQ, execute from qiskit import BasicAer as Aer from qiskit.providers.aer import noise ckt = QuantumCircuit(2, 2) ckt.h(0) ckt.cx(0, 1) ckt.measure(0, 0) ckt.measure(1, 1) qsim = Aer.get_backend(""qasm_simulator"") IBMQ.load_account() provider = IBMQ.get_provider(hub=""ibm-q"") qc = provider.get_backend(""ibmqx2"") props = qc.properties() coupling_map = qc.configuration().coupling_map noise_model = noise.device.basic_device_noise_model(props) job = execute( ckt, qsim, noise_model=noise_model, coupling_map=coupling_map, basis_gates=noise_model.basis_gates ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-1-2f987d65d1f7&gt; in &lt;module&gt; 25 noise_model=noise_model, 26 coupling_map=coupling_map, ---&gt; 27 basis_gates=noise_model.basis_gates 28 ) ~/.venvs/qk/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, **run_config) 220 221 # executing the circuits on the backend and returning the job --&gt; 222 return backend.run(qobj, **run_config) TypeError: run() got an unexpected keyword argument 'noise_model' Env: macOS 10.14.6 Python 3.7.3 qiskit 0.12.0",<python><quantum-computing><qiskit>,9/19/2019 19:04,58018154.0,58018154.0,The error is coming up because you are using BasicAer to retrieve the simulator backend. I do not think this will work with the BasicAer provider. You should be using the Aer provider. from qiskit import Aer qsim = Aer.get_backend('qasm_simulator') If you just change your import statement from from qiskit import BasicAer as Aer to from qiskit import Aer then your code should work,9/19/2019 19:55
58918250.0,How to connect to IBMQ from Qiskit?,"I have a problem with connecting on IBMQ from jupyter, by typing : from qiskit import IBMQ IBMQ.save_account('Token') IBMQ.load_account() i tried many different code but nothing worked. I uninstalled Qiskit, then i reinstall it and it still don't work. If you have an idea of what is happening, please tell me",<qiskit>,11/18/2019 15:43,58919672.0,58919672.0,"Please try running IBMQ.delete_account() to remove any old/incorrect credentials that may have accidentally got stored. Then check you have the most up to date versions of all the qiskit packages, especially IBM Q provider which should be on 0.4.1. If the packages need updating run pip install --upgrade qiskit. Once this has finished, run IBMQ.save_account(token) to save the credentials again. After this you should be able to run IBMQ.load_account()",11/18/2019 17:06
59862723.0,Could I get the detail of error from qiskit,"Sometimes, I execute a circuit on the Quantum computing device (ex. ibmq_16_melbourne) and got error like 'Invalid job state. The job should be DONE but it is JobStatus.ERROR'. Could I get the detail of this error, such as the cause of a mistake or sth like that. For this time, I try to execute a circuit that including from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, IBMQ, execute from qiskit.visualization import * from qiskit.tools.jupyter import * from qiskit.tools.monitor import job_monitor IBMQ.load_account() qr = QuantumRegister(6) cr = ClassicalRegister(5) mycir = QuantumCircuit(qr,cr) for i in range(13): mycir.mct([qr[0],qr[1],qr[2],qr[3]],qr[4],None, mode='noancilla') mycir.mct([qr[0],qr[1],qr[2]],qr[3],None, mode='noancilla') provider = IBMQ.get_provider(group='open') backend = provider.get_backend('ibmq_16_melbourne') job = execute(mycir, backend, shots=1000) job_monitor(job) result = job.result() counts = result.get_counts() # print(counts) plot_histogram(counts, figsize=(14,8)) the result is error like above.",<qiskit>,1/22/2020 15:09,59864921.0,59864921.0,"Running this circuit through the transpiler, I get a circuit that has a depth of 2201. I imagine the reason this circuit won't run therefore is because it is too deep. To remedy this I would suggest either reducing the depth of your circuit, or running it on a simulator with a noise model similar to the device you are trying to run it on.",1/22/2020 17:09
60682091.0,cannot save tensorrflow keras quantum model using save/pickle,"how to save tensorflow quantum model? I am getting the following when i am trying to save keras model with quantum circuits. I didnt find any support for the same. tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments WARNING:tensorflow:Layer add_circuit_2 was passed non-serializable keyword arguments: {'prepend': cirq.Circuit([ cirq.Moment(operations=[ cirq.H.on(cirq.GridQubit(0, 0)), cirq.H.on(cirq.GridQubit(0, 1)), cirq.H.on(cirq.GridQubit(0, 2)), cirq.H.on(cirq.GridQubit(0, 3)), cirq.H.on(cirq.GridQubit(1, 0)), cirq.H.on(cirq.GridQubit(1, 1)), cirq.H.on(cirq.GridQubit(1, 2)), cirq.H.on(cirq.GridQubit(1, 3)), cirq.H.on(cirq.GridQubit(2, 0)), cirq.H.on(cirq.GridQubit(2, 1)), cirq.H.on(cirq.GridQubit(2, 2)), cirq.H.on(cirq.GridQubit(2, 3)), cirq.H.on(cirq.GridQubit(3, 0)), cirq.H.on(cirq.GridQubit(3, 1)), cirq.H.on(cirq.GridQubit(3, 2)), cirq.H.on(cirq.GridQubit(3, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 1), cirq.GridQubit(0, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 2), cirq.GridQubit(0, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(0, 3), cirq.GridQubit(1, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 0), cirq.GridQubit(1, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 1), cirq.GridQubit(1, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 2), cirq.GridQubit(1, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(1, 3), cirq.GridQubit(2, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 0), cirq.GridQubit(2, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 1), cirq.GridQubit(2, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 2), cirq.GridQubit(2, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(2, 3), cirq.GridQubit(3, 0)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 0), cirq.GridQubit(3, 1)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 1), cirq.GridQubit(3, 2)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 2), cirq.GridQubit(3, 3)), ]), cirq.Moment(operations=[ cirq.CZ.on(cirq.GridQubit(3, 3), cirq.GridQubit(0, 0)), ]),])}. They will not be included in the serialized model (and thus will be missing at deserialization time). --------------------------------------------------------------------------- NotImplementedError Traceback (most recent call last) &lt;ipython-input-91-a74ee5c9d34d&gt; in &lt;module&gt;() ----&gt; 1 qcnn_model.save('qcnn_model.h5') 8 frames /usr/local/lib/python3.6/dist-packages/tensorflow_core/python/keras/engine/base_layer.py in get_config(self) 497 # or that `get_config` has been overridden: 498 if len(extra_args) &gt; 1 and hasattr(self.get_config, '_is_default'): --&gt; 499 raise NotImplementedError('Layers with arguments in `__init__` must ' 500 'override `get_config`.') 501 return config NotImplementedError: Layers with arguments in `__init__` must override `get_config`.",<tensorflow><keras><model><save><tensorflow-quantum>,3/14/2020 11:12,60688418.0,60688418.0,"TensorFlow Quantum does not yet implement get_config and load_config. We had some difficulty with saving certain Cirq objects, we are working on it. For now if you want to save models that contain quantum layers you can use the model = tf.keras.Model(...) model.save_weights(""some_path"") ... model.load_weights(""some_path"") function instead.",3/14/2020 23:47
60709643.0,How to create VSCode bindings to input bra and ket efficiently,"I'm currently using VSCode for Q# programming. This sometimes entails including simple qubit expressions in the comments for clarity. It is of course possible to just settle with using regular angle brackets (such as |00&gt; or &lt;00|), but it looks nicer using the appropriate Unicode characters (such as |00â© or â¨00|). Copying and pasting these characters whenever needed is a bit cumbersome, so it would be nice to have key bindings in VSCode just for this purpose. Actually, I'd like to be able to configure VSCode for quick access to any selection of characters I might be interested at the moment.",<visual-studio-code><keyboard-shortcuts><special-characters><quantum-computing><ide-customization>,3/16/2020 16:23,60709644.0,60709644.0,"VSCode customization supports a type command which does exactly that - types in its argument. In order to create an entry for a keybinding, open the command prompt (Ctrl+Shift+P or â+Shift+P on Mac) and type Preferences: Open Keyboard Shortcuts (JSON) and insert entries of the form: { ""key"": ""&lt;key-binding&gt;"", ""command"": ""type"", ""args"": { ""text"": ""&lt;character&gt;"" } } where &lt;key-binding&gt; is the usual description of the keybinding and &lt;character&gt; is the desired character literal. So, for the bra-ket case above, my customization looks like this: [ { ""key"": ""ctrl+shift+."", ""command"": ""type"", ""args"": { ""text"": ""â©"" } }, { ""key"": ""ctrl+shift+,"", ""command"": ""type"", ""args"": { ""text"": ""â¨"" } } ]",3/16/2020 16:23
60839687.0,using third part modules in IBM quantum experience,"is there something i can do to use NumPy in IBM quantum experience? I have searched on google but i couldn't find anything. I thought about coping the source code, any suggestion?",<python><quantum-computing>,3/24/2020 21:34,60848813.0,60848813.0,"NumPy is one of the pre-installed packages (it's a pre-requisite for Qiskit, for one thing). You should be able to just do import numpy from your Jupyter notebook.",3/25/2020 12:25
61379417.0,AssertionError: wrong color format 'ansibrightred',"I am running my old qiskit code after a very long time it's not running now showing error wrong color format 'ansibrightred' and I don't know why? from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister # %matplotlib inline circuit = QuantumCircuit(3,3) circuit.h(0) circuit.h(1) circuit.h(2) circuit.measure([0,1], [0,1])",<quantum-computing><qiskit>,4/23/2020 4:33,61380576.0,61380576.0,I ran into the same problem. I solved it by removing my install and installing qiskit==0.16.2. pip install qiskit==0.16.2,4/23/2020 6:22
62048900.0,Unexpected keyword argument 'datatime' qiskit provider,"I'm trying to set datatime calling backend.properties qiskit. this is my code : from qiskit import * from qiskit.providers.ibmq import * provider = IBMQ.get_provider(hub='ibm-q') provider.backends(simulator=False) backend = provider.get_backend(name) prp = backend.properties(datatime=datatime).to_dict() I'm getting this error : TypeError: properties() got an unexpected keyword argument 'datatime'. If I use refresh = True and not datatime in propertis, the code works.",<quantum-computing><qiskit>,5/27/2020 17:11,62049287.0,62049287.0,"The keyword is datetime, not datatime.",5/27/2020 17:31
62161231.0,In quantum computing is there a preference to usage of little endian or big endian?,"I've been learning quantum computing related concepts over the past few months. We've generally used the big endian notation while solving problems on paper. Recently on starting to code I find that at a lot of places the little endian notation is used. I see the same in Quantum Katas by Microsoft and also in Qiskit. On paper, however, thinking in terms of Little endian reverses the order of tensor products, etc. So sometimes it gets confusing. Is there any particular trend on using little endian in quantum computing softwares (QDK, Qiskit, etc) or any reason for the same? Any suggestions in terms of what is the best way to think (in the above context), that can help while developing quantum algos to problems and smoothly translating them into code are welcome.",<quantum-computing>,06/02/2020 20:52,62184514.0,62184514.0,"I believe the preference in the user code is mostly dictated by the notation used by two sources: the libraries and the books/papers detailing the topic; and the preference in the libraries is dictated by the notation in the books/papers used to implement the libraries. For example, quantum Fourier transform as described in Nielsen and Chuang uses big endian notation for input/output registers; so if a library uses this book as a reference (as the first part of the QFT kata does), it is likely to use big endian notation as well. I don't think there is a quantum-specific reason to prefer little endian over big endian or vice versa, at some level it's an arbitrary choice informed by the notation preferred by the sources.",06/03/2020 23:38
62409919.0,How does DenseLayout in qiskit's transpiler work?,"I'm looking for an explanation about the Dense Layout algorithm used by qiskit's transpiler. I saw the source code, but still I don't understand what """"""Choose a Layout by finding the most connected subset of qubits"""""" means! Is there a paper about this kind of mapping algorithm or other resource I can learn about it from?",<layout><mapping><qiskit>,6/16/2020 13:40,62419747.0,62419747.0,"It does a breadth first search for a connected subset starting at each qubit. The subset with the most connectivity is selected. Due to symmetry there are many subsets with same connectivity. However, it also looks at the noise in the device and picks the subset with the least amount of noise. Finally that set is run through a reverse cuthill mckee traversal to reorder the qubits in the set for a lower degree. There is no paper on it as I came up with it to solve a bug in earlier versions of the Qiskit swap mapper.",6/17/2020 0:47
64538775.0,Q# : QDK Errors,"I've recently tried to install the QDK via the VSCode extension in my Windows 10 Desktop and VSCode wasn't able to find the Microsoft libraries even after I was able to execute the code by the dotnet run command on the terminal. The code was the sample project code described in the create new project part of the tutorial. I also didn't have .NET SDK so I installed it but it seems to be working fine. In computers I got problems all the code, all related to not finding the namespaces. namespace QuantumRNG { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; open Microsoft.Quantum.Math; open Microsoft.Quantum.Convert; operation GenerateRandomBit() : Result { using (q = Qubit()) { H(q); return MResetZ(q); } } operation SampleRandomNumberInRange(max : Int) : Int { mutable output = 0; repeat { mutable bits = new Result[0]; for (idxBit in 1..BitSizeI(max)) { set bits += [GenerateRandomBit()]; } set output = ResultArrayAsInt(bits); } until (output &lt;= max); return output; } @EntryPoint() operation SampleRandomNumber() : Int { let max = 50; Message($&quot;Sampling a random number between 0 and {max}: &quot;); return SampleRandomNumberInRange(max); } }",<visual-studio-code><q#>,10/26/2020 14:08,64602732.0,64602732.0,"Do you see any error messages in the output console? To see the output console select &quot;View: Toggle Output&quot; (Ctrl + Shift + U) and select &quot;Q# Language Extension&quot; from the drop down list. If the drop down list doesn't show &quot;Q# Language Extension&quot; then it probably means that the language-server that gets downloaded on first run is still downloading, so give it a minute or so (depending on your internet connection).",10/30/2020 4:27
64817371.0,How to loop several times within a list?,"I have a code that looks like this,: import random import numpy as np from operator import itemgetter import sys equal_to = {&quot;a&quot;:&quot;u_plus&quot;, &quot;b&quot;:&quot;u_minus&quot;, &quot;c&quot;:&quot;v_plus&quot;, &quot;d&quot;:&quot;v_minus&quot;} #bell state p = 8 #length of generated binary key1 = [] #list of generated binary for i in range(p): temp = random.randint(0,1) key1.append(temp) tmplist2 = [] #list of random sample_letters for i in range(p): while True: attempt = str(random.choice(list(equal_to))) tmplist2.append(attempt) if attempt == 'b': break #evaluate result of alice binary and bell state def eva(alice, bell): if alice == 1: if bell == 'a' or bell == 'b': return 1 elif bell == 'c' or bell == 'd': return 0 elif alice == 0: if bell == 'c' or bell == 'd': return 1 elif bell == 'a' or bell == 'b': return 0 for_bob = [] #list of generated binary and bell state through logic gate for k in key1: for t in tmplist2: e = eva(k, t) for_bob.append(e) #tr = [[eva(k,t) for t in tmplist2] for k in key1] #list comprehension split the key properly print(&quot;generated random binary strings:&quot;, key1) print(&quot;generated bell states:&quot;, tmplist2) print(&quot;encrypted strings:&quot;, for_bob) It printed out something like this: generated random binary strings: [0, 0, 0, 0, 0, 1, 1, 0] generated bell states: ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] encrypted strings: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0] I was looking a way to loop within tmplist2 without starting again from the beginning, if the string 'b' came out. The loop is supposed to function as follows: key1[0] shall evaluate with 'b', returning to 0. Since 'b' came out, outer loop should continue to next element key1[1] and it should evaluate with 'c' and 'b', returning 1 0. Again because 'b' came out, outer loop shall proceed to next element key[2] and evaluate itself with 'a', 'a', 'c', and 'b', returning 0 0 1 0. This should continue until tmplist2 finished. Anyone got solutions for the issue? I was searching the solution of how to loop within a loop and not returning to the beginning when a certain condition is given. In this case 'b'. n.b.: this program was meant to simulate quantum teleportation.",<python><quantum-computing>,11/13/2020 8:02,64818488.0,64818488.0,"Main data for_bob = [] key1 = [0, 0, 0, 0, 0, 1, 1, 0] tmplist2 = ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] Approach 1 _tmp = tmplist2[:] for k in key1: while _tmp: if _tmp[:1] != ['b']: for_bob.append(eva(k, *_tmp[:1])) _tmp = _tmp[1:] else: for_bob.append(eva(k, *_tmp[:1])) _tmp = _tmp[1:] break Approach 2: _tmp = iter(tmplist2) for i in key1: for j in iter(lambda: next(_tmp), None): if j != 'b': for_bob.append(eva(i, j)) else: for_bob.append(eva(i, j)) break generated random binary strings: [0, 0, 0, 0, 0, 1, 1, 0] generated bell states: ['b', 'c', 'b', 'a', 'a', 'c', 'b', 'b', 'd', 'd', 'd', 'c', 'c', 'b', 'a', 'd', 'd', 'b', 'c', 'c', 'd', 'c', 'd', 'b', 'd', 'c', 'a', 'd', 'c', 'd', 'c', 'c', 'b'] encrypted strings: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]",11/13/2020 9:31
65254223.0,Set random seed for cirq functions,"I am working with cirq and use a random unitary for testing purposes with: random_matrix = cirq.testing.random_unitary(dim=4) where can can the random seed for this function be set, using random.seed(a=1) does not seem to do this.",<linear-algebra><quantum-computing><cirq>,12/11/2020 15:34,65254479.0,65254479.0,"Cirq relies on numpy for its random functions, so using: np.random.seed(2) Sets the seed for cirq",12/11/2020 15:50
66148518.0,Quantum computing vs traditional base10 systems,"This may show my naivetÃ© but it is my understanding that quantum computing's obstacle is stabilizing the qbits. I also understand that standard computers use binary (on/off); but it seems like it may be easier with today's tech to read electric states between 0 and 9. Binary was the answer because it was very hard to read the varying amounts of electricity, components degrade over time, and maybe maintaining a clean electrical &quot;signal&quot; was challenging. But wouldn't it be easier to try to solve the problem of reading varying levels of electricity so we can go from 2 inputs to 10 and thereby increasing the smallest unit of storage and exponentially increasing the number of paths through the logic gates? I know I am missing quite a bit (sorry the puns were painful) so I would love to hear why or why not. Thank you",<binary-data><quantum-computing>,02/11/2021 03:52,66260965.0,66260965.0,"&quot;Exponentially increasing the number of paths through the logic gates&quot; is exactly the problem. More possible states for each n-ary digit means more transistors, larger gates and more complex CPUs. That's not to say no one is working on ternary and similar systems, but the reason binary is ubiquitous is its simplicity. For storage, more possible states also means we need more sensitive electronics for reading and writing, and a much higher error frequency during these operations. There's a lot of hype around using DNA (base-4) for storage, but this is more on account of the density and durability of the substrate. You're correct, though that your question is missing quite a bit - qubits are entirely different from classical information, whether we use bits or digits. Classical bits and trits respectively correspond to vectors like Binary: |0&gt; = [1,0]; |1&gt; = [0,1]; Ternary: |0&gt; = [1,0,0]; |1&gt; = [0,1,0]; |2&gt; = [0,0,1]; A qubit, on the other hand, can be a linear combination of classical states Qubit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt; where Î± and Î² are arbitrary complex numbers such that such that |Î±|2 + |Î²|2 = 1. This is called a superposition, meaning even a single qubit can be in one of an infinite number of states. Moreover, unless you prepared the qubit yourself or received some classical information about Î± and Î², there is no way to determine the values of Î± and Î². If you want to extract information from the qubit you must perform a measurement, which collapses the superposition and returns |0&gt; with probability |Î±|2 and |1&gt; with probability |Î²|2. We can extend the idea to qutrits (though, just like trits, these are even more difficult to effectively realize than qubits): Qutrit: |Î¨&gt; = Î± |0&gt; + Î² |1&gt; + Î³ |2&gt; These requirements mean that qubits are much more difficult to realize than classical bits of any base.",2/18/2021 13:29
66197227.0,Return two numbers in Q Sharp (Q#) (Quantum Development Kit),"So, basically, I did the tutorial to create a random number on the website of Microsoft Azure and now I am trying to add some functionalities, including their suggestion add a minimum number. The initial code to generate just one number, max, is: operation SampleRandomNumberInRange(max : Int) : Int { // mutable means variables that can change during computation mutable output = 0; // repeat loop to generate random numbers until it generates one that is less or equal to max repeat { mutable bits = new Result[0]; for idxBit in 1..BitSizeI(max) { set bits += [GenerateRandomBit()]; } // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer set output = ResultArrayAsInt(bits); } until (output &lt;= max); return output; } @EntryPoint() operation SampleRandomNumber() : Int { // let declares var which don't change during computation let max = 50; Message($&quot;Sampling a random number between 0 and {max}: &quot;); return SampleRandomNumberInRange(max); } Everything works well. Now, I want to generate two numbers so I would like to create a function TwoSampleRandomNumbersInRange but I can't figure out how to make the function return a result such as &quot;Int, Int&quot;, I tried a few things including the follow: operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int { // mutable means variables that can change during computation mutable output = 0; // repeat loop to generate random numbers until it generates one that is less or equal to max repeat { mutable bits = new Result[0]; for idxBit in 1..BitSizeI(max) { set bits += [GenerateRandomBit()]; } for idxBit in 1..BitSizeI(min) { set bits += [GenerateRandomBit()]; } // ResultArrayAsInt is from Microsoft.Quantum.Convert library, converts string to positive integer set output = ResultArrayAsInt(bits); } until (output &gt;= min and output &lt;= max); return output; } To generate two numbers, I tried this: operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : Int, Int { //code here } ...but the syntax for the output isn't right. I also need the output: set output = ResultArrayAsInt(bits); to have two numbers but ResultArrayAsInt, as the name says, just returns an Int. I need to return two integers. Any help appreciated, thanks!",<azure><quantum-computing><q#>,2/14/2021 16:03,66199077.0,66199077.0,"The return of an operation has to be a data type, in this case to represent a pair of integers you need a tuple of integers: (Int, Int). So the signature of your operation and the return statement will be operation TwoSampleRandomNumbersInRange(min: Int, max : Int) : (Int, Int) { // code here return (integer1, integer2); }",2/14/2021 19:09
66198976.0,ValueError: numpy.ndarray size changed on importing qiskit,"While trying to run the following commands on Jupyter from qiskit import QuantumCircuit, Aer, BasicAer, execute from qiskit.visualization import plot_histogram I am encountering the following error.I am using python 3.8. Does anyone have any idea how can this be resolved? I have tried upgrading numpy and reinstalling Qiskit but the problem prevails --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-3-a0c116756cb0&gt; in &lt;module&gt; ----&gt; 1 from qiskit import QuantumCircuit, Aer, BasicAer, execute 2 from qiskit.visualization import plot_histogram C:\ProgramData\Anaconda3\lib\site-packages\qiskit\__init__.py in &lt;module&gt; 55 # Try to import the Aer provider if installed. 56 try: ---&gt; 57 from qiskit.providers.aer import Aer 58 except ImportError: 59 suppress_warnings = os.environ.get('QISKIT_SUPPRESS_PACKAGING_WARNINGS', '') C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\__init__.py in &lt;module&gt; 62 63 # pylint: disable=wrong-import-position ---&gt; 64 from .aerprovider import AerProvider 65 from .aerjob import AerJob 66 from .aererror import AerError ... C:\ProgramData\Anaconda3\lib\site-packages\qiskit\providers\aer\pulse\qutip_extra_lite\fastsparse.py in &lt;module&gt; 438 # ------------------------------------- 439 # pylint: disable=no-name-in-module, wrong-import-position, import-error --&gt; 440 from .cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult) spmath.pyx in init qiskit.providers.aer.pulse.qutip_extra_lite.cy.spmath() ValueError: numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject",<python><python-3.x><numpy><qiskit>,2/14/2021 18:59,66199810.0,66199810.0,worked after I used the following command pip install --ignore-installed qiskit-terra qiskit-aer,2/14/2021 20:28
66288920.0,Can I have two iterables in the reduce function? (Python),"Suppose I have the following command (using Python and Qiskit): a = reduce(lambda x,y: x.compose(y,c),circli, qcla) (qcla is an initializer) Here, compose is an internal qiskit function, x and y are elements of the list circli (iterable). I'm wondering is it possible for me to add another iterable in this reduce function? Here, c itself in (y,c) represents a coordinate, such as [2,3], and I'm hoping to have it updated as well. Can I create another list containing all the possible c's and add it as another iterable? Thanks!",<python><lambda><reduce><qiskit>,2/20/2021 7:01,66289038.0,66289038.0,"It is possible to reduce a list (iterable) of pairs and also to create a pair at the end. For the first one you need the zip function, for the latter one you need to modify the lambda function to return a tuple. For example: a, x_sum = reduce(lambda x,y: (x[0].compose(y[0], y[1]), x[1][0]+y[1][0]), zip(circli, cs), (qcla, 0)) I use the name cs for the list of c values here. zip creates pairs of circli and cs items and you can go through the pairs. In this case I get the sum of the x coordinates of c values as the result as well. If the values in cs is the constant c in your example (cs = [c]*len(circli)) , the a in the result will be the same as in your example.",2/20/2021 7:22
67411006.0,"Python calling q# file on IONQ QPU results in error about a System.Text.Json, Version=5.0.0.0 file not being found","Attempting to learn how to call q# from Python code and have it run for real on the IONQ QPU as it does (or appears to do) using VS and &gt;dotnet run of the raw q# code. I followed the guides and workshop. Python code: import qsharp import qsharp.azure qsharp.projects.add(&quot;****path to *******/TestIONQ.csproj&quot;) from TestIONQ import GetRandomResult print(f&quot;Simulated Result: {GetRandomResult.simulate()}&quot;) print(&quot;------------------------------------------------&quot;) qsharp.azure.connect( subscription = &quot;****************************&quot;, resourceGroup = &quot;**************&quot;, workspace = &quot;************&quot;, location = &quot;******* US&quot;) qsharp.azure.target(&quot;ionq.qpu&quot;) result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;) print(f&quot; Final result from IONQ - QPU: {result}&quot;) q# code: namespace TestIONQ { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; //@EntryPoint() operation GetRandomResult() : Result { use q = Qubit(); H(q); return M(q); } } and the .csproj file: &lt;Project Sdk=&quot;Microsoft.Quantum.Sdk/0.16.2104138035&quot;&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt; &lt;ExecutionTarget&gt;ionq.qpu&lt;/ExecutionTarget&gt; &lt;IQSharpLoadAutomatically&gt;true&lt;/IQSharpLoadAutomatically&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt; The results of running the above Python code in Anaconda qsharp-env environment (Python 3.7.10) are as follows: Simulated Result: 0 ------------------------------------------------ Connected to Azure Quantum workspace ####### in location #####us. Loading package Microsoft.Quantum.Providers.IonQ and dependencies... Active target is now ionq.qpu Submitting TestIONQ.GetRandomResult to target ionq.qpu... Failed to submit Q# operation TestIONQ.GetRandomResult for execution. Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken=####token#####'. The system cannot find the file specified. Obviously, no problem connecting to Azure and the Workspace. In fact I can run the container-ship optimization example no problem from Python. This also works fine for the first half of the Python code when .simulate() is invoked. Next, when I try to bypass the IONQ QPU and use its own simulator by changing this one line: qsharp.azure.target(&quot;ionq.simulator&quot;) The resulting error is the same and the results are as follows: Simulated Result: 1 ------------------------------------------------ Connected to Azure Quantum workspace ######## in location #######. Loading package Microsoft.Quantum.Providers.IonQ and dependencies... Active target is now ionq.simulator Submitting TestIONQ.GetRandomResult to target ionq.simulator... Failed to submit Q# operation TestIONQ.GetRandomResult for execution. Could not load file or assembly 'System.Text.Json, Version=5.0.0.0, Culture=neutral, PublicKeyToken='....token......'. The system cannot find the file specified. Traceback (most recent call last): File &quot;ionq_sim_remote.py&quot;, line 18, in &lt;module&gt; result = qsharp.azure.execute(GetRandomResult, jobName=&quot;Generate random bit&quot;) File &quot;F:\Python38\miniconda\envs\qsharp-env\lib\site-packages\qsharp\azure.py&quot;, line 137, in execute if &quot;error_code&quot; in result: raise AzureError(result) qsharp.azure.AzureError: {'error_code': 1010, 'error_name': 'JobSubmissionFailed', 'error_description': 'Failed to submit the job to the Azure Quantum workspace.'} This runs very easily on Azure using the q# code snippet within Visual Studio at the command line using a variant of what was shown during the workshop az quantum execute --target-id ionq.qpu --job-name IONQ_test --resource-group ***rg name*** --workspace-name ***ws name*** --location **** -o table and indeed this appears to have run on the actual QPU hardware as compared to the simulator (which gives the exact 0.5/0.5 result). Result Frequency -------- ---------- 0 0.49800000 1 0.50200000 But then calling that same q# code from Python - including the same .csproj file seems to throw this JSON file error - even with the qsharp-env loaded into Anaconda. I apologize if it is something silly that I have done- trying to learn here. By the way, this works great as a way around the problem with no Anaconda environment required or anything special: Python: import os os.system(f'powershell.exe az quantum execute --target-id ionq.qpu --job-name Pytest --resource-group **** --workspace-name **** --location **** -o table ') And the result was definitely run on the actual hardware (took a good while): Result Frequency -------- ----------- ------------------------- 0 0.53200000 ââââââââââââ | 1 0.46800000 ââââââââââ |",<python><azure><q#><azure-quantum>,05/06/2021 02:20,67421883.0,67421883.0,"@Joab.Ai, thank you for posting this issue! We've identified this to be specific to the latest version of qsharp (0.16.2104.138035). While we are looking into a fix, a workaround will be to downgrade your qsharp package version: Edit: we have fixed this issue in our latest release! Update to the latest version with this command: conda install -c quantum-engineering qsharp=0.16.2105.140472 or simply run: conda update -c quantum-engineering qsharp",05/06/2021 16:02
72031758.0,sympy: substitution of expressions with Braket-notation,"I am using sympy (in sagemath). I would like to do a substitution, with Braket-notation (for quantum mechanical problem). Below there is a minimalistic code, in order to reproduce the problem. from sympy.physics.quantum import Bra, Ket from sympy import * theta=symbols('theta',commutative=True) pi, mu= symbols(&quot;pi mu&quot;,commutative=False) W=2*pi*mu print(W.subs(pi*mu,theta)) V=Bra(pi)*Ket(mu) print(V.subs(Bra(pi)*Ket(mu),theta)) U=2*Bra(pi)*Ket(mu) print(U.subs(Bra(pi)*Ket(mu),theta)) The output is: 2*theta theta 2*&lt;pi|*|mu&gt; If there is no leading scalar multiplier, the substitution works finely. I am stuck with a more complicated expression.",<sympy><quantum-computing>,4/27/2022 15:48,72032642.0,72032642.0,"In these occasions srepr can shed some light: srepr(U) # out: &quot;Mul(Integer(2), Bra(Symbol('pi', commutative=False)), Ket(Symbol('mu', commutative=False)))&quot; srepr(Bra(pi)*Ket(mu)) # out: &quot;InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False)))&quot; Note that the first output is a multiplication, object of type Mul, whereas the second output is an object of type InnerProduct. With the command U.subs(Bra(pi)*Ket(mu),theta) you are asking to search for an object of type InnerProduct into U, but there is none, hence no substitution has been done. In this case, you have to do: U.subs(Mul(Bra(pi), Ket(mu)),theta) # out: 2*theta Edit: or as @Oscar Benjamin pointed out, you do: from sympy.physics.quantum import qapply U = qapply(U) srepr(U) # out: &quot;Mul(Integer(2), InnerProduct(Bra(Symbol('pi', commutative=False)),Ket(Symbol('mu', commutative=False))))&quot; Now you can see an InnerProduct as an argument of Mul. FInally: U.subs(Bra(pi)*Ket(mu), theta) # out: 2*theta",4/27/2022 16:56
72341743.0,How to decompose a N x N unitary matrix into 2- or 1-qubit operators?,"Given an N x N unitary operator M, I would like to build a circuit that does the same operation as M by explicitly inputting the gates myself (let's say into the IBMQ composer). I heard that 2-qubit operators could be decomposed using a Qiskit built-in function, however I was wondering if such a thing existed for a general case. More concretely, given a N x N unitary operator M, I would like to decompose it to something of the form M_1 x M_2 x M_3 x ... x M_n where &quot;x&quot; represents the tensor product and M_i is either a 2- or 1-qubit unitary operator. Is there a way to do this programatically, or can it be done by hand on paper in an algorithmic way? Thank you in advance!",<quantum-computing><qiskit>,5/22/2022 22:33,72349417.0,72349417.0,"If you want to implement custom unitary, there is a way to do it using Operator function, like this (example for 4x4 unitary matrix): from qiskit import QuantumRegister, QuantumCircuit from qiskit.quantum_info.operators import Operator q = QuantumRegister(2,&quot;qreg&quot;) qc = QuantumCircuit(q) customUnitary = Operator([ [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0] ]) qc.unitary(customUnitary, [q[0], q[1]], label='custom') qc.draw(output='mpl') But if your purpose is to decompose it to 1 or 2-qubit operators, the problem is more complex since there can be multiple ways to decompose the same unitary. I think the best you can do is to use Qiskit transpiler and define set of gates you want to use: from qiskit.compiler import transpile newCircuit = transpile(qc, basis_gates=['ry', 'rx', 'cx'], optimization_level = 3) newCircuit.draw(output='mpl')",5/23/2022 13:28
72417370.0,Qiskit: 'no counts for experiment',"Although I imported plot_histogram, I am not getting the output as expected. Here is my code: a = QuantumCircuit(1) a.z(0) a.x(0) a.h(0) a.sdg(0) a.t(0) backend = Aer.get_backend('qasm_simulator') result = execute(a, backend).result() counts = result.get_counts() plot_histogram(counts) print(c)```",<qiskit>,5/28/2022 16:29,72421265.0,72421265.0,You are missing measurements. a.z(0) a.x(0) a.h(0) a.sdg(0) a.t(0) a.measure_all(). #&lt;-- ... This will measure the qubits and set a classical register with the result.,5/29/2022 5:55
72451052.0,"Multi-processing a for loop, target's argument needs to be a list","I'm trying to use multiprocessing to split a for loop over multiple processes. Thus speeding up a QuTiP's library solver, here's my target function: def solve_entropy(t): # Parameters k = 0.5 n = 2 N = 5 r = 1.0 alpha = 2.0 beta = 2.0 gamma = 0.2 wm = 1 w0 = r * wm g = k * wm # Operators a = tensor(destroy(N), identity(N), identity(N)) b = tensor(identity(N), destroy(N), identity(N)) c = tensor(identity(N), identity(N), destroy(N)) # result = mesolve(H,psi0,t,c_ops) result = mesolve( w0 * a.dag() * a + w0 * b.dag() * b + wm * c.dag() * c - g * a.dag() * a * (c + c.dag()) - g * b.dag() * b * (c + c.dag()), tensor(coherent(N, alpha), coherent(N, alpha), coherent(N, beta)), t, sqrt(gamma) * c, ) S = [entropy_linear(ptrace(i, n)) for i in result.states] return S where mesolve takes a list of times (t) as argument, here's my multiprocessing code: if __name__ == &quot;__main__&quot;: t = np.linspace(0, 25, 100) # list of times t pool = mp.Pool(mp.cpu_count()) result = pool.map(solve_entropy, t) pool.close() pool.join() data = list(zip(t, result)) np.savetxt(&quot;entropy.dat&quot;, data, fmt=&quot;%.8f&quot;) However when I run this code I get the following error &quot;object of type 'numpy.float64' has no len()&quot;. It seems like mp.Pool splits my list t in float points instead of a smaller list, and since mesolve needs a list as argument I get an error. Is there a way to keep &quot;t&quot; as a list over multiple processes? Since it won't work if &quot;t&quot; is a number.",<python><numpy><multiprocessing><physics><qutip>,5/31/2022 16:10,72452112.0,72452112.0,"First, define function split, which takes an iterable and splits it into n lists: def split(iterable, n): # function to split iterable in n even parts if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) return list(iterable[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in range(n)) Then: if __name__ == &quot;__main__&quot;: # One smaller list for each process in the pool # This will create a list of numpy.ndarray instances: t = split(np.linspace(0, 25, 100), mp.cpu_count()) ... # etc. Update: Seeing the split Function In Action I have converted the split function into a generator function to better see what happens on each iteration. With a list of 93 elements being split into 10 sublists, the algorithm attempts to make each list as close to the same size it can. The code is very clever (I did not write it, but found it). In this case the statement k, m = divmod(l, n) with l -&gt; 93 and n -&gt; 10, it results in k -&gt; 9 and m -&gt; 3. Since m is not 0, it will create m lists of size k+1 and n-m lists of size k. def split(iterable, n): # function to split iterable in n even parts\n, if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) print() print(f'list size is {l}, number of sublists = {n}, k = {k}, m = {m}') if m == 0: print(f'This should yield {n} sublists of size {k}') else: print(f'Thus should yield {m} lists of size {k+1} and {n-m} lists of size {k}') print() for i in range(n): index_start = i * k + min(i, m) index_end = (i + 1) * k + min(i + 1, m) list_size = index_end - index_start print(f'i = {i}, min(i, m) = {min(i, m)}, min(i + 1, m) = {min(i + 1, m)}, index_start = {index_start}, index_end = {index_end}, size = {list_size}') yield iterable[index_start:index_end] for sublist in split(list(range(93)), 10): print('sublist =', sublist) for sublist in split(list(range(30)), 10): print('sublist =', sublist) for sublist in split(list(range(27)), 4): print('sublist =', sublist) Prints: list size is 93, number of sublists = 10, k = 9, m = 3 Thus should yield 3 lists of size 10 and 7 lists of size 9 i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 10, size = 10 sublist = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 10, index_end = 20, size = 10 sublist = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 20, index_end = 30, size = 10 sublist = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29] i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 30, index_end = 39, size = 9 sublist = [30, 31, 32, 33, 34, 35, 36, 37, 38] i = 4, min(i, m) = 3, min(i + 1, m) = 3, index_start = 39, index_end = 48, size = 9 sublist = [39, 40, 41, 42, 43, 44, 45, 46, 47] i = 5, min(i, m) = 3, min(i + 1, m) = 3, index_start = 48, index_end = 57, size = 9 sublist = [48, 49, 50, 51, 52, 53, 54, 55, 56] i = 6, min(i, m) = 3, min(i + 1, m) = 3, index_start = 57, index_end = 66, size = 9 sublist = [57, 58, 59, 60, 61, 62, 63, 64, 65] i = 7, min(i, m) = 3, min(i + 1, m) = 3, index_start = 66, index_end = 75, size = 9 sublist = [66, 67, 68, 69, 70, 71, 72, 73, 74] i = 8, min(i, m) = 3, min(i + 1, m) = 3, index_start = 75, index_end = 84, size = 9 sublist = [75, 76, 77, 78, 79, 80, 81, 82, 83] i = 9, min(i, m) = 3, min(i + 1, m) = 3, index_start = 84, index_end = 93, size = 9 sublist = [84, 85, 86, 87, 88, 89, 90, 91, 92] list size is 30, number of sublists = 10, k = 3, m = 0 This should yield 10 sublists of size 3 i = 0, min(i, m) = 0, min(i + 1, m) = 0, index_start = 0, index_end = 3, size = 3 sublist = [0, 1, 2] i = 1, min(i, m) = 0, min(i + 1, m) = 0, index_start = 3, index_end = 6, size = 3 sublist = [3, 4, 5] i = 2, min(i, m) = 0, min(i + 1, m) = 0, index_start = 6, index_end = 9, size = 3 sublist = [6, 7, 8] i = 3, min(i, m) = 0, min(i + 1, m) = 0, index_start = 9, index_end = 12, size = 3 sublist = [9, 10, 11] i = 4, min(i, m) = 0, min(i + 1, m) = 0, index_start = 12, index_end = 15, size = 3 sublist = [12, 13, 14] i = 5, min(i, m) = 0, min(i + 1, m) = 0, index_start = 15, index_end = 18, size = 3 sublist = [15, 16, 17] i = 6, min(i, m) = 0, min(i + 1, m) = 0, index_start = 18, index_end = 21, size = 3 sublist = [18, 19, 20] i = 7, min(i, m) = 0, min(i + 1, m) = 0, index_start = 21, index_end = 24, size = 3 sublist = [21, 22, 23] i = 8, min(i, m) = 0, min(i + 1, m) = 0, index_start = 24, index_end = 27, size = 3 sublist = [24, 25, 26] i = 9, min(i, m) = 0, min(i + 1, m) = 0, index_start = 27, index_end = 30, size = 3 sublist = [27, 28, 29] list size is 27, number of sublists = 4, k = 6, m = 3 Thus should yield 3 lists of size 7 and 1 lists of size 6 i = 0, min(i, m) = 0, min(i + 1, m) = 1, index_start = 0, index_end = 7, size = 7 sublist = [0, 1, 2, 3, 4, 5, 6] i = 1, min(i, m) = 1, min(i + 1, m) = 2, index_start = 7, index_end = 14, size = 7 sublist = [7, 8, 9, 10, 11, 12, 13] i = 2, min(i, m) = 2, min(i + 1, m) = 3, index_start = 14, index_end = 21, size = 7 sublist = [14, 15, 16, 17, 18, 19, 20] i = 3, min(i, m) = 3, min(i + 1, m) = 3, index_start = 21, index_end = 27, size = 6 sublist = [21, 22, 23, 24, 25, 26] Explanation When m is 0 (the iterable of length l can be divided into n sublists of size l // n, then the ith starting slice index is: i * k + min(i, m) # but min(i, m) is 0 for all i, so this is just: i * k # where k is the size of each sublist, l // n But when m is not 0, min(i, m) is just i for the first m sublists, so the starting index is i * k + i -&gt; i * (k+1) and the ending index is (i + 1) * k + i + 1 -&gt; i * (k+1) + k + 1 So the first m sublists are length k + 1. The starting index of ith sublist for i == m is i * k + min(i, m) -&gt; m * k + m and the ending index is (i + 1) * k + min(i + 1, m) -&gt; (m + 1) * k + m -&gt; m * k + k + m The difference between the ending and starting indices is just k. Update 2 Here is split rewritten as a generator function, which makes the logic clearer: def split(iterable, n): if type(iterable) is range and iterable.step != 1: # algorithm doesn't work with steps other than 1: iterable = list(iterable) l = len(iterable) n = min(l, n) k, m = divmod(l, n) start_index = 0 if m == 0: for _ in range(n): end_index = start_index + k yield iterable[start_index:end_index] start_index = end_index else: l2 = k + 1 for _ in range(m): end_index = start_index + l2 yield iterable[start_index:end_index] start_index = end_index for _ in range(n - m): end_index = start_index + k yield iterable[start_index:end_index] start_index = end_index",5/31/2022 17:43
72875257.0,"Cannot import QISKIT ""ModuleNotFoundError: No module named 'qiskit._accelerate'""","I'm trying to use qiskit in virtual environment via Anaconda, however although I see qiskit as installed, importing qiskit always fails with: ModuleNotFoundError: No module named 'qiskit._accelerate' I can't find information about this anywhere. What is this module? What is wrong with the environment? It seems there's nothing called qiskit._accelerate",<python><anaconda><qiskit>,07/05/2022 20:36,72888163.0,72888163.0,"I've solved the issue thanks to Joseph Geipel's advice. There's some compatibility issue between Python and Qiskit. Python 3.9.12 and Qiskit 0.37.0 seem not to work well together. When I've created a new environment with Python 3.8.13 and the same version of Qiskit, the problem was solved.",07/06/2022 18:11
73239349.0,"Why am I getting ""NameError: name 'qiskit' is not defined"" on my program when I already imported all qiskit functions","I'm using the IBM quantum lab to run my python program. I imported all these functions/libraries: from ibm_quantum_widgets import CircuitComposer from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi import json import ast from qiskit import * from qiskit import QuantumCircuit, execute, BasicAer from qiskit.tools.monitor import job_monitor from qiskit import IBMQ from qiskit import BasicAer just to make sure I literally got everything from the qiskit library (if that's the right term, I'm kind of a beginner). It's overkill but I did it mainly because every time I run my program and get to this line of code: measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1) I get a nameerror, qiskit not defined. I wanted to import everything just to be sure that wasn't the issue. Does anyone understand what possibly could be the issue here? for context, I'll copy and paste the code before the error: IBMQ.load_account() provider = IBMQ.get_provider(hub = 'ibm-q') thequantumcomputer = provider.get_backend('ibmq_qasm_simulator') #measures all the circuits circuit.measure(0,0) circuit.measure(1,1) circuit.measure(2,2) circuit.measure(3,3) circuit.measure(4,4) circuit.measure(5,5) circuit.measure(6,6) circuit.measure(7,7) circuit.measure(8,8) measure = qiskit.execute(circuit, backend=thequantumcomputer, shots=1) Thanks for any suggestions you have :)",<python><qiskit>,08/04/2022 16:27,73239399.0,73239399.0,"You would need to say import qiskit What you have said is from qiskit import execute That brings in the name execute. It does not define a name called qiskit. So, you could say: measure = execute(circuit, backend=thequantumcomputer, shots=1) Or you could just use import qiskit instead of importing all the individual names. I tend to prefer that, because then I know exactly where the name came from.",08/04/2022 16:31
73477635.0,Bundled QC Circuit on Qiskt (Index error),"I'm trying to execute a list of ciruits on qiskit, but was faced with this strange dilemma: --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-4-653a7fab138c&gt; in &lt;module&gt; ----&gt; 1 job = execute(circuit_list, backend = device, shots = 1024) 2 print(job.job_id()) ~\anaconda3\envs\qc_env\lib\site-packages\qiskit\execute_function.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config) 274 &quot;&quot;&quot; 275 if isinstance(experiments, Schedule) or ( --&gt; 276 isinstance(experiments, list) and isinstance(experiments[0], Schedule) 277 ): 278 # do not transpile a schedule circuit IndexError: list index out of range I did not transpile any circuit before adding it to the list nor am I transpiling it during execution. Does anyone have an answer to why this is happening? Edit: I'm not using a schedule either.",<python><qiskit>,8/24/2022 17:52,73477848.0,73477848.0,"That error would be caused by passing an empty list to execute(). What are the contents of circuit_list in your code? For the record, the execute() function is just a shorthand convenience function doig backend.run(transpile(experiments, backend)). So you're doing the correct thing not transpiling before passing circuit objects to execute().",8/24/2022 18:12
73819500.0,P vs. NP and Shor's Algorithm,"Given that Shor's algorithm can solve factorization in polynomial time on a quantum computer (BQP), if we prove that BQP is the same as P on a classical computer, won't factorization (which is an NP problem) be a counterexample to P != NP? In other words, if that statement is true, isn't P != NP not true, because we can solve an NP problem (factorization) in P time?",<np><quantum-computing>,9/22/2022 18:58,73819699.0,73819699.0,"The P vs NP question asks whether every problem in NP is also in P. Therefore, if you just find a single problem in NP that is also in P, that does not itself prove that P = NP. We already know of many problems with this property - since P is a subset of NP, every problem in P is also in NP. It is the case that if you can find an NP-complete problem in P then P = NP, but as of now we donât have a proof that the integer factorization problem (or more properly, the decision version of that problem) is NP-complete.",9/22/2022 19:19
73963180.0,This worked last week(Qiskit library issue),"This code used to work last week. I made sure that the pip install command is up-to-date and the right environment is set. I've been working on this code across windows and MacOS.... not the best idea but that may be part of the problem? Why is it not working? note: I blanked out the sensitive provider info... it's not really all Xs. import numpy as np from collections import defaultdict from qiskit import Aer from qiskit.visualization import plot_histogram from qiskit.utils import QuantumInstance from qiskit.algorithms import Grover, AmplificationProblem from qiskit.circuit.library import PhaseOracle from qiskit.compiler import transpile from qiskit import assemble from qiskit import IBMQ from qiskit import execute from qiskit.tools import job_monitor import matplotlib.pyplot as plt IBMQ.save_account('xxxxxxx', overwrite=True) IBMQ.load_account() provider = IBMQ.get_provider(hub='xxxx', group='xxxx', project='xxxx') device = provider.get_backend('ibmq_kolkata') circuit_list = [] verification_list = [] --------------------------------------------------------------------------- ImportError Traceback (most recent call last) ~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr) 147 try: --&gt; 148 from qiskit.providers import ibmq 149 ~\anaconda3\envs\qc_env\lib\site-packages\qiskit\providers\ibmq\__init__.py in &lt;module&gt; 85 ---&gt; 86 from qiskit.providers import BaseBackend, Backend # type: ignore[attr-defined] 87 ImportError: cannot import name 'BaseBackend' from 'qiskit.providers' (C:\Users\Ahmad\AppData\Roaming\Python\Python38\site-packages\qiskit\providers\__init__.py) The above exception was the direct cause of the following exception: MissingOptionalLibraryError Traceback (most recent call last) &lt;ipython-input-2-63cbbaf81b4b&gt; in &lt;module&gt; 14 import matplotlib.pyplot as plt 15 #import mapomatic as mm ---&gt; 16 IBMQ.save_account('xxxxxxx', overwrite=True) 17 IBMQ.load_account() 18 #provider = IBMQ.get_provider(hub = 'ibm-q') ~\AppData\Roaming\Python\Python38\site-packages\qiskit\__init__.py in \__getattr__(self, attr) 150 self.ibmq = ibmq.IBMQ 151 except ImportError as ex: --&gt; 152 raise MissingOptionalLibraryError( 153 &quot;qiskit-ibmq-provider&quot;, &quot;IBMQ provider&quot;, &quot;pip install qiskit-ibmq-provider&quot; 154 ) from ex MissingOptionalLibraryError: &quot;The 'qiskit-ibmq-provider' library is required to use 'IBMQ provider'. You can install it with 'pip install qiskit-ibmq-provider'.&quot;",<python-3.x><qiskit>,10/05/2022 16:01,73988665.0,73988665.0,It was a Jupyter Notebook issue. Uninstalling and reinstalling it solved the problem.,10/07/2022 14:25
74207230.0,Unable to install tensorflow-quantum using pip,"Using the command pip install tensorflow-quantum gives the following error: ERROR: Could not find a version that satisfies the requirement tensorflow-quantum (from versions: none) ERROR: No matching distribution found for tensorflow-quantum Not sure why the versions is none. Also, not sure how to proceed. I can build from source but need help on this error.",<pypi><tensorflow-quantum>,10/26/2022 11:46,76757032.0,76757032.0,"This is because you are using a python version that does not support TensorFlow Quantum. TensorFlow Quantum is supported on Python 3.7, 3.8, and 3.9. Change your Python version to any of these then try reinstalling.",7/24/2023 18:08
74239149.0,TensorCirucit c.draw() NameError,I want to plot a circuit build with TensorCircuit using the draw method. I am working on Google Colab and have pip installed qiskit. Yet i get NameError: name 'QuantumCircuit' is not defined. I have also tried from qiskit import QuantumCircuit but still i get the same error. Executing the code on another JuypterHub works.,<google-colaboratory><draw><qiskit>,10/28/2022 17:49,74472050.0,74472050.0,pip install qiskit pip install pylatexenc import numpy as np from qiskit import * Once you are done with above code you have to restart your runtime so that installed library come into force into your colab environment. For restarting runtime: Click on Runtime Select Restart runtime Select Run all This help you to rectify your problem.,11/17/2022 8:07
75162746.0,ket.draw() not showing |00> : Qiskit,"ket.draw() must give |00&gt; as result but I get: Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) what can I change to get the desired result? This is my code: from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(2) # This calculates what the state vector of our qubits would be # after passing through the circuit 'qc' ket = Statevector(qc) # The code below writes down the state vector. # Since it's the last line in the cell, the cell will display it as output ket.draw()",<python><quantum-computing><qiskit>,1/18/2023 17:02,75162797.0,75162797.0,"You can pass the keyword argument output='latex' to the .draw method. from qiskit import QuantumCircuit from qiskit.quantum_info import Statevector qc = QuantumCircuit(2) # This calculates what the state vector of our qubits would be # after passing through the circuit 'qc' ket = Statevector(qc) # The code below writes down the state vector. # Since it's the last line in the cell, the cell will display it as output ket.draw(output='latex')",1/18/2023 17:07
76371779.0,Calculating CHSH inequality violation in a two-qubit system with projective measurements,Suppose a two-qubit system is in the state |Î¦â© = (|00â© + |11â© )/ â2. Consider projective measurements with outcome Â±1. Calculate the maximal violation of the CHSH inequality and find the measurement setting that can result the maximal violation. I am new to quantum computing.I don't know how to solve this problem.,<quantum-computing>,5/31/2023 8:58,76427971.0,76427971.0,"I's a tough one and one I struggled with too. Calculating the maximal violation of the CHSH inequality for the given two-qubit state |Î¦â© = (|00â© + |11â© )/ â2, we need to consider four different measurement settings and compute the corresponding expectation values. The CHSH inequality is expressed as follows: CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B') â¤ 2, where A, A' are the measurement settings for the first qubit there, and B, B' are the measurement settings for the second qubit, and E(A, B) is the expectation value for the measurement settings A and B. If that makes sense? Now considering the four measurement settings: Setting 1: A = Ïz (measurement in the computational basis for the first qubit) B = Ïz (measurement in the computational basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïz)|Î¦â©. Expanding the tensor product and substituting |Î¦â© = (|00â© + |11â© )/ â2: E(A, B) = â¨Î¦|(Ïz â Ïz)|Î¦â© = (1/â2)(â¨00|(Ïz â Ïz)|00â© + â¨00|(Ïz â Ïz)|11â© + â¨11|(Ïz â Ïz)|00â© + â¨11|(Ïz â Ïz)|11â©) = (1/â2)(1 + 1 + 1 - 1) = 2/â2 = â2. Setting 2: A = Ïx (measurement in the Hadamard basis for the first qubit) B = Ïz (measurement in the computational basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïz)|Î¦â©. Using the same steps as above, we find: E(A, B) = -1/â2. Setting 3: A = Ïz (measurement in the computational basis for the first qubit) B = Ïx (measurement in the Hadamard basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïz â Ïx)|Î¦â©. Using the same steps as above, we find: E(A, B) = -1/â2. Setting 4: A = Ïx (measurement in the Hadamard basis for the first qubit) B = Ïx (measurement in the Hadamard basis for the second qubit) In this case, the expectation value E(A, B) can be calculated as follows: E(A, B) = â¨Î¦|A â B|Î¦â© = â¨Î¦|(Ïx â Ïx)|Î¦â©. Using the same steps as above, we find: E(A, B) = -â2. Now, let's calculate the maximal violation of the CHSH inequality: CHSH = E(A, B) + E(A, B') + E(A', B) - E(A', B') = â2 + (-1/ Hope that helps you.",06/08/2023 00:58
76772726.0,How can I use quantum entanglement to improve the performance of my web application?,"This question blends cutting-edge quantum physics concepts with web application performance, which is not a common topic of discussion on Stack Overflow. While quantum computing and its potential applications are gaining attention, it's still relatively new and not a mainstream topic in web development. However, as technology continues to advance, this type of question may become more relevant in the future. Remember, Stack Overflow is a collaborative platform for programmers, and the questions asked there are usually more focused on practical coding challenges and development issues. Speculative or theoretical questions might not be as common, but who knows what the future will bring? I am expecting a better solution for this!",<web><quantum-computing>,7/26/2023 15:10,76772738.0,76772738.0,"But hey, who knows what the future holds? Technology advances rapidly, and we've seen some incredible breakthroughs in the past. Perhaps one day, we'll find a way to leverage quantum entanglement or other quantum principles to revolutionize how we handle web application performance. Until then, let's keep pushing the boundaries of what's possible in both quantum computing and web development separately. Exciting times are ahead! Remember, innovation often comes from asking daring and unconventional questions, so keep dreaming big and exploring new ideas. Who knows? Your question might just inspire the next big leap in technology!",7/26/2023 15:12
2258685.0,Quantum Computers: can we start programming it?,"Although we'll have to wait at least two or three decades until we can see a practical QC, it seems that theoretical studies are improving dramatically (studies using the free QLC language are good examples). However, does that make us expect that big companies and corporations are building (maybe secretly) âquantum softwareâ: each seeking to get the leadership in this domain?",<quantum-computing>,2/13/2010 19:09,,,,
3392445.0,How do qubits work and what are their pros and cons? What impact will they have on programming languages?,"What can we do more with qubits than normal bits, and how do they work? I read about them some time ago, and it appears that qubits can store not just 0 or 1, but also 0 and 1 at the same time. I don't really understand how they work. Can someone please explain this to me? What are their pros and cons, and what impact will they have on programming languages like C after quantum computers are actually invented? How would we manage memory when a bit (which is also a quantum) can take multiple values at once? How can we determine if something is true or false, when there is more than just 1 and 0?",<memory><quantum-computing>,08/02/2010 22:59,,,,
4595156.0,Software simulation of a quantum computer,"While we are waiting for our quantum computers, is it possible to write a software simulation of one? I suspect the answer is no, but hope the reasons why not will throw some light on the mystery.",<simulation><quantum-computing>,01/04/2011 15:15,,,,
4866531.0,Quantum Key:Logic behind this?,I have a project i.e. third party authentication using Quantum Key. But we are facing lot of problems related to hardware so now we are focusing on simulation. So can anyone guide me what type of simulation we should use?,<security><networking><quantum-computing><quantumgrid>,02/01/2011 18:36,,,,
7131569.0,Deutsch-Jozsa algorithm,"When I was reading about quantum algorithms I faced the Deutsch-Jozsa algorithm, I see that if we want to solve that problem in a non-quantum algorithm, our algorithm would have exponential time complexity. Now I want to know what is the time complexity of Deutsch-Jozsa algorithm as a quantum algorithm on quantum computers?",<algorithm><time-complexity><complexity-theory><quantum-computing>,8/20/2011 11:50,,,,
7680526.0,Solving chess with a quantum computer,Given that the game-tree complexity of the game of chess is at least 10123 and quantum computers may eventually become millions of times faster than a classical computer; will it be possible for a quantum algorithm to process each possible combination of moves within a lifetime?,<quantum-computing>,10/06/2011 21:14,,,,
9845959.0,How do I implement a set of qubits on my computer?,"I would like to get familiar with quantum computing basics. A good way to get familiar with it would be writing very basic virtual quantum computer machines. From what I can understand of it, the, effort of implementing a single qubit cannot simply be duplicated to implement a two qubit system. But I don't know how I would implement a single qubit either. How do I implement a qubit? How do I implement a set of qubits?",<quantum-computing>,3/23/2012 20:15,,,,
13379089.0,Would quantum computers affect the C++ language?,"The advent of quantum computers could still be decades from now. Nevertheless, because software gets incredibly complex these days, it would be good to know if C++, one of the most used programming languages to develop such software, is able to project itself into the future where quantum computing is a norm and, in addition to portability across platforms, ensure portability of such software over decades.",<c++><portability><quantum-computing>,11/14/2012 12:46,,,,
17568480.0,How much I should know in Computer Science to work with Quantum Computing,"I browsed some books about quantum computers and there is some concepts from computer science (for example, Turing machine) except quantum physics and mathematics. So, if I want to study quantum computing what I should know from computer science? Is it useful to read SICP, for example?",<computer-science><quantum-computing>,07/10/2013 10:38,,,,
19761700.0,How can I run QCL (quantum programming language) on Windows?,I'm sure someone must have done this before. I've tried compiling QCL for Cygwin but it just doesn't work. If someone has already managed to compile it for Cygwin can you please post a copy? Or alternatively suggest an easier way to run it in Windows.,<quantum-computing><qcl>,11/04/2013 04:34,,,,
21681474.0,A quantum algorithm with high probability on a 4 to 1 function,"Let f : {0, 1}â¿ â {0, 1}â¿ be a 4-to-1 function, such that there exist distinct and non-zero a, b â {0, 1}â¿ such that for all x â {0, 1}â¿: f(x) = f(x â a) = f(x â b) = f(x â a â b). Note that â is a bit-wise xor, and that for all y â {x, x â a, x â b, x â a â b}, f(y) â f(x). Find a quantum algorithm that with high probability reports the set {a, b, a â b}.",<quantum-computing>,02/10/2014 15:39,,,,
25898403.0,Python QuTip: Plot full lines in Bloch sphere,"I've recently started using QuTip for Python. I've want to plot the evolution of a two-level system in a Bloch sphere using qutip.Bloch(), but I don't know how to make such a plot as a continuous line. This is the code I currently use: bola = Bloch() bola.add_points(pnts) bola.point_marker = ['o'] bola.point_size=[8] bola.show() And of course I get a standard Bloch sphere with a lot of discrete points. Is there any way to join the points with a straight line?",<python><qutip>,9/17/2014 19:04,,,,
26357131.0,Predictability of Pseudo Random Generators by Quantum computers,"May classical pseudo random generators be predictable by powerful quantum computers in the future or is it proven that this is not possible? If they are predictable, do scientists know whether there exist PRGs that are unpredictable by quantum computers?",<random><quantum-computing>,10/14/2014 9:25,,,,
28969078.0,last step in Deutsch's algorithm,"In Deutsch's algorithm, with respect to a given function f, one ends up with the tensor product of two qubits, |f(0)+f(1) mod 2>|[(|0>-|1>)/sqrt(2)] This last step is to ""only"" measure the first qubit. How, precisely, does one extract the first qubit from a tensor product?",<linear-algebra><quantum-computing>,03/10/2015 16:29,,,,
30218492.0,Sympy: Expanding sum that involves Kets from its quantum module,"Today I started using sympy and its quantum module to implement some basic calculations in Bra-Ket notation. Executing the code: from sympy.physics.quantum import * from sympy.physics.quantum.qubit import * from sympy import * from sympy.abc import k print Sum(Ket(k),(k,0,5)) yields the expected result, that is, Sum(|k&gt;, (k, 0, 5)) is printed. Now I'd like to expand the sum and therefore write: print Sum(Ket(k),(k,0,5)).doit() However, this doesn't give the correct result, but prints out 6*|k&gt; which obviously is not the desired output. Apparently, the program doesn't recognize Ket(k) as depending on the index k. How could I work around or solve this issue?",<python><sympy><quantum-computing>,5/13/2015 14:53,,,,
33614988.0,Matlab call setter inside getter,"I'm trying an interesting experiment using Matlab. The goal here is to model a pair of quantum entangled particles with a simple binary model (The ""unknown"" or ""superposition"" state being ignored for the moment). This is not looking for physics advice, I know this is a gross oversimplification of a qubit. I want to model one specific aspect/process of the particle. The process being modeled is this: whenever you try to ""read"" the state of the particle, you also change the state of the particle. In this case, I'm only modeling two pure states, 0 and 1. This leads to an interesting programming problem where I can't see a way to model this without breaking conventional programming wisdom, or at all. Here is the source for my first try: classdef qparticle %qparticle class % models spin state of one of two particles in a quantum entangled pair properties observed_spin_state; end properties (Hidden = true) spinstate = []; end methods function obj = qparticle(initspin) if islogical(initspin) obj.spinstate = initspin; else obj.spinstate = NaN; end end function value = get.observed_spin_state(obj) %Getting spin state changes spinstate obj.spinstate = ~obj.spinstate; value = obj.spinstate; end %% set.spinstate should be private, only callable by getspinstate function obj = set.spinstate(obj, value) if islogical(value) obj.spinstate = value; else obj.spinstate = NaN; end end end end I have an overarching class qpair which will ensure that the two qparticles within it are always in opposite states, but that code is not necessary for this. I think I understand what is going on here, that when I call the getter, the object is being passed ""by value"" - a copy of it is going to the getter, so when I make the statement obj.spinstate = ~obj.spinstate, the local copy of obj is modified, but it is not passed back to the obj that called the function, thus the flipping of the bit does not go back to the parent object. If I use a setter, a handle class, or other function which returns the object itself, then I have no way to return the actual value to the calling function (I think). How can I have a single method in the object essentially perform both the set/get? (It's OK if I am not able to use the assignment operator '=', and it's OK if it has to call other methods).",<matlab><oop><quantum-computing>,11/09/2015 17:44,,,,
34347817.0,How do I run the Initial value x0 also in parallel,"This code works fine but the plot is not correct because the optimization function fmincon will depend on the initial condition x0 and the number of iterations. For each value of alpha (a) and beta (b), I should run the optimization many times with different initial conditions x0 to verify that I am getting the right answer. More iterations might be required to get an accurate answer. I want to be able to run the optimization with different initial conditions for x0, a and b. Function file function f = threestate2(x,a,b) c1 = cos(x(1))*(cos(x(5))*(cos(x(9))+cos(x(11)))+cos(x(7))*(cos(x(9))-cos(x(11))))... +cos(x(3))*(cos(x(5))*(cos(x(9))-cos(x(11)))-cos(x(7))*(cos(x(9))+cos(x(11)))); c2=sin(x(1))*(sin(x(5))*(sin(x(9))*cos(x(2)+x(6)+x(10))+sin(x(11))*cos(x(2)+x(6)+x(12)))... +sin(x(7))*(sin(x(9))*cos(x(2)+x(8)+x(10))-sin(x(11))*cos(x(2)+x(8)+x(12))))... +sin(x(3))*(sin(x(5))*(sin(x(9))*cos(x(4)+x(6)+x(10))-sin(x(11))*cos(x(4)+x(6)+x(12)))... -sin(x(7))*(sin(x(9))*cos(x(4)+x(8)+x(10))+sin(x(11))*cos(x(4)+x(8)+x(12)))); f=(a*a-b*b)*c1+2*a*b*c2; Main file %x=[x(1),x(2),x(3),x(4),x(5),x(6),x(7),x(8),x(9),x(10),x(11),x(12)]; % angles; lb=[0,0,0,0,0,0,0,0,0,0,0,0]; ub=[pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi]; x0=[pi/8;0;pi/3;0;0.7*pi;.6;0;pi/2;.5;0;pi/4;0]; xout=[]; fout=[]; options = optimoptions(@fmincon,'Algorithm','interior-point','TolX',10^-10,'MaxIter',1500); a=0:0.01:1; w=NaN(length(a)); for i=1:length(a) bhelp=(1-a(i)*a(i)); if bhelp&gt;0 b=sqrt(bhelp); [x,fval]=fmincon(@(x)threestate2(x,a(i),b),x0,[],[],[],[],lb,ub,[],options); w(i)=fval; w(i)=-w(i); B(i)=b; else w(i)=NaN; B(i)=b; end end %surface(b,a,w) %view(3) %meshc(b,a,w) x=a.^2; plot(x,w) grid on ylabel('\fontname{Times New Roman} S_{max}(\Psi_{gs})') xlabel('\fontname{Times New Roman}\alpha^2') %ylabel('\fontname{Times New Roman}\beta') title('\fontname{Times New Roman} Maximum of the Svetlichny operator(\alpha|000&gt;+\beta|111&gt;)')",<matlab><quantum-computing>,12/18/2015 2:49,,,,
35388321.0,show the qubit state Î±|001âª+Î³|100âª can be written as a product state of two of the qubits and the remaining qubit,"I need to show that the state Î±|001âª+Î³|100âª can be written as a product state of two of the qubits and the remaining qubit.? I have tried this Î±|0âªâ£01âª+Î³|10âªâ£0âª Î±(|0âª+â£1âª)â£01âª+Î³|10âª(â£0âª+â£1âª) Î±(|001âª+â£101âª)+Î³(|100âª+â£101âª), but this â Î±|001âª+Î³|100âª Can you please help me with this ? Thank you for your assistance .",<quantum-computing>,2/14/2016 4:20,,,,
35568035.0,Plotting 3 variables against 1 variable,"I have a code that computes the max value. this code consists of four variables www is the function of a,b, and c labaled xx, yy, and zz respectively, so my question is how can i plot www against xx,yy, and zz? Thanks for helping objfun file function f=W4qubit(x,a,b,c,d) c1=-cos(x(1))*(cos(x(5))*(cos(x(9))*(cos(x(13))-cos(x(15)))-cos(x(11))*(cos(x(13))+cos(x(15))))+... cos(x(7))*(cos(x(11))*(cos(x(15))-cos(x(13)))-cos(x(9))*(cos(x(13))+cos(x(15)))))-... cos(x(3))*(cos(x(5))*(cos(x(11))*(cos(x(15))-cos(x(13)))-cos(x(9))*(cos(x(13))+cos(x(15))))-... cos(x(7))*(cos(x(9))*(cos(x(13))-cos(x(15)))-cos(x(11))*(cos(x(13))+cos(x(15))))); c2=cos(x(1))*(cos(x(5))*(sin(x(9))*(sin(x(13))*cos(x(10)-x(14))-sin(x(15))*cos(x(10)-x(16)))-... sin(x(11))*(sin(x(13))*cos(x(12)-x(14))+sin(x(15))*cos(x(12)-x(16))))+... cos(x(7))*(sin(x(11))*(sin(x(15))*cos(x(12)-x(16))-sin(x(13))*cos(x(12)-x(14)))-... sin(x(9))*(sin(x(13))*cos(x(10)-x(14))+sin(x(15))*cos(x(10)-x(16)))))+... cos(x(3))*(cos(x(5))*(sin(x(11))*(sin(x(15))*cos(x(12)-x(16))-sin(x(13))*cos(x(12)-x(14)))-... sin(x(9))*(sin(x(13))*cos(x(10)-x(14))+sin(x(15))*cos(x(10)-x(16))))-... cos(x(7))*(sin(x(9))*(sin(x(13))*cos(x(10)-x(14))-sin(x(15))*cos(x(10)-x(16)))-... sin(x(11))*(sin(x(13))*cos(x(12)-x(14))+sin(x(15))*cos(x(12)-x(16))))); c3=cos(x(1))*(sin(x(5))*(cos(x(9))*(sin(x(13))*cos(x(6)-x(14))-sin(x(15))*cos(x(6)-x(16)))-... cos(x(11))*(sin(x(13))*cos(x(6)-x(14))+sin(x(15))*cos(x(6)-x(16))))+... sin(x(7))*(cos(x(11))*(sin(x(15))*cos(x(8)-x(16))-sin(x(13))*cos(x(8)-x(14)))-... cos(x(9))*(sin(x(13))*cos(x(8)-x(14))+sin(x(15))*cos(x(8)-x(16)))))+... cos(x(3))*(sin(x(5))*(cos(x(11))*(sin(x(15))*cos(x(6)-x(16))-sin(x(13))*cos(x(6)-x(14)))-... cos(x(9))*(sin(x(13))*cos(x(6)-x(14))+sin(x(15))*cos(x(6)-x(16))))-... sin(x(7))*(cos(x(9))*(sin(x(13))*cos(x(8)-x(14))-sin(x(15))*cos(x(8)-x(16)))-... cos(x(11))*(sin(x(13))*cos(x(8)-x(14))+sin(x(15))*cos(x(8)-x(16))))); c4=cos(x(1))*(sin(x(5))*(sin(x(9))*cos(x(6)-x(10))*(cos(x(13))-cos(x(15)))-sin(x(11))*cos(x(6)-x(12))*(cos(x(13))+cos(x(15))))+... sin(x(7))*(sin(x(11))*cos(x(8)-x(12))*(cos(x(15))-cos(x(13)))-sin(x(9))*cos(x(8)-x(10))*(cos(x(13))+cos(x(15)))))+... cos(x(3))*(sin(x(5))*(sin(x(11))*cos(x(6)-x(12))*(cos(x(15))-cos(x(13)))-sin(x(9))*cos(x(6)-x(10))*(cos(x(13))+cos(x(15))))-... sin(x(7))*(sin(x(9))*cos(x(8)-x(10))*(cos(x(13))-cos(x(15)))-sin(x(11))*cos(x(8)-x(12))*(cos(x(13))+cos(x(15))))); c5=sin(x(1))*(cos(x(5))*(cos(x(9))*(sin(x(13))*cos(x(2)-x(14))-sin(x(15))*cos(x(2)-x(16)))-... cos(x(11))*(sin(x(13))*cos(x(2)-x(14))+sin(x(15))*cos(x(2)-x(16))))+... cos(x(7))*(cos(x(11))*(sin(x(15))*cos(x(2)-x(16))-sin(x(13))*cos(x(2)-x(14)))-... cos(x(9))*(sin(x(13))*cos(x(2)-x(14))+sin(x(15))*cos(x(2)-x(16)))))+... sin(x(3))*(cos(x(5))*(cos(x(11))*(sin(x(15))*cos(x(4)-x(16))-sin(x(13))*cos(x(4)-x(14)))-... cos(x(9))*(sin(x(13))*cos(x(4)-x(14))+sin(x(15))*cos(x(4)-x(16))))-... cos(x(7))*(cos(x(9))*(sin(x(13))*cos(x(4)-x(14))-sin(x(15))*cos(x(4)-x(16)))-... cos(x(11))*(sin(x(13))*cos(x(4)-x(14))+sin(x(15))*cos(x(4)-x(16))))); c6=sin(x(1))*(cos(x(5))*(sin(x(9))*cos(x(2)-x(10))*(cos(x(13))-cos(x(15)))-sin(x(11))*cos(x(2)-x(12))*(cos(x(13))+cos(x(15))))+... cos(x(7))*(sin(x(11))*cos(x(2)-x(12))*(cos(x(15))-cos(x(13)))-sin(x(9))*cos(x(2)-x(10))*(cos(x(13))+cos(x(15)))))+... sin(x(3))*(cos(x(5))*(sin(x(11))*cos(x(4)-x(12))*(cos(x(15))-cos(x(13)))-sin(x(9))*cos(x(4)-x(10))*(cos(x(13))+cos(x(15))))-... cos(x(7))*(sin(x(9))*cos(x(4)-x(10))*(cos(x(13))-cos(x(15)))-sin(x(11))*cos(x(4)-x(12))*(cos(x(13))+cos(x(15))))); c7=sin(x(1))*(sin(x(5))*cos(x(2)-x(6))*(cos(x(9))*(cos(x(13))-cos(x(15)))-cos(x(11))*(cos(x(13))+cos(x(15))))-... sin(x(7))*cos(x(2)-x(8))*(cos(x(11))*(cos(x(15))-cos(x(13)))-cos(x(9))*(cos(x(13))+cos(x(15)))))+... sin(x(3))*(sin(x(5))*cos(x(4)-x(6))*(cos(x(11))*(cos(x(15))-cos(x(13)))-cos(x(9))*(cos(x(13))+cos(x(15))))-... sin(x(7))*cos(x(4)-x(8))*(cos(x(9))*(cos(x(13))-cos(x(15)))-cos(x(11))*(cos(x(13))+cos(x(15))))); A2=2*a*b; A3=2*a*c; A4=2*b*c; A5=2*a*d; A6=2*b*d; A7=2*c*d; f1=c1+A2*c2+A3*c3+A4*c4+A5*c5+A6*c6+A7*c7; f=-(f1^2); my main file of the code clear close clc %x=[x(1),x(2),x(3),x(4),x(5),x(6),x(7),x(8),x(9),x(10),x(11),x(12),x(13),x(14),x(15),x(16)]; % angles; lb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; ub=[pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi,pi,2*pi]; options = optimoptions(@fmincon,'TolX',10^-12,'MaxIter',1500,'MaxFunEvals',10^8,'Algorithm','sqp','TolFun',10^-8); a=0:0.1:1; b=0:0.1:1; c=0:0.1:1; w=NaN(length(a),length(b),length(c)); ww=NaN(length(a),length(b),length(c)); www=NaN(length(a),length(c)); for k=1:100 x0=rand([1,16]).*ub*.9986;%7976 for i=1:length(a) for j=1:length(b) for l=1:length(c) dhelp=1-(a(i)^2)-(b(j)^2)-(c(l)^2); if (dhelp&gt;0 || dhelp==0) d=sqrt(dhelp); [~,fval]=fmincon(@(x)W4qubit(x,a(i),b(j),c(l),d),x0,[],[],[],[],lb,ub,[],options); w(i,j,l)=sqrt(-fval); else w(i,j,l)=nan; end ww=max(w,ww); end end end end www=max(ww,[],3); yy=b.^2;xx=a.^2;zz=c.^2; meshc(xx,yy,www) grid on zlabel('\fontname{Times New Roman} M_{max}') xlabel('\fontname{Times New Roman}\alpha^2') ylabel('\fontname{Times New Roman}\gamma^2') %title('fontname{Times New Roman} Maximum of the Svetlichny operator. Method 1 (alpha|0001&gt;+beta|0010&gt;+gamma|1000&gt;)')",<matlab><quantum-computing>,2/23/2016 3:06,,,,
36262270.0,How does measurement gate work?,"I have a state |Q&gt; of n bits and want to measure the bit number i. Is there a matrix to apply on the state, so the state Q ends up to Q', like the Hadamard or X gates? Or I should apply the measurement matrix |x&gt;&lt;x| based on the outcome of the measurement, if 0 then x=0, and if 1 then x=1?",<quantum-computing>,3/28/2016 12:25,,,,
36753924.0,Quantum computing Justin Trudeaus explanation how much valid?,What is the difference between normal computer and a quantum computer ? Was Justin Trudeau's explanation about quantum computing correct ?,<quantum-computing>,4/20/2016 19:56,,,,
36916851.0,Monte Carlo solver in parallel with QuTiP,"I'm trying to run some code in QuTiP, but when I run a function in parallel with parfor I am getting an error. results= parfor(func2, range(len(delta))) Error: AssertionError Traceback (most recent call last) &lt;ipython-input-206-6c2ffcb32b4f&gt; in &lt;module&gt;() ----&gt; 1 results= parfor(func2, range(len(delta))) /usr/lib/python2.7/dist-packages/qutip/parallel.pyc in parfor(func, *args, **kwargs) 119 try: 120 map_args = ((func, v, os.getpid()) for v in var) --&gt; 121 par_return = list(pool.map(task_func, map_args)) 122 123 pool.terminate() /usr/lib/python2.7/multiprocessing/pool.py in map(self, func, iterable, chunksize) 249 ''' 250 assert self._state == RUN --&gt; 251 return self.map_async(func, iterable, chunksize).get() 252 253 def imap(self, func, iterable, chunksize=1): /usr/lib/python2.7/multiprocessing/pool.py in get(self, timeout) 556 return self._value 557 else: --&gt; 558 raise self._value 559 560 def _set(self, i, obj): AssertionError: daemonic processes are not allowed to have children Here is my code: def func2(x): def H1_coeff(t,args): return exp(-((t-4)/2.0) ** 2) H0 = np.pi*w * a.dag() *a Hi= delta[x]*(a.dag()) H = [H0, [Hi,H1_coeff]] result = mesolve(H, psi0, tlist, c_ops, []) numer=expect(n,result.states) print delta[x], ""done"" return numer Does anybody know what's wrong here?",<parallel-processing><montecarlo><qutip>,4/28/2016 13:55,,,,
41702337.0,"Can we break RSA/AES encrypted document using quantum algorithms? If yes, How can we do it?","RSA and AES-256 are defined standards for encrypting ""Top Secret"" documents. Is it possible to attack using quantum algorithms like shor's and grover's?",<cryptography><aes><rsa><quantum-computing>,1/17/2017 16:35,,,,
42007805.0,Fast eigenvectors finding on a HPC using Qutip and slepc4py,"I am doing some numeric simulations of quantum computation, and I wish to find the eigenvectors of a big hermitian matrix (~2^14 rows/columns) I am running on a 24 core/48 threads XEON machine. The code was originally written with the help of the Qutip library. I found out that the included eigenstates() function only utilizes a single thread on my machine so I am trying to find a faster way to do that. I tried using scipy.linalg eig() and eigh() functions as well as scipy.sparse.linalg eig() and eigh() but both seem slower than the function built in Qutip. I've seen some suggestion that I might get some speedup from using slepc4py, however the documentation of the package seems very lacking. I cant find out how to convert the numpy complex array to a SLEPC matrix. A = PETSc.Mat().create() A[:,:] = B[:,:] # where B is a scipy array of complex type TypeError: Cannot cast array data from dtype('complex128') to dtype('float64') according to the rule 'safe'",<python><scipy><mpi><eigenvector><qutip>,02/02/2017 16:48,,,,
42123693.0,Matlab memory leak when forward propagating cell arrays or 3D matrices,"I'm having an issue with the way Matlab is dealing with forward multiplying matrices when there are a large number of them. As a simplified example, i'd like to do x(ii + 1) = y(ii) * x(ii). However when the dimensions of the matrix are large, and there are a lot of them, the memory requirement grows exponentially, way out of range for what it should be. Here's some example code, where according to the matlab memory profiler it's using 1e-07TB of RAM, which although isn't correct this loop often takes up 256GB of RAM. function forward_test() K = 250; dim = 1024; U = cell(K,1); for ii = 1 : K U{ii} = rand(dim,dim) + (1i*rand(dim,dim)); end r_tmp = cell(K + 1, 1); r_tmp{1} = eye(dim); for k = 1 : K r_tmp{k+1} = U{k} * r_tmp{k}; % &lt;--- this line is the issue end % convert the matrix to a 3D array, I'm certian there's a better way of doing this, but this is quick and dirty u_test = zeros(dim, dim, K); for ii = 1 : K u_test(:,:,ii) = U{ii}; end % test the same operation on a 3D array, rather than a set of 2D maricies. tmp2 = zeros(dim, dim, K + 1); tmp2(:,:,1) = eye(dim); for ii = 1 : K tmp2(:,:, ii + 1) = U{ii} * tmp2(:,:,ii); end for ii = 1 : numel(r_tmp) if ~(all(all(r_tmp{ii} == tmp2(:,:,ii)))) error('Result missmatch!'); end end end To check performance run: profile off profile -memory on forward_test profreport",<matlab><matrix><memory-leaks><quantum-computing>,02/08/2017 21:12,,,,
45476846.0,How is Iota on Tangle Quantum proof?,"I do understand Tangle has a graph based data structure i.e. forming a direct acyclic graph. It is not a merkle tree like a typical blockchain. But I could not figure out this relation makes it quantum proof or not. Is no-mining, and peer verification enough to make a distributed ledger quantum proof?",<iot><quantum-computing>,08/03/2017 06:49,,,,
47456221.0,Facebook Pixel 'View Product' Event not tracking,"Having real trouble getting this event configured. I use Qubit.com tag manager and this is the code I have used for the 'view product' event. This event is not tracking and I don't know why. This is the code - function () { var _this = this; console.log('1 FB ViewContent Start'); var product_ids = []; if(universal_variable.transaction.line_items){ for (var i = 0; i &lt; universal_variable.transaction.line_items.length; i++) { product_ids.push(universal_variable.transaction.line_items[i].product.sku_code) } } console.log('2 FB ViewContent Product List Compiled'); fbq('track', 'ViewContent', { content_ids: product_ids, content_type: 'product', value: """" + _this.valueForToken(""ORDER_TOTAL""), currency: """" + _this.valueForToken(""CURRENCY_CODE"") }); console.log('3 FB ViewContent Tracked'); }",<javascript><facebook><qubit>,11/23/2017 13:03,,,,
47616245.0,Microsoft Liquid: How to show the current quantum state,"I am programming quantum algorithms in Microsoft Liquid (F#). For debugging, it would be really nice to see what the current quantum state is. I can use: for q in qs do show ""q[%d]=%s"" q.Id (q.ToString()) where qs is my list of qubits, but this only works if the state is not entangled. However, if it is entangled, is there a way to just show the current quantum state, e.g.: ket = 1/sqrt(2)*[|00&gt;+|11&gt;]",<algorithm><f#><liquid><quantum-computing><qubit>,12/03/2017 07:28,,,,
49575282.0,configure: error: No working boost sleep implementation found,"we are using that commands in my vps Server my server configuration is: 2 GB Memory / 50 GB Disk / NYC1 - Ubuntu 14.04.5 x64 This is for VPS. ./autogen.sh ./configure --with-miniupnpc --enable-wallet --enable-upnp-default --disable-tests --enable-hardening --enable-debug --with-libressl CPPFLAGS=""-I/home/theusername/bitcoin/db4/include -O2"" LDFLAGS=""-L/home/theusername/bitcoin/db4/lib"" CXXFLAGS=""--param ggc-min-expand=1 --param ggc-min-heapsize=32768"" SSL_CFLAGS=-I/usr/local/openssl/include SSL_LIBS=-L/usr/local/openssl/lib CRYPTO_CFLAGS=-I/usr/local/openssl/include CRYPTO_LIBS=-L/usr/local/openssl/lib --with-boost=""/usr/include/boost"" --with-boost-libdir=""/usr/lib/x86_64-linux-gnu"" make After make command we getting this error (configure: error: No working boost sleep implementation found.)",<boost><bitcoin-testnet><qubit>,3/30/2018 13:21,,,,
50236440.0,Easy way to implement Qobj based in zeros and sigma in qutip,"I am new to qutip and I am struggling on the way to create quantum objects with such a shape in a much clever manner: from qutip import * object1 = Qobj([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]) object2 = Qobj([[0, 0, 0, -1j], [0, 0, 1j, 0], [0, 0, 0, 0], [0, 0, 0, 0]) And so on. The idea is to do so for all sigma submatrices with liberty on how to build in a nicer way usign sigma 2x2 matrix. Is there a better way to do so? Sincerely, Paul",<python-3.x><qutip>,05/08/2018 14:48,,,,
50546812.0,Is it possible to reproduce Quantum interferences with classic code?,Whilst I've heard of some quantum emmulators I don't know if I can recreate Quantum interferences (i.e. wave interferences) using them.,<quantum-computing>,5/26/2018 20:39,,,,
50611414.0,Jupyter notebook always gives BrokenProcessPool error while executing qiskit code,"defining function for toffoli gate: def toffoli(qc,i1,i2,i3): qc.h(i3) qc.cx(i2,i3) qc.tdg(i3) qc.cx(i1,i3) qc.t(i3) qc.cx(i2,i3) qc.tdg(i3) qc.cx(i1,i3) qc.t(i3) qc.tdg(i2) qc.cx(i1,i2) qc.h(i3) qc.tdg(i2) qc.cx(i1,i2) qc.t(i1) qc.s(i2) Defining the registers: qr=QuantumRegister(5) cr=ClassicalRegister(5) qc=QuantumCircuit(qr,cr) to run the code: qc.x(qr[0]) qc.x(qr[1]) toffoli(qc,qr[0],qr[1],qr[2]) qc.measure(qr[0],cr[0]) qc.measure(qr[1],cr[1]) qc.measure(qr[2],cr[2]) circuits=[qc] job=execute(circuits,backend=""local_qasm_simulator"") result=job.result() error: BrokenProcessPool Traceback (most recent call last) &lt;ipython-input-10-47786bf8d782&gt; in &lt;module&gt;() 1 circuits=[qc] ----&gt; 2 job=execute(circuits,backend) 3 job.status 4 result=job.result() ~\Anaconda3\envs\QISKitenv\lib\site-packages\qiskit\wrapper\_wrapper.py in execute(circuits, backend, config, basis_gates, coupling_map,initial_layout, shots, max_credits, seed, qobj_id, hpc, skip_translation) 202 q_job = QuantumJob(qobj, backend=backend, preformatted=True, resources={ 203 'max_credits': qobj['config']['max_credits']}) --&gt; 204 return backend.run(q_job) ~\Anaconda3\envs\QISKitenv\lib\site- packages\qiskit\backends\local\qasm_simulator_cpp.py in run(self, q_job) 83 def run(self, q_job): 84 """"""Run a QuantumJob on the the backend."""""" ---&gt; 85 return LocalJob(self._run_job, q_job) 86 87 def _run_job(self, q_job): ~\Anaconda3\envs\QISKitenv\lib\site-packages\qiskit\backends\local\localjob.py in __init__(self, fn, q_job) 44 self._q_job = q_job 45 self._backend_name = q_job.backend.name ---&gt; 46 self._future = self._executor.submit(fn, q_job) 47 48 def result(self, timeout=None): ~\Anaconda3\envs\QISKitenv\lib\concurrent\futures\process.py in submit(self, fn, *args, **kwargs) 450 with self._shutdown_lock: 451 if self._broken: --&gt; 452 raise BrokenProcessPool('A child process terminated ' 453 'abruptly, the process pool is not usable anymore') 454 if self._shutdown_thread: BrokenProcessPool: A child process terminated abruptly, the process pool is not usable anymore I executed this code earlier and it worked. now whichever code I run in Jupyter notebook, I get brokenprocesspool error in the line job=execute(circuits,backend) I am not able to understand how to remove this error. Any code i run in my Jupyter Notebook I get the same error in this line. I sent this code to a friend and it executed in his jupyter notebook. Please help.",<quantum-computing><qiskit>,5/30/2018 18:36,,,,
50920192.0,Does Q# support web development?,"I have read articles from different sites, cause I didn't wanna install it without knowing how it works first. I was wondering if Q#, a new programming language developed by Microsoft, supports web development?",<web-development-server><q#>,6/19/2018 3:25,,,,
51120917.0,Looping through an array in Q#,How to loop through the elements of an array and access them by their index in Q# language since the conventional looping in C++ doesn't work here.,<quantum-computing><q#>,07/01/2018 06:23,,,,
51206015.0,How to pass a register of qubits through an Oracle object in Q#,"Suppose I made a ReflectionOracle object using ReflectionStart() function which reflects about the |00...00> axis. But how do I pass my register of qubits through this oracle? Since this Oracle is an object I can't use it as a function. Is there a standard library tool similar to UseOracle(reflectionoracle,register) ?",<quantum-computing><q#>,07/06/2018 08:24,,,,
51469550.0,Microsoft Q# output to WPF or Windows Form,It is possible to interface a Q# class with a Windows Form or a WPF? The examples Microsoft provide in their Quantum Development Tool Kit seem only to interface with a Console.,<quantum-computing><q#>,7/22/2018 21:52,,,,
51731347.0,How can i manipulate a javaScript object,"From the below command: __qubit.deliver.cookie.v1.get('_qb_se') I retrieve something like: { 610333: { e:106949 t:1533657574344 }, 686672: { e:118370 t:1533657574344 }, 704213: { e:121077 t:1533657574344 }, 738557: { e:126419 t:1533657574344 }, 755358: { e:128988 t:1533657574344 }, 780710: { e:132748 t:1533657574344 } } I want to be able to access the key (eg 610333) and also the e (eg 106949). How can each value in different variables? Thanks,",<javascript><object><key><qubit>,08/07/2018 16:19,,,,
51758572.0,Microsoft quantum Development Kit with another PC,"I think that quantum teleportation can be realized by the Microsoft Quantum Development Kit, but by placing one piece of data (name A) on a PC not connected to the Internet and acting on one side (name B) Is it possible to react experimentally? In the sample code, I do not feel realized just by comparing two variables in one code in one PC.",<quantum-computing><q#>,08/09/2018 03:53,,,,
51895234.0,How do you use an operation written in another file in Q#?,File A has Operation Foo() : () { body{ ... } } I want to use Foo in another operation in File B Operation Bar() : (){ // How to use Foo? } File A and B may not be in the same folder.,<import><quantum-computing><q#>,8/17/2018 12:14,,,,
52226600.0,Cryptography in Q# - Is it possible?,"Title says it all. Since Quantum Computers are said to be the next big thing, I figured the speed at which these systems operate on should be enough to decrypt files/applications in a 'Brute Force' manner. Is it possible? When will it be possible?",<cryptography><q#>,09/07/2018 16:41,,,,
52743814.0,microsoft.quantum.development.kit qsc.dll error,.nuget\packages\microsoft.quantum.development.kit\0.2.1809.701-preview\tools\qsc\qsc.dll'. Format of the executable (.exe) or library (.dll) is invalid. How to repair qsc.dll?,<q#>,10/10/2018 15:31,,,,
53026483.0,on qutip is it possible to transform a state to vector?,"If I build a state from qutip import Bloch,basis state=(basis(2,0)+(0+1j)*basis(2,1)).unit() can I trasform it in a bloch-sphere vector? In this form: state -&gt; vec=np.array",<python><quantum-computing><qutip>,10/27/2018 21:35,,,,
53097483.0,How to simulate Grover's Algorithm in quantum computing?,"If I want to write a program to simulate Grover's algorithm, how could I write the oracle for it? If I already know the result, why should I use the search?",<quantum-computing>,11/01/2018 08:21,,,,
53386738.0,Pointer to related research (papers),"Recently, I was reading a paper (arXiv:1804.03719 [cs.ET]), which had the following quote (the most relevant part has been bolded), Quantum algorithms are often grouped into number-theory-based, oracle- based, and quantum simulation algorithms, such as for instance on the excellent Quantum Zoo site [57], which is largely based on the main quantum algorithmic paradigm that these algorithms use. These paradigms are the Quantum Fourier Transform (QFT), the Grover Operator (GO), the Harrow/Hassidim/Lloyd (HHL) method for linear systems, variational quantum eigenvalue solver (VQE), and direct Hamiltonian simulation (SIM). The fact that most known quantum algorithms are based on these few paradigms in combination is remarkable and perhaps surprising. The discovery of additional quantum algorithm paradigms, which should be the subject of intense research, could make quantum algorithms applicable across a much wider range of applications. I am very interested in exploring the topic of quantum algorithm paradigms. However, my usual approach of following the reference trail failed to unearth any relevant papers. If anyone has any suggestions regarding where to look, or know any relevant papers, I would appreciate your input. Thanks!",<quantum-computing>,11/20/2018 5:27,,,,
53414750.0,TypeError: 'Line3DCollection' object is not iterable,"I'm trying to create animation about how the value of a quantum bit would be changed by computation called X-gate, in form of an arrow. Here are the codes that I wrote. #Import libraries from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt from matplotlib import animation import numpy as np #Accept input (theta, phi) from a user print(""Put angle theta and phi, 0â¤ theta â¤180, 0â¤ phi â¤360"") theta = input(""theta:"") phi = input(""phi:"") theta = np.radians(float(theta)) phi = np.radians(float(phi)) #Calculate x,y,z coordinates X = np.sin(theta) * np.cos(phi) Y = np.sin(theta) * np.sin(phi) Z = np.cos(theta) #Adjusting the length of an arrow length = np.sqrt(X**2 + Y**2 + Z**2) if length &gt; 1: X = X/length Y = Y/length Z = Z/length # Figure of the animation fig = plt.figure() ax = fig.gca(projection='3d') ax.set_aspect(""equal"") u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j] x = np.cos(u)*np.sin(v) y = np.sin(u)*np.sin(v) z = np.cos(v) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.plot_wireframe(x,y,z, color=""black"") # Calculate x,y,z coordinates in the process of the change length = 9 xgate_theta = np.linspace(theta,theta+np.pi,length) xgate_phi = np.linspace(phi,phi,length) #Array of x,y,z coordinates xgate= [] # Only x coordinates xgate_x = [] # Only y coordinates xgate_y = [] # Only z coordinates xgate_z = [] for i in range(length): xgate_x.append(X) xgate_z.append(np.cos(xgate_theta[i])) xgate_y.append(np.sqrt(1-np.sqrt(xgate_x[i]**2+xgate_z[i]**2))*(-1)) for j in range(length): xgate.append(plt.quiver(0,0,0,xgate_x[j],xgate_y[j],xgate_z[j],color=""red"")) ani = animation.ArtistAnimation(fig,xgate,interval=1000) plt.show() Then, I got the following error. Traceback (most recent call last): File ""/Users/makotonakai/anaconda3/lib/python3.6/site- packages/matplotlib/cbook/__init__.py"", line 388, in process proxy(*args, **kwargs) File ""/Users/makotonakai/anaconda3/lib/python3.6/site-packages/matplotlib/cbook/__init__.py"", line 228, in __call__ return mtd(*args, **kwargs) File ""/Users/makotonakai/anaconda3/lib/python3.6/site-packages/matplotlib/animation.py"", line 1026, in _start self._init_draw() File ""/Users/makotonakai/anaconda3/lib/python3.6/site-packages/matplotlib/animation.py"", line 1556, in _init_draw for artist in f: TypeError: 'Line3DCollection' object is not iterable I cannot tell what line causes this error by just looking this error message. Can anybody tell me how I can fix this error?",<python-3.x><animation><quantum-computing>,11/21/2018 14:55,,,,
53668113.0,Gradient Descent huge loss function,"I'm facing a non-binary classification problem of this form: Input: 2-dimensional vector (x,y) with -1 &lt; x &lt; 1, -1 &lt; y &lt; 1. Output: 4-dimensional vector (p_0, p_1, p_2, p_3), where 0 &lt; p_i &lt; 1, and sum(p_i) &lt;= 1 (of course, i = 0,...,3). The program I use to classify them wants to simulate a 4-qubit quantum circuit, that meaning that I start with a 16-dimensional vector with a 1 as a first entry, and 0s elsewhere, and then I apply a series of rotations in the shape of matrix products. Rephrasing it a bit: I start with said 16-dimensional vector, and then I multiply it by a 16x16 matrix which depends on the point's first component ""x"", which renders a new 16-dimensional vector. Next, I multiply this new vector by a different matrix, now having ""y"" as a parameter. I call this process the ""encoding"" of the data. Once encoded, I use a set of matrices, depending on a different parameter each. A smart choice of these parameters is what will bring me the desired classification. So, after every product is calculated, I end up with a new 16-dimensional vector, which depends on every mentioned parameter, and we will call a(x,y). From here I design a target function f(x,y) = (p_0, p_1, p_2, p_3). Each of the p_i's will be a sum of some of a(x,y)'s components. Now, f(x,y) is the actual output I obtain for input (x,y). Let me call d(x,y) the desired output. My goal is to find a set of parameter values that makes f(x,y) be as close as possible to d(x,y) for a somewhat large amount of input data. d(x,y) can take only one of four possible values: (1,0,0,0) -dubbed as ""0"", (0,1,0,0) -dubbed as ""1"", (0,0,1,0) -dubbed as ""2"", (0,0,0,1) -dubbed as ""3"". The cost function I chose for this affair is a quadratic cost function. In order to minimize the cost function, I use a Gradient Descent algorithm. I compute the partial derivatives with a centered finite differences method. So, now that the program is described, my real problem: With this configuration, I obtain pretty high Cost (loss) values, ranging from 1.5 to about 4. In order to achieve these results, I run the Gradient Descent program for 30 times (epochs), with a learning rate of 1. I'm used to having really small loss values (0.25 used to be a very bad result for a very similar problem), but I do still not have a good enough grip of what is actually going on behind the numbers as to know whether I should be too worried about this or not. My program achieves a ~40% accuracy at its finest (trying several different sets of matrices) for a 1000 training points and a 1000 evaluating points. I assume that a high loss value might mean that my program is just not good enough to perform this classification, but I do not know to what extend shall I be able to obtain better results. Is there anything I'm doing utterly wrong, or is it just that this structure is not good enough for classifying? Thank you very much for any feedback in advance.",<machine-learning><classification><gradient-descent><loss-function><quantum-computing>,12/07/2018 10:56,,,,
53985617.0,How to change the line width while plotting over the Bloch sphere,"I am using QuTiP for the Bloch sphere plotting in Python. If I have several points on the Bloch sphere then I can connect them with a line using the command b.add_points(pnts,meth='l')| I wanted to know how can I change the linewidth of the line connecting these points.",<python><qutip>,12/31/2018 9:12,,,,
54002534.0,How to give aplot title while plotting a Bloch sphere using QuTiP,I am plotting a Bloch sphere figure using QuTiP. I want to give it a title. How can I do this? I searched on Google but could not find an answer.,<python><matplotlib><qutip>,01/02/2019 07:09,,,,
54639848.0,The trace of square matrix?,if A is nxn matrix of some basis |b>. How we can show that the trace of A is actually the sum of the diagonal elements? I want to understand why Aii = &lt; i |A| i >. I know unitary matrix can transform basis to another like U|b> = |b'>. can this help to understand the concept of the trace? I'm not a physics person so that might be straightforward to understand to others.,<matrix><physics><quantum-computing>,02/11/2019 22:03,,,,
54758076.0,Auto code completion in Visual Studio Q# IDE?,Title says it all... I canât find an option to trigger code completion or show me the available methods for a program. Is there even one?,<visual-studio-2017><q#>,2/19/2019 2:35,,,,
54838676.0,There is no document formatter for 'qsharp'-files installed,"I've recently started using Q# on VS Code. When I Press, ctrl+shift+I, I get the error about a missing document formatter. I've tried searching the extensions and settings, but I'm unable to find one that does the job (There is an extension which provides syntax highlighting, but it doesn't seem to do formatting though) :'(. I understand that Q# is a new language and as such is not a very popular one. So, all I want is to auto-indent using the same rules as C# for now. Is there a way I can get away with using the same formatter that VS Code uses for C# to indent? I've searched the settings for some simple setting to fill up or toggle but found none. I'm very confused about the whole settings.json thing and only enabled vim keybindings with great difficulty, so I can't really say I've played around with it. UPDATE: Basically, what I want to do is something like this in the settings.json file: if (filetype == 'qs'){ editor.formattype = 'C#'; }",<c#><visual-studio-code><code-formatting><auto-indent><q#>,2/23/2019 5:55,,,,
54856564.0,How to install VSCode Extensions in Ubuntu,"I'm trying to run a Q# program that uses Microsoft.Quantum.Extensions.Convert, I added to my project file and included it in the code, but when I run 'dotnet run', I get '/workspace/QSharp/QSharpTest/QSharpTest.csproj : error NU1101: Unable to find package Microsoft.Quantum.Extensions.Convert. No packages exist with this id in source(s): nuget.org'. QSharpTest.csproj &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt; &lt;PlatformTarget&gt;x64&lt;/PlatformTarget&gt; &lt;/PropertyGroup&gt; &lt;ItemGroup&gt; &lt;PackageReference Include=""Microsoft.Quantum.Canon""/&gt; &lt;PackageReference Include=""Microsoft.Quantum.Development.Kit""/&gt; &lt;PackageReference Include=""Microsoft.Quantum.Extensions.Convert""/&gt; &lt;/ItemGroup&gt; &lt;/Project&gt; Operations.qs namespace QSharpTest { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Primitive; open Microsoft.Quantum.Development.Kit; open Microsoft.Quantum.Extensions.Convert; operation HelloQ () : Unit { let hello = GetHello(); Message(hello); let multiple = multiply(2, 3); Message(ToStringI(multiple)); } function GetHello () : (String) { return ""Hello""; } function multiply (a : Int, b : Int) : (Int) { return a*b; } }",<visual-studio-code><ubuntu-18.04><q#>,2/24/2019 21:08,,,,
55038361.0,density matrix elements from qutip's mesolve as a function of time,I am using qutip's mesolve for the open system dynamics of a system. I need to save all the density matrix elements as a function of time. mesolve gives the options of returning the expectation value of any given operator only. I am wondering if there is a way of having each element of the density matrix as a function of time without having to write an operator for each element. Please help if you have any suggestions.,<qutip>,03/07/2019 07:34,,,,
55079006.0,How to install QCL in Windows in order to implement Grover's algorithm?,I installed QCL and could run it from command prompt but I couldn't import files. Please help me with the tutorials too if possible. Also let me know how to write codes in editor and compile it.,<quantum-computing>,03/09/2019 15:42,,,,
56873741.0,implementation of CNOT gate using a Hamiltonian,"I need to show that using following Hamiltonian (for a closed bipartite system), we are able to implement the Controlled-Not gate. The Hamiltonian is : ð»=g/4 (ð¼ â ðz )â (ð¼ â ðx) Any tips will be appreciated.",<quantum-computing>,07/03/2019 15:42,,,,
57170236.0,Pip install qiskit: Command errored out with exit status 255:,"I am trying to install Qiskit on elementaryOS juno running Python 3.7, using pip. I even upgraded to the latest pip. I get the following log: Building wheels for collected packages: qiskit Building wheel for qiskit (setup.py) ... error ERROR: Command errored out with exit status 255: command: /home/laura/.pyenv/versions/anaconda3-2019.03/bin/python -u -c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-p35oetbg/qiskit/setup.py'""'""'; __file__='""'""'/tmp/pip-install-p35oetbg/qiskit/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' bdist_wheel -d /tmp/pip-wheel-2ms47shp --python-tag cp37 cwd: /tmp/pip-install-p35oetbg/qiskit/ Complete output (1 lines): running bdist_wheel ---------------------------------------- ERROR: Failed building wheel for qiskit Running setup.py clean for qiskit Failed to build qiskit Installing collected packages: qiskit Running setup.py install for qiskit ... done Successfully installed qiskit-0.11.0",<python><pip><qiskit>,7/23/2019 18:31,,,,
57446750.0,What is Grover's algorithm in a big simplification?,"I'm new in quantum computing. I mean extremely new. I saw that there is some king of an algorithm called Grover's search algorithm. I have read that it searches through the database containing N-elements in order to find the specific element. I also read that standard computers would be doing it for many, many years while quantum computers would do it in just a few seconds. And that is what confuses me the most. How I understand this: Let's say we want to search the database containing 50.000 different names and we are looking for a name ""Jack"". The standard computer wouldn't do it for years right? I think there's matter of seconds or minutes as searching through the database containing names which is probably text won't take long... Example in python: names = [""Mark"", ""Bob"", ""Katty"", ""Susan"", ""Jack""] for i in range(len(names)): if names[i] == ""Jack"": print(""It's Jack!"") else: print(""It's not Jack :("") That's how I understand it. So let's imagine this list contains 50.000 names and we want to search for ""Jack"". I guess it wouldn't take long. So how does this Grover's algorithm works? I really can't figure it out.",<python><algorithm><quantum-computing>,08/11/2019 01:31,,,,
57527671.0,Is it possible to use Grover's algorithm for a real data search?,"Last time I modeled the Grover search algorithm with Pyquil from Rigetti. It works on simulator. My question is, if it is possible to use this algorithm for a real search problem (yes I know, quantum computers still far apart from performance to do) in databases or files - theoretically, or is this algorithm only useable for the special search for a function result? This is a theoretical question only.",<algorithm><computer-science><quantum-computing>,8/16/2019 15:54,,,,
58358117.0,"Given random quantum behavior, how are qubits expected to be coaxed to produce a meaningful output in a quantum computer?","My understanding of qubits is that their power lies in the fact that they ""can have many states at once."" But how would one go about taking advantage of this to get anything that relates to a concrete question/input/program and a meaningful output? My understanding is that the many states disappears once a measurement is taken, so I don't understand why entanglement would help because there is no additional information from an entangled pair once you know the state of one. In other words, how are quantum computers supposed to carry out more of a meaningful result than old soothsayers that threw bones for answers. Yes, the positions of the bones are randomly placed in one of many possible positions but how is this supposed to actually meaningfully relate to a computational program. I understand how computer gates work to create logic in traditional silicon computers. But they don't behave randomly. How is random behavior of cubits and the quantum world in general supposed to yield any useful result? The power seems to be based on the multistate randomness but why is this random state thought to somehow provide anything more than random output? Please answer for the type of computer google is building - not DWave ""quantum"" computers.",<quantum-computing>,10/12/2019 20:17,,,,
58476180.0,OR gate implementation using Toffoli gate,Can an OR gate be implemented using not more than 2 Toffoli gates? I have already implemented it using 3 Toffoli gates but couldn't find any way to implement it using 2 Toffoli gates.,<quantum-computing>,10/20/2019 18:45,,,,
58640135.0,Two mode Wigner function in python,"I have attempted to adjust the qutip Wigner function, for it to process two mode states, specifically for the iterative method. However the size of the array my output gives out is too big and I am unsure of why? That is when I try and calculate the Wigner logarithmic negativity using it, the integrals come out as arrays rather than singular values. The code and description of what it is meant to do is below: `import numpy as np from scipy import (zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, size, polyval, fliplr, conjugate, cos, sin) import scipy.sparse as sp import scipy.fftpack as ft import scipy.linalg as la from scipy.special import genlaguerre from scipy.special import binom from scipy.special import sph_harm from qutip.qobj import Qobj, isket, isoper from qutip.states import ket2dm from qutip.parallel import parfor from qutip.utilities import clebsch from scipy.special import factorial from qutip.cy.sparse_utils import _csr_get_diag from qutip import * def wigner2(psi, xvec1, yvec1, xvec2, yvec2, method='iterative', g=np.sqrt(2)): """"""Wigner function for a state vector or density matrix at points `xvec1 + i * yvec1` `xvec2 + i * yvec2` Parameters state : qobj A state vector or density matrix. xvec1 : array_like x-coordinates at which to calculate the Wigner function. yvec1 : array_like y-coordinates at which to calculate the Wigner function. xvec2 : array_like x-coordinates at which to calculate the Wigner function. yvec2 : array_like y-coordinates at which to calculate the Wigner function. g : float Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {'iterative'} Select method 'iterative', where 'iterative' uses an iterative method to evaluate the Wigner functions for density matrices :math:|m&gt;&lt;n|. The 'iterative' method is default, and in general recommended, but the 'laguerre' method is more efficient for very sparse density matrices (e.g., superpositions of Fock states in a large Hilbert space). The 'fft' method is the preferred method for dealing with density matrices that have a large number of excitations (>~50). Returns W : array Values representing the Wigner function calculated over the specified range [xvec1,yvec1] and [xvec2,yvec2] """""" if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'): raise TypeError('Input state is not a valid operator.') if psi.type == 'ket' or psi.type == 'bra': rho = ket2dm(psi) #always use density matrix else: rho = psi if method == 'iterative': return _wigner2_iterative(rho, xvec1, yvec1, xvec2, yvec2, g) else: raise TypeError( ""method must be 'iterative'"") def _wigner2_iterative(rho, xvec1, yvec1, xvec2, yvec2, g=np.sqrt(2)): """"""Using an iterative method to evaluate the wigner functions for the Fock state :math:|mp&gt;&lt;nq| The Wigner function is calculated as :math:W = \sum_{mpnq} \\rho_{mpnq} W_{mpnq} where :math:W_{mpnq} is the Wigner function for the density matrix :math:|mp&gt;&lt;nq|. In this implementation, for each row m*p, Wlist contains the Wigner functions Wlist = [0, ..., W_mpmp, ..., W_mpnq]. As soon as one W_mpnq Wigner function is calculated, the corresponding contribution is added to the total Wigner function, weighted by the corresponding element in the density matrix :math:rho_{mpnq}."""""" M1 = np.prod(ptrace(rho, 0).shape[0]) M2 = np.prod(ptrace(rho, 1).shape[0]) M = np.prod(rho.shape[0]) X1, Y1, X2, Y2 = np.meshgrid(xvec1, yvec1, xvec2, yvec2) A1 = 0.5 * g * (X1 + 1.0j * Y1 + 0 * X2 + 0 * Y2) A2 = 0.5 * g * (0 * X1 + 0 * Y1 + X2 + 1.0j * Y2) Wlist1 = array([zeros(np.shape(A1), dtype=complex) for k in range(M)]) Wlist2 = array([zeros(np.shape(A2), dtype=complex) for k in range(M)]) W = real(rho[0, 0]) * real(Wlist1[0] * Wlist2[0]) for m in range(0,M1): if m==0: Wlist1[0] = exp(-2.0 * abs(A1) ** 2) / (pi) else: Wlist1[m] = ((2.0 * A1 * Wlist1[m - 1]) / sqrt(m)) for n in range(0, M2): if n==0: Wlist2[0] = exp(-2.0 * abs(A2) ** 2) / (pi) else: Wlist2[n] = ((2.0 * A2 * Wlist2[n - 1]) / sqrt(n)) if m != 0 and n != 0: W += 2 * real(rho[0, m * M2 + n] * Wlist1[m] * Wlist2[n]) for p in range(0, M1): temp1 = copy(Wlist1[m]) temp2 = copy(Wlist2[n]) if p==0: Wlist1[p] = exp(-2.0 * abs(A1) ** 2) / (pi) else: Wlist1[p] = ((2.0 * conj(A1) * temp1 -sqrt(p) * Wlist1[p-1]) / sqrt(p)) for q in range(0, M2): if q==0: Wlist2[q] = exp(-2.0 * abs(A2) ** 2) / (pi) else: Wlist2[q] = ((2.0 * conj(A2) * temp2 - sqrt(q) * Wlist1[q - 1]) / sqrt(q)) W += 2 * real(rho[p * M2 + q, p * M2 + q] * Wlist1[p] * Wlist2[q]) if p != 0 and q !=0: for k in range(p + 1, M1): temp3 = (2 * A1 * Wlist1[k-1] - sqrt(k) * temp1) / sqrt(k) temp1 = copy(Wlist1[k]) Wlist1[k] = temp3 for l in range(q +1, M2): temp4 = (2 * A2 * Wlist2[l-1] - sqrt(l) * temp2) / sqrt(l) temp2 = copy(Wlist2[l]) Wlist2[l] = temp4 W += 2 * real(rho[p * M2 + q, k *M2 +l] * Wlist1[k] * Wlist2[l]) return 0.5 * W * g **2'",<python><numpy><scipy><qutip>,10/31/2019 9:21,,,,
58720137.0,Getting a not enough input arguments error,"I'm trying to plot the Yukawa Potential in Matlab and I want to have my program go through user inputs for the values alpha (called alph in my program) and l. The values I need to use are 0.1, 0.2 and 0.3 for alpha with values of 0, 1 and 2 of l for each value of alpha. I know I could set up a loop for this but it doesn't have to be pretty and I want to test the values one at a time. Anyway I keep getting an error after I input the values for alpha, the error I keep getting is in my function, saying that I don't have enough input arguments. The output should be the T matrix, the Hamiltonian matrix and a plot of the first 10 eigenfunctions. I've tried going in and simply defining alpha as the numbers I want to look at and the program works fine with displaying the output I'm looking for. I just want to be able to change the values for alpha without having to change the program itself. I haven't had any problems with the l inputs. r = linspace(0.05,19.95,1999) n = 1999 dr = 0.05 a = full(gallery(""tridiag"",n,1,-2,1)) T = -0.5*a/(dr^2) l = input('Input a value for l.') alph = input('Input a value for alpha.') v = arrayfun(@(r) yuk_pot(r,l),r); V = diag(v) H = T + V [O,D] = eig(H); plot(r,O(:,1),r,O(:,2),r,O(:,3),r,O(:,4),r,O(:,5),r,O(:,6),r,O(:,7),r,O(:,8),r,O(:,9),r,O(:,10)) function v = yuk_pot(r,alph,l) v = (-exp(-alph*r)/r) + 0.5*(l*(l+1)/(r^2)); end",<matlab><function><input><quantum-computing>,11/05/2019 22:00,,,,
58784924.0,How to write C# implementation for a Q# operation with intrinsic body?,"I have created a library in C# to be used in Q# programs. The library has two scripts, a C# class library called ""Class1.cs"" and a matching Q# script called ""Util.qs"", I share the code snippet of each here: Class1.cs: using System; using Microsoft.Quantum.Simulation.Common; using Microsoft.Quantum.Simulation.Core; using Microsoft.Quantum.Simulation.Simulators; namespace MyLibrary { class Class1 : QuantumSimulator { static void Method_1 (string str) { ... } . . . } } Util.qs: namespace MyLibrary { operation Op_1 (str : String) : Unit { body intrinsic; } } There is another Q# program in a different namespace that uses the namespace ""MyLibrary"" so after adding reference, in this Q# program I have: namespace QSharp { open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; open MyLibrary; operation TestMyLibrary() : Unit { Op_1(""some string""); } } When I execute ""dotnet run"" in the terminal I receive this message: Unhandled Exception: System.AggregateException: One or more errors occurred. (Cannot create an instance of MyLibrary.Op_1 because it is an abstract class.) ---&gt; System.MemberAccessException: Cannot create an instance of MyLibrary.Op_1 because it is an abstract class. How can I fix it? Thanks. UPDATE: Following Mariia' answer and also checking Quantum.Kata.Utils, I changed my code as following: So, I changed Class1 script to: using System; using Microsoft.Quantum.Simulation.Common; using Microsoft.Quantum.Simulation.Core; using Microsoft.Quantum.Simulation.Simulators; namespace MyLibrary { class Class1 : QuantumSimulator { private string classString = """"; public Class1() { } public class Op_1_Impl : Op_1{ string cl_1; public Op_1_Impl (Class1 c) : base (c) { cl_1 = c.classString; } public override Func&lt;string, QVoid&gt; Body =&gt; (__in) =&gt; { return cl1; }; } } Now the error messages are: error CS0029: Cannot implicitly convert type 'string' to 'Microsoft.Quantum.Simulation.Core.QVoid' error CS1662: Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type Having checked Quantum.Kata.Utils, I realised I need to create a field and a constructor for Class1 which is a base class and also I should override Func&lt;string, QVoid&gt; as the Op_1 parameter is string type. But I am not sure if each of these steps individually is done properly? Second Update: I have changed the previous c# code in first update to the following one: using System; using Microsoft.Quantum.Simulation.Common; using Microsoft.Quantum.Simulation.Core; using Microsoft.Quantum.Simulation.Simulators; namespace MyLibrary { class Class1 : QuantumSimulator { public Class1() { } public class Op_1_Impl : Op_1{ Class1 cl_1; public Op_1_Impl (Class1 c) : base (c) { cl_1 = c; } public override Func&lt;string, QVoid&gt; Body =&gt; (__in) =&gt; { return QVoid.Instance; }; } } Now the error message is the same as the very first one: Unhandled Exception: System.AggregateException: One or more errors occurred. (Cannot create an instance of MyLibrary.Op_1 because it is an abstract class.) ---&gt; System.MemberAccessException: Cannot create an instance of MyLibrary.Op_1 because it is an abstract class. And also in this new code shouldn't the constructor public Class1() { } have a parameter? if so what datatype?",<q#>,11/10/2019 01:01,,,,
59022076.0,How to get the type of a Q# operation parameter?,"Suppose we have the following operation in a Q# program: operation MyOperation (num : Int , qubit : Qubit) : Bool { ... ... ... } If in another C# script in the same namespace we have: Assembly assembly = Assembly.GetExecutingAssembly (); Type[] classes = assembly.GetTypes (); foreach (var item in classes) { Console.WriteLine (""Class : {0}"", item.Name); List&lt;MethodInfo&gt; methods = new List&lt;MethodInfo&gt; (item.GetMethods ()); foreach (var method in methods) { // This array contains the parameters of EACH individual method ParameterInfo[] p = method.GetParameters(); foreach (var param in p) { // parameter manipulation } } } inside foreach (var param in p) { ... } we access each single parameter of a specific method. Now if we run the program, the output will be similar to: Class : MyOperation ... ... (where the dots refer to the information of other classes exists in the assembly but are not important in this question.) As it is seen, each Q# operation is considered as a class (and it makes sense), but my question is how to get the MyOperation parameter(s) as in the outcome of the code they are not retrieved?",<c#><q#>,11/24/2019 20:28,,,,
59122795.0,IBMQProviderError: 'No provider matching the criteria',"Given below is the code I ran on jupyter notebook I have created account on IBM for this project. Please help ! import qiskit as q import numpy as np import matplotlib %matplotlib inline circuit = q.QuantumCircuit(2 , 2) # 2 qubit and 2 classical bits #currently: (0,0) circuit.x(0) #now : (1,0) circuit.cx(0 , 1) #cnot gate , controlled NOT gate , it flips 2nd bit if 1 quibit is 1 # now : (1 , 1) circuit.measure([0,1],[0,1]) # map quibit to bits circuit.draw(output=""mpl"") # ascii of circuit from qiskit import IBMQ IBMQ.save_account('MY_TOKEN_NUMBER',overwrite=True) #save your creds IBMQ.load_account() #got this as output to prev line of code : # &lt;AccountProvider for IBMQ(hub='ibm-q', group='open', project='main')&gt; provider = IBMQ.get_provider(q.providers.baseprovider)",<python><quantum-computing><qiskit>,12/01/2019 05:30,,,,
59136318.0,How can I optimize lattice constants (celldm) in Quantum espresso?,How can I optimize lattice constants (celldm) in Quantum espresso? I want to choose the best celldm for my unit cell of two carbon atoms.,<quantum-computing>,12/02/2019 09:52,,,,
59183610.0,How many different programming paradigms are there-and what are they?,"I am beginner in programming. when I was reading soft computing then many times I encountered the term computing, programming paradigms and soft computing use different programming paradigms like fuzzy logic, artificial neural network, genetic algorithm, etc...",<machine-learning><cluster-computing><distributed-computing><scientific-computing><quantum-computing>,12/04/2019 19:44,,,,
59278737.0,Quantum Programming . . . How?,"So I understand some of the basic ideas with setting up a quantum program . . . libraries, classical logic feeding to a quantum API, all that. I even get that there are quantum operations you apply. Where I am struggling is how do you figure out the correct quantum operations to apply for a given problem? Can someone walk through a basic problem and how to derive the quantum equation to solve it?",<quantum-computing><q#><qiskit>,12/11/2019 04:03,,,,
59472632.0,How to create unitary gate from np.array in qiskit?,"Hi all: Cirq offers a way to create a unitary gate from an array. I tried doing the same in Qiskit but have not been able to quite make it. Here is a sample code with what I could put together so far. Also, is there a way to apply the controlled operation with this unitary from q[0] to q[1] say? Or create a certain labeled gate for that purpose to be used in the circuit? If so, how? Thanks a lot! from qiskit.extensions import * U2x2 = np.array([[0.998762, -0.049745], [-0.049745, -0.998762]]) # Still not sure how to use this, though it compiles gate2x2 = UnitaryGate(U2x2) # The best I could do so far was this: # Create the quantum circuit q = QuantumRegister(2) c = ClassicalRegister(2) qc = QuantumCircuit(q, c) qc.unitary(U2x2, range(1)) qc.measure(q[0], c[0])",<python><quantum-computing><qiskit>,12/24/2019 19:06,,,,
59499254.0,Kernel dies again and again in qiskit,"I am running the following code on Qiskit using IBM Q experience's jupyter notebook here is the code : %matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, execute, Aer, IBMQ,QuantumRegister,ClassicalRegister from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * # Loading your IBM Q account(s) provider = IBMQ.load_account() simulator=Aer.get_backend('qasm_simulator') qi=QuantumRegister(6) qx=QuantumRegister(6) qb=QuantumRegister(3) qo=QuantumRegister(5) qe=QuantumRegister(5) v=QuantumRegister(1) qd=QuantumRegister(3) c=ClassicalRegister(9) circuit=QuantumCircuit(qi,qx,qb,qe,qd,qo,v,c) def fun_or(qc,q0,q1,q2): qc.x(q0) qc.x(q1) qc.ccx(q0,q1,q2) qc.x(q2) qc.x(q1) qc.x(q0) def fun_and (qc,q0, q1, q2): qc.ccx( q0, q1, q2) def fun_nand (qc,q0, q1, q2): fun_and(qc,q0,q1,q2) qc.x(q2) def or3 (qc,q0, q1, q2, b, q3): fun_or(qc,q0, q1, b) fun_or(qc,b,q2,q3) qc.reset(b) def or4 (qc,q0, q1, q2,q3, b1,b2,q4): or3(qc,q0, q1, q2,b1,b2) fun_or(qc,b2,q3,q4) qc.reset(b1) qc.reset(b2) def or5 (qc,q0, q1, q2,q3,q4 ,b1,b2,b3,q5): or4(qc,q0, q1, q2,q3,b1,b2,b3) fun_or(qc,b3,q4,q5) qc.reset(b1) qc.reset(b2) qc.reset(b3) def and3 (qc,q0, q1, q2, b, q3): fun_and(qc,q0,q1,b) fun_and(qc,b, q2, q3) qc.reset(b) def and4 (qc,q0, q1, q2,q3, b1,b2, q4): and3(qc,q0,q1,q2,b1,b2) fun_and(qc,b2, q3, q4) qc.reset(b1) qc.reset(b2) def and5 (qc,q0, q1, q2,q3,q4, b1,b2,b3, q5): and4(qc,q0,q1,q2,q3,b1,b2,b3) fun_and(qc,b3, q4, q5) qc.reset(b1) qc.reset(b2) qc.reset(b3) #give inputs below #give inputs above for i in range (0,6): circuit.cx(qi[i],qx[i]) circuit.x(qx[i]) # Bit one of digit and3(circuit,qx[0],qx[1],qx[2],qb[0],qe[0]) and4(circuit,qx[0],qx[1],qx[3],qx[4],qb[0],qb[1],qe[1]) and4(circuit,qx[0],qx[2],qx[3],qi[5],qb[0],qb[1],qe[2]) and4(circuit,qx[2],qx[1],qx[3],qi[5],qb[0],qb[1],qe[3]) and4(circuit,qx[1],qx[2],qi[5],qx[4],qb[0],qb[1],qe[4]) and4(circuit,qx[0],qx[2],qi[5],qx[3],qb[0],qb[1],qo[0]) and4(circuit,qx[2],qx[1],qx[3],qi[4],qb[0],qb[1],qo[1]) and5(circuit,qx[1],qx[2],qx[5],qx[4],qi[3],qb[0],qb[1],qb[2],qo[2]) and5(circuit,qx[0],qi[2],qi[5],qi[4],qi[3],qb[0],qb[1],qb[2],qo[3]) and5(circuit,qx[0],qi[2],qx[5],qi[4],qx[3],qb[0],qb[1],qb[2],v[0]) fun_and(circuit,v[0],qi[1],qo[4]) circuit.reset(v) or5(circuit,qe[0],qe[1],qe[2],qe[3],qe[4],qb[0],qb[1],qb[2],v[0]) circuit.reset(qe) or5(circuit,qo[0],qo[1],qo[2],qo[3],qo[4],qb[0],qb[1],qb[2],qe[0]) circuit.reset(qo) fun_or(circuit,qe[0],v[0],qd[2]) circuit.measure(qd[2],c[2]) ############## #Second bit and4(circuit,qx[0],qi[1],qx[2],qx[5],qb[0],qb[1],qe[0]) and4(circuit,qx[0],qi[1],qx[4],qx[5],qb[0],qb[1],qe[1]) and5(circuit,qx[0],qx[1],qi[2],qi[5],qx[4],qb[0],qb[1],qb[2],qe[2]) and4(circuit,qx[0],qi[1],qi[3],qx[5],qb[0],qb[1],qe[3]) and5(circuit,qx[0],qi[1],qx[2],qi[3],qi[4],qb[0],qb[1],qb[2],qe[4]) and5(circuit,qx[0],qx[1],qi[2],qx[5],qi[4],qb[0],qb[1],qb[2],qo[0]) fun_and(circuit,qo[0],qx[3],qo[1]) and5(circuit,qx[0],qi[1],qi[2],qi[5],qi[4],qb[0],qb[1],qb[2],qo[2]) fun_and(circuit,qo[2],qx[3],qd[1]) circuit.measure(qd[1],c[1]) circuit.reset(qe) circuit.reset(qo) ######### #Third Bit and3(circuit,qx[0],qx[1],qx[2],qb[0],qe[0]) and3(circuit,qx[0],qx[1],qx[4],qb[0],qe[1]) and3(circuit,qx[0],qx[4],qx[5],qb[0],qe[2]) and4(circuit,qx[1],qx[2],qx[4],qx[5],qb[0],qb[1],qe[3]) and4(circuit,qx[0],qi[2],qi[3],qx[4],qb[0],qb[1],qe[4]) and5(circuit,qx[0],qi[2],qi[3],qi[4],qi[5],qb[0],qb[1],qb[2],qo[0]) or5(circuit,qe[0],qe[1],qe[2],qe[3],qe[4],qb[0],qb[1],qb[2],qo[1]) fun_or(circuit,qo[1],qo[0],qd[0]) circuit.measure(qd[0],c[0]) ##################################### #circuit.measure(qi[0],c[0]) #circuit.measure(qi[1],c[1]) #circuit.measure(qi[2],c[2]) ###################################### job = execute(circuit, simulator, shots=100) print('#') print(job.result()) result=job.result() print('##') counts = result.get_counts(circuit) print('###') circuit.draw() print('111!!') print(""\nTotal count "",counts) I am using IBM's Quantum Experience's Jupyter notebook. Whenever I hit run, the program runs for a few minutes before a dialog box appears saying that the kernel died. I don't what's causing this, maybe that the code is too much for qiskit? Please help!",<python><jupyter-notebook><kernel><quantum-computing><qiskit>,12/27/2019 10:21,,,,
59884561.0,How to plot a state vector in Bloch sphere on Qutip?,"Very simple. I define a Qutip state object import qutip as qt import numpy as np state = qt.Qobj(1/2*np.array([np.sqrt(3),-1])) # This is my quantum state vector (normalized) What I want is plotting this state in Bloch sphere, but if I just do: b = qt.Bloch() b.add_vectors(state) b.show() It gives me an error IndexError: index 1 is out of bounds for axis 0 with size 1 I suppose this is due to the interpretation of my state as a normal 3D vector. So, there exists a simple way to go with this kind of plot?",<python><quantum-computing><qutip>,1/23/2020 17:55,,,,
60081502.0,Microsoft Quantum Development Kit Symmetric key encryption,Is there any open-source Post-Quantum Cryptography (PQC) or Quantum Safe Symmetric cryptography algorithm available for Microsoft Quantum Development Kit,<visual-studio><quantum-computing><q#>,02/05/2020 17:54,,,,
60121676.0,Is there any limit to execute a quantum circuit?,"I am trying to build an optimization for a machine learning quantum circuit, so I need to call several times the same circuit. I am using the execute function to compile it, but the quantum function is only called about four times in the same loop when I run the code. Then the program keeps running but it stops on the execute line doing nothing. Is this a limitation of IBM Quantum Systems? I can't find why this happens if the code calls the quantum circuit four times before it stops. This issue occurs both in the simulator and in the quantum machines, so I suppose it is not a credit problem.",<qiskit>,02/07/2020 22:00,,,,
60143176.0,Understanding Hadamard gate in depth,"I know that a Hadamard gate is implemented by rotating around the axis (x + z )/ sqrt(2), but how can I compute the matrix obtained by rotation around this axis by Ï radians, and compare to a Hadamard gate matrix. Thanks for your help.",<quantum-computing>,02/10/2020 01:57,,,,
60474911.0,Qutip: TypeError: 'Result' object does not support indexing,"I want to fix this code. Everything is fine but when i am trying to run this code it is showing some error as TypeError: 'Result' object does not support indexing, I don't know why this problem is coming. If somebody can resolve this is most welcome. The answer would be appreciated. import math import pylab as pl from qutip import * %matplotlib inline # system parameters n = 3 m = 128 gamma = 1 kappa = 0.5 Y = 0.01 g = 1/np.sqrt(2.0) omega_M = 1 kappa_M = 0.1 ntraj = 1 # initial state psi0 = tensor(fock(2,1), fock(n,0), fock(m,0)) # operators sig_plus = tensor(sigmap(), qeye(n), qeye(m)) a = tensor(qeye(2), destroy(n), qeye(m)) b = tensor(qeye(2), qeye(n), destroy(m)) # collapse operators c_ops= [np.sqrt(2*kappa)*a, np.sqrt(gamma)*sig_plus.dag(), np.sqrt(kappa_M)*b] # expectation values e_ops = [a.dag()*a.dag()*a*a, a.dag()*a*sig_plus*sig_plus.dag(), a.dag()*a, sig_plus*sig_plus.dag()] # lists of steady-state values fieldfield_list = [] atomfield_list = [] tlist = np.linspace(0,20,2000) gM_list = np.linspace(0,3,200) # build the correlation plots for g_M in gM_list: H = omega_M*b.dag()*b + Y*(a + a.dag())+ g*((a*sig_plus) + (a.dag()*sig_plus.dag())) + g_M*a.dag()*a*(b + b.dag()) evalues = mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True) fieldfield_list.append(evalues[0][-1]/(evalues[2][-1]**2)) atomfield_list.append(evalues[1][-1]/(evalues[2][-1]*evalues[3][-1])) # plot the correlation functions pl.plot(gM_list, fieldfield_list, 'r', gM_list, atomfield_list, 'b') pl.xlabel('g_M') pl.ylabel('intensity correlation values') pl.legend(('field-field', 'atom-field')) pl.show() After run the above code i am getting this error. TypeError Traceback (most recent call last) &lt;ipython-input-20-15b5e0ad0f36&gt; in &lt;module&gt;() 33 evalues =mcsolve(H, psi0, times_list, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True) 34 ---&gt; 35 fieldfield_list.append(evalues[0][-1]/(evalues[2][-1]**2)) 36 atomfield_list.append(evalues[1][-1]/(evalues[2][-1]*evalues[3][-1])) 37 # plot the correlation functions TypeError: 'Result' object does not support indexing",<python><python-3.x><qutip>,03/01/2020 12:05,,,,
60497765.0,4th order Runge-Kutta for infinite square well,"The following code works for n = 1 but for higher energy levels the wave function is flipped in the x-axis compared to the expected wave function. Does anyone know why this is? V(x) is set to be 0 for all x and the energies were all correct compared to expected values. All constants have been defined. x = np.arange(-a,a,h) def f(r,x,E): psi = r[0] phi = r[1] fpsi = phi fphi = (2*m/(hbar**2))*(V(x)-E)*psi return np.array([fpsi,fphi],float) def RungeKutta2d(xpoints,E): r = [0,1] psipoints = [] phipoints = [] for x in xpoints: psipoints.append(r[0]) phipoints.append(r[1]) k1 = h*f(r,x,E) k2 = h*f(r+0.5*k1, x+0.5*h,E) k3 = h*f(r+0.5*k2, x+0.5*h,E) k4 = h*f(r+k3, x+h,E) r = r + (k1 + 2*k2 + 2*k3 + k4)/6 psipoints.append(r[0]) phipoints.append(r[1]) return np.array(psipoints) def Secant(E1,E2): psi1 = RungeKutta2d(xpoints,E1)[N] psi2 = RungeKutta2d(xpoints,E2)[N] tolerance = e/1000 while abs(E2-E1) &gt; tolerance: E3 = E2 - psi2*(E2-E1)/(psi2-psi1) E1 = E2 E2 = E3 psi1 = RungeKutta2d(xpoints,E1)[N] psi2 = RungeKutta2d(xpoints,E2)[N] return E3",<python><python-3.x><runge-kutta><quantum-computing>,03/02/2020 22:52,,,,
60523060.0,Reason for the exponential speed-up expected from quantum computers,In quantum computers those 2 effects should be seen: 1) If an operator acts on an arbitrary QuBit Qn of a quantum system S consisting of several QuBits than we get a new quantum system S' where the amplitues of ALL QuBits have changed. 2) If an operator acts on one QuBit of a quantum system T consisting of two entangled QuBits than both QuBits are affected. So which one of these is the reason for the exponential speed-up expected from quantum computers?,<performance><parallel-processing><time-complexity><space-complexity><qubit>,03/04/2020 09:40,,,,
60611844.0,\_tfq_simulate_ops.so not found while import tensorflow_quantum,"Trying import of initial libraries related to tensorflow_quantum: import tensorflow as tf import tensorflow_quantum as tfq import cirq import sympy import numpy as np Getting error in 2nd line: File ""Path_to_anaconda_site_packages\tensorflow_core\python\framework\load_library.py"", line 61, in load_op_library lib_handle = py_tf.TF_LoadLibrary(library_filename) NotFoundError: Path_To_Tensorflow_Quantum\core\ops\_tfq_simulate_ops.so not found",<python><tensorflow><tensorflow-quantum><cirq>,03/10/2020 05:08,,,,
60949333.0,"How to fix this problem with Q# installation: ""Preparing Q# environment... Access to the path 'C:\Users\Sanjiv\Application Data' is denied.""","I installed Q# with Python as per the instructions on Microsoft's site. Then, I tested the installation. It ran fine the first time. But subsequently, when I try to run any program, I get the message: Preparing Q# environment... Access to the path 'C:\Users\Sanjiv\Application Data' is denied. Then it waits for a while and then I get the message: Exception: Q# environment was not available in allocated time. I have tried the following: 1. Changing ownership of C:\Users\Sanjiv and its subdirectories to myself. 2. Running the command window as admin. I don't know what else to try to fix this problem.",<python><quantum-computing><q#>,3/31/2020 11:18,,,,
61102614.0,CVXPY can't maximize function,"I'm trying to maximize the value of a function based on qutip to find the hermitian positive semidefinite matrix of trace equal 1 that maximized this function, but CVXPY always returns the value 0.0 and a diagonal matrix, do I have to do something for the solver to allow complex values on the matrix? My code below: import numpy as np from qutip import * import matplotlib.pyplot as plt import cvxpy as cp def Coherence(density_matrix): rho = Qobj(density_matrix) diag = rho.diag() matrix_diag = np.diag(diag) rho_diag = Qobj(matrix_diag) coherence = entropy_vn(rho_diag, 2) - entropy_vn(rho, 2) return coherence n = 2**7 density_matrix = cp.Variable((n,n), hermitian=True) constraints = [cp.trace(density_matrix) == 1] prob = cp.Problem(cp.Maximize(Coherence(density_matrix.value)),constraints) prob.solve() # Print result. print(""The optimal value is"", prob.value) print(""A solution density matrix is"") print(density_matrix.value) always returns this results: The optimal value is -0.0 A solution density matrix is [[0.0078125+0.j 0. +0.j 0. +0.j ... 0. +0.j 0. +0.j 0. +0.j] [0. +0.j 0.0078125+0.j 0. +0.j ... 0. +0.j 0. +0.j 0. +0.j] [0. +0.j 0. +0.j 0.0078125+0.j ... 0. +0.j 0. +0.j 0. +0.j] ... [0. +0.j 0. +0.j 0. +0.j ... 0.0078125+0.j 0. +0.j 0. +0.j] [0. +0.j 0. +0.j 0. +0.j ... 0. +0.j 0.0078125+0.j 0. +0.j] [0. +0.j 0. +0.j 0. +0.j ... 0. +0.j 0. +0.j 0.0078125+0.j]]",<python-3.x><numpy><cvxpy><convex-optimization><qutip>,04/08/2020 14:04,,,,
61131662.0,Quantum algorithm for summation of superposition,"Im not at all sure how to word this question, but I will try my best. Im wanting to have examples of quantum algorithms that can complete logical parallel tasks. It extends beyond simply summation, for example multiplication, or finding the highest value, or a value closest to a given fixed value. I know quantum algorithms can very easily ""input"" multiple states into a function/circuit and get a superposition of all answers, and even select specific desired outputs with grover's algorithm, but is it possible to incorporate multiple superposition into a final classical answer? Since there is no order to each ""probability"", obviously operations that depend on sequence are not possible. Im trying to get into the mindset of how to make use of a quantum computer, and design circuits for it. Im not interested in theory or equations, just raw circuit/qasm diagrams. Such examples that Im trying to refer to can be written as pseduo code like below struct possibility { float weight; int value; }; int summation(possibility[] input) { int result = 0; for (int i = 0; i &lt; sizeof(input); i++) { result += input[i].value * input[i].weight; } return result; } int multiplication(possibility[] input) { int result = 1; for (int i = 0; i &lt; sizeof(input); i++) { result *= input[i].value * input[i].weight; } return result; } int findClosest(possibility[] input, int toValue) { int result = input[0].value; int resultDistance = abs(toValue - result) * input[0].weight; for (int i = 1; i &lt; sizeof(input); i++) { int distance = abs(toValue - input[i].value) * input[i].weight; if (distance &lt; resultDistance) { result = input[i].value; resultDistance = distance; } } return result; } Sorry for my poor wording. Im not at all sure how to word this question better with my tiny knowledge in this subject. Any help at all is appreciated!",<algorithm><quantum-computing>,04/09/2020 23:09,,,,
61145226.0,Why is shor's algorithm only effective in quantum computer?,I'm trying to learn about quantum computing and came across Shor's algorithm to find prime factors of a number. I understand the math behind shor's algorithm but can't understand why it can't be implemented in a classical computer as it just seems like a mathematical formula.,<encryption><quantum-computing>,04/10/2020 17:12,,,,
61173457.0,How to do the square root of X operation in Qiskit,"I'm trying to do the Bell Inequality Test in Qiskit but to do that you need preform the controlled negative square root of X operation. An example of this in Cirq is cirq.CNOT(bob_ref, bob)**-0.5 I tried to do something similar in Qiskit and it gave me an error cir.cx(bob_ref, bob)**-0.5",<algorithm><quantum-computing><qiskit><cirq>,04/12/2020 15:00,,,,
61184725.0,"Python/Q#: Module not found error, with .qs file in the same directory","Lately I started working with Q# and python as host language. I was working on a project and everything seemed fine. Suddenly I get the error ""module not found"" and I seem to get it in all my previous projects too. So I have a directory: C:\Users\Username\Q#projects In this folder I have 2 files: HostProtocol.py, which is the main file, and BB84.qs, which is the file from which I want to import. The HostProtocol.py file looks like this: import qsharp from Quantum.BB84 import Run_BB84Protocol Run_BB84Protocol.simulate() The BB84.qs file looks like this: namespace Quantum.BB84 { open Microsoft.Quantum.Arrays; open Microsoft.Quantum.Measurement; open Microsoft.Quantum.Canon; open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Diagnostics; open Microsoft.Quantum.Convert; open Microsoft.Quantum.Math; function Run_BB84Protocol() Unit{... the code from the function...} } When I try to run HostProtocol.py I get the following error message: Exception has occurred: ModuleNotFoundError No module named 'Quantum' File ""C:\Users\Username\Q#projects\HostProtocol.py"", line 3, in from Quantum.BB84 import Run_BB84Protocol And this is for all my previous projects too. It's very frustrating and I have no clue what could have caused it because it worked fine previously. Any help is definitely welcome!",<python><module><compiler-errors><q#>,4/13/2020 9:15,,,,
61602722.0,"while creating a quantum circuit I came across this dilemma, which circuit is better for binary operator",what are the advantages and disadvantages between 8 qbit register and 8 single qbit register? suppose someone created quantum register with 8 qbit and another person created 8 registers with single qbit init. what is the difference between these two?,<qiskit>,05/04/2020 22:32,,,,
61603069.0,Returning chance of qubit state as a decimal,"I'm trying to run X gates on 2 qubits and then return the chance of the qubit in either state as a decimal. I've searched for answers but I haven't gotten anywhere. ##THE CODE## import math import numpy as np from qiskit import * from qiskit.providers.aer.extensions.snapshot_probabilities import * #call for qubits q = QuantumRegister(2) c = ClassicalRegister(2) #creates qubits and classical bits qc = QuantumCircuit(q, c) #applys a half not ad for i in range(2): qc.u3(0.5 * math.pi,0,0, q[i]) # Map the quantum measurement to the classical bits for i in range(2): qc.measure(q[i], c[i]) # Execute the circuit on the qasm simulator simulator = Aer.get_backend('qasm_simulator') job = execute(qc, simulator, shots=1000) result = job.result() counts = result.get_counts(qc) ## END OF CODE##",<python><qiskit>,05/04/2020 23:03,,,,
61640317.0,How can I find the partial transpose for three qubit density matrix usign mathematica?,"I know that the density matrix of a three-qubit is an 8x8 matrix. How can I use Mathematica to find the partial transpose of this 8x8 matrix with respect to the first, second, or the third qubit?",<wolfram-mathematica><quantum-computing><qubit>,05/06/2020 16:30,,,,
61851081.0,How to embed classical iterations into the oracle of Grover's algorithm in Qiskit?,"I am newly using Qiskit to learn quantum computing. Now I want to know if there is any way to make this: For instance, I obtain an array X, where each element is sum of something else, say X[0] = y[0][0]+y[0][1]+...+y[0][m], X[1] = y[1][0]+y[1][1]+..., ..., till X[n], each element in X is obtained in one iteration. The task is to find a certain X[i] == k. Then should I finish all the iterations before Grover's iterates? I have read some textbooks and papers where oracles are constructed by some binary function marking target states as 1 with conditions. What I can do now in Qiskit as I know, is to mark the index indicating the position of target element like from qiskit.circuit.library import Diagonal from qiskit.quantum_info import Statevector mark_state = Statevector.from_label('100') mark_circuit = Diagonal((-1)**mark_state.data) # circuit that induces a -1 phase on the mark_state That's in Qiskit Terra. Another way in Qiskit Aqua is to call APIs of Oracles and Grover, but Oracles only accept logical expression, truth table and custom circuit: construction of any one needs to know the exact X and location of the X[i] as I understand. All I want to do is to illustrate the quadric advantage taken by Grover's algorithm. If it's possible, the iterations shouldn't be traversed, at least outside the oracle, but then how to implement it in code?",<quantum-computing><qiskit>,5/17/2020 11:33,,,,
62001137.0,IBMQProvider issue,"I successfully installed and ran a couple of circuits on a backend the other day (essex). Everything was ok, results came up, but the next day, once I wanted more QC, I could not manage to get a provider. I have looked into my account (active), looked into the package (up-to-date), and a new file in the project. I also already disabled and enabled the account without problems, but I keep having this error. Code from qiskit import IBMQ IBMQ.active_account() IBMQ.providers() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') and I get: &gt;~/my_environment_name/lib/python3.7/site-packages/qiskit/providers/ibmq/ibmqfactory.py in get_provider(self, hub, group, project) 425 raise IBMQProviderError('No provider matches the specified criteria: ' 426 'hub = {}, group = {}, project = {}' --&gt; 427 .format(hub, group, project)) 428 if len(providers) &gt; 1: 429 raise IBMQProviderError('More than one provider matches the specified criteria.' IBMQProviderError: 'No provider matches the specified criteria: hub = ibm-q, group = open, project = main' I would like to know where I am wrong, I look forward to keep learning thru the backends efficiently. Thank you in advance",<quantum-computing><qiskit>,5/25/2020 11:05,,,,
62077194.0,"CanÂ´t import qiskit, attribute error in numpy: "" 'numpy.random' has no attribute 'default_rng'""","IÂ´m using Python 3 and IÂ´m working in jupyter, when I try to import qiskit the following error is showed: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-2-578b7f7e9727&gt; in &lt;module&gt; ----&gt; 1 import qiskit ~\AppData\Roaming\Python\Python36\site-packages\qiskit\quantum_info\synthesis\two_qubit_decompose.py in __init__(self, unitary_matrix) 169 # D, P = la.eig(M2) # this can fail for certain kinds of degeneracy 170 for i in range(100): # FIXME: this randomized algorithm is horrendous --&gt; 171 state = np.random.default_rng(i) 172 M2real = state.normal()*M2.real + state.normal()*M2.imag 173 _, P = la.eigh(M2real) AttributeError: module 'numpy.random' has no attribute 'default_rng'",<python><numpy><import><attributes><qiskit>,5/29/2020 1:27,,,,
62077725.0,Ways to speedup solution time for a large LP (>10 million decision variables),"I have a large LP with more than 10 million decision variables and nearly the same number of constraints. I use CPLEX to solve the LP but it takes ~20 hours to solve, and that's on the best server of our institution. Are there ways to significantly speedup the solution time (without adding more servers)? I've read about Quantum Computing and its application in optimization problems speedup. Does anybody have a similar experience in that, or more generally any other ways of reducing the solution time?",<performance><large-data><cplex><quantum-computing>,5/29/2020 2:30,,,,
62083158.0,Changing the signature of EntryPoint opeartion in auto-generated drivers,"It appears that Q# now auto-generates C# drivers from annotations in new versions. When creating a plain command-line project from a VS Code template, we are presented with the following operation: @EntryPoint() operation HelloQ() : Unit { Message(""Hello quantum world!""); } However, for many quantum experiments we would want to return a Result. For example: @EntryPoint() operation HelloQ() : Result { mutable state = zero; using (qubit = Qubit()) { H(qubit); set state = M(qubit); Reset(qunit); } return state; } This does not build, and yields a somewhat enigmatic error code 253. Do I have to update the driver manually? If this is the case I cannot understand why the driver would be maintained as a build artifact. Is the driver schema driven by one of the many json/bson files?",<q#>,5/29/2020 9:50,,,,
62166511.0,Problem executing Qiskit with Dask. Worker does not start,"I am trying to execute Qiskit using Dask. When I submit a function that execute a quantum circuit simulation using Qiskit, it does not work properly and additionally, workers start to produce errors with callbacks. So i decide to start preloading Qiskit on workers, but it does not work. Workers stop gracefully without any error. However, importing another python package as numpy, they work as expected. Any idea why workers cannot load Qiskit? This is a trace of the problem: [user@c6601 ~]$ conda --version conda 4.7.12 [user@c6601 ~]$ conda activate qiskit (qiskit) [user@c6601 ~]$ (qiskit) [user@c6601 ~]$ python --version Python 3.7.7 (qiskit) [user@c6601 ~]$ python -c ""import qiskit; print(qiskit.__qiskit_version__)"" {'qiskit-terra': '0.14.1', 'qiskit-aer': '0.5.1', 'qiskit-ignis': '0.3.0', 'qiskit-ibmq-provider': '0.7.1', 'qiskit-aqua': None, 'qiskit': '0.19.2'} (qiskit) [user@c6601 ~]$ dask-worker --version dask-worker, version 2.17.0 (qiskit) [user@c6601 ~]$ dask-scheduler --scheduler-file /tmp/sched.json&amp; [1] 16228 (qiskit) [user@c6601 ~]$ distributed.scheduler - INFO - ----------------------------------------------- distributed.http.proxy - INFO - To route to workers diagnostics web server please install jupyter-server-proxy: python -m pip install jupyter-server-proxy distributed.scheduler - INFO - ----------------------------------------------- distributed.scheduler - INFO - Clear task state distributed.scheduler - INFO - Scheduler at: tcp://10.120.66.1:8786 distributed.scheduler - INFO - dashboard at: :8787 (qiskit) [user@c6601 ~]$ dask-worker --scheduler-file /tmp/sched.json --preload ""import qiskit;print(qiskit.__qiskit_version__)"" distributed.utils - INFO - Reload module tmp2c9jac8m from .py file {'qiskit-terra': '0.14.1', 'qiskit-aer': '0.5.1', 'qiskit-ignis': '0.3.0', 'qiskit-ibmq-provider': '0.7.1', 'qiskit-aqua': '0.7.1', 'qiskit': '0.19.2'} {'qiskit-terra': '0.14.1', 'qiskit-aer': '0.5.1', 'qiskit-ignis': '0.3.0', 'qiskit-ibmq-provider': '0.7.1', 'qiskit-aqua': '0.7.1', 'qiskit': '0.19.2'} distributed.preloading - INFO - Import preload module: /scratch/4070613/tmp2c9jac8m.py distributed.dask_worker - INFO - End worker But numpy loads without problems. (qiskit) [user@c6601 ~]$ dask-worker --scheduler-file /tmp/sched.json --preload ""import numpy;print(numpy.__version__)"" distributed.utils - INFO - Reload module tmpm2y2lp42 from .py file 1.18.1 1.18.1 distributed.preloading - INFO - Import preload module: /scratch/4070613/tmpm2y2lp42.py distributed.nanny - INFO - Start Nanny at: 'tcp://10.120.66.1:46577' distributed.utils - INFO - Reload module tmpzhdz9u4h from .py file 1.18.1 1.18.1 distributed.preloading - INFO - Import preload module: /scratch/4070613/tmpzhdz9u4h.py distributed.worker - INFO - Start worker at: tcp://10.120.66.1:34459 distributed.worker - INFO - Listening to: tcp://10.120.66.1:34459 distributed.worker - INFO - dashboard at: 10.120.66.1:45970 distributed.worker - INFO - Waiting to connect to: tcp://10.120.66.1:8786 distributed.worker - INFO - ------------------------------------------------- distributed.worker - INFO - Threads: 4 distributed.worker - INFO - Memory: 21.47 GB distributed.worker - INFO - Local Directory: /mnt/netapp2/Home_FT2/home/cesga/user/dask-worker-space/worker-dleqkfmk distributed.worker - INFO - ------------------------------------------------- distributed.scheduler - INFO - Register worker &lt;Worker 'tcp://10.120.66.1:34459', name: tcp://10.120.66.1:34459, memory: 0, processing: 0&gt; distributed.scheduler - INFO - Starting worker compute stream, tcp://10.120.66.1:34459 distributed.core - INFO - Starting established connection distributed.worker - INFO - Registered to: tcp://10.120.66.1:8786 distributed.worker - INFO - ------------------------------------------------- distributed.core - INFO - Starting established connection",<dask><qiskit>,06/03/2020 06:24,,,,
62217794.0,Difference between density matrix and completeness relation,The expression for completeness relation in quantum mechanics is - Î£ |Ï_n&gt;&lt;Ï_n| = 1 where the expression for density matrix in statistical mechanics is - Ï = Î£ p_n |Ï_n&gt;&lt;Ï_n| Both of the equation looks the same. So what are the differences between the density matrix and completeness relation? What is the basic difference between them?,<quantum-computing>,06/05/2020 14:33,,,,
62430185.0,How to use CRT batch technique in Microsoft SEAL 3.1?,"Can you please tell me whether SEAL 3.1 supports PolyCRTBuilder class? I am trying to run the following program but failed because the class is not declared in this scope. /** Suppose I have two arrays x = [1,2,3,4,5] and xMean = [3,3,3,3,3]. I composed and encrypted the two array using PolyCRTBuilder ( xCiphertext and xMeanCiphertext ) . If I subtract the two ciphertexts ( xCiphertext MINUS xMeanCiphertext ), I should get xResult = [-2, -1, 0, 1, 2] but after the homomorphic subtraction I am getting xResultDecrypted = [40959, 40960, 0 ,1, 2] . I can relate the overflow result to the plain modulus set but is there a work around for this problem. Here is the code: */ #include &lt;iostream&gt; #include ""seal/seal.h"" using namespace std; using namespace seal; /* Helper function: Prints the parameters in a SEALContext. */ void print_parameters(shared_ptr&lt;SEALContext&gt; context) { // Verify parameters if (!context) { throw invalid_argument(""context is not set""); } auto &amp;context_data = *context-&gt;context_data(); /* Which scheme are we using? */ string scheme_name; switch (context_data.parms().scheme()) { case scheme_type::BFV:scheme_name = ""BFV""; break; case scheme_type::CKKS:scheme_name = ""CKKS""; break; default: throw invalid_argument(""unsupported scheme""); } cout &lt;&lt; ""/ Encryption parameters:"" &lt;&lt; endl; cout &lt;&lt; ""| scheme: "" &lt;&lt; scheme_name &lt;&lt; endl; cout &lt;&lt; ""| poly_modulus_degree: "" &lt;&lt; context_data.parms().poly_modulus_degree() &lt;&lt; endl; /* Print the size of the true (product) coefficient modulus. */ cout &lt;&lt; ""| coeff_modulus size: "" &lt;&lt; context_data. total_coeff_modulus_bit_count() &lt;&lt; "" bits"" &lt;&lt; endl; /* For the BFV scheme print the plain_modulus parameter. */ if (context_data.parms().scheme() == scheme_type::BFV) { cout &lt;&lt; ""| plain_modulus: "" &lt;&lt; context_data. parms().plain_modulus().value() &lt;&lt; endl; } cout &lt;&lt; ""\\ noise_standard_deviation: "" &lt;&lt; context_data. parms().noise_standard_deviation() &lt;&lt; endl; cout &lt;&lt; endl; } int main(){ cout &lt;&lt; ""\nTotal memory allocated from the current memory pool: ""&lt;&lt; (MemoryManager::GetPool().alloc_byte_count() &gt;&gt; 20) &lt;&lt; "" MB"" &lt;&lt; endl; EncryptionParameters parms(scheme_type::BFV); //EncryptionParameters parms; parms.set_poly_modulus_degree(4096); parms.set_coeff_modulus(coeff_modulus_128(4096)); parms.set_plain_modulus(40961); ////Make the coefficient modulus prime&gt;2n to enable CRT batching auto context = SEALContext::Create(parms); print_parameters(context); IntegerEncoder encoder(parms.plain_modulus()); KeyGenerator keygen(context); PublicKey public_key = keygen.public_key(); SecretKey secret_key = keygen.secret_key(); // SEALContext context(parms); // KeyGenerator keygen(context); // auto public_key = keygen.public_key(); // auto secret_key = keygen.secret_key(); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); PolyCRTBuilder crtbuilder(context); int slot_count = crtbuilder.slot_count(); int row_size = slot_count / 2; vector&lt;uint64_t&gt; x_pod_matrix(slot_count, 0); x_pod_matrix[0] = 1; x_pod_matrix[1] = 2; x_pod_matrix[2] = 3; x_pod_matrix[3] = 4; x_pod_matrix[4] = 5; Plaintext x_plain_matrix; crtbuilder.compose(x_pod_matrix, x_plain_matrix); Ciphertext x_encrypted_matrix; encryptor.encrypt(x_plain_matrix, x_encrypted_matrix); vector&lt;uint64_t&gt; x_mean_pod_matrix(slot_count, 0); x_mean_pod_matrix[0] = 3; x_mean_pod_matrix[1] = 3; x_mean_pod_matrix[2] = 3; x_mean_pod_matrix[3] = 3; x_mean_pod_matrix[4] = 3; Plaintext x_mean_plain_matrix; crtbuilder.compose(x_mean_pod_matrix, x_mean_plain_matrix); Ciphertext x_mean_encrypted_matrix; encryptor.encrypt(x_mean_plain_matrix, x_mean_encrypted_matrix); evaluator.sub_plain(x_encrypted_matrix, x_mean_encrypted_matrix); // Decrypt x_encrypted_matrix Plaintext x_plain_result; decryptor.decrypt(x_encrypted_matrix, x_plain_result); vector&lt;uint64_t&gt; pod_result; crtbuilder.decompose(x_plain_result, pod_result); for(int i = 0; i &lt; 5; i++) { std::cout &lt;&lt; pod_result[i] &lt;&lt; '\n'; } return 0; }",<c++><encryption><seal><post-quantum-cryptography>,6/17/2020 13:27,,,,
62460488.0,Failed to install Qiskit through Anaconda,"Windows 10 Anaconda Python 3.7 pip 20.1.1 I trid to install qiskit on Anaconda Prompt: pip install qiskit and it reports error while builidng wheels for cvxpy, scs, ecos: Building Wheels for collected packages: cvxgy, scs Building wheel for cvxpy(PEP 517) ... error ... Building wheel for scs (setup.py) ... error ... Building wheel for ecos (setup.py)... error ... ERROR: Could not build wheels for cvxpy which use PEP 517 and cannot be installed directly I tried to update pip and install PEP 517 after and tried again, but the error still remained.",<pip><anaconda><anaconda3><qiskit><pep517>,6/18/2020 22:38,,,,
62732494.0,"How to solve ""jupyter_client.kernelspec.NoSuchKernel: No such kernel named iqsharp"" in python?","I was trying to print hello world in Microsoft's Q#. When I ran the code It's shows like this. Even I installed the package. I don't know where the problem is. I think it's in jupyter notebook's permission or something. Thanks for your help. Here is my simple code import qsharp from HelloWorld import SayHello SayHello.simulate() Here is my output File &quot;d:\Program Files\Quantum Projects\hello_quantum.py&quot;, line 1, in &lt;module&gt; import qsharp File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\qsharp\__init__.py&quot;, line 119, in &lt;module&gt; client = _start_client() File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\qsharp\clients\__init__.py&quot;, line 28, in _start_client client.start() File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\qsharp\clients\iqsharp.py&quot;, line 75, in start self.kernel_manager.start_kernel(extra_arguments=[&quot;--user-agent&quot;, f&quot;qsharp.py{user_agent_extra}&quot;]) File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\jupyter_client\manager.py&quot;, line 246, in start_kernel kernel_cmd = self.format_kernel_cmd(extra_arguments=extra_arguments) File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\jupyter_client\manager.py&quot;, line 170, in format_kernel_cmd cmd = self.kernel_spec.argv + extra_arguments File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\jupyter_client\manager.py&quot;, line 82, in kernel_spec self._kernel_spec = self.kernel_spec_manager.get_kernel_spec(self.kernel_name) File &quot;C:\Users\ELCOT\AppData\Local\Programs\Python\Python36\lib\site-packages\jupyter_client\kernelspec.py&quot;, line 236, in get_kernel_spec raise NoSuchKernel(kernel_name) jupyter_client.kernelspec.NoSuchKernel: No such kernel named iqsharp",<python-3.x><quantum-computing><q#>,07/04/2020 17:47,,,,
62833406.0,Find closest matching array element and group them,"I would like to use qunatum computing for the below problem statement There are list of arrays upto n a1= [a,b,c,d,e] a2= [a,b,d,e] a3= [a,e] a4=[a,e] a5=[a,b,c,d,e] The output should give the maximum common grouping items like, for a1 and a5 both are an exact match a1 and a2 are matching except c and a3 a4 are exact match so there can be one group which will give an output of exact match and close match which would be a1 a2 and a5 (they are having only 1 element in difference) another group would be a3 and a4 How can we solve this in dynamic or qunatum computing",<c#><grouping><quantum-computing>,07/10/2020 11:32,,,,
63190295.0,Importing function from IQsharp notebook to Python notebook,I'm working with two notebooks: one for Q# operations and one for python3 to activate and analyze - both of them are on the same directory. How can I import a Q# operation (from the IQsharp notebook) into the python one? what is the namespace of IQsharp?,<python><quantum-computing><q#>,7/31/2020 10:37,,,,
63211932.0,How does one code a number x into a quantum state?,"We have 4 numbers x = [x1, x2, x3, x4] We want to prepare quantum state Psi somehow to encode x We want to make QFT on Psi to get Phi = QFT (Psi)",<quantum-computing>,08/02/2020 02:55,,,,
63272123.0,Qiskit quantum fourier transform,"We have 4 numbers x = [x1, x2, x3, x4] We want to prepare quantum state Psi somehow to encode x We want to make QFT on Psi to get Phi = QFT (Psi) I have no idea how to approach this on qiskit",<quantum-computing><qiskit>,08/05/2020 19:17,,,,
63328141.0,From DFT to QFT python/qiskit,"I have the following code x = [1, -4, 5, -2] # Data points N = len(x) # Number of samples n = np.arange(N) # Current sample k = n.reshape((N, 1)) # Current frequency e = np.exp(-2j * np.pi * k * n / N) # Exponential part DFT = np.dot(e, x) How can I make this Classical Fourier Transform into the Quantum version, either via python or qiskit?",<python><quantum-computing><qiskit>,08/09/2020 15:28,,,,
63342432.0,Python quantum Fourier transform,"This is the inverse quantum Fourier transform. What changes do I have to do to obtain the quantum Fourier transform (not the inverse)? Is this in the right path at all? How would I encode values x1,x2,x3,x4 into the basis state? from math import pi,pow from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, BasicAer, execute def IQFT(circuit, qin, n): for i in range (int(n/2)): circuit.swap(qin[i], qin[n -1 -i]) for i in range (n): circuit.h(qin[i]) for j in range (i +1, n, 1): circuit.cu1(-pi/ pow(2, j-i), qin[j], qin[i]) n = 3 qin = QuantumRegister(n) cr = ClassicalRegister(n) circuit = QuantumCircuit(qin, cr, name=&quot;Inverse_Quantum_Fourier_Transform&quot;) circuit.h(qin) circuit.z(qin[2]) circuit.s(qin[1]) circuit.z(qin[0]) circuit.t(qin[0]) IQFT(circuit, qin, n) circuit.measure (qin, cr) backend = BasicAer.get_backend(&quot;qasm_simulator&quot;) result = execute(circuit, backend, shots = 500).result() counts = result.get_counts(circuit) print(counts)",<python><fft><quantum-computing><qiskit>,08/10/2020 14:41,,,,
63370210.0,Qiskit Portfolio Optimization Application,"I recently got flung into the world of quantum computing and I'm a beginner at coding. I was assigned to do the Portfolio Optimization tutorial of the Qiskit Finance Tutorials and input real data. Truth be told, I'm clueless. It's my understanding that I have to replace the &quot;TICKER&quot; and &quot;RandomDataProvider&quot; parts of the code in order to generate a real-life portfolio. # Generate expected return and covariance matrix from (random) time-series stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)] data = RandomDataProvider(tickers=stocks, start=datetime.datetime(2016,1,1), end=datetime.datetime(2016,1,30)) data.run() mu = data.get_period_return_mean_vector() sigma = data.get_period_return_covariance_matrix() I've imported Quandl and WikipediaDataProvider. I want to keep the number of assets the same, using Microsoft &quot;MSFT&quot;, Disney &quot;DIS&quot;, Nike &quot;NKE&quot;, and Home Depot &quot;HD&quot; stocks. How might I apply this financial from Quandl to the tutorial? I've tried this so far: num_assets = 4 # Generate expected return and covariance matrix from (random) time-series stocks = [(&quot;MSFT%s&quot; , &quot;DIS%s&quot; , &quot;NKE%s&quot; , &quot;HD%s&quot; % i) for i in range(num_assets)] data = WikipediaDataProvider(tickers=stocks, token=&quot;xeesvko2fu6Bt9jg-B1T&quot;, start=datetime.datetime(2016,1,1), end=datetime.datetime(2016,1,30)) data.run() mu = data.get_period_return_mean_vector() sigma = data.get_period_return_covariance_matrix() But get the error: --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-59-19e4d9cde1e3&gt; in &lt;module&gt; 3 # Generate expected return and covariance matrix from (random) time-series 4 stocks = [(&quot;MSFT%s&quot; , &quot;DIS%s&quot; , &quot;NKE%s&quot; , &quot;HD%s&quot; % i) for i in range(num_assets)] ----&gt; 5 data = WikipediaDataProvider(tickers=stocks, 6 token=&quot;xeesvko2fu6Bt9jg-B1T&quot;, 7 start=datetime.datetime(2016,1,1), TypeError: Can't instantiate abstract class WikipediaDataProvider with abstract methods run I apologize for my limited coding skills - I'm very new to all of this! Thank you in advance.",<python><optimization><quandl><quantum-computing><qiskit>,08/12/2020 05:14,,,,
63478941.0,The Tutorials in Qiskit: Option Pricing with qGANs,"# Set upper and lower data values bounds = np.array([0.,7.]) # Set number of qubits used in the uncertainty model num_qubits = [3] # Set entangler map entangler_map = [] for i in range(sum(num_qubits)): entangler_map.append([i, int(np.mod(i+1, sum(num_qubits)))]) # Load the trained circuit parameters g_params = [0.29399714, 0.38853322, 0.9557694, 0.07245791, 6.02626428, 0.13537225] # Set an initial state for the generator circuit init_dist = NormalDistribution(sum(num_qubits), mu=1., sigma=1., low=bounds[0], high=bounds[1]) init_distribution = np.sqrt(init_dist.probabilities) init_distribution = Custom(num_qubits=sum(num_qubits), state_vector=init_distribution) I want to know how to obtain the trained circuit parameters, which Attribute or Method should be used?",<python><pytorch><qiskit>,8/19/2020 1:56,,,,
63581553.0,"Problem installing qutip on Mac Catalina 10.15.6: ""could not build wheels for qutip which use PEP 517""","I am trying to install qutip on a Mac (Catalina 10.15.6). I am using: Python 3.8.3 Anaconda 4.8.4 I create a virtual environment with the command conda create -n qutip python=3.8 anaconda. Here's the error message: g++ -bundle -undefined dynamic_lookup - L/usr/local/anaconda3/envs/qutip/lib -arch x86_64 -L/usr/local/anaconda3/envs/qutip/lib -arch x86_64 /usr/local/opt/readline/include -arch x86_64 build/temp.macosx-10.9-x86_64-3.7/qutip/cy/spmatfuncs.o build/temp.macosx-10.9-x86_64-3.7/qutip/cy/src/zspmv.o -o build/lib.macosx-10.9-x86_64-3.7/qutip/cy/spmatfuncs.cpython-37m-darwin.so -mmacosx-version-min=10.9 ld: can't map file, errno=22 file '/usr/local/opt/readline/include' for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) error: command 'g++' failed with exit status 1 ---------------------------------------- ERROR: Failed building wheel for qutip Failed to build qutip ERROR: Could not build wheels for qutip which use PEP 517 and cannot be installed directly I looked around and I don't see anything recent for this. I tried to install qutip from source and I got the same error. Does anyone have any thoughts? Thank you.",<python><macos><qutip>,8/25/2020 14:52,,,,
63673224.0,Why can't we add 'rx'(Rotation around X-axis) and 'ry' gates to the noise model basis gates in Qiskit?,"I can easily add any Unitary gate which I create using Qiskit but it gives a warning when I try to add these rotation gates to the noise model basis gates. It might be a problem with the labelling(I used 'rx' and 'ry') or some other issues which I am not able to figure out. The problem is the noise won't affect these gates unless I add them to the basis gates. noise_model = NoiseModel() error_1 = depolarizing_error(prob_1, 1) error_2 = depolarizing_error(prob_2, 2) noise_model.add_all_qubit_quantum_error(phase_damping_error(0.1), ['Z1','Z2','rx','ry','h']) noise_model.add_all_qubit_quantum_error(phase_damping_error(0.1),['CZÏA','CZÏB']) noise_model.add_basis_gates(['unitary','rx','ry']) basis_gates = noise_model.basis_gates circs = transpile([qc1, qc2, qc3], basis_gates=basis_gates) result_error = execute(circs, QasmSimulator(), shots=10, noise_model=noise_model, basis_gates=basis_gates).result() print(noise_model) Warning: Adding a gate &quot;rx&quot; to basis_gates which is not in QasmSimulator basis_gates. Warning: Adding a gate &quot;ry&quot; to basis_gates which is not in QasmSimulator basis_gates. NoiseModel: Basis gates: ['cx', 'h', 'id', 'u3', 'unitary'] Instructions with noise: ['CZÏB', 'Z2', 'CZÏA', 'rx', 'h', 'ry', 'Z1'] All-qubits errors: ['Z1', 'Z2', 'rx', 'ry', 'h', 'CZÏA', 'CZÏB']",<physics><quantum-computing><qiskit>,8/31/2020 14:58,,,,
63812476.0,About the input of quantum neural network in tensorflow quantum,"I created a quantum neural network using tensorflow quantumï¼It's input is a tensor converted by circuit.About this input circuitï¼I found that if the parameters of the circuit are also specified by tensors, the quantum neural network cannot be trained. The circuit when using normal parameters can make the network train normally theta_g=1 blob_size = abs(1 - 4) / 5 spread_x = np.random.uniform(-blob_size, blob_size) spread_y = np.random.uniform(-blob_size, blob_size) angle = theta_g + spread_y cir=cirq.Circuit(cirq.ry(-angle)(qubit), cirq.rx(-spread_x)(qubit)) discriminator_network(tfq.convert_to_tensor([cir])) But when I use the following code, the quantum neural network cannot be trained theta_g=tf.constant([1]) blob_size = abs(1 - 4) / 5 spread_x = np.random.uniform(-blob_size, blob_size) spread_y = np.random.uniform(-blob_size, blob_size) spred_x = tf.constant(spread_x) spred_y = tf.constant(spread_y) angle = theta_g + spread_y cir=cirq.Circuit(cirq.ry(-angle)(qubit), cirq.rx(-spread_x)(qubit)) discriminator_network(tfq.convert_to_tensor([cir])) ** the disciminator_network** def discriminator(): theta = sympy.Symbol('theta') q_model = cirq.Circuit(cirq.ry(theta)(qubit)) q_data_input = tf.keras.Input( shape=(), dtype=tf.dtypes.string) expectation = tfq.layers.PQC(q_model, cirq.Z(qubit)) expectation_output = expectation(q_data_input) classifier = tf.keras.layers.Dense(1, activation=tf.keras.activations.sigmoid) classifier_output = classifier(expectation_output) model = tf.keras.Model(inputs=q_data_input, outputs=classifier_output) return model",<tensorflow2.0><tensorflow-quantum>,09/09/2020 13:12,,,,
63890795.0,How to return measurement probabilities from the QDK Full-state simulator?,"Is there a way for the QDK full-state simulator to return the wavefunction or the measurement probabilities of a quantum state? Specifically to a C# host application? I want to sample from the output distribution of a quantum algorithm in C#. Currently I am re-invoking the simulator and performing the destructive measurement for each sample, however this process is quite slow.",<q#>,9/14/2020 19:33,,,,
63905743.0,using third part modules in IBM quantum experience (Tensorflow),"Is there any option to use Tensorflow in IBM quantum experience? I have searched on google but I couldn't find anything. I thought about copying the source code, any suggestion?",<python><quantum-computing><qiskit>,9/15/2020 16:02,,,,
64306429.0,How to get the Qiskit textbook widgets working?,"For example, when trying to run from qiskit_textbook.widgets import gate_demo gate_demo(gates='pauli') in Jupyter notebook or a script, the output I get is HBox(children=(Button(description='X', layout=Layout(height='3em'), style=ButtonStyle()), Button(... Image(value=b'\x89PNG\r\n\xla\n\x00\x00\x00\rIHDR\x00\x00\x02...",<qiskit>,10/11/2020 16:29,,,,
64341674.0,I can't install Quantum Espresso in MacOS High Sierra,I have problems while executing ./configure. I am quite new with these things and I don't really know where the problem is. In configure.log file I get the following errors (I couldn't upload it because it was too heavy): gfortran: error: unrecognized command-line option '-V' gfortran: fatal error: no input files collect2: error: ld returned 1 exit status configure: failed program was: | program main | call dgemm | end Does anyone know which is the real problem? Thank you in advance,<installation><configure><quantum-computing>,10/13/2020 19:08,,,,
64364352.0,My Q# language server won't stop downloading on VS Code,"I'm trying to create a Q# New Project in VS Code, but VS Code won't let me do that until I have my Q# language server downloaded. I'm using a mac. And the Q# language server just kept downloading for hours. How do I solve this problem?",<q#>,10/15/2020 3:17,,,,
64707625.0,Visualizing circuits in qiskit with matplotlib,"I'm learning how to use qiskit and I'm using the jupyter notebook, but everytime I try to visualize the circuit with the attribute draw I get this error: import qiskit from qiskit import * from qiskit import IBMQ qr = QuantumRegister(2) cr = ClassicalRegister(2) circuit = QuantumCircuit(qr, cr) %matplotlib inline circuit.draw(output='mpl') --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-8-bd220039ee1c&gt; in &lt;module&gt; ----&gt; 1 circuit.draw(output='mpl') AttributeError: module 'qiskit.circuit' has no attribute 'draw' I also try applying a Hadamard gate and I get: circuit.h(qr(0)) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-59-c8b4318b743b&gt; in &lt;module&gt; ----&gt; 1 circuit.h(qr(0)) AttributeError: module 'qiskit.circuit' has no attribute 'h'",<python><matplotlib><qiskit>,11/06/2020 01:25,,,,
64717329.0,Usage of Tensorflow to train Qiskit circuits,"In order to explore whether it is possible to train a Qiskit Quantum circuit with tensorflow I built a small toy model. The purpose of this toy model is to find via tensorflow the correct angle to get &quot;zero&quot; output independent of the input. import numpy as np import qiskit from qiskit.circuit import QuantumCircuit, QuantumRegister import tensorflow as tf from tensorflow.keras.layers import Input, Dense, Layer def QuantumCircuit(thetas, n_qubits=1): simulator = qiskit.Aer.get_backend('qasm_simulator') shots=1024 circuit= qiskit.QuantumCircuit(n_qubits) circuit.h(0) circuit.ry(float(thetas),0) circuit.measure_all() job = qiskit.execute(circuit,backend=simulator,shots=shots) result = job.result().get_counts(circuit) counts = np.array(list(result.values())) states = np.array(list(result.keys())).astype(float) # Compute probabilities for each state probabilities = counts / shots # Get state expectation expectation = np.sum(states * probabilities) return np.array(expectation) class Linear(Layer): def __init__(self,units=1,input_dim=1): super(Linear,self).__init__() self.w = self.add_weight(shape=(input_dim,units),initializer='random_uniform', trainable=True) def call(self, inputs, input_dim=1): if (tf.executing_eagerly()): return QuantumCircuit(self.w) return inputs x_train = np.arange(10) y_train = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) inputs=Input(shape=(1,)) outputs=Linear()(inputs) model=tf.keras.models.Model(inputs=inputs,outputs=outputs) model.summary() model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.01), loss=tf.keras.losses.MeanSquaredError()) model.fit(x_train, y_train, epochs=100, batch_size=1, verbose=1) Unfortunately the toy model doesn't work and I get the following error: optimizer_v2.py:1219 _filter_grads ([v.name for _, v in grads_and_vars],)) ValueError: No gradients provided for any variable: ['Variable:0']. So I tried to calculate the gradient &quot;by myself&quot;: @tf.custom_gradient def custom_activation(w): result = QuantumCircuit(w) def grad(dy): eps=0.0001 result1=QuantumCircuit(w) result2=QuantumCircuit(w+eps) grad=(result2-result1)/eps return dy * [grad] return result, grad as an intermediate step before the Quantum circuit is called. But this works out neither :-( Does anybody have another idea to plug in Qiskit circuits into tensorflow and to deal with the fact that the automatic differentiation framework of tensorflow does not work in this case ? Thanks a lot !!",<tensorflow><keras><quantum-computing><qiskit>,11/06/2020 15:24,,,,
64801121.0,ModuleNotFoundError: No module named 'tensorflow_quantum',"I'm using Python 3.8(64-bit) Basically, I tried every possible solution on the internet like update the python version and tensorflow version etc. But when I try to do this: import tensorflow_quantum as tfq terminal always say: Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ModuleNotFoundError: No module named 'tensorflow_quantum' Does anyone have any idea on this issue? Cheers",<python><tensorflow><quantum-computing><tensorflow-quantum>,11/12/2020 09:21,,,,
64915576.0,IBM Quantum computer code keeps running job after job,"I'm using qiskit for my University research project but whenever I send a job to run on IBM's Quantum experience, it'll wait in the queue, run, obtain results (in the form of a histogram) but instead of moving to the next part of the code (analyzing the results), it'll join the back of the queue to be ran again. This creates a new job to be ran, obtains results, and joins the back of the queue. Has anyone else experienced a similar issue, or know how to resolve it? I should state I'm not using any loops in my code (whether for or otherwise), and I'm mainly focused on the chemistry aspect of qiskit (Ground State Eigen Solvers and VQEUCCSDFactory)",<quantum-computing><qiskit>,11/19/2020 16:13,,,,
65027865.0,Subplots with QuTip Bloch sphere,"I would like to know if is it possible to plot a figure with two subplots, in which one is a regular 2D plot and the other one a Bloch sphere.",<matplotlib><qutip><subfigure>,11/26/2020 18:59,,,,
65333227.0,Jupyter Notebook command failing in Qiskit,"I have Qiskit installed via Anaconda and a virtual environment set up in Python 3.8. When I run the command jupyter notebook in the Anaconda prompt I get an error. I'm not sure what the problem is. How do I fix it? (.venv) C:\Users\brenm&gt;pip install qiskit Requirement already satisfied: qiskit in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (0.23.1) Requirement already satisfied: qiskit-ignis==0.5.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.5.1) Requirement already satisfied: qiskit-ibmq-provider==0.11.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.11.1) Requirement already satisfied: qiskit-terra==0.16.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.16.1) Requirement already satisfied: qiskit-aqua==0.8.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.8.1) Requirement already satisfied: qiskit-aer==0.7.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.7.1) Requirement already satisfied: pybind11&gt;=2.4 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (2.6.1) Requirement already satisfied: qiskit-terra==0.16.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.16.1) Requirement already satisfied: scipy&gt;=1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.5.4) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: cython&gt;=0.27.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (0.29.21) Requirement already satisfied: psutil&gt;=5 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (5.7.3) Requirement already satisfied: qiskit-terra==0.16.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.16.1) Requirement already satisfied: scipy&gt;=1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.5.4) Requirement already satisfied: qiskit-ignis==0.5.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.5.1) Requirement already satisfied: fastdtw in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.3.4) Requirement already satisfied: scikit-learn&gt;=0.20.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.23.2) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: pandas in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.1.5) Requirement already satisfied: dlx in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.0.4) Requirement already satisfied: yfinance in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.1.55) Requirement already satisfied: docplex in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (2.19.202) Requirement already satisfied: sympy&gt;=1.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.7.1) Requirement already satisfied: h5py in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (3.1.0) Requirement already satisfied: retworkx&gt;=0.5.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.7.2) Requirement already satisfied: setuptools&gt;=40.1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (51.0.0.post20201207) Requirement already satisfied: quandl in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (3.5.3) Requirement already satisfied: requests in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.25.0) Requirement already satisfied: six in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.15.0) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: python-dateutil&gt;=2.7.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from pandas-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.8.1) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: pytz&gt;=2017.2 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from pandas-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2020.4) Requirement already satisfied: six in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.15.0) Requirement already satisfied: requests in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.25.0) Requirement already satisfied: urllib3&gt;=1.21.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.26.2) Requirement already satisfied: python-dateutil&gt;=2.7.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from pandas-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.8.1) Requirement already satisfied: qiskit-terra==0.16.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.16.1) Requirement already satisfied: requests-ntlm&gt;=1.1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.1.0) Requirement already satisfied: nest-asyncio!=1.1.0,&gt;=1.0.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.4.3) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: websockets&gt;=8 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-ibmq-provider==0.11.1-&gt;qiskit) (8.1) Requirement already satisfied: qiskit-terra==0.16.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit) (0.16.1) Requirement already satisfied: scikit-learn&gt;=0.20.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.23.2) Requirement already satisfied: scipy&gt;=1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.5.4) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: setuptools&gt;=40.1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (51.0.0.post20201207) Requirement already satisfied: dill&gt;=0.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (0.3.3) Requirement already satisfied: psutil&gt;=5 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (5.7.3) Requirement already satisfied: fastjsonschema&gt;=2.10 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (2.14.5) Requirement already satisfied: python-constraint&gt;=1.4 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (1.4.0) Requirement already satisfied: python-dateutil&gt;=2.7.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from pandas-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.8.1) Requirement already satisfied: scipy&gt;=1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.5.4) Requirement already satisfied: networkx&gt;=2.2 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (2.5) Requirement already satisfied: ply&gt;=3.10 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (3.11) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: sympy&gt;=1.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.7.1) Requirement already satisfied: retworkx&gt;=0.5.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (0.7.2) Requirement already satisfied: jsonschema&gt;=2.6 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-terra==0.16.1-&gt;qiskit) (3.2.0) Requirement already satisfied: six in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.15.0) Requirement already satisfied: pyrsistent&gt;=0.14.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from jsonschema&gt;=2.6-&gt;qiskit-terra==0.16.1-&gt;qiskit) (0.17.3) Requirement already satisfied: setuptools&gt;=40.1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (51.0.0.post20201207) Requirement already satisfied: attrs&gt;=17.4.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from jsonschema&gt;=2.6-&gt;qiskit-terra==0.16.1-&gt;qiskit) (20.3.0) Requirement already satisfied: decorator&gt;=4.3.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from networkx&gt;=2.2-&gt;qiskit-terra==0.16.1-&gt;qiskit) (4.4.2) Requirement already satisfied: inflection&gt;=0.3.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from quandl-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (0.5.1) Requirement already satisfied: python-dateutil&gt;=2.7.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from pandas-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.8.1) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: pandas in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.1.5) Requirement already satisfied: more-itertools in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from quandl-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (8.6.0) Requirement already satisfied: requests in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.25.0) Requirement already satisfied: six in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.15.0) Requirement already satisfied: certifi&gt;=2017.4.17 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from requests-&gt;docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2020.12.5) Requirement already satisfied: idna&lt;3,&gt;=2.5 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from requests-&gt;docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.10) Requirement already satisfied: urllib3&gt;=1.21.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.26.2) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from requests-&gt;docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (3.0.4) Requirement already satisfied: ntlm-auth&gt;=1.0.2 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.5.0) Requirement already satisfied: requests in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.25.0) Requirement already satisfied: cryptography&gt;=1.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.11.1-&gt;qiskit) (3.3.1) Requirement already satisfied: six in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.15.0) Requirement already satisfied: cffi&gt;=1.12 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from cryptography&gt;=1.3-&gt;requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.11.1-&gt;qiskit) (1.14.4) Requirement already satisfied: pycparser in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from cffi&gt;=1.12-&gt;cryptography&gt;=1.3-&gt;requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.11.1-&gt;qiskit) (2.20) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: threadpoolctl&gt;=2.0.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from scikit-learn&gt;=0.20.0-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.1.0) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: joblib&gt;=0.11 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from scikit-learn&gt;=0.20.0-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.0.0) Requirement already satisfied: scipy&gt;=1.0 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.5.4) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: mpmath&gt;=0.19 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from sympy&gt;=1.3-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (1.1.0) Requirement already satisfied: lxml&gt;=4.5.1 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from yfinance-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (4.6.2) Requirement already satisfied: requests in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from docplex-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (2.25.0) Requirement already satisfied: pandas in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aqua==0.8.1-&gt;qiskit) (1.1.5) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from qiskit-aer==0.7.1-&gt;qiskit) (1.19.4) Requirement already satisfied: multitasking&gt;=0.0.7 in c:\users\brenm\anaconda3\envs.venv\lib\site-packages (from yfinance-&gt;qiskit-aqua==0.8.1-&gt;qiskit) (0.0.9) (.venv) C:\Users\brenm&gt;jupyter notebook 'jupyter' is not recognized as an internal or external command, operable program or batch file.'",<python><anaconda><qiskit>,12/17/2020 0:51,,,,
65420982.0,Importing only specific variable from different file to current file,"I have 2 files on the same folder alice.py and bob.py. These are the program I wrote: #alice.py import random import numpy as np from numpy.random import randint equal_to = {&quot;upl&quot;:&quot;u_plus&quot;, &quot;EPR&quot;:&quot;u_minus&quot;, &quot;vpl&quot;:&quot;v_plus&quot;, &quot;vmin&quot;:&quot;v_minus&quot;} np.random.seed() n = 8 alice_bits = randint(2, size=n) bell_state = [] for i in range(n): while True: attempt = str(random.choice(list(equal_to))) bell_state.append(attempt) if attempt == 'EPR': break def eva(alice, bell): if alice == 1: if bell == 'upl' or bell == 'EPR': return 1 elif bell == 'vpl' or bell == 'vmin': return 0 elif alice == 0: if bell == 'vpl' or bell == 'vmin': return 1 elif bell == 'upl' or bell == 'EPR': return 0 encrypted_bits = [] _tmp = bell_state[:] for i in alice_bits: while _tmp: if _tmp[:1] != ['EPR']: encrypted_bits.append(eva(i, _tmp[0])) _tmp = _tmp[1:] else: encrypted_bits.append(eva(i, *_tmp[:1])) _tmp = _tmp[1:] break print(alice_bits) print(dict((i,e) for i,e in enumerate(bell_state)), len(bell_state)) print(str(encrypted_bits).replace(',', ''), len(encrypted_bits)) #bob.py from alice_number import * from operator import itemgetter epr_index = [i for i,e in enumerate(bell_state) if e == 'EPR'] bob_bits = list(itemgetter(*epr_index)(encrypted_bits)) print(epr_index) print(str(bob_bits).replace(',', '')) I am trying to import prepared list on alice.py and use it on bob.py. The lists are bell_state=[] and encrypted_bits=[]. How do I perform this without rerunning the entire alice.py program? I did not get the expected result because every time bob.py just rerun the entire alice.py. In principal, this is how the code should run: alice.py runs and output these results (values are example): Alice bits: [1 0 1 1 0 0 1 0] -&gt; saved as list in alice_bits bell states: {0: 'vmin', 1: 'vpl', 2: 'upl', 3: 'vpl', 4: 'vmin', 5: 'upl', 6: 'vmin', 7: 'EPR', 8: 'vpl', 9: 'vmin', 10: 'upl', 11: 'vpl', 12: 'vmin', 13: 'vpl', 14: 'upl', 15: 'upl', 16: 'vmin', 17: 'vpl', 18: 'upl', 19: 'upl', 20: 'EPR', 21: 'vpl', 22: 'vmin', 23: 'vmin', 24: 'upl', 25: 'upl', 26: 'vmin', 27: 'vmin', 28: 'vmin', 29: 'vpl', 30: 'EPR', 31: 'vpl', 32: 'vmin', 33: 'upl', 34: 'vpl', 35: 'upl', 36: 'vmin', 37: 'vpl', 38: 'upl', 39: 'vmin', 40: 'EPR', 41: 'upl', 42: 'vmin', 43: 'EPR', 44: 'vpl', 45: 'vpl', 46: 'upl', 47: 'EPR', 48: 'vmin', 49: 'vmin', 50: 'EPR', 51: 'EPR'} -&gt; saved as list in bell_state Encrypted bits: [0 0 1 0 0 1 0 1 1 1 0 1 1 1 0 0 1 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 1 0 0 1 0 1 0 1 0 1 1 0 0 0 0 1 0] -&gt; saved as list in encrypted_bits bob.py runs. Taking prepared lists of bell_state and encrypted_bits to be used in the program. As the result it should give: epr_index = [7, 20, 30, 40, 43, 47, 50, 51](index number where result is EPR) bob_bits = [1 0 1 1 0 0 1 0] Expected result should always be alice_bits == bob_bits is True. Problem is every time I run the program in this order, the result becomes alice_bits != bob_bits. I suppose this happens because alice.py is being executed once again in bob.py, thus generating different random bit sequence. If only I can import prepared bell_state=[] and encrypted_bits=[], this would not be an issue. n.b. this program is to simulate Quantum key distribution protocol",<python><python-3.x><numpy><quantum-computing>,12/23/2020 8:13,,,,
65428875.0,Jupyter Notebook failed command in Anaconda Prompt for Qiskit,"I have Qiskit installed via Anaconda and a virtual environment set up in Python 3.8. when I run (.venv) C:\Users\brenm&gt;jupyter notebook (in Anaconda prompt) it fails and throws 'jupyter' is not recognized as an internal or external command, operable program or batch file. To counter this, I ran (.venv) C:\Users\brenm&gt;python -m pip install jupyter --user and jupyter notebook installed properly. But when I run jupyter notebookin the Anaconda prompt, it still throws 'jupyter' is not recognized as an internal or external command, operable program or batch file. I'm very confused as to what is happening because I believed jupyter notebook was a Qiskit dependency that was supposed to be installed already. More so, I'm confused why when I manually install jupyter notebook, the command jupyter notebook is not recognized.",<python><python-3.x><jupyter-notebook><anaconda><qiskit>,12/23/2020 18:03,,,,
65833565.0,Can I change the byte ordering from little endian to big endian in qiskit?,"The regular Matrix representation of a CNOT gate as found in literature is: CNOT = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} However in Qiskit, the matrix is represented as CNOT = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} Is this something related to the Big-endian/Little-endian issue? Is there a way to represent my matrix the same way it is recovered in literature?",<endianness><qiskit>,1/21/2021 18:24,,,,
65971394.0,Applications of Grover's algorithm in machine learning,"I am trying to see applications of grover's algorithm. I have seen it can be applied in the DNA sequence alignment. I was wondering where in machine learning (deep learning, NLP and reinforcement learning) can i use the grover's algorithm.",<machine-learning><quantum-computing>,1/30/2021 17:59,,,,
66322856.0,Is it possible to use Grover's Search Algorithm on an Array in Node.js?,"I have an array, and am wondering if using Grover's search algorithm would work on it. Is this possible to do in Node.js? Would I use something like quantum-circuit to achieve this goal? Thanks.",<node.js><quantum-computing>,2/22/2021 20:21,,,,
66348257.0,Qiskit: how can you use a different state for each shot in a quantum circuit?,"I am trying to run a quantum circuit many times, each time using a different random state - a single qubit i.e. |\psi&gt;= a|0&gt; + b|1&gt; with different a and b. Once each qubit has gone through the circuit, I am saving the state vector of the final state, and converting this to spherical coordinates by calculating \theta and \phi. I append each \theta and \phi value to a list and then plot them on a histogram (omitted below). Whilst this works, for large 'num_states' it is very slow, so I am wondering if there is a way to use the 'shots' feature when executing the circuit, since you can write: job = execute(qc, backend, shots=1000) I tried playing around with this but found after the initial random state was generated, it repeated the circuit with the same state for the number of shots, rather than doing a different state each time. I'd like to use the shots feature as I believe this will be much quicker since OpenMP is built into Qiskit. Any ideas on how I might be able to implement a different state each time using shots would be much appreciated:) import numpy as np from qiskit import( QuantumCircuit, execute, Aer) from math import pi from qiskit.quantum_info import random_statevector #----------------------------------------------------------------------# backend = Aer.get_backend('statevector_simulator') def simulate_states(num_states): qc = QuantumCircuit(1) theta_vals = [] phi_vals = [] for i in range(num_states): random_state = random_statevector(2).data qc.initialize(random_state, 0) qc.z(0) job = execute(qc, backend) result = job.result() out_state = result.get_statevector() theta, phi, alpha_r, alpha_i, beta_r, beta_i = state_coords(out_state) theta += pi/2 theta_vals.append(theta) phi_vals.append(phi) return theta_vals, phi_vals def state_coords(statevector): &quot;&quot;&quot; determines the spherical coordinates of a state on the Bloch sphere i.e. calculates \theta and \phi. &quot;&quot;&quot; alpha = statevector[0] alpha_r = alpha.real alpha_i = alpha.imag beta = statevector[1] beta_r = beta.real beta_i = beta.imag theta = np.arcsin(2*((alpha_r*beta_r) - (alpha_i*beta_i))) phi = 2*np.arccos(2*((alpha_r**2)+(beta_r**2))-1) return theta, phi, alpha_r, alpha_i, beta_r, beta_i",<python><quantum-computing><qiskit>,2/24/2021 9:41,,,,
66437187.0,make: *** No rule to make target 'generic64/libkeccak.a',"I downloaded some post quantum algorithms from NIST and tested them. Some codes need to use Keccak package, so I downloaded it. When I tried to &quot;make generic64/libkeccak.a&quot;, I got an error message: make: *** No rule to make target 'generic64/libkeccak.a'. Stop. How can I fix it? Thank you for any help.",<c++><keccak><post-quantum-cryptography>,03/02/2021 10:02,,,,
66633807.0,qubit/cbit arguments does not match gate expectation,"I am trying to use the code tutorials/finance/09_credit_risk_analysis.html for 3 assets. Face problem in running line 13: # define the registers for convenience and readability. The error: ---&gt; state_preparation.append(agg.to_gate(), qr_state[:] + qr_sum[:] + qr_carry[:]) CircuitError: 'The amount of qubit/clbit arguments does not match the gate expectation.' Please help me to debug.",<qiskit>,3/15/2021 7:21,,,,
66869975.0,compare between the factorization time get prime,"i try to compare between the factorization time between : 1) classical algorithm function: def is_prime1(n): if n&lt;2: return False for i in range(2,n): if n % i ==0: return False return True def output_prime_factors(num): num=round(num) p=0 while p &lt; num: p +=1 if num % p==0 and is_prime1(p)==True: print (p) Shor's algorithm on Qiskit (IBM) but the output is Unexpected that the quantum is slower how this happen ) N = 15 shor = Shor(N) backend = BasicAer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1024) result = shor.run(quantum_instance) print(f&quot;The list of factors of {N} as computed by the Shor's algorithm is {result['factors'][0]}.&quot;) the qiskit is slower than the classical function",<algorithm><factorization><qiskit>,3/30/2021 11:16,,,,
66883644.0,What's the complexity of 3-SAT algorithm on a quantum machine?,I know that 3-SAT problem is NP-Complete but 'they say' it can be run quit faster on a quantum machine. Could you explain what kind of performance is possible to gain using quantum computers?,<algorithm><np><quantum-computing>,3/31/2021 7:42,,,,
66995542.0,Generate 3 qubit W state using standard quantum gates,"Starting from the state |000&gt;, how can I generate the state (|100&gt; + |010&gt; + |001&gt;)/sqrt(3) using only X,Y,Z,H,S,T,SWAP,TOFFOLI, rotation gates, QFT, and their controlled versions and any number of ancilla bits?",<quantum-computing>,04/07/2021 23:42,,,,
66996905.0,'qiskit' has no attribute '__qiskit_version__',"as title says, I type qiskit.__qiskit_version__ and get the error AttributeError: module 'qiskit' has no attribute 'qiskit_version'. I have Anaconda installed as well as pip installed qiskit and qiskit[visualization]. The jupyter notebook only works within my python file and not sure what else to do?",<python><qiskit>,04/08/2021 03:21,,,,
67042982.0,"How to create Entanglement, Superposition and interference?","I am looking the way How to create Entanglement, Superposition and interference? Can someone help to show how to code in qiskit? and the docs related to these mentioned above? Thanks",<python><algorithm><temenos-quantum><qiskit>,04/11/2021 08:44,,,,
67328122.0,Can't we enforce a limited number of attempts to prevent quantum computing from cracking our RSA encryption in the future? Or am I missing something?,"It is often said that quantum computing could eventually be the end of modern encryption, and data security companies will eventually need to discover and implement quantum safe encryption. But can't a company just set limits on how many password attempts are allowed in a given time? Couldn't this slow down the brute force enough to keep data safe for several hundred+ years?",<security><authentication><encryption><rsa><quantum-computing>,4/30/2021 4:18,,,,
67435154.0,Using qutip.mesolve() to calculate the time evolved Hamiltonian with time dependent variable,"I'm trying to find the time evolution of some initial state with a time dependent hailtonian where also the z variable (gradient of time evolution) is time dependent. Usually the qutip.mesolve() function can be used for this when the z variable is a constant and the Hamiltonian is defined as follows: def hamiltonian_t(t,args): &quot;&quot;&quot; evaluate the hamiltonian at time t. &quot;&quot;&quot; H0 = args[0] Hp = args[1] z = args[2] return (1-t*z)*H0 + t*z*Hp This is a Hamiltonian that evolves from H0 to Hp. I then use qt.mesolve(hamiltonian_t,psi_init,tlist,[],[],H_args) with args = (H0,Hp,z). But for the current problem with the time dependent z variable I have tried to define the Hamiltonian as follows: def hamiltonian_t(tz,args): &quot;&quot;&quot; evaluate the hamiltonian at time t. &quot;&quot;&quot; H0 = args[0] Hp = args[1] t = tz[0] z = tz[1] return (1-t*z)*H0 + t*z*Hp Here args = (H0,Hp) for some H0 and Hp. I then tried using qt.mesolve(hamiltonian_t,psi_init,tz,[],[],H_args) to calculate the time evolution where tz=[(tlist[0],z[0]),...,(tlist[-1],z[-1])]. I'm receiving the error TypeError: 'float' object is not subscriptable at the line t = tz[0]. I don't understand why I get this error because the input for tz is a list of tuples not floats. The mesolve function should then take every list element and evaluate the Hamiltonian, at least that's what I thought it did. This function usually works for finding the time evolution when I have args = (H0,Hp,z) for some H0, Hp and z and I use qt.mesolve(hamiltonian_t,psi_init,tlist,[],[],H_args) , but my problem involves a z variable that is different for each t in tlist. Can anybody please help me define this function properly so that qutip.mesolve() can use the corresponding z for each time in tlist and calculate the time evolution?",<python><quantum-computing><qutip><multiple-arguments>,05/07/2021 12:41,,,,
67448934.0,"The Universtal Gate U(theta, phi, lamda) in Open QASM vs Qiskit","I have noticed that Open QASM and Qiskit define the universal single-qubit gate U(lambda, theta, phi) differently. The difference causes a phase difference in RZ, for example. Has anyone come across this problem? Which should one choose?",<quantum-computing><qiskit>,05/08/2021 15:01,,,,
67480117.0,How to use qiskit gpu on window?,I want to calculate unitary of quantum circuit with GPU because my cpu is already too busy. But it seems qiskit-aer-gpu supports only ubuntu. Is there any way to use it on window10?,<python><qiskit>,05/11/2021 03:16,,,,
67593941.0,"tensorflow, tensorflow-quantum, grpcio dependency conflicts","I installed tensorflow-quantum and got the following error: tensorflow-quantum 0.5.0 requires grpcio==1.30.0, but you have grpcio 1.32.0 which is incompatible. So, I installed grpcio 1.30.0, but then got the following error: tensorflow 2.4.1 requires grpcio~=1.32.0, but you have grpcio 1.30.0 which is incompatible. It seems these dependency conflicts are cyclic. What should I do?",<tensorflow><installation><pip><tensorflow-quantum><grpcio>,5/18/2021 21:04,,,,
67674886.0,Re-implement a QuTip function without the need for the QuTip toolbox,"Is there a way to implement this function that is part of QuTip functions ( Quantum Toolbox in Python) without the need for installing QuTip? def destroy(N, offset=0): if not isinstance(N, (int, np.integer)): # raise error if N not integer raise ValueError(&quot;Hilbert space dimension must be integer value&quot;) data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)) ind = np.arange(1,N, dtype=np.int32) ptr = np.arange(N+1, dtype=np.int32) ptr[-1] = N-1 return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False) DESTROY returns annihilation operator for N-dimensional Hilbert space out = destroy(N), N is integer value &amp; N&gt;0",<python><function><quantum-computing><qutip>,5/24/2021 15:34,,,,
67707357.0,Qiskit Nature VQE print full quantum circuit,I am doing VQE using Qiskit Nature. I want to see how my final quantum circuit looks like. How to print the whole quantum circuit (like an ansatz)?,<qiskit>,5/26/2021 14:48,,,,
67822937.0,Error installing Quipper - cannot build quipper-utils-0.9.0.0 (Couldn't match type 'Maybe TH.Exp' with 'TH.Exp'),"Trying to install Quipper (quantum programming language for Haskell), it throws a compilation error: My build profile: -w ghc-9.0.1 -O1 Preprocessing library for quipper-utils-0.9.0.0.. Building library for quipper-utils-0.9.0.0.. ... [11 of 15] Compiling Quipper.Utils.Template.Lifting ( Quipper/Utils/Template/Lifting.hs, dist/build/Quipper/Utils/Template/Lifting.o, dist/build/Quipper/Utils/Template/Lifting.dyn_o ) Quipper/Utils/Template/Lifting.hs:252:28: error: â¢ Couldn't match type âMaybe TH.Expâ with âTH.Expâ Expected: [TH.Exp] Actual: [Maybe TH.Exp] â¢ In the second argument of âmapMâ, namely âexpsâ In a stmt of a 'do' block: exps' &lt;- mapM expTHtoAST exps In the expression: do exps' &lt;- mapM expTHtoAST exps return (TupE exps') | 252 | exps' &lt;- mapM expTHtoAST exps | ^^^^ Quipper/Utils/Template/Lifting.hs:417:20: error: â¢ Couldn't match type âTH.Expâ with âMaybe TH.Expâ Expected: [Maybe TH.Exp] Actual: [TH.Exp] â¢ In the first argument of âTH.TupEâ, namely âexps'â In the second argument of â($)â, namely âTH.TupE exps'â In a stmt of a 'do' block: return $ TH.TupE exps' | 417 | return $ TH.TupE exps' | ^^^^^ cabal: Failed to build quipper-utils-0.9.0.0 (which is required by quipper-0.9.0.0). See the build log above for details.",<haskell><ghc><quantum-computing><qiskit>,06/03/2021 14:03,,,,
67982685.0,Difference between different Quantum states with the same result,"What is the practical and theoretical difference is between these 3 states, which ultimately produce the same output result. Could you tell me some examples of different results obtained starting from these 3 states and doing the same operations below. The concept is unclear to me. Thank you |0&gt; -&gt; RY(pi/2) -&gt; RX(pi) -&gt; cnot q[0] q[1] |0&gt; -&gt; RX(pi/2) -&gt; cnot q[0] q[1] |0&gt; -&gt; H -&gt; cnot q[0] q[1]",<quantum-computing>,6/15/2021 8:27,,,,
68137793.0,Calculate the time dependence expectation value of a quantum operator with tensorflow,"I'm trying to calculate the expectation value of a quantum operator in function of time. I obtained yes the states for every istance t_l = tf.constant( np.linspace(0, 4 / gam_q, 1000, dtype = np.complex128) ) dt = t_l[1] - t_l[0] H_t = tf.tensordot(- 1j * t_l, H, 0) H_t = tfla.expm(H_t) psi0 = tf.constant( ((qtp.fock(2, 0)).unit()).full() ) psi_t = tf.tensordot(H_t, psi0, [[2], [0]]) where H is the Hamiltonian (sigma_z in this case). However, I need to know the time dependence of the expectation value of an operator S_op. I tried this pre = tf.tensordot( tf.math.conj(psi_t), S_op, [[1], [0]]) #psi_t was not transposed, so I put [[1], [0]] expect = tf.tensordot(pre, psi_t, [[2], [1]]) which returns a tensor of shape (1000, 1, 1000, 1), while I need a 1D array of shape (1000). EDIT I solved by introducing the einsum pre = tf.tensordot(tfmt.conj(psi_t), S_op, [[1], [0]]) expect = tfmt.real( tf.tensordot(pre, psi_t, [[2], [1]]) ) expect = tf.einsum(&quot;ijij-&gt;i&quot;, expect)",<python><tensorflow><physics><quantum-computing><qutip>,6/25/2021 22:58,,,,
68326212.0,Observe the expectation values of seperate qubits in OpflowQNN (Qiskit machine learning),"I create an instance of a OpflowQNN with the following: qnn = OpflowQNN(operator=~StateFn(Z ^ Z ^ I ^ I) @ StateFn(circuit), input_params=input_params, weight_params=weights, quantum_instance=qi ) where circuit is a qiskit.circuit.QuantumCircuit operating on 4 qubits. What I am trying to achieve is to only measure the expectation value on qubit 2 and 3 in the Z-basis when running the forward pass. I don't need the values for qubits 0 and 1. I want the expectation value for both qubits seperately, which leads to an output shape of (2,) in the forward pass. What I tried to do is to apply the Pauli Z operators to the 2nd and 3rd qubit only, as you can see in the code snippet above. But still the output of the forward pass has shape (1,). I am currently struggeling to understand what exacly these Observables do. I also don't really get what the output of the forward pass in the OpflowQNN is. My guess was some summed up expectation values, but I am not quite sure about it. Another thing I tried with the work-in-progress version of qiskit that I built from source (Otherwise this would not work): operator=ListOp([~StateFn(Z ^ I ^ I ^ I), ~StateFn(I ^ Z ^ I ^ I)]) @ StateFn(circuit) This gives me an array of shape (2,) in the forward pass, but I am not sure if this is really the right way to calculate the expectation values on qubit 2 and 3.",<machine-learning><quantum-computing><qiskit>,07/10/2021 08:50,,,,
68981632.0,How do you change the backend.run() command?,"This is code from Chapter 6.1 of the qiskit textbook, which shows a job being run. How would you change the first line of the backend.run() command, the schedules parameter, in order to use it for a measurement for a constant pulse shape. The schedules parameter from the given code represents a frequency sweep that was defined earlier in the qiskit textbook. I want to keep the other parameters of backend.run the same and change the schedules part to something else and use this command on a constant pulse shape. I don't know exactly how to modify the schedules part of the command properly. num_shots_per_frequency = 1024 job = backend.run(schedules, meas_level=1, meas_return='avg', shots=num_shots_per_frequency)",<qiskit>,7/26/2021 4:27,,,,
68561531.0,Can I get statevector of the experiment result while working with IBM Computers?,"I know that working with Aer.get_backend(&quot;statevector_simulator&quot;) gives me a statevector. I am trying to get the statevector when I worked with the IBM's quantum computers. To explain in the codes; From the code below I can reach the statevector. backend = Aer.get_backend('statevector_simulator') job = execute(circ, backend) print(f&quot;print(job):{job}\n\n&quot;) #print(job.status()) result = job.result() print(f&quot;print(result):{result}\n\n&quot;) output = result.get_statevector(circ, decimals=5) print(f&quot;print(output):{output}\n\n&quot;) ,and my question is wheter I can get the statevector while using one of the IBM's computer; provider = IBMQ.load_account() provider = IBMQ.get_provider(&quot;ibm-q&quot;) device = least_busy(provider.backends(filters=lambda x: x.configuration().n_qubits &gt;= 3 and not x.configuration().simulator and x.status().operational==True)) job = execute(circ, device) result = job.result() output = result.get_statevector(circ, decimals=5) The last line is where I get the error. I need to figure out how to get the statevector from job.result()",<quantum-computing><qiskit>,7/28/2021 13:41,,,,
68563259.0,Getting a Symbol not found error while importing a python module,"I'm trying to import a python module called qiskit, but whenever I do, I get the following error: ImportError: dlopen(/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so, 2): Symbol not found: _aligned_alloc Referenced from: /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so Expected in: /usr/lib/libSystem.B.dylib in /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so This occurred yesterday when I installed another module called ibm_quantum_widgets. I tried uninstalling and reinstalling qiskit but it doesn't seem to work. Any ideas?",<python><python-3.x><pip><qiskit>,7/28/2021 15:29,,,,
68598726.0,ad_hoc_data(...) resulting in test_input as an array instead of a dictionary,"qiskit version : 0.18.0 numpy version : 1.21.1 qiskit_machine_learning version : 0.2.0 qiskit.aqua version : 0.9.4 I am trying to run a simple code as described in Qiskit's tutorial on Machine Learning. feature_dim=2 training_dataset_size=20 testing_dataset_size=10 random_seed=10598 shots=10000 sample_Total,training_input,test_input,class_labels = ad_hoc_data(training_size=training_dataset_size, test_size=testing_dataset_size, gap=0.3, n=feature_dim, plot_data=True) datapoints,class_to_label=split_dataset_to_data_and_labels(test_input) But I receive the error AttributeError Traceback (most recent call last) &lt;ipython-input-11-f11e4f763266&gt; in &lt;module&gt; 10 n=feature_dim, 11 plot_data=True) ---&gt; 12 datapoints,class_to_label=split_dataset_to_data_and_labels(test_input) ~\anaconda3\lib\site-packages\qiskit\aqua\utils\dataset_helper.py in split_dataset_to_data_and_labels(dataset, class_names) 83 labels = [] 84 if class_names is None: ---&gt; 85 sorted_classes_name = sorted(list(dataset.keys())) 86 class_to_label = {k: idx for idx, k in enumerate(sorted_classes_name)} 87 else: AttributeError: 'numpy.ndarray' object has no attribute 'keys' By which I assume (and checked by printing it) that ad_hoc_data(...) is resulting in test_input in numpy.ndarray type as opposed to the expected dict type. Is there something trivial I'm missing here or is there an actual issue with the code? Thanks in advance",<python><machine-learning><adhoc><qiskit>,7/31/2021 2:57,,,,
68614557.0,Why do I get an import error when importing Qiskit?,"Whenever I import qiskit, I get the following error. Anyone know why? ImportError: dlopen(/opt/anaconda3/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so, 2): Symbol not found: _aligned_alloc Referenced from: /opt/anaconda3/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so Expected in: /usr/lib/libSystem.B.dylib in /opt/anaconda3/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so",<python><pip><jupyter-notebook><qiskit>,08/01/2021 21:39,,,,
68877919.0,No module named 'qiskit_metal',"When I just want to import qiskit_metal, and it can't found it. Should install something? There is the wrong Traceback (most recent call last): File &quot;&quot;, line 1, in import qiskit_metal ModuleNotFoundError: No module named 'qiskit_metal'",<qiskit>,8/22/2021 1:44,,,,
68907762.0,ImportError - from qiskit import BasicAer,"I used conda create --name qc-26 --clone base; conda activate qc-26; jupyter notebook Whenever I ran, from qiskit import BasicAer I received the following error messages ImportError: dlopen(/opt/anaconda3/envs/QC/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so, 2): Symbol not found: _aligned_alloc Referenced from: /opt/anaconda3/envs/QC/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so Expected in: /usr/lib/libSystem.B.dylib in /opt/anaconda3/envs/QC/lib/python3.8/site-packages/tweedledum/_tweedledum.cpython-38-darwin.so Below is the qiskit information on my iMAC, version 10.13.6 {'qiskit-terra': '0.17.4', 'qiskit-aer': '0.8.2', 'qiskit-ignis': '0.6.0', 'qiskit-ibmq-provider': '0.13.1', 'qiskit-aqua': '0.9.1', 'qiskit': '0.26.1', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': '0.2.0'}",<python><importerror><dlopen><alloc><qiskit>,8/24/2021 12:39,,,,
68919833.0,Qiskit simulator intermediate results,"Is it possible to get an intermediate result from qiskit simulator? Let's suppose I have a really simple circuit. OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q[2]; creg c[2]; h q[0]; z q[0]; measure q[0] -&gt; c[0]; I would like to get the vector state after applying the H gate and then again after applying the Z gate. I can not use the measurement gate, because I would lose the qubit state. Can I query the qubit/vector for each step in a circuit?",<python><qiskit>,8/25/2021 8:57,,,,
68954685.0,Qiskit: mpl drawer module,"I started using Qiskit with their official tutorial (Sezon 1) and I got a few bugs with the same code, at the beginning I just had to install pylatexenc but then I had &quot;module 'qiskit.circuit' has no attribute 'draw'&quot; error, this is not true as I used it before, I found some things about it on GitHub but no clear solution, my code is: from qiskit import * qr = QuantumRegister(2) cr = ClassicalRegister(2) circuit = QuantumCircuit(qr, cr) circuit = QuantumCircuit(qr, cr) circuit.draw() [it worked, output: q0_0: q0_1: c0: 2/ ] circuit.h(qr[0]) [output: &lt;qiskit.circuit.instructionset.InstructionSet at 0x12dc159de50&gt;] circuit.draw(output= 'mpl') error: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-4-4b6f233c71ed&gt; in &lt;module&gt; ----&gt; 1 circuit.draw(output= 'mpl') AttributeError: module 'qiskit.circuit' has no attribute 'draw' I use jupiter and Python 3.8, if version is wrong please tell me what version should I use and where do I download it, also, the output in first circuit.draw() is for some reason different than in original video",<python><jupyter><qiskit>,8/27/2021 13:58,,,,
69015167.0,How can I obtain the numerical values of the density matrix elements in a state_city plot in qiskit,"I have run code following the documentation in the qiskit section on Entanglement Verification, up through the steps: [Earlier material from Entanglement Verification, followed by] meas_calibs, state_labels = complete_meas_cal(qubit_list=qubit_list, qr=qr, circlabel='mcal') job_c = execute(meas_calibs, backend=qcomp, coupling_map=coupling_map) job_monitor(job_c) meas_result = job_c.result() meas_fitter = CompleteMeasFitter(meas_result,state_labels,circlabel='mcal') result_em = meas_fitter.filter.apply(job.result()) tomo_em = StateTomographyFitter(result_em, qst) visualization.plot_state_city(tomo.fit(),&quot;Density Matrix&quot;) This prints a very useful plot showing the real and imaginary parts of the density matrix, so it seems to be working. Question: How can I print the actual numerical values of the density matrix elements that are being plotted? Thanks in advance for any help!",<qiskit>,09/01/2021 04:14,,,,
69245836.0,Getting 'Figure(..x..)' when drawing quantum circuit with qiskit âmplâ output mode,"I am just starting with Quantum Computing and I tried the following code. from qiskit import * qr = QuantumRegister(2) cr = ClassicalRegister(2) Qc = QuantumCircuit(qr,cr) print ('This is the initial state') print(Qc.draw(output = 'mpl')) print ('') The problem I am facing is with drawing the circuit. When use qc.draw() it gives me a line representation of the circuit and its good enough for me to see what is on it. But when I put output='mpl' I am getting the following results. This results in This is the initial state Figure(142.949x204.68) I have been using spyder for all my programming but I also tried the same thing in jupyter and the result was the same. What is this Figure(.............) and where can I find it?",<quantum-computing><qiskit>,9/19/2021 18:02,,,,
69485215.0,How do I get Pycharm to show qiskit visualization?,"I am trying to do the qiskit tutorials in pycharmCE. I can get all the numbers but I am unable to get the graphs to show. Instead of a graph, it prints &quot;Figure(700x700) Here is the code: from qiskit import * from qiskit.visualization import plot_histogram from qiskit.tools.monitor import job_monitor #qunatum circit in bell state bell = QuantumCircuit(2 ,2) bell.h(0) bell.cx(0, 1) meas = QuantumCircuit(2, 2) meas.measure([0,1], [0,1]) #execute Qc backend = BasicAer.get_backend('qasm_simulator') #the divice to run circ = bell.compose(meas) result = backend.run(transpile(circ, backend), shots=1000).result() counts = result.get_counts(circ) print(counts) plot_histogram(counts)",<pycharm><qiskit>,10/07/2021 17:09,,,,
69691564.0,qiskit install error Command errored out with exit status 1:,"I was installing qiskit with python 3.10 using pip install qiskit I had this error message then retried to reinstall dependencies starting from scipy. ERROR: Command errored out with exit status 1: 'C:\Users\V\Anaconda3\envs\quantum\python.exe' -u -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '&quot;'&quot;'C:\\Users\\V\\AppData\\Local\\Temp\\pip-install-wzcm65xt\\numpy_c83cea5123ba4c3796a5f07a57f874a8\\setup.py'&quot;'&quot;'; __file__='&quot;'&quot;'C:\\Users\\V\\AppData\\Local\\Temp\\pip-install-wzcm65xt\\numpy_c83cea5123ba4c3796a5f07a57f874a8\\setup.py'&quot;'&quot;';f = getattr(tokenize, '&quot;'&quot;'open'&quot;'&quot;', open)(__file__) if os.path.exists(__file__) else io.StringIO('&quot;'&quot;'from setuptools import setup; setup()'&quot;'&quot;');code = f.read().replace('&quot;'&quot;'\r\n'&quot;'&quot;', '&quot;'&quot;'\n'&quot;'&quot;');f.close();exec(compile(code, __file__, '&quot;'&quot;'exec'&quot;'&quot;'))' install --record 'C:\Users\V\AppData\Local\Temp\pip-record-5ph1znak\install-record.txt' --single-version-externally-managed --prefix 'C:\Users\V\AppData\Local\Temp\pip-build-env-cfe2bivd\overlay' --compile --install-headers 'C:\Users\V\AppData\Local\Temp\pip-build-env-cfe2bivd\overlay\Include\numpy' Check the logs for full command output. The only similar request was with out a solution.",<python><installation><pip><qiskit>,10/23/2021 19:55,,,,
69760037.0,Determining the phase of a qubit,"Let's say I've got a qubit, being in one of two states: either [ 0.995+0j, 0.098+0j ] or [ 0.995+0j, -0.098+0j ], that is the state I get when applying a RY-gate with Î¸ = Â±Ï/x to |0&gt;. In the both states above, x would be 16, but let's just say it is just a large number, so the probability to measure |1&gt; is nearly 0%. Is there any way to determine which of these cases is true, so whether the phase angle now is 0 or Ï? I am not very familiar with either quantum computers or the english language, so I hope that I managed to somehow express what I mean and that you can forgive me the mistakes I have most probably made.",<quantum-computing><qubit>,10/28/2021 19:44,,,,
69802802.0,Install IBM Qiskit for quantum computer simulation,"I am having trouble uploading qiskit to my Ananconda3 environment. I follow these steps without any problem. In Anaconda3 shell conda create -n ENV_NAME python=3 conda activate ENV_NAME pip install qiskit pip install qiskit[visualization] When I check the modules with conda list, qiskit is not to be found. Other modules such as numpy, matplotlib, etc. are present. Any suggestions? On my previous Windows based PC, I was able to download everything without any problems.",<qiskit>,11/01/2021 21:07,,,,
70295468.0,I'm trying to use the new Qiskit Dynamics module. Do I have to do anything special to import it?,"I'm running in the IBM Quantum Lab environment, so I should have access to all the latest code. But I get the following error: ModuleNotFoundError: No module named 'qiskit_dynamics'",<qiskit>,12/09/2021 19:13,,,,
70343216.0,Applying QPE on a large matrix on amazon-braket,"I'm running a QPE algorithm on the amazon-braket but it can only apply on a 22 or 44 matrix, when I want to expand it into a 5*5 or more, it will come an error. As I know, there is no theoretical limitation on the size of matrix QPE can solve. Here is the main part of the code: def get_qpe_phases(measurement_counts, precision_qubits, items_to_keep=1): bitstrings_precision_register = [ substring(key, precision_qubits) for key in measurement_counts.keys() ] bitstrings_precision_register_set = set(bitstrings_precision_register) bitstrings_precision_register_list = list(bitstrings_precision_register_set) precision_results_dic = {key: 0 for key in bitstrings_precision_register_list} for key in measurement_counts.keys(): counts = measurement_counts[key] count_key = substring(key, precision_qubits) precision_results_dic[count_key] += counts c = Counter(precision_results_dic) topmost = c.most_common(items_to_keep) phases_decimal = [binaryToDecimal(item[0]) for item in topmost] return phases_decimal, precision_results_dic def run_qpe( unitary, precision_qubits, query_qubits, query_circuit, items_to_keep=1, shots=1000 ): circ = query_circuit circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False) # Add desired results_types number_precision_qubits = len(precision_qubits) num_qubits = len(precision_qubits) circ.probability(np.array(precision_qubits)) device = LocalSimulator() task=device.run(circ,shots=shots) result=task.result() metadata = result.task_metadata probs_values = result.values[0] measurements = result.measurements measured_qubits = result.measured_qubits measurement_counts = result.measurement_counts measurement_probabilities = result.measurement_probabilities format_bitstring = &quot;{0:0&quot; + str(num_qubits) + &quot;b}&quot; bitstring_keys = [format_bitstring.format(ii) for ii in range(2 ** num_qubits)] phases_decimal, precision_results_dic = get_qpe_phases( measurement_counts, precision_qubits, items_to_keep ) print('\nPhases:',phases_decimal) eigenvalues = [np.exp(2 * np.pi * 1j * phase) for phase in phases_decimal] # aggregate results out = { &quot;circuit&quot;: circ, &quot;task_metadata&quot;: metadata, &quot;measurements&quot;: measurements, &quot;measured_qubits&quot;: measured_qubits, &quot;measurement_counts&quot;: measurement_counts, &quot;measurement_probabilities&quot;: measurement_probabilities, &quot;probs_values&quot;: probs_values, &quot;bitstring_keys&quot;: bitstring_keys, &quot;precision_results_dic&quot;: precision_results_dic, &quot;phases_decimal&quot;: phases_decimal, &quot;eigenvalues&quot;: eigenvalues, } return out And when it comes to a 6*6 matrix, from scipy.stats import unitary_group import numpy as np np.random.seed(seed=3000) unitary1 = unitary_group.rvs(6) result = estimate_phase(4,unitary1,5,printcir=False) the error report is like: --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-21-4eae0beac402&gt; in &lt;module&gt; 4 5 unitary = unitary_group.rvs(6) ----&gt; 6 result = estimate_phase(4,unitary,5,printcir=False) &lt;ipython-input-9-30dffae9e6c6&gt; in estimate_phase(n, unitary, runit, shots, printcir) 15 query = Circuit().h(query_qubits) 16 ---&gt; 17 result = run_qpe(unitary, precision_qubits, query_qubits, query, items_to_keep=elen, shots = shots) 18 qeigvals= postprocess_qpe_results(result,printcir) 19 &lt;ipython-input-6-1875e0e5a610&gt; in run_qpe(unitary, precision_qubits, query_qubits, query_circuit, items_to_keep, shots) 92 ): 93 circ = query_circuit ---&gt; 94 circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False) 95 96 # Add desired results_types ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) &lt;ipython-input-6-1875e0e5a610&gt; in qpe(precision_qubits, query_qubits, unitary, control_unitary) 39 else: 40 for _ in range(2 ** power): ---&gt; 41 qpe_circ.controlled_unitary(qubit, query_qubits, unitary) 42 qpe_circ.inverse_qft(precision_qubits) 43 ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) &lt;ipython-input-6-1875e0e5a610&gt; in controlled_unitary(control, target_qubits, unitary) 21 targets = [control] + target_qubits 22 ---&gt; 23 circ.unitary(matrix=controlled_matrix, targets=targets) 24 25 return circ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/gates.py in unitary(targets, matrix, display_name) 1339 &quot;&quot;&quot; 1340 if 2 ** len(targets) != matrix.shape[0]: -&gt; 1341 raise ValueError(&quot;Dimensions of the supplied unitary are incompatible with the targets&quot;) 1342 1343 return Instruction(Gate.Unitary(matrix, display_name), target=targets) ValueError: Dimensions of the supplied unitary are incompatible with the targets So I'm wondering if it's the packages' problem or the program problem or any other had met the similar problem as I? Thanks in advance!",<python><amazon-web-services><numpy><matrix><quantum-computing>,12/14/2021 2:47,,,,
70394317.0,pip install qiskit errors,"So I'm trying to get qiskit to work on my system (arch linux) but I'm having trouble installing qiskit, specifically qiskit-aer. I've seen several other posts with similar issues suggesting that I downgrade python. To do this I'm using pyenv running python 3.8.7 so if I run python -V i get the output python 3.8.7. Still when i try to pip install qiskit i get this gigantic error that i'll leave below: I noticed that even running pyenv if i do pip --version i get the output pip 21.3.1 from /home/gustavo/.local/lib/python3.10/site-packages/pip (python 3.10) i don't know if that has anything to do with it. Any help getting this thing to work is much appreciated. command: /usr/bin/python -u -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;'; __file__='&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;';f = getattr(tokenize, '&quot;'&quot;'open'&quot;'&quot;', open)(__file__) if os.path.exists(__file__) else io.StringIO('&quot;'&quot;'from setuptools import setup; setup()'&quot;'&quot;');code = f.read().replace('&quot;'&quot;'\r\n'&quot;'&quot;', '&quot;'&quot;'\n'&quot;'&quot;');f.close();exec(compile(code, __file__, '&quot;'&quot;'exec'&quot;'&quot;'))' bdist_wheel -d /tmp/pip-wheel-yvnffenf cwd: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/ Complete output (199 lines): /home/gustavo/.local/lib/python3.10/site-packages/setuptools/installer.py:27: SetuptoolsDeprecationWarning: setuptools.installer is deprecated. Requirements should be satisfied by a PEP 517 installer. warnings.warn( -------------------------------------------------------------------------------- -- Trying &quot;Ninja&quot; generator -------------------------------- --------------------------- ---------------------- ----------------- ------------ ------- -- Not searching for unused variables given on the command line. CMake Error: CMake was unable to find a build program corresponding to &quot;Ninja&quot;. CMAKE_MAKE_PROGRAM is not set. You probably need to select a different build tool. -- Configuring incomplete, errors occurred! See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_cmake_test_compile/build/CMakeFiles/CMakeOutput.log&quot;. -- ------- ------------ ----------------- ---------------------- --------------------------- -------------------------------- -- Trying &quot;Ninja&quot; generator - failure -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -- Trying &quot;Unix Makefiles&quot; generator -------------------------------- --------------------------- ---------------------- ----------------- ------------ ------- -- Not searching for unused variables given on the command line. -- The C compiler identification is GNU 11.1.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- The CXX compiler identification is GNU 11.1.0 -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_cmake_test_compile/build -- ------- ------------ ----------------- ---------------------- --------------------------- -------------------------------- -- Trying &quot;Unix Makefiles&quot; generator - success -------------------------------------------------------------------------------- Configuring Project Working directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build Command: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 -G 'Unix Makefiles' -DCMAKE_INSTALL_PREFIX:PATH=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-install -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python -DPYTHON_VERSION_STRING:STRING=3.10.1 -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.10 -DPYTHON_LIBRARY:FILEPATH=/usr/lib/libpython3.10.so -DSKBUILD:INTERNAL=TRUE -DCMAKE_MODULE_PATH:PATH=/usr/lib/python3.10/site-packages/skbuild/resources/cmake -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9 -DCMAKE_BUILD_TYPE:STRING=Release -- The CXX compiler identification is GNU 11.1.0 -- The C compiler identification is GNU 11.1.0 -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Conan: Automatic detection of conan settings from cmake -- Conan: Settings= -s;build_type=Release;-s;compiler=gcc;-s;compiler.version=11;-s;compiler.libcxx=libstdc++11 -- Conan: checking conan executable -- Conan: Found program /usr/bin/conan -- Conan: Version found Conan version 1.43.0 -- Conan executing: /usr/bin/conan install . -s build_type=Release -s compiler=gcc -s compiler.version=11 -s compiler.libcxx=libstdc++11 -e=CONAN_CMAKE_PROGRAM=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake -g=cmake --build=missing Configuration: [settings] arch=x86_64 arch_build=x86_64 build_type=Release compiler=gcc compiler.libcxx=libstdc++11 compiler.version=11 os=Linux os_build=Linux [options] [build_requires] [env] CONAN_CMAKE_PROGRAM=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake conanfile.txt: Installing package Requirements fmt/6.2.1 from 'conancenter' - Cache muparserx/4.0.8 from 'conancenter' - Cache nlohmann_json/3.1.1 from 'conancenter' - Cache spdlog/1.5.0 from 'conancenter' - Cache Packages fmt/6.2.1:6557f18ca99c0b6a233f43db00e30efaa525e27e - Cache muparserx/4.0.8:6557f18ca99c0b6a233f43db00e30efaa525e27e - Cache nlohmann_json/3.1.1:5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9 - Cache spdlog/1.5.0:bf273214613ae9cd4f65a4be0b5f493fe5d66e2b - Cache Installing (downloading, building) binaries... fmt/6.2.1: Already installed! muparserx/4.0.8: Already installed! nlohmann_json/3.1.1: Already installed! spdlog/1.5.0: Already installed! conanfile.txt: Generator cmake created conanbuildinfo.cmake conanfile.txt: Generator txt created conanbuildinfo.txt conanfile.txt: Aggregating env generators conanfile.txt: Generated conaninfo.txt conanfile.txt: Generated graphinfo -- Conan: Loading conanbuildinfo.cmake -- Conan: Adjusting output directories -- Conan: Using cmake targets configuration -- Library spdlog found /home/gustavo/.conan/data/spdlog/1.5.0/_/_/package/bf273214613ae9cd4f65a4be0b5f493fe5d66e2b/lib/libspdlog.a -- Library muparserx found /home/gustavo/.conan/data/muparserx/4.0.8/_/_/package/6557f18ca99c0b6a233f43db00e30efaa525e27e/lib/libmuparserx.a -- Library fmt found /home/gustavo/.conan/data/fmt/6.2.1/_/_/package/6557f18ca99c0b6a233f43db00e30efaa525e27e/lib/libfmt.a -- Conan: Adjusting language standard -- Current conanbuildinfo.cmake directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build -- Conan: Compiler GCC&gt;=5, checking major version 11 -- Conan: Checking correct version: 11 -- Looking for OpenMP support... -- OpenMP found! -- OpenMP_CXX_FLAGS = -fopenmp -- OpenMP_EXE_LINKER_FLAGS = -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Looking for OpenBLAS library... -- OpenBLAS not found. Looking for any other BLAS &amp; Lapack libraries... -- Looking for sgemm_ -- Looking for sgemm_ - not found CMake Error at .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:230 (message): Could NOT find BLAS (missing: BLAS_LIBRARIES) Call Stack (most recent call first): .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:594 (_FPHSA_FAILURE_MESSAGE) .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindBLAS.cmake:1337 (find_package_handle_standard_args) CMakeLists.txt:222 (find_package) -- Configuring incomplete, errors occurred! See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build/CMakeFiles/CMakeOutput.log&quot;. See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build/CMakeFiles/CMakeError.log&quot;. Traceback (most recent call last): File &quot;/usr/lib/python3.10/site-packages/skbuild/setuptools_wrap.py&quot;, line 586, in setup env = cmkr.configure(cmake_args, File &quot;/usr/lib/python3.10/site-packages/skbuild/cmaker.py&quot;, line 237, in configure raise SKBuildError( An error occurred while configuring with CMake. Command: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 -G 'Unix Makefiles' -DCMAKE_INSTALL_PREFIX:PATH=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-install -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python -DPYTHON_VERSION_STRING:STRING=3.10.1 -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.10 -DPYTHON_LIBRARY:FILEPATH=/usr/lib/libpython3.10.so -DSKBUILD:INTERNAL=TRUE -DCMAKE_MODULE_PATH:PATH=/usr/lib/python3.10/site-packages/skbuild/resources/cmake -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9 -DCMAKE_BUILD_TYPE:STRING=Release Source directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 Working directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build Please see CMake's output for more information. ---------------------------------------- ERROR: Failed building wheel for qiskit-aer ERROR: Command errored out with exit status 1: command: /usr/bin/python -u -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;'; __file__='&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;';f = getattr(tokenize, '&quot;'&quot;'open'&quot;'&quot;', open)(__file__) if os.path.exists(__file__) else io.StringIO('&quot;'&quot;'from setuptools import setup; setup()'&quot;'&quot;');code = f.read().replace('&quot;'&quot;'\r\n'&quot;'&quot;', '&quot;'&quot;'\n'&quot;'&quot;');f.close();exec(compile(code, __file__, '&quot;'&quot;'exec'&quot;'&quot;'))' install --record /tmp/pip-record-zdzqufj0/install-record.txt --single-version-externally-managed --user --prefix= --compile --install-headers /home/gustavo/.local/include/python3.10/qiskit-aer cwd: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/ Complete output (201 lines): /home/gustavo/.local/lib/python3.10/site-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( /home/gustavo/.local/lib/python3.10/site-packages/setuptools/installer.py:27: SetuptoolsDeprecationWarning: setuptools.installer is deprecated. Requirements should be satisfied by a PEP 517 installer. warnings.warn( -------------------------------------------------------------------------------- -- Trying &quot;Ninja&quot; generator -------------------------------- --------------------------- ---------------------- ----------------- ------------ ------- -- Not searching for unused variables given on the command line. CMake Error: CMake was unable to find a build program corresponding to &quot;Ninja&quot;. CMAKE_MAKE_PROGRAM is not set. You probably need to select a different build tool. -- Configuring incomplete, errors occurred! See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_cmake_test_compile/build/CMakeFiles/CMakeOutput.log&quot;. -- ------- ------------ ----------------- ---------------------- --------------------------- -------------------------------- -- Trying &quot;Ninja&quot; generator - failure -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- -- Trying &quot;Unix Makefiles&quot; generator -------------------------------- --------------------------- ---------------------- ----------------- ------------ ------- -- Not searching for unused variables given on the command line. -- The C compiler identification is GNU 11.1.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- The CXX compiler identification is GNU 11.1.0 -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_cmake_test_compile/build -- ------- ------------ ----------------- ---------------------- --------------------------- -------------------------------- -- Trying &quot;Unix Makefiles&quot; generator - success -------------------------------------------------------------------------------- Configuring Project Working directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build Command: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 -G 'Unix Makefiles' -DCMAKE_INSTALL_PREFIX:PATH=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-install -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python -DPYTHON_VERSION_STRING:STRING=3.10.1 -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.10 -DPYTHON_LIBRARY:FILEPATH=/usr/lib/libpython3.10.so -DSKBUILD:INTERNAL=TRUE -DCMAKE_MODULE_PATH:PATH=/usr/lib/python3.10/site-packages/skbuild/resources/cmake -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9 -DCMAKE_BUILD_TYPE:STRING=Release -- The CXX compiler identification is GNU 11.1.0 -- The C compiler identification is GNU 11.1.0 -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Check for working CXX compiler: /usr/bin/c++ - skipped -- Detecting CXX compile features -- Detecting CXX compile features - done -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Performing Test flag_supported -- Performing Test flag_supported - Success -- Conan: Automatic detection of conan settings from cmake -- Conan: Settings= -s;build_type=Release;-s;compiler=gcc;-s;compiler.version=11;-s;compiler.libcxx=libstdc++11 -- Conan: checking conan executable -- Conan: Found program /usr/bin/conan -- Conan: Version found Conan version 1.43.0 -- Conan executing: /usr/bin/conan install . -s build_type=Release -s compiler=gcc -s compiler.version=11 -s compiler.libcxx=libstdc++11 -e=CONAN_CMAKE_PROGRAM=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake -g=cmake --build=missing Configuration: [settings] arch=x86_64 arch_build=x86_64 build_type=Release compiler=gcc compiler.libcxx=libstdc++11 compiler.version=11 os=Linux os_build=Linux [options] [build_requires] [env] CONAN_CMAKE_PROGRAM=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake conanfile.txt: Installing package Requirements fmt/6.2.1 from 'conancenter' - Cache muparserx/4.0.8 from 'conancenter' - Cache nlohmann_json/3.1.1 from 'conancenter' - Cache spdlog/1.5.0 from 'conancenter' - Cache Packages fmt/6.2.1:6557f18ca99c0b6a233f43db00e30efaa525e27e - Cache muparserx/4.0.8:6557f18ca99c0b6a233f43db00e30efaa525e27e - Cache nlohmann_json/3.1.1:5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9 - Cache spdlog/1.5.0:bf273214613ae9cd4f65a4be0b5f493fe5d66e2b - Cache Installing (downloading, building) binaries... fmt/6.2.1: Already installed! muparserx/4.0.8: Already installed! nlohmann_json/3.1.1: Already installed! spdlog/1.5.0: Already installed! conanfile.txt: Generator cmake created conanbuildinfo.cmake conanfile.txt: Generator txt created conanbuildinfo.txt conanfile.txt: Aggregating env generators conanfile.txt: Generated conaninfo.txt conanfile.txt: Generated graphinfo -- Conan: Loading conanbuildinfo.cmake -- Conan: Adjusting output directories -- Conan: Using cmake targets configuration -- Library spdlog found /home/gustavo/.conan/data/spdlog/1.5.0/_/_/package/bf273214613ae9cd4f65a4be0b5f493fe5d66e2b/lib/libspdlog.a -- Library muparserx found /home/gustavo/.conan/data/muparserx/4.0.8/_/_/package/6557f18ca99c0b6a233f43db00e30efaa525e27e/lib/libmuparserx.a -- Library fmt found /home/gustavo/.conan/data/fmt/6.2.1/_/_/package/6557f18ca99c0b6a233f43db00e30efaa525e27e/lib/libfmt.a -- Conan: Adjusting language standard -- Current conanbuildinfo.cmake directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build -- Conan: Compiler GCC&gt;=5, checking major version 11 -- Conan: Checking correct version: 11 -- Looking for OpenMP support... -- OpenMP found! -- OpenMP_CXX_FLAGS = -fopenmp -- OpenMP_EXE_LINKER_FLAGS = -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Looking for OpenBLAS library... -- OpenBLAS not found. Looking for any other BLAS &amp; Lapack libraries... -- Looking for sgemm_ -- Looking for sgemm_ - not found CMake Error at .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:230 (message): Could NOT find BLAS (missing: BLAS_LIBRARIES) Call Stack (most recent call first): .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindPackageHandleStandardArgs.cmake:594 (_FPHSA_FAILURE_MESSAGE) .eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/share/cmake-3.22/Modules/FindBLAS.cmake:1337 (find_package_handle_standard_args) CMakeLists.txt:222 (find_package) -- Configuring incomplete, errors occurred! See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build/CMakeFiles/CMakeOutput.log&quot;. See also &quot;/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build/CMakeFiles/CMakeError.log&quot;. Traceback (most recent call last): File &quot;/usr/lib/python3.10/site-packages/skbuild/setuptools_wrap.py&quot;, line 586, in setup env = cmkr.configure(cmake_args, File &quot;/usr/lib/python3.10/site-packages/skbuild/cmaker.py&quot;, line 237, in configure raise SKBuildError( An error occurred while configuring with CMake. Command: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/.eggs/cmake-3.22.1-py3.10-linux-x86_64.egg/cmake/data/bin/cmake /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 -G 'Unix Makefiles' -DCMAKE_INSTALL_PREFIX:PATH=/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-install -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python -DPYTHON_VERSION_STRING:STRING=3.10.1 -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.10 -DPYTHON_LIBRARY:FILEPATH=/usr/lib/libpython3.10.so -DSKBUILD:INTERNAL=TRUE -DCMAKE_MODULE_PATH:PATH=/usr/lib/python3.10/site-packages/skbuild/resources/cmake -DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9 -DCMAKE_BUILD_TYPE:STRING=Release Source directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29 Working directory: /tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/_skbuild/linux-x86_64-3.10/cmake-build Please see CMake's output for more information. ---------------------------------------- ERROR: Command errored out with exit status 1: /usr/bin/python -u -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;'; __file__='&quot;'&quot;'/tmp/pip-install-hdx4vhk7/qiskit-aer_a40dd1ec77a24f92ad7ab25442a2ee29/setup.py'&quot;'&quot;';f = getattr(tokenize, '&quot;'&quot;'open'&quot;'&quot;', open)(__file__) if os.path.exists(__file__) else io.StringIO('&quot;'&quot;'from setuptools import setup; setup()'&quot;'&quot;');code = f.read().replace('&quot;'&quot;'\r\n'&quot;'&quot;', '&quot;'&quot;'\n'&quot;'&quot;');f.close();exec(compile(code, __file__, '&quot;'&quot;'exec'&quot;'&quot;'))' install --record /tmp/pip-record-zdzqufj0/install-record.txt --single-version-externally-managed --user --prefix= --compile --install-headers /home/gustavo/.local/include/python3.10/qiskit-aer Check the logs for full command output.````",<python><linux><qiskit>,12/17/2021 13:58,,,,
70411614.0,Place value notation in quantum computing?,"How do quantum computers store numbers in place value systems? Do they use the binary system, like traditional computation does?",<binary><numbers><computation><quantum-computing>,12/19/2021 12:57,,,,
70429641.0,How to create a new Q# Project in VSCode,"I am trying to figure out how to start writing code using Microsoft Q# and QDK, but am running into a lot of issues as there aren't any good documents that help you set up projects from scratch. I tried running dotnet new console and that created a Program.cs file, which for Q# needs to be Program.qs, I tried simply changing the name of that file but it gave this error: CSC : error CS5001: Program does not contain a static 'Main' method suitable for an entry point Does anyone know how to setup a Q# project from scratch in VS Code? I am really struggling with this",<c#><visual-studio-code><quantum-computing><q#>,12/21/2021 1:08,,,,
70450944.0,H5py Driver Issue on Qiskit Nature Drivers,"While using the IBM Quantum experience, whenever I want to install any driver an error with the h5py appears. Specifically, the error is &quot;Using default_file_mode other than 'r' is no longer supported. Pass the mode to h5py.File() instead.&quot; Does anyone have any solutions to it (not sure which version to revert back to). Thanks!!",<python-3.x><h5py><qiskit>,12/22/2021 14:53,,,,
70550877.0,"Plotting Bloch Vectors in Qiskit: "" 'Arrow3D' object has no attribute '_path2d' ""","I am working through the Qiskit tutorial textbook, and in Section 1.4 ('Single Qubit Gates'), I can't seem to plot vectors on the Bloch Sphere. I am using Google Colab and am importing as: !pip install qiskit !pip install qiskit[visualization] from qiskit import QuantumCircuit, assemble, Aer from math import pi, sqrt from qiskit.visualization import plot_bloch_multivector, plot_histogram sim = Aer.get_backend('aer_simulator') and then the following code is taken directly from the textbook: qc = QuantumCircuit(1) qc.x(0) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result().get_statevector() plot_bloch_multivector(state) Yet doing this gives the error: &quot; 'Arrow3D' object has no attribute '_path2d' &quot;. Any help would be greatly appreciated. Edit: Adding a line plt.show() no longer brings up an error message, but still no image shows.",<python><quantum-computing><qiskit>,01/01/2022 18:16,,,,
70824777.0,Defining a non-commutative algebra,"I'm new to Mathematica, and I'm trying to learn the ropes. I'm trying to write a little boson algebra engine, with basic useful functions such as non-commutative algebra, normal-ordering and vacuum expectation values. So, for starters I define the following OpProd[] function, OpProd[a_ + b_, c_] := OpProd[a, c] + OpProd[b, c]; OpProd[a_, b_ + c_] := OpProd[a, b] + OpProd[a, c]; OpProd[c_, a_] := c a /; NumericQ[c] == True; OpProd[left__, a_, b_] = OpProd[left, OpProd[a, b]]; which simply defines the basic properties of the algebra, and seems to work fine. My problem is that I'd like to have an alias for OpProd[], so that whenever I write a^ b^ c^, or any string like that, Mathematica would use OpProd[] to implement the product. (*Shorthand notation for operator products*) Unprotect[Times]; \!\(\*OverscriptBox[\(a__\), \(^\)]\) \!\(\*OverscriptBox[\(b__\), \(^\)]\) := OpProd[a, b]; Protect[Times]; This unfortunately does not seem to work, outputting just In[10]:= \!\(\*OverscriptBox[\(a\), \(^\)]\) \!\(\*OverscriptBox[\(b\), \(^\)]\) \!\(\*OverscriptBox[\(c\), \(^\)]\) \!\(\*OverscriptBox[\(d\), \(^\)]\) \!\(\*OverscriptBox[\(e\), \(^\)]\) // Simplify Out[10]= OpProd[a, b] OpProd[c, d] \!\(\*OverscriptBox[\(e\), \(^\)]\) Any help would be appreciated!",<wolfram-mathematica><quantum-computing>,1/23/2022 17:34,,,,
70924577.0,DLL load failed while importing _tweedledum,"I need to use Qiskit library, but I have issue with importing qiskit itself. I have Python 3.8.10 installed on Windiws 10 While I run import, I have follow error: c:\repos\quantml&gt;py -0 Installed Pythons found by py Launcher for Windows -3.8-64 * c:\repos\quantml&gt;py Python 3.8.10 (tags/v3.8.10:3d8993a, May 3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; import qiskit Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;C:\Users\psheom\AppData\Local\Programs\Python\Python38\lib\site-packages\qiskit\__init__.py&quot;, line 25, in &lt;module&gt; from qiskit.circuit import ClassicalRegister File &quot;C:\Users\psheom\AppData\Local\Programs\Python\Python38\lib\site-packages\qiskit\circuit\__init__.py&quot;, line 244, in &lt;module&gt; from .classicalfunction.types import Int1, Int2 File &quot;C:\Users\psheom\AppData\Local\Programs\Python\Python38\lib\site-packages\qiskit\circuit\classicalfunction\__init__.py&quot;, line 98, in &lt;module&gt; from .classicalfunction import ClassicalFunction File &quot;C:\Users\psheom\AppData\Local\Programs\Python\Python38\lib\site-packages\qiskit\circuit\classicalfunction\classicalfunction.py&quot;, line 18, in &lt;module&gt; from tweedledum.classical import simulate File &quot;C:\Users\psheom\AppData\Local\Programs\Python\Python38\lib\site-packages\tweedledum\__init__.py&quot;, line 5, in &lt;module&gt; from ._tweedledum import * ImportError: DLL load failed while importing _tweedledum: ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð¼Ð¾Ð´ÑÐ»Ñ. &gt;&gt;&gt; ^Z This is log of pip install: Collecting qiskit Using cached qiskit-0.34.1.tar.gz (13 kB) Preparing metadata (setup.py) ... done Collecting qiskit-terra==0.19.1 Downloading qiskit_terra-0.19.1-cp38-cp38-win_amd64.whl (5.6 MB) ---------------------------------------- 5.6/5.6 MB 13.8 MB/s eta 0:00:00 Collecting qiskit-aer==0.10.2 Downloading qiskit_aer-0.10.2-cp38-cp38-win_amd64.whl (24.2 MB) ---------------------------------------- 24.2/24.2 MB 43.6 MB/s eta 0:00:00 Collecting qiskit-ibmq-provider==0.18.3 Using cached qiskit_ibmq_provider-0.18.3-py3-none-any.whl (238 kB) Collecting qiskit-ignis==0.7.0 Using cached qiskit_ignis-0.7.0-py3-none-any.whl (200 kB) Requirement already satisfied: scipy&gt;=1.0 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-aer==0.10.2-&gt;qiskit) (1.7.3) Requirement already satisfied: numpy&gt;=1.16.3 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-aer==0.10.2-&gt;qiskit) (1.22.1) Requirement already satisfied: requests&gt;=2.19 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2.27.1) Requirement already satisfied: urllib3&gt;=1.21.1 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-ibmq-provider==0.18.3-&gt;qiskit) (1.26.8) Requirement already satisfied: websocket-client&gt;=1.0.1 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-ibmq-provider==0.18.3-&gt;qiskit) (1.2.3) Requirement already satisfied: python-dateutil&gt;=2.8.0 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2.8.2) Collecting requests-ntlm&gt;=1.1.0 Using cached requests_ntlm-1.1.0-py2.py3-none-any.whl (5.7 kB) Requirement already satisfied: setuptools&gt;=40.1.0 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from qiskit-ignis==0.7.0-&gt;qiskit) (56.0.0) Collecting retworkx&gt;=0.8.0 Downloading retworkx-0.11.0-cp38-cp38-win_amd64.whl (1.2 MB) ---------------------------------------- 1.2/1.2 MB 37.5 MB/s eta 0:00:00 Collecting stevedore&gt;=3.0.0 Using cached stevedore-3.5.0-py3-none-any.whl (49 kB) Collecting tweedledum&lt;2.0,&gt;=1.1 Downloading tweedledum-1.1.1-cp38-cp38-win_amd64.whl (1.1 MB) ---------------------------------------- 1.1/1.1 MB 66.1 MB/s eta 0:00:00 Collecting ply&gt;=3.10 Using cached ply-3.11-py2.py3-none-any.whl (49 kB) Collecting psutil&gt;=5 Downloading psutil-5.9.0-cp38-cp38-win_amd64.whl (246 kB) ---------------------------------------- 246.5/246.5 KB ? eta 0:00:00 Collecting sympy&gt;=1.3 Using cached sympy-1.9-py3-none-any.whl (6.2 MB) Collecting dill&gt;=0.3 Using cached dill-0.3.4-py2.py3-none-any.whl (86 kB) Collecting python-constraint&gt;=1.4 Using cached python-constraint-1.4.0.tar.bz2 (18 kB) Preparing metadata (setup.py) ... done Requirement already satisfied: six&gt;=1.5 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from python-dateutil&gt;=2.8.0-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (1.16.0) Requirement already satisfied: certifi&gt;=2017.4.17 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from requests&gt;=2.19-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2021.10.8) Requirement already satisfied: charset-normalizer~=2.0.0 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from requests&gt;=2.19-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2.0.11) Requirement already satisfied: idna&lt;4,&gt;=2.5 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from requests&gt;=2.19-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2.10) Collecting cryptography&gt;=1.3 Using cached cryptography-36.0.1-cp36-abi3-win_amd64.whl (2.2 MB) Collecting ntlm-auth&gt;=1.0.2 Using cached ntlm_auth-1.5.0-py2.py3-none-any.whl (29 kB) Collecting pbr!=2.1.0,&gt;=2.0.0 Using cached pbr-5.8.0-py2.py3-none-any.whl (112 kB) Collecting mpmath&gt;=0.19 Using cached mpmath-1.2.1-py3-none-any.whl (532 kB) Requirement already satisfied: cffi&gt;=1.12 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from cryptography&gt;=1.3-&gt;requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (1.15.0) Requirement already satisfied: pycparser in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from cffi&gt;=1.12-&gt;cryptography&gt;=1.3-&gt;requests-ntlm&gt;=1.1.0-&gt;qiskit-ibmq-provider==0.18.3-&gt;qiskit) (2.21) Building wheels for collected packages: qiskit, python-constraint Building wheel for qiskit (setup.py) ... done Created wheel for qiskit: filename=qiskit-0.34.1-py3-none-any.whl size=11754 sha256=e9b4a0e9fc197867c9f52eb6258afe2938de7d67824ffd71fc21ade5e7a0b387 Stored in directory: c:\users\psheom\appdata\local\pip\cache\wheels\9f\f8\19\dacc191256a3d7dc26aec784e0293340351285b7123d23703d Building wheel for python-constraint (setup.py) ... done Created wheel for python-constraint: filename=python_constraint-1.4.0-py2.py3-none-any.whl size=24081 sha256=4658eabe616621c3e0fdfcacd5ce5c3f557f1106c2ed0bc044a6d5ef503e26b1 Stored in directory: c:\users\psheom\appdata\local\pip\cache\wheels\86\ba\5c\4e9115777de42c6a2e1ca77ef7c9d0d479254c5080341b55c5 Successfully built qiskit python-constraint Installing collected packages: python-constraint, ply, mpmath, tweedledum, sympy, retworkx, psutil, pbr, ntlm-auth, dill, stevedore, cryptography, requests-ntlm, qiskit-terra, qiskit-ignis, qiskit-ibmq-provider, qiskit-aer, qiskit Successfully installed cryptography-36.0.1 dill-0.3.4 mpmath-1.2.1 ntlm-auth-1.5.0 pbr-5.8.0 ply-3.11 psutil-5.9.0 python-constraint-1.4.0 qiskit-0.34.1 qiskit-aer-0.10.2 qiskit-ibmq-provider-0.18.3 qiskit-ignis-0.7.0 qiskit-terra-0.19.1 requests-ntlm-1.1.0 retworkx-0.11.0 stevedore-3.5.0 sympy-1.9 tweedledum-1.1.1 Collecting matplotlib Downloading matplotlib-3.5.1-cp38-cp38-win_amd64.whl (7.2 MB) ---------------------------------------- 7.2/7.2 MB 17.1 MB/s eta 0:00:00 Collecting pillow&gt;=6.2.0 Downloading Pillow-9.0.0-cp38-cp38-win_amd64.whl (3.2 MB) ---------------------------------------- 3.2/3.2 MB 34.1 MB/s eta 0:00:00 Requirement already satisfied: pyparsing&gt;=2.2.1 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from matplotlib) (3.0.7) Collecting fonttools&gt;=4.22.0 Downloading fonttools-4.29.0-py3-none-any.whl (895 kB) ---------------------------------------- 895.0/895.0 KB 55.3 MB/s eta 0:00:00 Requirement already satisfied: numpy&gt;=1.17 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from matplotlib) (1.22.1) Collecting kiwisolver&gt;=1.0.1 Downloading kiwisolver-1.3.2-cp38-cp38-win_amd64.whl (52 kB) ---------------------------------------- 52.1/52.1 KB ? eta 0:00:00 Collecting cycler&gt;=0.10 Using cached cycler-0.11.0-py3-none-any.whl (6.4 kB) Requirement already satisfied: packaging&gt;=20.0 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from matplotlib) (21.3) Requirement already satisfied: python-dateutil&gt;=2.7 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from matplotlib) (2.8.2) Requirement already satisfied: six&gt;=1.5 in c:\users\psheom\appdata\local\programs\python\python38\lib\site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.16.0) Installing collected packages: pillow, kiwisolver, fonttools, cycler, matplotlib Successfully installed cycler-0.11.0 fonttools-4.29.0 kiwisolver-1.3.2 matplotlib-3.5.1 pillow-9.0.0",<python-3.x><windows-7><qiskit>,1/31/2022 10:40,,,,
71309024.0,"Pytorch loss.backward() gives none grad for parameters of Rx, Ry Gate","I'm trying to train parameters params by performing linear Transformation on an input tensor x by matrix multiplying Rx to input followed by Ry matrix to their result. (each matrix Rx and Ry have a parameter params[i] each that define the matrix). then I calculate loss by mse of y and the predicted output. when I do loss.backward() Im getting params.grad as None. import torch def get_device(gpu_no): if torch.cuda.is_available(): return torch.device('cuda', gpu_no) else: return torch.device('cpu') device = get_device(0) params = torch.tensor(([[0.011], [0.012]]), requires_grad=True).to(device).to(torch.cfloat) x_gate = torch.tensor([[1., 0.], [0., 1.]]).to(device) y_gate = torch.tensor(([[0, -1j], [1j, 0]])).to(device) def rx(theta): # co = torch.cos(theta / 2) # si = torch.sin(theta / 2) # Rx_gate = torch.stack([torch.cat([co, -si], dim=-1), # torch.cat([-si, co], dim=-1)], dim=-2).squeeze(0).to(device).to(torch.cfloat).requires_grad_() # Rx_gate = torch.exp(-1j * (theta / 2) * x_gate).to(device).to(torch.cfloat).requires_grad_() Rx_gate = torch.tensor(([[torch.cos(theta/2), -torch.sin(theta/2)], [-torch.sin(theta/2), torch.cos(theta/2)]]), requires_grad=True).to(device).to(torch.cfloat) return Rx_gate def ry(theta): # co = torch.cos(theta / 2) # si = torch.sin(theta / 2) # Ry_gate = torch.stack([torch.cat([co, -si]), # torch.cat([si, co])], dim=-2).squeeze(0).to(device).to(torch.cfloat).requires_grad_() # Ry_gate = torch.exp(-1j * (theta / 2) * y_gate).to(device).to(torch.cfloat).requires_grad_() Ry_gate = torch.tensor(([[torch.cos(theta / 2), -torch.sin(theta / 2)], [torch.sin(theta / 2), torch.cos(theta / 2)]]), requires_grad=True).to(device).to(torch.cfloat) return Ry_gate x = torch.tensor([1., 0.]).to(device).to(torch.cfloat) y = torch.tensor([0., 1.]).to(device).to(torch.cfloat) def pred(params): out = rx(params[0]) @ x out = ry(params[1]) @ out return out print(&quot;params :&quot;, params) print(&quot;prediction :&quot;, pred(params)) loss = torch.pow((y - pred(params)), 2).sum() print(&quot;loss :&quot;, loss) loss.backward() print(&quot;loss grad :&quot;, loss.grad) print(&quot;params grad :&quot;, params.grad) my output is params : tensor([[0.0110+0.j], [0.0120+0.j]], device='cuda:0', grad_fn=&lt;ToCopyBackward0&gt;) prediction : tensor([1.0000e+00+0.j, 5.0000e-04+0.j], device='cuda:0', grad_fn=&lt;MvBackward0&gt;) loss : tensor(1.9990+1.7485e-07j, device='cuda:0', grad_fn=&lt;SumBackward0&gt;) loss grad : None params grad : None why grad is none even though params has grad_fn=&lt;ToCopyBackward0&gt;. Also i get this warning: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won't be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at aten\src\ATen/core/TensorBody.h:417.) return self._grad",<python><pytorch><qml><quantum-computing><autograd>,03/01/2022 13:13,,,,
71456850.0,DQCPError: The problem is not DQCP. while implementing a QSVM in IBM Quantum Experience,"I was trying to execute the following code in IBM QE (implementing a QSVM based classifier) feature_dim = 2 feature_map = ZZFeatureMap(feature_dimension=feature_dim, reps=2, entanglement='linear') qsvm = QSVM(feature_map, training_input, test_input) backend = BasicAer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=seed, seed_transpiler=seed) result = qsvm.run(quantum_instance) print(f'Testing success ratio: {result[&quot;testing_accuracy&quot;]}') I get the following error : Traceback (most recent call last): Input In [18] in &lt;cell line: 8&gt; result = qsvm.run(quantum_instance) File /opt/conda/lib/python3.8/site-packages/qiskit/aqua/algorithms/quantum_algorithm.py:71 in run return self._run() File /opt/conda/lib/python3.8/site-packages/qiskit/aqua/algorithms/classifiers/qsvm/qsvm.py:476 in _run return self.instance.run() File /opt/conda/lib/python3.8/site-packages/qiskit/aqua/algorithms/classifiers/qsvm/_qsvm_binary.py:135 in run self.train(self._qalgo.training_dataset[0], self._qalgo.training_dataset[1]) File /opt/conda/lib/python3.8/site-packages/qiskit/aqua/algorithms/classifiers/qsvm/_qsvm_binary.py:82 in train [alpha, b, support] = optimize_svm(kernel_matrix, labels, scaling=scaling, lambda2=lambda2) File /opt/conda/lib/python3.8/site-packages/qiskit/aqua/utils/qp_solver.py:93 in optimize_svm prob.solve(verbose=show_progress, qcp=True) File /opt/conda/lib/python3.8/site-packages/cvxpy/problems/problem.py:473 in solve return solve_func(self, *args, **kwargs) File /opt/conda/lib/python3.8/site-packages/cvxpy/problems/problem.py:945 in _solve raise error.DQCPError(&quot;The problem is not DQCP.&quot;) DQCPError: The problem is not DQCP. Use %tb to get the full traceback. Is this because of deprecated packages like in the case of aqua, also the qiskit tutorials on QSVMs (both binary and multi-classifier ) are missing. Could someone help me out ? Much thanks",<python><anaconda><svm><quantum-computing><qiskit>,3/13/2022 12:41,,,,
71768097.0,"Qiskit QAOA compile error , EvolvedOp object has no attribute 'broadcast_arguments","Nowadays, I am studying quantum computing. when I did follow this code, I got an error. I don't know why I got this error. I just searched to solve this problem. In the below, the MinimumEigenOptimizer.solve() input is QuadraticProgram. MinimumEigenOptimizer.solve(problem) The parameter of the function, MinimumEigenOptimizer.solve(), is QuadraticProgram. In the below code, I followed the rule of the parameter. # generate qiskit's cost function qiskit_cost_function = QuadraticProgram() The error is: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) C:\Users\Public\Documents\ESTsoft\CreatorTemp/ipykernel_12164/1668192560.py in &lt;module&gt; 8 results = [] 9 # solve quadratic program ---&gt; 10 result = optimizer_qaoa.solve(qiskit_cost_function) 11 print(result) 12 ~\anaconda3\lib\site-packages\qiskit\optimization\algorithms\minimum_eigen_optimizer.py in solve(self, problem) 194 195 # approximate ground state of operator using min eigen solver --&gt; 196 eigen_result = self._min_eigen_solver.compute_minimum_eigenvalue(operator) 197 198 # analyze results ~\anaconda3\lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py in compute_minimum_eigenvalue(self, operator, aux_operators) 495 # this sets the size of the ansatz, so it must be called before the initial point 496 # validation --&gt; 497 self._check_operator_ansatz(operator) 498 499 # set an expectation for this algorithm run (will be reset to None at the end) ~\anaconda3\lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\qaoa.py in _check_operator_ansatz(self, operator) 131 if operator != self._cost_operator: 132 self._cost_operator = operator --&gt; 133 self.ansatz = QAOAAnsatz( 134 operator, self._reps, initial_state=self._initial_state, mixer_operator=self._mixer 135 ).decompose() # TODO remove decompose once #6674 is fixed ~\anaconda3\lib\site-packages\qiskit\circuit\library\blueprintcircuit.py in decompose(self, gates_to_decompose) 100 def decompose(self, gates_to_decompose=None): 101 if self._data is None: --&gt; 102 self._build() 103 return super().decompose(gates_to_decompose) 104 ~\anaconda3\lib\site-packages\qiskit\circuit\library\n_local\qaoa_ansatz.py in _build(self) 257 return 258 --&gt; 259 super()._build() 260 261 # keep old parameter order: first cost operator, then mixer operators ~\anaconda3\lib\site-packages\qiskit\circuit\library\evolved_operator_ansatz.py in _build(self) 172 173 evolved_op = self.evolution.convert((coeff * op).exp_i()).reduce() --&gt; 174 circuits.append(evolved_op.to_circuit()) 175 176 self.rotation_blocks = [] ~\anaconda3\lib\site-packages\qiskit\aqua\operators\primitive_ops\primitive_op.py in to_circuit(self) 259 &quot;&quot;&quot; Returns a ``QuantumCircuit`` equivalent to this Operator. &quot;&quot;&quot; 260 qc = QuantumCircuit(self.num_qubits) --&gt; 261 qc.append(self.to_instruction(), qargs=range(self.primitive.num_qubits)) # type: ignore 262 return qc.decompose() 263 ~\anaconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py in append(self, instruction, qargs, cargs) 1228 requester = self._resolve_classical_resource 1229 instructions = InstructionSet(resource_requester=requester) -&gt; 1230 for qarg, carg in instruction.broadcast_arguments(expanded_qargs, expanded_cargs): 1231 instructions.add(appender(instruction, qarg, carg), qarg, carg) 1232 return instructions AttributeError: 'EvolvedOp' object has no attribute 'broadcast_arguments' Could you give me a hand? help me please!! I am very very beginner.",<python><qiskit>,04/06/2022 13:55,,,,
71818251.0,ValueError: setting an array element with a sequence for scikit learn,"I am trying to implement Quantum Kernel Ridge Regression (replacing the classical kernel with quantum kernel) in qiskit. The shape of my input x is (7165 x 529) and due to reshaping errors, I added an extra column with zeroes to make it (7165 x 530) and shape of y is (7165,). I was able to implement the classical KRR but when I am trying to replace the kernel with the quantum counterpart, I am getting the mentioned error. x and y: 2 (7165, 530) [[36.858105 2.9076326 2.907612 ... 0. 0. 0. ] [36.858105 12.599944 2.9019997 ... 0. 0. 0. ] [36.858105 14.261827 1.503703 ... 0. 0. 0. ] ... [36.858105 8.569991 13.293801 ... 0. 0. 0. ] [36.858105 12.540301 8.026131 ... 0. 0. 0. ] [36.858105 12.629306 12.609996 ... 0. 0. 0. ]] 1 (7165,) [ -417.96 -712.42 -564.21 ... -1662.1 -1782.01 -1919. ] Code: data_feature_map = ZZFeatureMap(feature_dimension= 2, reps=2, entanglement=&quot;linear&quot;) data_backend = QuantumInstance( BasicAer.get_backend(&quot;qasm_simulator&quot;), shots=1024, seed_simulator=seed, seed_transpiler=seed ) data_kernel = QuantumKernel(feature_map=data_feature_map, quantum_instance=data_backend) quantum_kernel = KernelRidge(kernel=data_kernel.evaluate) quantum_kernel.fit(x_train, y_train) predictions = quantum_kernel.predict(x_test) score = quantum_kernel.score(x_test,y_test) rmse = math.sqrt(mean_squared_error(y_test, predictions)) print('Kernel Ridge Regression Score: %.1f' % score) print('############################') print('Root Mean Squared Error: %.1f' % rmse) Error: TypeError Traceback (most recent call last) TypeError: only size-1 arrays can be converted to Python scalars The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last) Input In [74], in &lt;cell line: 2&gt;() 1 quantum_kernel = KernelRidge(kernel=data_kernel.evaluate) ----&gt; 2 quantum_kernel.fit(x_train, y_train) 4 predictions = quantum_kernel.predict(x_test) 6 score = quantum_kernel.score(x_test,y_test) File /opt/conda/lib/python3.8/site-packages/sklearn/kernel_ridge.py:197, in KernelRidge.fit(self, X, y, sample_weight) 194 if sample_weight is not None and not isinstance(sample_weight, float): 195 sample_weight = _check_sample_weight(sample_weight, X) --&gt; 197 K = self._get_kernel(X) 198 alpha = np.atleast_1d(self.alpha) 200 ravel = False File /opt/conda/lib/python3.8/site-packages/sklearn/kernel_ridge.py:155, in KernelRidge._get_kernel(self, X, Y) 153 else: 154 params = {&quot;gamma&quot;: self.gamma, &quot;degree&quot;: self.degree, &quot;coef0&quot;: self.coef0} --&gt; 155 return pairwise_kernels(X, Y, metric=self.kernel, filter_params=True, **params) File /opt/conda/lib/python3.8/site-packages/sklearn/metrics/pairwise.py:2053, in pairwise_kernels(X, Y, metric, filter_params, n_jobs, **kwds) 2050 else: 2051 raise ValueError(&quot;Unknown kernel %r&quot; % metric) -&gt; 2053 return _parallel_pairwise(X, Y, func, n_jobs, **kwds) File /opt/conda/lib/python3.8/site-packages/sklearn/metrics/pairwise.py:1430, in _parallel_pairwise(X, Y, func, n_jobs, **kwds) 1427 X, Y, dtype = _return_float_dtype(X, Y) 1429 if effective_n_jobs(n_jobs) == 1: -&gt; 1430 return func(X, Y, **kwds) 1432 # enforce a threading backend to prevent data communication overhead 1433 fd = delayed(_dist_wrapper) File /opt/conda/lib/python3.8/site-packages/sklearn/metrics/pairwise.py:1457, in _pairwise_callable(X, Y, metric, force_all_finite, **kwds) 1455 iterator = itertools.combinations(range(X.shape[0]), 2) 1456 for i, j in iterator: -&gt; 1457 out[i, j] = metric(X[i], Y[j], **kwds) 1459 # Make symmetric 1460 # NB: out += out.T will produce incorrect results 1461 out = out + out.T ValueError: setting an array element with a sequence. I am aware that this is caused by ill formed input but after trying all the possible suggestions online, I still am not able to figure out the problem. Any help would be appreciated !",<python><tensorflow><machine-learning><scikit-learn><qiskit>,04/10/2022 15:56,,,,
72318926.0,ImportError: cannot import name '_compat' from 'cirq' (unknown location),"I am trying to import the module tensorflow_quantum as follows &gt;&gt;&gt; import tensorflow_quantum as tfq But, I get the following error. Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/opt/conda/lib/python3.8/site-packages/tensorflow_quantum/__init__.py&quot;, line 18, in &lt;module&gt; from tensorflow_quantum.core import (append_circuit, get_expectation_op, File &quot;/opt/conda/lib/python3.8/site-packages/tensorflow_quantum/core/__init__.py&quot;, line 17, in &lt;module&gt; from tensorflow_quantum.core.ops import (get_expectation_op, File &quot;/opt/conda/lib/python3.8/site-packages/tensorflow_quantum/core/ops/__init__.py&quot;, line 18, in &lt;module&gt; from tensorflow_quantum.core.ops.circuit_execution_ops import ( File &quot;/opt/conda/lib/python3.8/site-packages/tensorflow_quantum/core/ops/circuit_execution_ops.py&quot;, line 20, in &lt;module&gt; from tensorflow_quantum.core.ops import (cirq_ops, tfq_simulate_ops, File &quot;/opt/conda/lib/python3.8/site-packages/tensorflow_quantum/core/ops/cirq_ops.py&quot;, line 22, in &lt;module&gt; import cirq_google File &quot;/opt/conda/lib/python3.8/site-packages/cirq_google/__init__.py&quot;, line 18, in &lt;module&gt; from cirq import _compat ImportError: cannot import name '_compat' from 'cirq' (unknown location) I have already installed cirq. It works as follows &gt;&gt;&gt; import cirq &gt;&gt;&gt; Any help please?",<python-3.x><jupyter-notebook><tensorflow-quantum>,5/20/2022 12:26,,,,
72319342.0,AttributeError: module 'cirq' has no attribute 'GridQubit',"I tried the following code in nvidia-dgx2 machine. import cirq # Pick a qubit. qubit = cirq.GridQubit(0, 0) # Create a circuit circuit = cirq.Circuit( cirq.X(qubit)**0.5, # Square root of NOT. cirq.measure(qubit, key='m') # Measurement. ) print(&quot;Circuit:&quot;) print(circuit) # Simulate the circuit several times. simulator = cirq.Simulator() result = simulator.run(circuit, repetitions=20) print(&quot;Results:&quot;) print(result) But, I get the attribute error. --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) /tmp/ipykernel_36197/3759634386.py in &lt;module&gt; 2 3 # Pick a qubit. ----&gt; 4 qubit = cirq.GridQubit(0, 0) 5 6 # Create a circuit AttributeError: module 'cirq' has no attribute 'GridQubit' Any solution to this issue?",<python-3.x><tensorflow-quantum>,5/20/2022 12:59,,,,
72529281.0,QKD BB84 protocol: Is confirmation of the qubit possible? Or does the two generals problem apply?,"In the Quantum Key Distribution protocol BB84, Alice sends x qubits to Bob. There is no acknowledgement of receipt. This cannot be done over the quantum channel. If I need an acknowledgement, it must be sent via a classical channel. But that means that I am sending two messages independently of each other, which brings us to the two generals problem. Do I understand this correctly? Or am I missing something that could help me confirm the transmission similarly to TCP?",<quantum-computing>,06/07/2022 09:59,,,,
72592774.0,How does the Z-Gate in sympy.physics.quantum.gate excatly work?,"If I run the following Python script: from sympy.physics.quantum import qapply from sympy.physics.quantum.qubit import Qubit from sympy.physics.quantum.gate import X, Z, ZGate print(&quot;1a) Z(0)*Qubit('0')={0}&quot;.format(qapply(Z(0)*Qubit('0')))) print(&quot;1b) Z(0)*Qubit('1')={0}\n&quot;.format(qapply(Z(0)*Qubit('1')))) print(&quot;2a) Z(0)*Qubit('00')={0}&quot;.format(qapply(Z(0)*Qubit('00')))) print(&quot;2b) Z(0)*Qubit('01')={0}&quot;.format(qapply(Z(0)*Qubit('01')))) print(&quot;2c) Z(0)*Qubit('10')={0}&quot;.format(qapply(Z(0)*Qubit('10')))) print(&quot;2d) Z(0)*Qubit('11')={0}&quot;.format(qapply(Z(0)*Qubit('11')))) print(&quot;2e) Z(1)*Qubit('00')={0}&quot;.format(qapply(Z(1)*Qubit('00')))) print(&quot;2f) Z(1)*Qubit('01')={0}&quot;.format(qapply(Z(1)*Qubit('01')))) print(&quot;2g) Z(1)*Qubit('10')={0}&quot;.format(qapply(Z(1)*Qubit('10')))) print(&quot;2h) Z(1)*Qubit('11')={0}&quot;.format(qapply(Z(1)*Qubit('11')))) I get the following output: 1a) Z(0)*Qubit('0')=|0&gt; 1b) Z(0)*Qubit('1')=-|1&gt; 2a) Z(0)*Qubit('00')=|00&gt; 2b) Z(0)*Qubit('01')=-|01&gt; 2c) Z(0)*Qubit('10')=|10&gt; 2d) Z(0)*Qubit('11')=-|11&gt; 2e) Z(1)*Qubit('00')=|00&gt; 2f) Z(1)*Qubit('01')=|01&gt; 2g) Z(1)*Qubit('10')=-|10&gt; 2h) Z(1)*Qubit('11')=-|11&gt; The ouput in line 1a) and 1b) are correct as my opinion is concerned but line 2b), 2c), 2f) and 2g) are wrong. Where is the problem? Any help is welcome. Kind regards Klaus",<sympy><quantum-computing>,06/12/2022 13:46,,,,
72750858.0,Moving states inside a tensor (QuTip),"I have a qutip tensor as follows: psi = constants*tensor(fock(N,0),fock(N,1),fock(N,2)) I need a way to swap the positions of the third state with the second state such that the structure becomes: psi = (some operation on psi) psi = constants*tensor(fock(N,0),fock(N,2),fock(N,1)) I need it to maintain the ket nature of psi, any help is appreciated.",<python><qutip>,6/25/2022 2:20,,,,
72751841.0,Chaquopy fails to install qiskit,"Hello I am trying to build an app with Chaquopy(12.0.0) and qiskit(0.34.2). The gradle sync is happening fine. But when I go and build the app and install it on my phone. it give error for the qiskit package as ERROR: Command errored out with exit status 1:. The other package are installing fine, and the app is running, with other python function being called, just qiskit is giving problem. I tried to used python 3.8, but gives the same error, my current python version is 3.9 gradle version(8.0) Here's my gradle file python { buildPython &quot;C:/Program Files/python/python3.8/python.exe&quot; pip { // A requirement specifier, with or without a version number: install &quot;numpy&quot; install &quot;qiskit==0.36.2&quot; install &quot;matplotlib&quot; } } here is the python file I am using from qiskit import * from qiskit.tools.visualization import plot_histogram from qiskit.tools.visualization import plot_state_qsphere from qiskit.tools.visualization import plot_bloch_multivector def bv(num): return &quot;test return&quot;",<python><android><quantum-computing><qiskit><chaquopy>,6/25/2022 6:51,,,,
73169948.0,Prove bases are orthonormal,"How are the bases 1/sqrt(2)(1, i) and 1/sqrt(2)(1, -i) orthonormal? I know for a basis to be orthonormal it must have a dot product of zero and a norm of 1. Yet, while the dot product of these two vectors is 1, my textbook lists these bases as orthonormal.",<quantum-computing>,7/29/2022 19:01,,,,
73272446.0,Calculate an Qobjevo operator of qutip,"I define a time-dependent operator in the form of an Qobjevo and pass it to sesolve() to solve for Schrodinger's equation. Below is an MWE. from qutip import * import numpy as np tlist = np.linspace(0, np.pi / 2) H = [ sigmaz(), [sigmax(), 'cos(t)'] ] psi0 = basis(2, 1) result = sesolve(H, psi0, tlist) Now I want to check the time-dependent Hamiltonian at given times in tlist. How do I get a list of Hamiltonians, each at time tlist[i]? Which qutip function can I refer to?",<python><quantum-computing><qutip>,08/08/2022 02:37,,,,
73333072.0,how to find identical bitposition in a string in python,"create a circuit of 5 qubits qr = QuantumRegister(5, &quot;qr&quot;) # quantum bit register cr = ClassicalRegister(5, &quot;cr&quot;) # classical bit register circuit = QuantumCircuit(qr, cr) # all qubits in superposition (50%:50% chance to be in |0&gt; or |1&gt;) and independent of each other #The circuit is a superposition of 5 qubits. circuit.h(qr) circuit.h(qr) circuit.h(qr) circuit.h(qr) circuit.h(qr) circuit.h(qr) circuit.measure(qr, cr) circuit.draw(output='mpl', scale=1) backend = Aer.get_backend('qasm_simulator') result = execute(circuit, backend, shots=128, memory=True).result() # get all experiments (number of shots) rawvalues_sim = result.get_memory() print(rawvalues_sim) counts = result.get_counts() print(counts) plot_histogram(counts) print(&quot;Length of data:&quot;, len(rawvalues_sim)) binarybytes = [] combinedbytes=[] mainstring = 0 # for each qubit for round in range(0, 5): # construct sequence of 0s &amp; 1s, creating a Byte for each sequence of 8 bits rawvalues_sim_str = &quot;&quot;.join(rawvalues_sim) startindex = 0 endindex = 128 for i in range(0, len(rawvalues_sim_str),128): #rawvalues is storing 5 bits per index b=rawvalues_sim_str[startindex:endindex] startindex = endindex endindex += 128 print(b)` the b here prints the random 128 sequence of bits. Now I want to find the identical bits in sequence of 128 bits. But I don't understand how.",<python><random><indexing><quantum-computing><bitstring>,08/12/2022 10:56,,,,
73502938.0,How to replace core classes/functionalities with a custom SPI?,"I'm trying to add some post quantum key algorithms (from liboqs-java) to Keycloak via custom SPI's. I can generate keys with the algorithms i've added, but I ran into some issues while manipulating them. Keycloak is having trouble while handling keys with my new algorithms... I think Java BouncyCastle does not recognizes post quantum algorithms (such as Dilithium2) and it causes system to crash. I'm having issues specifically with JcaPEMWriter BouncyCastle class, on BCPemUtilsProvider Keycloak class. My solution was to rewrite BCPemUtilsProvider so I can replace BouncyCastle functions but, in order to do this, I would need to change a core file from Keycloak and recompile the entire project, what would take an enormous amount of time, for each minor change. I'd like to fix this via SPI (if possible) or some lightweight solution, so I can do tests in a practical time. Is there any way to change core functionalities without recompiling the entiry Keycloak (or, maybe, another solution I'm not seeing)? Thanks in advance!! By the way, here is the code for key generating: public AbstractGeneratedDLSecretKeyProvider(ComponentModel model, KeyUse use, String type, String algorithm) { this.status = KeyStatus.from(model.get(Attributes.ACTIVE_KEY, true), model.get(Attributes.ENABLED_KEY, true)); this.kid = model.get(Attributes.KID_KEY); this.model = model; this.use = use; this.type = type; this.algorithm = algorithm; if (model.hasNote(PrivateKey.class.getName()) &amp;&amp; model.hasNote(PublicKey.class.getName())) { privateKey = model.getNote(PrivateKey.class.getName()); publicKey = model.getNote(PublicKey.class.getName()); } else { Signature signer = new Signature(&quot;Dilithium2&quot;); signer.generate_keypair(); privateKey = new DLPrivateKey(signer.export_secret_key()); publicKey = new DLPublicKey(signer.export_public_key()); model.setNote(PrivateKey.class.getName(), privateKey); model.setNote(PublicKey.class.getName(), publicKey); } } And this is the error I'm facing: 2022-08-25 21:06:18,476 ERROR [org.keycloak.services.error.KeycloakErrorHandler] (executor-thread-0) Uncaught server error: org.keycloak.common.util.PemException: java.lang.IllegalArgumentException: failed to construct sequence from byte[]: Extra data detected in stream at org.keycloak.crypto.def.BCPemUtilsProvider.encode(BCPemUtilsProvider.java:56) at org.keycloak.common.crypto.PemUtilsProvider.encodeKey(PemUtilsProvider.java:129) at org.keycloak.common.util.PemUtils.encodeKey(PemUtils.java:98) at org.keycloak.services.resources.admin.KeyResource.toKeyMetadataRepresentation(KeyResource.java:83) at org.keycloak.services.resources.admin.KeyResource.lambda$getKeyMetadata$0(KeyResource.java:67) at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) at java.base/java.util.stream.Streams$StreamBuilderImpl.forEachRemaining(Streams.java:411) at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658) at java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274) at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655) at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913) at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578) at org.keycloak.services.resources.admin.KeyResource.getKeyMetadata(KeyResource.java:69) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:170) at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:130) at org.jboss.resteasy.core.ResourceMethodInvoker.internalInvokeOnTarget(ResourceMethodInvoker.java:660) at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTargetAfterFilter(ResourceMethodInvoker.java:524) at org.jboss.resteasy.core.ResourceMethodInvoker.lambda$invokeOnTarget$2(ResourceMethodInvoker.java:474) at org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364) at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:476) at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:434) at org.jboss.resteasy.core.ResourceLocatorInvoker.invokeOnTargetObject(ResourceLocatorInvoker.java:192) at org.jboss.resteasy.core.ResourceLocatorInvoker.invoke(ResourceLocatorInvoker.java:152) at org.jboss.resteasy.core.ResourceLocatorInvoker.invokeOnTargetObject(ResourceLocatorInvoker.java:183) at org.jboss.resteasy.core.ResourceLocatorInvoker.invoke(ResourceLocatorInvoker.java:152) at org.jboss.resteasy.core.ResourceLocatorInvoker.invokeOnTargetObject(ResourceLocatorInvoker.java:183) at org.jboss.resteasy.core.ResourceLocatorInvoker.invoke(ResourceLocatorInvoker.java:141) at org.jboss.resteasy.core.ResourceLocatorInvoker.invoke(ResourceLocatorInvoker.java:32) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:492) at org.jboss.resteasy.core.SynchronousDispatcher.lambda$invoke$4(SynchronousDispatcher.java:261) at org.jboss.resteasy.core.SynchronousDispatcher.lambda$preprocess$0(SynchronousDispatcher.java:161) at org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364) at org.jboss.resteasy.core.SynchronousDispatcher.preprocess(SynchronousDispatcher.java:164) at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:247) at io.quarkus.resteasy.runtime.standalone.RequestDispatcher.service(RequestDispatcher.java:73) at io.quarkus.resteasy.runtime.standalone.VertxRequestHandler.dispatch(VertxRequestHandler.java:151) at io.quarkus.resteasy.runtime.standalone.VertxRequestHandler.handle(VertxRequestHandler.java:82) at io.quarkus.resteasy.runtime.standalone.VertxRequestHandler.handle(VertxRequestHandler.java:42) at io.vertx.ext.web.impl.RouteState.handleContext(RouteState.java:1212) at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:163) at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:141) at io.quarkus.vertx.http.runtime.StaticResourcesRecorder$2.handle(StaticResourcesRecorder.java:67) at io.quarkus.vertx.http.runtime.StaticResourcesRecorder$2.handle(StaticResourcesRecorder.java:55) at io.vertx.ext.web.impl.RouteState.handleContext(RouteState.java:1212) at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:163) at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:141) at io.quarkus.vertx.http.runtime.VertxHttpRecorder$5.handle(VertxHttpRecorder.java:380) at io.quarkus.vertx.http.runtime.VertxHttpRecorder$5.handle(VertxHttpRecorder.java:358) at io.vertx.ext.web.impl.RouteState.handleContext(RouteState.java:1212) at io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:163) at io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:141) at org.keycloak.quarkus.runtime.integration.web.QuarkusRequestFilter.lambda$createBlockingHandler$1(QuarkusRequestFilter.java:90) at io.vertx.core.impl.ContextImpl.lambda$null$0(ContextImpl.java:159) at io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:100) at io.vertx.core.impl.ContextImpl.lambda$executeBlocking$1(ContextImpl.java:157) at io.quarkus.vertx.core.runtime.VertxCoreRecorder$13.runWith(VertxCoreRecorder.java:545) at org.jboss.threads.EnhancedQueueExecutor$Task.run(EnhancedQueueExecutor.java:2449) at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1478) at org.jboss.threads.DelegatingRunnable.run(DelegatingRunnable.java:29) at org.jboss.threads.ThreadLocalResettingRunnable.run(ThreadLocalResettingRunnable.java:29) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.base/java.lang.Thread.run(Thread.java:829) Caused by: java.lang.IllegalArgumentException: failed to construct sequence from byte[]: Extra data detected in stream at org.bouncycastle.asn1.ASN1Sequence.getInstance(ASN1Sequence.java:92) at org.bouncycastle.asn1.x509.SubjectPublicKeyInfo.getInstance(SubjectPublicKeyInfo.java:43) at org.bouncycastle.openssl.jcajce.JcaMiscPEMGenerator.convertObject(Unknown Source) at org.bouncycastle.openssl.jcajce.JcaMiscPEMGenerator.&lt;init&gt;(Unknown Source) at org.bouncycastle.openssl.jcajce.JcaPEMWriter.writeObject(Unknown Source) at org.bouncycastle.openssl.jcajce.JcaPEMWriter.writeObject(Unknown Source) at org.keycloak.crypto.def.BCPemUtilsProvider.encode(BCPemUtilsProvider.java:50) ... 68 more",<java><cryptography><keycloak><bouncycastle><post-quantum-cryptography>,8/26/2022 14:55,,,,
73710267.0,I get an errorat at qresorc=provider.get_backend('ibmq_oslo'),"I try to run a simple quantum circuit on a quantum computer ('ibmq_oslo') and I get an error at qresorc=provider.get_backend('ibmq_oslo'). I verified that ibmq_oslo is in my resources list from my IBM quantum account. Here it is the code: from qiskit import * circuit = QuantumCircuit(2, 2) circuit.h(0) circuit.cx(0, 1) circuit.draw() simulator = Aer.get_backend('qasm_simulator') result = execute(circuit, backend=simulator).result() from qiskit .tools.visualization import plot_histogram plot_histogram(result.get_counts(circuit)) from qiskit import IBMQ provider = IBMQ.get_provider('ibm-q') qresorc = provider.get_backend('ibmq_oslo') QiskitBackendNotFoundError Traceback (most recent call last) Input In [14], in &lt;cell line: 1&gt;() ----&gt; 1 qresorc=provider.get_backend('ibmq_oslo') File ~\anaconda3\lib\site-packages\qiskit\providers\provider.py:55, in ProviderV1.get_backend(self, name, **kwargs) 53 raise QiskitBackendNotFoundError(&quot;More than one backend matches the criteria&quot;) 54 if not backends: ---&gt; 55 raise QiskitBackendNotFoundError(&quot;No backend matches the criteria&quot;) 57 return backends[0] QiskitBackendNotFoundError: 'No backend matches the criteria'",<python><qiskit>,9/14/2022 0:18,,,,
74101294.0,How does measurement affect multiple entangled qubits,"I'm trying to understand how measurement affects the non-measured qubits when I have more than two entangled qubits. Question 1: Say I have three entangled qubits in the state 1/2 (|000&gt; + |011&gt; + |101&gt; + |110&gt;), i.e. an equal chance of any even parity bit pattern. I then measure the left bit, and say it's 0. Are the other two bits still entangled, or does the wave function collapse upon the measurement of any bit? Question 2: Suppose I wrote the code: qc = QuantumCircuit(3, 3) # Let the transpiler figure out how to get the entangled state matrix = np.array((1, 0, 0, 1, 0, 1, 1, 0), dtype=float) / 2 qc.initialize(matrix) qc.measure(0, 0) # See text below qc.measure((1, 2), (1, 2)) result = Aer.get_backend('aer_simulator').run(qc).result() In this code, I would get identical results whether or not the bits are entangled after the first measurement. Is there something I could add to the code above that would distinguish entangled qubits from qubits forced to be |0&gt; or |1&gt;. Question 3. Suppose, instead, my state were A|000&gt; + B|011&gt; + C|101&gt; + D|110&gt;, and I measured the left bit to be 0. The new state is A'|001&gt; + B'|110&gt;. Are A' and B' just A and B multiplied by the appropriate scale factor so the norm is 1? Is there a phase shift of any sort?",<quantum-computing><qiskit>,10/17/2022 17:55,,,,
74114658.0,Must have Matplotlib installed,"I have installed matplotlib but I was still getting this error How can I solve this error? ImportError Traceback (most recent call last) Input In [10], in &lt;cell line: 18&gt;() 16 array_to_latex(psi, pretext=&quot;|\\psi\\rangle =&quot;) 17 # Show it on a Bloch sphere ---&gt; 18 plot_bloch_multivector(psi) File ~\anaconda3\lib\site-packages\qiskit\visualization\state_visualization.py:276, in plot_bloch_multivector(state, title, figsize, rho) 243 &quot;&quot;&quot;Plot the Bloch sphere. 244 245 Plot a sphere, axes, the Bloch vector, and its projections onto each axis. (...) 273 plot_bloch_multivector(state, title=&quot;New Bloch Multivector&quot;) 274 &quot;&quot;&quot; 275 if not HAS_MATPLOTLIB: --&gt; 276 raise ImportError('Must have Matplotlib installed. To install, run &quot;pip install ' 277 'matplotlib&quot;.') 278 # Data 279 bloch_data = _bloch_multivector_data(state) ImportError: Must have Matplotlib installed. To install, run &quot;pip install matplotlib&quot;.",<python><matplotlib><qiskit>,10/18/2022 16:51,,,,
74225579.0,How to keep visualizations (i.e. draw('mpl')) displayed while other code is called,"I would like to be able to save and call a visualization, then have it show in-between other code. I know with MatPlotLib, you can do plt.show(), is there anything like that for Qiskit? def test(): return plot_bloch_multivector(circ) print(&quot;This is what the plot looks like&quot;) test() print(&quot;See? Anyway...&quot;) # more code Output: This is what the plot looks like See? Anyway... Desired output: This is what the plot looks like # O O O (displayed bloch multivector) See? Anyway... I am using Google Colab (ver. 3.7.15).",<matplotlib><qiskit>,10/27/2022 16:49,,,,
74356381.0,What's the difference between pauliOp and SparsePauliOp in Qiskit?,"Recently I was building my own PauliOPerator component, but when I looked up the QIskit literature, I wondered what was the difference between PauliOPerator and SparsePauliOPerator, especially in the underlying implementation I want to know how to implement SparsePauliOPerator. Is there any relevant paper information",<qiskit>,11/08/2022 06:13,,,,
74522968.0,do fit function of QSVC require float values as parameters?,"Following is my code. The error seems to be in qsvc.fit() line but I can't understand why.one of the error line says &quot;TypeError: Invalid parameter values, expected Sequence[Sequence[float]].&quot; I'm pretty much sure I have passed arrays as parameters in fit function but do they need to be float type because labels are generally strings. sorry this is my first time trying this so these may seem naive. import pandas as pd import matplotlib.pyplot as plt import numpy as np from sklearn.model_selection import train_test_split from qiskit import Aer from qiskit.circuit.library import ZFeatureMap from qiskit_machine_learning.kernels import FidelityQuantumKernel from qiskit.algorithms.state_fidelities import ComputeUncompute from qiskit.primitives import Sampler from qiskit.utils import QuantumInstance from qiskit_machine_learning.algorithms import PegasosQSVC data=pd.read_csv('train.csv') X = data.loc[1:1000,[&quot;marital&quot;,&quot;balance&quot;,&quot;loan&quot;]].values Y = data.iloc[:1000,-1].values x_train, x_test, y_train, y_test = train_test_split(X, Y) data_feature_map = ZFeatureMap(feature_dimension=3, reps=1 ) sampler = Sampler() fidelity = ComputeUncompute(sampler=sampler) data_kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=data_feature_map) pegasos_qsvc = PegasosQSVC(quantum_kernel=data_kernel, C=1000, num_steps=100) pegasos_qsvc.fit(x_train, y_train) qsvc_score = pegasos_qsvc.score(x_test, y_test) print(f&quot;QSVC classification test score: {qsvc_score}&quot;)",<python><machine-learning><quantum-computing><qiskit>,11/21/2022 17:48,,,,
75011941.0,How do I use specific module in Qiskit Runtime?,I am using qiskit runtime and I need to serialize a class pass it in json format and rebuild the class once the program is uploaded. For this I wanted to use import jsonpickle which would make it very simple but if I try to import it I get the error: ERROR Failed to execute program: No module named 'jsonpickle' Is there a way to import this library using qiskit runtime?,<qiskit><python>,01/03/2023 16:11,,,,
75003129.0,How do I run a QuantumCircuit?,"I'm fairly new to quantum algorithms and I went from IBMQ Composer to the Python style of writing circuits. My question is: The code bellow just draws the circuit, is there a way to run the circuit and get the output without having to write a separate programs for visualization and execution? I looked into the &quot;QuantumCircuit&quot; functions (from the qiskit library), but none seem to do what I want. # importing Qiskit from qiskit import IBMQ, Aer from qiskit.providers.ibmq import least_busy from qiskit import QuantumCircuit, transpile, assemble # import basic plot tools from qiskit.visualization import plot_histogram # from qiskit_textbook.tools import simon_oracle deutsch_circuit = QuantumCircuit(2, 1) deutsch_circuit.h(0) deutsch_circuit.x(1) deutsch_circuit.h(1) deutsch_circuit.cx(0, 1) deutsch_circuit.h(0) deutsch_circuit.measure(0, 0) deutsch_circuit.draw()",<python><quantum-computing><qiskit>,01/04/2023 09:04,,,,
75229115.0,How can I make this density matrix on qiskit,"I want to make the density matrix on qiskit. The state is Ï=[7/9,0 ; 0, 2/9]. At first, I'm gonna make that matrix by unitrary transform from |0&gt;. But I realize that it cannot happend. Because there is no unitary transform which satisfy U|0&gt;&lt;0|U(Dagger) = [7/9,0 ; 0, 2/9]. How to do it on qiskit very simply? making the arbitrary density matrix on qiskit.",<quantum-computing><qiskit>,1/25/2023 2:11,,,,
75424858.0,Issue in Qiskit VQC with Amplitude Encoding for state preparation,"I have a problem in my code for quantum neural network. I tried to encoding 16 classical vectors to 4 qubits. The function for amplitude encoding in my code as below: def amplitude_encoding(num_qubits,x): qc = QuantumCircuit(num_qubits,name =&quot;Amplitude Encoding&quot;) qc.initialize(x, [0, 1, 2, 3]) encode = qc.to_instruction() return encode I assigned &quot;parameters&quot; to x with code as below: self.X = [qiskit.circuit.Parameter('X{}'.format(i)) for i in range(self.n_inputs)] And I got a same error as below. How can I solve this problem? --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In [16], line 3 1 simulator = qiskit.Aer.get_backend('aer_simulator') ----&gt; 3 circuit = QuantumCircuit_fixed(4, simulator, 100) 4 circuit._circuit.draw('mpl') Cell In [15], line 21, in QuantumCircuit_fixed.__init__(self, n_qubits, backend, shots) 18 self.theta = [qiskit.circuit.Parameter('theta{}'.format(j)) for j in range(self.n_inputs)] 19 print(self.theta) ---&gt; 21 self.feature_map = amplitude_encoding(self.n_qubits, self.X) 22 #self.feature_map = RawFeatureVector(16) 23 self._circuit.append(self.feature_map, range(4)) Cell In [2], line 7, in amplitude_encoding(num_qubits, x) 5 def amplitude_encoding(num_qubits,x): 6 qc = QuantumCircuit(num_qubits,name =&quot;Amplitude Encoding&quot;) ----&gt; 7 qc.initialize(x, [0, 1, 2, 3]) 8 encode = qc.to_instruction() 9 return encode File ~\anaconda3\envs\QISKIT\lib\site-packages\qiskit\extensions\quantum_initializer\initializer.py:191, in initialize(self, params, qubits) 188 qubits = [qubits] 189 num_qubits = len(qubits) if isinstance(params, int) else None --&gt; 191 return self.append(Initialize(params, num_qubits), qubits) File ~\anaconda3\envs\QISKIT\lib\site-packages\qiskit\extensions\quantum_initializer\initializer.py:57, in Initialize.__init__(self, params, num_qubits) 36 def __init__(self, params, num_qubits=None): 37 r&quot;&quot;&quot;Create new initialize composite. 38 39 Args: (...) 55 and the remaining 3 qubits to be initialized to :math:`|0\rangle`. 56 &quot;&quot;&quot; ---&gt; 57 self._stateprep = StatePreparation(params, num_qubits) 59 super().__init__(&quot;initialize&quot;, self._stateprep.num_qubits, 0, self._stateprep.params) File ~\anaconda3\envs\QISKIT\lib\site-packages\qiskit\circuit\library\data_preparation\state_preparation.py:99, in StatePreparation.__init__(self, params, num_qubits, inverse, label) 96 self._from_label = isinstance(params, str) 97 self._from_int = isinstance(params, int) ---&gt; 99 num_qubits = self._get_num_qubits(num_qubits, params) 101 params = [params] if isinstance(params, int) else params 103 super().__init__(self._name, num_qubits, params, label=self._label) File ~\anaconda3\envs\QISKIT\lib\site-packages\qiskit\circuit\library\data_preparation\state_preparation.py:201, in StatePreparation._get_num_qubits(self, num_qubits, params) 198 raise QiskitError(&quot;Desired statevector length not a positive power of 2.&quot;) 200 # Check if probabilities (amplitudes squared) sum to 1 --&gt; 201 if not math.isclose(sum(np.absolute(params) ** 2), 1.0, abs_tol=_EPS): 202 raise QiskitError(&quot;Sum of amplitudes-squared does not equal one.&quot;) 204 num_qubits = int(num_qubits) TypeError: bad operand type for abs(): 'Parameter'",<qiskit>,02/12/2023 04:14,,,,
75553239.0,AttributeError: can't set attribute in qiskit Grover Algorithm,"Here is my code def gen_grover(width): oracle = QuantumCircuit(width, name='q') oracle.z(width-1) full_circuit = GroverOperator(oracle, insert_barriers=False, name='q') full_circuit = dag_to_circuit(circuit_to_dag(full_circuit)) full_circuit.qregs[0].name = 'q' full_circuit = full_circuit.decompose() full_circuit = transpile(full_circuit,optimization_level=3) return full_circuit I get the error below: full_circuit.qregs[0].name = 'q' AttributeError: can't set attribute python-BaseException",<qiskit>,2/24/2023 6:27,,,,
75576387.0,Implementing Quantum Addition in C# for Solving Complex Problems,"var simulator = new QuantumSimulator(); int[] numbers = new int[] { 1, 2, 3, 4, 5 }; QArray&lt;int&gt; qNumbers = new QArray&lt;int&gt;(numbers); int sum = 0; for (int i = 0; i &lt; qNumbers.Length; i++) { var register = new QArray&lt;int&gt;(new int[] { qNumbers[i], sum }); simulator.OnRun += () =&gt; Microsoft.Quantum.Primitive.Swap.Run(simulator, register[0], register[1]); simulator.Run(new Microsoft.Quantum.Samples.QSharp.Swap()); sum = register[0]; } Console.WriteLine(&quot;The sum is &quot; + sum); The above code attempts to use a quantum computing simulator to calculate the sum of an array of integers. But it doesn't work !!! Error: Unhandled Exception: System.InvalidOperationException: The sum calculated by the quantum algorithm is incorrect. at MyProgram.Main() in C:\MyProgram.cs:line 17",<c#><quantum-computing>,2/27/2023 2:48,,,,
75724242.0,Python Numpy implementing PIMC QAVRP,"I`m having some trouble implementing PIMC QAVRP, an Quantum Annealing algorithm that uses Path-Integral Monte Carlo. Actully, my problem is with numpy. Here is my code: import numpy as np #Calculo da energia potencial do sistema def pot_energy(S, d): return np.sum(d * np.einsum('...i,...j,ij-&gt;...ij', S, S, np.ones_like(d)), axis=(-1, -2)) #Calculo da energia potencial do sistema def kin_energy(S): Hkin = np.zeros_like(S) Hkin[1:] += S[:-1] * S[1:] Hkin[-1] += S[-1] * S[0] return np.sum(Hkin) #Calculo da transformaÃ§Ã£o de Suzuki-Trotter para uma replica def suzuki_trotter_replica(S, J, dt): S = (S * np.exp(-1j * J * dt / 2)).astype(float) np.fft.fftn(S, axes=[-2, -1]) S = (S * np.exp(-1j * J * dt / 2)).astype(float) np.fft.ifftn(S, axes=[-2, -1]) S = S * np.exp(-1j * dt).astype(float) S[1:] *= S[:-1] S[-1] *= S[0] S = S * np.exp(-1j * dt).astype(float) return S #Calculo da transformaÃ§Ã£o de Suzuki-Trotter para todas as replicas def suzuki_trotter(S, J, dt): for i in range(S.shape[0]): S[i] = suzuki_trotter_replica(S[i], J, dt) return S #ALGORITIMO DE EXECUÃÃO DO QAVRP def pimc_qa_vrp(d, num_steps, num_replicas, beta, dt): # Inicializa a matriz de spins aleatÃ³riamente S = np.random.choice([-1, 1], size=(num_replicas, *d.shape)) # Inicializa os arrays de energia H_pot = np.zeros(num_replicas) H_kin = np.zeros(num_replicas) # Loop principal for step in range(num_steps): # Aplica a transformaÃ§Ã£o de Suzuki-Trotter S = suzuki_trotter(S, beta, dt) # Calcula a energia potencial do sistema for i in range(num_replicas): H_pot[i] = np.sum(pot_energy(S[i],d)) H_kin[i] = kin_energy(S[i]) # Calcula a energia Total H = H_pot / num_replicas - np.sum(H_kin) * beta / num_replicas # Aplica o QAVRP S = np.sign(np.tanh(-beta * (H - H.min()) / 2) + np.random.rand(*S[:, 0:1, :, :].shape + (1,)) - 0.5) ''' Essa expressÃ£o implementa a transiÃ§Ã£o quÃ¢ntica aleatÃ³ria, onde o estado atual Ã© atualizado para um novo estado aleatÃ³rio com uma probabilidade que depende da diferenÃ§a de energia potencial entre os dois estados. Se a energia potencial do novo estado Ã© menor do que a do estado atual, o novo estado Ã© aceito. Caso contrÃ¡rio, o novo estado Ã© aceito com uma probabilidade que depende da temperatura. ''' return S[0] d = np.array([[0, 1, np.sqrt(2)], [1, 0, 1], [np.sqrt(2), 1, 0]]) num_steps = 1000 num_replicas = 100 beta = 2.0 dt = 0.1 solution = pimc_qa_vrp(d, num_steps, num_replicas, beta, dt) print(solution) When I run it, I get the following error: C:\Users\vitor\OneDrive\Documentos\qiskit\test.py:16: ComplexWarning: Casting complex values to real discards the imaginary part S = (S * np.exp(-1j * J * dt / 2)).astype(float) C:\Users\vitor\OneDrive\Documentos\qiskit\test.py:18: ComplexWarning: Casting complex values to real discards the imaginary part S = (S * np.exp(-1j * J * dt / 2)).astype(float) C:\Users\vitor\OneDrive\Documentos\qiskit\test.py:20: ComplexWarning: Casting complex values to real discards the imaginary part S = S * np.exp(-1j * dt).astype(float) C:\Users\vitor\OneDrive\Documentos\qiskit\test.py:23: ComplexWarning: Casting complex values to real discards the imaginary part S = S * np.exp(-1j * dt).astype(float) Traceback (most recent call last): File &quot;C:\Users\vitor\OneDrive\Documentos\qiskit\test.py&quot;, line 70, in &lt;module&gt; solution = pimc_qa_vrp(d, num_steps, num_replicas, beta, dt) File &quot;C:\Users\vitor\OneDrive\Documentos\qiskit\test.py&quot;, line 51, in pimc_qa_vrp S = np.sign(np.tanh(-beta * (H - H.min()) / 2) + np.random.rand(*S[:, 0:1, :, :].shape + (1,)) - 0.5) IndexError: too many indices for array: array is 3-dimensional, but 4 were indexed Not really worried about the warnings, but that problem with numpy is making me crazy. I`ve tried adding new dimensions to S, but no luck at all. I was hopping to get S[0] as the best solution for VRP!",<python><numpy><quantum-computing>,3/13/2023 16:02,,,,
75755628.0,ModuleNotFoundError: No module named 'qiskit.chemistry',"Ive been trying to solve this issue but this line is causing me trouble from qiskit.chemistry.core import Hamiltonian, TransformationType I know that i have to use qiskit nature instead of qiskit chemistry but i dont know to what i have to migrade to for &quot;Hamiltonian&quot; and &quot;TransformationType&quot;. import numpy as np from qiskit import QuantumCircuit, Aer from qiskit.aqua import aqua_globals, QuantumInstance from qiskit.aqua.algorithms import VQE from qiskit.aqua.components.optimizers import SLSQP from qiskit.circuit.library import TwoLocal from qiskit.chemistry.drivers import PySCFDriver from qiskit.chemistry.core import Hamiltonian, TransformationType # Set the number of qubits and optimization parameters n_qubits = 4 depth = 3 # Set up the molecule and driver molecule = 'H .0 .0 -{0}; H .0 .0 {0}' distance = 0.74 driver = PySCFDriver(atom=molecule.format(distance/2), unit=TransformationType.ANGSTROM, charge=0, spin=0, basis='sto3g') qmolecule = driver.run() hamiltonian = qmolecule.get_molecular_hamiltonian() # Define the ansatz circuit ansatz = TwoLocal(n_qubits, ['ry', 'rz'], 'cz', reps=depth) # Define the optimizer optimizer = SLSQP(maxiter=1000) # Define the VQE algorithm vqe = VQE(ansatz, optimizer) # Run the VQE algorithm result = vqe.compute_minimum_eigenvalue(hamiltonian) # Print the energy of the ground state print('Ground state energy: ', result.eigenvalue.real)",<python><quantum-computing><qiskit>,3/16/2023 11:27,,,,
75883668.0,How can I make Qutip turn a sparse matrix into a Qobject?,"I have some operators in matrix form and Iâm turning the into Qobjects. Nevertheless, these matrices are sparse. I was wondering if I could give Qutip a scypy sparse matrix, so that when I do things like solving the master equation, the calculations become faster",<python><qutip>,3/30/2023 2:34,,,,
76030148.0,Quantum Fourier Transformation Qiskit implementation,I tried to work the Qiskit implementation using python3 AttributeError: 'QuantumCircuit' object has no attribute 'cu1' is the error message import matplotlib.pyplot as plt %matplotlib inline import numpy as np from math import pi from qiskit import *,<python><quantum-computing>,4/16/2023 20:24,,,,
76108789.0,Probelm in retreiving backend to run a repeat until success circuit on qiskit,"I'm trying to run a repeat until success circuit on hardware by following instructions from qiskit tutorials. Here is the code: from qiskit_ibm_provider import IBMProvider, least_busy provider = IBMProvider() hub = &quot;\&lt;hub\&gt;&quot; group = &quot;\&lt;group\&gt;&quot; project = &quot;\&lt;project\&gt;&quot; hgp = f&quot;{hub}/{group}/{project}&quot; backend_name = &quot;\&lt;backend name\&gt;&quot; backend = provider.get_backend(backend_name, instance=hgp) print(f&quot;Using {backend.name}&quot;) The error it shows is : QiskitBackendNotFoundError: 'No backend matches the criteria' The line backend = provider.get_backend(backend_name, instance=hgp) is showing this error. I also tried replacing &quot;&lt;backend name&gt;&quot; qith the name of a backend , but still the same error.",<qiskit>,4/26/2023 8:41,,,,
76149096.0,Is it easier to rewrite a pyomo model into a Docplex or a Gurobi model?,I've got an optimization problem written in pyomo that I want to translate to Qiskit. The only issue is that Qiskit has the ability to take in Docplex or Gurobi models. My question is this: Is it easier to rewrite a pyomo model into a Docplex or a Gurobi model?,<python><pyomo><gurobi><docplex><qiskit>,05/01/2023 18:01,,,,
76152273.0,"Qiskit 'No counts for experiment ""0""'","Error 'No counts for experiment &quot;0&quot;' in line answer = job_result.get_counts() here's my code shots = 1000 backend_type = 'qasm_simulator' backend = Aer.get_backend(backend_type) provider = IBMQ.load_account() #backend = provider.get_backend(backend_type) job = execute(qc, backend = backend, shots = shots) job_result = job.result() answer = job_result.get_counts() print(answer) plot_histogram(answer, title = 'Measurement Qubit')",<qiskit>,05/02/2023 06:34,,,,
76494714.0,how to improve QSVC accuracy and decrease computation time?,"I developed SVM and QSVM on iris_data to see the potential advantage of QML over classical ML but I got QSVC with less accuracy and more computation time compare to SVC , can some please help how can I increase accuracy and optimize the computation time of QSVC. pasted below the code for reference #code for SVC svc=SVC(kernel='linear') start=time.time() svc.fit(X_train,y_train) time.time()-start. #svc with 0.008 computation time and with accuracy of 0.95 #code for QSVC service=QiskitRuntimeService() with Session(service=service,backend='simulator_statevector') as session: sampler1=Sampler(session=session) fidelity=ComputeUncompute(sampler=sampler1) fmap=ZZFeatureMap(feature_dimension=4,reps=2,entanglement='linear') kernel=FidelityQuantumKernel(feature_map=fmap,fidelity=fidelity) qsvc=QSVC(quantum_kernel=kernel) #time: 5 minutes and accuracy 0.73 How can I improve the performance of QSVC?",<machine-learning><quantum-computing><svc>,6/17/2023 4:31,,,,
76560698.0,Python 3.10 QuTip: AttributeError: can't set attribute 'format',"I'm trying to setup a simple docker container to make my code portable. Following is the docker container setup that I start with docker run -it --name qutip_portble python:3.10.9-slim bash Once the docker container starts, I install some packages as follows pip install qutip pip install matplotlib Both of these install succesfully without any error. However, when I try to run the following import in python import qutip I get the following error Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/usr/local/lib/python3.10/site-packages/qutip/__init__.py&quot;, line 106, in &lt;module&gt; from qutip.qobj import * File &quot;/usr/local/lib/python3.10/site-packages/qutip/qobj.py&quot;, line 2526, in &lt;module&gt; import qutip.superop_reps as sr File &quot;/usr/local/lib/python3.10/site-packages/qutip/superop_reps.py&quot;, line 74, in &lt;module&gt; _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()) File &quot;/usr/local/lib/python3.10/site-packages/qutip/operators.py&quot;, line 508, in identity return qeye(dims) File &quot;/usr/local/lib/python3.10/site-packages/qutip/operators.py&quot;, line 488, in qeye return Qobj(fast_identity(size), File &quot;/usr/local/lib/python3.10/site-packages/qutip/fastsparse.py&quot;, line 389, in fast_identity return fast_csr_matrix((data,ind,ptr),shape=(N,N)) File &quot;/usr/local/lib/python3.10/site-packages/qutip/fastsparse.py&quot;, line 55, in __init__ self.format = 'csr' AttributeError: can't set attribute 'format' I get this error at the import stage before even writing any code of mine. Therefore, I'm assuming this is because of some setup issue. Any help will be appreciated.",<python><python-3.x><qutip>,6/26/2023 22:57,,,,
76622848.0,"Write FALCON public key,private key, and hash to an external file","I use FALCON from liboqs with python wrapper from OQS. I have 2 python files, one for generating the public key, hashes and dump the result to an external file. While the second file will be use for verifying the hash from public key which will be extract from the external file. Below is the full code for generating keys, hash and verify. message = &quot;Secret messagea&quot;.encode('utf-8') print(message) algo = &quot;Falcon-512&quot; with oqs.Signature(algo) as falcon: print(&quot;\nDetails:&quot;) pprint(falcon.details) print(&quot;\n\n\n============================================&quot;) pub_key = falcon.generate_keypair() pri_key = falcon.export_secret_key() sign = falcon.sign(message) check = falcon.verify(message, sign, pub_key) print(&quot;\n Valid signature?&quot;, check) What I have tried so far: dumping the key and hash directly to .txt on bytes format Write code with open(file, &quot;wb&quot;) as file: file.write(key) file.write(hash) Read Code with open(file, &quot;rb&quot;) as file: key = file.read() hash = file.read() When extracting, the value is different I tried converting to base64 however I when I decode it from base64 to byte the value is different. Below is the code to decode from base64 pub_key = base64.b64decode(pub_key) I have research for using .pem file format, below is the function to write to .pem from cryptography.hazmat.primitives import serialization def writepem(key): pem_key = key.public_bytes(encoding=serialization.Encoding.PEM) with open(file, &quot;wb&quot;) as file: file.write(pem_key) However it resulted in error shown below AttributeError: 'bytes' object has no attribute 'private_bytes' I don't know how to use the cryptography module properly. Quite new to cryptographic programming.",<python-3.x><pem><python-cryptography><post-quantum-cryptography>,07/05/2023 17:48,,,,
76624299.0,Super Operator Representation of Operators,"Can someone guide me as to how to convert operators into super operators? If i have a bitflip noise channel, how can i convert it into a super operator? Thank you",<operators><quantum-computing>,07/05/2023 22:00,,,,
76624462.0,Dimension mismatch with numpy,"I am trying to run a code for the following Hamiltoninan: H = $\sum_{i&lt;j} J_{ij}(\sigma_i^+ \sigma_j^- + \sigma_i^- \sigma_j^+) + \sum_j(B + B_j)\sigma_j^z$ The code is as follows: import numpy as np import qutip as qt from scipy.constants import hbar # Qubit-qubit coupling matrix: alpha = 1.47 constant = 67.3765 def create_matrix(rows, columns): matrix = [] for i in range(rows): row = [] for j in range(columns): if i == j: entry = 0 row.append(entry) else: entry = constant*np.power(abs(i - j), -alpha) row.append(entry) matrix.append(row) return matrix num_qubits = 8 J_ij = create_matrix(num_qubits, num_qubits) J_ij = np.matrix(J_ij) # Magnetic field: B_i = np.array([[2.85884931, 26.22601547, 48.5376065, 62.948092, 53.7557919, 37.31269595, 10.50862743, 0.1]]) B = 15707.96326795 # Hamiltonian: # Define the spin operators for each ion spin_operators = [qt.jmat(0.5, 'x'), qt.jmat(0.5, 'y'), qt.jmat(0.5, 'z')] # Define the raising and lowering operators for each ion s_plus = [qt.tensor([qt.qeye(2)] * i + [qt.create(2)] + [qt.qeye(2)] * (num_qubits - i - 1)) for i in range(num_qubits)] s_minus = [qt.tensor([qt.qeye(2)] * i + [qt.destroy(2)] + [qt.qeye(2)] * (num_qubits - i - 1)) for i in range(num_qubits)] s_z = [qt.tensor([qt.qeye(2)] * i + [spin_operators[0]] + [qt.qeye(2)] * (num_qubits - i - 1)) for i in range(num_qubits)] # XY interaction term interaction_term = sum([J_ij[i, j] * (s_plus[i] * s_minus[j] + s_minus[i] * s_plus[j]) for i in range(num_qubits-1) for j in range(i+1, num_qubits)]) # Transverse magnetic field term #transverse_field_term = hbar*B * sum(s_z) transverse_field_term = B*sum(s_z) # Define the Hamiltonian H = interaction_term + transverse_field_term H = H.full() I am providing the full code so it is reproducible. The problem is with the line transverse_field_term = B*sum(s_z) which I need to modify. I was working with H = $\sum_{i&lt;j} J_{ij}(\sigma_i^+ \sigma_j^- + \sigma_i^- \sigma_j^+) + B\sum_j\sigma_j^z$ but the last term is now \sum_j(B + B_j)\sigma_j^z which I tried to write in the code as: # Transverse magnetic field term transverse_field_term = sum((B + B_i[i]) * s_z[i] for i in range(num_qubits)) But I got the following error: --------------------------------------------------------------------------- ValueError Traceback (most recent call last) 42 # Transverse magnetic field term ---&gt; 43 transverse_field_term = sum((B + B_i[i]) * s_z[i] for i in range(num_qubits)) 45 # Define the Hamiltonian &lt;ipython-input-11-c550e8be0fe1&gt; in &lt;genexpr&gt;(.0) 41 42 # Transverse magnetic field term ---&gt; 43 transverse_field_term = sum((B + B_i[i]) * s_z[i] for i in range(num_qubits)) 44 45 # Define the Hamiltonian ~/.virtualenvs/cgan_tf/lib/python3.10/site-packages/qutip/qobj.py in __rmul__(self, other) 633 return out 634 else: --&gt; 635 return other * self.data 636 637 elif isinstance(other, list): ~/.virtualenvs/cgan_tf/lib/python3.10/site-packages/scipy/sparse/_base.py in __rmul__(self, other) 618 619 def __rmul__(self, other): # other * self --&gt; 620 return self._rmul_dispatch(other) 621 622 ####################### ~/.virtualenvs/cgan_tf/lib/python3.10/site-packages/scipy/sparse/_base.py in _rmul_dispatch(self, other) 612 except AttributeError: 613 tr = np.asarray(other).transpose() --&gt; 614 ret = self.transpose()._mul_dispatch(tr) 615 if ret is NotImplemented: 616 return NotImplemented ~/.virtualenvs/cgan_tf/lib/python3.10/site-packages/scipy/sparse/_base.py in _mul_dispatch(self, other) 557 # dense row or column vector 558 if other.shape != (N,) and other.shape != (N, 1): --&gt; 559 raise ValueError('dimension mismatch') 560 561 result = self._mul_vector(np.ravel(other)) ValueError: dimension mismatch I tried to correct it with # Reshape B_i to match the shape of s_z B_i_reshaped = np.reshape(B_i, (num_qubits, 1)) # Transverse magnetic field term transverse_field_term = -B * sum((B_i_reshaped[i] + B) * s_z[i] for i in range(num_qubits)) But I got the same error. How can I make it right?",<python><numpy><matrix-multiplication><qutip>,07/05/2023 22:40,,,,
76784514.0,Grovers algorithm for specific qubits,"Is it possible to use Grover's algorithm on a particular register instead of all qubits? For example, if I have the superposition of 2 qubits and I'm looking to see if qubit 1 is present on the second qubit, can I apply Grover's algorithm to increase the probabilities of 01 and 11 in the superposition of 2 qubits?",<quantum-computing><qiskit>,7/28/2023 2:32,,,,
76789850.0,Converting Classical Images to Quantum Images using INEQR Technique: Feasibility and Python Implementation?,"How to convert a classical image into a quantum image using the INEQR technique? and is it possible using Python? I'm facing difficulties to convert a classical image into a quantum image.so, I'm expecting some suggestions, on how to convert a classical image into a quantum image and whether is it possible to use Python or not. if possible need the Python implementation code,",<python><image-processing><quantum-computing>,7/28/2023 17:15,,,,
76791904.0,Probability m randomly selected Boolean n-vectors is likely to span the whole space,"What probability of a set of m randomly selected Boolean n-vectors is likely to span the whole space, provided m = Î©(nlog 2n)? I know probability at least 1/2 then m randomly selected Boolean n-vectors is likely to span the whole space. But i dont know prove that.",<linear-algebra><algebra><quantum-computing>,7/29/2023 3:08,,,,
,,,,,,,,
1508.0,"In a Quantum Turing Machine, how is the decision to move along the memory tape made?","Let, for a Quantum Turing machine (QTM), the state set be $Q$, and the alphabet of symbols be $\sum=\{0,1\}$, which appear at the tape head. Then, as per my understanding, at any given time while the QTM is calculating, the qubit that appears at its head will hold an arbitrary vector $V_\sum = a|1\rangle+b|0\rangle$. Also, if $|q_0\rangle , |q_1\rangle, ... \in Q$, then the state vector at that instance will also be an arbitrary vector $V_q=b_0|q_0\rangle + b_1 |q_1\rangle+ ...$. Now, after the instruction cycle is complete, the vectors $V_\sum$ and $V_q$ will decide whether the QTM will move left or right along the Qubit tape. My question is- since Hilbert space formed by $Q \otimes \sum$ is an uncountable infinite set and $\{\text{Left,Right}\}$ is a discrete set, the mapping between them will be difficult to create. So how is the decision to move left or right made? Does the QTM move both left and right at the same time, meaning that the set $\{\text{Left,Right}\}$ also forms a different Hilbert space, and hence the motion of the QTM becomes something like $a|\text{Left}\rangle+b|\text{Right}\rangle$. Or, just like a Classical Turing machine, the QTM moves either left or right, but not both at the same time?",<classical-computing><computational-models><quantum-turing-machine>,3/30/2018 11:30,1592.0,1592.0,"If we have a QTM with state set $Q$ and a tape alphabet $\Sigma = \{0,1\}$, we cannot say that the qubit being scanned by the tape head ""holds"" a vector $a|0\rangle + b|1\rangle$ or that the (internal) state is a vector with basis states corresponding to $Q$. The qubits on the tape can be correlated with one another and with the internal state, as well as with the tape head position. As an analogy, we would not describe a probabilistic Turing machine's global state by independently specifying a distribution for the internal state and for each of the tape squares. Rather, we have to describe everything together so as to properly represent correlations among the different parts of the machine. For example, the bits stored in two distant tape squares might be perfectly correlated, both 0 with probability 1/2 and both 1 with probability 1/2. So, in the quantum case, and assuming we're talking about pure states of quantum Turing machines with unitary evolutions (as opposed to a more general model based on mixed states), the global state is represented by a vector whose entries are indexed by configurations (i.e., classical descriptions of the internal state, the location of the tape head, and the contents of every tape square) of the Turing machine. It should be noted that we generally assume that there is a special blank symbol in the tape alphabet (which could be 0 if we want our tape squares to store qubits) and that we start computations with at most finitely many squares being non-blank, so that the set of all reachable configurations is countable. This means that the state will be represented by a unit vector in a separable Hilbert space. Finally, and perhaps this is the actual answer to the question interpreted literally, the movement of the tape head is determined by the transition function, which will assign an ""amplitude"" to each possible action (new state, new symbol, and tape head movement) for every classical pair $(q,\sigma)$ representing the current state and currently scanned symbol. Nothing forces the tape head to move deterministically -- a nonzero amplitude could be assigned to two or more actions that include tape head movements to both the left and right -- so it is possible for a QTM tape head to move both left and right in superposition. For example, you can imagine a QTM with $Q = \{0,1\}$ and $\Sigma = \{0,1\}$ (and we'll take 0 to be the blank symbol). We start in state 0 scanning a square that stores 1, and all other squares store 0. I won't explicitly write down the transition function, but will just describe the behavior in words. On each move, the contents of the scanned tape square is interpreted as a control bit for a Hadamard operation on the internal state. After the controlled-Hadamard is performed, the head moves left if the (new) state is 0 and moves right if the (new) state is 1. (In this example we never actually change the contents of the tape.) After one step, the QTM will be in an equally weighted superposition between being in state 0 with the tape head scanning square -1, and being in state 1 with the tape head scanning square +1. On all subsequent moves the controlled-Hadamard does nothing because every square aside from square 0 contains the 0 symbol. The tape head will therefore continue to move simultaneously both left and right, like a particle travelling to the left and to the right in superposition. If you wanted to, you could of course define a variant of the quantum Turing machine model for which the tape head location and movement is deterministic, and this would not ruin the computational universality of the model, but the ""classic"" definition of quantum Turing machines does not impose this restriction.",04/04/2018 14:43
2051.0,"Why does job.running in QISKit output False, even if the job is still running?","I submitted a job in the 0.5.0 version of QISKit using job = execute(qc, 'ibmqx5', shots=shots) This just submits the job, and does not wait for a result. I then immediately tested whether the job was still running using print(job.running) This gave the result False. However, when I requested the result using job.result() This still took a while to get the result, suggesting that the job actually was still running after all. What is going on here?",<programming><qiskit>,5/14/2018 13:19,2052.0,2052.0,"There are three stages that the job goes through, as you'll see if you also print the status using print(job.status). The first is an initialization stage. This returns False for job.running, because it hasn't started running yet. Then your job actually will run, and so give True for job.running. Finally it will have finished running, and so job.running goes back to False. So don't use job.running to test whether a result is ready.",5/14/2018 13:19
2282.0,Why is it harder to build quantum computers than classical computers?,"Is it because we don't know exactly how to create quantum computers (and how they must work), or do we know how to create it in theory, but don't have the tools to execute it in practice? Is it a mix of the above two? Any other reasons?",<physical-realization><classical-computing>,06/10/2018 12:34,2285.0,2285.0,"We know exactly, in theory, how to construct a quantum computer. But that is intrinsically more difficult than to construct a classical computer. In a classical computer, you do not have to use a single particle to encode bits. Instead, you might say that anything less than a billion electrons is a 0 and anything more than that is a 1, and aim for, say, two billion of electrons to encode a 1 normally. That makes you inherently fault-tolerant: Even if there are hundreds of millions of electrons more or less than expected, you will still get the correct classification as a digital 0 or a 1. In a quantum computer, this trick is not possible due to the non-cloning theorem: You cannot trivially employ more than one particle to encode a qubit (quantum bit). Instead, you must make all your gates operate so well that they are not just accurate to the single particle level but even to a tiny fraction of how much they act on a single particle (to the so-called quantum-error correction threshold). This is much more challenging than to get gates accurate merely to within hundreds of millions of electrons. Meanwhile we do have the tools to, just barely, make quantum computers with the required level of accuracy. But nobody has, as of yet, managed to make a big one meaning one that can accurately operate on the perhaps hundred of thousands of physical qubits needed to implement a hundred or so logical qubits to then be undeniably in the realm where the quantum computer beats classical computers at select problems (quantum supremacy).",06/10/2018 17:11
2363.0,Will Moore's Law be no longer effective once quantum computers are created?,"Moore's law states that computer power doubles in every 18 months (more formally: ""the number of transistors in a dense integrated circuit doubles about every two years.""). Statistics suggest that this observation should be correct, but aren't quantum computers much more powerful than just double-powered classical computers? More interesting question is, is there even a way to improve the power of quantum computers?",<classical-computing><experiment><scalability>,6/16/2018 9:45,2364.0,2364.0,"but aren't quantum computers much more powerful than just double-powered classical computers? Yes. A universal quantum computer with only 100 qubits (12.5 quantum bytes) can find the ground state of a matrix with $2^{200} = 10^{60}$ elements. Assuming Moore's Law could continue forever (which is not true due to physical limitations), it would take longer than the age of the universe (13.5 billion years) for the ""doubling of transistors every 18 months"" to bring classical computers to what a quantum computer with one quantum gigabyte can do, for certain problems. More interesting question is, is there even a way to improve the power of quantum computers? There have been proposals for exploiting certain types of phenomena that would lead to devices even more powerful than quantum computers, but in all cases quantum computers would be a special case of such devices (just like classical computers are a special case of quantum computers, they are quantum computers that just only use classical gates and inputs that are not in any superposition). It is hard enough to build a quantum computer, so building the more generalized devices would be even harder.",6/16/2018 17:31
2477.0,Phase-Shift Gate in Qiskit,How to implement the phase shift gate in qiskit or ibmq? Phase Shift Gate : $$\begin{pmatrix}e^{ia} &amp;&amp; 0 \\ 0 &amp;&amp; e^{ia}\end{pmatrix} = e^{ia}I$$,<programming><qiskit><ibm-q-experience>,6/26/2018 16:52,2478.0,2478.0,"You can implement the phase shift gate $$P_h(\theta) = \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix}$$ with the X and u1 gate from the IBM Q chips: $$ \begin{align} P_h(\theta) &amp;= U_1(\theta)\ X\ U_1(\theta)\ X \\ &amp;= \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}1 &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp; 1\\1 &amp; 0\end{pmatrix} \\ &amp;= \begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix}\begin{pmatrix}0 &amp; 1\\e^{i\theta} &amp; 0\end{pmatrix} \\ &amp;= \begin{pmatrix}e^{i\theta} &amp; 0\\0 &amp; e^{i\theta}\end{pmatrix} \end{align}$$ So: def Ph(quantum_circuit, theta, qubit): quantum_circuit.u1(theta, qubit) quantum_circuit.x(qubit) quantum_circuit.u1(theta, qubit) quantum_circuit.x(qubit) implements the $P_h$ gate on Qiskit.",6/26/2018 17:05
3846.0,List of qubit locations with cirq,"As far I understand, qubits in cirq are labelled by their positions on chip. For example print( cirq.google.Foxtail.qubits ) yields frozenset({GridQubit(0, 1), GridQubit(1, 9), GridQubit(0, 2), ... I would like to get a simpler version of the above, namely a simple array of tuples for the positions of all qubits [ (0,1), (0,2), (0,3), ..., (1,1), (1,2), (1,3), ... ] What is the easiest way to obtain this for a given known device in cirq?",<programming><cirq>,7/23/2018 9:39,3849.0,3849.0,"GridQubit has comparison methods defined, so sorted will give you a list of the qubits in row-major order: &gt;&gt;&gt; sorted(cirq.google.Foxtail.qubits) [GridQubit(0, 0), GridQubit(0, 1), [...] GridQubit(1, 9), GridQubit(1, 10)] Once you have that, you're one list comprehension away: &gt;&gt;&gt; [(q.row, q.col) for q in sorted(cirq.google.Foxtail.qubits)] [(0, 0), (0, 1), [...] (1, 9), (1, 10)] Because tuples also have a default ordering, it doesn't matter whether you sort before or after the conversion: &gt;&gt;&gt; sorted((q.row, q.col) for q in cirq.google.Foxtail.qubits) [(0, 0), (0, 1), [...] (1, 9), (1, 10)]",7/23/2018 12:08
3902.0,Are classical bits quantum?,"A bit is a binary digit, typically 0 or 1. Until a value is assigned (or a measurement is made) a bit is in a superposition of the entangled binary pair, is it not?",<classical-computing>,7/31/2018 1:55,3905.0,3905.0,"A bit, either 0 or 1, can certainly be thought of as a special case of being a qubit. However, that is not to say that anything capable of computing with classical bits is capable of computing with quantum bits. If you have a bit, and donât know if itâs a 0 or a 1, then how do you describe its state? You have to use Bayesian priors. If you have no idea which it is, you assign the two options equal probabilities. And it really is probabilities here. So itâs 50:50 being in 0 or 1. You canât describe this as a pure quantum state, but you can use a density matrix: $$\rho=(|0\rangle\langle 0|+|1\rangle\langle 1|)/2.$$ This formalism also means that if you later learn something about what the bit value might be (perhaps as a result of reading other bits in a computation), you can update those probabilities using conditional probabilities and Bayesâ rule. Note that this also means itâs a subjective description of the state: it reflects your personal knowledge of the state of the bit, while somebody else, who perhaps prepared the bit, already knows what value it has. This is perhaps one way to see why it should be different from the pure state that you proposed, which should be an objective description that everyone would agree on (in that there is no uncertainty in the state; the only uncertainty is induced by the action of the measurement).",7/31/2018 5:26
3908.0,"Possibility of a ""reset"" quantum gate","I wish to have a ""reset"" gate. This gate would have an effect to bring a qubit to the $\mid0\rangle$ state. Clearly, such a gate is not unitary (and so I'm unable to find any reliable implementation in terms of universal gates). Now for my particular needs, I need this ability to reset a qubit or a quantum register to that state so users can always start from $\mid0\rangle$. I'm making a small programming language that transpiles to QASM, and when a function is exited, I want all local (quantum) variables (qubits) reset to $\mid0\rangle$ so they can be reused. QASM reset instruction does not work on the real processor. I think that something to this effect may be achieved with quantum phase estimation but I'm wondering if there is another way.",<quantum-gate><programming>,7/31/2018 12:05,3909.0,3909.0,"One way is simply to measure the qubit in the standard, $Z$, basis. If you get the answer 0, then you've got the state you want. Otherwise, you apply a bit-flip to it. Indeed, if you want to implement a non-unitary operation, you need some sort of measurement operation somewhere, whether that's a direct measurement, or the implementation of a CP map or POVM (but for these options, you need to introduce ancillas of a fixed state, which rather negates the point). Or you could use noise in the system, but you are unlikely to have sufficient control of it - it's noise after all! Of course, none of these options just reset a single qubit; anything that qubit is entangled with is also affected, but that's kind of in the definition of ""reset"" in the quantum context. The only other option is to uncompute, but this is not a generic option because, generically you have to uncompute the entire computation to reset even a single qubit, and that resets everything. Except it doesn't work perfectly because of errors. You would be better starting a new computation. There are specific scenarios where an ancilla qubit is used and it can be uncomputed, but this is typically built into the algorithm because the uncomputation step is important for getting rid of some unwanted entanglement that would otherwise appear.",7/31/2018 12:21
3935.0,"How do we code the matrix for a controlled operation knowing the control qubit, the target qubit and the $2\times 2$ unitary?","Having n qubits, I want to have the unitary described a controlled operation. Say for example you get as input a unitary, an index for a controlled qubit and another for a target. How would you code this unitary operation?",<quantum-gate><programming><gate-synthesis>,08/04/2018 11:05,3941.0,3941.0,"Hereâs some pseudo code, where id(n) creates an $2^n\times 2^n$ identity matrix, and tensor(A,B,...) returns $A\otimes B\otimes\ldots$. def cU(ctrl,targ,U,size): '''implement controlled-U with: control qubit ctrl, target qubit targ, within a set of size qubits''' #check input ranges assert 1&#60;=ctrl&#60;=size assert 1&#60;=targ&#60;=size assert ctrl&#60;&#62;targ assert ctrl,targ,size &#8714; &#8484; #ensure U is a 2x2 unitary assert U&#8714;&#8450;2x2 assert U.U&dagger;=id(2) #the actual code if ctrl&#60;targ: return id(size)+tensor(id(ctrl-1),id(1)-Z,id(targ-1-ctrl),U-id(1),id(size-targ))/2 else: return id(size)+tensor(id(targ-1),U-id(1),id(ctrl-1-targ),id(1)-Z,id(size-ctrl))/2 However, remember that usually you're trying to calculate the action of a unitary on some state vector. It will be far more memory efficient to calculate that application directly, rather than first calculating the unitary matrix and applying it to the state vector. To understand where this formula came from, think about the two-qubit version, where the first qubit is the control qubit. You'd normally write the unitary as $$ |0\rangle\langle 0|\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U. $$ Let's rewrite this as $$ (\mathbb{I}-|1\rangle\langle 1|)\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U=\mathbb{I}\otimes\mathbb{I}+|1\rangle\langle 1|\otimes (U-\mathbb{I}). $$ It can be easier to write things in terms of Pauli matrices, so $$ |1\rangle\langle 1|=(\mathbb{I}-Z)/2. $$ To get the same unitary on a different number of qubits, you just need to pad with identity matrices everywhere.",08/05/2018 05:14
4268.0,"How to construct the ""Inversion About the Mean"" operator?","It seems like it should be simple, based on how Nielsen and Chuang talk about it, but I cannot seem to correctly implement the Inversion About the Mean operator ($2|\psi\rangle \langle\psi| - \mathcal{I}$) that is used in the Grover search algorithm, especially without using any ancilla bits. I thought about performing a NOT operation on all the working qubits, then performing a controlled-NOT on a separate toggle qubit with the control being all the working qubits, then performing a controlled phase flip with control of the toggle bit, and finally flipping the phase of all the states. I'm not sure how I'd actually implement the controlled phase flipping, though, since, I believe, phase flipping one or all of the bits would not produce the desired effect. Does anyone know how I can construct this? I am using Q#, by the way, if you'd like to answer in code.",<programming><q#>,9/22/2018 21:31,4269.0,4269.0,"First, let's represent operation $2|\psi\rangle \langle\psi| - \mathcal{I}$ as $H^{\otimes n}(2|0\rangle \langle0| - \mathcal{I})H^{\otimes n}$, as Nielsen and Chuang do. Doing $H^{\otimes n}$ is easy - it's just ApplyToEach(H, register). $2|0\rangle \langle0| - \mathcal{I}$ flips the phase of all computational basis states except $|0...0\rangle$. Let's do instead $\mathcal{I} - 2|0\rangle \langle0|$, flipping the phase of only $|0...0\rangle$ (it introduces a global phase of -1 which in this case I think can be ignored). To flip the phase of only $|0...0\rangle$: flip the state of all qubits using ApplyToEach(X, register). Now we need to flip the phase of only $|1...1\rangle$ state. do a controlled-Z gate on one of the qubits (for example, the last one), using the rest as control. This can be done using Controlled functor: (Controlled Z)(Most(register), Tail(register)). Tail returns the last element of the array, and Most returns all elements except the last one. flip the state of all qubits again to return them to the original state.",9/22/2018 23:57
4367.0,"How to make ""random U3"" in QASM?","I want to make an operator: $\mathrm{U3}(\arccos(\sqrt p),0,0)$, when $p$ is a random value between $0$ and $1$ How do I write code in QASM language of this ""random $\mathrm{U3}$"" operator?",<programming><qasm>,10/07/2018 16:27,4376.0,4376.0,"There are many forms of QASM, so I'll answer for OpenQASM 2.0, as is currently used by IBM. Declaring a gate to be random means that it would be randomly generated at compile time. Since QASM is used as an expression of a compiled circuit, such randomness must be resolved by the time the QASM is created. It is true that are transpilation processes in the IBM stack, which convert a user generated QASM into one optimized for the needs of a given device. This could allow for the functionality your desire to be built into future versions. But I doubt that will be the case. It is much easier just to use randomness when generating the QASM, such as with Pythons random number generation when creating circuits with Qiskit. Disclaimer: I work for IBM.",10/09/2018 08:41
4531.0,Can we speed up the Grover's Algorithm by running parallel processes?,"In classical computing, we can run the key search (for example AES) by running parallel computing nodes as many as possible. It is clear that we can run many Grover's algorithms, too. My question is; it possible to have a speed up using more than one Grover's algorithm as in classical computing?",<classical-computing><grovers-algorithm><cryptography>,10/24/2018 20:06,4538.0,4538.0,"Certainly! Imagine you have $K=2^k$ copies of the search oracle $U_S$ that you can use. Normally, you'd search by iterating the action $$ H^{\otimes n}(\mathbb{I}_n-2|0\rangle\langle 0|^{\otimes n})H^{\otimes n}U_S, $$ starting from an initial state $(H|0\rangle)^{\otimes n}$. This takes time $\Theta(\sqrt{N})$. (I'm using $\mathbb{I}_n$ to denote the $2^n\times 2^n$ identity matrix.) You could replace this with $2^k$ parallel copies, each indexed by an $x\in\{0,1\}^k$, using $$ \left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)\mathbb{I}_k\otimes(\mathbb{I}_{n-k}-2|0\rangle\langle 0|^{\otimes (n-k)})\left(\mathbb{I}_k\otimes H^{\otimes (n-k)}\right)U_S $$ and starting from a state $|x\rangle(H|0\rangle)^{\otimes(n-k)}$ The time required for running these would be reduced to $O(\sqrt{N/K})$, at the cost of requiring $K$ times more space. In a scaling sense, one might consider this an irrelevant result. If you have a fixed number of oracles, $K$, then you get a fixed ($\sqrt{K}$) improvement (just like, if you have $K$ parallel classical cores, the best improvement you can get is a factor of $K$), and that does not change the scaling. But it does change the fundamental running time. We know that Grover's algorithm is exactly optimal. It takes the absolute minimum time possible with a single oracle. So, knowing that you get a $\sqrt{K}$ improvement in time is useful with regards to that benchmark of a specific running time at a specific value of $N$.",10/25/2018 8:02
4810.0,Implementing gate with two parameters using Qiskit in Python,"I am trying to implement the HHL algorithm (for solving $Ax=b$). I am assuming $A$ to be unitary and Hermitian so that I can find the Hamiltonian simulation for it easily. For any $A$ to be Hermitian and unitary, it has to be of form, $$ A = \begin{pmatrix} x &amp; \pm\sqrt{1-x^2}\\ \pm\sqrt{1-x^2} &amp; x\end{pmatrix} $$ I reduced $e^{i\alpha A}$ to following (by using formula $e^{i\theta A} = (\cos\theta)I + i(\sin\theta)A$ where $A^2=I$), but I don't know how to implement it on Qiskit. $$ e^{i\alpha A} = \begin{pmatrix} \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} &amp; i\sin\alpha \sin\frac{\theta}{2} \\ i\sin\alpha \sin\frac{\theta}{2} &amp; \cos\alpha+i\sin\alpha\cos\frac{\theta}{2} \end{pmatrix} .$$ where $\theta = 2\cos^{-1}{x}$. How to construct this gate?",<quantum-gate><programming><qiskit><gate-synthesis><hhl-algorithm>,11/26/2018 12:57,4812.0,4812.0,"(Remark: I have corrected a typo in the matrix exponentiation). Please notice that the matrix has the form: $$ e^{i\alpha A} = \begin{pmatrix} a &amp; b \\ b &amp; a \end{pmatrix} $$ with $$|a|^2 + |b|^2 = 1$$ Now, please notice that this matrix can be expanded as: $$\begin{pmatrix} a &amp; b \\ b &amp; a \end{pmatrix} = \begin{pmatrix} e^{i \arg(a)} &amp; 0 \\ 0 &amp; e^{i \arg(a)} \end{pmatrix} \begin{pmatrix} |a | &amp; i|b| \\ i|b |&amp; |a| \end{pmatrix} $$ Defining $$ |a| = \cos \phi$$ $$ |b| = \sin \phi$$ Thus we obtain: $$ e^{i\alpha A} = e^{i \arg(a) I_2} e^{i\phi \sigma_x} $$ In short, the result constitutes of an overall phase multiplication and an $R_x$ gate. Expressed in the question's original variables: $$\arg(a) = \arctan (\tan \alpha \cos \frac{\theta}{2})$$ and $$\phi = \arcsin (\sin \alpha \sin \frac{\theta}{2})$$",11/26/2018 14:19
4907.0,qiskit - Is there any way to discard the results of a measurement?,"I have a circuit composed by n qubits, plus a single one which is an ancilla. I'm making multiple measurements on the ancilla at different stages of the circuit, while working on the n qubits. These measurements are not really needed at all: they are just a way to collapse the state of the qubit at some point during the computation and then reuse the same qubit in a different way. At the end of the circuit, when I'm measuring the outcome of the n qubits, I don't want the result of this ancilla to be shown in the output of the get_counts() function; what I want is only the output of the n qubits. Is there any way to achieve this result?",<circuit-construction><programming><measurement><qiskit>,12/11/2018 10:46,4971.0,4971.0,"If you keep measuring to the same bit, the value should get overridden every time. So you won't receive the intermediary values. For example, the following will output a single 1 from the second measurement, with no trace of the first. from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit from qiskit import execute from qiskit import BasicAer q = QuantumRegister(1) c = ClassicalRegister(1) qc = QuantumCircuit(q,c) qc.measure(q,c) qc.x(q) qc.measure(q,c) job = execute(qc,backend=BasicAer.get_backend('qasm_simulator')) job.result().get_counts() I guess what you want is something more like q = QuantumRegister(n) # n qubits a = QuantumRegister(1) # one ancilla qubit c = ClassicalRegister(n) # n classical bits for output qc = QuantumCircuit(q,a,c) qc.x(a[0]) qc.measure(a[0],c[0]) # measure the ancilla to one of the classical bits qc.measure(q,c) # measure the n qubits to the n bits (overwriting the output from the previous measurement",12/15/2018 17:32
5075.0,How do I name the adjoint of an operation in Q#?,"For example, if I've defined the operation PlusEqual, I'd like to say operation MinusEqual = Adjoint PlusEqual; but this produces a syntax error. Is the only way to do this by exhaustively re-listing all arguments and functors? operation MinusEqual (all_args_and_types_again) : ReturnType { body (...) { return Adjoint AddEqual(all_args); } adjoint auto; controlled auto; controlled adjoint auto; }",<programming><q#>,12/29/2018 16:38,5077.0,5077.0,"You can define an immutable symbol for MinusEqual inside the body of an operation which will use it (you can't define it globally): operation UseMinusEqual () : Unit { ... let MinusEqual = Adjoint PlusEqual; MinusEqual(...); } If you need MinusEqual to be a globally visible operation, there is no shorthand syntax for this right now, so the only way to do it is a full operation definition like you say.",12/29/2018 18:57
5109.0,Representing a real valued vector with qubits,"I have some understanding that with qubits, I can represent a $2^n$ size vector using only $n$ qubits. However, I'm having trouble putting this together in a way that can make a useful circuit. Say I want to represent the input $(0 \ 0 \ 0 \ 1)$ for my circuit. I should be able to do this with only 2 qubits. Starting with the initial state $|0\rangle|0\rangle$, which as far as I know represents the vector $(1 \ 0 \ 1 \ 0)$, I can use a not gate on the second qubit to transform that to $(1 \ 0 \ 0 \ 1)$. However, I'm not sure what operation I can do to put the first qubit into a $(0 \ 0)$ state. On top of that, I have even less of an idea of how to represent real-value vectors, like $(0.5 \ 0.5)$ (assuming including a normalization constant). I have a feeling I can use phase, but I'm not sure how to set up a circuit to achieve this. Edit: Realized my earlier representation was very off. The initial state $|00\rangle$ is the same as the vector $(1 \ 0 \ 0 \ 0)$, so transforming that into the the desired $(0 \ 0 \ 0 \ 1)$ Would just require two NOT gates: 0 -- NOT -- 1 0 -- NOT -- 1 However, I'm still unsure how to represent real-valued vectors, or even a vector like $(1 \ 0 \ 1 \ 0)$.",<quantum-state><programming>,01/02/2019 21:11,5111.0,5111.0,"$(1,0,1,0)$ means $$ 1 (1,0,0,0) + 1 (0,0,1,0) $$ and you already know how $| 0 0 \rangle$ and $(1,0,0,0)$ correspond. To make $(0,0,1,0)$ the encoding would be $| 1 0 \rangle$. I'm assuming you are reading the entries as 0,1,2,3 in that order for the vector and the first qubit corresponds to the most significant bit. (Little vs Big endian). If not, make the necessary changes. So all together you need $1 | 00 \rangle + 1 | 10 \rangle$. For other combinations like $(a_0 , 0 , a_2 , 0)$ change the coefficents. $a_0 | 00 \rangle + a_2 | 10 \rangle$",01/02/2019 23:31
5144.0,Can I remove gates from a QuantumCircuit?,"Suppose I want to implement run several circuits one after another, but they are constructed in a similar fashion. I could reinstantiate a QuantumCircuit for each iteration, like this: params = np.linspace(0, 2 * np.pi, num=20) for p in params: circ = QuantumCircuit(q, c) do_stuff(circ, p) do_other_stuff() but I'm afraid that creating a bunch of unnecessary circ objects takes too much memory or too many calls to the garbage collector. Instead, I would like to remove the gates from the QuantumCircuit object and build the new circuit in the old object. Is it possible, and if so, is it reasonable?",<programming><qiskit>,01/08/2019 17:51,5209.0,5209.0,"Quantum circuits have a data attribute, which is a list of all gates. You can remove elements from this as with any Python list. For example, here's a circuit q = QuantumRegister(1) circ = QuantumCircuit(q) circ.h(q[0]) circ.s(q[0]) circ.x(q[0]) Let's get rid of the S gate. First, we can look at the list of gates with circ.data. This gives [&lt;qiskit.extensions.standard.h.HGate at 0x11721b7b8&gt;, &lt;qiskit.extensions.standard.s.SGate at 0x11721b828&gt;, &lt;qiskit.extensions.standard.x.XGate at 0x11721b7f0&gt;] Element 1 of this list (i.e. the second element) is the gate we want rid of. We can do this with pop. qiskit.data.pop(1) The resulting circuit can then be seen by print(circ) ââââââââââ q0_0: |0&gt;â¤ H ââ¤ X â ââââââââââ As you can see, we have succeeded in removing the S gate. Note that you can get information about the elements of the data list using the methods name and qargs, etc, of gate objects. For example, to see that element 0 is a Hadamard, and to see which qubit it acts on, we can use print( circ.data[0].name ) print( circ.data[0].qargs ) This returns h [(QuantumRegister(1, 'q0'), 0)]",1/15/2019 14:53
5156.0,How do I get a list of control qubits from Q# operations when tracing the simulation in C#?,"I want to write code that prints out the controls of each operation executed during a simulation in Q#. For example this code prints the control counts: var qsim = new QCTraceSimulator(config); qsim.OnOperationStart += (op, arg) =&gt; { Console.WriteLine($""{Controls(op, arg).Length""}); } I'm having trouble writing the Controls function, which extracts a list of qubits being used as controls. When the operation is uncontrolled, or controlled by 0 qubits, the returned array should be of length 0. The issue I'm running into is that the type and layout of arg.Value varies from operation to operation, even after conditioning on op.Variant being OperationFunctor.ControlledAdjoint or OperationFunctor.Controlled. I can handle individual cases by inspecting the types, but I keep running into new unhandled cases. This indicates there's probably a ""correct"" way to do this that I'm missing. In short, how do I implement this function: object[] Controls(ICallable op, IApplyData arg) { ??? } By ""controls"" I always mean the cs in Controlled Op(cs, ...). The same operation may have different controls when expressed in different ways. For example, the controls list of Controlled Toffoli(a, (b, c, d)) is the list [a] whereas the controls list of Controlled X([a, b, c], d) is the list [a, b, c]. A further example: the controls list of Toffoli(b, c, d) is [], even though normally one might think of the first two arguments as the controls. It is of course expected that within Toffoli(b, c, d) there may be a sub-operation Controlled X((b, c), d) where the controls list is [b, c]; I'm not thinking of controls as some kind of absolute concept that is invariant as you go down through layers of abstraction.",<programming><q#>,01/09/2019 22:37,5157.0,5157.0,"arg.Value contains the actual tuple that the controlled operation receives at runtime. It's a two item tuple in which the first item is the control qubits, and the second another tuple with the arguments the operation normally expects, so in your case you are only interested in the first item of this tuple. Overall, arg.Value can be anything, thus it has object as type, but fear not, using a little bit of C#'s reflection is easy to retrieve its content. The implementation you are looking for is this: static Qubit[] Controls(ICallable op, IApplyData arg) { // Uncontrolled operations have no control qubits. if (op.Variant != OperationFunctor.Controlled &amp;&amp; op.Variant != OperationFunctor.ControlledAdjoint) { return new Qubit[0]; } // Get the first item of the (controls, args) tuple. dynamic v = arg.Value; QArray&lt;Qubit&gt; ctrls = v.Item1; return ctrls.ToArray(); } Notice the array of Qubits is encapsulated in something called a QArray&lt;Qubit&gt;, QArray is the data structure we use in simulation for all Q# arrays.",01/09/2019 23:42
5159.0,TypeError: unorderable types: QuantumRegister() >= int(),"I've been using qiskit for about a year now, and as of late, I've had issues finding an available backend to run my circuit on. Looking into the matter, I reinstalled qiskit to find that most everything had changed quite a bit. Now when I try to run just a basic test circuit program, taken from the tutorial I get this: ~$ python3 test.py Traceback (most recent call last): File ""test.py"", line 27, in &lt;module&gt; job = execute(circ, backend) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 108, in execute skip_transpiler, seed_mapper, pass_manager, memory) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/tools/compiler.py"", line 67, in compile coupling_map=coupling_map, seed=seed, memory=memory) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 61, in circuits_to_qobj coupling_map)) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/converters/circuits_to_qobj.py"", line 92, in _circuit_to_experiment json_circuit = DagUnroller(dag, JsonBackend(dag.basis)).execute() File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 38, in execute self._process() File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_dagunroller.py"", line 161, in _process self.backend.new_qreg(name, width) File ""/home/micciche/.local/lib/python3.5/site-packages/qiskit/unroll/_jsonbackend.py"", line 98, in new_qreg assert size &gt;= 0, ""invalid qreg size"" TypeError: unorderable types: QuantumRegister() &gt;= int() Does anybody know how to resolve this? Thanks. Edit: This is the code I tried to run, which I just copied from a tutorial: import numpy as np from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute # Create a Quantum Register with 3 qubits. q = QuantumRegister(3, 'q') # Create a Quantum Circuit acting on the q register circ = QuantumCircuit(q) # Add a H gate on qubit 0, putting this qubit in superposition. circ.h(q[0]) # Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting # the qubits in a Bell state. circ.cx(q[0], q[1]) # Add a CX (CNOT) gate on control qubit 0 and target qubit 2, putting # the qubits in a GHZ state. circ.cx(q[0], q[2]) # Import Aer from qiskit import BasicAer # Run the quantum circuit on a statevector simulator backend backend = BasicAer.get_backend('statevector_simulator') # Create a Quantum Program for execution job = execute(circ, backend) result = job.result() outputstate = result.get_statevector(circ, decimals=3) print(outputstate)",<programming><qiskit>,01/10/2019 02:57,5168.0,5168.0,"The code you provide works fine for me, so I guess that something is wrong with your installation. I recommend running the command pip uninstall qiskit and also pip uninstall qiskit-terra pip uninstall qiskit-aqua pip uninstall qiskit-aer and then reinstalling with pip install qiskit",01/10/2019 13:58
5197.0,Why won't Qiskit ccx gate accept registers?,"In Qiskit, they have the concept of a Toffoli gate (ccx). However, the following code throws an error: from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute, Aer q1 = QuantumRegister(2) qctrl = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q1, qctrl, c) qc.x(q1) qc.ccx(q1[0], q1[1], qctrl) qc.measure(q1, c) backend_sim = Aer.get_backend('qasm_simulator') job_sim = execute(qc, backend_sim) result_sim = job_sim.result() print(result_sim.get_counts(qc)) According to my knowledge and research, this should produce the output 111 but instead I get an error message: qiskit.qiskiterror.QiskitError: ""QuantumRegister(1, 'q0') is not a tuple. A qubit should be formated as a tuple."" This seems like a bug with Qiskit to me. Am I wrong? And if so, how can I fix my code?",<programming><qiskit>,1/14/2019 7:44,5198.0,5198.0,"It is not a bug. Qiskit makes the difference between quantum registers and quantum bits. In your case, qctrl is a QuantumRegister (as shown in your error) whereas the ccx gate expect a qubit. For Qiskit, a qubit is defined as a Tuple of a QuantumRegister and an index. You can get a qubit from a QuantumRegister by using the indexing notation: qtrl[0] represents the first qubit (and the only one) of the QuantumRegister qctrl. In summary, replace qc.ccx(q1[0], q1[1], qctrl) by qc.ccx(q1[0], q1[1], qctrl[0]) and your issue should be fixed.",1/14/2019 8:32
5308.0,Qiskit: 'per shot' result,"Is there a way to access the results of measurements 'per shot' performed on a backend such as one of the real IBM machines? I know it can generate a histogram from the cumulative data, but I was wondering if it is possible to see what the measurement outcomes were for a particular shot out of the standard 1024.",<programming><qiskit><ibm-q-experience>,1/29/2019 19:41,5309.0,5309.0,"There is indeed. You just need to use get_memory() instead of get_counts() (and also use a memory=True flag in the execute function. It works with the local qasm simulator and the 5 qubit device (and not currently with the cloud-based qasm simulator or 14 qubit device). Here's an example using it to generate a series of random bits. q = QuantumRegister(1) c = ClassicalRegister(1) circ = QuantumCircuit(q, c) circ.h(q) circ.measure(q,c) job = execute(circ, Aer.get_backend('qasm_simulator'), shots=10024, memory=True) data = job.result().get_memory()",1/30/2019 2:26
5364.0,Why is Grover's algorithm not converging monotonically? (Python implementation),"I have tried to implement Grover's algorithm for three qubits in python/numpy and the first two iterations work like a charm but the third one starts to diverge. Is this expected, or is there a bug in the code? I expected the inversion around the mean to blow up the coefficient of the marked state in each iteration. The code follows Nielsen closely, with a silly Oracle that hard-codes the negation of the basis state. The Python code requires a little bit of set-up but the essential idea is: Define a phase shift operator of -1 on all basis states except zero. Define a reflection around the mean operator as Hadamard â Phase Shift â Hadamard. Define the full Grover step as the Oracle followed by the reflection. Start with an equally balanced state. Repeatedly apply the Grover step. Source code: import numpy as np def dagger(m): return np.transpose(np.conjugate(m)) def proj(m): return m * dagger(m) # identity matrix for 3 qubits = 8x8 matrix id3 = np.identity(2**3) # hadamard matrix for 1, 2 and 3 qubits H1 = np.matrix([[1.0, 1.0], [1.0, -1.0]], dtype=np.complex256) / np.sqrt(2) H2 = np.kron(H1, H1) H3 = np.kron(H2, H1) # 3 qubit zero vector |000&gt; zero3 = np.array([[1],[0],[0],[0],[0],[0],[0],[0]], dtype=np.complex256) # phase shift operator 2*|0&gt;&lt;0| - I for 3 qubits PS3 = 2 * proj(zero3) - id3 # reflection around the mean R = H3 * PS3 * H3 # 3 qbit oracle, marking/negating state |101&gt; = column vector (0 0 0 0 0 1 0 0) O = id3 O[5,5] = -1 # grover operator G = R * O # start state |000&gt; x0 = H3 * zero3 # apply grover step three times x1 = G * x0 print x1 x2 = G * x1 print x2 x3 = G * x2 print x3 The output of the program is shown below. The coefficient (driving the probability) for the state to search for is 0.88 after one iteration, then 0.97 but then falls back to 0.57. Am I missing any essential step in the algorithm? [[ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j] [ 0.88388348+0.0j] [ 0.1767767+0.0j] [ 0.1767767+0.0j]] [[-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j] [ 0.97227182+0.0j] [-0.088388348+0.0j] [-0.088388348+0.0j]] [[-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j] [ 0.57452426+0.0j] [-0.30935922+0.0j] [-0.30935922+0.0j]]",<programming><grovers-algorithm>,02/03/2019 22:33,5365.0,5365.0,"This seems normal by applying the definition of the inversion about average operator which transforms the amplitudes $\alpha_i $ by the formula : $$ - \alpha_i + 2 \langle\alpha\rangle\,, $$ Apply this to your example (using the above formula for each step to verify your intermediary steps) and you should retrieve this numbers. This operator is periodic. After the maximum number of operations giving you the highest probability of the desired state to be measured, you will reset the amplitudes if you apply it another time, meaning you have to reapply again to amplify its amplitude the same way.",02/03/2019 23:01
5471.0,Is programming in quantum computer same as programming in quantum simulator in classical computer?,"I just started programming in Q# and I wonder if the coding for Q# in classical computer would be the same as coding in a quantum computer. Obviously, these 2 kinds of computers work differently, so I guess the language must be working differently as well. Does this affect the coding part in any way (syntax, dealing with operations and variables etc.)?",<programming><q#>,02/12/2019 13:54,5475.0,5475.0,"Running programs on a quantum computer will indeed require some routines which are not required for running them on a classical simulation. Two easiest examples are error correction (a classical simulation is perfect but a quantum device will be noisy and will require error correction to produce useful results) and translating logical qubits and gates to physical ones (in a simulation you can do any gate on any pair of qubits, but a physical device will be limited to certain set of primitive gates and a certain connectivity scheme). However, the person writing high-level quantum code is likely uninterested in such low-level routines (unless they are researching them specifically), same as a person writing this answer doesn't really want to care about the addresses of the bytes storing it on their computer. High-level programming languages (in particular Q#, since you asked about it) aim to provide a high-level abstraction for the programmer and delegate low-level routines to the compiler. This also allows to run the same code on the simulators (for debugging and resource estimation purposes) and then to take it to a quantum device without modifications.",02/12/2019 17:48
5494.0,How to set a starting state in cirq?,I'm learning how to use the cirq library. Every time I set up a circuit the starting state of the qubits is $|0000..0\rangle$. Is there any way to make the starting state different? I'm thinking of somehow giving as input some np.array (vector) to the circuit so that the system initializes with such state. I know I could build a circuit to prepare the state I want but I would like a shorter way to do this. Thanks!,<programming><cirq>,2/15/2019 13:22,5496.0,5496.0,"Cirq distinguishes between ""running"" a circuit, which is generally supposed to act like hardware would (e.g. only getting samples), and ""simulating"" a circuit, which has more freedom. Most ""simulate"" methods, like cirq.Simulator().simulate(...) have a parameter initial_state which can either be a computational basis state (specified as an integer e.g. initial_state=0b000111000) or a state vector (specified as a numpy array e.g. initial_state=np.array([0.5, -0.5, 0.5j, 0.5])). For ""run"" methods, like cirq.Simulator().run(...), there is no way to specify the initial state because that's how it works in hardware. If you want a specific state, you have to make it with gates.",2/15/2019 17:42
5867.0,Qiskit DAG circuit - print information about individual gate/node by number,"I created a DAG circuit in Qiskit and don't really understand how to see which gate is which. I want to call a function like dag_circuit.gate_info(gate_number), which will then print, for example, that gate number 9 is a hadamard gate $H$, and that gate number 11 is a $U_3(\theta=0.1,\phi=0.2,\lambda=-0.5)$. How do I get this information?",<programming><qiskit>,04/06/2019 20:31,5882.0,5882.0,"NOTE: At the moment this method is correct, however, this information might be out of date once the 0.9 release of Qiskit is deployed. Hi Samuel, if you have a dag circuit and you want to access information about the nodes, you need to call dag_circuit.multi_graph.nodes[index_of_node] The information you can get from a node in the circuit is a dictionary containing the following: type (either ""in"", ""out"", or ""op"") name (either a qubit, classical bit, or an operation name) wire (the Register Object of the qubit or classical bit that the wire is attached to) An ""op"" node will will have these other values in addition to the ones above (excluding the ""wire"" value): 'op' (The data type of the operation) qargs (The qubits this gate is applied to) cargs (The classical bits this gate is applied to) condition In your example where you have an $H$ Gate at node 9 and a $U_3(\theta=0.1, \phi=0.2, \lambda=-0.5)$ Gate at node 11, if you were to call print(dag_circuit.multi_graph.nodes[8]) and print(dag_circuit.multi_graph.nodes[10]), you would receive the following output: {'type': 'op', 'op': &lt;qiskit.extensions.standard.h.HGate object at ""some_memory_address""&gt;, 'name': 'h', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None} {'type': 'op', 'op': &lt;qiskit.extensions.standard.u3.U3Gate object at ""some_memory_address""&gt;, 'name': 'u3', 'qargs': [(QuantumRegister(1, 'q'), 0)], 'cargs': [], 'condition': None}",04/09/2019 14:37
5869.0,(name of gate) is not in the list of basis operations,"I'm trying to define a custom gate for my computations. I decided to copy the structure in one of the files in qiskit.extensions.standard package. Here is the code of h.py (Hadamard gate): # -*- coding: utf-8 -*- # Copyright 2017, IBM. # # This source code is licensed under the Apache License, Version 2.0 found in # the LICENSE.txt file in the root directory of this source tree. # pylint: disable=invalid-name """""" Hadamard gate. """""" from qiskit.circuit import Gate from qiskit.circuit import QuantumCircuit from qiskit.circuit import InstructionSet from qiskit.circuit import QuantumRegister from qiskit.qasm import pi from qiskit.dagcircuit import DAGCircuit from qiskit.extensions.standard import header # pylint: disable=unused-import from qiskit.extensions.standard.u2 import U2Gate class HGate(Gate): """"""Hadamard gate."""""" def __init__(self, qubit, circ=None): """"""Create new Hadamard gate."""""" super().__init__(""h"", [], [qubit], circ) def _define_decompositions(self): """""" gate h a { u2(0,pi) a; } """""" decomposition = DAGCircuit() q = QuantumRegister(1, ""q"") decomposition.add_qreg(q) decomposition.add_basis_element(""u2"", 1, 0, 2) rule = [ U2Gate(0, pi, q[0]) ] for inst in rule: decomposition.apply_operation_back(inst) self._decompositions = [decomposition] def inverse(self): """"""Invert this gate."""""" return self # self-inverse def reapply(self, circ): """"""Reapply this gate to corresponding qubits in circ."""""" self._modifiers(circ.h(self.qargs[0])) def h(self, q): """"""Apply H to q."""""" if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.h((q, j))) return instructions if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.h(q)) return instructions self._check_qubit(q) return self._attach(HGate(q, self)) QuantumCircuit.h = h Trying to change the names of the class, the property of QuantumCircuit and the name string in Gate constructor results in an exception (name of the gate) is not in the list of basic operations if I try to either draw or execute an example circuit containing the gate. "" """" [1]-const gate. """""" from qiskit.circuit import Gate from qiskit.circuit import QuantumCircuit from qiskit.circuit import InstructionSet from qiskit.circuit import QuantumRegister from qiskit.qasm import pi from qiskit.dagcircuit import DAGCircuit from qiskit.extensions.standard import header # pylint: disable=unused-import from qiskit.extensions.standard.u2 import U2Gate class OneConstGate(Gate): def __init__(self, qubit, circ=None): super().__init__(""oneconst"", [], [qubit], circ) def _define_decompositions(self): decomposition = DAGCircuit() q = QuantumRegister(1, ""q"") decomposition.add_qreg(q) decomposition.add_basis_element(""u2"", 1, 0, 2) rule = [ U2Gate(0, pi, q[0]) ] for inst in rule: decomposition.apply_operation_back(inst) self._decompositions = [decomposition] def inverse(self): """"""Invert this gate."""""" return self # self-inverse def reapply(self, circ): """"""Reapply this gate to corresponding qubits in circ."""""" self._modifiers(circ.oneconst(self.qargs[0])) def oneconst(self, q): """"""Apply H to q."""""" if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.oneconst((q, j))) return instructions if isinstance(q, QuantumRegister): instructions = InstructionSet() for j in range(q.size): instructions.add(self.oneconst(q)) return instructions self._check_qubit(q) return self._attach(OneConstGate(q, self)) QuantumCircuit.oneconst = oneconst Here is the example code: x = QuantumRegister(1, 'x') gate = QuantumCircuit(x) gate.oneconst(x[0]) gate.draw() Note that I haven't changed any logic yet. Just the names. Did I forgot something? Edit (1): I had a look at header.py code in qiskit.extensions.standard. Adding these lines of code remove the error on draw method, but not in execute method: import sympy from qiskit.circuit import QuantumCircuit from qiskit.qasm import _node as node QuantumCircuit.definitions[""oneconst""] = { ""print"": False, ""opaque"": False, ""n_args"": 0, ""n_bits"": 1, ""args"": [], ""bits"": [""a""], # gate x a { u3(pi,0,pi) a; } ""body"": node.GateBody([ node.CustomUnitary([ node.Id(""u3"", 0, """"), node.ExpressionList([ node.Real(sympy.pi), node.Int(0), node.Real(sympy.pi) ]), node.PrimaryList([ node.Id(""a"", 0, """") ]) ]) ]) }",<programming><qiskit>,04/07/2019 09:48,5884.0,5884.0,"Did you add these lines to the file qiskit/extensions/standard/__init__.py: from .oneconst import oneconst from .oneconst import OneConstGate I did everything you described doing, as well as added those lines to __init__.py and the following code ran without error: import qiskit from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute from qiskit import Aer qr = QuantumRegister(1) cr = ClassicalRegister(1) gate = QuantumCircuit(qr, cr) gate.oneconst(qr[0]) gate.measure(qr[0], cr[0]) print(gate.draw()) backend = Aer.get_backend(""qasm_simulator"") job = execute(gate, backend, shots=100) print(job.result().get_counts(gate))",04/09/2019 17:49
5877.0,How do I do printf debugging in Q# in a convenient way?,"When initially writing an operator in Q#, I often want to see intermediate values of registers during the computation. This allows me to check that I haven't made mistakes. For example, if I was writing an addition circuit I would input a computational basis state and print out the computational basis states of qubits at particular key points. I am not aware of a way to do this conveniently. If I print out the qubits like Message($""{qubit}"") then I get their IDs instead of their values. That makes sense. I have to do a measurement to access their value. But if I do a measurement, then Q# will e.g. not automatically generate an adjoint operation and this tends to cause compilation failures. Also, I don't actually want to perform a measurement (which may have side effects) I just want to peek at the simulator state. (I originally thought I could package the concept of ""peeking"" at a value into an operation that did a hidden measurement, which would have resolved the issue. But Q# doesn't allow operations with an adjoint to have a return type.) Is there some built-in way to get at the computational basis value of some qubits, and print it to the console during simulation under the Toffoli simulator?",<programming><q#>,04/08/2019 20:19,5878.0,5878.0,"For Toffoli simulator in particular, DumpRegister will provide this information. For example, the following code operation XorTest() : Bool { using ((a, b) = (Qubit[2], Qubit[2])) { // initialize: a = 1, b = 2 ApplyPauli([PauliI, PauliX], a); ApplyPauli([PauliX, PauliI], b); // check initialization Message(""a = ""); DumpRegister((), a); Message(""b = ""); DumpRegister((), b); // calculate a â b and write it to b CNOT(a[0], b[0]); CNOT(a[1], b[1]); // check result: a â b = 3 Message(""a xor b = ""); DumpRegister((), b); } return true; } will print the following result (and throw an exception in the end because the qubits are released not in zero state): a = State: 0: False 1: True b = State: 2: True 3: False a xor b = State: 2: True 3: True The numbers before values are qubit ids.",04/09/2019 01:14
5901.0,How do you start a simulation with a random initial state in Cirq?,How do you create a random initial state by modifying the $2^{n}$ vector amplitudes instead of starting every simulation at $|0000...000\rangle$?,<programming><cirq>,04/12/2019 15:03,5902.0,5902.0,"If you want a random computational basis state, set the input state to the integer random.randint(0, 2**qubits-1). If you want a random superposition sampled from the Haar measure, there is a method cirq.testing.random_superposition(dim=2**qubits). Once you have created your initial state, you pass it into the simulator like cirq.Simulator().simulate(circuit, initial_state=...). Note that run methods do not support an initial state, because they are supposed to more closely mimic the hardware.",04/12/2019 15:50
5904.0,Experiment runtime on IBMQ,"I have been trying to get the runtime of my experiment on IBM's quantum computer. I am using the classic stuff, i.e job = execute(qwalk_circuit, backend='ibmq_16_melbourne', shots=1000) results = job.result() results.get_counts() print(results.data()) I saw on another post that you could see the runtime by using results.get_data(), but that doesnt work anymore, giving me an error that the get_data() attribute does not exist. Is there another way to pull the runtime of my experiment from IBM's quantum computer backend? My imports, in case I am missing something there: # importing QISKit from qiskit import Aer, IBMQ from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute from qiskit import IBMQ, BasicAer from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor",<programming><ibm-q-experience><ibm>,4/13/2019 10:22,9911.0,9911.0,"I was recently looking for a similar solution. Hope this helps. job = execute(qc, backend=backend, shots=1024) results = job.result() print(results.time_taken) You can also check all the values stored in result as it is a dictionary by printing it: print(results) Here you can check for all the information that is available within the dictionary and you can also observe the value for 'time_taken'",2/19/2020 15:37
5959.0,Grover's algorithm returns skewed probability distribution,"I wrote an implementation of Grover's algorithm that looks like this: from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute # Initialize circuit m_qubit = QuantumRegister(1) search_register = QuantumRegister(4) result_register = ClassicalRegister(4) ancillaries = QuantumRegister(3) circuit = QuantumCircuit(search_register, result_register, m_qubit, ancillaries) # Put M qubit into 1-superposition circuit.x(m_qubit) circuit.h(m_qubit) # Put search qubits into superposition circuit.h(search_register) for _ in range(2): # Encode S1 * !S2 * S3 circuit.x( search_register[2] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) circuit.x( search_register[2] ) # Encode S0 * S1 circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) # Encode oracle ((S0 * S1) + (S1 * !S2 * S3)) circuit.x(ancillaries) circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] ) circuit.x(ancillaries) circuit.x(m_qubit) # Reset ancillaries to be used later circuit.reset(ancillaries) # Do rotation about the average circuit.h(search_register) circuit.x(search_register) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] ) circuit.x(search_register) circuit.x(m_qubit) circuit.h(search_register) # Reset ancillaries for use later circuit.reset(ancillaries) circuit.measure(search_register, result_register) # Run the circuit with a given number of shots backend_sim = Aer.get_backend('qasm_simulator') job_sim = execute(circuit, backend_sim, shots = 1024) result_sim = job_sim.result() # get_counts returns a dictionary with the bit-strings as keys # and the number of times the string resulted as the value print(result_sim.get_counts(circuit)) Essentially, this circuit should search for any value that matches $X_1 X_2 X_3 + X_0 X_1$. When I do the math for this circuit I get the following: $$\frac{1}{1024 \sqrt{2}} \left( -304 \left( \sum_{x \in \{00, 01, 11\}} \left| x \right&gt; \left( \left|00\right&gt; + \left|01\right&gt; + \left|10\right&gt; \right) + \left|1000\right&gt; + \left|1001\right&gt; \right) + 80 \left( \sum_{x = 00}^{11} \left|x\right&gt; \left|11\right&gt; + \left|1010\right&gt; \right) \right) \left( \left|0\right&gt; - \left|1\right&gt; \right)$$ These amplitudes correspond to probabilities of $-\frac{{304}^{2}}{2({1024}^{2})} = -\frac{{19}^{2}}{2({64}^{2})}$ and $\frac{{80}^{2}}{2({1024}^{2})} = \frac{{5}^{2}}{2({64}^{2})}$ for the unsuccessful and successful probabilities, respectively. What I don't understand from this is how the successful outputs would appear over the unsuccessful ones, because the magnitude of the probability for the unsuccessful results is much higher. Can someone explain how the normalization is done in this case? Furthermore, these results do not obtain when I actually run the circuit. Instead of a step-function for the probabilities, when I run 1024 shots I tend to get between 30 and 50 for the unsuccessful results and the successful results are spread between 200 and 460. While it's obvious that the successful results have been selected, the spread is concerning because the math seems to indicate that they should be fairly close together. Moreover, the successful results always fall in the same order, which is also counter-intuitive given that results are probabilistic. This implies one of two things to me: The superposition isn't actually equal (i.e. there's some bias towards one value versus the other). However, this doesn't make sense as these results were obtained with a simulator so they should be very close to optimal. I have inadvertently entangled the qubits in such a way that the result is affected. Any insight into this would be greatly appreciated.",<programming><qiskit><measurement><grovers-algorithm>,4/23/2019 2:10,6083.0,6083.0,"It turns out the issue with this circuit was in the use of the reset operator in conjunction with entanglement and superposition. In the oracle code I submitted, I use a Toffoli gate several times, which creates an entanglement between both input qubits and the output qubit. Since the input qubits are in superposition, that superposition state then &quot;spreads&quot; (for lack of a better term) to the output qubit. So, when the output qubit is reset using the reset operator, its superposition state and entanglements with the input qubits causes certain states to collapse, which changes the output of the circuit as a whole. This had confused me earlier because using reset with either superposition or entanglement causes no issue, because both can collapse without change to the input; because, in a sense, the output and input qubits are separated. It is only, therefore, when they are used in conjunction that reset causes this behavior. The solution then, is quite simple: reverse the circuit to return the output qubit to a $\left|0\right&gt;$ state after it is no longer needed: # Encode S1 * !S2 * S3 circuit.x( search_register[2] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) # Encode S0 * S1 circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) # Encode oracle ((S0 * S1) + (S1 * !S2 * S3)) circuit.x(ancillaries) circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] ) circuit.x(m_qubit) # Return ancillaries to 0s so they can be used later circuit.x(ancillaries) circuit.ccx( search_register[0], search_register[1], ancillaries[2] ) circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[1], search_register[2], ancillaries[0] ) circuit.x( search_register[2] ) # Do rotation about the average circuit.h(search_register) circuit.x(search_register) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] ) circuit.x(search_register) circuit.x(m_qubit) # Return ancillaries to 0s for use later circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] ) circuit.ccx( search_register[0], search_register[1], ancillaries[0] ) circuit.h(search_register) Doing this instead produced the desired result.",05/07/2019 01:52
6364.0,About the Qiskit draw function,Where does Qiskit put the rendered figure created by circuit.draw(output='mpl')?,<programming><qiskit>,06/06/2019 14:40,6369.0,6369.0,"Qiskit does not save the rendered Figure of the circuit anywhere, unless you provide a filename to the call. For example: circuit.draw(filename='&lt;file_path&gt;'). In regards to having the Figure render and stay open, you simply need to remove a line of code. If you go to where qiskit is installed in your environment, go into the file qiskit/visualization/matplotlib.py, and go to line 436 you will see the line plt.close(self.figure). Comment this line out, and run your program again. You should see the Figure in a new window.",06/06/2019 19:30
6433.0,Perform quantum gate operations using state vectors and matrices,"I am getting confused as to how to perform gate operations using matrices and am hoping someone will help me walk through this example. Say I want to perform a Pauli-X gate on the 3rd qubit in a 3-qubit system. That operation would be: U = I â I â X Then say I have the state $|001\rangle$ so after applying U the state would become $|000\rangle$. I am trying to use Python and NumPy to calculate this but I believe I am missing something. i = np.array([[1, 0], [0, 1]]) x = np.array([[0, 1], [1, 0]]) state_0 = np.array([[1], [0]]) state_1 = np.array([[0], [1]]) x_3 = np.kron(np.kron(i,i),x) v = np.kron(np.kron(state_0, state_0), state_1) print(x_3.dot(v)) This code outputs: [[1] [0] [0] [0] [0] [0] [0] [0]] I am unsure if this output is correct and if it is how would I see this as the state $|000\rangle$? Any clarifications would be very useful! Thank you!",<programming><quantum-gate>,06/12/2019 20:33,6434.0,6434.0,"You can use the same tools you used to get this output to check that it is correct: the state $|000\rangle$ would be represented as tensor product $|0\rangle \otimes |0\rangle \otimes |0\rangle$, which in your Python notation would be np.kron(np.kron(state_0, state_0), state_0). This should give you the same column vector you got from running your code, with the first element 1 and the rest of them 0s.",06/12/2019 21:07
6629.0,Can a quantum computer run classical algorithms?,"I realize that fundamentally speaking quantum and classical computers might as well be apples and oranges, and that for very specific problems such as integer factorization with Shor's algorithm quantum computers blow conventional computers out of the water, but could a quantum computer run classical algorithms? If so, using a comparable classical computer, how would the calculation speed of a quantum computer running a classical algorithm compare to the calculation speed of the classical computer?",<classical-computing><classical-quantum>,6/29/2019 7:24,6630.0,6630.0,"Quantum computers can run classical computations using exactly the same algorithms, and hence have the same running time in terms of scaling. For example, if you look at shorâs algorithm, a major component of that is modular exponentiation, but nobody ever draws the circuit because they just say âuse the classical algorithmâ. In terms of absolute running time, that is heavily hardware dependant so you canât make comparisons so easily. Quantum computers offer the possibility of other algorithms in addition to the classical ones that could be faster, but thereâs no standard method for generating an improvement.",6/29/2019 9:42
6799.0,A quantum computer that doesn't use entangled qubits has the same computational power as a classical one?,Is the statement in the question correct? I would love to receive an explanation as to why it is or isn't. I have a computer science degree background and I am a beginner learning the fundamental of QC from scratch.,<classical-computing>,7/17/2019 22:07,6801.0,6801.0,"Assuming you are talking about starting from a pure state, your statement is true. There are two steps to the proof: Show that a system without entanglement can implement any classical computation. Show that a system that remains separable can be simulated by a classical computation, proving that there are no calculations it can implement that a classical computer cannot. The first is straightforward. Every classical computation can be written as a classical reversible computation. The Toffoli gate (controlled-controlled-not) is universal for classical reversible computation, so any circuit can be entirely decomposed in terms of that. But Quantum computers can implement the Toffoli gate, so they can implement any classical computation, and the state of the system at any intermediate point must be the same as in the classical computation, and therefore separable. The second is also reasonably straightforward. If we know that every qubit remains separable, then we can hold in memory just the set of $N$ qubit states, comprising $N$ 2-element normalised complex vectors (as compared to the general case of a single $2^N$ element normalised complex vector). Whatever set of gates we use to describe the computation will act on some finite number of qubits, say $k$ at maximum (independent of $N$). So each computational step requires the action of a $2^k\times 2^k$ matrix, which we just have to apply to the appropriate set of $k$ separable states. We extract the separable states at the end, and continue. The total simulation time is $O(NM)$ for a sequence of $M$ gates on a classical computer.",7/18/2019 6:42
6940.0,How to calculate an Expected Value of some operator acting on qubits?,"I'm trying to implement the Variational Quantum Eigensolver in Qiskit. Suppose, I have an operator $A = \sigma_1^z\sigma_2^z$ acting on some two-qubit state $|\psi\rangle$. After a measurement I get a set of probabilities corresponding to states $|00\rangle$, $|01\rangle$, $|10\rangle$, $|11\rangle$. My question is: How to calculate $\langle\psi|A|\psi\rangle$ using known set of probabilities?",<programming><qiskit><measurement><textbook-and-exercises><vqe>,08/04/2019 12:05,6944.0,6944.0,"Qiskit currently supports measurements in the computational basis from Qiskit Terra and Aer, that is, returning 1 if the qubit is in state $|1\rangle$, and 0 if the qubit is measured to be in state $|0\rangle$. However, it is relatively easy to perform a change of basis unitary to our quantum circuit just prior to measurement, in order to instead measure in the eigenbasis of an arbitrary operator $A$: First, we need to compute the eigendecomposition of our Hermitian observable $A|v_i\rangle=\lambda_i|v_i\rangle$. Since $A$ is Hermitian, we are always able to diagonalize $A$ in this eigenbasis: $$A = \sum_{i}\lambda_i |v_i\rangle \langle v_i|= U^\dagger \Lambda U$$ where $\Lambda = \text{diag}(\lambda_1,\dots,\lambda_n)$ and $U$ is a unitary matrix composed of the eigenvectors down the columns. Next, we apply the unitary operation $U$ to the end of our quantum circuit, using qc.unitary. To see why, note that $$\langle\psi|A|\psi\rangle = \langle\psi|U^\dagger \Lambda U|\psi\rangle = \langle\psi'|\Lambda|\psi'\rangle $$ where $|\psi'\rangle = U|\psi\rangle.$ Since $\Lambda$ is diagonal, we have transformed the problem from one where we must perform a measurement in an arbitrary basis, to one where we simply measure in the computational basis. Finally, we measure the state $|\psi'\rangle$ in the computational basis $|i \rangle$ using qc.measure(q, c), and execute the jobs to get the counts and probabilities $\mathbb{P}_i = |\langle i|\psi'\rangle|^2$. Using the previously computed eigenvalues of $A$, we can now reconstruct the expectation value: $$\langle \psi | A | \psi\rangle = \langle\psi'|\Lambda|\psi'\rangle = \sum_i \langle\psi'|i\rangle \langle i | \Lambda | i\rangle \langle i|\psi'\rangle = \sum_i \lambda_i \mathbb{P}_i$$ For example, shots = result.results[0].shots counts = result.get_counts() probs = sorted([(i, c/shots) for i, c in counts.items()]) P = np.float64(np.array(probs)[:, 1]) A_expectation = lambda @ p For a more high-level interface to coding and running variational quantum algorithms, you can also check out the PennyLane Python library, which has a Qiskit plugin available for using Qiskit simulators and IBM hardware as a backend. For example, a expectation values of arbitrary operators in PennyLane using qiskit looks like this: import pennylane as qml dev = qml.device('qiskit.basicaer', wires=2) # use 'qiskit.ibm' instead to run on hardware @qml.qnode(dev) def circuit(x, y, z): qml.RX(x, wires=0) qml.RY(y, wires=1) qml.RZ(z, wires=0) qml.CNOT(wires=[0, 1]) return qml.expval(qml.Hermitian(A, wires=[0, 1])) def cost(x, y, z): return (1-circuit(x, y, z))**2 # optimization follows You can use NumPy, TensorFlow, or PyTorch to do the optimization - check out some of the tutorials. Disclaimer: I am one of the developers on PennyLane.",08/05/2019 05:21
8244.0,Big Endian vs. Little Endian in Qiskit,I've noticed that Q# favors Little Endian. Meaning that most operations are designed for this type of encoding. Is is it the same with Qiskit?,<programming><qiskit><q#>,09/12/2019 15:34,8370.0,8370.0,"Qiskit uses little-endian for both classical bit ordering and qubit ordering. For classical bits: A 3-bit classical register creg with value abc has creg[0]=c, creg[1]=b, creg[2]=a. For qubits: The ordering is with respect to the tensor-product structure of the state space. So a 3-qubit quantum register qreg with wave-function $|\psi\rangle = |A\otimes B\otimes C\rangle = |ABC\rangle$ has qreg[0]$= |C\rangle$, qreg[1]$= |B\rangle$, qreg[2]$= |A\rangle$. Similarly for representing unitary matrices of a circuit. $U = U_A \otimes U_B \otimes U_C = U_A U_B U_C$ would have $U_C$ acting on qreg[0], $U_B$ acting on qreg[1] and $U_A$ acting on qreg[2].",9/30/2019 17:40
8269.0,Backend Warning: The skip Qobj validation does not work for IBMQ provider. Disable it,"I am using QAOA to solve the max-cut problem. On my machine, 10 qubits already takes a minute or two to simulate. I'm hoping that the ibmq-qasm-simulator could simulate 32 qubits faster than my laptop would. Here's my code: After loading in my IBMQ token and such... optimizer = COBYLA() # Simulate using IBM's cloud service backend = provider.get_backend('ibmq_qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1) part_array = part.values w = calc_w(part_array) # Calculate pairwise distances between points # Execute algorithm qubit_ops, offset = max_cut.get_max_cut_qubitops(w) qaoa = QAOA(qubit_ops, optimizer, p) result = qaoa.run(quantum_instance) While the code runs a message in red (like a warning but without ""Warning:"") displays saying, ""The skip Qobj validation does not work for IBMQ provider. Disable it."" How do I do what this message is asking?",<programming><qiskit><ibm-q-experience><qaoa>,9/19/2019 0:43,8271.0,8271.0,"There is a parameter when instantiating a QuantumInstance() called skip_qobj_validation. This parameter is set to True by default. When creating the QuantumInstance, you can set it to False, and that will get rid of the warning. q_instance = QuantumInstace(skip_qobj_validation=False)",9/19/2019 14:14
8299.0,Running jobs on different backends at the same time,"qr = QuantumRegister(2,'qr') cr = ClassicalRegister(2,'cr') circ = QuantumCircuit(qr,cr) circ.x(qr[0]) circ.measure(qr,cr) provider = IBMQ.get_provider(group = 'open') backends = provider.get_backend(['ibmqx2', 'ibmq_16_melbourne', 'ibmq_vigo', 'ibmq_ourense']) job = execute(circ, backend=backends, shots=1024) job_monitor(job, interval = 5) result = job.result() counts = result.get_counts(circ) plot_histogram(counts) How do I run my quantum code on more than one backend at the same time?",<programming><qiskit><ibm-q-experience>,9/23/2019 18:59,8307.0,8307.0,"You would need to send a job to each backend you want to run on. For example, if you wanted to send to ibmqx2 and ibmq_ourense you could execute code similar to this: backend_1 = provider.get_backend('ibmqx2') backend_2 = provider.get_backend('ibmq_ourense') job_1 = execute(circuit, backend_1) # Sends a job to run on ibmqx2 job_2 = execute(circuit, backend_2) # Sends a job to run on ibmq_ourense You can then get the results from each job normally: result_1 = job_1.result().get_counts(circuit) result_2 = job_2.result().get_counts(circuit)",9/24/2019 13:36
8304.0,How to unpickle a Result object returned by an IBMQ experiment?,"I have executed an experiment using IBMQ and receive a Result object. I am writing the ASCII repr of the result with f.write(res) into a file and see a line like Result(backend_name='ibmq_16_melbourne', backend_version='1.1.0',... How can I reconstruct the Result object from that line? Which methods do I have to call?",<programming><qiskit><ibm-q-experience>,9/24/2019 10:34,8306.0,8306.0,I found a solution: to serialise instead of print(res) I need to do: print(res.to_dict()) To load the serialized string (eg. line from a file) dict = eval(line) res = Result.from_dict(dict) all of the above with from qiskit.result import Result,9/24/2019 12:51
8308.0,How many classical registers are there on (IBM) quantum computers?,I have a circuit where I only use 3 qubits but need to utilize hundreds of classical registers. My questions are: what is the maximum number of classical bits on the current IBM Qs? What is the quantum computer with the highest number of classical bits right now that is available for researchers and the public?,<programming><qiskit><ibm-q-experience>,9/25/2019 5:59,8309.0,8309.0,"As far as I am aware you can have as many ClassicalRegisters as you need, assuming they fit in the memory of the classical device controlling the Quantum Computer. I would suggest trying to reuse them if possible if you are concerned about this!",9/25/2019 7:18
8388.0,How can classical computations be non-unitary?,"Given that classical physics emerges from quantum physics on a macroscopic scale, and all quantum operators are unitary, how are we able to perform non-unitary operations (such as setting a register to zero) in classical computation? I suspect that unitarity must be preserved because information leaks to the environment as heat. However if this is the case, it begs a second question, why can quantum computers not 'simply' leak information to the environment as a hack to allow non-unitary transformations?",<classical-computing><unitarity>,10/02/2019 22:17,8391.0,8391.0,"Quantum computers can leak information to the environment in order to perform non-unitary transformations. The problem is that this irreversibly entangles the computer's state with the environment, i.e. it is equivalent to measuring the qubits that were leaked. This will collapse the state of the computer and prevent the interference effects that are needed if you want to do a quantum computation that's not secretly just a classical computation.",10/03/2019 05:30
8505.0,How to prepare a specific initial state of three qubits?,I would like to prepare the following initial state for variational quantum algorithms: $$ \sin\theta_1 \sin\theta_2 \sin\theta_3 |000\rangle + \sin\theta_1 \sin\theta_2 \cos\theta_3 |001\rangle + \sin\theta_1 \cos\theta_2 |010\rangle + \cos\theta_1 |100 \rangle. $$ Should I make a circuit for this state from scratch? Or is there any library to find a circuit to make this state such as Cirq or Qiskit?,<programming><qiskit><cirq>,10/17/2019 8:43,8509.0,8509.0,"If you call initialize in this case, you will be specifying a general state in $\mathbb{C}^8$. However what you have is more specialized. For example only having 4 nonzero amplitudes. So the call to initialize won't know this a priori. So it won't realize the initialization circuit can be decomposed easily. Or at least it will need to do some extra simplification steps before realizing this. I'm going to change $\sin$ and $\cos$ from your state. You can fix this by changing the angles with appropriate angle redefinitions. $\theta \to \frac{\pi}{2}-\theta$. $$ | \psi_1 \rangle = (\mathrm{R}(\theta_1) \otimes I_4) | 0 0 0 \rangle = \cos \theta_1 | 0 0 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\ | \psi_2 \rangle = (\mathrm{CR}(0,\theta_2) \otimes I_2) | \psi_1 \rangle = \cos \theta_1 \cos \theta_2 | 0 0 0 \rangle + \cos \theta_1 \sin \theta_2 | 0 1 0 \rangle + \sin \theta_1 | 1 0 0 \rangle\\ | \psi \rangle = \mathrm{CCR}(00,\theta_3) | \psi_2 \rangle $$ where $\mathrm{R}(\theta)$ is to indicate a 2 by 2 rotation matrix. $\mathrm{CR}(0,\theta)$ is to indicate controlled $\mathrm{R}(\theta)$ on the second index but controlled on 0 instead of 1 on the first. $\mathrm{CCR}(00,\theta)$ is to indicate controlled $\mathrm{R}(\theta)$ on the third index but controlled on 00 instead of 11 on the first two. You should be able to fix the angles and get the controls back to normal from here.",10/17/2019 15:18
8837.0,Which algorithm in quantum computing can be implemented for a HPC system?,"I am new to quantum computing and I wanted to do a project for one of my classes where I study a specific algorithm from the field and then insert parallelism in it so it can be executed more efficiently on a cluster i.e., high-performance computing (HPC) system. I would appreciate any suggestions which algorithm should I pursue to implement, as well as any resources available to study its background. Thanks in advance!",<algorithm><programming><quantum-parallelism>,11/18/2019 13:14,8915.0,8915.0,"If I understand you correctly, your goal is: To choose some quantum algorithm (your question is: which algorithm would be good?) Instead of running the quantum algorithm on a real quantum computer, you want to run a simulation of a quantum computer on a classical computer to simulate the execution of the quantum algorithm. You want to optimize your classical simulator to make efficient use of the special capabilities offered by a High Performance Cluster (e.g. parallelism) and demonstrate that the simulation runs faster. If so, it really does not matter which quantum algorithm you choose, as long as it involves many qubits and many gates. You are probably best off choosing some very well-known algorithm that is well described in the literature, e.g. Grover or Shor. Your simulation will involve multiplying very large matrices with each other. The more qubits, the larger the matrices. The growth is exponential: if you have $N$ qubits, you will be multiplying $2^N$ by $2^N$ matrices. The more gates, the more multiplications. You will make life easier on yourself if you assume the qubits are perfect (no noise, no errors). Since the main point of your exercise is to parallelize some code for an HPC, it probably doesn't matter that the simulation is less realistic.",11/24/2019 7:49
8844.0,ImportError: cannot import name 'matplotlib_circuit_drawer',"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from qiskit.tools.visualization import matplotlib_circuit_drawer as drawer from qiskit import Aer from qiskit import execute import numpy as np %matplotlib inline This is the code cell that I am trying to implement. The error is in the second line. Error--&gt; ImportError: cannot import name 'matplotlib_circuit_drawer' I'm using Google Colab to execute the code. How to solve this?",<programming><qiskit>,11/19/2019 6:53,8845.0,8845.0,"qiskit.tools.visualization has been moved to qiskit.visualization and matplotlib_circuit_drawer has been removed. Instead of using it, try using qiskit.visualization.circuit_drawer() with the appropriate arguments. So in this case it should be qiskit.visualization.circuit_drawer(my_circuit, output='mpl', filename='my_circuit.png')",11/19/2019 7:23
8883.0,Moments-based quantum circuit in Cirq,"In Cirq, quantum circuit consists of moments, which in turn consists of operations. This is different from Qiskit/OpenQASM, which doesnât have the concept of moments. What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it? As a result of moments, one can insert operations in different moments using different insert strategies. It seems to me the earliest insert strategy is always preferred, which is the same as Qiskit/OpenQASM. What are the use cases for different insert strategies?",<programming><cirq>,11/21/2019 10:09,8891.0,8891.0,"What is the design philosophy behind the moment-based quantum circuit? What are the advantages and disadvantages of it? The basic idea is that we wanted to give users more control over what will actually happen on hardware. Whether or not two gates are run in parallel is really important information when dealing with noise (e.g. it determines total runtime), so it's important for users to be able to determine-whether that's happening and also control-if that's happening. The philosophy of giving more control isn't limited to moments. Cirq also requires users to specify specific qubits (no implicit placement), and to use the native gateset of whatever device they are targeting (no implicit decomposition). The important thing is that you should be able to have a clear concrete idea of what will actually happen on the device. Cirq also has the concept of a ""schedule"", which has even more control over timing. But ironically we've found that users don't want to use it, and programmers don't like consuming it. So we're actually cutting that next version. The list-of-moments structure seems to be a nice sweet spot in terms of flexibility, ease of production, and ease of consumption. You can certainly put the abstraction boundary in other places, but that's where we've found ourselves pulled towards. It seems to me the earliest insert strategy is always preferred It's a good rule of thumb, which is why it's the default. But it's not always optimal. For example, hardware may perform best when circuits are stratified into layers of single-qubit gates and layers of two-qubit gates (but never a layer with both single and two qubit gates). So even if you can move a single qubit operation earlier, that may result in it being in the same layer as two qubit operations. Moving it would not be a fatal mistake, the circuit would still run, but it might be slightly noisier. There are lots of ""little things"" like that when dealing with hardware.",11/21/2019 19:36
8893.0,Why is the order reversed on measurement?,"Why is the order reversed on measurement? from qiskit import( QuantumCircuit, execute, Aer) from qiskit.visualization import plot_histogram # Use Aer's qasm_simulator simulator = Aer.get_backend('qasm_simulator') # Create a Quantum Circuit acting on the q register circuit = QuantumCircuit(3, 3) # Add a X gate on qubit 0 circuit.x(0) # Add a CX (CNOT) gate on control qubit 0 and target qubit 1 circuit.cx(0, 1) circuit.barrier() # Map the quantum measurement to the classical bits circuit.measure([0,1,2], [0,1,2]) # Execute the circuit on the qasm simulator job = execute(circuit, simulator, shots=1000) # Grab results from the job result = job.result() # Returns counts counts = result.get_counts(circuit) print(""\nTotal count:"",counts) # Draw the circuit circuit.draw() Got result: Total count for 00 and 11 are: {'011': 1000} But I'm expecting '110'.",<quantum-gate><programming><qiskit>,11/21/2019 21:23,8894.0,8894.0,"I still run into this issue too. If you consider $|q0\rangle$ to be the most significant bit (MSB) you have to map it to the most significant classical bit as well, which is in your case a bit no. 2. Or you can flip your quatnum circuit upside down and then $|q0\rangle$ become the least significant bit (LSB) and the measurement will meet your expectation. A code circuit.measure([0,1,2], [0,1,2]) is valid in case $|q0\rangle$ is LSB and circuit.measure([0,1,2], [2,1,0]) in case $|q0\rangle$ is MSB. I think that the reason for this arrangement is simply a convention, so you can choose whether $|q0\rangle$ is MSB or LSB and set the measurement procedure accordingly.",11/21/2019 22:39
9522.0,Logical Explanation behind second reflection in Grover's algorithm,"Logically, what does the second reflection in Grover's algorithm do? I currently don't have a lot of background in linear algebra so I'm failing to understand what exactly its purpose is and what it does.",<algorithm><programming><grovers-algorithm>,1/13/2020 18:40,9527.0,9527.0,"An application of the reflection operator change each amplitude of a basis state $ |i\rangle$ by $$ \alpha_i \rightarrow- \alpha_i + 2 \langle\alpha\rangle\ $$ where $ \langle\alpha\rangle\ $ is the average of all amplitudes. It follows the oracle which is use to ""mark"" the seeked elements $ |i\rangle$. Say for instance that you have 8 elements, so you work on 3 qubits and you want to output $ |011\rangle$ with high probability. At the beginning, each basis state has $\frac{1}{8}$ probability to be measured as their amplitude are $\frac{1}{\sqrt{8}}$. The oracle first will mark $ |011\rangle$, so its amplitude will be $-\frac{1}{\sqrt{8}} = -\frac{1}{2\sqrt{2}}$. $$ \langle\alpha\rangle\ = \frac{1}{8} (7* \frac{1}{\sqrt{8}} - \frac{1}{\sqrt{8}}) = \frac{6}{8\sqrt{8}} = \frac{3}{8\sqrt{2}}$$ So the amplitude of $ |011\rangle$ after the reflection operator becomes $$ - (-\frac{1}{2\sqrt{2}}) + 2\langle\alpha\rangle\ = \frac{5}{4\sqrt{2}} $$ while others will have a new amplitude: $$ - (\frac{1}{2\sqrt{2}}) + 2*\frac{3}{8\sqrt{2}} = \frac{1}{4\sqrt{2}}$$ If you square those amplitudes, then $ |011\rangle$ has $\frac{25}{32} \approx 0.78 &gt; \frac{1}{8}$ probability to be measured, while another state will have $\frac{1}{32}$ probability to be measured. You see the probability of the solution to be outputed increased while non-solutions less likely to be.",1/13/2020 23:16
9641.0,How is quantum error applied to the qubits?,"I am trying to check the way qiskit has the noise implemented. I have read how is this theoretically done using quantum channels (see Nielsen and Chuang chapter 8) and I want to verify if qiskit follows the same procedure. I have started by the bit-flip error using the pauli_error function. Finally it creates a quantum error object which can be added to the NoiseModel object. However when adding this you have to use the add_all_qubit_quantum_error function and I do not really understand how this works. It is supposed to add the quantum error to all qubits when given a set of gates as an argument, as in the following example: # Example error probabilities p_reset = 0.03 p_meas = 0.1 p_gate1 = 0.05 # QuantumError objects error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)]) error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)]) error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)]) error_gate2 = error_gate1.tensor(error_gate1) # Add errors to noise model noise_bit_flip = NoiseModel() noise_bit_flip.add_all_qubit_quantum_error(error_reset, ""reset"") noise_bit_flip.add_all_qubit_quantum_error(error_meas, ""measure"") noise_bit_flip.add_all_qubit_quantum_error(error_gate1, [""u1"", ""u2"", ""u3""]) noise_bit_flip.add_all_qubit_quantum_error(error_gate2, [""cx""]) print(noise_bit_flip) However I do not know when the bit-flit is applied. Is it applied everytime one gate that can be decomposed in any of the ones of the list [""u1"", ""u2"", ""u3""]? What I need to know is how often it is applied and with which criterion. Thank you for your help!",<qiskit><programming><noise>,1/25/2020 9:22,9653.0,9653.0,"Qiskit simulator behaves like this for your code snippet: whenever it encounters one of u1, u2, or u3 gates (in the compiled circuit), it first applies the gate; then it performs an X gate according to the provided probability (0.05 in our case).",1/26/2020 9:05
9748.0,How to encode eigenvalues of matrix $A$ in solving $A\vec{x} = \vec{b}$ using the HHL Algorithm,"I am trying to implement multiple parallel subroutines of HHL algorithm, each working on a different set of matrix $A$ (when solving for $x$, in $A\vec{x} = \vec{b}$), to find the expectation values of $|x\rangle$. The matrix $A$ is randomly generated Hermitian matrix, and may/may not be sparse (checking what happens, is also something I'm wondering). I have the following queries: If I understand correctly, I need to encode eigenvalues of a $2 \times 2$ matrix $A$, say $\lambda_1$ and $\lambda_2$ in the quantum register. Is that right? How do I do that? Is the quantum register initialized with the binary values of $\lambda_1$ and $\lambda_2$? Does that mean 2 runs of HHL? Is finding Eigenvalues of matrix $A$ supposed to be a classical subroutine?",<algorithm><programming><hhl-algorithm>,02/06/2020 04:02,9757.0,9757.0,"Finding the eigenvalues of $A$ is an intermediate part of the HHL algorithm (although it will not output them). It is a quantum routine known as phase estimation, for which you need to be able to implement a controlled-unitary evolution where the unitary is determined by $U=e^{iAt}$ for some $t$. You do not need to find them by any classical routine. However, you do need some prior information: a bound on the range that the eigenvalues can occupy (this determines the $t$ in the previous relation), and a bound on how close to zero these eigenvalues might be (this determines how large a register you need for performing the phase estimation).",02/06/2020 12:29
9951.0,Is there anything that can be programmed on a classical computer but not on a quantum computer?,Would we need to create new algorithms that only work on quantum computers or would be simply edit codes in languages such as C++ to involve the new primitives from quantum computing? Are there things that can be programmed on a classical computer that canât be programmed ona. Quantum computer? I know that quantum computer are turing complete.,<algorithm><classical-computing>,2/23/2020 18:14,9954.0,9954.0,"Short answer: no. Any classical algorithm can be transformed into quantum algorithm. This result has little practical value, because you don't obtain quantum speedup, but it is important from theoretical point of view.",2/23/2020 18:58
9957.0,IBMQ: `from qiskit import QISKitError` gives 'cannot import name QISKitError',When I run: from qiskit import QISKitError I get the error: ImportError: cannot import name 'QISKitError' I need QISKitError for exception handling with my program. Did IBMQ recently update this import?,<qiskit><programming><ibm-q-experience>,2/23/2020 21:43,9958.0,9958.0,This has been moved to from qiskit.exceptions import QiskitError,2/23/2020 22:26
9967.0,How to use external .csv data file in quantum support vector machine qiskit python code?,"I am new to python programming and Qiskit. I would like to ask can we use sklearn for adding external .csv data file before Qiskit libraries, or without sklearn, we can do or is there any other Qiskit library to add any external .csv file, to run the python code of quantum support vector machine? How I can use .csv data file with Qiskit libraries to run quantum SVM ? I am following the code written below, where I should put my own .csv data file import numpy as np from dataset import breast_cancer from sklearn.datasets.samples_generator import make_blobs from qiskit.aqua.utils import split_dataset_to_data_and_labels from sklearn import svm from utils import svm_utils from matplotlib import pyplot as plt #matplotlib inline #load_ext autoreload #autoreload 2 % Breast Cancer dataset n = 2 # number of principal components kept training_dataset_size = 20 testing_dataset_size = 10 sample_Total, training_input, test_input, class_labels = breast_cancer(training_dataset_size, testing_dataset_size, n) data_train, _ = split_dataset_to_data_and_labels(training_input) data_test, _ = split_dataset_to_data_and_labels(test_input) # %%Breast Cancer dataset ##%% Linear Support vector machine # We use the function of scikit learn to generate linearly separable blobs centers = [(2.5,0),(0,2.5)] x, y = make_blobs(n_samples=100, centers=centers, n_features=2,random_state=0,cluster_std=0.5) fig,ax=plt.subplots(1,2,figsize=(10,5)) ax[0].scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1]) ax[0].set_title('Breast Cancer dataset'); ax[1].scatter(x[:,0],x[:,1],c=y) ax[1].set_title('Blobs linearly separable'); ##%% Hands-on session on support vector machine plt.scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1]) plt.title('Breast Cancer dataset'); model= svm.LinearSVC() model.fit(data_train[0], data_train[1]) accuracy_train = model.score(data_train[0], data_train[1]) accuracy_test = model.score(data_test[0], data_test[1]) X0, X1 = data_train[0][:, 0], data_train[0][:, 1] xx, yy = svm_utils.make_meshgrid(X0, X1) Z = model.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) fig,ax=plt.subplots(1,2,figsize=(15,5)) ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1]) ax[0].set_title('Accuracy on the training set: '+str(accuracy_train)); ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1]) ax[1].set_title('Accuracy on the test set: '+str(accuracy_test)); ##%% We now implement a SVM with gaussian kernel clf = svm.SVC(gamma = 'scale') clf.fit(data_train[0], data_train[1]); accuracy_train = clf.score(data_train[0], data_train[1]) accuracy_test = clf.score(data_test[0], data_test[1]) X0, X1 = data_train[0][:, 0], data_train[0][:, 1] xx, yy = svm_utils.make_meshgrid(X0, X1) Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) fig,ax=plt.subplots(1,2,figsize=(15,5)) ax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1]) ax[0].set_title('Accuracy on the training set: '+str(accuracy_train)); ax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm) ax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1]) ax[1].set_title('Accuracy on the test set: '+str(accuracy_test)); ##%% First steps in Qiskit import qiskit as qk # Creating Qubits q = qk.QuantumRegister(2) # Creating Classical Bits c = qk.ClassicalRegister(2) ##%% Define and print empty circuit circuit = qk.QuantumCircuit(q, c) print(circuit) ##%%% Add gates to the qubits # Initialize empty circuit circuit = qk.QuantumCircuit(q, c) # Hadamard Gate on the first Qubit circuit.h(q[0]) # CNOT Gate on the first and second Qubits circuit.cx(q[0], q[1]) # Measuring the Qubits circuit.measure(q, c) print (circuit) ##%% Run the circuit on the quantum simulator # Using Qiskit Aer's Qasm Simulator: Define where do you want to run the simulation. simulator = qk.BasicAer.get_backend('qasm_simulator') # Simulating the circuit using the simulator to get the result job = qk.execute(circuit, simulator, shots=100) result = job.result() # Getting the aggregated binary outcomes of the circuit. counts = result.get_counts(circuit) print (counts) from qiskit.aqua.components.feature_maps import SecondOrderExpansion feature_map = SecondOrderExpansion(feature_dimension=2, depth=1) ##%%Print the feature map circuit x = np.array([0.6, 0.3]) print(feature_map.construct_circuit(x)) ##%%% QSVM Algorithm from qiskit.aqua.algorithms import QSVM qsvm = QSVM(feature_map, training_input, test_input) ##%% Run QSVM from qiskit.aqua import run_algorithm, QuantumInstance from qiskit import BasicAer backend = BasicAer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=10598, seed_transpiler=10598) result = qsvm.run(quantum_instance) ##%%% Analyze output plt.scatter(training_input['Benign'][:,0], training_input['Benign'][:,1]) plt.scatter(training_input['Malignant'][:,0], training_input['Malignant'][:,1]) plt.show() length_data = len(training_input['Benign']) + len(training_input['Malignant']) print(""size training set: {}"".format(length_data)) print(""Matrix dimension: {}"".format(result['kernel_matrix_training'].shape)) print(""testing success ratio: "", result['testing_accuracy']) test_set = np.concatenate((test_input['Benign'], test_input['Malignant'])) y_test = qsvm.predict(test_set, quantum_instance) ##%% And here we plot the results. The first plot shows the label predictions of the QSVM and the second plot shows the test labels. plt.scatter(test_set[:, 0], test_set[:,1], c=y_test) plt.show() plt.scatter(test_input['Benign'][:,0], test_input['Benign'][:,1]) plt.scatter(test_input['Malignant'][:,0], test_input['Malignant'][:,1]) plt.show()",<algorithm><qiskit><programming>,2/24/2020 15:24,9968.0,9968.0,"I have previously used this function to load a custom data set - it should still work but I haven't tried it with more recent releases of Aqua def userDefinedData(location, file, class_labels,training_size, test_size, n=2, PLOT_DATA=True): data, target, target_names = load_data(location, file) # sample_train is of the same form as data sample_train, sample_test, label_train, label_test = train_test_split( data, target,test_size=0.25, train_size=0.75 ,random_state=22) # Now we standarize for gaussian around 0 with unit variance std_scale = StandardScaler().fit(sample_train) sample_train = std_scale.transform(sample_train) sample_test = std_scale.transform(sample_test) # Now reduce number of features to number of qubits pca = PCA(n_components=n).fit(sample_train) sample_train = pca.transform(sample_train) sample_test = pca.transform(sample_test) # Samples are pairs of points samples = np.append(sample_train, sample_test, axis=0) minmax_scale = MinMaxScaler((-1, 1)).fit(samples) sample_train = minmax_scale.transform(sample_train) sample_test = minmax_scale.transform(sample_test) # If class labels are numeric if class_labels[0].isdigit(): # Pick training size number of samples from each distro training_input = {key: (sample_train[label_train == int(key), :])[:training_size] for k, key in enumerate(class_labels)} test_input = {key: (sample_test[label_test == int(key), :])[: test_size] for k, key in enumerate(class_labels)} else: # if they aren't training_input = {key: (sample_train[label_train == k, :])[:training_size] for k, key in enumerate(class_labels)} test_input = {key: (sample_train[label_train == k, :])[training_size:( training_size + test_size)] for k, key in enumerate(class_labels)} if PLOT_DATA: for k in range(0, 9): plt.scatter(sample_train[label_train == k, 0][:training_size], sample_train[label_train == k, 1][:training_size]) plt.title(""PCA dim. reduced user dataset"") plt.show() return sample_train, training_input, test_input, class_labels",2/24/2020 15:37
9976.0,Will quantum computers pass the Turing test?,Will quantum computers be able to pass the Turing test sooner than classical computers?,<classical-computing><quantum-turing-machine>,2/24/2020 18:47,9982.0,9982.0,"I think a better phrasing to this question is - will cloud access to a quantum computer enable a classical computer to pass the Turing test sooner than a classical computer with no such access? A quantum computer ""alone"" is very unlikely to pass the Turing test earlier than the above mentioned device, since quantum computers have technical difficulties performing large-scale simple tasks (e.g. multiply two 2048-digit numbers). Our usage of quantum computers relies on their ability to perform very specific tasks that are out of reach for classical computers. In order to pass the Turing test, the computer needs to be able to cover an extremely wide variety of tasks; there is no reason to assume a quantum computer will be better than a classical computer in such a wide variety. So the question remains - will cloud access to a quantum computer help with passing the Turing test? Here we can only speculate as well. For example, one can guess that good machine learning capabilities are essential to passing the Turing test (since you need to be able to tell the difference between a picture of a cat and a picture of a dog), and we hope that quantum computers will help us with machine learning. But this is still only in the realm of speculation. My personal guess: Yes, it will help. But only because we have many years ahead of us until a computer passes the Turing test, and I believe(/hope/dream) that quantum computing will mature by then.",2/25/2020 8:37
9996.0,How to read the elements of a circuit in qiskit?,"I would like to know if there is a way to read the elements of a circuit. What I mean is if I have a QuantumCircuit object, can I obtain the gates that are applied to each qubit in order? I would like to implement certain noise gate after each Hadamard and I would have therefore to identify each Hadamard in the QuantumCircuit object. So I need a function that gives me all the gates in a circuit and that allows me to modificate what it returns so I can construct a modified quantum circuit.",<quantum-gate><qiskit><programming>,2/26/2020 14:45,10013.0,10013.0,You can play with the circuit's data. First write: print(circ.data) or from pprint import pprint pprint(vars(circ.data)) Then you'll understand the structure and how to modify it.,2/27/2020 6:46
10006.0,How do I know in which state the qubit is in each step of the circuit for the simulator in qiskit?,"I would like to know how to know in which state a qubit is (I am talking about single-qubit errors), because in order to apply a non unitary gate in the simulator I have to renormalize the state or the corresponding non unitary Kraus operator (the non unitary gate in my circuit). Therefore I need to know in which state the circuit it. I am of course talking about the simulator, which in fact is classical and therefore it must be a way to know the state at each point of the circuit.",<quantum-gate><qiskit><programming><noise>,2/26/2020 17:51,10008.0,10008.0,"You can take snapshots of the statevector of the circuit when you use the 'qasm_simulator'. You simply append snapshot instructions into your circuit where you would like to see the statevector, and then can see the values in the result object that is returned. You add a snapshot instruction using from qiskit.extensions.simulator import snapshot qc.snapshot('my_label')",2/26/2020 18:03
10092.0,What do the numbers of the operation object in QuantumCircuit.data outputs?,"When you have a quantum circuit and use QuantumCircuit.data you get a list with objects of this type (this is the one for a X gate acting on qubit 0 y a 2 qubits Quantum Circuit): (qiskit.extensions.standard.x.XGate object at 0x0000019B8DEC2EB8, [Qubit(QuantumRegister(2, 'q'), 0)], []) The first element represents the operation. What does the sequence of digits 0x0000019B8DEC2EB8 mean? I suppose it has something to do with the location or the time, but I do not know how to obtain each digit. I need to know exactly how to reproduce one of these sequences myself. Thank you so much in advance.",<qiskit><programming>,03/04/2020 18:30,10093.0,10093.0,"That is the address in memory (represented as a hexademical number) of that specific gate object. It can be used to differentiate that specific X gate object from a different X gate object. Other than that it general is not useful, and it's definitely not something you would ever need to manually reproduce.",03/04/2020 19:04
10109.0,How to calculate the Von Neuman entropy on qiskit with the module quantum_info?,"I am trying to wrap my head around he quantum_info module on qiskit, since most of the functions on qiskit.tools are going to be deprecated, but I am very confused with the Statevector and DensityMatrix objects. For example, with this snippet of code: simulator = BasicAer.get_backend('statevector_simulator') # the device to run on result6 = execute(circuit6, simulator).result() outputstate6 = result6.get_statevector(circuit6, decimals=3) probability = np.abs(np.array(outputstate6))**2 outstatevector=quantum_info.states.Statevector(outputstate6) print(type(outstatevector)) print(type(outputstate6)) print(outputstate6) print(quantum_info.entropy(outputstate6)) I get: &lt;class 'qiskit.quantum_info.states.statevector.Statevector'&gt; &lt;class 'numpy.ndarray'&gt; [0.447+0.j 0. +0.j 0.632+0.j 0.632+0.j] as expected but then I get the error on quantum_info.entropy(outputstate6): QiskitError: 'Input quantum state is not a valid' How can I solve this?",<qiskit><programming><entropy>,03/06/2020 23:08,10124.0,10124.0,"Short answer You are getting that error because your example does not use a valid (normalized) statevector. If you remove the decimals=3 kwarg where you call result.get_statevector it will work. Long Answer The Von-Neuman entropy function in the qiskit.quantum_info works with either Statevector or DensityMatrix object inputs, or inputs that can be implicitly converted to those objects (ie a list or np.array for a vector or a square matrix). So you can do any of the following for example: import numpy as np from qiskit.quantum_info import entropy, Statevector, DensityMatrix # Pure state entropy (Note this is always 0) # The following are equivalent: s1 = entropy([1, 0, 0, 0]) # Statevector as list s2 = entropy(np.array([1, 0, 0, 0])) # Statevector as array s3 = entropy(Statevector([1, 0, 0, 0])) # Statevector object print(s1, s2, s3) # Mixed state entropy # The following are equivalent s1 = entropy([[0.75, 0], [0, 0.25]]) # Density matrix as list s2 = entropy(np.array([[0.75, 0], [0, 0.25]])) # density matrix as array s3 = entropy(DensityMatrix([[0.75, 0], [0, 0.25]])) # Density matrix object print(s1, s2, s3) As for your specific issue: the entropy is only well-defined for a valid quantum state, so the function checks the input state is valid. In the case of a statevector this is checking it has norm 1, in the case of a density matrix that it is trace 1 and postive-semidefinite. Your example does not have a norm-1 input state because you truncated the decimals when you got the output state from the simulator. You can check this using the statevector object for example: # Returns True: Statevector([1 / np.sqrt(2), 1 / np.sqrt(2)]).is_valid() # Returns False: Statevector([0.707, 0.707]).is_valid() Entropy base: Another thing you should keep in mind if you didn't already notice is that the qiskit.quantum_info.entropy function takes logarithms in base 2 by default (and you can use a different base using the base kwarg). The deprecated qiskit.tools.qi.entropy function was always taken in log base e: import numpy as np from qiskit.quantum_info import entropy from qiskit.tools.qi import entropy as old_entropy rho = [[0.75, 0], [0, 0.25]] s1 = entropy(rho) # base-2 s2 = entropy(rho, base=np.e) # base-e s3 = old_entropy(rho) # base-e print(s1, s2, s3, s2 == s3) ```",03/08/2020 15:58
10164.0,"In Qiskit, where is the floating point operation performed?",I am using Qiskit - the simple circuits I am writing can either run on the hardware backend (using least_busy) or the QASM simulator backend. If I have statements like the following - (random_numbers were generated using QRNG in the circuits - not shown here) b = .6 a = .3 flt = [] for rn_num in random_numbers: flt.append( b*(a-rn_num) + a * rn_num) Where are these floating point operations performed? I am connected to IBM Quantum Experience - using Jupyter. Are these operations performed on a traditional machine or a quantum backend? My understanding is unless it is related to a Quantum circuit - everything gets executed on a traditional machine (similar to print or sockets?) Is there a document that explains this further? I read release notes - I found them a bit ambiguous. I found this comment in Aer 0.3 release note Increased performance with simulations that require less floating point numerical precision. Maybe this note is referring to statevectors in floating point ...??,<qiskit><programming><ibm-q-experience>,03/12/2020 09:43,10165.0,10165.0,"The Qiskit backends (quantum devices or simulators) work only when you explicitly invoke them, usually with execute. The code in your snippet does not call qiskit, and runs on a traditional machine.",03/12/2020 09:54
11568.0,Can I learn Quantum Programming and then go back to learn the Mathematics / Physics behind it later?,Learning from the ground up (while great) is an overdose of the mathematics behind quantum computing and is taking way too long to grasp. I have a Computer Science / Programming background. I am happy to learn the programming aspects and then go back and learn the math behind it or learn the background math whenever it is necessary while programming. I started with MacMahon's book and now on Nielsen and Chuang.. but I feel it is taking longer to get to the application layer.,<algorithm><resource-request><classical-computing>,4/16/2020 7:38,11570.0,11570.0,"Quantum computing is completely different paradigm in comparison with classical computers. Therefore an approach to programming quantum computers is different as well. It is not only about learning a new programming language but also about understanding underlying technology. Currently, there is only a little abstraction between quatum algorithms (programs) and quantum hardware. Nowadays, programming a quantum computer is similar to approach used in 1950's when computers were programmed in assembler or even microinstructions (what is different that we have common quantum gates). There are some higher programming languages (for example Qiskit based on Python) helping you to load data into a quantum computer and postprocess results. However, quantum algorithm is still expressed on quantum gates level. Overall, to be able to program quantum computer and understand why you do so, you should learn at least basic mathematical background of quantum computing.",4/16/2020 8:06
11610.0,Why don't I get what I expect when measuring with respect to a different basis?,"$\newcommand{\bra}[1]{\left&lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&gt;}\newcommand{\bk}[2]{\left&lt;#1\middle|#2\right&gt;}\newcommand{\bke}[3]{\left&lt;#1\middle|#2\middle|#3\right&gt;}$ If I make a rotation of $\frac{\pi}{4}$ around the x axis, starting from $\ket{0}$, I expect $\alpha = \frac{\sqrt{2 + \sqrt{2}}}{2}$ and $\beta= \frac{\sqrt{2 - \sqrt{2}}}{2}$ when measured with respect to the computational basis states of $\ket{0}$ and $\ket{1}$. I can verify this is correct empirically using a quantum simulator. I want to measure with respect to new basis states $\ket{+}$ and $\ket{-}$, defined in Quantum Computation and Quantum Information as follows $\ket{+} \equiv \frac{\ket{0}+\ket{1}}{\sqrt{2}}$, $\ket{-} \equiv \frac{\ket{0}-\ket{1}}{\sqrt{2}}$, and corresponding to the poles of the x axis of the Bloch sphere. Looking at the Bloch sphere, I would expect to get $\ket{+}$ half of the time, and $\ket{-}$ the other half, and I have been able to empirically verify this. However, according to the mathematics presented in the aforementioned book, I should be able to express this state $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, with the $\alpha$ and $\beta$ previously mentioned, as follows: $$\ket{\psi} = \alpha\ket{0} + \beta\ket{1} = \alpha\frac{\ket{+} + \ket{-}}{\sqrt{2}} + \beta\frac{\ket{+} - \ket{-}}{\sqrt{2}} = \frac{\alpha + \beta}{\sqrt{2}}\ket{+} + \frac{\alpha -\beta}{\sqrt{2}}\ket{-}$$ This math seems sound to me, however if I attempt to translate to this new basis using my $\alpha$ and $\beta$, I get $$ \frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{+} + \frac{\sqrt{2+\sqrt{2}} -\sqrt{2-\sqrt{2}}}{2\sqrt{2}}\ket{-} $$ Since $\left(\frac{\sqrt{2+\sqrt{2}} + \sqrt{2-\sqrt{2}}}{2\sqrt{2}}\right)^2 \approx 0.85$ this is not at all what I expect from looking at the Bloch sphere, and does not match what I am able to demonstrate empirically. What am I missing? For reference, the important bit of my Q# code I've been using to test this is: Rx(PI()/4.0, qubit); set state = Measure([PauliX], [qubit]);",<quantum-state><mathematics><nielsen-and-chuang><q#><superposition>,4/19/2020 14:45,11613.0,11613.0,"I think there should be $-i$ in the expression for $\beta$: \begin{equation} R_x\left(\frac{\pi}{4}\right) |0\rangle= \begin{pmatrix} \cos\left(\frac{\pi}{8}\right) &amp; -i \sin\left(\frac{\pi}{8}\right) \\ -i \sin\left(\frac{\pi}{8}\right) &amp; \cos\left(\frac{\pi}{8}\right) \end{pmatrix} \begin{pmatrix} 1 \\ 0\end{pmatrix} = \\ =\frac{\sqrt{2 + \sqrt{2}}}{2} |0\rangle - i \frac{\sqrt{2 - \sqrt{2}}}{2} |1\rangle \end{equation} So, we will have: $$|\psi\rangle = \frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |+\rangle + \frac{\sqrt{2 + \sqrt{2}} + i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}} |-\rangle$$ Then: $$\left|\frac{\sqrt{2 + \sqrt{2}} -i \sqrt{2 - \sqrt{2}}}{2\sqrt{2}}\right|^2 = 0.5 $$",4/19/2020 16:29
11620.0,How to create states in Qiskit using complex phase angles?,"How do we create an arbitrary vector of the following form in Qiskit? Say, we want to initialize a qubit with a vector, $$ \vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle $$ If I put it in the form $$ \vert \psi \rangle = \frac{1+i}{\sqrt{3}}\vert 0 \rangle - \frac{i}{\sqrt{3}}\vert 1 \rangle = cos(\frac{\theta}{2})|0&gt; + e^{i\phi}sin(\frac{\theta}{2})|1&gt; $$ where $0 &lt; \theta &lt; \pi$ and $0 &lt; \phi &lt;2\pi$ and then calculate $\theta$ and $\phi$ So, $$ cos(\frac{\theta}{2}) = \frac{1+i}{\sqrt{3}}\\ e^{i\phi}sin(\frac{\theta}{2}) = - \frac{i}{\sqrt{3}} $$ Therefore, $$ \theta = 2 * \arccos{\frac{1+i}{\sqrt{3}}} \\ \phi = i * ln(\frac{- \frac{i}{\sqrt{3}}}{sin(\frac{\theta}{2})}) $$ Now, I am using the following code.. #We create the quantum state manually first arb_quantum_state = ((1+1.j)/math.sqrt(3))*ket_0 - (1.j/math.sqrt(3))*ket_1 print(arb_quantum_state) theta = 2*cmath.acos((1+1.j)/cmath.sqrt(3)) print('theta : ',theta) sinValue = cmath.sin(theta/2) print(sinValue) phase = -1*(1.j/cmath.sqrt(3))/sinValue phi = cmath.log(phase)/1.j print('phi : ',phi) # Use these theta and phi to create the circuit circ = QuantumCircuit(1,1) #Verify why complex values are not allowed #circ.u3(theta.real,phi.real,0,0) circ.u3(theta,phi,0,0) results = execute(circ, backend=Aer.get_backend('statevector_simulator')).result() quantum_state = results.get_statevector(circ, decimals=3) print (quantum_state) The above code creates the gate alright, but the execute function is returning the following error, TypeError: can't convert complex to float However, if I use just the real values of theta and phi, then the execute function returns a state vector, which is different than the one it should be.",<qiskit><programming><quantum-state>,4/20/2020 12:52,11621.0,11621.0,"The problem is that you're trying to equate $\cos(\theta/2)$ (a real number) with $(1+i)/\sqrt{3}$ (a complex number). The way around this is you need to take into account a global phase $\gamma$ such that $$ e^{i\gamma}|\psi\rangle=\cos\frac{\theta}{2}|0\rangle+e^{i\phi}\sin\frac{\theta}{2}|1\rangle. $$ To do this, it helps to express your initial state as complex exponentials: As a first step your state can be reduced to $$ |\psi\rangle=\sqrt{\frac{2}{3}}\left(\frac{1}{\sqrt{2}} + \frac{1}{\sqrt{2}}i\right)|0\rangle+\frac{1}{\sqrt{3}}\left(0 - i*1\right)|1\rangle $$ Then to, $$ |\psi\rangle=\sqrt{\frac{2}{3}}e^{i\pi/4}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{3}{2}\pi}|1\rangle $$ so that we can rewrite it as $$ |\psi\rangle=e^{i\pi/4}\left(\sqrt{\frac{2}{3}}|0\rangle+\frac{1}{\sqrt{3}}e^{i\frac{5}{4}\pi}|1\rangle\right). $$ Now you can easily see that $$ \cos\frac{\theta}{2}=\sqrt{\frac{2}{3}},\qquad \phi=\frac{5\pi}{4},\qquad \gamma=\frac{\pi}{4}. $$",4/20/2020 13:14
11768.0,Using entropy_mutual function in QuTiP,"I am trying to calculate mutual entropies using QuTiP, but I am being unsuccessful so far. More specifically, I consider a 2^n x 2^n matrix representing the density operator of a n-qubit bipartite system AB made of system A (first m &lt; n qubits) and B (remaining n-m qubits). No tutorial nor material on the internet addressed this specific task. For simplicity, let us consider a 1-qubit system A and a 2-qubit system B and a density operator of dimension 8x8 representing AB in computational basis. More practically in python, let rhoAB = Qobj=(np.random.rand(8,8)), and assume that this is a valid density operator. How should I call entropy_mutual so that I can get this measure between A and B, in particular, regarding the arguments selA and selB? Ideally, I would call something like entopy_mutual(rhoAB, selA=[1], selB=[2,3]) but this not the approach how the function interprets the subsystems and their respective dimensions.",<programming><entropy><qutip>,4/30/2020 13:25,11795.0,11795.0,"Best to look at the source code when the documentation isn't helpful enough. The definition of entropy_mutual is def entropy_mutual(rho, selA, selB, base=e, sparse=False): """""" Calculates the mutual information S(A:B) between selection components of a system density matrix. Parameters ---------- rho : qobj Density matrix for composite quantum systems selA : int/list `int` or `list` of first selected density matrix components. selB : int/list `int` or `list` of second selected density matrix components. base : {e,2} Base of logarithm. sparse : {False,True} Use sparse eigensolver. Returns ------- ent_mut : float Mutual information between selected components. """""" if isinstance(selA, int): selA = [selA] if isinstance(selB, int): selB = [selB] if rho.type != 'oper': raise TypeError(""Input must be a density matrix."") if (len(selA) + len(selB)) != len(rho.dims[0]): raise TypeError(""Number of selected components must match "" + ""total number."") rhoA = ptrace(rho, selA) rhoB = ptrace(rho, selB) out = (entropy_vn(rhoA, base, sparse=sparse) + entropy_vn(rhoB, base, sparse=sparse) - entropy_vn(rho, base, sparse=sparse)) return out So we see selA and selB are passed as arguments to compute the partial trace. I am not too familiar with qutip but here is an example computing $S(A:B)$ for $\rho_{AB}$ where $A$ is a qubit system and $B$ is a two-qubit system. import qutip as qtp # note there is a rand_dm function # We should also let qutip know how are systems are partitioned # This is so it knows how to correctly compute the partial trace rho = qtp.rand_dm(8, dims=[[2,4],[2,4]]) qtp.entropy_mutual(rho,0,1) With the above example we could also specify the second system as two-qubits instead of a four dimensional system i.e. rho = qtp.rand_dm(8, dims=[[2,2,2],[2,2,2]]) qtp.entropy_mutual(rho,0,[1,2])",05/01/2020 16:38
11886.0,How can I make qiskit output raw data?,"I am new to quantum computing, and I want to make a program to output 0 or 1 randomly by Hadamard gate, and use that information to make a GUI interface. For example, a coin flip program that output ""Tail"" when it is 1, and ""Head"" when it is 0. However, when I try to get raw data by job.result(job), I get the information of the result instead. By the way, here is the code: from qiskit import * simulator = Aer.get_backend('qasm_simulator') qr = QuantumRegister(1) cr = ClassicalRegister(1) circuit = QuantumCircuit(qr, cr) circuit.h(qr[0]) circuit.measure(qr, cr) job = execute(circuit, backend = simulator, shots=1024) a = job.result(job) #the problematic code print(a) I use Qiskit with Python, and do not use Jupyter notebooks.",<qiskit><programming><hadamard>,05/07/2020 11:03,11887.0,11887.0,"You need to do .get_counts() to get a dictionary of the counts returned by the circuit. You would do this as follows job = execute(circuit, backend = simulator, shots=100) result = job.result() counts_dict = result.get_counts() Using your circuit and this code, counts_dict will look something like {'0':497, '1':503}. From there you might want to extract the key which has a higher value to be the result of your coin flip.",05/07/2020 11:30
11934.0,ModuleNotFoundError: No module named 'qiskit.circuit.library',I am importing from qiskit.circuit.library import MCMTVChain on python IDLE editor but it showing error ModuleNotFoundError: No module named 'qiskit.circuit.library' although it's working fine on google colab. Also why Qiskit does not work properly on python IDLE it's show lots of other error not just this one?,<qiskit><programming><circuit-construction><ibm-q-experience>,05/10/2020 02:11,11936.0,11936.0,"You most probably haven't installed the qiskit module. Qiskit can be installed via : pip install qiskit Try the following commands in command prompt, one of them should work (if your PATH variables are appropriately set): py -m pip install qiskit Or python -m pip install qiskit Or if you have more than one python versions, you can try: py -'version number like 3.7' pip install qiskit without the quotes. This should install the qiskit module and then you can import it.",05/10/2020 05:47
12073.0,How to reduce unnecessary waiting time when using IBM's backend?,"I'm working with a program, which needs iterations of quantum computation like this def quantum(n): Grover(oracle).run(QuantumInstance(...)) #n is input size associated with oracle, #and some other components are omitted. for n in range(0,10): start = time.time() quantum(n) end = time.time() Now I have to wait for hours to run this on the 16-qubit quantum computer. So is there any way to pack all computation into one round?",<qiskit><programming><ibm-q-experience>,5/19/2020 8:41,12074.0,12074.0,"Assuming your quantum() method creates a circuit, you can run lots of circuits in one go by using the execute command. For example execute([grover_1, grover_2, grover_3], backed=my_backend).",5/19/2020 10:03
12080.0,Evaluating expectation values of operators in Qiskit,"I'm wondering how in Qiskit one can calculate the expectation value of an operator given as a WeightedPauli (or, at least, of a single Pauli operator...) in a certain state (given as a QuantumCircuit object â â meaning that the actual state is the result of the action of this circuit on the computational basis state). I would like the inputs of such a procedure to be floats, not Parameters (it is an essential requirement â I'm using an external library to form the circuit for each set of parameters, and then converting it gate-by-gate to Qiskit format). This would be useful if, say, we wanted to manually implement VQE, and for that needed a function calculating the expectation value of the Hamiltonian on a quantum computer. More importantly, we would need this for implementing generalizations of VQE, such as subspace search. I guess, PauliBasisChange may be involved...",<qiskit><programming>,5/19/2020 12:04,12210.0,12210.0,"Note: This post is a bit older and Qiskit Aqua is now deprecated. Replace all occurences of qiskit.aqua.operators with qiskit.opflow to be compatible with Qiskit Terra 0.17.0 and above. The operators in Qiskit Aqua allow the evaluation of expectation values both exactly (via matrix multiplication) or on shot-based sampling (closer to real quantum computers). The basic principle is the same both times, it only differs in how the expectation value is evaluated in the end. First, you need to define the operator $O$ you're interested in and the state $|\psi\rangle$ with respect to which you want to compute the expecation value. So we're looking for $$ E = \langle\psi|O|\psi\rangle. $$ In the code below we have $O$ = op and $|\psi\rangle$ = psi. See also there for your use-case of a WeightedPauliOperator. # you can define your operator as circuit circuit = QuantumCircuit(2) circuit.z(0) circuit.z(1) op = CircuitOp(circuit) # and convert to an operator # or if you have a WeightedPauliOperator, do op = weighted_pauli_op.to_opflow() # but here we'll use the H2-molecule Hamiltonian from qiskit.aqua.operators import X, Y, Z, I op = (-1.0523732 * I^I) + (0.39793742 * I^Z) + (-0.3979374 * Z^I) \ + (-0.0112801 * Z^Z) + (0.18093119 * X^X) # define the state you w.r.t. which you want the expectation value psi = QuantumCircuit(2) psi.x(0) psi.x(1) # convert to a state psi = CircuitStateFn(psi) There are now different ways to evaluate the expectation value. The straightforward, &quot;mathematical&quot;, approach would be to take the adjoint of $|\psi\rangle$ (which is $\langle\psi|$) and multiply with $O$ and then $|\psi\rangle$ to get the expectation. You can actually do exactly this in Qiskit: # easy expectation value, use for small systems only! print('Math:', psi.adjoint().compose(op).compose(psi).eval().real) to get Exact: -1.0636533199999998 This is only suitable for small systems though. To use the simulators, and the also get the shot-based result, you can use the PauliExpectation (shots), AerPauliExpectation (exact) or MatrixExpectation (exact). Here's how to do it: from qiskit import Aer from qiskit.aqua import QuantumInstance from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn # define your backend or quantum instance (where you can add settings) backend = Aer.get_backend('qasm_simulator') q_instance = QuantumInstance(backend, shots=1024) # define the state to sample measurable_expression = StateFn(op, is_measurement=True).compose(psi) # convert to expectation value expectation = PauliExpectation().convert(measurable_expression) # get state sampler (you can also pass the backend directly) sampler = CircuitSampler(q_instance).convert(expectation) # evaluate print('Sampled:', sampler.eval().real) which yields Sampled: -1.0530518430859401 This result varies if you execute multiple times. For comparison, here the other methods to evaluate the expecation value expectation = AerPauliExpectation().convert(measurable_expression) sampler = CircuitSampler(backend).convert(expectation) print('Snapshot:', sampler.eval().real) expectation = MatrixExpectation().convert(measurable_expression) sampler = CircuitSampler(backend).convert(expectation) print('Matrix:', sampler.eval().real) which produces Snapshot: -1.06365328 Matrix: -1.06365328 I hope that clarifies how to compute the expectation value!",5/27/2020 17:40
12094.0,Tensor Product in Q#,"Does anyone know how you can obtain a new state |z&gt; from two pre-existing states |x&gt; and |y&gt; using the Tensor product in Q#? i.e. |z&gt; = |x&gt; â|y&gt; ? Thanks in advance for the help! Edit: for clarity, the states that I am working with are $|x\rangle = \frac{1}{\sqrt{2}} \sum^{3}_{j=0} \sin \frac{\pi (j + 0.5)}{4} |j\rangle$ $|y\rangle = \sum^{1}_{i=0} b_i |i\rangle$ where the $b_i$'s are just real numbers.",<programming><q#><tensor-product>,5/20/2020 12:53,12098.0,12098.0,"If you have an array of Qubit objects, and you prepare the individual qubits into arbitrary states, then the array effectively contains the tensor product of all of the original qubits. To quickly illustrate what I mean: using (qubits = Qubit[2]) { // do something to prepare qubits[0] individually // do something to prepare qubits[1] individually // now the state of ""qubits"" is the tensor product of the two // individual qubit states that you prepared } This also generalizes if you're preparing groups of qubits within the array that you allocated.",5/20/2020 15:59
12176.0,Modifying measurements in a Qiskit circuit,"Assume my function Qiskit receives a certain circuit as an input. How do I check if this circuit already has some measurements appended to it? If so, how can I modify them? For example, if there are measurements on certain qubits, I would like to remove those in order to add some more gates, and then add the measurement of all qubits.",<qiskit><programming>,5/25/2020 17:06,12182.0,12182.0,"The easiest way to do this is probably by converting the circuit to a DAGCircuit, which can be done using the method from qiskit.converters import circuit_to_dag. From the DAG you can get properties, such as any measurement operations, by using the function my_dag.named_nodes('measurement'). DAGNode objects are returned which will tell you the properties of the measurement. You can then remove nodes using my_dag.remove_op_node(a_measurement_node), it is preferable to remove and add nodes than to modify inplace. Following this you could convert the DAGCircuit back to a QuantumCircuit using from qiskit.converters import dag_to_circuit and then append any measurement operations as desired.",5/25/2020 19:38
12356.0,Transpiler Error: Number of qubits greater than maximum in coupling map,"Transpiler Error: Number of qubits (2) in circuit11 is greater than maximum (1) in the couplings map # Initialize two qubits and create Entanglement using Hadamard and CX/CNOT Gate q = qiskit.QuantumRegister(2) c = qiskit.ClassicalRegister(2) qc = qiskit.QuantumCircuit(q, c) qc.h(q[0]) qc.cx(q[0], q[1]) qc.measure(q, c) job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3) Error: --------------------------------------------------------------------------- TranspilerError Traceback (most recent call last) &lt;ipython-input-11-7b13276b10ae&gt; in &lt;module&gt;() 9 qc.cx(q[0], q[1]) 10 qc.measure(q, c) ---&gt; 11 job_exp = qiskit.execute(qc, backend=backend, shots=1024, max_credits=3) 2 frames /usr/local/lib/python3.6/dist-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, **run_config) 249 seed_transpiler=seed_transpiler, 250 optimization_level=optimization_level, --&gt; 251 backend=backend) 252 253 if schedule_circuit: /usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, seed_transpiler, optimization_level, pass_manager, callback, output_name) 205 callback, output_name) 206 --&gt; 207 _check_circuits_coupling_map(circuits, transpile_args, backend) 208 209 # Transpile circuits in parallel /usr/local/lib/python3.6/dist-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend) 245 'in {} '.format(circuit.name) + 246 'is greater than maximum ({}) '.format(max_qubits) + --&gt; 247 'in the coupling_map') 248 249 TranspilerError: 'Number of qubits (2) in circuit11 is greater than maximum (1) in the coupling_map'",<qiskit><programming>,06/06/2020 06:42,12359.0,12359.0,This error means that you are trying to execute a circuit on a backend that has fewer qubits than used in your circuit. In this case you are trying to execute a 2 qubit circuit on a device that only has one qubit. To fix this I would use a different backend which has 2 or more qubits. You can see how many qubits a backend has by looking at it on the IBM Quantum website or by calling backend.configuration(),06/06/2020 10:45
12474.0,How does a classical computer simulate nonclassical correlations?,"This may be a dumb question, if so please forgive me, it is late at night. I have learned that a classical computer can simulate a quantum computer in exponential time and space, but classical computers are bound to non-quantum phenomenon. How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate? In general, how could a classical computer simulate quantum phenomena that cannot be explained classically (such as the dynamics of more than a single particle)? I would think that one could not generate random numbers violating any of Bell's inequalities, i.e. necessarily quantum correlations are off limits.",<entanglement><simulation><classical-computing><nonlocal-games><non-locality>,6/14/2020 9:16,12479.0,12479.0,"How then, would one be able to simulate say CHSH, which produces fundamentally quantum probabilities that cannot be explained locally/classically? Am I misinterpreting the meaning of simulate? Quantum phenomena cannot be ""explained classically"" only when locality is taken into consideration. In other words, classical phenomena cannot reproduce (some types of) quantum correlations provided that we don't allow for certain types of correlations. As a concrete example, consider a standard CHSH scenario. We can compute the outcome probability distributions for each measurement setting (it's what you do when you study the protocol), therefore you can trivially write some code to ""simulate"" the results of an experiment, meaning to draw a possible sequence of measurement outcomes you would find in an experiment. But this is clearly not the same as observing nonlocality with a classical computer: you would just be crunching some numbers that you know, in some situations, can be interpreted as markers of nonclassical correlations. Put in another way, you can always sample from an arbitrary probability distribution $p(ab|xy)$. Whether such a distribution is ""nonclassical"" is only meaningful in relation to some imposed restriction (e.g. defining ""classical"" when it can be written as $p(ab|xy)=\sum_\lambda p_\lambda p_\lambda(a|x) p_\lambda(b|y)$). When you simulate such a distribution on a computer, you don't need to respect such restrictions, so there is no problem. In general, how could a classical computer simulate quantum phenomena that cannot be explained classically Aside from locality constraints, such as those described above, quantum mechanics does not predict output probability distributions that are incompatible with classical physics. The difference is in how those outputs can be obtained: quantum mechanic can produce output probability distributions in a radically different way than what classical physics allows for, and in some cases these new behaviours are more efficient.",6/14/2020 12:46
12542.0,Graph coloring - Q# -,"I am checking Q# - Graph coloring for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) { InitializeColor(C, register); Can you help me explain this part of the code? Thnx for (N in 1 .. 4) { using (register = Qubit[N]) { for (C in 0 .. (1 &lt;&lt;&lt; N) - 1) { InitializeColor(C, register); let measurementResults = MultiM(register); Fact(ResultArrayAsInt(measurementResults) == C, $&quot;Unexpected initialization result for N = {N}, C = {C} : {measurementResults}&quot;); ResetAll(register); } } } }",<programming><q#>,6/18/2020 20:33,12555.0,12555.0,This is part of the Graph Coloring Kata. The InitializeColor is an operation that you must implement. The code above is part of the checker code to confirm the working of the implementation. The code is used to check if the InitializeColor operation is implemented correctly. It is supposed to take an input C denoting the color as an non-negative integer. It is supposed to apply a unitary to convert the state $|000...0\rangle$ to state denoted by LittleEndian encoding of $|C\rangle$. The InitializeColor operation is supposed to take a register which is in the state $|0..0\rangle$ and applies a Unitary which transforms it into a register in the state $|C\rangle$. The nextline measures the register using the MultiM operation. The Fact function essentially confirms if the measured result in the state $|C\rangle$ and if not it print the error statement. The last line resets the register and brings it back to the state $|000..0\rangle$. An example can be with $C=2$ and $N=4$. Then InitializeColor should apply a Unitary Operation which transform $|0000\rangle$ into $|0100\rangle$ assuming LittleEndian encoding or $|0010\rangle$ assuming BigEndian encoding.,6/19/2020 13:00
12550.0,How to append an Instruction to a QuantumCircuit with variable length of QuantumRegisters as qargs?,"I think it is a bug but I'm not really sure. Basically, what I'm trying to do is the following: I have an Oracle Instruction which I want to append to my QuantumCircuit, looks as follows: # initialising registers for readability [control, train_register] = circ.qregs circ.h(control) # create and append oracle oracle = create_oracle(train_register, control) # returns an Instruction circ.append(oracle, [train_register, control]) If my train_register and control are both QuantumRegisters with length 1, this works perfectly fine. But I want to make this work for variable length of these registers, I get the error qiskit.circuit.exceptions.CircuitError: 'The amount of qubit arguments does not match the instruction expectation.'. This is logical, since this error occurs because qiskit checks the length of my provided qargs in QuantumCircuit.append(), and I provided two registers in a list with both one qubit, so the length of the list happens to be the same as the number of qubits. However, I want this to work for variable length. If I know what the length of my QuantumRegisters are, say len(train_register) is 3 and len(control) is 1 I can use circ.append(oracle, [0, 1, 2, 3]) Or to make it work for unspecified lengths, I can write something like: indices_to_append_to = list(np.arange(len(train_register) + len(control))) circ.append(oracle, indices_to_append_to) But I just really like the idea of just plugging in the names of the qregs as qargs. Is there something to make this work like that?",<quantum-gate><algorithm><qiskit><programming><circuit-construction>,6/19/2020 8:32,12551.0,12551.0,"If you pass a list of qubits instead of a list of register this works. For this do circ.append(oracle, train_register[:] + control[:]) where train_register and control are QuantumRegisters.",6/19/2020 8:49
12602.0,Finding phase angle in Q#,"I've trying to measure the phase angle from X axis of a qubit, but unable to find any function in Q# documentation, can anyone help me with this?",<quantum-state><entanglement><q#><phase-estimation>,6/22/2020 9:43,12768.0,12768.0,"If this is part of a debugging effort then you can use the DumpRegister function. If you have a qubit q which is in the general state $\alpha|0\rangle + \beta|1\rangle$ where $\alpha$ and $\beta$ are complex numbers such that $|\alpha|^2+|\beta|^2=1$. DumpRegister([q]) will give an output like this (Having Different Numbers) # wave function for qubits with ids (least to most significant): 1 â£0â­: 0.707107 + 0.000000 i == *********** [ 0.500000 ] --- [ 0.00000 rad ] â£1â­: -0.500000 + -0.500000 i == *********** [ 0.500000 ] / [ -2.35619 rad ] However if the qubit is entangled with some other qubit the result would be Qubits provided (0;) are entangled with some other qubit. Each row of the output tells the Amplitude of the Qubit along the Particular Computational Basis. The left hand values are in the Regular Complex Notation (Real and Imaginary Parts) and right hand values are in [Probability] [Phase]. The phase angle with $X$ axis is simply the $\arctan$ of the ratio of the absolute values of the amplitudes. Proof: Let us say the results give the amplitudes of basis states $|0\rangle$ and $|1\rangle$ as $\alpha = \alpha_R + i\alpha_I = |\alpha|e^{i\theta_1}$ and $ \beta = \beta_R + i\beta_I =|\beta|e^{i\theta_2} $ respectively. Then q is in the state $\alpha|0\rangle + \beta|1\rangle = |\alpha|e^{i\theta_1}|0\rangle + |\beta|e^{i\theta_2}|1\rangle$. We can remove the global phase and thus the relative phase will be $e^{i\theta_1-i\theta_2} = e^{i\theta}$ and let $\phi = 2\arctan\frac{|\beta|}{|\alpha|}$. Thus q is in the state $\cos\frac{\theta}{2}|0\rangle + e^{i\theta}\sin\frac{\theta}{2}|1\rangle$. This state can be represented on the Bloch Sphere by the coordinates $(\sin\theta\cos\phi, \sin\theta\sin\phi, \cos\theta)$. Consequently the phase angle with X axis is given by $\arctan$ of the $x$ and $y$ coordinates. Thus the phase angle is $\phi=2\arctan\frac{|\beta|}{|\alpha|}$",07/03/2020 15:47
12639.0,Find orthogonal state for random 7 qubit state,"I have a system that generates a random 7 qubit state and I need a method to always find the orthogonal state. I'm currently using python and qutip for this, representing this 7 qubit state by a 128-dimensional vector.",<algorithm><programming><qutip>,6/24/2020 17:19,12640.0,12640.0,"Basically, you divide the entire $7$-qubit Hilbert space into two subspaces: the one spanned by your state (let's call the state $|\psi\rangle$), let's call that subspace $W$, and it's orthogonal complement $V = W^{\perp}$. You want any vector from $V$, because this will by definition be orthogonal. We know that $P_{V}$ + $P_{W} = I$, with $P_{V}$ and $P_{W}$ being the projectors upon the $V$ and $W$ subspaces. Since $P_{W} = |\psi\rangle\langle\psi|$, we can easily calculate $P_{V}$: $$ P_{V} = I - |\psi\rangle\langle\psi|. $$ We can let this projection matrix act on virtually any state to obtain a state orthogonal on $|\psi\rangle$, lets use the $0$ vector $|00....0\rangle$. An orthogonal state $|\psi^{\perp}\rangle$ to $|\psi\rangle$ is thus: $$ |\psi^{\perp}\rangle = P_{V}|00...0\rangle = (I - |\psi\rangle\langle\psi|)|00...0\rangle = |00...0\rangle - \langle\psi|00...0\rangle|\psi\rangle $$ which is more or less the Gram-Schmidt process. Note that you can use (almost) any state instead of $|00...0\rangle$; the only state that you cannot use is $|\psi\rangle$ itself. In python, this becomes something like: from numpy import zeros_like, inner zeros_vect = zeros_like(psi_orig) psi_orth = zeros_vect - inner(zeros_vect,psi_orig).conj()*psi_orig",6/24/2020 17:42
12683.0,What would be the difference between using qsharp library on python vs learning the Q# langauge?,"One difference of course is the syntax. But I'm guessing the idea is eventually quantum computers will be able run Q#, whereas now it uses simulations. Will code written in Python with the qSharp library also be able to do this?",<simulation><q#>,6/27/2020 10:45,12691.0,12691.0,"There are several separate questions entangled here. Using Q# with Python as the host language is similar to using Q# with C# or another classical host language: it allows you to run Q# code and do necessary classical processing (for example, preparing the data or analyze the results). The Q# code invoked from the classical host language has to be written somewhere - it will be either the library code or the code you wrote yourself. Learning Q# language itself allows you to implement any algorithm you want; without doing that, you'll be limited to using algorithms implemented by somebody else. That's certainly possible. Running the program on quantum hardware vs in simulation is completely independent from the way you run it (from Python, C# or in standalone mode) - it's a matter of configuring the right target machine.",6/27/2020 18:51
12739.0,How to implement a while loop in a quantum computer?,"How can a while loop be implemented in a quantum computer? If quantum computing consists of : preparing a state applying a unitary operator measuring, then it seems like it's not possible to wait for an indefinite amount of time before measuring. How can one know that the while loop ended and that it's time to mesure ?",<algorithm><programming><physical-realization>,07/01/2020 17:06,12747.0,12747.0,"The way that many algorithms would deal with such a desire is to incorporate the measurement at a more fundamental level, essentially making it part of the 'while' condition. i.e. you have an output qubit that is 0/1 for computation complete or not, you measure it, and decide whether to continue or not. Because that's a bit of classical processing, it doesn't have to be reversible, and you avoid the need for infinite space. For example, many quantum algorithms only have a finite probability of success. For example, search or Factoring. In both of these cases, you know if you succeeded, and so there's an additional bit of classical logical that says &quot;repeat until successful&quot; i.e. a while loop.",07/02/2020 07:22
12841.0,Applying a gate to all line qubits without explicitly listing them in Cirq,"Say we have a custom gate CG, defined by a unitary matrix U, and line qubits qubits in Cirq. Something like this: import numpy import cirq U = np.eye(8) # The custom unitary matrix goes here CG = cirq.MatrixGate(U) qubits = cirq.LineQubit.range(3) We build the circuit as follows: circuit = cirq.Circuit() circuit.append(CG(qubits[0], qubits[1], qubits[2])) Is it possible to build the circuit without explicitly specifying all the qubits? Something like circuit.append(CG(qubits)), which would apply the CG gate to all the qubits?",<quantum-gate><programming><circuit-construction><cirq>,07/08/2020 22:18,12842.0,12842.0,"In Python you can say callable(*args) instead of callable(args[0], args[1], args[2]).",07/08/2020 23:34
12844.0,How the simulator work?,"Recently I focused on how to simulate in classical computer, and I found Qiskit offers qasmsimulator and statevector simulator. And others such as project Q also can simulate on classical computer. So is there a general way to simulate on classical computer? And what are differences among simulators? I mean actually it seems like we just need to multiply gate operation as matrixes.",<quantum-gate><quantum-state><qiskit><programming><simulation>,07/09/2020 06:21,12852.0,12852.0,"There are three major levels of simulation difficulty (broadly, there are a bunch of others, but these are the main levels.) Clifford simulators can simulate circuits composed of only Clifford elements on stabilizer states. This is classically efficient, since it is classically efficient to calculate the propagation of a Pauli operator through a Clifford gate. As a result, the simulator takes the stabilizers of the input state, propagates them through the circuit, and the resulting stabilizer group represents the final state. The idea that a quantum algorithm needs non-Clifford gates to be better than a classical one comes from the fact that a fully Clifford quantum algorithm could be simulated classically in polynomial time. The second level of simulation is State Vector simulation. In this case, we are basically doing what you mentioned in your question. We take an input state (of size $2^n$, where n is the number of qubits) and then apply gates to it through matrix multiplication. Due to the exponential size of the state, this requires resources exponential in the system size to be simulated, and as a result is not considered classically efficient. The only restriction on these simulations is that the gates must all be unitary and all states must be pure. The last level is Density Matrix simulation. Here, we store the full $2^n \times 2^n$ density matrix of the state. As a result we can simulate any quantum channel, and mixed states are permissible. However we now have an even bigger object to work with. These simulations are often necessary for doing work on simulating physical noise or other non-unitary processes, but are extremely limited in size due to their exponential resource requirements.",07/09/2020 19:03
12888.0,Is running a for loop faster on a quantum computer than a classical computer?,"Curious to understand if I run for loop within a quantum algorithm, and lets say I want the quantum algorithm to run in classical run time of O(1). Can this be done?",<algorithm><programming>,7/13/2020 19:51,12889.0,12889.0,"No, quantum computers can't run for-loops faster in general. There are certain specific tasks that can be done using a for-loop that can instead be done in a different way on a quantum computer, with fewer total operations. For example, Grover search can replace the loop for x in range(N): if predicate(x): y = x with something that uses $O(\sqrt{N})$ calls to predicate instead of the $N$ that the for loop is using.",7/13/2020 21:00
12898.0,How to construct quantum circuit to count number of 0-qubits and 1-qubits,"Suppose we have a 3-qubit input; each bit is either 0 or 1. How to decide if there are more 1's than 0's? Only 1 extra qubit may be used for the output. (Yes I know this can be achieved using 3 Toffoli gates, but can it be done without Toffoli gates?) Now suppose we have an answer to the above question, then, how to extend the above circuit to deal with a 5-qubit input?",<programming><circuit-construction>,7/14/2020 15:27,12907.0,12907.0,"Here's a general strategy that doesn't quite fulfil the brief: for an $n$-qubit input where $n+1=2^k$, $k$ an integer (e.g. $n=3,k=2$), it uses $k$ ancilla qubits but no Toffolis. (You can do something similar if $n+1$ is not a powe of 2, but you'd need some classical post-processing and I'd have thought you might as well just measure the input qubits!) The idea is to define a Hamiltonian $$ H=\left(\sum_{j=1}^nZ_j+nI\right)/2. $$ Note that this has eigenvalues $0,1,2,3,\ldots,n$ corresponding to the number of 1s in the string it's acting on. So, let $U=e^{2i\pi H/2^k}$. This is a unitary with the eigenvectors that we need. If you run a phase estimation procedure using $k$ ancilla qubits, it will exactly read out the number of 1s for you. This requires controlled-$U$, which is just a bunch of controlled-phase gates (i.e. all two-qubit gates) and the Fourier transform which, again, is two-qubit gates. Actually you only need the semi-classical Fourier transform, so it's just one-qubit gates with feed-forward of measurement results. So, once you know who many 1s there are, you can classically process that to decide if it's greater than $n/2$. In the case of $n+1$ being a power of 2, this is particularly simple. You just look at the bit representation of the output, and the most significant bit will give you the answer. So, this would be the only qubit you would need to measure. (Note that this is the last bit output by the Fourier transform, not the first).",7/15/2020 7:32
13063.0,Is it possible to convert classical algorithms to quantum ones?,"I am new in this field and I am considering to do research for my engineering degree. First, I would like to have an opinion from more experienced people. Do you think it is possible to convert classic algorithms to quantum algorithms? Having in mind that the conversion will take in consideration the particularities of quantum algorithms. If so, can you explain your point of view and if it is possible, an example?",<algorithm><classical-computing>,7/28/2020 5:47,13065.0,13065.0,"It depends on what you mean by converting classical algorithm to quantum one. One angle of view can be: Is it possible to run any classical algorithm on quantum computer? If this is a case then answer is yes. Since so-called Toffoli gate is effectivelly NAND gate (in case the controlled qubit is set to state $|1\rangle$ before) and such gate enables to implement any logical function. Hence, you can use universal gate-based quantum computer for implementation of any classical algorithm. Seconde angle of view could be: Is there a qunatum counterpart to any classical algorithm? In this case the answer is difficult and I am not sure whether it has been resolved already. However, there are some examples of quantum algorithms solving problems we have classical ones for. For instance: Shor's algorithm is used for integers factoring, Grover's algorithm for searching in unordered databases, HHL algorithm for solving systems of linear equations, there are Monte Carlo algorithms useful in finance, Hamiltonian simulations algorithms useful in simulation of quantum systems (the original purpose the quantum computers have been developed for) etc. Moreover, there is a family of so-called quantum annealers. These are single purpose quantum computers implementing quantum annealing algorithm on hardware level.",7/28/2020 7:34
13080.0,How to undo an operation in qiskit on jupyter notebook?,"I am not able to undo an operation. For example, I want a single Hadamard gate on a single qubit but by mistake two Hadamard gate added. Now I want to remove one of them without interrupting kernel. Is there any easy way. Please help me. Thank you.",<qiskit><programming><hadamard>,7/29/2020 7:43,13087.0,13087.0,To remove the last gate you can do qc.data.pop(). Example: qc = QuantumCircuit(1) qc.h(0) qc.draw('text') output: âââââ q_0: â¤ H â âââââ Then: qc.data.pop() qc.draw('text') output: q_0:,7/29/2020 13:41
13186.0,Is there a Q# funtion which returns the type of a variable?,"As the title says, I am asking myself is there is a specific function which returns the type of something. Ideally, I would work as follows : let a = 4.0; Message(Type(a)); This would print : double Is there anything similar to this ? I tried to look at the api, but didn't find anything, I could definitely have missed something there.",<programming><q#>,08/05/2020 16:27,13188.0,13188.0,"No, there isn't. We are avoiding having the means for types to impact the program flow, but I'd be interested to hear what the use case is. If is it only a matter of wanting to print the type rather than getting something that can be used within the program, then that is certainly something we could cover in the future (please consider making a feature request).",08/05/2020 19:28
13266.0,How to initialize a random state in Qiskit?,"I know I can make a random_circuit, but I see that Qiskit has random_statevector. I'd like to optimize computation time by initializing a state by that instead of putting a random circuit at the beginning. Is it possible and how do I do it? Thank you!",<qiskit><programming>,08/11/2020 15:55,13270.0,13270.0,"here is an example of how to initialize the random statevector then send it to the quantum circuit: from qiskit.quantum_info import random_statevector, Statevector from qiskit import QuantumCircuit # import numpy as np vec = random_statevector(2) # vec = Statevector([1, 0]) print('before circuit: {}'.format(vec)) qc = QuantumCircuit(1) qc.x(0) qc.draw() new_vec = vec.evolve(qc) print('after circuit: {}'.format(new_vec)) you should notice that the dim of state vector is 2 so the quantum circuit is 1 qubit.",08/12/2020 00:27
13341.0,Can classical linear algebra solvers implement quantum algorithms with similar speed-ups?,"A quantum algorithm begins with a register of qubits in an initial state, a unitary operator (the algorithm) manipulates the state of those qubits, and then the state of the qubits is read out (or at least some information about the state on a single run of the algorithm). It seems to me that a quantum computer answers the question of the unitary acts on the quantum state. This is &quot;just&quot; a matter of linear algebra. It strikes me, then, that quantum computers can be seen as linear algebra calculators. Why then do we need quantum mechanics? Can we not find a classical system which implements linear algebra operations and use this to implement the algorithms which have been designed for quantum computers? Of course classical digital computers will not suffice, these machines are based on binary processing of information rather than the manipulation of vectors in a high dimensional space. Question: Are there any candidates for classical linear algebra solvers (classical analog computers) which could implement the &quot;quantum computer&quot; algorithms whiles enjoying a similar speedup over digital classical computers? Question 2: Perhaps I'm over simplifying by reducing a quantum computer to being simply a linear algebra solver. Is this the case? What complexity am I glossing over?",<algorithm><classical-computing><speedup><information-theory>,8/16/2020 2:56,13344.0,13344.0,"The complexity that you are glossing over is that in the general case you need to store $2^n$ complex amplitudes to even represent an $n$ qubit system classically. Therefore, for a quantum computer of let's say 1000 qubits you need to store $2^{1000}$ complex amplitudes. Even if you use one atom per amplitude to do this, you still run out of atoms in the observable universe. As far as I know, the above is the general argument. However, there might still be ways to represent certain quantum algorithms in a classically tractable manner by utilising some clever insight to save on the representational needs of the algorithm, thereby going below the $2^n$ requirement. But this is likely to be problem-specific and unlikely to work in the general case.",8/16/2020 11:59
13433.0,Implementing block of gates at different times in a same qiskit program,"I am implementing an Ising chain over 8 qubits. It involves pair-wise CNOT between all the qubits. In the first time step, I am doing CNOTs between qubits 0 and 1, 2 and 3, 4 and 5, and 6 and 7. In the second time step, I would do CNOTs between qubits 1 and 2, 3 and 4, and 5 and 6. I have written the code as follows: # Block A for the first time step qp.cx(q0,q1) qp.cx(q2,q3) qp.cx(q4,q5) qp.cx(q6,q7) # Block B for the second time step qp.cx(q1,q2) qp.cx(q3,q4) qp.cx(q5,q6) I would like the gates in Block A to be applied simultaneously. Then, in the next step, gates in Block B should be applied simultaneously. How to convey to the compiler that I do not want the above written code to be compiled sequentially, rather I want it to be applied block-wise.",<qiskit><programming><ibm-q-experience>,8/22/2020 14:39,13457.0,13457.0,"Did you try to put a barrier between your two blocks? You can do this by writing this qp.barrier() right after your first block, then Qiskit will transpile separately the two blocks. Is this what you were searching for?",8/24/2020 14:16
13662.0,Error while running Qiskit code on real quantum hardware,"I started to learn Qiskit, so sorry if my question is very basic. So far I used qasm_simulator or state_vectorsimulator, however, now I would like to run my circuit on real IBM Q processor. Here is my code, I wanted to execute: %matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * provider = IBMQ.load_account() backend = provider.backends(name='ibmq_ourense') q = QuantumRegister(5, name = 'q') c = ClassicalRegister(2,name = 'c') circuit = QuantumCircuit(q,c) circuit.h(q[0]) circuit.cx(q[0],q[1]) circuit.measure(q[0],c[0]) circuit.measure(q[1],c[1]) job = execute(circuit, backend, shots = 1024) counts = job.result().get_counts() plot_histogram(counts) However, this error was shown: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-26-b48ae13f56aa&gt; in &lt;module&gt; 11 circuit.measure(q[1],c[1]) 12 ---&gt; 13 job = execute(circuit, backend, shots = 1024) 14 counts = job.result().get_couns() 15 plot_histogram(counts) /opt/conda/lib/python3.7/site-packages/qiskit/execute.py in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config) 258 seed_transpiler=seed_transpiler, 259 optimization_level=optimization_level, --&gt; 260 backend=backend) 261 262 if schedule_circuit: /opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in transpile(circuits, backend, basis_gates, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, seed_transpiler, optimization_level, pass_manager, callback, output_name) 211 callback, output_name) 212 --&gt; 213 _check_circuits_coupling_map(circuits, transpile_args, backend) 214 215 # Transpile circuits in parallel /opt/conda/lib/python3.7/site-packages/qiskit/compiler/transpile.py in _check_circuits_coupling_map(circuits, transpile_args, backend) 244 245 # If coupling_map is None, the limit might be in the backend (like in 1Q devices) --&gt; 246 elif backend is not None and not backend.configuration().simulator: 247 max_qubits = backend.configuration().n_qubits 248 AttributeError: 'list' object has no attribute 'configuration' I think that the problem is hidden in getting backends or execute command. Note: I run my code in Quantum Lab on IBM Q website interface. Could any please help me how to change my code to run it on real IBM Q processor?",<qiskit><programming><ibm-q-experience>,09/09/2020 11:08,13663.0,13663.0,Looks like backend = provider.backends(name='ibmq_ourense') returns a list of backends whose name is ibmq_oursense (a list whose length is obviously 1). Try backend = provider.backends(name='ibmq_ourense')[0].,09/09/2020 11:18
13774.0,My IBMQ job hangs forever?,"I am running a very simple script just to learn how to use IBMQ, but my job will hang indefinitely and I am forced to terminate it. from qiskit import * from qiskit.compiler import transpile, assemble from qiskit import IBMQ from qiskit import QuantumCircuit, execute, BasicAer import logging logging.basicConfig(filename='log',level=logging.DEBUG) IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') #SELECT A BACKEND backend = provider.get_backend('ibmq_qasm_simulator') #ALGO qr = QuantumRegister(3) cr = ClassicalRegister(3) circuit = QuantumCircuit(qr, cr) circuit.x(qr[0]) circuit.x(qr[1]) circuit.ccx(qr[0], qr[1], qr[2]) circuit.cx(qr[0], qr[1]) circuit.measure(qr, cr) print('About to run job') job = execute(circuit, backend) print('Job Finished') result = job.result() counts = result.get_counts(circuit) print(counts) In an attempt to debug, I am using &quot;logging.basicConfig&quot; which stops at: &quot;websocket._connect:DEBUG:2020-09-16 11:26:57,813: Starting new websocket connection: wss://wss.quantum-computing.ibm.com/jobs/5f6258f09234fe0012dbd748/status/v/1&quot; When I go to my IBMQ home page it says that the job has run successfully. It is only at the line result = job.result() that it fails. So it seems that the websocket is hanging forever. I'd appreciate any help I can get to fix this issue.",<qiskit><programming><ibm-q-experience>,9/16/2020 18:39,13775.0,13775.0,"The function execute is non-blocking. That means that it will return after sending the job, but not necessarily with the result. In your code, you should wait for the status of the job to be DONE: print('About to run job') job = execute(circuit, backend) job.status() JobStatus.QUEUED After waiting some time: job.status() JobStatus.DONE Then, job.result() will work.",9/16/2020 18:53
13878.0,Why does job appear to be stuck in queue on IBMQ backend?,"I have submitted a batch of circuits to ibmq_vigo using the IBMQJobManager and the batch is correctly split properly into multiple jobs(as viewed on the dashboard), however the job at the front of the queue appears stuck at the front for multiple hours. The backend does not appear to be in reserve mode and I did not have this issue when I successfully executed the same batch of circuits on ibmq_rochester. Does anyone know what might be the issue? Also this is my second unsuccessful attempt at executing on ibmq_vigo.",<programming><ibm-q-experience>,9/22/2020 19:27,13881.0,13881.0,"Sometime that happens. The controlled electronic might got a reboot during while your jobs were in queue or something of that sort... You can try to cancel your jobs and resubmitted them to see if that fixes it. Note that if you running jobs through Aqua, like performing QAOA or VQE, you can cancel the current jobs and they will create a replacement job automatically.",9/22/2020 22:54
13894.0,Qiskit: Error when importing libraries for ADMM optimizer,"I would like to try and ADMM optimizer as shown in Qiskit Tutorial in Quantum Lab. Firstly, I imported necessary libraries (copy/paste from the Tutorial): import time from typing import List, Optional, Any import numpy as np import matplotlib.pyplot as plt from docplex.mp.model import Model from qiskit import BasicAer from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer from qiskit.optimization.problems import QuadraticProgram from qiskit.optimization.algorithms.admm_optimizer import ADMMParameters, ADMMOptimizer When I started the import this error appeared: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-32-c32e151d13df&gt; in &lt;module&gt; 11 12 from qiskit import BasicAer ---&gt; 13 from qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver 14 from qiskit.optimization.algorithms import CobylaOptimizer, MinimumEigenOptimizer 15 from qiskit.optimization.problems import QuadraticProgram /opt/conda/lib/python3.7/site-packages/qiskit/aqua/__init__.py in &lt;module&gt; 75 from .aqua_globals import aqua_globals 76 from .quantum_instance import QuantumInstance ---&gt; 77 from .algorithms import QuantumAlgorithm 78 from ._logging import (QiskitLogDomains, 79 get_logging_level, /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/__init__.py in &lt;module&gt; 190 from .eigen_solvers import NumPyEigensolver, ExactEigensolver, EigensolverResult 191 from .factorizers import Shor --&gt; 192 from .linear_solvers import HHL, NumPyLSsolver, ExactLSsolver 193 from .minimum_eigen_solvers import (VQE, VQEResult, QAOA, IQPE, IQPEResult, QPE, QPEResult, 194 ClassicalCPLEX, CPLEX_Ising, NumPyMinimumEigensolver, /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/__init__.py in &lt;module&gt; 15 &quot;&quot;&quot; Linear Solvers Package &quot;&quot;&quot; 16 ---&gt; 17 from .hhl import HHL 18 from .numpy_ls_solver import NumPyLSsolver, ExactLSsolver 19 /opt/conda/lib/python3.7/site-packages/qiskit/aqua/algorithms/linear_solvers/hhl.py in &lt;module&gt; 24 from qiskit.aqua import QuantumInstance 25 from qiskit.aqua.algorithms import QuantumAlgorithm ---&gt; 26 from qiskit.ignis.verification.tomography import state_tomography_circuits, \ 27 StateTomographyFitter 28 from qiskit.converters import circuit_to_dag /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/__init__.py in &lt;module&gt; 98 &quot;&quot;&quot; 99 from .quantum_volume import qv_circuits, QVFitter --&gt; 100 from .randomized_benchmarking import (CNOTDihedral, 101 randomized_benchmarking_seq, 102 RBFitter, InterleavedRBFitter, /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/__init__.py in &lt;module&gt; 19 20 # Randomized Benchmarking functions ---&gt; 21 from .circuits import randomized_benchmarking_seq 22 from .dihedral import (CNOTDihedral, decompose_cnotdihedral, random_cnotdihedral) 23 from .fitters import (RBFitter, InterleavedRBFitter, PurityRBFitter, /opt/conda/lib/python3.7/site-packages/qiskit/ignis/verification/randomized_benchmarking/circuits.py in &lt;module&gt; 204 is_purity: bool = False, 205 group_gates: Optional[str] = None, --&gt; 206 rand_seed: Optional[Union[int, RandomState]] = None) -&gt; \ 207 (List[List[qiskit.QuantumCircuit]], List[List[int]], 208 Optional[List[List[qiskit.QuantumCircuit]]], AttributeError: module 'qiskit' has no attribute 'quantum_info' Since I only copied the code, it seems there is some bug. Does anybody know how to solve this? Note: I work in Quantum Lab in IBM Q Experience interface",<qiskit><programming><ibm-q-experience><optimization>,9/24/2020 11:43,13897.0,13897.0,"Looks like a glitch. It is not reproducible under my account. I've seen similar errors when there's mismatch in versions between Qiskit Aqua and Terra installed locally, but I don't think it is the case in Quantum Lab. Try to restart the kernel or create a new notebook and run the same imports.",9/24/2020 15:01
13933.0,On number of parameters and operators in UCCSD in qiskit,"I have two questions on UCCSD in qiskit, please see the code below. import numpy as np from qiskit.chemistry.components.variational_forms import UCCSD from qiskit.chemistry.drivers import PySCFDriver, UnitsType from qiskit.chemistry import FermionicOperator from qiskit.aqua import QuantumInstance def get_qubit_op( atom , basis , map_type ): driver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, charge=0, spin=0, basis=basis) molecule = driver.run() repulsion_energy = molecule.nuclear_repulsion_energy num_particles = molecule.num_alpha + molecule.num_beta num_spin_orbitals = molecule.num_orbitals * 2 ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals) qubitOp = ferOp.mapping(map_type=map_type, threshold=0.00000001) # qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles) shift = repulsion_energy return qubitOp, num_particles, num_spin_orbitals, shift atom='H .0 .0 .0; H .0 .0 0.74' qubitOp, num_particles, num_spin_orbitals, shift = get_qubit_op( atom , basis = 'sto3g' , map_type = 'parity' ) num_qubits = qubitOp.num_qubits print( 'num_qubits = ' , num_qubits ) from qiskit.chemistry.components.initial_states import HartreeFock init_state = HartreeFock( num_spin_orbitals , num_particles , 'parity' , two_qubit_reduction=False ) # setup the variational form for VQE from qiskit.chemistry.components.variational_forms import UCCSD var_form_vqe = UCCSD( num_orbitals=num_spin_orbitals, num_particles=num_particles, initial_state=init_state, qubit_mapping='parity' , two_qubit_reduction = False ) print( 'var_form_vqe.num_parameters = ' , var_form_vqe.num_parameters ) var_form_vqe.construct_circuit([1,1,1]).draw() # Give some random para The outputs are (without the plot of the circuit) num_qubits = 4 var_form_vqe.num_parameters = 3 My questions are 1. Why there are only 3 free parameters in UCCSD? Since I have 4 spin-orbs, I should expect there are at least 4^4 free parameters from the double excitation operators? 2. Is there a way to see which operators are involved in UCCSD? I plot out the circuit, but there are âEvolution^1â block involved. If I use âdecompose().â, it shows all the 1 and 2 qubit operations? Would it be possible to show something in between, by which I mean for example adding barrier for the decomposed circuit, or showing which fermionic excitation operators are involved? Many thanks!",<qiskit><programming><vqe>,9/28/2020 5:14,13934.0,13934.0,"Since UCCSD is a particle- and spin-conserving variational form, the number of parameters does not only depend on the number of spin orbitals but also their &quot;nature&quot;. What I mean by that is that you also need to consider these conservation rules which leads to the following scenario in your case: H2 has 2 electrons in 2 molecular orbitals, which correspond to 4 spin orbitals (and, thus, 4 qubits since you do not apply any reductions, here). Taking into account the spin-conservation you have the following possible single excitations: 0 -&gt; 1 2 -&gt; 3 where I use Qiskit's notation in which spin orbitals are ordered block-wise (i.e. first all alpha orbitals, then all beta ones). If the spin was not conserved, then you would also see excitations such as 0 -&gt; 3 and 1 -&gt; 2. The double excitations are a little bit simpler in this case because there is only one possibility regardless: 0, 1 -&gt; 2, 3 However, if the example was more complex, the same reasoning would apply here, too. Regarding your second question: if you would like to see the excitation lists as I have written them above you can take a look at the single_excitations and double_excitations attributes of the UCCSD class. I am not aware of any &quot;partial&quot; decompose() functionality which could otherwise provide that you describe above.",9/28/2020 6:14
13937.0,Why is circuit inverse not working for EfficientSU2?,"For some reason I get the following error when attempting to find the inverse of the EfficientSU2 VQE variational form: TypeError: 'NoneType' object is not reversible My code is as follows: var_form = EfficientSU2(6, entanglement=&quot;linear&quot;) var_form_inv = var_form.inverse() # error thrown of this line Is there a bug in the implementation of the inverse method? and if so how can I implement a working inverse function? Note qiskit.__qiskit_version__: {'qiskit-terra': '0.15.2', 'qiskit-aer': '0.6.1', 'qiskit-ignis': '0.4.0', 'qiskit-ibmq-provider': '0.9.0', 'qiskit-aqua': '0.7.5', 'qiskit': '0.21.0'}",<qiskit><programming><ibm-q-experience><vqe>,9/28/2020 8:38,13938.0,13938.0,"EfficientSU2 is a BlueprintCircuit and does not populates its internal data field until you try to access them. In this case, when you are calling the inverse function the data are still empty (None) and this is the error you are getting. It is probably a bug and should be fixed. Nevertheless, as a workaround for now you can try: var_form = EfficientSU2(6, entanglement=&quot;linear&quot;) # build the circuit var_form._build() # or just print it print(var_form) var_form_inv = var_form.inverse()",9/28/2020 9:31
13987.0,How to realize Su-Schrieffer-Heeger model in Qiskit,"This is a very specific question, which I try to implement a simple dimerized tight-binding Hamiltonian on qiskit. The model is one dimensional, and defined as $$ H = \sum_{\langle i,j\rangle} t_{ij} c^\dagger_i c_j $$ where $\langle i,j\rangle$ denotes the nearest neighbor coupling with strength $t_{ij}$. The important aspect of the model is that the coupling is dimerized in the following sense. If we label the sites as 1,2,3,4...., then the nearest neighbor coupling $t_{ij}$ reads, for example, $$ t_{1,2} = 1, t_{2,3} = 2 , t_{3,4} = 1 , t_{4,5} = 2, etc $$ which is alternating. I try to pretend this is a molecular Hamiltonian and realize it in the same way with &quot;FermionicOperator&quot;. However, I am not sure how to properly index the &quot;one-body&quot; integral here, which is the nearest neighbor coupling $t_{ij}$ here.",<qiskit><programming><ibm-q-experience><hamiltonian-simulation>,10/01/2020 23:41,13991.0,13991.0,"I don't think it really matter how you index your $t_{ij}$. As you mentioned you can use FermionicOperator all you need to do is define the one body integral. This of course can be done in many ways. Here is a convenient way. def ssh_ham(gamma, lamda, n): sigmax = np.array([[0,1],[1,0]], dtype=np.complex_) sigmay = np.array([[0,-1j],[1j,0]], dtype=np.complex_) op_eye_x = np.eye(n) op_cos_x = 1/2*(np.eye(n, k=1) + np.eye(n,k=-1)) op_sin_x = 1j/2*(np.eye(n, k=1) - np.eye(n,k=-1)) h = np.kron(gamma*op_eye_x + lamda*op_cos_x, sigmax) + np.kron(lamda*op_sin_x, sigmay) return h This function would return the one-body integral for you. In this function, the $\sigma$ degree of freedom represents the two atoms in the unit cell, and $n$ represents how many unit cells you have in the SSH chain, and for the dimmerized limit you asked for you can take $\gamma = 1,\ \lambda = 2 $. You can use the output of this function fer_op = FermionicOperator(h1 = ssh_ham(1,2,10)) That being said, I'm not sure what the benefit would be. Trying to solve this Hamiltonian using VQE for example is an over-kill since this Hamiltonian can be readily diagonalized from its one-body Hamiltonian. Putting this on a quantum computer would give you $2n$ qubits, this is a Hilbert space of $2^n$ dimensions, whereas you can diagonalize the the Hamiltonian by diagonalizing the $2n \times 2n$ matrix $t_{ij}$.",10/02/2020 12:58
14017.0,How do I visualize the action of Pauli $X$ and $Y$ gates on $|0\rangle$?,"I visualize Pauli Gates making rotations by Ï radians about the x, y, and z axes on the Bloch sphere. If this is the case, then how Pauli-X and Pauli-Y gates applied to $|0\rangle$ differ? As both should rotate the $|0\rangle$ state to same location.",<quantum-gate><programming><pauli-gates>,10/05/2020 04:32,14021.0,14021.0,"Applying X gate to the $|0\rangle$ state gives you $|1\rangle$, and applying Y gate to the $|0\rangle$ state gives you $i|1\rangle$. These states differ only by a global phase (the $i$ scalar multiplier in the second case), so they are not physically distinguishable (you cannot set up an experiment to observe the difference between them). Bloch sphere represents all states that differ by a global phase as one point on it, so you won't be able to see the difference using it. X and Y gates differ in their effect on most other states, though (except $|1\rangle$, which will give you the same issue).",10/05/2020 05:22
14044.0,How can I run a job as offline on real hardware?,"Can I run circuits on real hardware as offline? I mean that a job with 100 circuits may take a long time and I want to shot down my laptop in running time. In the meantime, can the real hardware run all of the circuits in the job, and in another time I can obtain my results? Or is it necessary my laptop to be turned on till I receive the last result? If I need any code for this issue, I would be very grateful anyone can provide it.",<programming><ibm-q-experience>,10/07/2020 19:34,14045.0,14045.0,"All jobs sent to IBMQ backends are asynchronous. You just need to save the job ID and use the ID retrieve it later. For example: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_vigo') job = execute(circuits, backend) print(job.job_id()) Once the job is submitted, you can turn off your laptop. Then when you're ready to get the results, do result = backend.retrieve_job(job_id).result() If you forget to write down the job ID, you can always find it on the IQX dashboard or use backend.jobs() to query for it.",10/07/2020 20:46
14115.0,I don't get anything when calling circuit.draw(),"I'm following the YouTube tutorials for Programming on Quantum Computers and I've completed everything until I reach circuit.draw() since I don't get $|0\rangle$ or 0 next to q or c. Here's my code: from qiskit import * qr = QuantumRegister(2) cr = ClassicalRegister(2) circuit = QuantumCircuit(qr, cr) %matplotlib inline circuit.draw() [ q0_0: q0_1: c0: 2/ ] and so when I attempt an H gate, I receive the error 'QuantumRegister' object is not callable: circuit.h(qr(0)) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-55-c8b4318b743b&gt; in &lt;module&gt; ----&gt; 1 circuit.h(qr(0)) TypeError: 'QuantumRegister' object is not callable",<qiskit><programming>,10/12/2020 12:55,14116.0,14116.0,"There is probably a change on the default arguments of draw() function. To reproduce the same visualization as on the youtube video, try: circuit.draw(initial_state=True, cregbundle=False) and add a Hadamard gate like: circuit.h(qr[0])",10/12/2020 13:07
14141.0,Output a Cirq gate as a Numpy array?,"How do I output a Cirq gate as a Numpy array? For example, I would like to print a Pauli X gate cirq.X as numpy.array([[0,1],[1,0]]) Thank you.",<programming><cirq>,10/14/2020 6:52,14145.0,14145.0,"This can be done by calling cirq.unitary. &gt;&gt;&gt; import cirq &gt;&gt;&gt; cirq.unitary(cirq.X) array([[0.+0.j, 1.+0.j], [1.+0.j, 0.+0.j]])",10/14/2020 14:28
14226.0,Suppress Warnings,"I wish to know how to suppress the following warning obtained on qiskit when I try to add two different types of noise to a qubit WARNING: quantum error already exists for instruction &quot;u2&quot; on qubits [0] , appending additional error. I know that some warnings can be suppressed with import warnings warnings.filterwarnings('ignore', category=DeprecationWarning) but I do not know what category my warning is contained in. I would also like to know if I can access somewhere all the different warning categories. Additionally trying import warnings warnings.filterwarnings('ignore') to suppress all warnings does not help.",<qiskit><programming><ibm-q-experience>,10/18/2020 6:47,14243.0,14243.0,"Qiskit's NoiseModel class processes warnings through a logger from the logging package, not through the warnings package, so suppressing warnings as in other answers won't help. However, each method in NoiseModel provides a warnings parameter; it defaults to True but you can set it to False to prevent the warnings from being logged. Example: myNoiseModel.add_quantum_error(..., warnings=False)",10/19/2020 1:52
14229.0,Qiskit BasicAer simulator options,"I usually use Qiskit &quot;Aer&quot; to simulate quantum circuit with several methods such as statevector, density_matrix, stabilizer, extended_stabilizer, and matrix_product_state. Recenlty I came across another simulator called &quot;BasicAer&quot; and I wonder if the qiskit BasicAer supports above methods.",<qiskit><programming><simulation>,10/18/2020 7:59,14234.0,14234.0,"For any provider, you can check the backends with backends(): from qiskit import BasicAer BasicAer.backends() [&lt;QasmSimulatorPy('qasm_simulator') from BasicAer()&gt;, &lt;StatevectorSimulatorPy('statevector_simulator') from BasicAer()&gt;, &lt;UnitarySimulatorPy('unitary_simulator') from BasicAer()&gt;] Check the doc for each of them: for backend in BasicAer.backends(): print(&quot;%s: %s&quot; % (backend.name(), backend.__doc__)) qasm_simulator: Python implementation of a qasm simulator. statevector_simulator: Python statevector simulator. unitary_simulator: Python implementation of a unitary simulator.",10/18/2020 13:45
14241.0,Producing $|ghz\rangle\langle ghz|$ State in Cirq,"I could manage to produce 3 qubit ghz state in Cirq. But I don't know how I can produce $|GHZ\rangle\langle GHZ|$ in Cirq Here is my code for 3 qubit ghz state Can you help me please for improving my code from $|GHZ\rangle$ to $|GHZ\rangle\langle GHZ|$: n = 3 qubits = cirq.LineQubit.range ( n ) def circuit (): circuit = cirq.Circuit () circuit.append (cirq.H(qubits[0])) for i in range (n-1): circuit.append ( cirq.CNOT ( qubits [i] , qubits [i+1]) ) circuit.append (cirq.measure (* qubits , key ='x') ) print (circuit) return circuit def simulation (circuit): simulator = cirq.Simulator() results = simulator.run ( circuit , repetitions = 200) counts = cirq.plot_state_histogram (results) def main(): simulation (circuit()) if __name__ == &quot;__main__ &quot;: main ()",<programming><quantum-state><cirq><ghz-state>,10/18/2020 18:33,14529.0,14529.0,"Since you can produce the GHZ state, I will skip the corresponding code and just use that QuantumCircuit object to build a density matrix $|GHZ&gt;&lt;GHZ|$. from qiskit.quantum_info import DensityMatrix DM=DensityMatrix.from_instruction(circuit) # here circuit denotes the circuit that contains your GHZ state. Or there is another way to do so(not recommended, just for reference). from qiskit.aqua.operators import StateFn psi=StateFn(circuit)# produce the state vector DM=(psi@~psi).eval()# state ket tensor state bra =density matrix # When calling StateFn function, the quantum circuit must not contain classical register But note that the density matrix produced by the latter method is not admitted by qiskit, because the DensityMatrix object in qiskit has two attributes(the matrix itself and its dimension).",11/08/2020 12:06
14286.0,Multiple Bipartite Entangled State in Cirq,"I am trying to create this state: rho = = q . rho_{1,2} + r . rho_{2,3} + s . rho{1,3} + (1-q-r-s) . rho_separable And I wrote this code: import random import numpy as np import cirq circuit, circuit2, circuit3 = cirq.Circuit() p = 0.2 q = 0.1 r = 0.3 alice, bob, charlie = cirq.LineQubit.range(1, 4) rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) #circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) rho_23 = circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) rho_13 = circuit.append([cirq.H(alice), cirq.CNOT(alice, charlie)]) circuit = rho_12 + rho_23 + rho_13 print(circuit) In here I have 2 problem: 1)This line is not working: circuit = rho_12 + rho_23 + rho_13 2)I cannot multiply the state with p or q or r. What I mean is that I can't write this line: rho_12 = circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) * q Could you please show me how I can write this state?",<programming><quantum-state><entanglement><cirq>,10/21/2020 20:38,14287.0,14287.0,"You seem to think append is returning a circuit, instead of modifying the circuit you called it on. circuit.append(op) doesn't return anything, it adds an operation to circuit. alice, bob, charlie = cirq.LineQubit.range(1, 4) circuit = cirq.Circuit() circuit.append([cirq.H(alice), cirq.CNOT(alice, bob)]) circuit.append([cirq.H(bob), cirq.CNOT(bob, charlie)]) ... Alternatively, you can make a new circuit for each of the pieces and then add them together: rho_12 = cirq.Circuit( cirq.H(alice), cirq.CNOT(alice, bob), ) ... circuit = rho_12 + rho_23 + rho_13",10/21/2020 21:28
14301.0,State Vector Output for T$|1\rangle$ in Qiskit differs from manual calculation. Why is this so?,"The T Gate is defined as $\begin{bmatrix} 1&amp;0 \\ 0&amp;e^{i\pi/4} \end{bmatrix} = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$ So $\begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \vert 1 \rangle = \begin{bmatrix} 1&amp;0 \\ 0&amp;\frac{\sqrt{2}}{2}(1+i) \end{bmatrix} \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ \frac{\sqrt{2}}{2}(1+i) \end{bmatrix}.$ But the following code for the T Gate gives a slightly different output: from qiskit import QuantumCircuit, Aer, execute from qiskit_textbook.tools import array_to_latex qc = QuantumCircuit(1) qc.initialize([0,1],0) # initialize to |1&gt; qc.t(0) display(qc.draw('mpl')) backend = Aer.get_backend('statevector_simulator') # simulate the circuit state = execute(qc,backend).result().get_statevector() # get final state array_to_latex(state, pretext=&quot;\\text{Output} = &quot;) # show final state vector which is $\begin{bmatrix} 0 \\ \frac{1}{\sqrt{2}}(1+i) \end{bmatrix}.$ Why do these two results differ? Thanks for any insights.",<qiskit><programming><quantum-state>,10/22/2020 21:51,14302.0,14302.0,"$\frac{\sqrt{2}}{2}(1+i) $ = $\frac{1}{\sqrt{2}}(1+i)$. To see how this is the case, multiply the numerator and denominator of $\frac{1}{\sqrt{2}}$ by $\frac{\sqrt{2}}{\sqrt{2}}$ = $1$. $\frac {\sqrt{2}}{\sqrt{2}} \frac{1}{\sqrt{2}} = \frac{\sqrt{2}}{{2}}$ . The result doesn't differ; only how it's displayed in comparison to your manual calculation does.",10/22/2020 22:07
14681.0,IBM Q - Individual Run Results,"In Qiskit, is there a way to get the individual results from each shot on the IBM quantum device (instead of simply the summary statistics)? The result JSON file provides the count of all the 1024 shots.",<qiskit><programming><ibm-q-experience>,11/16/2020 18:01,14682.0,14682.0,"You can set memory=True in assemble() or execute(). Then use result.get_memory() to get the per-shot measurement. For example: job = execute(circs, memory=True, shots=4) result = job.result() print(result.get_counts(0)) # prints {'00': 3, '11': 1} print(result.get_memory(0)) # prints ['00', '00', '11', '00']",11/16/2020 19:28
14698.0,$S^{\dagger}$ gate in Q#,"I would like to implement $S^{\dagger}$ gate in Q# and I would like the best way to do it, is it correct to say that $S^{\dagger}$ is equivalent to R1( -Pi()/2 , q) ? Is it also correct to say that $S^{\dagger}$ is equivalent to Rz( -Pi()/2 , q) but with a global phase ? Thank you.",<q#>,11/17/2020 13:31,14699.0,14699.0,It is correct. Since you have $R_1(\theta) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; e^{i\theta}\end{bmatrix}$ and $R_z(\theta) = \begin{bmatrix}e^{-i\theta/2} &amp; 0\\ 0 &amp; e^{i\theta/2}\end{bmatrix}$ just using the value of $\theta = -\pi/2$ gives you $R_1(-\pi/2) = \begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix} = S^{\dagger}$ and $R_z(-\pi/2) = e^{i\pi/4}\begin{bmatrix}1 &amp; 0\\ 0 &amp; -i\end{bmatrix}$ which works exactly the same as $S^{\dagger}$ but with a global phase of $e^{i\pi/4}$.,11/17/2020 13:56
14718.0,How do I check what is wrong in my full-adder code?,"I am trying to solve the first question on the qiskit test which is writing a code for a full adder. So based on my research if I have $A$ q[0], $B$ q[1] and $C$ in q[2] as input and Sum and Cout as output, I should be able to produce the correct outputs by the following gates: q[0] XOR1 q[1] ---&gt; q[4] q[0] AND1 q[1] ---&gt; q[3] q[2] XOR2 q[4] ---&gt; q[5] (SUM) q[2] AND2 q[4] ---&gt; q[6] q[3] OR q[6] ---&gt; q[7] (COUT) Writing the following program I get that my answer is producing wrong results : from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from qiskit import IBMQ, Aer, execute ##### build your quantum circuit here #Define registers and a quantum circuit q = QuantumRegister(8) c = ClassicalRegister(2) qc = QuantumCircuit(q,c) # Preparing inputs qc.x(q[0]) # Comment this line to make Qbit0 = |0&gt; qc.x(q[1]) # Comment this line to make Qbit1 = |0&gt; qc.x(q[2]) # Comment this line to make Qbit2 = |0&gt; ( carry-in bit ) qc.barrier() # AND gate1 implementation qc.ccx(q[0],q[1],q[3]) qc.barrier() # XOR gate1 implementation qc.cx(q[0],q[4]) qc.cx(q[1],q[4]) qc.barrier() # XOR gate2 implementation qc.cx(q[2],q[5]) qc.cx(q[4],q[5]) qc.barrier() # AND gate2 implementation qc.ccx(q[2],q[4],q[6]) qc.barrier() #OR gate implementation qc.cx(q[3],q[7]) qc.cx(q[6],q[7]) qc.ccx(q[3],q[6],q[7]) qc.barrier() # Measuring and put result to classical bit # ( sum ) qc.measure(q[5],c[0]) # ( carry-out ) qc.measure(q[7],c[1]) # execute the circuit by qasm_simulator backend = Aer.get_backend('qasm_simulator') job = execute(qc, backend, shots=1000) result = job.result() count = result.get_counts() print(count) qc.draw(output='mpl') Grading tells me that my results are not matching, but I cannot figure out what is wrong with my code. Thank you so much for help.",<quantum-gate><programming><circuit-construction>,11/19/2020 7:20,14722.0,14722.0,"If I am correct, I suppose you are talking about the Qiskit Challenge 2020. A possible reason why your circuit is being graded wrong is because the question asks you to construct the circuit for full adder and give it the input $A=1$, $B=0$ and $X=1$. However, I think as per your code, you are preparing the qubits to be $|ABX\rangle = |111\rangle$ instead of $|101\rangle$. Baring that, your circuit works perfectly fine from what I could analyze.",11/19/2020 9:28
14719.0,Import Qiskit fails,"I have successfully installed the Qiskit in Anaconda by using pip install qiskit. But I can't import Qiskit and get the following error. --------------------------------------------------------------------------- OSError Traceback (most recent call last) &lt;ipython-input-5-578b7f7e9727&gt; in &lt;module&gt; ----&gt; 1 import qiskit ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\__init__.py in &lt;module&gt; 29 30 # The main qiskit operators ---&gt; 31 from qiskit.circuit import ClassicalRegister 32 from qiskit.circuit import QuantumRegister 33 from qiskit.circuit import AncillaRegister ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\__init__.py in &lt;module&gt; 212 random.random_circuit 213 &quot;&quot;&quot; --&gt; 214 from .quantumcircuit import QuantumCircuit 215 from .classicalregister import ClassicalRegister, Clbit 216 from .quantumregister import QuantumRegister, Qubit, AncillaRegister, AncillaQubit ~\anaconda3\envs\quantum_computing\lib\site-packages\qiskit\circuit\quantumcircuit.py in &lt;module&gt; 23 from collections import OrderedDict, defaultdict 24 from typing import Union ---&gt; 25 import numpy as np 26 from qiskit.exceptions import QiskitError 27 from qiskit.util import is_main_process ~\AppData\Roaming\Python\Python38\site-packages\numpy\__init__.py in &lt;module&gt; 138 139 # Allow distributors to run custom init code --&gt; 140 from . import _distributor_init 141 142 from . import core ~\AppData\Roaming\Python\Python38\site-packages\numpy\_distributor_init.py in &lt;module&gt; 24 # NOTE: would it change behavior to load ALL 25 # DLLs at this path vs. the name restriction? ---&gt; 26 WinDLL(os.path.abspath(filename)) 27 DLL_filenames.append(filename) 28 if len(DLL_filenames) &gt; 1: ~\anaconda3\envs\quantum_computing\lib\ctypes\__init__.py in __init__(self, name, mode, handle, use_errno, use_last_error, winmode) 379 380 if handle is None: --&gt; 381 self._handle = _dlopen(self._name, mode) 382 else: 383 self._handle = handle OSError: [WinError 193] %1 is not a valid Win32 application So what should I do to solve this problem?",<qiskit><programming>,11/19/2020 8:37,14760.0,14760.0,Reinstalling numpy didn't work for me. I delete the C:\Users\USERNAME\AppData\Roaming\Python\Python38\* folder because that was left behind by a previous Python which I had uninstalled. And this work for me. Thanks to everyone who all answered my questions and I appreciate it.,11/21/2020 10:13
14785.0,How to apply a operator to qubit system on the basis of current state of system?,"Suppose I have three different operators $U_1, U_2,U_3$. Now, these three operators will be applied if my current state of the system is $|\psi_0\rangle,|\psi_1\rangle $ and $|\psi_2\rangle$ respectively. Now suppose I started with some initial state $|\psi_{initial}\rangle$ and after applying two unitary operations it will be converted to one of the states above and on the basis of that the respective unitary operator needs to applied. I know we can't measure the state as it will collapse the system. So, what method can be applied here?",<quantum-gate><programming><quantum-state><unitarity>,11/22/2020 16:06,15080.0,15080.0,"I assume that you have a qubit register $q$ and given that the state of $q$ is $|\psi_i\rangle$ you want to apply $U_i$ to $q$ for $i=0,1,2$. If this is what you wish to do, then unfortunately if the states $|\psi_i\rangle$'s are not orthogonal to each other, then this kind of operations are not possible in a quantum setting in for any general $U_i$'s. This is not possible because such an operator is not unitary. For instance take the simple case of $q$ being in either the state $|0\rangle$ or $|+\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}$ and I wish to apply $I$ on $q$ if it is in the state $|0\rangle$ and $H$ gate on $q$ if the state of $q$ is $|+\rangle$. This mathematically would mean that I need an operator $U$ that works as follows: $$U|0\rangle=|0\rangle \text{ and } U|+\rangle = \frac{1}{\sqrt{2}}(U|0\rangle + U|1\rangle) =|0\rangle.$$ It is quite obvious that $U$ is not reversible and hence is not a unitary. So such a quantum operation does not exist. However, if the states $|\psi_i\rangle$'s are orthogonal to each other and the state in $q$ is one of these states and is not any superposition of these states, then certainly you can measure and then conditioned on the measured result you can apply the $U_i$ of your choice.",12/10/2020 09:26
14820.0,Cirq.simulate expectation value of a Hamiltonian,I want to simulate the final state of an ansatz in cirq using simulate. Now I want to calculate the expectation value of a Hamiltonian. How do I do this? I can only find simulator.run examples in cirq. But I want to access the wavefunction and therefore would need simulator.simulate. Is there a function in cirq I can use or how could I do this?,<programming><hamiltonian-simulation><cirq>,11/24/2020 22:40,14823.0,14823.0,"You can get the wavefunction from cirq.final_state_vector(circuit). Then you can define your observable as an instance of cirq.PauliSum, on which you will be able to use the expectation_from_state_vector() method to get the expectation value.",11/25/2020 0:32
14870.0,"IBMQ: ""Credentials are already in use""","Executing the following: import numpy as np from qiskit import IBMQ, QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator from qiskit.providers.ibmq import least_busy from qiskit.visualization import plot_histogram from qiskit.tools.jupyter import * provider = IBMQ.load_account() I get the following error which I do not know what to do about, does anybosy know what I can do? ibmqfactory.load_account:WARNING:2020-11-27 13:08:45,170: Credentials are already in use. The existing account in the session will be replaced.",<programming><qiskit><ibm-q-experience>,11/27/2020 19:15,14871.0,14871.0,"This is NOT an error. It just means that you have loaded your account previously, maybe from the previous run. It will just replace your previous credential... and shouldn't cause any issue.",11/27/2020 19:25
14874.0,Why do I get the error name operator is not defined?,"I checked this code multiple times, I am trying to reproduce the same code using Grover's algorithm from qiskit summerschool: import numpy as np from qiskit import IBMQ, QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator from qiskit.providers.ibmq import least_busy from qiskit.visualization import plot_histogram from qiskit.tools.jupyter import * provider = IBMQ.load_account() def phase_oracle(n, indices_to_mark, name='Oracle'): qc = QuantumCircuit(n, name=name) oracle_matrix = np.identity(2**n) for index_to_mark in indices_to_mark: oracle_matrix[index_to_mark, index_to_mark]= -1 qc.unitary(operator(oracle_matrix), range(n)) return qc def diffuser(n): qc=QuantumCircuit(n,name='Diff - &quot;V&quot;') qc.h(range(n)) qc.append(phase_oracle(n,[0]),range(n)) qc.h(range(n)) return qc def Grover(n, marked): qc=QuantumCircuit(n,n) r = int(np.round(np.pi/ (4*np.arcsin(np.sqrt(len(marked)/2**n)))-1/2)) print(f'{n} qubits, basis state {marked} marked, {r} rounds') qc.h(range(n)) for _ in range(r): qc.append(phase_oracle(n,marked),range(n)) qc.append(diffuser(n),range(n)) qc.measure(range(n),range(n)) return qc n = 5 x = np.random.randint(2**n) marked = [x] qc = Grover(n, marked) qc.draw() I get the name operator error which I cannot figure out the reason: NameError Traceback (most recent call last) &lt;ipython-input-22-96635782dc30&gt; in &lt;module&gt; 2 x = np.random.randint(2**n) 3 marked = [x] ----&gt; 4 qc = Grover(n, marked) 5 6 qc.draw() &lt;ipython-input-20-f14e47e0af5d&gt; in Grover(n, marked) 20 qc.h(range(n)) 21 for _ in range(r): ---&gt; 22 qc.append(phase_oracle(n,marked),range(n)) 23 qc.append(diffuser(n),range(n)) 24 qc.measure(range(n),range(n)) &lt;ipython-input-20-f14e47e0af5d&gt; in phase_oracle(n, indices_to_mark, name) 4 for index_to_mark in indices_to_mark: 5 oracle_matrix[index_to_mark, index_to_mark]= -1 ----&gt; 6 qc.unitary(operator(oracle_matrix), range(n)) 7 return qc 8 NameError: name 'operator' is not defined. Can anybody help me woth this?",<programming>,11/27/2020 22:54,14877.0,14877.0,"That is because on line 14 of your program, you wrote: qc.unitary(operator(oracle_matrix), range(n)) when it should be: qc.unitary(Operator(oracle_matrix), range(n)) You should have capitalized the O in operator. Changing that, I get the following output when executed your code: 5 qubits, basis state [15] marked, 4 rounds ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» q_0: â¤ H ââ¤0 ââ¤0 ââ¤0 ââ¤0 ââ¤0 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_1: â¤ H ââ¤1 ââ¤1 ââ¤1 ââ¤1 ââ¤1 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_2: â¤ H ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; ââ¤2 Oracle âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_3: â¤ H ââ¤3 ââ¤3 ââ¤3 ââ¤3 ââ¤3 âÂ» âââââ¤â ââ ââ ââ ââ âÂ» q_4: â¤ H ââ¤4 ââ¤4 ââ¤4 ââ¤4 ââ¤4 âÂ» ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» c: 5/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» Â« ââââââââââââââââââââââââââââââââââââââââââââ Â«q_0: â¤0 ââ¤0 ââ¤0 ââ¤Mâââââââââââââ Â« â ââ ââ âââ¥ââââ Â«q_1: â¤1 ââ¤1 ââ¤1 âââ«ââ¤Mââââââââââ Â« â ââ ââ â â ââ¥ââââ Â«q_2: â¤2 Diff - &quot;V&quot; ââ¤2 Oracle ââ¤2 Diff - &quot;V&quot; âââ«âââ«ââ¤Mâââââââ Â« â ââ ââ â â â ââ¥ââââ Â«q_3: â¤3 ââ¤3 ââ¤3 âââ«âââ«âââ«ââ¤Mââââ Â« â ââ ââ â â â â ââ¥ââââ Â«q_4: â¤4 ââ¤4 ââ¤4 âââ«âââ«âââ«âââ«ââ¤Mâ Â« âââââââââââââââââââââââââââââââââââââââââ â â â â ââ¥â Â«c: 5/âââââââââââââââââââââââââââââââââââââââââââ©âââ©âââ©âââ©âââ©â Â« 0 1 2 3 4",11/28/2020 1:18
14887.0,Does 1 qubit correspond to 2 bits?,"In a lot of presentation I always see people say that $n$ qbit are approximately $2^n$ classical bit. Those talks where oriented for a broad audience, so they left out a lot of things. Deep down I felt that this couldn't be possible, but I didn't know anythings about qc so maybe this was the problem. Now I've started learning qc (as a computer engineer) and I'm studying the concept of super dense coding, that it the base of the association $n$ qbit equal $2^n$ classical bits.(If it's not this let me know) I've understood what the topic is about, but I still think that the association $n$ qbit equal $2^n$ classical bits is wrong or at least misleading. Sending 2 bit to Bob, will require Alice to have 1 qbit and 1 entangled qbit where the other part of the eqbit is owned by Bob. Just by reading this is clear that 2 bit actually correspond to 1 qbit + 1eqbit, but reading online one common approach to say that 1qbit=2bit is by introducing a third part that is responsible to send and eqbit to Alice and Bob. Isn't this a flawed way to think? When someone say $n$ qbit equal $2^n$ bit, they are implicitly stating that there is a way to encode the information of $2^n$ bits in $n$ qbit, but if you actually study the theory is not like this. Also saying that 1qbit +1eqbit =2 bit, is not too much different than saying 1qbit+1qbit=2qbit=2bit, because at the end of the day 1eqbit is just a qbit in a particular state. I know that differentiating between them is important since they are two different things, but physically we can see them as two object (two photons for example) that are in a different position, still they 'occupy the space of two object'. I also know that approximating 1 eqbit with 1 qbit is a strong affirmation, but stating that 1qbit = 2bit is stronger imo. Is my way of thinking flawed? Why and where? Also there is another thing that I couldn't understand on my own. In the textbook that I'm using (Quantum Computation and Quantum Information) one thing that they say is: Suppose Alice and Bob initially share a pair of qubits in the entangled state.. Since the sharing of the eqbit and the sending of the qbit seems to happen in two different temporal window, they are able to store qbit? In essence I don't understand the temporal window of the algorithm. I understand how it works, but not when. Can you clarify this? Note that this second question is related to the first, because I kind of understand the point of super dense coding, if you can send qbit at two different time and exploit quantum mechanics to send less qbit when needed, but if everything happen at the same time (the sending of the eqbit and the sending of the qbit) then I don't know the point of super dense coding.",<classical-computing><superdense-coding>,11/28/2020 15:48,14896.0,14896.0,"Lets start with notion that $n$ qubits are equivalent to $2^n$ classical bits. This is wrong. However, it is true that to describe a quantum state composed of $n$ qubits we need $2^n$ complex numbers since $n$ qubits state is superposition containing all combination of $n$ classical qubits ($2^n$). Writen by formula, $n$ qubits state is $$ |q_0q_1...q_{n-1}\rangle = \sum_{i=0}^{2^n}a_{i}|i\rangle, $$ where $i$ represent basis states (e.g. $|0...00\rangle$, $|0...01\rangle$, $|0...10\rangle$, $|0...11\rangle$ etc. until $|1...11\rangle$) and $a_{i} \in \mathbb{C}$. Concerning information contained in qubits. Any qubit can be described as $$ |q\rangle = \alpha|0\rangle + \beta|1\rangle, $$ where $\alpha, \beta \in \mathbb{C}$. Since paraeters $\alpha$ and $\beta$ are complex numbers, theoretically a qubit can contain infinite amount of information because you need infinite amout of bits to represent complex number exactly. This is of course impossible in reality since computers have finite memory. Moreover and what is the most important, when you measure a qubit, it collapeses to either 0 or 1. So, in the end you have either 0 or 1, i.e. one classical bit. Therefore, one qubit contains one bit of information. Regarding superdense coding. It is often said that in superdense coding you send only one qubit but in the end you have two classical bits. It is true that you send only one qubit but to have superdense coding, you need to have two entangled qubits before. So, effectively two qubits are needed for transmiting two classical bits.",11/29/2020 8:00
14934.0,Using Qiskit VQE for solving an eigenvalue problem,"I am a new user of Qiskit and I believe there is a simple answer to my question but I have had a very hard time finding a straightforward answer. I am trying to transform a given $3 \times 3$ (Hermitian) Hamiltonian matrix into a qubit operator and then use the built-in VQE solver for evaluating the minimum eigenvalue for said matrix. I have been successful in doing something similar using the qiskit.chemistry.FermionicOperator built-in class (see example below) but for this example the Hamiltonian is mapped to a Fermionic one-body qubit Hamiltonian which has $2^n$ eigenvalues instead of $n$ eigenvalues (where $n=3$ for this case). I am hoping there is a simple way to directly map a matrix to a qubit operator. My vague understanding is I need to write the matrix as a sum of weighted Pauli operators but I would expect there would exist some predefined function for doing this? (I have looked at the source code for the FermionicOperator class but it did not help me much). import numpy as np import scipy import h5py from qiskit.aqua.algorithms import VQE, NumPyEigensolver from qiskit.chemistry import FermionicOperator from qiskit import Aer backend = Aer.get_backend(&quot;qasm_simulator&quot;) c1=1 c2=2 c3=3 ff=np.zeros((3,3)) ff[1,1]=2 ff[2,2]=1 n=3 Hamil=np.zeros((n,n)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=np.sqrt(2)*c1 Hamil[1,2]=np.sqrt(2)*c1 Hamil[2,0]=np.sqrt(2)*c1 Hamil[2,1]=np.sqrt(2)*c1 vals,vecs=np.linalg.eig(Hamil) print(&quot;Standard Eigenvalues: &quot;) print(vals) Hamil_op = FermionicOperator(h1=Hamil) Hamil_ops = Hamil_op.mapping(map_type='parity', threshold=1e-12) result = NumPyEigensolver(Hamil_ops,k=int(2**n)).run() print(&quot;Quibit Eigenvalues=&quot;) print(result['eigenvalues']) vqe = VQE(operator=Hamil_ops) vqe_result = np.real(vqe.run(backend)['eigenvalue']) print(&quot;VQE Eigenvalue&quot;) print(vqe_result) With result: Standard Eigenvalues: [-1.45426242 0.90078898 3.05347344] Quibit Eigenvalues= [-1.45426242+0.j -0.55347344+0.j 0. +0.j 0.90078898+0.j 1.59921102+0.j 2.5 +0.j 3.05347344+0.j 3.95426242+0.j] VQE Eigenvalue 0.18608074335373637",<qiskit><programming><vqe><eigenvalues-and-eigenvectors>,12/02/2020 20:00,14999.0,14999.0,"I believe to have answered my own question through further attempts. Per the comment from KAJ226, it is true that a $(3 \times 3)$ matrix cannot be represented as a string of Paulis so I have nested the $(3 \times 3)$ matrix into a $(4 \times 4)$ matrix where the final row and column are all zeros. From this I can omit the useless eigenvalue/eigenvector and just retain the relevant results for the $(3 \times 3)$ matrix. My solution mostly came from using the WeightedPauliOperator, MatrixOperator, and op_converter classes. Below is a sample of my code with corresponding outputs. Thanks to those who gave suggestions to help me out! import numpy as np import scipy import h5py from qiskit.aqua.algorithms import VQE, NumPyEigensolver from qiskit.aqua.operators import WeightedPauliOperator, MatrixOperator, op_converter from qiskit import Aer backend = Aer.get_backend(&quot;qasm_simulator&quot;) c1=-0.5 c2=.75 c3=2 n1=3 Hamil=np.zeros((n1,n1)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=c1 Hamil[1,2]=c1 Hamil[2,0]=c1 Hamil[2,1]=c1 print(&quot;(3x3) Hamiltonian&quot;) print(Hamil) vals,vecs=np.linalg.eig(Hamil) print(&quot;Standard Eigenvalues: &quot;) print(vals) n2=4 Hamil=np.zeros((n2,n2)) Hamil[1,1]=c2 Hamil[2,2]=-c3/2+c2 Hamil[0,2]=c1 Hamil[1,2]=c1 Hamil[2,0]=c1 Hamil[2,1]=c1 print(&quot;(4x4) Hamiltonian&quot;) print(Hamil) Hamil_Mat=MatrixOperator(Hamil) Hamil_Qop = op_converter.to_weighted_pauli_operator(Hamil_Mat) q_vals = NumPyEigensolver(Hamil_Qop,k=4).run() print(&quot;Qubit Op Eigenvalues: &quot;) print(q_vals['eigenvalues']) vqe=VQE(Hamil_Qop) vqe_result=vqe.run(backend) print(&quot;VQE Eigenvalue: &quot;) print(vqe_result['eigenvalue']) With result: (3x3) Hamiltonian [[ 0. 0. -0.5 ] [ 0. 0.75 -0.5 ] [-0.5 -0.5 -0.25]] Standard Eigenvalues: [-0.75 0.25 1. ] (4x4) Hamiltonian [[ 0. 0. -0.5 0. ] [ 0. 0.75 -0.5 0. ] [-0.5 -0.5 -0.25 0. ] [ 0. 0. 0. 0. ]] Qubit Op Eigenvalues: [-0.75+0.j 0. +0.j 0.25+0.j 1. +0.j] VQE Eigenvalue: (-0.705078125+0j)",12/05/2020 20:23
14945.0,Why is the Measurement Result Always 1? (expected to find uniformly random measurement),"I created a $|0\rangle$ state then applied $H$ gate to get $\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)$ and then I meausred my state. But I always found 1. I expected to find 0 and 1 uniformly random like the case of beam splitter. Here is my code: qubit = cirq.NamedQubit(&quot;myqubit&quot;) circuit = cirq.Circuit(cirq.H(qubit)) for i in range(10): result2 = cirq.measure(qubit, key='myqubit') print(result2) print(circuit) # run simulation result = cirq.Simulator().simulate(circuit) print(&quot;result:&quot;) print(result) print(result2) How can I find uniformly random result ?",<programming><quantum-state><measurement><cirq><random-quantum-circuit>,12/03/2020 14:40,14949.0,14949.0,"You are not measuring your qubit. Look at what your print(circuit) is returning myqubit: âââHâââ You need to add the measurement gate to the circuit like so: circuit = cirq.Circuit(cirq.H(qubit), cirq.measure(qubit, key='myqubit')) Printing this circuit returns myqubit: âââHâââMâââ In your case, with the loop; you can append the gates: for i in range(10): circuit.append(cirq.measure(qubit, key='myqubit')) Printing this one returns myqubit: âââHâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââMâââ Both programs will get you the expected uniform random measurements.",12/03/2020 16:32
15058.0,How to project a composite system down into a smaller subspace in Python?,"If we have a composite system over five qubits ($|\psi\rangle = |a\rangle|b\rangle|c\rangle|d\rangle|e\rangle$), and I want to project into a specific subspace of the first three systems, I can build a projector of the form $|011\rangle\langle011| \otimes I_{de}$ (for example). Before projecting, state $|\psi\rangle$ can be thought of as an array with length $2^5 = 32$. My goal is to do the projection and reduce the size of my vector appropriately (so now I only have an array over the final two qubits). I'm doing this in Qiskit (after I get the statevector and am done evolving). My projectors will always have the form above, just perhaps with a different bitstring (in my example, I had &quot;011&quot;). This is what I've done so far: Since the projectors are diagonal, I convert the string &quot;011&quot; into an integer. In this case, it's 3. The corresponding matrix will look like: $$ \begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{pmatrix} .$$ Because the subspace is like this, the identity matrix $I_{de}$ will just be a matrix of size $2^2\times2^2$ and when we take the tensor product, we will get a matrix similar to the one above, but now the size of the matrix will be bigger, and the $1$ that's above will be the only place where the identity shows up (since everywhere else will be zero). I won't write down the matrix because it has size $32\times32$. If I have my state $|\psi\rangle$ and I want to project down, I figured I just had to find the components of my 32-element array which correspond to this subspace. If the position of the 1 in my matrix above is given by $p$ and my state is an array called psi, then I want to say that the projection is given by simply slicing my array as such: projected = psi[(2**2)p:(2**2)*(p+1)] My question is: Am I doing the right slicing in step 4? I think I am, but it's easy to get tripped up with these subspaces. I know that this won't work in general since the projection operator could be more involved, but in the case where it's diagonal like the above matrix and is only one element, do I have the steps involved correct?",<programming><projection-operator>,12/08/2020 21:34,15069.0,15069.0,"Your slicing is correct, and gives the right answer in your example. Here is a generalization of your slicing, for the case where you may have a different string of bits. import numpy as np def return_indices(subspace): n_qubits = len(subspace) indices = np.array(range(32)).reshape((2,)*n_qubits) output_indices = indices[subspace].reshape(-1) return output_indices # building a test psi to see if the code works well psi = np.zeros(32, dtype=np.complex) psi[12:16] = list(range(1,5)) # representing the subspace that we would like to project on subspace = (0,1,1,slice(0,2),slice(0,2)) output_indices = return_indices(subspace) #returns array([12, 13, 14, 15]) psi[output_indices] #returns array([1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j]) I also ran another test, by taking subspace2 = (1,0,slice(0,2),1,slice(0,2)) output_indices2 = return_indices(subspace2) Then output_indices2 is array([18, 19, 22, 23]), as it should. Edit: In case you are interested in projecting on the subspace where the first qubit is $0$, the second qubit is $1$ and the third quibit is $+$, then you can simply use linear superposition. Indeed, this is $1/\sqrt{2}$ times the projection of the state on the $|010::\rangle$ subspace plus $1/\sqrt{2}$ times the projection of the state on the $|011::\rangle$ subspace. I am using a colon, just as in Python, to indicate that the corresponding index is free. So you can adapt the code to handle a case where you have a $+$ state. However, the code is written assuming you are mostly interested in $0$ and $1$ states.",12/09/2020 15:22
15087.0,How can I resolve this get_count issue from running multiple circuits?,"I'm running a couple of circuits at the same time using an array of variables. However, I met an issue regarding accessing the counts. Here's part of the code I have: probsu = [] circuits = [] for i in range(len(Variable)): circuit = QuantumCircuit(qrz,crz) circuit = qc(Variable[i]) circuits.append(circuit) prob = counts['1001'] / sum(counts.values()) **Issue here** probsu.append(prob) **Issue here** circuits = transpile(circuits, backend=backend) job_manager = IBMQJobManager() MyExperiments = job_manager. run(circuits, backend=backend, name='MyExperiment') results = MyExperiments.results() counts = results.get_counts(circuit) I'm not able to get the counts since the line is referenced before the definition in the last line. However, there will be similar issues pop up if I remove the bottom lines before the for loop. How can I resolve this issue? Thanks:)",<programming><qiskit><experiment>,12/10/2020 17:13,15088.0,15088.0,"You mean something like this? %matplotlib inline # Importing standard Qiskit libraries from qiskit import QuantumCircuit, QuantumRegister, IBMQ, ClassicalRegister from qiskit.circuit import QuantumCircuit, ParameterVector from qiskit.compiler import transpile, assemble from qiskit.providers.ibmq.managed import IBMQJobManager from qiskit.visualization import * provider = IBMQ.load_account() backend = provider.get_backend('ibmq_qasm_simulator') def qc(Variable): var_form = QuantumCircuit(2,2) var_form.ry(Variable,0) var_form.cx(0,1) var_form.h(1) var_form.measure([0,1],[0,1]) return var_form Variables = [1,2,3,4,5] circuits = [] for i in range(len(Variables) ): circuit = QuantumCircuit(2,2) circuit = qc(Variables[i]) circuits.append( circuit ) circuits = transpile(circuits, backend=backend) job_manager = IBMQJobManager() MyExperiments = job_manager.run(circuits, backend=backend, shots =1000, name='MyExperiment') results = MyExperiments.results() probsu = [] for i in range(len(Variables) ): prob = results.get_counts(i)['11']/sum( results.get_counts(i).values() ) probsu.append(prob) print('probability of getting |11&gt; at each circuit:', probsu) which generate the output: probability of getting |11&gt; at each circuit: [0.121, 0.33, 0.458, 0.417, 0.178] the output above corresponds to the probabilities of reading out $|11\rangle$ on each of the 5 circuits... You can modify this circuit to your purpose... as this is only an example.",12/10/2020 17:45
15096.0,Classically controlled quantum operators,Does CirQ support classically controlled quantum operators where the classical values obtained by the measurement?,<programming>,12/11/2020 00:48,15097.0,15097.0,"Currently, there is no mechanism for performing classical feedback in cirq. It is on the roadmap. It will probably look something like cirq.X(q)**measurement_result(key) in the end, but for now it doesn't exist.",12/11/2020 05:37
15109.0,ProjectQ - Error messages,"How can we get rid of runtime next error: Traceback (most recent call last): File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\types\_qubit.py&quot;, line 135, in __del__ self.engine.deallocate_qubit(weak_copy) File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_basics.py&quot;, line 153, in deallocate_qubit tags=[DirtyQubitTag()] if is_dirty else [])]) File &quot;C:\Users\Marija\Anaconda3\lib\site-packages\projectq\cengines\_main.py&quot;, line 288, in send raise compact_exception # use verbose=True for more info RuntimeError: Qubit has not been measured / uncomputed. Cannot access its classical value and/or deallocate a qubit in superposition! raised in: ' File &quot;C:\\Users\\Marija\\Anaconda3\\lib\\site-packages\\projectq\\backends\\_sim\\_pysim.py&quot;, line 139, in get_classical_value' ' raise RuntimeError(&quot;Qubit has not been measured / &quot;'```",<programming>,12/11/2020 10:49,15490.0,15490.0,"By measuring all the qubits at the end of the code, I avoided the above-mentioned error message.",01/12/2021 01:06
15189.0,XY Hamiltonian in a 1D Heisenberg Chain,"I've been trying to implement the 1D Heisenberg chain (i.e. the XXZ model) on Qiskit but have been having trouble. To recap, the Heisenberg hamiltonian is as follows: $$H_{XXZ} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1} + \Delta S^{z}_{i}S^{z}_{i+1})] $$ and we can take the XY hamiltonian to be $$H_{XY} = \sum^{N}_{i = 1} [J(S^{x}_{i}S^{x}_{i+1} + S^{y}_{i}S^{y}_{i+1})]$$ as I understand. I know that the matrix representation of this hamiltonian's time evolution takes the form $$XY(\theta) = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; \cos[{\theta}/2] &amp; i\sin[{\theta}/2] &amp; 0\\ 0 &amp; i\sin[{\theta}/2] &amp; \cos[{\theta}/2] &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}$$ however, I'm not exactly sure how to implement it on Qiskit with the available Quantum logic gates. I do know that a special case to this problem is the iSwapGate, where it is equal to $XY(\theta = \pi)$, but is there a way to implement $XY(\theta)$ for arbitrary angles?",<quantum-gate><programming><qiskit><hamiltonian-simulation><matrix-representation>,12/18/2020 18:17,15191.0,15191.0,"Here is an implementation from qiskit.circuit import QuantumCircuit, Parameter theta = Parameter('Î¸') qc = QuantumCircuit(2) qc.cx(0, 1) qc.crx(-1 * theta, 1, 0) qc.cx(0, 1) print(qc) --- ââââââââââ q_0: âââ âââ¤ RX(-Î¸) ââââ ââ âââ´âââââââ¬ââââââââ´ââ q_1: â¤ X ââââââ ââââââ¤ X â âââââ âââââ and to evaluate that it works: from qiskit.quantum_info import Operator def XY(theta): c = np.cos(theta / 2) s = 1j * np.sin(theta / 2) return np.array([[1, 0, 0, 0], [0, c, s, 0], [0, s, c, 0], [0, 0, 0, 1]]) val = pi / 14 circ = qc.bind_parameters({theta: val}) np.allclose(Operator(circ).data, XY(val)) --- True",12/18/2020 19:51
15233.0,Increase maximum shots on IBM Hardware when running Quantum Variational Algorithms,"I am interested to know whether there is a quick and elegant way of increasing the number of shots (more than 8192 shots) on IBM hardware when running variational algorithms like VQE or QAOA. I know that within Qiskit, I can specify: backend._configuration.max_shots= shots to change the number of max_shots but this only works for simulator. I can't increase the shots parameter to go over 8192 shots when I set my backend as one of the real hardware. That is, if I specify the following: hardware_backend = provider.get_backend('ibmq_valencia ') maxshots = 20000 hardware_backend._configuration.max_shots= maxshots quantum_instance = QuantumInstance(hardware_backend, shots = maxshots, initial_layout = None, optimization_level = 3) then upon executing the circuit, I will have an error message: Error is : The number of shots in the Qobj (20000) is higher than the number of shots supported by the device (8192). Is there a quick and elegant way to overcome this issue within Qiskit? Thank you!",<programming><qiskit><ibm-q-experience><vqe>,12/22/2020 19:20,15238.0,15238.0,"According to my knowledge, 8192 is a maximum of shots. I think that the reason is fair timesharing as nowadays there are many users of IBM Q. To get better results from VQE, I can only recommend to run your task several times and then pick up the best solution, i.e. the one wiht the lowest (highest) value of the optimized function.",12/23/2020 7:34
15284.0,"How can I run a set of circuits, each of which has 100 shots?","I'm running simulations of my quantum circuit, which includes both parametrized variables and random numbers. The question I'm trying to solve is that for each parameterized variable, I will generate a set of quantum circuits, each element of which contains different random numbers. I'm hoping to run each quantum circuit in the set with 100 shots, then carry out some analyses on the counts. I'm not exactly sure how I can do that, here's part of the code I have: from qiskit import IBMQ provider = IBMQ.load_account() sim = provider.backends.ibmq_qasm_simulator backend = provider.get_backend('ibmq_qasm_simulator') E = np.linspace(-5,5,10) # Parameters circuits = [] nuni = 10. # Number of the circuits in each set. for i in range(10): circuitsi = [] for j in range (nuni): circuit = QuantumCircuit(qrz,crz) circuit = qc(E[i]) # qc is a function with both parameters and random numbers. circuitsi.append(circuit) circuits.append(circuitsi) for i in range (len(circuits)): for j in range (nuni): circuits[i][j] = transpile(circuits[i][j],backend=backend) for i in range (10): job_manager = IBMQJobManager() MExperiments = job_manager.run(circuits[i], backend=backend, shots = nshot) results = MExperiments.results() for j in range (nuni): counts = results.get_counts(circuits[i][j]) My current code doesn't quite work, I'm wondering am I on the right track? How can I fix my code? Thanks a lot for your help:) Update: My code works, but it takes a really long time to run. I'm still wondering if there's a simpler way to carry out the experiment? Thanks!",<qiskit><programming>,12/26/2020 21:36,15297.0,15297.0,"In your code, circuits is an array of array of quantum circuits and each element of circuits is an array of quantum circuits. In the code, you are using a for loop to run each element of the circuits array individually using the for loop. This runs each of the 10 array of circuits one after the other. However, you can run all the quantum circuits of all the arrays all at once. All you have to do is to construct an array say all_circuits and append all the quantum circuits of each of the circuitsi. Then you can run the simulation using this array of circuits. Once the results are out, you can then post process it to get an array of array of results. So the code after creating all the circuits will be more like the below: all_circuits = [] for i in range(10): all_circuits += circuits[i][:] from qiskit.tools.monitor import job_monitor qjob = execute(all_circuits,shots=shots,backend=backend) job_monitor(qjob) result = qjob.result() counts = [] for i in range(10): count_i = [] for j in range(nuni): count_i.append(result.get_counts(all_circuits[(nuni*i)+j])) counts.append(count_i) Since you execute all the circuits at one, this would reduce the time of execution quite a lot. Also, if you are using execute, you could also skip transpile since transpile will also be performed as a part of execute. This might not decrease the run time but might help in writing the code simpler. I hope this helps.",12/27/2020 10:45
15462.0,Quantum PRGN against Hard disk Forensics,"We can make use of the Qbit to make a random string of bytes then as I have an office laptop and I can do some espionage by copying the files to my local disk from the network share and upload it to some online board. It Leaves a shadow file if I choose to delete it and or encrypt the file. If forensics is performed then that file can be retrieved in its entirity( best case), partially(most cases), encrypted entirety( rarely), or a sign that the file was attempted to be shredded and implementation may vary from OS to OS and File system to file system. My proposal is that we expose an online service where we input the remaining size of our harddisk, let's suppose I have a disk size of 2TB and 1.5TB is remaining so I shall download a file with Quantum random numbers of size 1.5TB hence overriding all the memory cell even if the disk firmware is ware balanced it will not be able to preserve the fragments of the previously deleted files as we are filling all the leftover disk space with random quantum numbers.",<programming><random-quantum-circuit>,01/10/2021 04:12,15482.0,15482.0,"To erase a HDD with a random numbers generated by quantum computer is in theory possible. Lets imagine you want to generate bit strings of length $n$, then you can simply put Hadamard gates on $n$ qubits. Such simple circuit prepares equal superposition of all $n$ bit long strings. When you put measurement after the Hadamard gates and run the circuit on a quantum computer you will get a random bit string coming from uniform distribution. However, nowadays there are two main obstacles: A small number of qubits in current quantum processors (as far as I know, IBM offers 63 qubit processor). But this can be easily overcame but producing higher number of shorter bitstrings. Most importantly, you would need to run your circuit many times to produce 1.5 TB of random bits. Since 1.5 TB = 12 Tb and suppose that you are able to produce at 63 bits long stings (on the IBM computer I mentioned above), this will take 190 million of runs. This is possible, however, I do not think that IBM would allow such load of their systems now. To conclude, yes it is possible but because of small capacity of current quantum computer it is difficult to do so. Just suggestion: try to use some physical generator of random numbers. They are based on measuring thermal noise. Produced random numbers are really random as in case of quantum computer. No algorithms like linear congruential generator is used.",01/11/2021 08:32
15464.0,Job fails when using PulseSimulator: Job Status: job incurred error,"I'm trying to simulate a basic circuit using the PulseSimulator in Qiskit. The following Qiskit Pulse code works when I run it on the real device, but not when using the PulseSimulator. The job monitor tells me Job Status: job incurred error and nothing else. Trying to run any gates native to the device causes an issue. If I remove schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi) then it runs fine, but I can't figure out what I'm doing wrong. I'd deeply appreciate any support. I'm using qiskit 0.23.2 #Essential Imports import numpy as np # Qiskit Imports from qiskit.providers.aer import PulseSimulator from qiskit import IBMQ, assemble from qiskit.tools.monitor import job_monitor import qiskit.pulse as pulse # Connect to an IBMQ Account and Backend API_TOKEN = '' IBMQ.save_account(API_TOKEN, overwrite=True) IBMQ.load_account() provider = IBMQ.get_provider() backend = provider.get_backend(&quot;ibmq_armonk&quot;) backend_pulse_simulator = PulseSimulator.from_backend(backend) #backend # Get information about the backend qubit = 0 backend_defaults = backend.defaults() backend_properties = backend.properties() qubit_frequency_updated = backend_properties.qubit_property(qubit, 'frequency')[0] inst_sched_map = backend_defaults.instruction_schedule_map measure_schedule = inst_sched_map.get('measure', qubits=[qubit]) # Assemble a job - circuit with a single qubit-&gt; u2 gate -&gt; measurement num_shots_per_point = 1024 drive_chan = pulse.DriveChannel(qubit) schedule = pulse.Schedule() schedule += inst_sched_map.get('u2', [qubit], P0=0.0, P1=np.pi) # Removing this solves the issue - why? schedule += measure_schedule &lt;&lt; schedule.duration pulse_program = assemble(schedule, backend=backend_pulse_simulator, meas_level=2, meas_return=&quot;single&quot;, shots=num_shots_per_point, schedule_los=[{drive_chan: qubit_frequency_updated}]) # Run the job job = backend_pulse_simulator.run(pulse_program) job_monitor(job)",<programming><qiskit><simulation><openpulse>,01/10/2021 05:04,15487.0,15487.0,"The Job Status: job incurred error with pulse can be the result of a timing problem in the execution of different pulses, but in your code the PulseSimulator() class must get backends provided by Terra such as FakeArmonk(), FakeParis()..etc. For example: from qiskit.test.mock import FakeArmonk backend=FakeArmonk() backend_pulse_simulator = PulseSimulator.from_backend(backend) # using FakeArmonk() backend print(type(backend_pulse_simulator)) The FakeBackends() have the properties of the IBM Quantum devices data and are stored in Qiskit Terra. Another way is to specify a PulseSystemModel() from a real backend and pass the system model to the execution method. Below is an example with ibmq_armonk. from qiskit.providers.aer.pulse import PulseSystemModel from qiskit.providers.aer import PulseSimulator armonk_backend= provider.get_backend(&quot;ibmq_armonk&quot;) armonk_model = PulseSystemModel.from_backend(armonk_backend) backend_pulse_simulator=PulseSimulator() job = backend_pulse_simulator.run(pulse_program, armonk_model) hope this helps Patrick",01/11/2021 14:55
15649.0,"Cirq: Result of rotating qubit measurements never come [0 1] or [1 0 ], always come as [0,0] or [1,1]","I am creating a 2 qubit entangled state: def density_matrix_chsh(i, j, qs): circuit = chsh_circuit(i, j, qs) return cirq.final_density_matrix(circuit, qubit_order=qs) def chsh_circuit(i, j, qs): return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j])) qs = [a, b] state = density_matrix_chsh(0, 1, qs) Then I am applying rotation for maximum violation: th = np.pi/(-2) th1 = np.pi/(4) th2 = 0 random_angles = [] newlist = [] b_big = cirq.kron(cirq.unitary(cirq.ry(th)),cirq.unitary(cirq.ry(th))) results = [] for choosen in itertools.product([th2, th1], repeat=2): random_angles.append(choosen) for i in range (1000): choosen_combination = random.choice(random_angles) a_big = cirq.kron(cirq.unitary(cirq.rz(choosen_combination[0])),cirq.unitary(cirq.rz(choosen_combination[1]))) rotated_state = b_big @ a_big @ state @ b_big.conj().T measurement_rotated = cirq.measure_density_matrix(rotated_state,indices=[0, 1]) print(&quot;measuring qubits &quot;,measurement_rotated) qubit_result = measurement_rotated[0] results.append(qubit_result) For instance here I tried 1000 times and both qubits are either 0 or 1 at the sma time but I could never see one of them 1 and the other one is 0 after measurement. Probably I am doing something wrong and I can't see Thanks for helps",<programming><measurement><cirq>,1/23/2021 11:31,15662.0,15662.0,"As Craig said, you applied b_big and a_big differently. The adjoint a_big is missing from your product. Try rotated_state = b_big @ a_big @ state @ a_big.conj().T @ b_big.conj().T. But Craig's right. Using Circuits would be much simpler: import itertools import random import cirq import numpy as np def chsh_circuit(i, j, qs): return cirq.Circuit(cirq.H(qs[i]), cirq.CNOT(qs[i], qs[j])) qs = cirq.NamedQubit(&quot;a&quot;), cirq.NamedQubit(&quot;b&quot;) th = np.pi/(-2) th1 = np.pi/(4) th2 = 0 random_angles = [] newlist = [] b_big = cirq.Circuit(cirq.ry(th)(qs[0]), cirq.ry(th)(qs[1])) results = [] for choosen in itertools.product([th2, th1], repeat=2): random_angles.append(choosen) print(random_angles) for i in range (1000): choosen_combination = random.choice(random_angles) a_big = cirq.Circuit(cirq.rz(choosen_combination[0])(qs[0]), cirq.rz(choosen_combination[1])(qs[1])) rotated_state = cirq.Circuit(chsh_circuit(0,1, qs), a_big, b_big, cirq.measure(*qs)) res = cirq.Simulator().run(program=rotated_state, repetitions=1) print(&quot;measuring qubits &quot;,res.measurements)",1/24/2021 7:04
15651.0,How to read the unitary matrix of a quantum circuit in ProjectQ?,I would like to read the unitary matrix of a quantum circuit in ProjectQ. Is there any way to do it?,<programming><projectq>,1/23/2021 18:49,15993.0,15993.0,"Most quantum circuit building softwares, including ProjectQ, do not have any convenience features that explicitly serve this purpose due to the potential overhead of calculating and storing the unitary as the number of qubits increases. The best solution is to create your own function that recovers the unitary. The general idea (software non-specific) is to: Create your quantum function Iterate through each operation and obtain the matrix representation Multiply each unitary to get the final unitary representation of the circuit",02/11/2021 15:57
15667.0,Qiskit: getting QAOA expectation,"Suppose I run the Qiskit's QAOA algorithm. qaoa = QAOA(operator=qubit_operator, p=p, optimizer=optimizer) result = qaoa.run(quantum_instance) There is a built-in method that gets me the most likely binary solution for this problem. sample_most_likely(result['eigenstate']) But how do I get the whole probability distribution of binary solutions? Ultimately, I would like to calculate the expected value for my problem, not the value based solely on the most likely string.",<programming><qiskit><vqe><qaoa>,1/24/2021 10:53,15671.0,15671.0,"You should be able to use: result['eigenstate'] That should spit out something like (if you are using 4 qubits): {'0001': 27, '0010': 20, '0011': 1821, '0100': 25, '0101': 591, '0110': 46, '0111': 5347, '1001': 18, '1010': 2, '1011': 226, '1101': 11, '1111': 58}",1/24/2021 17:46
15876.0,CERTIFICATE_VERIFY_FAILED after updating Python when trying to access results in IBM QE,"I had a question earlier about the Numpy DeprecationWarning flooding issue. I just updated the Python in my regular jupyter notebook and have trouble running the following cell: cal_job = execute(cal_circuits, backend = backend, shots = 1024, optimization_level = 0 ) ***cal_results = cal_job.result()*** meas_fitter = CompleteMeasFitter(cal_results, state_labels) fig, ax = plt.subplots(figsize=(10, 10)) meas_fitter.plot_calibration(ax) My code worked fine before upgrading but now it shows the following error message (The line with the error is marked with***): SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate On the IBMQ Experience page it shows my job has been successfully executed, but I cannot obtain any result from the notebook. What should I do? Thanks so much for the help!",<programming><qiskit><ibm-q-experience>,02/06/2021 03:14,15882.0,15882.0,"If running on MacOS, did you try to Install Certificates? You can execute the following line in a terminal, replacing &lt;version&gt; with your Python version. /Applications/Python\ &lt;version&gt;/Install\ Certificates.command",02/06/2021 14:26
15942.0,Take every second element of the array in Q#,"Very quick question, I am trying to implement SAT solving in Q# using Grover's Algorithm. I want to take every second element from an array starting at the second element, represented with a range element : 1..2..Length(array). I am not very experienced and I am trying to find a nice and clean way to do so, without too much unnecessary for loop. Could someone help ?",<programming><q#>,02/09/2021 11:20,15946.0,15946.0,You can create an array with every second element starting from the second one using the expression array[1..2...].,02/09/2021 15:14
15966.0,"Was the Quantum Circuit Attribute ""iden"" renamed?","I'm going through some older tutorials for my employer and everything seems to be working fine except the &quot;iden&quot; attribute. The error is listed below. I assume the name was changed but I don't know what it was changed to, and I don't know how to find out. AttributeError Traceback (most recent call last) &lt;ipython-input-10-fff169415f56&gt; in &lt;module&gt; 4 hello_qubit = QuantumCircuit(q) 5 ----&gt; 6 hello_qubit.iden(q[0]) 7 8 job = execute(hello_qubit, S_simulator) AttributeError: 'QuantumCircuit' object has no attribute 'iden' '''",<programming><qiskit>,02/10/2021 14:54,15968.0,15968.0,Now it is called id: from qiskit import * circuit = QuantumCircuit(1) circuit.id(0) print(circuit) âââââ q_0: â¤ I â âââââ If you want to implement a delay consider using delay.,02/10/2021 15:07
16003.0,Can I adjust the quantum circuit after transpiling it?,"I have a list of quantum circuits called all_circuits. I tried to run those circuits on a quantum computer by submitting the jobs to the IBM job manager: from qiskit.compiler import transpile, assemble from qiskit.providers.ibmq.managed import IBMQJobManager for i in range(len(all_circuits)): # Submit a single job, and transpile everything just once. all_circuits[i] = transpile(all_circuits[i],backend=backend) I'm wondering after transpiling the whole list of circuit, is it still possible for me to modify an element in the transpiled list, like adding a gate at a particular place? For instance, if each circuit in my list have the following elements (I'm not so sure if this is a good example haha): qc = QuantumCircuit(3,3) qc.H(0) qc.crx(a,2,1) # Suppose a is some random parameter ***Here!*** qc.barrier() qc.H([1,2]) qc.cx(1,3) qc.measure(...) I don't think that transpiling a circuit will mix the gates on the two sides of the barrier (the barrier will also be kept), so can I transpile all circuits first, then add a CNOT gate qc.cx(0,2) right before the barrier (marked as 'Here!') to each transpiled circuit, not original one ? Thanks!!",<programming><qiskit>,02/12/2021 01:09,16004.0,16004.0,"Yes. You can just add gates as usual. For example: Suppose that we have the following random circuit from qiskit.circuit.random import random_circuit num_qubits = 2 circuit_depth = 3 max_operands = 1 #between 0 and 3 measurement_all_qubit = True qc_random = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) print(qc_random) ââââââââââââââ ââââââââââââââââââââââââââââ q_0: âââââââââ¤ RZ(5.6174) âââââââââ¤ U1(5.5484) ââ¤ RX(6.0937) â âââââââââ´âââââââââââââ´âââââââââââââââââââââ¤ââââââââââââââ¤ q_1: â¤ U3(0.96086,4.3412,1.4989) ââ¤ RZ(4.7727) ââ¤ U1(3.1479) â âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ We can transpiled it to ibmq_athens to get: from qiskit.compiler import transpile provider = IBMQ.load_account() Circuit_Transpile = transpile(qc_random, provider.get_backend('ibmq_athens') , optimization_level=3) print(Circuit_Transpile) ââââââââââââââââââââââââââââââââââ q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) âââââââââââââââââââââ ââââââââââââââ¤ââââââ¤ââââââââââââââ¤ââââââââââââââââââââ q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) â ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ Now, we can just add additional gates on top of this transpiled circuit called &quot;Circuit_Transpile&quot; as you would normally do before. For example: for i in range(5): Circuit_Transpile.h(i) print(Circuit_Transpile) âââââââââââââââââââââââââââââââââââââââ q_0 -&gt; 0 â¤ RZ(2.1427) ââ¤ âX ââ¤ RZ(3.8622) ââ¤ H âââââââââââââââââââââ ââââââââââââââ¤ââââââ¤ââââââââââââââ¤âââââ´ââââââââââââââââââââ q_1 -&gt; 1 â¤ RZ(-3.245) ââ¤ âX ââ¤ RZ(4.3157) ââ¤ âX ââ¤ RZ(1.2987) ââ¤ H â âââââ¬ââââ¬ââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_0 -&gt; 2 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ¤ ancilla_1 -&gt; 3 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ¤ ancilla_2 -&gt; 4 âââââ¤ H âââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ Hopefully this helps. Update: It seems like your circuit have two parts that is being divided by the circuit barrier, and you want to add gate into the middle of the circuit (after the barrier) after the transpilation process. If that is the case, then what you can do is to split the two parts of the circuit into two different circuits then compose them together after the transpilation process. For instance: from qiskit.circuit.random import random_circuit num_qubits = 2 circuit_depth = 3 max_operands = 1 #between 0 and 3 measurement_all_qubit = True qc_random1 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) qc_random1.barrier(range(2)) qc_random2 = random_circuit(num_qubits, circuit_depth, max_operands=max_operands, measure= None) qc_random2.barrier(range(2)) print(qc_random1) print(qc_random2) âââââ ââââââââââââââ âââââ â q_0: â¤ X âââ¤ U1(2.7235) ââââââ¤ X âââââââââ âââââ¤ââ´âââââââââââââ¤âââââ´ââââ´âââââ â q_1: â¤ Z ââ¤ RX(0.94815) ââ¤ RX(2.0345) ââââ ââââââââââââââââââââââââââââââââââ â ââââââââââââââââââââââ âââââ ââââââââââââââ â q_0: â¤ U2(0.28027,1.7582) ââââââ¤ X âââââââ¤ RZ(4.5689) ââââ âââââââââââââââââââââ¬ââââââ´ââââ´ââââââââââ¬ââââ¬âââââ â q_1: â¤ U2(1.6123,1.6426) âââ¤ RZ(6.1746) ââââââ¤ S âââââââââ âââââââââââââââââââââ ââââââââââââââ âââââ â Now, do the transpilation as you would have normally do: from qiskit.compiler import transpile provider = IBMQ.load_account() Circuit_Transpile1 = transpile(qc_random1, provider.get_backend('ibmq_athens') , optimization_level=3) Circuit_Transpile2 = transpile(qc_random2, provider.get_backend('ibmq_athens') , optimization_level=3) print(Circuit_Transpile1) print(Circuit_Transpile2) ââââââââââââââ â q_0 -&gt; 0 â¤ RZ(3.5597) âââââââââââââââââââââââââââââââââââââââââ ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) ââââ ââââââââââââ âââââââââââââââââââââââââââââââââââââ â ancilla_0 -&gt; 2 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 ââââââââââââââââââââââââââââââââââââââââââââââââââââââ global phase: 0.29049 âââââââââââââ ââââââââââââââââââââ â q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ ââââââââââââââââââââââââââââââââââââ â ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ Now, add gates that you wanted to add to the first circuit: for i in range(2): Circuit_Transpile1.h(i) print(Circuit_Transpile1) ââââââââââââââ â âââââ q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H â ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤ q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H â ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââ ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ Then compose them together to formed a full circuit: Circuit_Transpile1.compose(Circuit_Transpile2, inplace = True) print(Circuit_Transpile1) ââââââââââââââ â âââââÂ» q_0 -&gt; 0 â¤ RZ(3.5597) ââââââââââââââââââââââââââââââââââââââââââ¤ H âÂ» ââ¬âââââââââââ¬ââââââââââââââââââââââââââââââââââââââ â âââââ¤Â» q_1 -&gt; 1 ââ¤ RZ(-Ï/2) âââ¤ âX ââ¤ RZ(6.1242) ââ¤ âX ââ¤ RZ(Ï/2) âââââ¤ H âÂ» ââââââââââââ âââââââââââââââââââââââââââââââââââââ â âââââÂ» ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â» Â« âââââââââââââ ââââââââââââââââââââ â Â« q_0 -&gt; 0 ââ¤ RZ(3.329) ââââ¤ âX ââ¤ RZ(5.8595) ââââ Â« ââ´ââââââââââââ´ââââââââ¤ââââââââââââââ¤ â Â« q_1 -&gt; 1 â¤ RZ(0.071774) ââ¤ âX ââ¤ RZ(4.6453) ââââ Â« ââââââââââââââââââââââââââââââââââââ â Â«ancilla_0 -&gt; 2 âââââââââââââââââââââââââââââââââââââââ Â« Â«ancilla_1 -&gt; 3 âââââââââââââââââââââââââââââââââââââââ Â« Â«ancilla_2 -&gt; 4 âââââââââââââââââââââââââââââââââââââââ Â« ```",02/12/2021 01:43
16176.0,Multiple Providers on IBMQ,"I am attempting to run parallel computations on two different backends from within the same Jupyter notebook, though it appears these two jobs are running sequentially. I understand the jobs will be asynchronous, but is there any way to submit two jobs to differing backends at the same time? I'm not seeing anything allowing for providing multiple backends. Thank you!",<programming><qiskit><ibm-q-experience><ibm>,2/23/2021 3:46,16184.0,16184.0,"There is a (much simpler in my opinion) solution that does not require multiprocessing at all: use qiskit API. A code sample is worth a thousand words: # Load the packages from qiskit import IBMQ, QuantumCircuit, execute # Log in to your IBMQ account IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') # Get the backends you are interested in backends = [provider.get_backend(b) for b in [&quot;ibmq_athens&quot;, &quot;ibmq_quito&quot;]] # Build the quantum circuit qc = QuantumCircuit(5) qc.h(list(range(5))) qc.cx(0, 1) qc.cx(1, 2) qc.cx(3, 4) qc.cx(5, 2) qc.measure_all() # Asynchronously submit the circuit on all the backends. # This will only submit the circuits, not wait for their completion. jobs = [execute(qc, backend) for backend in backends] # Do some work... # When you need your job results: # You can also query the results individually if needed. # The call to &quot;result()&quot; blocks until the job is finished. results = [j.result() for j in jobs] # Now you can use the results, for example to recover the counts # This is a non-blocking operation as the counts are already in # the results obtained in the previous step counts = [result.get_counts() for result in results]",2/23/2021 11:44
16321.0,Should I learn a low-level QC programming language?,"I've referred to some programming language recommendation questions on here, so I thought I'd post a follow-up question here. I'm a total beginner to the field but want to seriously learn it. Is there a low-level, QC-equivalent of assembly language, and is it worth it to learn that at this stage? Do existing QC programming languages provide that low-level functionality? And a minor second clarification - if I commit to learning any particular framework like Qiskit or Q#/QDK - is there a risk of that framework going obsolete depending on which company wins out in this QC race in the future?",<programming>,03/03/2021 02:30,16326.0,16326.0,"I will provide answer for IBM Q. There is a language callled QASM. As you can see from the name of the language, it is similar to assembly language known from classical computer. The language statements are very simple - they involve an operation (i.e. quantum gate) and affected qubits. For example to apply $X$ gate on qubit no. 0, you have to put in x q[0], for CNOT gate with control qubit no. 0 and target qubit 1, the statement is cnot q[0], q[1] etc. Also special stataments are used for measurement, setting number of qubits in qubit register and bits in classical register. You can also define subroutines which are called custom gates. This all means that you operates on qubit and gate level although logical ones. It is also possible to write a program in QASM using only basic gates which are $U3$ and CNOT on IBM Q (although $U3$ is still not physical gate). IBM Q also enables you to program a quantum processor with microwave pulses directly (only processor Armonk offers this capability now) which is really physical level, something like programming classical computer by switching particular transistors. Concerning the possibility of a something going to be obsolete. There is always such risk in any segment of industry, particularly in IT which evolves rapidly. As I see it, it think to learn QASM/Qiskit is useful as it allows you to get insight how quantum computers work. Then, it would be easy to switch to another language.",03/03/2021 07:54
16409.0,Is there a way to present conjugate transpose of a Y Pauli rotation as a Cirq Operator?,Given: Ry(theta) acting on one qubit I'm trying to use existing Cirq Operators to build the conjugate transpose of the above gate. I need the operator to produce the exact unitary of the given gate for the given theta. I'v already used cirq.optimizers.single_qubit_matrix_to_gates. It gives YPowGates but the global phase changes with theta. I need either the exact unitary of the gate or another conversion that its global phase does not change with theta.,<programming><cirq><pauli-gates>,03/08/2021 21:11,16410.0,16410.0,"cirq.inverse(operation) will return the conjugate transpose of an operation. Equivalently, you can use operation**-1 (this is the first thing that cirq.inverse tries). For the specific case of $R_y$, you can just negate the angle i.e. use cirq.ry(-theta).",03/08/2021 21:22
16413.0,Trying to simulate Weak Value Amplification using QuTiP,"Weak Value Amplification is a procedure in which one consider a bipartite Hamiltonian of the form $H = g A \otimes B$, where $A$ is called system, $B$ is called meter and $g$ is the extremely small parameter we are interested to measure by amplification. The procedure goes as follows: (1) The system and meter is initialized by some initial state $\vert\Psi\rangle=\vert\psi_{i}\rangle \otimes \vert \phi\rangle$. The evolution of the system $U = \exp(-igA \otimes B)$ is approximated to $1_{A}\otimes 1_{B}-ig A\otimes B$, since $g$ is extremely small. we get $$U\vert\Psi_{i}\rangle\approx(1_{A}\otimes 1_{B}-ig A\otimes B)\vert\psi_{i}\rangle \otimes \vert \phi\rangle,$$ $$(1_{A}\vert\psi_{i}\rangle\otimes 1_{B}\vert \phi\rangle-ig A\vert\psi_{i}\rangle\otimes B\vert\phi\rangle).$$ (2) After the evolution, the system is post selected onto some final state $\vert\psi_{f}\rangle$ (which is nearly orthogonal to the initial state) $$\langle\psi_{f}\vert U\vert\Psi_{i}\rangle\approx P_{s}(1_{B}\vert\phi\rangle - ig A_{w}B\vert\phi\rangle)$$. Where $P_s = \langle\psi_{f}\vert\psi_{i}\rangle$ is the post-selection probability and $A_{w} = \langle\psi_{f}\vert A\vert\psi_{i}\rangle/P_{s}$ is called the weak value. (3) If i re-exponentiate the above term, we get $$\frac{\langle\psi_{f}\vert U\vert\Psi_{i}\rangle}{P_{s}}=\exp(-igA_{w}B)\vert\phi\rangle$$ where the exponential on the RHS is the Kraus operator acting on the meter intial state, using which one can estimate the small parameter $g$. My attempt at solving: (step 1) I prepare the initial state say psi1 and evolved the state according the Hamiltonian using mesolve for a short time t = np.linspace(0, 0.01, 50) result = mesolve(H, psi1, t, c_ops = [], e_ops =[]) (step 2) The evolved state is result.states[49], but the problem I am facing is how do I make post-measurement on this with the final state? One such dumb attempt, I did was taking the final state psif and sandwiched directly with result.states[49] as eta = psif.dag()*result.states[49] But my objective was to do the post-selection at a specific time, like say I weakly evolve the system for a short time say 0 to 0.1 seconds and do post-selection exactly at 0.05th second. I am really lost what to do from my (step 1). Is there a way to do post-selection in QuTiP at a specific time?",<programming><qutip>,03/09/2021 04:34,17681.0,17681.0,"The state evolved at all of the time points in t[i] are stored in results.states[i]. You can use this to find the exact post-selected state and the exact post-selection probability by looking directly at the &quot;sandwiches&quot; psif.dag()*result.states[i] that you mention. But QuTiP gives an error about incompatible object sizes if you do this operation, which seems mathematically fine! That is because it prefers that you operate on states in the composite Hilbert space with things defined on the composite Hilbert space. Thus, instead of the shorthand definition of $\langle\psi_f|U|\Psi_i\rangle$, we are really using $$\left(\langle\psi_f|\otimes \mathbb{I}\right)U|\Psi_i\rangle.$$ If we define my psif as your psif tensored with the identity on the second Hilbert space, everything will work nicely. So: the unnormalized post-selected state at time point t[i] can be found through tensor(psif,qeye(N)).dag()*result.states[i], where N is the dimension of the Hilbert space on of the meter. You can verify that this gives psi1 when you $i=0$.",5/27/2021 19:35
16501.0,How to initialize a qubit with a custom state in Qiskit Composer,"I'm trying to initialize a qubit with a custom state in IBM's Qiskit Composer. I wrote the code in the Qiskit Lab and obtained the QASM code as shown below OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q0[1]; creg c[1]; initialize(0.5,0.8660254) q0[0]; This is giving error stating initialize is not defined. What's the way to initialize a qubit with a custom value in Qiskit Composer?",<programming><qiskit><quantum-state><ibm-q-experience>,3/14/2021 6:18,16503.0,16503.0,"What you can do is use qiskit to decompose the circuit with the initialize instruction to elementary gate, then print out the QASM code that you can paste into the Composer. For example: Using the vector you want to initialize, I can do from qiskit import QuantumCircuit, IBMQ import numpy as np num_qubits = 1 vector = [0.5,0.8660254] initial_state = vector/np.linalg.norm(vector) circuit = QuantumCircuit(num_qubits,num_qubits) circuit.initialize(initial_state, 0) print(circuit) qasm_circuit = circuit.decompose().decompose().decompose() print(qasm_circuit) âââââââââââââââââââââââââââ q_0: â¤ initialize(0.5,0.86603) â âââââââââââââââââââââââââââ c: 1/âââââââââââââââââââââââââââ ââââââââââââ q_0: â|0&gt;ââ¤ RY(2Ï/3) â ââââââââââââ c: 1/âââââââââââââââââ Then now, if I do: print(qasm_circuit.qasm()) then I will get OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q[1]; creg c[1]; reset q[0]; ry(2*pi/3) q[0]; You can now paste the QASM code to the Composer and continue on with your circuit construction.",3/14/2021 7:07
16518.0,"Best way to compute $\langle a|B|a \rangle$ in Cirq, where a is a state obtained running circuit A. And B is a different Quantum Circuit","I am implementing RQAOA in Cirq. After running regular QAOA to find an optimal state a (This I have done successfully). I need to calculate $\langle a|Z_iZ_j|a\rangle$ for all $i,j$ in MyGraph.edges(). How should I go about using state a found with the QAOA circuit, to calculate the expectation value of a different circuit with that state?",<programming><cirq><qaoa>,3/15/2021 10:21,16520.0,16520.0,"If you've already simulated the final state $|a\rangle$, something like the following should work: qubits = cirq.LineQubit.range(nqubits) # qubit order in the observables must match the qubit order in the circuit used to generate |a&gt; qubit_map = dict(zip(qubits, range(nqubits))) for (i, j) in MyGraph.edges(): # make the Z_i*Z_j observable ZiZj = cirq.Z(qubits[i]) * cirq.Z(qubits[j]) # compute desired expectation expectation_ZiZj = ZiZj.expectation_from_state_vector(a, qubit_map=qubit_map) Also in the expression $\langle a | B | a \rangle$, $B$ is generally not a quantum circuit, it needs to be an &quot;observable&quot; (Hermitian operator).",3/15/2021 18:49
16673.0,Make a controlled gate from a QuantumCircuit that uses append in Qiskit,"Here is a minimal example for what I want to do: from qiskit import QuantumCircuit qc1 = QuantumCircuit(1, name='qc1') qc1.x(0) qc2 = QuantumCircuit(1, name='qc2') qc2.h(0) qc2.append(qc1, [0]) qc2.z(0) c_qc2 = qc2.to_gate().control(1) This gives the following error: qiskit.exceptions.QiskitError: 'One or more instructions cannot be converted to a gate. &quot;qc1&quot; is not a gate instruction' I'm aware that in this example I can get the desired controlled gate of qc2 by manually adding a control qubit to each gate in qc2. However in practice qc2 would be complex and doing so would be tiresome. I also tried qc2.append(qc1.to_instruction(), [0]) which didn't solve the problem. Any help is appreciated. Thanks!",<programming><qiskit>,3/24/2021 18:44,16674.0,16674.0,"Edit: Miss understood your question earlier. As commented by @Egrettal you can do the following. from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit qc1 = QuantumCircuit(1, name='qc1') qc1.x(0) print(qc1) qc2 = QuantumCircuit(1, name='qc2') qc2.h(0) qc2.append(qc1.to_gate(), [0]) qc2.z(0) print(qc2) xs_gate = qc2.to_gate() cxs_gate = xs_gate.control() circuit = QuantumCircuit(2) circuit.append(cxs_gate, [0,1]) print('\n New circuit with controlled:\n',circuit) print('\n Decomposed new circuit:\n', circuit.decompose()) Which will output: âââââ q_0: â¤ X â âââââ âââââââââââââââââ q_0: â¤ H ââ¤ qc1 ââ¤ Z â âââââââââââââââââ New circuit with controlled: q_0: ââââ âââ ââââ´âââ q_1: â¤ qc2 â âââââââ Decomposed new circuit: ââââââââââ Â» q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââââââââââââââââ ââÂ» ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââââââââââââââââ´ââÂ» q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) ââ¤ RY(Ï/4) ââ¤ X âÂ» âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â« ââââââââ Â» Â«q_0: âââââââââââââââ âââ¤ P(0) ââââ âââââââââââââââââ âââââââââââââââââ ââÂ» Â« âââââââââââââââ´ââââââââââ¤âââ´âââââââââââââââââ´âââââââââââââââââ´ââÂ» Â«q_1: â¤ RY(-Ï/4) ââ¤ X ââ¤ P(0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X ââ¤ U(0,0,0) ââ¤ X âÂ» Â« ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââÂ» Â« ââââââââââ Â«q_0: â¤ P(Ï/2) ââââ ââââââââââââââââââââ ââââââââââââââ Â« ââââââââââ¤âââ´ââââââââââââââââââââ´ââââââââââââââ Â«q_1: â¤ P(Ï/2) ââ¤ X ââ¤ U(0,0,-Ï/2) ââ¤ X ââ¤ U(0,0,0) â Â« âââââââââââââââââââââââââââââââââââââââââââââââ",3/24/2021 18:56
16828.0,Writing the Jaynes-Cumming model in QuTip,"I want to write the Jaynes-Cumming Hamiltonian in QuTip. $$H = \hbar \omega_{C} a^\dagger a + \frac12 \hbar \omega_{a} \sigma_{z} + \hbar \lambda (\sigma_{+} a + \sigma_{-} a^\dagger)$$ I assume $\hbar = 1$, and we know $a, a^\dagger$ are the field (cavity) operators, and $\sigma_{z}, \sigma_{+}, \sigma_{-}$ are the atomic operators; and they commute. $\lambda$ is the coupling constant. I assume that the # of Fock basis states that I choose is N. Now, to write the Hamiltonian using qutip I would use the following statements, $a$: a = tensor(qeye(2), destroy(N)) $a^\dagger$: a.dag() $a^\dagger a$: a.dag() * a $\sigma_{z}$: sz = tensor(sigmaz(), qeye(N)) $\sigma_{+} a$: sp = tensor(sigmap(), qeye(N)) * a $\sigma_{-} a^\dagger$: sp.dag() $\sigma_{+} a + \sigma_{-} a^\dagger$: sp + sp.dag() But in the QuTip documentation the interaction term has been written as, sm = tensor(destroy(2), qeye(N)); Hint = a.dag() * sm + a * sm.dag() Could someone explain why they use the previous statement but not the one I would have assumed?",<programming><qutip>,04/02/2021 18:57,16830.0,16830.0,"Usually we say $|0\rangle$ is the ground state and is at the north pole, but sometimes people choose the convention that since the north pole is ``higher&quot; than the south pole on the Bloch sphere, that $|0\rangle$ should be the excited state instead. Thus, the qubit raising operator (with basis ordering $|0\rangle, |1\rangle$) is \begin{align} \sigma_+ = \begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{bmatrix} \end{align} which actually looks like the lowering operator in the first convention. QuTiP is treating the qubit as a two-level oscillator ($|0\rangle$ is ground), and you are using $|0\rangle$ as excited.",04/02/2021 19:36
16868.0,How to get eigenvectors of Hamiltonian in OpenFermion,"In OpenFermion you can create a Hamiltonian in terms of creation and annihilation pretty easily: ham = ((FermionOperator('1^ 1', .5)) + (FermionOperator('2^ 2', .25))) And getting the eigenvalues of the Hamiltonian is pretty straightforward as well: vals = eigenspectrum(ham) But I don't understand how to get the eigenvectors of the Hamiltonian. FermionOperator doesn't return a numpy object so I can't use usual linear algebra libraries. What am I missing?",<programming><hamiltonian-simulation><openfermion>,04/06/2021 04:24,16881.0,16881.0,"The following works: sparse_mat = openfermion.get_sparse_operator(ham, n_qubits=n) # type: scipy.sparse.csr_matrix mat = sparse_mat.toarray() # type: np.ndarray w, v = numpy.linalg.eigh(mat) Then w will contain the eigenvalues and the columns of v will contain the eigenvectors. Setting the n_qubits=n parameter will result in a matrix that gets padded up to $2^n \times 2^n$ which is important if you're going to do further matrix manipulations or algebra involving the matrix representing your Hamiltonian. And of course, for efficiency reasons you may choose not to cast the sparse operator to a numpy array but then you will end up using sparse matrix functions from scipy, for example scipy.sparse.linalg.eigsh to find some subset of eigenvalues/eigenvectors of a sparse matrix.",04/06/2021 18:21
16888.0,Quantum Katas - Tutorials - SingleQubitGates - Exercise 7 - Preparing an arbitrary state,"Exercise 7 &quot;Preparing an arbitrary state&quot; from the Quantum Katas - Tutorials - SingleQubitGates asks to prepare a state $\alpha|0\rangle + e^{i\theta}\beta|1\rangle$, using parameters $\alpha$, $\beta$, and $\theta$. In brief, $\theta$ is one of known-inputs, why we don't use $\theta$ for the Ry gate directly ? Something like this.. Ry(theta, q); R1(theta, q); But alas, I got error: Qubit in invalid state. Expecting: Zero Expected: 0 Actual: 0.061208719054813704 Try again! Any ideas would be highly appreciated!!",<programming><q#>,04/07/2021 03:02,16889.0,16889.0,"The angle to use for Ry gate is not necessarily the same one as the given angle $\theta$ to use for R1 gate. This means that you need to figure out the angle for Ry gate from the parameters $\alpha$ and $\beta$. If you're using $\theta$ for both angles, you'll be preparing a state $\cos \frac{\theta}{2}|0\rangle + e^{i\theta}\sin \frac{\theta}{2}|1\rangle$, not $\alpha|0\rangle + e^{i\theta}\beta|1\rangle$ the task asks for. I recommend checking out the workbook for that tutorial - it has a very detailed explanation of the steps you need to take to solve this task.",04/07/2021 03:19
17175.0,Quantum Katas - Tutorials - Oracles - Task 3.3 (OR oracle of all bits except for a single bit),"Let $x$ be an arbitrary state composed of $N$ qubits and $k$ be an integer such that $0\leq k \leq N.$ The task is to ignore the $k$-th bit and to flip the sign of $x$ if any of the remaining bits are equal to 1. In other words, flipping the sign of $x$ is independent of the $k$-th bit, but it is dependent on the existence of 1's lurking in $x$. The solution I came up with is the following, which, unfortunately, I cannot implement. Regardless of what $x$ is we flip its sign. There are two cases we should correct for, namely, the binary representations of 0 and $2^k$. Could not we take care of these two scenarios by using the ControlledOnInt function by setting $\textit{numberstate}$ to 0 (first we have the $X$ gate act on $x[k]$, so that $Z$ flips $x$) and $2^k$, the $\textit{oracle}$ to $Z$, the $\textit{control register}$ to $[x]$ and the $\textit{target register}$ to $x[k]$? Also, why can't the control and target registers be the same? How could we implement the above with an auxiliary qubit? In the second case where $x$ is the binary representation of $2^k$, we could use the task 3.2 from the same tutorial (flips the sign of $x$ if the $k$-th qubit is 1), but I am also having trouble with that task. I have been able to implement the OR oracle (task 3.1 of the same tutorial), but it was done with a marking oracle, not a phase oracle.",<q#><oracles>,4/21/2021 2:20,17176.0,17176.0,"There is a much simpler way to approach this task. It requires only two observations: You can always convert a marking oracle to a phase oracle using the phase kickback trick (discussed earlier in the tutorial). Some tasks in this tutorial prohibit using extra qubits for this purpose to push you towards a solution that doesn't rely on that, but this task doesn't have this restrictions, so you can allocate that extra qubit, implement a marking oracle and use them to get your phase oracle. If you need to perform some computation on the whole register except one qubit, why not just define a qubit array that holds the rest of the qubits and use that array as the input for the marking oracle? (This is more of a programming trick than a quantum computing one, but it's a useful one!) With those two observations, the code is pretty straightforward: use minus = Qubit(); within { X(minus); H(minus); } apply { Or_Oracle(x[...k-1] + x[k+1...], minus); } x[...k-1] + x[k+1...] is a concatenation of two qubit arrays: all qubits before the $k$-th one and all qubits after the $k$-th one. You can always check the file ReferenceImplementation.qs in the tutorial folder to see the author's solutions to the tasks.",4/21/2021 2:51
17320.0,What is the superop simulator in Qiskit for?,"I'm trying to understand what the use case of a superop simulator would be. My understanding is that density matrix is generally more resource intensive than state vector, but it has additional capabilities to support noisy channels and such. And also my understanding is that every circuit has a corresponding superop that can be extracted from it via QIS, but I believe that can be obtained via calculation rather than simulation. So I don't understand what a superop simulator is for. I know it's even more resource intensive than density matrix, but what additional capabilities does it provide?",<programming><qiskit><quantum-state><simulation><density-matrix>,05/01/2021 15:51,17337.0,17337.0,"If you have an ideal quantum circuit, you can easily get its superoperator representation using qiskit.quantum_info.SuperOp as follows, qc = QuantumCircuit(1) qc.x(0) super_op = SuperOp(qc) array_to_latex(super_op) The output will be $$ \left[\begin{matrix} 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 0\\ \end{matrix}\right] $$ And to see how a quantum state is evolved by applying this operator: rho1 = DensityMatrix.from_label('0') rho2 = rho1.evolve(super_op) rho2.draw('latex') However, you can not use this method to get the superoperator representation of the circuit in the presence of errors. Instead, you can use superop simulator, which accepts a NoiseModel as a parameter # Add save_superop instruction to save the simulator state to the returned results: qc.save_superop() # Get noise model: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_16_melbourne') noise_model = NoiseModel.from_backend(backend) # Get the superoperator: noisy_simulator = AerSimulator(method = 'superop', noise_model = noise_model) result = noisy_simulator.run(qc).result() super_op_array = result.data()['superop'] array_to_latex(super_op_array) And in this case the output will be somthing like that: $$ \left[\begin{matrix} 0.00094 &amp; 0 &amp; 0 &amp; 0.99979\\ 0 &amp; 0 &amp; 0.99907 &amp; 0\\ 0 &amp; 0.99907 &amp; 0 &amp; 0\\ 0.99906 &amp; 0 &amp; 0 &amp; 0.00021\\ \end{matrix}\right] $$",05/03/2021 23:23
17336.0,Can I use Grover's algorithm on overlapping sets of qubits?,"Let's say I have 3 qubits: $q_1,q_2,q_3$. I want to apply Grover's algorithm on q1,q2, such that q1,q2 $\neq$ 10 and do the same for q2,q3, so that q2,q3 $\neq$ 11. The final possible combinations of the qubits q1,q2,q3 should then be: 000 001 010 110 And they shouldn't be: 011 100 101 111 If this is possible then couldn't I solve 3sat in polynomial time with a quantum computer? Couldn't I just remove the possibility of each clause being unsatisfied from a set of qbits representing the variables in the 3sat problem and then collapse the qbits to see if the final result is satisfiable? Example of how I think a quantum computer would solve an instance of a 3sat problem in polynomial time: Note: each computation should be on a set of 3 qbits at a time which should take $2^{3/2}$ time with Grover's algorithm, or O(1) in big O notation) Variables = ${a,b,c,d,e}$ clauses = ${(\neg a \vee b \vee \neg c),(b \vee c \vee d),(\neg b \vee \neg c \vee d),(c \vee \neg d \vee e),(c \vee \neg d \vee \neg e)}$ We have qubits $q_a, q_b, q_c, q_d, q_e$ for $q_a, q_b, q_c$ we remove the possibility of 101 (since this would not satisfy the 1st clause) for $q_b, q_c, q_d$ we remove the possibility of 000 and 110 (since those would not satisfy the 2nd and 3rd clause) for $q_c, q_d, q_e$ we remove the possibility of 010 and 011 (since those would not satisfy the 4th and 5th clause) Now the possible outputs of the qbits are: 00100 00101 00110 00111 01000 01001 01110 01111 11000 11001 11110 11111 So if I collapse the qbits I should remain with one of these combinations which satisfies the problem. If there is no possible solution, the qbits will just collapse into something meaningless which will not satisfy the problem. If anyone can show me the flaw in my logic, please let me know, I highly doubt I solved 3sat. I'm just trying to learn.",<programming><quantum-state><algorithm><grovers-algorithm><quantum-advantage>,05/03/2021 17:31,17353.0,17353.0,"Grover's algorithm has two components, which alternate and repeat $O(\sqrt{N})$ times: a diffusion operator and an oracle operator. The diffusion operator will cause problems with your idea. As I understand, what you want to do is start from a uniform superposition $$\vert \psi_0\rangle =\frac{1}{\sqrt{2^n}}\sum_{b_1,\dots,b_n\in\{0,1\}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$ and then solve for (e.g.) a clause $C_1$ in $b_1,b_2,b_3$, to get something like: $$\vert\psi_1\rangle=\frac{1}{\sqrt{N}}\sum_{\substack{b_1,\dots,b_n\in\{0,1\}\\ C_1(b_1,b_2,b_3)=1}} \vert b_1\rangle \vert b_2\rangle\dots\vert b_n\rangle$$ where $N$ is the number of remaining solutions. From this superposition, you want to solve for another clause $C_2$ which involves (e.g.) $b_1, b_4, b_5$ (if no other clause involves $b_1,b_2,b_3$, then it's easy to solve for these 3 variables first and then remove them from the problem). But now you're searching over the first qubit, $b_1$, but $\vert\psi_1\rangle$, your superposition over $b_1$, is non-trivial. Grover's algorithm requires a way to flip the phase of the starting superposition. Normally, the way to do this is to apply $H$ gates to every qubit and flip the all-zeros state, then apply $H$ again to return to the previous state, but after solving the first clause, the superposition $\vert\psi_1\rangle$ is not just $H^{\otimes n}\vert 0^n\rangle$. In fact, (as far as I am aware) the only way to construct a diffusion operator for the superposition $\vert\psi_1\rangle$ where $C_1$ is solved is to undo the solution for $C_1$, then apply $H$ gates, then flip over $\vert 0^n\rangle$, then redo those same operations. If you do that, then you can run Grover's algorithm on a clause-by-clause basis and solve the 3-SAT problem. However, the cost is not polynomial: If there are $m$ clauses, for the last clause, the diffusion operator must solve and unsolve an $m-1$ clause 3-SAT problem. So if the cost of solving this problem is $c_{m-1}$, the total cost will be $\approx\sqrt{2^3}c_{m-1}$. But solving an $m-1$ clause 3-SAT problem will require a diffusion operator that solves an $m-2$ clause 3-SAT problem, so $c_{m-1}\approx \sqrt{2^3}c_{m-2}$ (and so on). You end up multiplying all of the factors of $\sqrt{2^3}$ each time you go through, and the total cost ends up as something like $O(\sqrt{2^{3m}})$ -- which is roughly the exponential cost you would expect from a naive Grover search.",05/05/2021 08:14
17341.0,Why `cirq` needs `Qid` class instead of just `Qudit` class?,"I am just wondering in what way cirq.Qid class generalizes qudits. From cirq.Qid documentation we read that it Identifies a quantum object such as a qubit, qudit, resonator, etc. I am not sure what this resonator means and if it is somehow connected to other qudits in the system. Could anyone clarify it?",<programming><cirq><qudit>,05/04/2021 16:16,17345.0,17345.0,"Well, originally the idea was that we didn't want to exclude things like continuous quantum systems, and ancillary systems being used as control surfaces, and concepts like &quot;a place where an ion might be&quot; as opposed to the ion itself. So we went with a very generic &quot;identifier for quantum-associated thing&quot; name (qid). At some point Qid gained a dimension method that returns an integer telling you how many quantum levels there are... so it really basically is a qudit now.",05/04/2021 19:40
17375.0,Is there any way to obtain the number of qubits of a given backend in Qiskit?,"I'm testing out a program in different IBMQ mock backends, and I want the program to use the maximum number of qubits in each case. Is there any function/method to extract the number of qubits of a given backend, so that I don't have to manually look it up every time? Extra: Is there any way to automate the process of selecting each of these mock backends? My plan is to create an array fake_servers = [FakeAlmaden(), FakeAthens(), FakeBelem(), FakeBoeblingen()] etc, but if there's a more straightforward way, I'd like to know about it...",<programming><qiskit><ibm-q-experience><ibm>,05/06/2021 14:44,17376.0,17376.0,"The number of qubits is part of the backend configuration: FakeManhattan().configuration().n_qubits 65 If you need to filter the list of mocked backends based on the amount of qubits: from qiskit.test.mock import FakeProvider provider = FakeProvider() [ b.name() for b in provider.backends() if b.configuration().n_qubits &gt; 20] ['fake_cambridge', 'fake_cambridge', 'fake_manhattan', 'fake_montreal', 'fake_mumbai', 'fake_paris', 'fake_rochester', 'fake_sydney', 'fake_toronto']",05/06/2021 14:59
17438.0,Performing a generic single-qubit Pauli error channel in stim,"I have a Pauli channel with disjoint probabilities $P_I$, $P_X$, $P_Y$, $P_Z$ (meaning $P_I + P_X + P_Y + P_Z = 1$) corresponding to Pauli errors I, X, Y, Z. Is there some way apply this Pauli channel in Stim?",<programming><stim>,05/11/2021 00:39,17439.0,17439.0,"Update: Since v1.4, stim supports custom pauli channels PAULI_CHANNEL_1(px, py, pz) and PAULI_CHANNEL_2(pix, piy, ..., pzz). Before v1.4 If $P_x = P_y = P_z$ then DEPOLARIZE1 is what you need. If $P_y = P_z = 0$ then X_ERROR is what you need (ditto Y_ERROR, Z_ERROR). Otherwise you can use CORRELATED_ERROR and ELSE_CORRELATED_ERROR. For example, suppose $P_x = 0.1$, $P_y = 0.2$, $P_z = 0.3$ and your target is qubit $5$. You can do this: CORRELATED_ERROR(0.1) X5 ELSE_CORRELATED_ERROR(0.22222222222) Y5 # note: P(Y|not X) = 20%/(100% - 10%) ELSE_CORRELATED_ERROR(0.42857142857) Z5 # note: P(Z|not X and not Y) = 30%/(100% - 10% - 20%) The else-case probabilities are conditioned on the earlier cases not happening, which is why they are larger than the original probabilities. Here's the general case, implemented as python code: def append_generic_single_qubit_error_channel_to_circuit( circuit: stim.Circuit, target: int, px: float, py: float, pz: float): &quot;&quot;&quot; Args: circuit: The circuit to append the error channel to. target: The qubit to hit with the error channel. px: The disjoint probability of an X error. py: The disjoint probability of a Y error. pz: The disjoint probability of a Z error. Requires: 0 &lt;= px &lt;= 1 0 &lt;= py &lt;= 1 0 &lt;= pz &lt;= 1 px+py+pz &lt;= 1 &quot;&quot;&quot; circuit.append_operation(&quot;CORRELATED_ERROR&quot;, [stim.target_x(target)], px) circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_y(target)], py / (1 - px)) circuit.append_operation(&quot;ELSE_CORRELATED_ERROR&quot;, [stim.target_z(target)], pz / (1 - px - py)) Note that it agrees with the example case: import stim c = stim.Circuit() append_generic_single_qubit_error_channel_to_circuit( circuit=c, target=5, px=0.1, py=0.2, pz=0.3) print(c) E(0.1) X5 ELSE_CORRELATED_ERROR(0.222222) Y5 ELSE_CORRELATED_ERROR(0.428571) Z5 (E is an abbreviation for CORRELATED_ERROR)",05/11/2021 00:39
17441.0,Is there a way I can reduce the code for generating simple circuits with the same structure?,"here's the code I'm using to generate 3 quantum circuits with the same structure (They're only differed by the first U3 gate on the qubit): quancs = QuantumCircuit(1) # Circ 1 quancs.u3(gamma,beta,delta,0) quancs1 = QuantumCircuit(1) # Circ 2 quancs1.u3(2,3,2,0) quancs1.u3(gamma,beta,delta,0) quancs2 = QuantumCircuit(1) # Circuit 3. quancs2.u3(-2.5,2,-2,0) quancs2.u3(gamma,beta,delta,0) results = execute(quancs, simulator).result() results1 = execute(quancs1, simulator).result() results2 = execute(quancs2, simulator).result() I treated the circuits separately to obtain the results. I'm wondering is there a way I can simplify/shorten this code? Thanks for the help!",<programming><qiskit>,05/11/2021 03:17,17442.0,17442.0,"How about something like this: from qiskit.circuit import QuantumCircuit def my_circuit(initial_gate_params, params): circuit = QuantumCircuit(1) circuit.u3(initial_gate_params[0],initial_gate_params[1],initial_gate_params[2],0) circuit.u3(params[0], params[1], params[2], 0) return circuit initial_gate_params = [ [0,0,0], [2,3,2], [-2.5,2,-2] ] #the params for your initial u3 gate params = [gamma, beta, zeta] #your defined gamma, beta, zeta circuits = [my_circuit(i, params) for i in initial_gate_params ] from qiskit import Aer, execute backend = Aer.get_backend('qasm_simulator') results = execute(circuits, backend)",05/11/2021 03:38
17464.0,Time result for my algorithm,"I've used the function result.time_taken to know the amount of time used to execute a task on the real chip, but I don't understand if the result is in seconds or in milliseconds, because if I run my circuit with 1 shot my result is 7.8, if I run my circuit with 1024 shots my result is 8.4. How is this possible? Does the time include only time to execute the algorithm, or other times (for instance the initialization of my input...)?",<programming><qiskit><algorithm><ibm-q-experience>,05/12/2021 05:57,17467.0,17467.0,"The device time consists of multiple step, such as loading the circuit to the device, then the actual processor time and finally the return of the results. Only the processor time scales with the number of shots, the device loading time, and result return are constant overhead. Thus it makes sense to see the behavior you saw; you have some constant time and then on top the time that scales linearly in the number of shots. You could find the time for the overhead if you do a linear fit to the total execution time, then the offset equals the overhead. As a more concrete example, on a recent job the device load and return result together took about 10s and the processor time for 1024 shots was ~4s, and for 8192 ~28s (so even a little bit faster than 8x the 1024 shots time). Of course these numbers depend on the device you're using!",05/12/2021 07:06
17663.0,What explains my anomalously scaled up VQE?,"I am trying to implement VQE from the Qiskit to obtain the ground state of a very specific Hamiltonian that has been generated via a docplex minimized quadratic model. The model has been converted to an Ising Hamiltonian using Qiskit's Optimization module. The resultant Hamiltonian denoted by H is as follows: from qiskit.providers.aer import AerSimulator, QasmSimulator from qiskit.algorithms import VQE from qiskit.algorithms.optimizers import COBYLA from qiskit.circuit.library import TwoLocal from qiskit import * from qiskit.opflow import OperatorBase from qiskit.opflow import Z, X, I # Pauli Z, X matrices and identity import pylab import matplotlib.pyplot as plt import numpy as np H = 504.0 * I^I^I^I^I^I^I^Z+1008.0 * I^I^I^I^I^I^Z^I+2016.0 * I^I^I^I^I^Z^I^I+504.0 * I^I^I^I^Z^I^I^I+1143.7999999999997 * I^I^I^Z^I^I^I^I+2287.6 * I^I^Z^I^I^I^I^I+4575.200000000001 * I^Z^I^I^I^I^I^I+1143.7999999999997 * Z^I^I^I^I^I^I^I+98.0 * I^I^I^I^I^I^Z^Z+196.0 * I^I^I^I^I^Z^I^Z+392.0 * I^I^I^I^I^Z^Z^I+49.0 * I^I^I^I^Z^I^I^Z+98.0 * I^I^I^I^Z^I^Z^I+196.0 * I^I^I^I^Z^Z^I^I+93.1 * I^I^Z^Z^I^I^I^I+186.2 * I^Z^I^Z^I^I^I^I+372.4 * I^Z^Z^I^I^I^I^I+46.55 * Z^I^I^Z^I^I^I^I+93.1 * Z^I^Z^I^I^I^I^I+186.2 * Z^Z^I^I^I^I^I^I backend = QasmSimulator() optimizer = COBYLA(maxiter=2000) ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False) # set the algorithm vqe = VQE(ansatz, optimizer, quantum_instance=backend) #run it with the Hamiltonian we defined above result = vqe.compute_minimum_eigenvalue(H) This however yields the error: 'Circuit execution failed: ERROR: [Experiment 0] QasmSimulator: Insufficient memory for 141-qubit circuit using &quot;statevector&quot; method. You could try using the &quot;matrix_product_state&quot; or &quot;extended_stabilizer&quot; method instead.' My questions are: How and why does my circuit yield 141 qubits when there are only 8 Pauli Operators in each term of my Hamiltonian? What am I missing conceptually? How do we calculate the number of qubits required when solving this sort of problem?",<programming><qiskit><vqe><optimization>,5/27/2021 5:12,17665.0,17665.0,"Easy Fix: It seems like it is because of the way you define $H$. You need the parenthesis around each of the term! So something like: H = (504.0 * I^I^I^I^I^I^I^Z) + (1008.0 * I^I^I^I^I^I^Z^I) + ( 2016.0 * I^I^I^I^I^Z^I^I) Just replace this in your code then it will work! Alternative (longer) way: Here I will offer another way to define the Hamiltonian in case you are curious. Instead of doing the above, if you replace it with something like: from qiskit.aqua.operators import * pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ] pauli_weights = [504.0, 1008.0, 2016.0] pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \ for i in range(len(pauli_terms))]} H = WeightedPauliOperator.from_dict(pauli_dict) This should work. I just grabbed the first 3 entries of your Hamiltonian. Here is the full script for you to reproduce the result: import numpy as np from qiskit.providers.aer import AerSimulator, QasmSimulator from qiskit.algorithms.optimizers import COBYLA from qiskit.circuit.library import TwoLocal from qiskit.aqua.operators import * from qiskit.aqua import set_qiskit_aqua_logging, QuantumInstance from qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE, NumPyEigensolver from qiskit.circuit import QuantumCircuit, ParameterVector pauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ] pauli_weights = [504.0, 1008.0, 2016.0] pauli_dict = {'paulis': [{&quot;coeff&quot;: {&quot;imag&quot;: 0., &quot;real&quot;: pauli_weights[i] }, &quot;label&quot;: pauli_terms[i]} \ for i in range(len(pauli_terms))]} Hamiltonian = WeightedPauliOperator.from_dict(pauli_dict) ansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False) print(ansatz) backend = QasmSimulator() quantum_instance = QuantumInstance(backend, shots = 8192, initial_layout = None, optimization_level = 3) optimizer = COBYLA(maxiter= 100, tol=0.000000001) vqe = VQE(Hamiltonian, ansatz, optimizer, initial_point= None , include_custom = False) print('We are using:', quantum_instance.backend) vqe_result = vqe.run(quantum_instance) vqe_result['eigenvalue'] output: ââââââââââââ ââââââââââââ q_0: â¤ RY(Î¸[0]) âââ¤ RY(Î¸[8]) â ââââââââââââ¤ ââââââââââââ¤ q_1: â¤ RY(Î¸[1]) âââ¤ RY(Î¸[9]) â ââââââââââââ¤ââ´âââââââââââ¤ q_2: â¤ RY(Î¸[2]) ââ¤ RY(Î¸[10]) â ââââââââââââ¤âââââââââââââ¤ q_3: â¤ RY(Î¸[3]) ââ¤ RY(Î¸[11]) â ââââââââââââ¤âââââââââââââ¤ q_4: â¤ RY(Î¸[4]) ââ¤ RY(Î¸[12]) â ââââââââââââ¤âââââââââââââ¤ q_5: â¤ RY(Î¸[5]) ââ¤ RY(Î¸[13]) â ââââââââââââ¤âââââââââââââ¤ q_6: â¤ RY(Î¸[6]) ââ¤ RY(Î¸[14]) â ââââââââââââ¤âââââââââââââ¤ q_7: â¤ RY(Î¸[7]) ââ¤ RY(Î¸[15]) â âââââââââââââââââââââââââ We are using: qasm_simulator (-3528+0j) Although I am not sure why you would have two consecutive layers of $RY$ rotation though.",5/27/2021 6:27
17704.0,Decomposition of gate $R_{y}$ into specific basis,"How can I decompose gate $R_{y}(\theta)$ into gate $R_{x}(\alpha)$ and gate $R_{z}(\beta)$. And how to perform it on Qiskit, is there any function to do it.",<programming><qiskit><quantum-gate>,5/29/2021 8:57,17706.0,17706.0,"Qiskit supports translating to different continuous basis sets by specifying the basis_gates in the transpile method. So in your case you could just do &gt;&gt;&gt; from qiskit import QuantumCircuit, transpile &gt;&gt;&gt; from qiskit.circuit import Parameter &gt;&gt;&gt; circuit = QuantumCircuit(1) &gt;&gt;&gt; circuit.ry(Parameter('theta'), 0) &gt;&gt;&gt; rxrz_basis = transpile(circuit, basis_gates=['rx', 'rz']) &gt;&gt;&gt; rxrz_basis.draw() âââââââââââââââââââââââââââââââââââââââââââââââââ q_0: â¤ RX(Ï/2) ââ¤ RZ(theta + Ï) ââ¤ RX(Ï/2) ââ¤ RZ(3Ï) â âââââââââââââââââââââââââââââââââââââââââââââââââ So you see that $$ R_Y(\theta) = R_Z(\pi) R_X\left(\frac{\pi}{2}\right) R_Z(\theta + \pi) R_X\left(\frac{\pi}{2}\right) $$ where I replaced the $3\pi$ by $\pi$ in the last RZ rotation since the operation is mod $2\pi$.",5/29/2021 9:26
18010.0,How can I write unit tests for a pennylane circuit?,"I have several mixing unitary circuits written using Pennylane to be used in the QAOA algorithm. Furthermore, I'd like to write unit tests for these mixing circuits to ensure that the code is doing what it is supposed to in the future as changes are made to the codebase. Consider the basic example: def x_mixer(beta, wires): for i in wires: qml.RX(beta, wires=i) Currently, I'm thinking of using assert statements to check that the output of: dev = qml.device('lightning.qubit', wires=2, shots=10000) circuit = qml.QNode(mixer_circuit, dev) result = circuit(0.5, wires=[0, 1]) is a certain value. Now one issue is that the results themselves are probabilistic and change during each run. My first question: What's the best way to get around this? Can you set random_seed in any of the simulator devices? In general if someone has ideas on how to do unit testing for Pennylane circuits, it would be really appreciated.",<programming><quantum-circuit><pennylane>,6/17/2021 19:32,18011.0,18011.0,"Simulator devices, like 'lightning.qubit' or 'default.qubit', can usually be run analytically. This is the default for most devices, but can be explicitly specified by setting shots=None. Devices inheriting from QubitDevice, like &quot;default.qubit&quot; and &quot;lightning.qubit&quot; currently rely on numpy.random for their random number generation. So you can also specify the global numpy seed to get reproducible results: import numpy as np np.random.seed(1234) Hope that helps :)",6/17/2021 20:21
18087.0,Are job IDs unique across backends?,"Are job IDs unique across backends, or is it possible that two jobs on two different backends have the same job ID? I'd like to use the job ID as primary key in a database. Thanks in advance!",<programming><qiskit>,6/22/2021 12:07,18095.0,18095.0,"Yes, they are unique across the full system. They are assigned by the server and it is safe to use them as primary key.",6/22/2021 18:25
18225.0,How to assemble two quantum circuits which has each own qubit mapping state?,"I'm curious about something. I tried to do some qubit mapping using SABRE algorithm. Suppose I have two quantum circuits and apply SABRE algorithm to both of them. Then each of them has its own qubit mapping states. After that, I want to compose them to make it as one long quantum circuit. How can I do it? I used python code and qiskit. I have already searched qiskit API and used some functions (compose, combine, append). But the circuits could not be combined. How can I assemble two quantum circuit which have different qubit mapping state respectively? Thank you",<programming><qiskit>,07/01/2021 02:26,18227.0,18227.0,"The short answer to composed circuit is the following. Given circuit1 and circuit2, you can do like this: circuit = circuit1 + circuit2 You can also do that with transpiled circuits: transpiled1 = transpile(circuit1, backend, routing_method='sabre') transpiled2 = transpile(circuit2, backend, routing_method='sabre') circuit = transpiled1 + transpiled2 Notice that the circuits to composed need to be the same size. After transpilation, that is ensured. transpile will make the circuit as big as the backend (given that you use the same backend during transpilation). The operation + will wire the links one-to-one. Here is an example to compose circuit with different sizes: circuit1 = QuantumCircuit(5) circuit1.mcx([0, 1, 3, 4], 2) print(circuit1) circuit2 = QuantumCircuit(2) circuit2.cx(0, 1) print(circuit2) q_0: âââ ââ â q_1: âââ ââ âââ´ââ q_2: â¤ X â âââ¬ââ q_3: âââ ââ â q_4: âââ ââ q_0: âââ ââ âââ´ââ q_1: â¤ X â âââââ In this case, you need to use compose(..., qubits=...). The parameter qubits indicates how to wire the circuits. circuit = circuit1.compose(circuit2, qubits=[3,2]) print(circuit) q_0: âââ âââââââ â q_1: âââ âââââââ âââ´âââââââ q_2: â¤ X ââ¤ X â âââ¬âââââ¬ââ q_3: âââ âââââ ââ â q_4: âââ âââââââ",07/01/2021 07:27
18310.0,Get the inverse of a Hermitian operator for measurement in qiskit,"I am using Qiskit to measure the Hamiltonian H, which isbasically sum of Pauli strings, say something like 2*X^X+0.5*Z^Y. For one variable, I need to get the analytically form of the inverse of H. It seems that there is no easy way to directly get the inverse observable. So, I am wondering that how can I get this done by using qiskit?",<programming><qiskit><measurement>,07/06/2021 12:38,18311.0,18311.0,"It seems that Qiskit does not have this feature. However, you can get the matrix, inverse it using numpy.linalg.inv(), then convert it to operator object again: from qiskit.opflow import X, Y, Z from qiskit.opflow.primitive_ops import MatrixOp import numpy as np op = 2*(X^X)+0.5*(Z^Y) inv_matrix = np.linalg.inv(op.to_matrix()) operator = MatrixOp(inv_matrix) print(operator.to_pauli_op()) And to get a PauliSumOp: pauli_list = [(p.primitive.to_label(), p.coeff) for p in operator.to_pauli_op().oplist] pauli_sum_op = PauliSumOp.from_list(pauli_list)",07/06/2021 13:18
18454.0,About qiskit's error mitigation,"In qiskit, the error correction using least squares is apparently in qiskit-ignis/qiskit/ignis/mitigation/measurement/filters.py, source code from github and reads: # Apply the correction for data_idx, _ in enumerate(raw_data2): if method == 'pseudo_inverse': raw_data2[data_idx] = np.dot( pinv_cal_mat, raw_data2[data_idx]) elif method == 'least_squares': nshots = sum(raw_data2[data_idx]) def fun(x): return sum( (raw_data2[data_idx] - np.dot(self._cal_matrix, x))**2) x0 = np.random.rand(len(self._state_labels)) # ******** x0 = x0 / sum(x0) # ******** cons = ({'type': 'eq', 'fun': lambda x: nshots - sum(x)}) bnds = tuple((0, nshots) for x in x0) res = minimize(fun, x0, method='SLSQP', constraints=cons, bounds=bnds, tol=1e-6) raw_data2[data_idx] = res.x else: raise QiskitError(&quot;Unrecognized method.&quot;) I'm not too skilled in python and I would not like to change my qiskit's base installation. I have marked with * the two lines that seems to me strange. My question is: in this error correction, one does least squares to minimize the function $F=|c_{\rm exp} - Mc_{\rm corr}|^2$, where $c_{\rm exp}, c_{\rm corr}$ are the experimental and corrected counts, respectively and $M$ is the &quot;correction matrix&quot;. As it is common, minimize requires a fair guess x0 in order to find the answer of $F$. I don't understand why the built-in function sets x0 as a random vector. Ok, I can buy that the method &quot;does not know which previous circuit was ran&quot;, but in theory if one knows the circuit, one should choose x0 based on this information, right?",<programming><qiskit><error-mitigation>,7/16/2021 11:14,18461.0,18461.0,"So yeah it is not the best choice. My guess is the individual who programmed it did not think about the physics of the problem. In short, it is best to use the raw input data as the starting point when measurement errors are small. In practice this gives you much faster convergence.",7/16/2021 21:01
18566.0,Job ids retrieval from ID. Big set of jobs,"I'm in the need of running a lot of jobs in the IBM backends. If one likes to run in parallel two jobs (say, with two different parameters), I have seen in the Jobs webpage that sometimes the jobs are mixed. What I mean with this is that e.g. in the downloadable cvs file, row 3 belongs to job 1 and row 4 to job 2. To filter out every single cell in the cvs does not appear feasible. Now, in qiskit, if I send a big job, this is partitioned into several chunks, something that job_set_foo.report(detailed=True) returns is: Job set name: 2021-07-22T14:09:01.003237 ID: XXXX-YYYY tags: [] ... Detail report: experiments: 0-74 job index: 0 job ID: ZZZ1 ... So suppose that my ID XXX-YYY contains 20 jobs ids ZZZx. Is there a way to, from directly the ID, retrieve as a list all the ZZZx's jobs ids? *job_set_foo = job_manager.run(circuits, backend=backend, shots=2**13)",<programming><ibm-q-experience>,7/22/2021 14:29,18567.0,18567.0,"If all what you want is a list of all job IDs for the jobs in a job set: job_set = job_manager.retrieve_job_set(job_set_id = 'XXX-YYY', provider = provider) id_list = [ job.job_id() for job in job_set.jobs() ]",7/22/2021 15:46
18593.0,How to re-ordering physical qubit location into desired one?,"Suppose original quantum circuit have 4 qubits and some quantum operation. Also suppose the result of original quantum circuit state is '1100'. Then apply qubit mapping then mapping state is like below 1 -&gt; 0 3 -&gt; 1 0 -&gt; 2 2 -&gt; 3 Then the result of quantum circuit after qubit mapping will be '1010'. But I want to know how to change these physical qubit state location. So ultimately, I want to see the result after qubit mapping like '1100' which is the same result of original quantum circuit. How can I do that?",<programming><physical-qubit><qubit-mapping>,7/24/2021 4:55,18594.0,18594.0,"I will answer using Python, but the underlying method can be easily adapted to another language. You can represent the mapping you describe in your question 1 -&gt; 0 3 -&gt; 1 0 -&gt; 2 2 -&gt; 3 as a map, or a Python dictionary in this case (it can also be represented as a simple array, but this complicates a little bit the code): logical2hardware_mapping = {0: 1, 1: 3, 2: 0, 3: 2} From this map representation, you can post-process your result quite easily by re-arranging the bits: import typing as ty def rearrange_hardware_result(hardware_result: str, mapping: ty.Dict[int, int]) -&gt; str: # 1. Invert the mapping hardware2logical_mapping = {v: k for k, v in mapping.items()} # 2. Construct the rearranged result return &quot;&quot;.join( hardware_result[hardware2logical_mapping[i]] for i in range(len(hardware_result)) ) Finally, you can test the function on your example and check that it works as expected: hardware_result = &quot;1010&quot; print(rearrange_hardware_result(hardware_result, logical2hardware_mapping)) # Output &quot;1100&quot; Side note: I worked quite a bit with these issues of mapping and how to change them. The most important thing to do at the very beginning in order to understand what you are doing is to note somewhere what is represented. For example in your mapping, you do not explicitly say what the indices on the left-hand side of the arrows are, same for the right-hand side ones. Once the meaning of the indices you are using is clear, everything starts to become easier.",7/24/2021 8:25
18647.0,Print runtime of an optimizer,"I want to find the runtime of my program, i.e. the time it is in the quantum computer without queue time. However, I am using an optimizer so the code is a little different. from qiskit.utils import algorithm_globals algorithm_globals.random_seed = 1234 backend = provider.get_backend('ibmq_belem') #backend = Aer.get_backend('statevector_simulator') cobyla = COBYLA() cobyla.set_options(maxiter=1) ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full') quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed) vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance) vqe = MinimumEigenOptimizer(vqe_mes) result = vqe.solve(qp) print(result) #print_result(result) How do I figure out the runtime? Printing result only shows optimal function value: -0.01488461311339271 optimal value: [1. 0. 0. 1.] status: SUCCESS",<programming><quantum-computing-for-finance>,7/28/2021 18:48,18648.0,18648.0,"I made a start and end_operation point with the method now(). At the end of the operation it will display the time it needed: from qiskit.utils import algorithm_globals from time import time as now algorithm_globals.random_seed = 1234 backend = provider.get_backend('ibmq_belem') #backend = Aer.get_backend('statevector_simulator') cobyla = COBYLA() cobyla.set_options(maxiter=1) ry = TwoLocal(num_assets, 'ry', 'cz', reps=3, entanglement='full') quantum_instance = QuantumInstance(backend=backend, seed_simulator=seed, seed_transpiler=seed) start_operation = now() vqe_mes = VQE(ry, optimizer=cobyla, quantum_instance=quantum_instance) vqe = MinimumEigenOptimizer(vqe_mes) end_operation = now() result = vqe.solve(qp) process_time = ( end_operation - start_operation ) print(f&quot;Operation took {process_time:.2f} seconds in machine&quot;) print(result) #print_result(result) Another possibility to meassure the program is to use the command rep_time: rep_time (int) â Time per program execution in seconds. Must be from the list provided by the backend (backend.configuration().rep_times). Defaults to the first entry. In your specific case you need to add it in your code like this: ... quantum_instance = QuantumInstance(backend=backend, rep_time=rep_time, seed_simulator=seed, seed_transpiler=seed) ...",7/28/2021 19:02
20798.0,Can I extract information from a single shot efficiently?,"I'm running a quantum simulation and want to obtain some information from a single shot of an experiment. Here's part of the code I'm working on: for i in range(Nshot): Expeb = [] for measure_circuit in [circ_1, circ_2, circ_3, circ_4]: measure_circuit = transpile(measure_circuit,backend=backend,optimization_level=2,initial_layout = [1]) counts = execute(measure_circuit, backend = backend, shots=1).result().get_counts() for output in ['0','1']: if output not in counts: counts[output] = 0 expe = (counts['0'] - counts['1']) Expeb.append(expe) Est = sum(x*y for x,y in zip(Expeb,[a,b,c,d])) The code works on simulators, but it might take a very long time if Nshot gets large (Like 5000, I think that's because I generated a lot of circuits) and I submit the jobs to a quantum device. I wonder is there a way I can extract information (like making calculations for) a single shot but in a more efficient way? Thanks for the help!",<programming><ibm-q-experience><simulation>,08/09/2021 16:17,20799.0,20799.0,"You can use memory option. It will make the per-shot measurement bit-strings returned in the result: memory = execute(measure_circuit, backend = backend, memory = True, shots = 1024).result().get_memory()",08/09/2021 16:33
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system? Below you can see the code idea: q1 = QuantumCircuit(2) q1.save_statevector() # Save initial state q1.h(0) q1.save_statevector() # Save state after Hadamard q1.cx(0, 1) q1.save_statevector() # Save state after CNOT (also a final state) job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024) statevectors = job.result().get_statevector() However, if I were to try and run this, an error occurs upon reaching execute command. If anyone can provide any insight on this, I would be very grateful.",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"You can also obtain the states at any point during circuit construction using Statevector, the class from Qiskit's quantum_info module as follows. First, import the Statevector class, from qiskit.quantum_info import Statevector And for your example, the code below will produce all the intermediate states that you want. qc = QuantumCircuit(2) st0 = Statevector.from_instruction(qc) qc.h(0) st1 = Statevector.from_instruction(qc) qc.cnot(0, 1) st2 = Statevector.from_instruction(qc) print(st0) print(st1) print(st2) Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0.70710678+0.j, 0. +0.j, 0. +0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0. +0.j, 0. +0.j, 0.70710678+0.j], dims=(2, 2))",8/25/2021 13:41
20904.0,Q# install issue,"I have followed the instructions to install Q# using conda as recommended, and given by MS. When I try to import qsharp from my virtual env within a Python program, I get the following error: Microsoft.Quantum.IQSharp.Workspace[0] QS5022: No identifier with the name âvâ exists. Does any one have experience of this issue please? I have googled it but to no avail. I use .NET run perfectly with example.qs and example.csproj files, but I would like to work within VSCode. (Ubuntu v. 20.04, .NET SDK v. 3.1, Python v. 3.7 + latest Miniconda)",<programming><q#>,8/21/2021 15:38,20938.0,20938.0,"When you call import qsharp, it will try to compile the .qs files in the current folder so the corresponding operations are available from Python. It seems the Q# compiler is having some problems with one of the files. Try to see if any of the .qs files in the directory have any syntax errors, and try removing the obj folder with temporary files if it exists.",8/23/2021 15:27
20978.0,Return only the measurements of a circuit,"I have written the following program in jupyter: from qiskit import * from qiskit import plot_histogram, matplotlib circuit = QuantumCircuit(16,16) #Making a circuit with 16 qubits qr = QuantumRegister(16) cr = ClassicalRegister(16) for i in range(16): circuit.h(i) circuit.measure(i,i) simulator = Aer.get_backend('qasm_simulator') result = execute(circuit, backend = simulator, shots = 200).result() counts = result.get_counts() print(counts) and the output is of the form : {'0111001100011110': 1, '0101000101101001': 1, '1100010111000100': 1, '0111111110101110': 1,..., '0110110010010110': 1} Is there any way that what I get as an output is the measurement only (e.g. '0111001100011110') without getting the times the measurement has appeared (: 1)?",<programming><qiskit><measurement>,8/26/2021 7:02,20980.0,20980.0,"You can take only the keys of the returned dictionary: measurements = set(counts.keys()) print(measurements) If you want only one random key, you can just take the first one in the set: random_key = next(iter(a)) or store all the keys in a list and take a random one from here: from random import randint measurements_list = list(measurements) random_key = measurement_list[randint(0, len(measurement_list)-1)]",8/26/2021 7:37
21001.0,Passing arrays to operations/functions in Q# Jupyter Notebooks,"In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, %simulate, and writes out the inputs as key-value pairs, key=value. For example, if I had some operation, operation HelloHardy (number : Int) : Unit {...}, then I would run the following %simulate HelloHardy number=1729. I am currently working with the operation, EvaluatePolynomial, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated. %simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false. Received invalid parameters. Please fix and try again: coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11. evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.",<programming><q#>,8/28/2021 19:51,21010.0,21010.0,"IQ# magics don't support passing arrays as parameters at the moment. When I need to pass something more complicated than a scalar, I usually define a wrapper operation that defines all parameters and calls the original operation, and call %simulate for that wrapper operation.",8/29/2021 17:56
21039.0,What is difference between qasm_simulator and ibmq_qasm_simulator?,"There are many ways how to simulate a quantum circuit on IBM Q. However, in partiuclar I am interested in a difference between qasm_simulator and ibmq_qasm_simulator. In Qiskit, the former can be called with statement processor = Aer.backends(name = 'qasm_simulator')[0] while the latter with provider = IBMQ.load_account() processor = provider.backends(name='ibmq_qasm_simulator')[0] I realized that ibmq_qasm_simulator sends jobs similarly to a real quantum processor, i.e. I see the job in Job pane in IBM Q environment. But this is not the case for qasm_simulator. In list of services on IBM Q page I found out only one qasm_simulator. So, my question is how these two simulators differ?",<programming><qiskit><ibm-q-experience><simulation>,09/01/2021 13:53,21040.0,21040.0,"ibmq_qasm_simulator performs the simulation on a classic computer on that resides on the cloud, whereas qasm_simulator does it locally on your computer and consumes your CPU.",09/01/2021 14:21
21210.0,Expected outcome of adding two PauliOp,"first of all, I would probably report this as a bug if I was confident enough in my QC abilities. As it stands, I've just started out, so I'm phrasing it as a question. From what I can tell, adding two PauliOps in this specific case does not result in the expected operator matrix: import qiskit as qk from qiskit.opflow.primitive_ops import PauliOp (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix() results in array([[0.+0.j, 1.-1.j], [1.+1.j, 0.+0.j]]) whereas the result that I would expect is the one i get when I run the following code: PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)).to_matrix() + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;)).to_matrix() Result: array([[0.+0.j, 2.+0.j], [0.+0.j, 0.+0.j]]) What further confuses me is that the deprecated version of PauliOp actually results in the expected operator. Running this code: import qiskit as qk from qiskit.aqua.operators.primitive_ops import PauliOp (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix() gives a deprecation warning and the [[0,2],[0,0]]-array that I want. Has the behaviour of the addition changed or is this a bug? In any case, how can I construct the operator that I want (in a non-deprecated way)? I'm running qiskit version 0.29.0 Thanks in advance!",<qiskit><programming>,9/15/2021 13:03,21217.0,21217.0,"You can do this instead: (PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + 1j*PauliOp(qk.quantum_info.Pauli(&quot;Y&quot;))).to_matrix() which gives what you expect: array([[0.+0.j, 2.+0.j], [0.+0.j, 0.+0.j]])",9/15/2021 20:21
21419.0,Equivalent matrix for operators in qiskit,"What is eqivalent matrix to qc.rx(np.pi, 0): import numpy as np from qiskit import QuantumCircuit, Aer, execute from qiskit.quantum_info import Operator qc = QuantumCircuit(1) qc.rx(np.pi, 0) print('Final matrix:', np.round(Operator(qc).data, 3)) I thought it is the following: $$X = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} =\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \\ \end{pmatrix} $$ but it is not, because of different result. And what would be equivalent matrices in case: qc.rx(np.pi, 0) qc.ry(np.pi, 0)",<qiskit><programming><quantum-gate><circuit-construction>,10/05/2021 14:10,21422.0,21422.0,"Qiskit defines the $RX$ gate as follows: $$ RX(\theta) = \exp\left(-i \frac{\theta}{2} X\right) = \begin{pmatrix} \cos{\frac{\theta}{2}} &amp; -i\sin{\frac{\theta}{2}} \\ -i\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}} \end{pmatrix} $$ Thus, setting $\theta = \pi$, would give us: $$ RX(\pi) = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} = -iX $$ Which is what I suspect you got as output to Operator(qc).data in the first code cell. Thus, a rotation of $\pi$ radians about the $x$-axis is equivalent to the normal bit flip gate $X$ up to a global phase of $-i$. I thought it is the following: $$X = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \\ \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} =\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \\ \end{pmatrix} $$ I think you got confused about matrix multiplication here. First of all, $X$ is only $\begin{pmatrix} 0 &amp; 1 \\ 1&amp; 0 \end{pmatrix}$. I suspect you are trying to get the final state of the circuit, which would correspond to the operation you do in the middle of the above equation (up to the global phase we discussed earlier). But, remember that the product of a matrix of size $2 \times 2$ with a vector of size $2 \times 1$ is another vector of size $2 \times 1$. Thus, you can't get a matrix from this operation. The correct operation to get the final state of your circuit would be the following: $$ RX(\pi)|0\rangle = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ -i \end{pmatrix} = -i|1\rangle $$ Which is equivalent to $|1\rangle$ up to a global phase that we can ignore here since we only have one qubit. If there were more qubits, this global phase would turn into a relative phase. And what would be equivalent matrices in case: qc.rx(np.pi, 0) qc.ry(np.pi, 0) The $RY$ gate is defined as follows: $$ RY(\theta) = \exp\left(-i \frac{\theta}{2} Y\right) = \begin{pmatrix} \cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} \\ \sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}} \end{pmatrix} $$ Thus, to get the unitary corresponding to that circuit, plug in the angle to each of the gates definition and perform matrix multiplication. The operation you need to do is $RY(\pi)RX(\pi)$. And then you could get the final state of the circuit following the same steps as with the first example.",10/05/2021 19:39
21499.0,What is the syntax for general control gate in stim,"For a stabilizer code with the stabilizers in canonical form, an encoding circuit has the form that's a product of hadamard gates and general control gates : $H_i C_i(U_i)$. For example for the $[[5,1,3]]$ code, the circuit would be : $H_{2}C_{2}(Y_{1})$ $H_{3}C_{3}(X_{1})$ $H_{4}C_{4}(X_{1}Z_{2}Z_{3})$ $H_{5}C_{5}(Y_{1}Z_{2}Z_{4})$ $C_i(U_i)$ means apply $U_i$ depending on qubit $i$. The normal $CNOT_{ij}$ would be $C_i(X_j)$. $CZ_{ij}$ gate would be $C_i(Z_j)$; $U_i$ usually needs to be applied to multiple qubits. How would a circuit like this be entered into stim?",<programming><circuit-construction><stabilizer-code><stim>,10/11/2021 03:14,21501.0,21501.0,"There currently isn't a controlled Pauli product gate in Stim. You have to decompose it into a series of CX, CY, and CZ gates. # Apply X1*Y2*Z3 controlled by qubit 0 CX 0 1 CY 0 2 CZ 0 3 # Apply X1*Y2*Z3 if latest measurement result was True CX rec[-1] 1 CY rec[-1] 2 CZ rec[-1] 3",10/11/2021 07:10
21779.0,"How can I initialize a state like, $|00\rangle$ or $|01\rangle$ or $|10\rangle$ or $|11\rangle$ in Qiskit?","Many thanks in advance for your help. I am a beginner in Qiskit. I want to implement a circuit that uses the position of an element/item, of the form (x,y) and I would like to represent it as a state $|\phi\rangle = |xy\rangle$. How can I initialize a state like, $|00\rangle$ or $|01\rangle$ or $|10\rangle$ or $|11\rangle$? Or how could I apply the tensor product to get it?",<qiskit><programming><quantum-gate><quantum-state>,11/03/2021 02:41,21781.0,21781.0,"Here is Qiskit code you wanted: from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister q = QuantumRegister(2) c = ClassicalRegister(2) #state |00&gt; circ00 = QuantumCircuit(q,c) circ00.draw() #do nothing, both qubits are already in state |0&gt; #state |01&gt; circ01 = QuantumCircuit(q,c) circ01.x(q[1]) circ01.draw() #state |10&gt; circ10 = QuantumCircuit(q,c) circ10.x(q[0]) circ10.draw() #state |11&gt; circ11 = QuantumCircuit(q,c) circ11.x(q[0]) circ11.x(q[1]) circ11.draw() State you want to prepare are so-called basis states in computational basis. You can easily prepare them with $X$ gate (i.e. equivalent of NOT in classical computation). Initially, qubits are in state $|0\rangle$. If you want to change one of them to state $|1\rangle$, simply put on that qubit the $X$ gate. Please run the code per partes to see how circuits differ for each of the basis states. In Qiskit, you can also use function initialize. It uses vector representation of states, which are in your case: $|00\rangle = \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}^T$ $|01\rangle = \begin{pmatrix}0 &amp; 1 &amp; 0 &amp; 0\end{pmatrix}^T$ $|10\rangle = \begin{pmatrix}0 &amp; 0 &amp; 1 &amp; 0\end{pmatrix}^T$ $|11\rangle = \begin{pmatrix}0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}^T$ So, the Qiskit code is following from qiskit import QuantumCircuit, transpile, Aer, IBMQ, QuantumRegister, ClassicalRegister, execute import numpy as np import numpy as np q = QuantumRegister(2) c = ClassicalRegister(2) circ = QuantumCircuit(q,c) #state = np.array([1,0,0,0]) #00 #state = np.array([0,1,0,0]) #01 #state = np.array([0,0,1,0]) #10 state = np.array([0,0,0,1]) #11 circ.initialize(state) circ.measure(q,c) processor = Aer.backends(name='qasm_simulator')[0] #simulator res = execute(circ, processor, shots = 1).result().get_counts(circ) print(res)",11/03/2021 09:36
21964.0,Stim: is it possible to add comments when creating a circuit?,"I'm trying to create a Stim.Circuit, given a list of qubits and operations on them. Does the API support adding comments to the circuit's string representation? I've tried using circuit.append_from_stim_program_text('# Some comment'), but such comments never appear when I later call print(repr(circuit)), so I presume this method only cares about appending actual circuit instructions. Any help / workarounds appreciated!",<programming><stim>,11/17/2021 10:59,21965.0,21965.0,"No, the python API doesn't support adding comments. Neither does the underlying C++ API, actually. Comments are completely discarded by the parser, and the circuit struct has no fields for storing them or related concepts such as whitespace. This is unlikely to change because such things tend to involve performance sacrifices (eg. additional memory allocations to store the comments during parsing or additional branches to deal with a more complex circuit struct during simulation). (Similar performance-driven limitations are that operation names get canonicalized and adjacent operations get fused. For example, parsing &quot;SQRT_Z 0\nSQRT_Z 1&quot; then printing it gives you &quot;S 0 1&quot;.) If you need to output a circuit that contains comments, you'll have to track the comments for yourself. For example, you could keep a dictionary mapping instruction indices to strings and then print the circuit instruction-by-instruction while appending comments from the dictionary: from typing import Dict import stim def print_commented_circuit(circuit: stim.Circuit, line_comments: Dict[int, str]): for i, instruction in enumerate(circuit): line = str(instruction) if i in line_comments: line += &quot; # &quot; + line_comments[i] print(line) print_commented_circuit( circuit=stim.Circuit(&quot;&quot;&quot; H 0 CX 0 1 M 0 1 &quot;&quot;&quot;), line_comments = { 1: &quot;entangle&quot;, }, ) Which outputs: H 0 CX 0 1 # entangle M 0 1",11/17/2021 12:18
22065.0,Openfermion state transformation from Bravyi-Kitaev basis to occupation number,"I'm working in the Bravyi-Kitaev basis implemented by the openfermion.bravyi_kitaev() function to find the ground state of a fermionic operator in the BK representation. Now I want to convert this ground state from the BK basis to the occupation number basis. I couldn't find any functions implementing this, and the transformation matrix shown in arXiv:1208.5986 is not the correct one. Has anyone managed to find a transform between these two bases?",<programming><cirq><openfermion>,11/25/2021 17:10,22134.0,22134.0,"I managed to solve the problem: The matrix $\beta$ that transforms a binary string from the occupation number basis to the Bravyi-Kitaev basis, introduced in arXiv:1208.5986 in eq. (23), is the correct matrix. For qubit states in cirq the ordering of the qubits has to be reversed, while qubit states in Qiskit can be transformed directly.",11/30/2021 10:03
22281.0,Simulating flag qubits and conditional branches using Stim,"In a quantum error correcting code using flag qubits, it's common to have flag measurements that tell you it's necessary to do some extra measurements for safety. So, for example, I want to say: if measurement_result_was_true: do_a_different_measurement How do I do this in Stim? There doesn't seem to be an if. (This was a question I received by email. Moving it here for posterity.)",<programming><error-correction><stim>,12/14/2021 21:51,22282.0,22282.0,"This is definitely a place where you'll struggle to use Stim. It's possible but it's not nice. It could still be worth your time just because you don't have to eg. manually write code to turn a circuit into a matching graph, but it'll be more tedious than branchless code. Part 1: Simulating The easiest thing to do is to use stim.TableauSimulator. It gives you the ability to apply operations one by one driven by python code, which is more than flexible enough to do what you need. Here is python code showing the general idea: import stim simulator = stim.TableauSimulator() # Run first part of circuit. simulator.do(stim.Circuit(&quot;&quot;&quot; H 0 CNOT 0 1 M 0 &quot;&quot;&quot;)) # Do something depending on the measurement result. latest_measurement_result = simulator.current_measurement_record()[-1] if latest_measurement_result: simulator.do(stim.Circuit(&quot;&quot;&quot; # ... &quot;&quot;&quot;)) # Run the rest of the circuit. simulator.do(stim.Circuit(&quot;&quot;&quot; # ... &quot;&quot;&quot;)) shot = simulator.current_measurement_record() The reason Stim doesn't support branching in its circuit format is because branches break an algorithmic optimization where the tableau simulator is only used once for a reference sample, and then stim switches to using much faster error frame simulation. Consequently, you will find that getting thousands of samples by repeatedly using stim.TableauSimulator is easily 100x slower than using circuit.compile_sampler().sample(shots). Hopefully it's still fast enough for your needs. If you have less than 10 branches, a possible alternative would be to run simulations for each possible case and then postselect out the inconsistent ones where the hardcoded branch disagreed with the measurement result deciding whether or not it was taken. The performance difference can be large enough to overcome the losses from the postselections. Part 2: Correcting I'm assuming you're using PyMatching. For each shot, you need to build the circuit that was actually run. This circuit will give you access to a detector error model (circuit.detector_error_model(decompose_errors=True)) and the ability to convert the measurement results into detection events (circuit.compile_m2d_converter().convert(shot, append_observables=True)). Convert the measurements into detection events + observable frame changes, and then run pymatching on the detector data, configured with the circuit's detector error model, and check whether or not it predicted the observable frame data. If you only have a few possible cases, you will get a large benefit from grouping shots that took the same paths together. If you have a lot of possible cases, so that each case is hit less than 3 times on average, grouping isn't worth it. It's likely that error model extraction will be your main bottleneck here. Stim is pretty quick at this, it takes it a third of a second or so to analyze the error model of a distance 25 surface code, but a third of a second per sample is awful. I intend for this use case to get better in the future, but haven't got any concrete designs I'm happy with yet.",12/14/2021 21:51
23353.0,How to order results after multi-circuit qiskit.execute parallel run?,"I'm kinda new to qiskit and I find really fascinating its parallelization capabilities, then I'm trying to creating all the needed circuits for my application at once and transpile, assemble and execute them all at once using the execute method. Basically, qcircuits = [] # construct my circuits and append to qcircuits # ... backend: backend: BaseBackend = qiskit.Aer.get_backend('qasm_simulator') n_shots = 1024 job = qiskit.execute( qcircuits, backend, optimization_level=optimization_level, shots=n_shots ) counts = job.result().get_counts() Nevertheless, I noticed that the job.result().get_couts() output is not deterministic as, I guess, it runs all the circuits using a parallel_map and appends in the returned list in the order they finish. Is there any way to force the execute method respecting the order of qcircuits ? If it is not the case, is there any way to label the execution results so that I can sort them myself afterwards ? Thanks in advance.",<qiskit><programming><simulation><quantum-parallelism>,12/21/2021 13:25,23382.0,23382.0,"Each qiskit.QuantumCircuit has a name attribute that is also accessible through each qiskit.result.Result. So, you can do the following to match the circuits to the measurement counts after running in parallel: for circuit in qcircuits: print(circuit.name) result_dict = jobs.result().to_dict()[&quot;results&quot;] result_counts = jobs.result().get_counts() for i in range(len(qcircuits)): name = result_dict[i][&quot;header&quot;][&quot;name&quot;] counts = result_counts[i] print(f&quot;{name}: {counts}&quot;) Before running your circuits, you could also assign your own descriptive names, e.g. for i in range(len(qcircuits)): qcircuits[i].name = &quot;mycircuit&quot;+str(i) Edit: Combining the ideas above to show how to order the results: # number input circuits in ascending order for i in range(len(qcircuits)): qcircuits[i].name = &quot;circuit_&quot;+str(i) job = qiskit.execute(qcircuits, backend, ...) result_dict = job.result().to_dict()[&quot;results&quot;] result_counts = job.result().get_counts() # initialize list to store ordered results results_ordered = [None] * len(qcircuits) for i in range(len(qcircuits)): name = result_dict[i][&quot;header&quot;][&quot;name&quot;] n = int(name.split('_')[1]) # index of circuit in input list results_ordered[n] = result_counts[i] # add to result list at same index",12/22/2021 20:48
23504.0,"Given this code fragment, what is the probability that a measurement would result in $|0\rangle$?","Trying to understand below probability how it occured? qc = QuantumCircuit(1) qc.ry(3 * math.pi/4, 0) A. 0.8536 B. 0.5 C. 0.1464 D. 1.0 And the answer is C. But I can't understand the calculation behind it. Can someone please explain?",<qiskit><programming><quantum-state><ibm-q-experience><textbook-and-exercises>,12/31/2021 10:55,23505.0,23505.0,"We have, $$\begin{align}\begin{aligned}\newcommand{\th}{\frac{\theta}{2}}\\\begin{split}Ry(\theta) = \exp\Big(-i \th Y\Big) = \begin{pmatrix} \cos{\th} &amp; -\sin{\th} \\ \sin{\th} &amp; \cos{\th} \end{pmatrix}\end{split}\end{aligned}\end{align}$$ If the input state is $|0\rangle$, then the probability of getting $|0\rangle$ as a measurement result is the square of the absolute value of the entry in the first row and first column. That is, $\cos^2\big({\th}\big)$. Now, $\theta = 3 \pi/4$, so the probability equals $\cos^2(3 \pi/8) = 0.1464$.",12/31/2021 12:43
23528.0,Quantum Phase Estimation - Should be getting exact answer,"Having read the Qiskit demonstration in the Qiskit textbook on how to implement Quantum Phase Estimation, I tried to do so on PennyLane's framework. My code pretty well follows what was done in Qiskit, with a few nuances according to PennyLane, but when I run it over many shots, I get varying answers. For reference, I was implementing the T-Gate (exactly what is done in Qiskit textbook). While my code yields varying possibilities, Qiskit's strictly obtains 001 (which, through post-processing, shows that the applied phase was 1/8). Perhaps there is something wrong with the program I wrote? Is the code supposed to always yield 001? dev = qml.device('default.qubit', wires = 4, shots=1) @qml.qnode(dev) def circuit(): qml.PauliX(wires = 3) for qubit in range(3): qml.Hadamard(qubit) def t_gate(j): qml.T(wires = j) repetitions = 1 n = len(dev.wires) - 1 for x in range(n-1, -1, -1): for i in range(repetitions): qml.ctrl(t_gate, control = x)(3) repetitions *= 2 def ops1(wires = [0, 2]): qml.templates.QFT(wires = [0, 2]) qml.adjoint(ops1)(wires = [0, 2]) return qml.sample() fig, ax = qml.draw_mpl(circuit)() fig.show() for i in range(0, 10): print(circuit()) Results: [0 0 1 1] [0 1 1 1] [1 1 1 1] [0 1 1 1] [1 1 1 1] [0 0 1 1] [1 0 1 1] [0 0 1 1] [0 0 1 1] [0 0 1 1]",<programming><pennylane>,01/02/2022 23:43,23544.0,23544.0,"Your circuit is very close, with only minor modifications needed to match the result from the Qiskit textbook. The counting registers are the first three wires of the circuit; so we need to apply the inverse QFT to wires 0, 1, and 2. Similarly, we want to measure samples only from wires 0, 1, and 2. Here is an updated version of your code with these two changes: import pennylane as qml import numpy as np dev = qml.device(&quot;default.qubit&quot;, wires=4, shots=10) @qml.qnode(dev) def circuit(): qml.PauliX(wires=3) for qubit in range(3): qml.Hadamard(wires=qubit) repetitions = 1 for x in range(2, -1, -1): for i in range(repetitions): qml.ControlledPhaseShift(np.pi / 4, wires=[x, 3]) repetitions *= 2 qml.adjoint(qml.QFT)(wires=[0, 1, 2]) return qml.sample(wires=[0, 1, 2]) print(qml.draw(circuit)()) print(circuit()) This gives the results: 0: ââHâââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââ­QFTâ»Â¹âââ­â¤ Sample[basis] 1: ââHâââââââââââââââââââââââââââââââââ­ControlledPhaseShift(0.785)âââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââQFTâ»Â¹ââââ¤ Sample[basis] 2: ââHâââ­ControlledPhaseShift(0.785)âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ°QFTâ»Â¹âââ°â¤ Sample[basis] 3: ââXâââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)âââ°ControlledPhaseShift(0.785)ââââââââââââ¤ [[0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1] [0 0 1]] matching the expected result from applying phase estimation. Note that I also made some other minor modifications: Rather than looping over the QNode executions, if you set shots=N in the device, you will get a somewhat significant speed boost! While qml.ctrl(qml.T, control=x)(wires=x) works, I have slightly modified this to use qml.ControlledPhaseShift, simply because it prints out slightly nicer in the circuit drawer qml.T and qml.QFT are directly callables, so they can be passed directly to qml.ctrl and qml.adjoint, no need to wrap them in functions :)",01/04/2022 07:27
24391.0,Is there any reasonably efficient way of performing qudit circuit simulations using Stim?,"Is there any reasonably efficient way of performing qudit circuit simulations using Stim? If so, then how much worse would the computational complexity scale?",<programming><error-correction><stim>,03/06/2022 12:21,24451.0,24451.0,"Stim only speaks qubits, not qudits. All of the supported gates are qubit gates, and all of the internal data structures are for specifically the qubit case. There are no plans to add native support for qudits to stim. (So if it's possible it will take the form of mapping qudit stabilizer circuits into qubit stabilizer circuits.)",03/09/2022 15:35
26097.0,Generating a random 16-digits in a superposition state using Qiskit,"Im trying to create a script using Qiskit for a days but somehow i couldn't seem to get it done!! Im new to QuantumComputing, so pardon me if i don't explain something properly. I need to create a simple script generating perfectly a random 16-digits (e. g 1548796654421354) in a superposition state using Hadamard gate (i think it requires 128 qubits i guess) and measuring them into a classical bits and printing the results different each time. (eg output: 5698744565414654) Thank you King.",<qiskit><programming><quantum-gate><quantum-state><algorithm>,4/22/2022 5:51,26101.0,26101.0,"You need $\lceil d\log_2(10)\rceil$ qubits to store a $d$ decimal digits number. So you can generate a superposition state of binary representation of a 16 decimal digits number using the following circuit: from qiskit import QuantumRegister, QuantumCircuit, Aer import numpy as np num_of_decimal_digits = 16 num_of_qubits = int(np.ceil(num_of_decimal_digits * np.log2(10))) qr = QuantumRegister(num_of_qubits, 'q') circ = QuantumCircuit(num_of_qubits) circ.h(qr) circ.measure_all() And to get the number: simulator = Aer.get_backend('qasm_simulator') result = simulator.run(circ, shots = 1).result() counts = result.get_counts() bitstring = next(iter(counts)) decimal = int(bitstring, 2) print('Binary:', bitstring) print('Decimal:', f'{decimal:016d}') Note: You need all these qubits to have a superposition. If you just want to generate a random 16-digits number, you can use a single qubit and run the circuit repeatedly (by setting shots = number of bits) then append the result bits.",4/22/2022 8:15
26241.0,Qiskit compute mean expectation value,"I want to calculate the mean expectation value of an PauliSumOp within qiskit after I executed a QAOA Circuit. My approach is the following: # Run and get counts job=qiskit.execute(circuit,backend=simulator,shots=shots,optimization_level=0) result = job.result().get_counts() # Compute average expectation value of the observable H Ising max_count=0 value=0 for string,count in result.items(): value+=count*sum([(~StateFn(string)@ op @ StateFn(string)).eval() for op in hamiltonian]) max_count+=count expectation=value/max_count Is this correct? I am especially concerned if StateFn(Bitstring) is a valid usage of qiskit in terms of StateFn(&quot;0101&quot;)=$|0101\rangle$",<qiskit><programming><qaoa>,05/02/2022 10:15,26344.0,26344.0,"Yes, StateFn(Bitstring) is a valid usage of qiskit in terms of StateFn(&quot;0101&quot;)=$\left|0101\right\rangle$. As an example: &gt;&gt;&gt; from qiskit.opflow import Plus, StateFn &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; print(Plus.to_circuit()) âââââ q_0: â¤ H â âââââ &gt;&gt;&gt; v_zero_one = (StateFn(&quot;0&quot;) + StateFn(&quot;1&quot;)) / np.sqrt(2) &gt;&gt;&gt; print(v_zero_one) DictStateFn({'0': 1.0, '1': 1.0}) * 0.7071067811865475 &gt;&gt;&gt; np.allclose(Plus.to_matrix(), v_zero_one.to_matrix()) True And yes, to me, the rest of your code looks correct for hamiltonian of type PauliSumOp.",05/10/2022 15:33
26377.0,Iterative quantum phase estimation - real device,"I'm trying to implement the iterative quantum phase estimation on a real (IBM) quantum computer. I'm using the code below. When I run this code on a simulator the results are the expected ones, but when running on a real device the results don't follow any pattern. import matplotlib.pyplot as plt # QML from pennylane import numpy as np from qiskit import * from qiskit.visualization import plot_histogram from qiskit.tools.monitor import job_monitor shots=32000 # Key with the maximum probability - maior in Portuguese def maior(dic): m=list(dic)[0] for n in list(dic): if dic[n]&gt;dic[m]: m=n return m from key import tok from qiskit import IBMQ #2 IBMQ.save_account(tok, overwrite=True) IBMQ.load_account() provider =IBMQ.get_provider(hub='ibm-q-minho', group='academicprojects', project='quantalab') backend = provider.get_backend('ibmq_toronto') #4 # ## Iterative Quantum Phase Estimation Algorithm def get_circuit_phase(t, QC, clbits, qubits, ancilla, backend=None, ): mycircuit=QuantumCircuit(2) mycircuit.cx(0,1) mycircuit.rx(2*t,0) mycircuit.rz(2*t,1) mycircuit.cx(0,1) mycircuit.cy(0,1) mycircuit.ry(2*t,0) mycircuit.cy(0,1) #print(mycircuit.draw()) # Circuit -&gt; controlled gate CU=mycircuit.to_gate().control(1) res = [] # start with the iteration phase = -2 * np.pi factor = 0 iterations = 3 # generate the qubit list on which the Unitary is applied qargs = [ancilla] for q in qubits: qargs.append(q) exponent = 2 ** (iterations - 1) for it in range(iterations): # start QC.reset(ancilla) QC.h(ancilla) # add the inverse rotation inv_phase = phase * factor QC.p(inv_phase, ancilla) # add the controlled Unitary of iteration it # need to add exponential amount of matrices for _ in range(int(exponent)): QC = QC.compose(CU, qubits=qargs) exponent /= 2 # add H gate QC.h(ancilla) QC.measure(ancilla, clbits[it]) if backend == None: # simulating backend=Aer.get_backend(&quot;qasm_simulator&quot;) t_qpe = transpile(QC, backend,optimization_level=3) job = backend.run(t_qpe, shots=shots) job_monitor(job) counts = job.result().get_counts(QC) # mai is the key with the most probability. mai=maior(counts) # Save the bit res.append(int(mai[3-it-1])) # if bit measured is 1 if mai[3-it-1] == &quot;1&quot;: factor += 1 / 2 # add the phase factor factor = factor / 2 # shift each towards one weight right # phase has now been stored in the clbits # returning its binary representation # need to reverse as LSB is stored at the zeroth index and # not the last res = res[::-1] # find decimal phase dec = 0 weight = 1 / 2 for k in res: dec += (weight) * k weight /= 2 return dec for estado in [-1,1]: tau=[] phase=[] for t in range(0,30,1): nq = 3 # number of qubits m = 3 # number of classical bits q = QuantumRegister(nq,'q') c = ClassicalRegister(m,'c') qc = QuantumCircuit(q,c) qc.h(0) qc.initialize(params=[0, 1/np.sqrt(2),estado*1/np.sqrt(2), 0],qubits=[1,2]) t=t/5 tau.append(t) x=get_circuit_phase(t, QC=qc, clbits=[0,1,2], qubits=[1,2], ancilla=[0], backend=backend ) phase.append(x) if estado==-1: plt.plot(tau,phase,label=&quot;- state&quot;) if estado==1: plt.plot(tau,phase,label=&quot;+ state&quot;) plt.xlabel(&quot;$tau$&quot;) plt.ylabel(&quot;$theta$&quot;) plt.legend() plt.show() I hope anyone can help with this issue, my sincere thanks, Gabriela Oliveira.",<programming><algorithm><ibm-q-experience><ibm>,5/13/2022 8:32,26426.0,26426.0,"Dynamic circuit capabilities (eg., circuits with control flow) are not yet supported by production IBM hardware. These capabilities will be coming later in 2022 to select devices as per the IBM Quantum Roadmap. For now, you must use a simulator.",5/16/2022 11:55
26591.0,Applying an S gate on which two states leaves the state unchanged,I was going through a guide given by my friend and it had this MCQ which I couldn't get the answer to. Applying an S gate on which two states leaves the state unchanged? |0 &gt; |+ &gt; |1 &gt; |- &gt; |â³ &gt;,<programming><quantum-gate><quantum-state>,5/27/2022 7:46,26592.0,26592.0,"You've got two options: just try applying $S$ to each of the states to see what happens. For example $S|+\rangle=(|0\rangle+i|1\rangle)/\sqrt{2}$, so the $|+\rangle$ state does change. note that you're effective asked to find the eigenvectors of $S$. So write it in matrix form. The only thing you have to be careful of is the sense in which I'm guessing &quot;doesn't change&quot; is meant here. Remember that global phases are irrelevant to quantum states, so one might consider $$ S|1\rangle=i|1\rangle\equiv|1\rangle $$ as being unchanged.",5/27/2022 8:07
27049.0,Why does having two classical registers sometimes only yeild one bit?,"I was running some qiskit code on qasm_simulator to test something and I realized that, when I have two separate classical registers, sometimes only one bit is generated, and I'm trying to understand why? If you have two meaurements, but send them to only one classical register, the second one overwrites the first in the final output. I would expect that if you have two seperate classical registers, both with be displayed in the output but that doesnt always seems to be the case? Fore example here is some simple code that demonstrates this: #Sending two measurements to one classical register yeilds only outputs of one bit. circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) job = execute(circuit, backend, shots=8192, memory=True) output=[] result_list=job.result().get_memory() for entry in result_list: output.append(int(entry)) print(output) &gt;&gt;&gt; [1, 1, 1, 0, 1, 1, 0, 0, 0,...] #Sending two measurements to two different classical register sometimes yeild two bits and sometimes yeilds one. circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[1]) job = execute(circuit, backend, shots=8192, memory=True) output=[] result_list=job.result().get_memory() for entry in result_list: output.append(int(entry)) print(output) &gt;&gt;&gt; [0, 10, 11, 11, 11, 10, 10, 1, 11, 11, 10, 11, 0, 11, 1, 10, 0, 11, 0, 10, 10, 1,...]",<measurement><classical-computing>,6/24/2022 14:37,27051.0,27051.0,"This happens because your convert the bit-strings to integers. output.append(int(entry)) Hence, the leading zeros are removed. If you want to keep the bit-string as it is, don't convert it: print(job.result().get_memory())",6/24/2022 16:12
27757.0,Partial Measurement in AWS Braket,"Is there a way to do partial Measurement in AWS Braket? Basically, if I have a circuit with $N$ qubits, can I measure only $n$ qubits out of them with the result type &quot;expectation&quot;?",<programming><amazon-braket>,08/12/2022 20:39,27759.0,27759.0,"Physically, there is currently no way to perform a partial measurement (on hardware in particular, all qubits are measured); you'll have to slice out the unwanted qubits if you're using raw measurements directly. As for result types, you can definitely measure the expectation of an observable on only a subset of qubits: from braket.circuits import Circuit, observables from braket.devices import LocalSimulator dev = LocalSimulator() circ = Circuit().h(0).cnot(0, 1).cnot(1, 2).expectation(observables.Z() @ observables.Z(), [0, 2]) dev.run(circ).result().values [1.0]",08/12/2022 23:04
27867.0,Qiskit: Can I run real experiments in QPUs with OOP structured code?,"The question might be naive, but I'm hesitant to design my algorithm in a complex, Object-Oriented scheme (custom classes, objects etc.). My fear is that current frameworks (e.g. ibmq, qiskit-runtime) don't support it. Is this the case? Can I verify/reject this?",<qiskit><programming><ibm-q-experience><python>,8/20/2022 11:01,27874.0,27874.0,"You can consider Qiskit as a classical interface between QPU and classical computer. You use classical programming language to prepare quantum circuit. Before sending the circuit to QPU you are still in classical world and you can do anything Python allows - use all other Python libraries, connect to SQL databases or other data sources etc. Even if you call already prepared algorithms from Qiskit libraries you do so classically. Once you call procedure for running the computation on QPU, your algorithm is transpiled to native quantum gates of particular QPU. This is also classical process. Only after that (again classical) electronic set up QPU and run the algorithm in quantum world. After measurement, you receive classical data and you can post-process them in Qiskit, again classically. To sum up, you can use any programming paradigm supported by Python. From your point of view, everything is done classically and QPU is just a device controlled by your classical program using Qiskit libraries.",8/21/2022 6:40
28366.0,Expectation values of non-local operators in Qiskit,"Is there a convenient way in Qiskit to calculate the expectation value for a non-local operator, i.e. I would like to calculate: $$ \langle \Psi|O|\Psi \rangle $$ More precisely, I would like to calculate the expectation value for an Operator that can be described by the following circuit: operator_circ = QuantumCircuit(4) operator_circ.x(0) operator_circ.cz([1, 1, 2], [2, 3, 3]) I am currently doing the following to calculate the expectation value: operator = Operator(operator_circ) #Where psi is some quantumstate/quantumcircuit psi.save_expectation_value(operator, range(4)) But I am afraid, that this is not what I want since when I look into the decomposition of the Operator it consists of some multiplexers that in turn consists of $CCX$ gates and a gate called squ_dg. However, what I would like is to calculate the expectation value w.r.t. the decomposition of the operator circuit into summed weighted local Pauli. Ideally some function expresses the $CZ$ gate like so: $$ CZ_{12} = \frac{1}{2} (I_1 \otimes I_2 + I_1 \otimes Z_2 + Z_1 \otimes I_2 - Z_1 \otimes Z_2) $$ and then calculates the expectation value over the sums of weighted Paulis on the right hand side. Or is it the same as just using the afformentioned code? What would be the best practice in Qiskit in this case?",<qiskit><programming><quantum-state><pauli-gates><non-locality>,10/01/2022 14:52,28374.0,28374.0,"Looking deeper into the source code I found out that any Operator always gets internally transformed into a SparsePauliOp, i.e. a representation of weighted (sparse) Paulis which is exactly what I wanted.",10/02/2022 14:31
29784.0,How to check a given unitary evolution is correct in a real quantum computer in Qiskit?,"For a given unitary, I want to know whether this unitary gate is correctly evolved in the circuit. In the simulator, I can use &quot;statevector&quot; to get the state vector to check the correctness of the evolution. But I don't know whether such a unitary can still evolve correctly on a real quantum computer. Is there a corresponding way to check its correctness? In more detail, I give a Hamiltonian H, then I get unitary U=expm(-1t*H). Then I add this unitary gate to the circuit usingqc.unitary(U, [0,1]). So how can I check whether it evolves correctly in the real quantum computer?",<qiskit><programming><quantum-gate><quantum-state><unitarity>,1/20/2023 10:24,29785.0,29785.0,"There is no way to get a &quot;perfectly correct&quot; state evolution on a real quantum computer since the hardware is affected by different types of noise (e.g. coherent gate error, state decoherence, etc.) and it is not error-corrected. What you can do is to first run your quantum circuit implementing the unitary $U$ on a perfect simulator, in order to check it is doing what it is supposed to do, and then set it up to run on your real device. In this case, you can be pretty sure that the deviation between the simulation and the actual execution is due to noise effects only.",1/20/2023 10:58
29964.0,"Generating random, but non-uniform state","I would like an algorithm that generates a random state, sampled according to some probability distribution which is not uniform in Hilbert space. Assume though that I have at my disposal a uniform (i.e. Haar) random state generator. How do I do that? For concreteness consider the case of a single qubit. Then a Haar random state is a point on the Bloch sphere which is distributed according to the Haar measure $d\psi$ on the sphere. One way to generate such states on a computer is to create a column vector with real and imaginary parts i.i.d. according to $\mathcal{N}(0,1)$, then normalize it. This method generalizes to multiple qubits. But suppose I want to generate states sampled not according to $d\psi$, but according to $$ p( \psi) d\psi = 2 \langle \psi|0\rangle \langle 0|\psi \rangle d\psi, $$ where $|0\rangle$ is the state corresponding to the North Pole on the Bloch sphere. One can check that $p(\psi) \geq 0$ and $\int d\psi p(\psi) = 1$ so $p(\psi$) is a valid probability density function. This distribution, is such that states near the North Pole occur more likely than states near the South Pole. How would I write a simple program to do this? Note: this is similar to the standard case of real numbers where if we have a uniform r.n.g. in $[0,1]$ we can use this to generate random numbers sampled from any other arbitrary distribution on the real line, e.g. using Box-Muller, inverse transform, ziggurat, rejection sampling. Presumably some variant of the above methods generalizes, but since the sample space is different I am finding it difficult to think about it.",<programming><probability><haar-distribution>,02/01/2023 00:58,29969.0,29969.0,"Rejection sampling is a good fit and works without any changes, simply by plugging the desired distribution $p(\psi)$ into the standard algorithm. Let$^1$ $M:=\max_{\psi\in\mathbb{CP}^1} p(\psi)$. To sample a pure state $\psi$ from the distribution specified by $p(\psi)$, do the following: Sample a pure state $\psi$ from the Haar distribution. Sample a real number $x$ from the uniform distribution over $[0,M]$. If $x&gt;p(\psi)$, go back to 1. Return $\psi$. This works for the same reason any rejection sampling works. Essentially, we are sampling uniformly distributed points $(\psi,x)$ from $\mathbb{CP}^1\times[0,M]$, throwing away the points that are &quot;above the plot of $p(\psi)$&quot; and keeping the ones &quot;below it&quot;. $^1$ The maximum exists, because Bloch sphere $\mathbb{CP}^1$ is compact and $p(\psi)$ is continuous.",02/01/2023 08:16
30109.0,Is it possible to automatically rename a job at submission time?,"I would like to find out if there is some way to rename a job automatically, either when the job is first sent to the queue, or later after the fact. I've tried searching through the forum and the documentation to try and find a solution, but nothing that seems to do the trick. The closest I have found is the qobj_id parameter, however, this is depreciated and no longer functions. Edit: I finally found a (frustratingly easy) solution, see my answer below",<qiskit><programming>,02/07/2023 20:26,30153.0,30153.0,"I finally managed to find a solution. It actually ended up being so simple, that I think the only way that I had missed it was that I was looking for a solution within backend.run() or execute() and not the job object itself. The solution uses the job.update_name() method and here is a simple implementation of it. backend = provider.get_backend('ibm_nairobi') qreg_q = QuantumRegister(1, 'q') creg_c = ClassicalRegister(1, 'c') circuit = QuantumCircuit(qreg_q, creg_c) circuit.h(qreg_q[0]) circuit.measure(qreg_q[0], creg_c[0]) job = execute(circuit, backend, shots=8192, memory=True) job.update_name('test_name') #the new job will have the name &quot;test_name&quot;",02/10/2023 20:48
30279.0,A quantum circuit to find if 4 given sides can form a rectangle,"I wrote this code that uses a swap test to find if 2 pairs of sides are equal. First, amplitude encoding the 4 sides on 3 qubits then performing the swap test. I'm not sure where my logic went faulty, especially that I'm not very familiar with the logic of swap test yet. Here is the code import math def is_rectangle(A: int, B: int, C: int, D: int) -&gt; int: # Define quantum circuit with 3 qubits and 1 classical bit qr = QuantumRegister(3) cr = ClassicalRegister(1) qc = QuantumCircuit(qr, cr) # Encode the input integers into the state of the first 2 qubits using amplitude encoding alpha = math.acos(math.sqrt(A/float(A**2 + B**2))) beta = math.acos(math.sqrt(B/float(A**2 + B**2))) qc.ry(2*alpha, qr[0]) qc.ry(2*beta, qr[1]) gamma = math.acos(math.sqrt(C/float(C**2 + D**2))) delta = math.acos(math.sqrt(D/float(C**2 + D**2))) qc.ry(2*gamma, qr[2]) qc.ry(2*delta, qr[1]) # Apply a series of SWAP gates to create the entangled state needed for the swap test qc.cx(qr[1], qr[2]) qc.cx(qr[0], qr[1]) qc.cx(qr[1], qr[2]) qc.cx(qr[0], qr[1]) qc.cx(qr[1], qr[2]) # Apply the swap test to determine if the input integers satisfy any of the conditions qc.h(qr[2]) qc.cx(qr[2], qr[1]) qc.h(qr[2]) # Measure the third qubit and return the measurement result as the output of the function qc.measure(qr[2], cr[0]) # Run the quantum circuit using the Qiskit simulator simulator = Aer.get_backend('qasm_simulator') result = execute(qc, simulator, shots=1).result() counts = result.get_counts() if '1' in counts: return 1 else: return 0```",<qiskit><quantum-gate><programming><algorithm><quantum-circuit>,2/19/2023 10:00,30289.0,30289.0,"I think you may want to change a few things. I've coded up the experiment like this (which should be easy to port to Qiskit and/or use it to correct your circuit): First - the function signature, the hopefully identical sides should be a1 and a2, as well a b1 and b2. For experimentation, use values in the range of 0.0 - 1.0: def run_experiment(a1: np.complexfloating, a2: np.complexfloating, b1: np.complexfloating, b2: np.complexfloating) -&gt; float: &quot;&quot;&quot;Construct swap test circuit and measure.&quot;&quot;&quot; # The swap circuit is quite simple: # # |0&gt; --- H --- o --- H --- Measure # | # a1 --------- x --------- # | # a2 ----------x --------- Create a circuit and a few registers, 1 register for each side (I use 2 registers of size 2 below) as well as 2 ancillas: qc = circuit.qc() ab = qc.reg(2, 0) cd = qc.reg(2, 0) anc = qc.reg(2, 0) Now encode the length into rotations on each of the 4 qubits corresponding to the 4 sides: qc.ry(ab[0], 2 * np.arcsin(a1)) qc.ry(ab[1], 2 * np.arcsin(a2)) qc.ry(cd[0], 2 * np.arcsin(b1)) qc.ry(cd[1], 2 * np.arcsin(b2)) Now, 2 swap tests (from anc[0] and anc[1] to the qubits corresponding to the sides, bracketed by Hadamards: qc.h(anc) qc.cswap(anc[0], ab[0], ab[1]) qc.cswap(anc[1], cd[0], cd[1]) qc.h(anc) Now - measurement. In my infra I can just get the probabilities of the ancillas. If the sides were identical, the corresponding probability will be 1.0. If the sides were, for example, maximally different as 0.0 and 1.0, the probability would be 0.5: p0_ab, _ = ops.Measure(qc.psi, anc[0], 0, collapse=False) p0_cd, _ = ops.Measure(qc.psi, anc[1], 0, collapse=False) print(f'a1: {a1:.3f} a1: {a2:.3f} b1: {b1:.3f} b2: {b2:.3f}') print(f'p0_ab: {p0_ab:.2f} p0_cd: {p0_cd:.2f} ') And to test: def main(argv): if len(argv) &gt; 1: raise app.UsageError('Too many command-line arguments.') run_experiment(1.0, 1.0, 0.5, 0.5) &gt;&gt; a1: 1.000 a1: 1.000 b1: 0.500 b2: 0.500 p0_ab: 1.00 p0_cd: 1.00 Or run_experiment(0.5, 0.6, 0.2, 0.6) &gt;&gt; a1: 0.500 a1: 0.600 b1: 0.200 b2: 0.600 p0_ab: 0.99 p0_cd: 0.91 ```",2/20/2023 4:52
32505.0,pytket compiler pass to shorten all angles by multiples of 2 pi,"After applying some compiler passes in pytket, I get gates like rx(3.5*pi). Is there a pass that simply shortens the angles by multiples of 2 pi, so that I get rx(1.5*pi) instead?",<programming><pytket>,05/09/2023 13:42,32533.0,32533.0,"Based on Callums feedback I wrote a function for a CustomPass. def shorten_rotations(circ: Circuit) -&gt; Circuit: circ_prime = Circuit(circ.n_qubits, circ.n_bits) for cmd in circ.get_commands(): if cmd.op.type in (OpType.Rx, OpType.Ry, OpType.Rz): params_prime = cmd.op.params params_prime[0] = params_prime[0] % 2 circ_prime.add_gate(cmd.op.type, params_prime, cmd.qubits) elif cmd.op.type == OpType.Measure: circ_prime.Measure(cmd.qubits[0].index[0], cmd.bits[0].index[0]) else: circ_prime.add_gate(cmd.op.type, cmd.op.params, cmd.qubits) return circ_prime",05/11/2023 10:04
32684.0,qiskit textbook code throws RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment,"I am trying to run the quantum communication algorithm from qiskit textbook &quot;Entangled States&quot; using my IBM API key, however, it throws the error RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment.. What am I doing wrong? This is my code: service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY]) backend = service.least_busy(simulator=False, operational=True) print(f'Running on {backend}') qc_charlie = QuantumCircuit(2,2) qc_charlie.h(1) qc_charlie.cx(1,0) MESSAGE = '01' qc_alice = QuantumCircuit(2,2) if MESSAGE[-2]=='1': qc_alice.z(1) if MESSAGE[-1]=='1': qc_alice.x(1) qc_bob = QuantumCircuit(2,2) # Bob disentangles qc_bob.cx(1,0) qc_bob.h(1) # Then measures qc_bob.measure([0,1],[0,1]) complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob)) backend.run(complete_qc).result().get_counts() I know the API works since I get Running on &lt;IBMBackend('ibmq_belem')&gt; and the circuit is ok as i can see it using qc_charlie.draw(), qc_alice.draw() and qc_bob.draw().",<qiskit><programming>,5/22/2023 20:48,32696.0,32696.0,"You need to use a Session object and the Sampler import qiskit from qiskit import QuantumCircuit from qiskit_ibm_runtime import QiskitRuntimeService from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY]) backend = service.least_busy(simulator=False, operational=True) print(f'Running on {backend.name}') qc_charlie = QuantumCircuit(2,2) qc_charlie.h(1) qc_charlie.cx(1,0) MESSAGE = '01' qc_alice = QuantumCircuit(2,2) if MESSAGE[-2]=='1': qc_alice.z(1) if MESSAGE[-1]=='1': qc_alice.x(1) qc_bob = QuantumCircuit(2,2) # Bob disentangles qc_bob.cx(1,0) qc_bob.h(1) # Then measures qc_bob.measure([0,1],[0,1]) complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob)) with Session(backend=backend): sampler = Sampler() result = sampler.run(complete_qc).result() print(result.quasi_dists)",5/23/2023 20:20
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system? Below you can see the code idea: q1 = QuantumCircuit(2) q1.save_statevector() # Save initial state q1.h(0) q1.save_statevector() # Save state after Hadamard q1.cx(0, 1) q1.save_statevector() # Save state after CNOT (also a final state) job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024) statevectors = job.result().get_statevector() However, if I were to try and run this, an error occurs upon reaching execute command. If anyone can provide any insight on this, I would be very grateful.",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,20967.0,20967.0,"You can also obtain the states at any point during circuit construction using Statevector, the class from Qiskit's quantum_info module as follows. First, import the Statevector class, from qiskit.quantum_info import Statevector And for your example, the code below will produce all the intermediate states that you want. qc = QuantumCircuit(2) st0 = Statevector.from_instruction(qc) qc.h(0) st1 = Statevector.from_instruction(qc) qc.cnot(0, 1) st2 = Statevector.from_instruction(qc) print(st0) print(st1) print(st2) Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0.70710678+0.j, 0. +0.j, 0. +0.j], dims=(2, 2)) Statevector([0.70710678+0.j, 0. +0.j, 0. +0.j, 0.70710678+0.j], dims=(2, 2))",8/25/2021 13:41
34065.0,Create qnode with density matrix on pennylane,"I'm using pennylane. What I want to do is Create a qnode with the 2*2 density matrix of a single qubit one. It has the parameter as phi Given density matrix: $$\frac{1}{\gamma\cos(\varphi)+(\gamma-2)\mathrm{e}^{\frac{t}{t_2}}}\begin{pmatrix}(\gamma-1)\left(\mathrm{e}^{\frac{t}{t_2}}+\cos(\varphi)\right)&amp;\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)\\-\mathrm{i}\sqrt{1-\gamma}\sin(\varphi)&amp;\cos(\varphi)-\mathrm{e}^{\frac{t}{t_2}}\end{pmatrix}$$ Pass is to qml.qinfo.classical_fisher(). I want to calculate classical fisher information respect to phi. But the problem is that when I create qnode with density matrix and pass it to qml.qinfo.classical_fisher() it shows the following error: DeviceError: Gate QubitDensityMatrix not supported on device default.qubit.autograd Is there any possible method to define a qnode with a custom density matrix available to use with autograd? I tried to convert it to a state vector but since the density matrix is a mixed state it can't be converted to state vector. Here is my code: import pennylane as qml from pennylane import numpy as np t1, t2, gamma = 1, 1, 0.5 # Define the density matrix def rho_ps(phi): density_matrix_ps = np.array([ [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)], [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2)) return density_matrix_ps n_wires = 1 dev = qml.device(&quot;default.qubit&quot;, wires=n_wires) # Define the qnode with density matrix @qml.qnode(dev) def circ(params): density_matrix = rho_ps(params) qml.QubitDensityMatrix(density_matrix, wires=0) # Initialize the qubit with the density matrix return qml.expval(qml.PauliZ(0)) # Generate parameters used in classical fisher information params = np.array([np.pi]) CFIM = qml.qinfo.classical_fisher(circ) print(CFIM) ```",<density-matrix><pennylane><programming><quantum-fisher-information>,09/07/2023 08:53,34095.0,34095.0,"My previous answer mistakenly read quantum_fisher instead of classical_fisher. It is actually possible to compute the latter with mixed states, but not the former. It seems that there are three problems in your code: The device you use should be default.mixed, since the density matrix you care about is mixed. params should be differentiable, and should thus be created with requires_grad=True CFIM must be called on params, as it's a function All in all, the following code gives you what you want (If I'm not mistaken): import pennylane as qml from pennylane import numpy as np t1, t2, gamma = 1, 1, 0.5 # Define the density matrix def rho_ps(phi): density_matrix_ps = np.array([ [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)], [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2)) return density_matrix_ps dev = qml.device(&quot;default.mixed&quot;, wires=[0]) @qml.qnode(dev) def circ(params): density_matrix = rho_ps(params) qml.QubitDensityMatrix(density_matrix, wires=0) return qml.expval(qml.PauliZ(0)) params = np.array([np.pi], requires_grad=True) CFIM = qml.qinfo.transforms.classical_fisher(circ) print(CFIM(params))",09/09/2023 10:08
34599.0,Converting a dictionary to a statevector in Qiskit,"Suppose we have a dictionary of computational basis states and their amplitudes: {'01':0.5, '10':0.5, '11':0.5, '00':0.5} How do I convert this (or any arbitrary dictionary) into a Statevector object? In this case the statevector should be is $$ | \psi \rangle = \frac{|00 \rangle + |01 \rangle + |10 \rangle + |11 \rangle}{2} $$",<qiskit><programming>,10/25/2023 15:40,34602.0,34602.0,"I don't think there a built-in functionality for this in Qiskit. However, it is easy to implement. The below code snippet shows how to do that: from qiskit.quantum_info import Statevector import numpy as np _state = {'01':0.5, '10':0.5, '11':0.5, '00':0.5} # Convert dictionary into array: num_qubits = len(next(iter(_state))) data = np.zeros(2 ** num_qubits) for key in _state: data[int(key, 2)] = _state[key] psi = Statevector(data) # Check: psi.draw('latex') Note that, it is not a production-quality code. For example, there is an implicit assumption that all the dictionary keys have the same length.",10/25/2023 15:58
34771.0,Why are quantum computing networks so far behind classical methods?,"I'm new to quantum computing, and computing in general, but it seems like quantum computing networks are really lagging behind what we have achieved with classical networks. I know that there are limitations, such as the need for quantum repeaters, as quantum information can not be cloned, but I have also seen that designs for such repeaters have been created. I was wondering why, if these limitations can be surpassed, has no global quantum computing network been created?",<classical-computing><quantum-networks>,11/08/2023 22:07,34799.0,34799.0,Quantum communication is a field where theory is far beyond experiment. Entanglement theory lies at the heart of computational complexity and entanglement is what really separates quantum mechanics from classical physics. To create a highly entangled state and keep it free from noise is the main problem of building a quantum computer and also of building a quantum network. Given that most quantum networks are represented by a graph state which is also a resource for universal quantum computation your question is equal to &quot;Why cannot we build a decent fault tolerant quantum computer while we can build classical computers with billions of bits?&quot; The problem is error correction again and it is far easier to error correct qubits in a quantum computer where you have all qubits lying close to each other when compared to a highly entangled graph state where you need to keep entanglement in the presence of thermal noise while sending the individual qubits over long distances.,11/10/2023 18:03
34896.0,If_test() - Dynamic Circuits in qiskit,"I am trying to run a dynamic circuit by having mid-measurement in my code as follows: from qiskit import * from math import * from qiskit.providers.fake_provider import FakeJakarta backend = FakeJakarta() q0 = QuantumRegister(1) q1 = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q0, q1, c) result_ = [] for i in range(2): qc.ry(2*pi/3, q0) qc.cx(q0, q1) qc.h(q1) qc.measure(q1, c[i]) with qc.if_test((c[i], 0)) as _else: result_.append(0) with _else: result_.append(1) job = backend.run(qc) print(result_) As it is obvious we must have a result like [0, 1, 0]. However, the list that I receive always is [0, 1, 0, 1]. Does anyone know how to solve this matter?",<qiskit><quantum-gate><programming>,11/17/2023 17:33,34900.0,34900.0,"It appears there's a misunderstanding regarding the use of if_test and _else constructs in your code. In Qiskit, these constructs are for adding conditional quantum operations to the circuit based on classical register states, not for controlling the flow of Python code execution. Consequently, in your loop, both result_.append(0) and result_.append(1) are executed in each iteration, leading to a list that's twice as long as expected. Also, you should only expect a list of length two as your result (not three), as you are measuring with classical bit c[0] in the first iteration, and c[1] in the second iteration. Here's a (potential) version of your code that gathers measurement data from each iteration (if I am correct in interpreting this you want to do): from qiskit import * from math import * from qiskit.providers.fake_provider import FakeJakarta backend = FakeJakarta() q0 = QuantumRegister(1) q1 = QuantumRegister(1) c = ClassicalRegister(2) qc = QuantumCircuit(q0, q1, c) results = [] for i in range(2): qc.ry(2*pi/3, q0) qc.cx(q0, q1) qc.h(q1) qc.measure(q1, c[i]) job = backend.run(qc, shots=1) result = job.result().get_counts(qc) results.append(result) print(results)",11/18/2023 13:49
35470.0,How to avoid azure-quantum ionq simulator computing a probability distribution of exponential size?,"I am running a 3-qubit simulation using ionq.simulator in azure-quantum. When I send the task, I get the result from one shot + probability distribution that includes all the possible 8 bitstrings. I am not interested in getting a probability distribution, just the result from 1 shot. This is a big problem when I try to do 29-qubit simulation, because I cannot even retrieve the results from Azure; the results are 12GB! Here is the 3 qubit example: from azure.quantum.qiskit import AzureQuantumProvider from azure.quantum import Workspace from qiskit import QuantumCircuit workspace = Workspace(resource_id = &quot;&quot;, location = &quot;&quot;) provider = AzureQuantumProvider(workspace) circuit = QuantumCircuit(3, 3) circuit.name = &quot;Qiskit Sample - 3-qubit GHZ circuit&quot; circuit.h(0) circuit.cx(0, 1) circuit.cx(1, 2) circuit.measure([0, 1, 2], [0, 1, 2]) device = provider.get_backend(&quot;ionq.simulator&quot;) job = device.run(circuit, shots=1) res = job.result() The results are: Result(backend_name='ionq.simulator', backend_version='1', qobj_id='Qiskit Sample - 3-qubit GHZ circuit', job_id='...', success=True, results=[ExperimentResult(shots=1, success=True, meas_level=2, data=ExperimentResultData(counts={'000': 1}, probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5})), header=QobjExperimentHeader(qiskit='True', name='Qiskit Sample - 3-qubit GHZ circuit', num_qubits='3', metadata={}, meas_map='[0, 1, 2]'))], date=None, status=None, header=None, error_data=None) The troublesome element for me is probabilities=defaultdict(&lt;class 'int'&gt;, {'000': 0.5, '111': 0.5}) since it grows exponentially with system size for an arbitrary circuit. Then, my question is, how do I avoid Azure computing the probability distribution? Which includes $2^n$ elements, with $n$ being the number of qubits.",<programming><azure-quantum><ionq>,1/13/2024 0:25,35540.0,35540.0,"This is currently unsupported scenario in Azure Quantum. Right now, you always get the complete job results back, which include the probability distribution. (I forwarded your question to the dev team, I think it's an interesting use case to consider.)",1/19/2024 20:28
35765.0,Efficient expectation value of a local operator,"I want to numerically compute something of the form $x=\langle\psi| A\otimes I |\psi\rangle$ where $I$ is the identity. Of course I can construct $A\otimes I$ and take the inner product, but I would like to save memory and compute $x$ without having to construct this large operator. What would be an efficient way to compute $x$ using simple numpy operations (reshape, einsum, trace etc) and without constructing the whole $ A\otimes I$ operator?",<programming>,02/08/2024 20:25,35767.0,35767.0,"I don't know if it's the fastest, but you can use the following subroutine for applying an operation to a subsystem of your state. This code will take an operation that's the correct shape for acting on a subsystem of $|\psi\rangle$ and apply it to that subsystem without having to tensor up to the size of the state space that $|\psi\rangle$ lives in: def mul_on_subsystem(op, state, target_subsystem): # `state` has a tensor shape, e.g. (dim_A, dim_B, dim_C) # make sure `op` is correctly shaped to be applied to the target subsystem! target_dim = state.shape[target_subsystem] assert op.shape == (target_dim, target_dim) # (1) tensordot op onto the target axis of the state # this applies axis 1 of `op` to the target axis of `state` out = np.tensordot(op, state, axes=([1], [target_subsystem])) # (2) rearrange the axes that get scrambled by tensordot out = np.moveaxis(out, 0, target_subsystem) return out Once you've applied $A$ to $|\psi\rangle$ in the way you like, you can compute the inner product in the obvious way, np.dot(state.conj().flatten(), mul_on_subsystem(local_operation, state, target_subsystem).flatten()) This technique also generalizes nicely to density operators, albeit with some very annoying shuffling of axes. Timing/validation/sample code: # declare your subsystem sizes; these are &quot;2&quot; if its qubits... dim_a = 25 # axis 0 dim_b = 25 # axis 1 dim_c = 35 # axis 2 # reshape your state to get it into tensor form (dim_a, dim_b, dim_c) state = np.random.rand(dim_a, dim_b, dim_c) state = state / np.linalg.norm(state) operation_A = np.random.rand(dim_a, dim_a) operation_B = np.random.rand(dim_b, dim_b) operation_C = np.random.rand(dim_c, dim_c) # being generous and not including the time to construct the tensored operation AII = np.kron(operation_A, np.kron(np.eye(dim_b), np.eye(dim_c))) IBI = np.kron(np.eye(dim_a), np.kron(operation_B, np.eye(dim_c))) IIC = np.kron(np.eye(dim_a), np.kron(np.eye(dim_b), operation_C)) for i in range(3): # using mul_on_subsystem local_operation = [operation_A, operation_B, operation_C][i] t0 = time.time() fast = mul_on_subsystem(local_operation, state, i) time_fast = time.time() - t0 # using tensored-up matrices tensored_operation = [AII, IBI, IIC][i] t0 = time.time() slow = np.dot(tensored_operation, state.flatten()) time_slow = time.time() - t0 system = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;][i] print(f&quot;system {system} fast: {time_fast:.5f} s, slow: {time_slow:.5f} s&quot;) np.testing.assert_allclose(fast.flatten(), slow) Output on my laptop system A fast: 0.02700 s, slow: 0.47000 s system B fast: 0.00100 s, slow: 0.21201 s system C fast: 0.00000 s, slow: 0.32400 s",02/08/2024 21:15
35768.0,How to compare the output of statevector_simulator and qasm_simulator in Qiskit,"I am stuck with a very difficult problem. Suppose, I execute a circuit on statevector_simulator, and I get all the values negative. Suppose, now i execute the same circuit on qasm_simulator. I will surely get positive coefficients, because here I will do the square root of the probabilities and probabilities are always positive. Now how should I check the equivalence or correctness? Edit To make my question more clear, am running a small two qubit circuit using qasm simulator and statevector simulator. You will see that results are different and I am not sure how to compare their results. Qasm_Simulator from qiskit import QuantumCircuit, execute from qiskit import IBMQ from qiskit import Aer import numpy as np import matplotlib.pyplot as plt IBMQ.load_account() simulator_used = 'qasm_simulator' circuit = QuantumCircuit(2,2) data = np.array([-0.5, -0.2, -0.2, -0.6]) norm_data = np.linalg.norm(data) normalized_data = data/ norm_data circuit.initialize(normalized_data, [0,1]) circuit.h(0) circuit.cx(0,1) circuit.x(0) circuit.rx(-np.pi/10, 0) circuit.ry(-np.pi/20, 1) circuit.measure([0,1],[0,1]) print(circuit) simulator = Aer.get_backend(simulator_used) job = execute(circuit, simulator, shots=10000) result = job.result() counts = result.get_counts(circuit) final_result = [] for key in counts: final_result.append(np.sqrt(counts[key]/10000)) print(final_result) The result is: IBMQ.load_account() âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ ââââââââââââââââ q_0: â¤0 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) ââ¤Mâ â Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´ââââââââââ¬ââ¬âââââââ¥â q_1: â¤1 âââââââ¤ X ââ¤ Ry(-Ï/20) âââââââ¤Mââââââââ«â ââââââââââââââââââââââââââââââââââââââââââââââââââââ ââââââââââââââââââ ââ¥â â c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ©ââââââââ©â 1 0 [0.6433506042586733, 0.6260990336999411, 0.30016662039607267, 0.322490309931942] Statevector_Simulator from qiskit import QuantumCircuit from qiskit.compiler import transpile from qiskit import IBMQ from qiskit import Aer import numpy as np import matplotlib.pyplot as plt IBMQ.load_account() simulator_used = &quot;statevector_simulator&quot; circuit = QuantumCircuit(2,2) data = np.array([-0.5, -0.2, -0.2, -0.6]) norm_data = np.linalg.norm(data) normalized_data = data/ norm_data circuit.initialize(normalized_data, [0,1]) circuit.h(0) circuit.cx(0,1) circuit.x(0) circuit.rx(-np.pi/10, 0) circuit.ry(-np.pi/20, 1) print(circuit) simulator = Aer.get_backend(simulator_used) result = simulator.run(transpile(circuit, simulator)).result() output_complex = result.get_statevector(circuit) output_real = np.array(np.real(output_complex)) print(&quot;The output real =&quot;, output_real) The result is: IBMQ.load_account() âââââââââââââââââââââââââââââââââââââââââââââââââââââââââ âââââ âââââââââââââ q_0: â¤0 ââ¤ H ââââ âââââââ¤ X ââââââ¤ Rx(-Ï/10) â â Initialize(-0.60193,-0.24077,-0.24077,-0.72232) âââââââââ´âââââââ´ââââ´âââââââââââââââââ q_1: â¤1 âââââââ¤ X ââ¤ Ry(-Ï/20) ââââââââââââââ ââââââââââââââââââââââââââââââââââââââââââââââââââââ ââââââââââââââââââ c: 2/ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ The output real = [ 0.31548377 -0.63950225 -0.27784191 -0.62437088] It would be great if someone can help me in resolving my problem.",<qiskit><programming><quantum-state>,02/08/2024 23:25,35895.0,35895.0,"Your problem is the line output_real = np.array(np.real(output_complex)) You should not be looking at output_real. In order to compare the results of these two simulations, you should instead be looking at the norm of the complex entries of output_complex. You will see that these norms are very close to the values in final_result (the values won't be exactly equal because of randomness in the simulation). Also be careful about the order of the entries in final_result. They should be ordered according to '00', '01', '10', '11', but counts is not always returned in that order. Here is a slim version of your code which gives the expected result from qiskit import QuantumCircuit, execute from qiskit import Aer from numpy import pi, array, sqrt from numpy.linalg import norm data = array([-0.5, -0.2, -0.2, -0.6]) norm_data = norm(data) normalized_data = data / norm_data qasm_sim = Aer.get_backend('qasm_simulator') statevector_sim = Aer.get_backend('statevector_simulator') def create_qc(): qc = QuantumCircuit(2) qc.initialize(normalized_data, [0,1]) qc.h(0) qc.cx(0,1) qc.x(0) qc.rx(-pi/10, 0) qc.ry(-pi/20, 1) return qc # qasm simulator qc = create_qc() qc.measure_all() result = execute(qc, qasm_sim, shots=10000).result() counts = result.get_counts() print('qasm simulator:', [ sqrt(counts['00'] / 10000), sqrt(counts['01'] / 10000), sqrt(counts['10'] / 10000), sqrt(counts['11'] / 10000) ] ) # statevector simulator qc = create_qc() result = execute(qc, statevector_sim).result() v = result.get_statevector() print('statevector simulator', [ norm(v[0]), norm(v[1]), norm(v[2]), norm(v[3]) ] ) A sample output is qasm simulator: [0.3377869150810907, 0.6431174076325411, 0.29274562336608895, 0.6217716622683925] statevector simulator [0.33134439021006384, 0.6414514034928228, 0.29491606277662025, 0.6259197296377109]",2/21/2024 8:18
35930.0,Microsoft Classic QDK simulator,"Is it possible to change the simulator used by the Classic QDK with Python simulation ? It's reported that Classic QDK supports several simulators (sparse, full-state...). Which one is used when called from Python environment, and is it possible to change it? I have a simulation which doesn't run because of large number of qubits instantiated (from 25 up to 61). The simulation with C# .NET runs perfectly. But when I use a Python host program, the simulation is simply blocked at qubit instantiation. So I suppose that C# .NET host uses sparse simulator, while Python uses full-state.",<programming><simulation><q#>,2/23/2024 15:16,35932.0,35932.0,"There are no default simulators chosen either in .NET or in Python, you always specify them explicitly. In C#, you use different classes for different simulators: QuantumSimulator for full state simulator, SparseSimulator for sparse simulator. In Python, you switch the command you use to run Q# operation to use different simulators: .simulate() uses full state simulator, and .simulate_sparse() uses sparse simulator.",2/23/2024 16:45
37300.0,Qiskit code works even without measure_all() with qasm_simulator,"I am need help in understanding about the measure_all() of the qiskit. The below code is correct even though measure_all() is not being used. from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) It would be great if someone can explain about the measure_all() concept, where to use it and where not to use it?",<qiskit><programming>,3/17/2024 7:55,37310.0,37310.0,"You are noticing that measurement behavior is different in different versions of Qiskit. In qiskit==0.33.1, we have the following behavior: import qiskit print(qiskit.__qiskit_version__) {'qiskit-terra': '0.19.1', 'qiskit-aer': '0.9.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.2', 'qiskit-aqua': '0.9.5', 'qiskit': '0.33.1', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None} from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) {'000': 100000} But in the next update qiskit==0.34.0 there is an error: import qiskit print(qiskit.__qiskit_version__) {'qiskit-terra': '0.19.1', 'qiskit-aer': '0.10.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.18.3', 'qiskit-aqua': '0.9.5', 'qiskit': '0.34.0', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None} from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) QiskitError: 'No counts for experiment &quot;&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x1550e7790&gt;&quot;' So your issue is not with the measure_all() concept per say, but rather you just need to keep notes of the versions in which these changes take place. Clarification: It should also be noted that in the qiskit==0.33.1 case, the output {'000': 100000} is reflecting the fact that no measurements have been loaded in to the classical bits (so the values all remain zero). If a measurement statement is included, then this circuit will have GHZ state measurement statistics: from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) circ.measure(range(3), range(3)) # actually measure the circuit backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts) {'000': 50094, '111': 49906}",3/17/2024 19:55
37309.0,vqe.compute_minimum_eigenvalue API of qiskit produces different eigenstate results for statevector_simulator ands qasm_simulator,"I am trying to understand the usage of vqe.compute_minimum_eigenvalue API of qiskit for the statevector_simulator and qasm_simulator. I am only interested in the eigenstate and eigenvalue. When I run the below code for statevector_simulator, I get the below as shown below: backend = Aer.get_backend(&quot;statevector_simulator&quot;) quantum_instance = QuantumInstance(backend= backend, shots= 1 seed_simulator= 28, seed_transpiler= 28, basis_gates= None, optimization_level=0) vqe = VQE(ansatz=ansatz_opt, optimizer= optimizer, quantum_instance=quantum_instance, initial_point=initial_point_values ) result = vqe.compute_minimum_eigenvalue(H_op) print(&quot;The value of result is =&quot;, result) The value of result is: The value of result is = { 'aux_operator_eigenvalues': None, 'cost_function_evals': 1352, 'eigenstate': array([0.01715463+0.42191317j, 0.02261512+0.55615892j, 0.02288142+0.56255103j, 0.01794385+0.44109138j]), 'eigenvalue': (1.2502114e-10+0j), 'optimal_circuit': None, 'optimal_parameters': { ParameterVectorElement(Î¸[3]): 1.8871963979619928, ParameterVectorElement(Î¸[0]): 3.4198843373829284, ParameterVectorElement(Î¸[2]): 4.2904615454665835, ParameterVectorElement(Î¸[1]): 0.8448563317717608, ParameterVectorElement(Î¸[4]): 3.448308970824199, ParameterVectorElement(Î¸[5]): 3.5108928973122078, ParameterVectorElement(Î¸[6]): 4.155936156778078, ParameterVectorElement(Î¸[7]): 5.828853129364108, ParameterVectorElement(Î¸[8]): 2.717512248330424, ParameterVectorElement(Î¸[9]): 1.1104402869985177, ParameterVectorElement(Î¸[10]): 0.35997873578438755, ParameterVectorElement(Î¸[11]): 5.383757228721264, ParameterVectorElement(Î¸[12]): 2.2265588674752292, ParameterVectorElement(Î¸[13]): -0.524391503109095, ParameterVectorElement(Î¸[14]): 2.721212459791864, ParameterVectorElement(Î¸[15]): 1.584924993236795, ParameterVectorElement(Î¸[16]): -0.49539861026959436, ParameterVectorElement(Î¸[17]): 4.162724464416642, ParameterVectorElement(Î¸[18]): 3.6325193273490144, ParameterVectorElement(Î¸[19]): 6.662136048337769}, 'optimal_point': array([ 3.41988434, 0.84485633, 4.29046155, 1.8871964 , 3.44830897, 3.5108929 , 4.15593616, 5.82885313, 2.71751225, 1.11044029, 0.35997874, 5.38375723, 2.22655887, -0.5243915 , 2.72121246, 1.58492499, -0.49539861, 4.16272446, 3.63251933, 6.66213605]), 'optimal_value': 1.2502114e-10, 'optimizer_evals': None, 'optimizer_result': None, 'optimizer_time': 52.66859722137451} But when I run the code for qasm_simulator, I get the results as below: backend = Aer.get_backend(&quot;qasm_simulator&quot;) quantum_instance = QuantumInstance(backend= backend, shots= 1000000 seed_simulator= 28, seed_transpiler= 28, basis_gates= None, optimization_level=0) vqe = VQE(ansatz=ansatz_opt, optimizer= optimizer, quantum_instance=quantum_instance, initial_point=initial_point_values ) result = vqe.compute_minimum_eigenvalue(H_op) print(&quot;The value of result is =&quot;, result) The value of result is The value of result is = { 'aux_operator_eigenvalues': None, 'cost_function_evals': 1, 'eigenstate': { '00': 0.13272528018429647, '01': 0.3030214513858714, '10': 0.7196895163888384, '11': 0.610417070534565}, 'eigenvalue': (5.67387294600939+0j), 'optimal_circuit': None, 'optimal_parameters': { ParameterVectorElement(Î¸[2]): 4.224454970398236, ParameterVectorElement(Î¸[0]): 5.863937784019204, ParameterVectorElement(Î¸[1]): 3.4455864378670014, ParameterVectorElement(Î¸[4]): 0.506017439486799, ParameterVectorElement(Î¸[3]): 2.3690675120103775, ParameterVectorElement(Î¸[5]): 4.79940129981895, ParameterVectorElement(Î¸[6]): 0.09967770119784523, ParameterVectorElement(Î¸[7]): 1.8225430500149276, ParameterVectorElement(Î¸[8]): 1.1087175676599133, ParameterVectorElement(Î¸[9]): 2.650606283797435, ParameterVectorElement(Î¸[10]): 1.932734623597688, ParameterVectorElement(Î¸[11]): 4.6581354731326785, ParameterVectorElement(Î¸[12]): 5.42013877739097, ParameterVectorElement(Î¸[13]): 5.232441413652715, ParameterVectorElement(Î¸[14]): 0.2577507460800755, ParameterVectorElement(Î¸[15]): 3.8652580750273775, ParameterVectorElement(Î¸[16]): 3.133086142322153, ParameterVectorElement(Î¸[17]): 5.98592177389689, ParameterVectorElement(Î¸[18]): 2.0935707919171658, ParameterVectorElement(Î¸[19]): 0.40662390687216604}, 'optimal_point': array([5.86393778, 3.44558644, 4.22445497, 2.36906751, 0.50601744, 4.7994013 , 0.0996777 , 1.82254305, 1.10871757, 2.65060628, 1.93273462, 4.65813547, 5.42013878, 5.23244141, 0.25775075, 3.86525808, 3.13308614, 5.98592177, 2.09357079, 0.40662391]), 'optimal_value': 5.67387294600939, 'optimizer_evals': None, 'optimizer_result': None, 'optimizer_time': 163.65113639831543} What I understand looking at statevector values is that they are coefficients, but these values are not unifying (they are completely different results). I am not able to understand the reason? Is I am doing something wrong? Please guide me. Thank for great help.",<qiskit><programming><vqe>,3/17/2024 18:32,37312.0,37312.0,"Using statevector simulator will give an ideal result for the computation of the operator expectation value. As the state (ansatz) is varied the value computed for any given point will always be the same. This is not the case with the qasm simulator, which samples (shots number of times) from that ideal result for the counts it gives back. The samples are random so the counts can change and this means the expectation value computed can change. You are using a large number of shots but even so, at any given point, the value will still vary. What optimizer are you using - if its a gradient based one like SLSQP small changes can throw it when it tries to compute a gradient at the local point where by default it uses finite difference with a small eps (epsilon) value where it computes the values around the point. You can try a gradient free optimizer like COBYLA, or SPSA which was designed to work in noisy conditions.",3/17/2024 21:05
37384.0,QuTiP ptrace function results do not recreate original composite system,"I have a qutip density matrix fullsystem for a system composed of two quantum systems with dims = [[n, n], [n, n]], shape = (n**2, n**2). It's my understanding that if I wanted the density matrix of each system separately, I could do subsystem1 = fullsystem.ptrace(0) subsystem2 = fullsystem.ptrace(1) Should I not be able to get fullsystem back by doing tensor(subsystem1, subsystem2)? This is not working for me (fullsystem == tensor(subsystem1, subsystem2) gives False), they are close but significantly more different than I'd expect. I have tried tensor(susbsystem1.unit(), subsystem2.unit()) as well. Am I just not understanding how I should be using ptrace? Are there certain assumptions about fullsystem that I need to take into account beyond knowing the two subsystem composition given by dims?",<programming><linear-algebra><qutip>,3/20/2024 22:54,37387.0,37387.0,"This would only work if fullsystem is a product state. Let $\rho$ be your full system. For example, say $$\rho = |011\rangle\langle011|\,.\tag{1}$$ Now, $$\rho_1 = \text{Tr}_{23}\big[\rho\big] = |0\rangle\langle0|\,,\tag{2.1}$$ $$\rho_{23} = \text{Tr}_{1}\big[\rho\big] = |11\rangle\langle11|\,.\tag{2.2}$$ So in this case, $$\rho = \rho_1 \otimes \rho_{23}\,,\tag{3}$$ is true. However, this will not be true if your $\rho$ has entanglement. Let's perform the same analysis programatically using QuTiP. Creating $\rho$: # Define basis states for 3 qubits q0 = basis(2, 0) # |0â© q1 = basis(2, 1) # |1â© psi = tensor(q0, q1, q1) # Example 3-qubit state: |0â© â |1â© â |1â© # Creating a density matrix from the state |0â© â |1â© â |1â© rho = psi * psi.dag() # Print the density matrix print(&quot;Density Matrix:&quot;) print(rho) This gives output: Density Matrix: Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True Qobj data = [[0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0.]] Now, taking the partial trace and computing $\rho_1$ and $\rho_{23}$: # Performing partial trace for the first qubit rho_1 = ptrace(rho, [0]) print(&quot;\nPartial Trace for the first qubit:&quot;) print(rho_1) # Performing partial trace for the second and third qubit rho_23 = ptrace(rho, [1, 2]) print(&quot;\nPartial Trace for the second and third qubit:&quot;) print(rho_23) This gives output: Partial Trace for the first qubit: Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True Qobj data = [[1. 0.] [0. 0.]] Partial Trace for the second and third qubit: Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True Qobj data = [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 1.]] And now, let's check if Eq.$(\text{3})$ holds true or not. rho == tensor(rho_1, rho_23) This gives output: True",3/21/2024 4:35
37405.0,QiskitBackendNotFoundError - Unable to run the backend using BackendEstimator primitive,"I am trying to run a small quantum circuit and generate the expectation value of an observable using the BackendEstimator primitive by incorporating the noise model from Fake20QV1 backend. Below is a snippet of the code. qc = QuantumCircuit(3,3) qc.x(0) qc.x(1) qc.h(2) qc.x(2) qc.measure(range(3), range(3)) observable = SparsePauliOp(&quot;ZZZ&quot;) #qc.draw('mpl') # Get the noise model of Fake20VQ1 backend_fake = Fake20QV1() noise_model = noise.NoiseModel.from_backend(backend_fake) # Get coupling map from backend coupling_map = backend_fake.configuration().coupling_map # Get basis gates from noise model basis_gates = noise_model.basis_gates # Perform a noisy simulation backend = AerSimulator(noise_model=noise_model, coupling_map=coupling_map, basis_gates=basis_gates, shots=1024) transpiled_circuit = transpile(qc, backend) result = backend.run(transpiled_circuit).result() Now, there are two ways in which I tried to run the circuit : Alternative #1 counts = result.get_counts(0) expectation_value = sampled_expectation_value(counts, observable) plot_histogram(counts) expectation_value Runs successfully and gives the expected outputs. Alternative #2 (using BackendSampler and BackendEstimator) with Session(backend=backend_fake): sampler = BackendSampler() estimator = BackendEstimator() result1 = sampler.run(qc).result() print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;) result2 = estimator.run(qc, observable).result() print(f&quot;EV : {result2.values[0]}&quot;) Generates QiskitBackendNotFoundError: 'No backend matches the criteria.' File ~/anaconda3/envs/qem/lib/python3.12/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:779, in QiskitRuntimeService.backend(self, name, instance) 763 &quot;&quot;&quot;Return a single backend matching the specified filtering. 764 765 Args: (...) 776 QiskitBackendNotFoundError: if no backend could be found. 777 &quot;&quot;&quot; 778 # pylint: disable=arguments-differ, line-too-long --&gt; 779 backends = self.backends(name, instance=instance) 780 if not backends: 781 cloud_msg_url = &quot;&quot; ... --&gt; 539 raise QiskitBackendNotFoundError(&quot;No backend matches the criteria.&quot;) 540 if not self._backends[name] or instance_filter != self._backends[name]._instance: 541 self._set_backend_config(name) QiskitBackendNotFoundError: 'No backend matches the criteria.'",<qiskit><programming><ibm-quantum-devices>,3/22/2024 5:33,37407.0,37407.0,"Since Qiskit has been updated, many things have been moved here and there, also the noise model fake backends that you are using. This is how you should run it in accordance with the recently updated Qiskit package. Necessary Imports from qiskit import QuantumCircuit from qiskit.quantum_info import SparsePauliOp from qiskit_aer import AerSimulator from qiskit_ibm_runtime.fake_provider import FakeVigo # fake noisy backends are moved to ibm_runtime, do pip install qiskit-ibm-runtime before from qiskit import transpile from qiskit.result import sampled_expectation_value from qiskit.visualization import plot_histogram from qiskit.primitives import BackendEstimator, BackendSampler Making the Quantum Circuit qc = QuantumCircuit(3,3) qc.x(0) qc.x(1) qc.h(2) qc.x(2) qc.measure(range(3), range(3)) observable = SparsePauliOp(&quot;ZZZ&quot;) qc.draw('mpl',style=&quot;iqp&quot;) Selecting the Noisy Backend and transpiling device_backend = FakeVigo() sim_vigo = AerSimulator.from_backend(device_backend) transpiled_circuit = transpile(qc, sim_vigo) # this step is necessary Running a Noisy Simulation result = sim_vigo.run(transpiled_circuit).result() counts = result.get_counts(0) expectation_value = sampled_expectation_value(counts, observable) expectation_value or getting the plot: plot_histogram(counts) Alternative Method sampler = BackendSampler(backend=sim_vigo) estimator = BackendEstimator(backend=sim_vigo) result1 = sampler.run(qc).result() print(f&quot;Quasi-probability distribution: {result1.quasi_dists[0]}&quot;) result2 = estimator.run(qc, observable).result() print(f&quot;EV : {result2.values[0]}&quot;) You have to specify the backend in the argument of BackendSampler and BackendEstimator. This code will run.",3/22/2024 7:00
37436.0,Quantum Circuit evaluation Qiskit vs. AWS Braket SDK,"I am examining a simple circuit using both Qiskit and the AWS Braket SDK (Python). The circuit is very simple. T : |0|1| q0 : -C-C- | | q1 : -Z-|- | q2 : ---Z- I trying to find the equivalent unitary operator for this circuit. I get different answers from Qiskit and AWS Braket SDK and I don't know why. Here is my Qiskit code: from qiskit import * qr = QuantumRegister(3, 'q') cr = ClassicalRegister(0, 'c') circuit = QuantumCircuit(qr, cr) circuit.cz(qr[0], qr[1]) circuit.cz(qr[0], qr[2]) simulator = Aer.get_backend('unitary_simulator') result = execute(circuit, backend = simulator).result() matprint(result.get_unitary().data) def matprint(mat, fmt=&quot;g&quot;): col_maxes = [max([len((&quot;{:&quot;+fmt+&quot;}&quot;).format(x)) for x in col]) for col in mat.T] for x in mat: for i, y in enumerate(x): print((&quot;{:&quot;+str(col_maxes[i])+fmt+&quot;}&quot;).format(y), end=&quot; &quot;) print(&quot;&quot;) The Qiskit result is: 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j 0+0j 0+0j -0+0j -0+0j -0+0j -1+0j -0+0j -0+0j -0+0j -0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0+0j 0+0j -0+0j -0+0j -0+0j -0+0j -0+0j -1+0j -0+0j -0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 0+0j 1+0j 0+0j 0-0j 0-0j 0-0j 0-0j 0-0j 0-0j 0-0j 1-0j This is what I expected from my hand-calculations. However, when using AWS Braket SDK I get something different. The Braket code: from braket.circuits import Circuit db=Circuit().cz(0,1).cz(0,2) print(db.to_unitary()) The result is: [[ 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j -1.+0.j 0.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j -1.+0.j 0.+0.j] [ 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]] I believe the Qiskit answer is correct because it is consistent with &quot;I kron CZ&quot; for the first operation. If I do &quot;CZ kron I&quot; for the first operation I get the Braket answer. I am new to quantum computing and would find an explanation valuable.",<qiskit><quantum-gate><programming><amazon-braket>,3/24/2024 21:17,37437.0,37437.0,The reason for the difference is that Qiskit and Braket use different endianness for their qubits; Qiskit is little endian: $$ | q_{n - 1} \ldots q_2 q_1 q_0 \rangle $$ while Braket is big-endian: $$ | q_0 q_1 q_2 \ldots q_{n - 1} \rangle $$ You can show this by reversing the endianness of the Qiskit unitary: from qiskit.quantum_info import Operator Operator(circuit).reverse_qargs().to_matrix(),3/24/2024 21:54
38093.0,Quantum circuit not showing when using qiskit with pycharm,"I am trying to run below code in PyCharm: from qiskit.circuit.library import MCXGate, HGate from qiskit import QuantumCircuit circuit = QuantumCircuit(4) circuit.append(HGate(), [0]) circuit.append(MCXGate(3), [0,1,2,3]) circuit.draw('mpl') But I don't see any output circuit. The plot window flashes for a bit but it immediately closes itself. If I use inline figures then I can get the circuit diagram but I want the interactive version. Can someone please help me with this issue. I have always used PyCharm for my other projects so I don't really want to change to another IDE.",<qiskit><programming>,05/02/2024 01:39,38094.0,38094.0,"By default, qiskit draws the quantum circuit for inline visualization (because inline figures are typlically used with jupyter lab). To fix this issue, you need to explicitly use .show() method from matplotlib.pyplot if you are creating the figure from an IDE. So, your code will look something like this: from qiskit.circuit.library import MCXGate, HGate from qiskit import QuantumCircuit import matplotlib.pyplot as plt circuit = QuantumCircuit(4) circuit.append(HGate(), [0]) circuit.append(MCXGate(3), [0,1,2,3]) circuit.draw('mpl') plt.show() # Add this line Hope this helps!",05/02/2024 02:38
38132.0,weird negative sign in a state vector in qiskit,"I run the following simple code in qiskit, which get statevector of a quantum circuit. qc = QuantumCircuit(3) qc.initialize( [ 0.0 + 0.0j, sqrt(1 / 3) + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, 0.0 + 0.0j, sqrt(2 / 3) + 0.0j, ] ) qc.cry(pi / 2, 1, 0) # (theta, controlled bit, target bit) print(Statevector(qc)) The output is the following: Statevector([ 0. +0.j, 0.57735027+0.j, 0. +0.j, 0. +0.j, 0. +0.j, 0. +0.j, -0.57735027+0.j, 0.57735027+0.j], dims=(2, 2, 2)) I expected that the sign of |011&gt; = |6&gt; is plus, however it seems minus.... Am I wrong? or What is the problem here? Thank you in advance!",<qiskit><quantum-state><programming>,05/03/2024 20:19,38138.0,38138.0,"We start with the state, $$\sqrt{1/3}|001\rangle + \sqrt{2/3}|111\rangle$$ Then apply $R_y(\pi/2)$ to the first qubit controlled by the second qubit. By linearity, we can calculate the impact of applying this gate to each basis state individually. The basis state $|001\rangle$ will not impacted since the second qubit in state $|0\rangle$. On the other hand, the basis state $|111\rangle$ will be impacted. We have, $$ R_y(\theta) = \left( {\begin{array}{*{20}{c}} \cos(\theta/2)&amp;-\sin(\theta/2) \\ \sin(\theta/2)&amp;\cos(\theta/2) \end{array}} \right) $$ Multiply the state of the first qubit by this matrix when $\theta = \frac{\pi}{2}$, $$\left( {\begin{array}{*{20}{c}} \frac{1}{\sqrt{2}}&amp;\frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}} \end{array}} \right) \left( {\begin{array}{*{20}{c}} 0 \\ 1 \end{array}} \right) = \left( {\begin{array}{*{20}{c}} \frac{-1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{array}} \right)$$ So, the final state will be, $$\frac{\sqrt{3}}{3} |001\rangle- \frac{\sqrt{3}}{3} |110\rangle+\frac{\sqrt{3}}{3} |111\rangle$$",05/04/2024 06:08
1327.0,Quantum memory assisting classical memory,"Consider a classical computer, one making, say, a calculation involving a large amount of data. Would quantum memory allow it to store that information (in the short term) more efficiently, or better handle that quantity of data? My thought would be it isn't possible, due to the advantage of quantum information storage being in the superpositions, and the data from a classical computer being very much not in a superposition, but I'd like to see if this is correct. Either way, citations for further reading would be much appreciated.",<quantum-memory><classical-computing>,3/25/2018 17:45,,,,
1341.0,Why do classical bits perform calculations at a scale that expands linearly and qubits at exponential scale in the number of (qu)bits?,"What does one mean by saying that classical bits perform operations at the scale of $2n$ and quantum computers perform operations at the scale of $2^n$? In both cases, $n$ = Number of bits/qubits.",<speedup><classical-computing>,3/26/2018 10:49,,,,
2177.0,How can I implement an n-bit Toffoli gate?,"I want to create a Toffoli gate controlled by n qubits, and implement it in QISKit. Can this be done? If so, how?",<quantum-gate><programming><qiskit>,5/28/2018 20:50,,,,
2242.0,Composing multiple quantum circuits in single quantum program in Qiskit,"I was wondering if there is a way to compose a program with multiple quantum circuits without having the register reinitialized at $0$ for each circuit. Specifically, I would like run a second quantum circuit after running the first one, as in this example: qp = QuantumProgram() qr = qp.create_quantum_register('qr',2) cr = qp.create_classical_register('cr',2) qc1 = qp.create_circuit('B1',[qr],[cr]) qc1.x(qr) qc1.measure(qr[0], cr[0]) qc1.measure(qr[1], cr[1]) qc2 = qp.create_circuit('B2', [qr], [cr]) qc2.x(qr) qc2.measure(qr[0], cr[0]) qc2.measure(qr[1], cr[1]) #qp.add_circuit('B1', qc1) #qp.add_circuit('B2', qc2) pprint(qp.get_qasms()) result = qp.execute() print(result.get_counts('B1')) print(result.get_counts('B2')) Unfortunately, what I get is the same result for the two runs (i.e. a count of 11 for the B1 and B2 instead of 11 and 00 for the second, as if B2 is run on a completely new state initialized on 00 after B1.",<quantum-algorithms><programming><qiskit>,06/05/2018 14:22,,,,
2444.0,Are we certain that quantum computers are more efficient than classical computers can be built?,I mean are we certain that they will be able to provide us a huge improvements (in some tasks) compared to clasical computers?,<experimental-realization><classical-computing>,6/24/2018 14:31,,,,
2516.0,What classical public key cryptography protocols exist for which hacking is QMA complete or QMA hard?,"Such a public key cryptosystem would be ""quantum safe"" in the sense that quantum computers cannot efficiently solve QMA hard problems.",<complexity-theory><classical-computing><cryptography><qma>,6/29/2018 4:59,,,,
2595.0,"If quantum speed-up is due to the wave-like nature of quantum mechanics, why not just use regular waves?","The intuition I have for why quantum computing can perform better than classical computing is that the wavelike nature of wavefunctions allow you to interfere multiple states of information with a single operation, which theoretically could allow for exponential speedup. But if it really is just constructive interference of complicated states, why not just perform this interference with classical waves? And on that matter, if the figure-of-merit is simply how few steps something can be calculated in, why not start with a complicated dynamical system that has the desired computation embedded in it. (ie, why not just create ""analog simulators"" for specific problems?)",<classical-computing>,07/03/2018 22:06,,,,
3786.0,Quantum SVM Algorithm Error on import,"I am experimenting with some Qiskit ACQUA AI algorithms which require the following import statement: from datasets import * However, import statement is throwing an error: ModuleNotFoundError Traceback (most recent call last) in from datasets import * ModuleNotFoundError: No module named 'datasets' I am unable to determine the package that this import is from. Clearly, Qiskit ACQUA installation doesn't have to all required packages for the algorithm code to run. I asked the question at the IBM QE forum but the traffic on it is very low. I have not had the answer from anyone yet. Any help would be most appreciated!",<quantum-algorithms><programming><qiskit>,7/17/2018 4:45,,,,
3809.0,What is the purpose of the TDG gate in QISKit?,The QISKIT documentation doesn't explain what a TDG gate does and I can't find it anywhere else online.,<programming><qiskit><ibm-q-experience>,7/19/2018 19:03,,,,
4137.0,What is quantum computing vs. what is not quantum computing,"That is to say, what are some common or popular misconceptions about what constitutes quantum computing? and how are those things misconceptions? It could help in explaining to frame this while imagining as if you were explaining for a layperson, such as Sophie (your meek-and-kindly-but-fox-news-informed great-aunt twice-removed), who has asked you out of genuine curiosity after hearing it referenced in passing multiple times on TV, radio, etc. Sophie isn't looking for a career in computing, never-mind quantum computing (She's a darned good seamstress herself), but does grok basic maths and logic despite her technologically simpler lifestyle. Sophie would like to know some mildly political things; such as how and why we fund studies in quantum-computing, why quantum-computing is studied, what we're actually using it for, as well as some mildly technical things; such as why her regular computer isn't &quot;quantum&quot; since it computes &quot;quantities&quot;, how quantum-computers are any faster than her Athlon XP with Windows 2000, why doing things the way we've done them in traditional computing isn't satisfactory by itself, and when she can get that quantum-pocket-calculator that answers her questions before she asks them. Of note: I am not Sophie nor do I have any aunt Sophie (to the best of my knowledge anyways; quantum-aunts notwithstanding!). I asked this question because I've read and heard a lot of random snippets of information on the topic, from which I have my own basic comprehension, but not an understanding which is strongly communicable to other people. Being slightly more computer-informed than other people around am also asked to try and explain the topic of quantum-computing for laypeople. Obviously I'm hardly an ideal teacher on the subject, but truncating conversations on the topic to the likes of &quot;I know its not what you just described but I can't tell you how it's not that&quot; never sits well with me, hence the rather arbitrary framing I offered.",<classical-computing><terminology-and-notation><applications><history>,09/02/2018 09:20,,,,
4185.0,Which programming language is suitable for a beginner?,"I understand there are a lot of programming languages (e.g. Q#, Qiskit, etc.) Which one is suitable for someone that just started learning programming and doesn't know anything about quantum mechanics?",<programming>,09/09/2018 14:08,,,,
4200.0,How to install qiskit in spyder editor?,I am working in Anaconda using spyder editor. Can anyone tell me how to install qiskit in spyder?,<programming><qiskit>,09/11/2018 10:31,,,,
4229.0,Can a stored programming model be applied to a Quantum Computer?,"A stored programming computer model is that where a central memory is used to store both instructions and data that they operate on. Basically all the classical computers of today that follow the von Neumann architecture use the stored programming model. During program execution the CPU reads instructions or data from the RAM and places it in the various registers such as Instruction Register (IR) and other general purpose registers. My question is whether such a stored programming model is applicable to a Quantum Computer or not, since because of the no-cloning theorem it is not possible to clone any arbitrary quantum state. It means that if we have some qubits in some state stored in a memory register then because of the no-cloning theorem the Quantum Computer processor will not be able to read or copy those qubits from the memory to some internal registers.",<architecture><classical-computing><quantum-memory>,9/14/2018 20:41,,,,
4231.0,How to add two integers in Q#?,"I have programmed in C++, but I am interested in writing quantum programs. I have some experience with Microsoft's Q#, and I know about the canonical Shor's and Grover's algorithms. Can anyone tell me how to write a quantum program to add two integers?",<quantum-algorithms><programming><q#>,9/15/2018 4:56,,,,
4244.0,Confusion over tensor products in sympy.physics.quantum.qubit (in Python),"I am working with sympy.physics.quantum.qubit to help teach myself more about quantum computing. I'm confused about how best to simplify two ket expressions that appear to me to be identical. Seems to me that B and C below should be the same: B = Qubit('01') C = TensorProduct(Qubit('0'),Qubit('1')) because their representation is identical, i.e. B.represent() == C.represent() #returns True it feels like they are the same qubit state. So far, so good. But now when I print out B and C I get: print(""B is"", B) B is |01&gt; but print(""C is"", C) C is |0&gt;x|1&gt; My question: Is there some way I could get the Python library to use the output of B and C so that the equivalence between the two would be obvious? Basically, how do I get C to simplify it's output so that it exactly resembles B? Am grateful for any help you could provide.",<programming><linear-algebra>,9/17/2018 22:17,,,,
4270.0,How would one implement a quantum equivalent of a while loop in IBM QISkit?,"I'm writing a simple multiplication algorithm that uses the Quantum Fourier Transform to repetitively add a number (the multiplicand) to itself and decrements another number (the multiplier). The repeated addition process is to be stopped once the multiplier hits the fundamental state (all qubits are in the zero state). Registers a, b, c hold the product, multiplicand and multiplier respectively. Classical register cl is used to store the final result: def multiply(first, second, n, m): a = QuantumRegister(m+n, ""a"") b = QuantumRegister(m+n, ""b"") c = QuantumRegister(m, ""c"") d = QuantumRegister(m, ""d"") cl = ClassicalRegister(m+n, ""cl"") qc = QuantumCircuit(a, b, c, d, cl, name=""qc"") for i in range(0, n): if first[i] == ""1"": qc.x(b[n-(i+1)]) if second[i] == ""1"": qc.x(c[m-(i+1)]) qc.x(d[0]) for i in range(0, m+n): createInputState(qc, a, m+n-(i+1)) for i in range(m): createInputState(qc, c, m-(i+1)) At this point, however, I need to create a while loop of sorts that allows me to add the multiplicand to the accumulator (register a) until register c is in the fundamental state. Unfortunately the only method I could think of was using a for loop with range (0, (value of multiplier)), but I want to find out if there is a more 'quantum' alternative. The while loop would need to have work as below: while (register c is not in the fundamental state): for i in range(0, m+n): evolveQFTState(qc, a, b, m+n-(i+1)) for i in range(0, m): decrement(qc, c, d, m-(i+1)) for i in range(0, m): inverseQFT(qc, c, i) And then we wrap things up: for i in range(0, m+n): inverseQFT(qc, a, i) for i in range(0, m+n): qc.measure(a[i], cl[i]) So, in short, I am looking for a way to implement a set of statments that execute while a given condition holds true, i.e. a quantum register is not in the fundamental state. The problem I face is due to the fact that, to the best of my knowledge, we cannot use classical register bits in if statements, such as below: if c[0] == 0: -------&gt; not possible for QISkit classical register bits #Do something Another approach I tried was to perform the decrement operation in a different quantum circuit, but I got error messages. Note: This is my first question here on QC SE, so please let me know if I have to rephrase it, change it or provide any additional information.",<quantum-gate><programming><qiskit>,9/23/2018 2:43,,,,
4273.0,Where is the problem stored in a quantum computer?,"I am trying to develop a more intuitive understanding of quantum computing -- I suppose Feynman would tell me thatâs impossible! Letâs try: if we are trying to find the minimum of a surface or function, I can picture a grouping of qubits that would somehow consider the whole surface somewhat simultaneously, eventually finding the minimum. (Feel free to correct or improve upon that description, or tell me itâs completely useless.) My question is this: Where is the function specified, in the arrangement or connection of qubits, or in the classical programming of the inputs (and outputs?).",<programming>,9/23/2018 22:28,,,,
4278.0,How can I get the qiskit module,"I have successfully installed qiskit. However, when I try to run a simulation I get the error ""No module named 'qiskit' from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute How can I get or enable this module?",<programming><qiskit>,9/24/2018 9:10,,,,
4283.0,How can I resolve the error QISkit Error: The same provider has already been registered!,"I am writing a small algorithm to multiply two numbers using IBM's QISkit. The code is below: times_shell.py import times first = input(""Enter a number with less than 7 digits."") l1 = len(first) second = input(""Enter another number with less than "" + str(8-l1) + "" digits."") l2 = len(second) if l1 &gt; l2: n = l1 m = l2 else: first, second = second, first n = l2 m = l1 prod = (""0"")*(m+n) while int(second) is not 0: second, prod = times.multiply(first, second, prod, n, m) times.py def multiply(first, second, product, n, m): a = QuantumRegister(m+n, ""a"") #accumulator b = QuantumRegister(m+n, ""b"") #holds multiplicand c = QuantumRegister(m, ""c"") #hold multiplier d = QuantumRegister(m, ""d"") #register with value 1 cl = ClassicalRegister(m+n, ""cl"") #used for final output cl2 = ClassicalRegister(m, ""cl2"") qc = QuantumCircuit(a, b, c, d, cl, cl2, name=""qc"") for i in range(0, m+n): if product[i] == ""1"": qc.x(a[m+n-(i+1)]) for i in range(0, n): if first[i] == ""1"": qc.x(b[n-(i+1)]) for i in range(0, m): if second[i] == ""1"": qc.x(c[m-(i+1)]) qc.x(d[0]) for i in range(0, m+n): createInputState(qc, a, m+n-(i+1), pie) for i in range(m): createInputState(qc, c, m-(i+1), pie) for i in range(0, m+n): evolveQFTState(qc, a, b, m+n-(i+1), pie) for i in range(0, m): decrement(qc, c, d, m-(i+1), pie) for i in range(0, m): inverseQFT(qc, c, i, pie) for i in range(0, m+n): inverseQFT(qc, a, i, pie) for i in range(0, m+n): qc.measure(a[i], cl[i]) for i in range(0, m): qc.measure(c[i], cl2[i]) print(qc.qasm()) register(Qconfig['APItoken'], Qconfig['url']) result = execute(qc, backend='ibmq_qasm_simulator', shots=1024).result() counts = result.get_counts(""qc"") print(counts) output = max(counts.items(), key=operator.itemgetter(1))[0] multiplier, accumulator = str(output).split("" "") print(multiplier) print(accumulator) return multiplier, accumulator When I run it I get an error. The terminal output (the program output and the error) is as follows: Traceback (most recent call last): File ""times_shell.py"", line 18, in &lt;module&gt; second, prod = times.multiply(first, second, prod, n, m) File ""D:\Projects\Quantum_Computing\IBM_Python\times.py"", line 122, in multiply register(Qconfig['APItoken'], Qconfig['url']) File ""C:\Users\ADMIN\AppData\Local\Programs\Python\Python37-32\lib\site- packages\qiskit\wrapper\_wrapper.py"", line 56, in register _DEFAULT_PROVIDER.add_provider(provider) File ""C:\Users\ADMIN\AppData\Local\Programs\Python\Python37-32\lib\site- packages\qiskit\wrapper\defaultqiskitprovider.py"", line 158, in add_provider raise QISKitError(""The same provider has already been registered!"") qiskit._qiskiterror.QISKitError: 'The same provider has already been registered!' I'm not sure what the issue is here. Any help with this issue would be appreciated.",<programming><qiskit>,9/24/2018 16:31,,,,
4301.0,Flying qubits compared with stationary qubits,"In a previous question I asked how stationary bits could be processed by logic gates. I casually mentioned that I could visualize qubits traversing stationary logic gates, and @DaftWullie said âIt might help if you explain how you're visualising the flying qubitâ, and I said to myself âOops, I probably donât have that right at at all!â. I simply visualize Bloch spheres moving in some constrained way from gate to gate, changing their vector angle according to the logic of the gate, with communication between the gates as programmed (like IBM Q makes it appear). If you can correct that image, maybe it would help me understand how stationary qubits (with moving gates?) work as well.",<programming><bloch-sphere>,9/27/2018 8:13,,,,
4402.0,Qiskit SDK problem,"So I am getting this error when I fire the command on Ipython or Jupyter Notebook &lt;ipython-input-14-8c9b14139f9d&gt; in&lt; module&gt;() from qiskit import IBMQ ImportError: cannot import name 'IBMQ' Does anyone know that kinda error? If anyone has experienced such errors while using qiskit, please help here.",<programming><qiskit>,10/15/2018 11:05,,,,
4411.0,How to run algorithms on IBMQ via Qiskit-Aqua?,"I am trying to run an optimization problem on IBMQ. Running the same code on QASM simulator works fine. However, changing only the backend name to IBMQX takes long time. I am aware of the queues although, there is no way to track the status of my job. I have followed the same code structure given on qiskit-aqua partition example tutorial. Any help would be really appreciated. Thanks.",<programming><qiskit><ibm-q-experience><optimization>,10/15/2018 21:23,,,,
4545.0,How can the state $\lvert0\rangle+M^{-1/2}\sum_{j=1}^M\lvert j\rangle$ be generated?,"I was wondering if anybody to help me to generate the following state. It would be preferable if you use only Hadamard, CNOT and T-gates, on $\lceil\log_2(M+1)\rceil$ qubits: $$|\psi\rangle = \frac{1}{\sqrt{2}}\biggl(|0\rangle + \frac{1}{\sqrt{M}}\sum_{j=1}^M|j\rangle\biggr)$$ Assume M is a power of 2 value.",<quantum-algorithms><quantum-gate><programming><circuit-construction><qiskit>,10/26/2018 15:14,,,,
4592.0,Practical example of Grover's algorithm (in Q#),"Is there any real example for Grover's algorithm but with real database (generated from SQL or file)? I download the Q# development kit &amp; its example, there was one call DatabaseSearchExample claim to use Grover's but it technically doesn't have any kind of database. May I ask a code for this if available?",<programming><grovers-algorithm><q#>,11/01/2018 09:07,,,,
4649.0,Is it better to use fewer gates or fewer working qubits?,"I have a script that takes a while to simulate. I can modify it in such a way where I can use fewer qubits at a time, but it will require more iterations of manipulation. I believe this will cut down on simulation time, but does is it worse when running on an actual quantum computer? It will still run in polynomial time, regardless. I am thinking I should go with the fewer qubits and more gates method, since I would free up qubits for others and cut my simulation time, but I would like to know which is technically the better way, computationally.",<quantum-gate><circuit-construction><programming>,11/07/2018 13:06,,,,
4743.0,Is it possible to create controlled gates with an exponent in Cirq?,"Is it possible to create controlled gates with an exponent in Cirq? For example, a controlled $\sqrt Z$ gate.",<programming><quantum-gate><cirq>,11/17/2018 0:32,,,,
4806.0,An algorithm with the Hadamard operator,"My goal in writing this algorithm in Q# was that func would either output (1,2) or (10,20), since the output result can be either One or Zero. However, I sometimes have (1,20) or (10,2) as output. Does anyone know why this happens? operation func () : (Int,Int) { mutable res000 = Zero; mutable int1 = 0; mutable int2 = 0; using (goop = Qubit[1]) { H(goop[0]); set res000 = M(goop[0]); if(res000 == Zero) { set int1 = 1; set int2 = 2; } else { set int1 = 10; set int2 = 20; } ResetAll(goop); } return (int1,int2); } Edit: Here's another bit of information. I also have two projection functions, and I want the projection functions to output func: operation Pr0 (m:Int,n:Int) : Int { return m; } operation Pr1 (m:Int,n:Int) : Int { return n; } operation func () : (Int,Int) { mutable res000 = Zero; mutable int1 = 0; mutable int2 = 0; using (goop = Qubit[1]) { H(goop[0]); set res000 = M(goop[0]); if(res000 == Zero) { set int1 = 1; set int2 = 2; } else { set int1 = 10; set int2 = 20; } ResetAll(goop); } return (int1,int2); } operation testPr1 () : (Int,Int) { return (Pr0(func()),Pr1(func())); } Here are the C# codes: class Driver { static void Main(string[] args) { using (var sim = new QuantumSimulator()) { var res3 = testPr1.Run(sim).Result; Console.WriteLine(res3); } Console.WriteLine(""Press any key to continue...""); Console.ReadKey(); } }",<quantum-algorithms><programming><q#>,11/26/2018 3:36,,,,
4838.0,How to set up Qconfig.py and where is the file?,How to set up Qconfig.py and where is the file? I mean under which folder? Like /anaconda/lib/python3.6/site-packages/qiskit/.,<programming><qiskit>,12/01/2018 23:51,,,,
4994.0,Module BasicAer not found,"After installing qiskit-terra via git (pip install qiskit), all python programs involving the line from qiskit import BasicAer do not run. Example: from qiskit import * q = QuantumRegister(2) c = ClassicalRegister(2) qc = QuantumCircuit(q,c) qc.h(q[0]) &lt;qiskit.extensions.standard.h.HGate object at 0x7f6a146ee7f0&gt; qc.cx(q[0],q[1]) &lt;qiskit.extensions.standard.cx.CnotGate object at 0x7f6a146ee940&gt; qc.measure(q,c) &lt;qiskit.circuit.instructionset.InstructionSet object at 0x7f6a146eea58&gt; backend_sim = Aer.get_backend('qasm_smulator') Traceback (most recent call last): File ""&lt;stdin&gt;"", line 1, in &lt;module&gt; NameError: name 'Aer' is not defined",<programming><qiskit>,12/18/2018 9:46,,,,
5026.0,Qiskit - expand and/or merge registers,"Suppose one of my functions create some ancillary qubits and reset them. Then, another function wants to create a larger number of ancillary qubits. So, I'd like to reuse the first set of qubits and add the difference two them. Is there any efficient way to achieve the goal? def function1(qc): r = 3 ancillas = QuantumRegister(r, 'ancillas') qc.add(sum_q) # use the ancillas return ancillas def function2(qc, partial_ancillas): r = 5 diff = r - len(partial_ancillas) if diff &gt; 0: # something like ancillas = partial_ancillas.add(diff) # or maybe ancillas = partial_ancillas + QuantumRegister(diff) else: ancillas = partial_ancillas return ancillas qc = QuantumCircuit() anc = function1(qc) anc = function2(qc, anc)",<programming><qiskit>,12/20/2018 19:20,,,,
5028.0,Qiskit - Authorization Required error,"When I use Qiskit to do quantum computing, I suffer from a big problem. When running the code,it turns out to be: {""error"":{""name"":""Error"",""status"":401,""message"":""Authorization Required"", ""statusCode"":401,""code"":""AUTHORIZATION_REQUIRED""}} It seems that I failed to authorize my account. I don't know how to get authorization. Can anyone help me?",<programming><qiskit><ibm-q-experience>,12/21/2018 12:52,,,,
5037.0,Programming quantum half adder,"While computing the carry bit [C=0 XOR (AB)] I am unable to compute that AB in Qiskit. I don't whether Toffoli gate is available in Qiskit. So does anyone know how to perform AB, which is basically the AND gate without using the Toffoli gate if it isn't available?",<programming><qiskit><circuit-construction>,12/23/2018 6:49,,,,
5068.0,How do I produce circuit diagrams from a Q# program?,"If I implement an adder operation in Q#, I'd like to see a quantum circuit diagram of what that adder is doing in order to check that it looks right. Is there a built-in way to do this?",<programming><q#>,12/28/2018 23:34,,,,
5073.0,Introspecting quantum circuit execution on Qiskit Aer simulators,Is there any way to get information from intermediate points in the execution of a quantum circuit. This is not possible on real quantum hardware but would be very useful on the Aer simulators for both learning quantum programming and for debugging.,<programming><qiskit><simulation>,12/29/2018 9:16,,,,
5132.0,How can noise on a device be simulated using measured noise parameters?,"The real devices used as backends for Qiskit have calibration data that quantifies errors ($T_1$ and $T_2$, gate fidelities, etc). This can be accessed by, for example from qiskit import IBMQ IBMQ.load_accounts() device = IBMQ.get_backend('ibmq_5_tenerife') properties = device.properties() print( properties.to_dict() ) How can a simulation be performed that takes all of this information into account, and produces a result given a simulation of this noise?",<programming><qiskit><simulation><noise>,01/07/2019 13:17,,,,
5291.0,ImportError: cannot import name 'QuantumProgram' from 'qiskit',"I get below error when I run a code on spyder environment: File C:/MYPYTHON Programs/My Quantum Programs/Shor algo.py, line 4, in from qiskit import QuantumProgram ImportError: cannot import name 'QuantumProgram' from 'qiskit' (C:\Users\gurmo\Anaconda3\envs\Qiskitenv\lib\site-packages\qiskit__init__.py)",<programming><qiskit>,1/28/2019 11:27,,,,
5307.0,QE error: No handlers could be found for logger,"When I run a QASM program on a QE simulator, I get this error. No handlers could be found for logger ""IBMQuantumExperience.IBMQuantumExperience"" What does this mean and how do I fix it?",<programming><ibm-q-experience><qasm>,1/29/2019 19:09,,,,
5340.0,How to create the oracle matrix in Grover's algorithm?,"I'm trying to implement Grover's algorithm in pyQuil, but I'm having trouble creating the oracle matrix given the function $f$, where $f(x)=1$ if $x=w$ and $f(x)=0$ otherwise. In most of the implementations I've seen, either a mysterious oracle function is called or the matrix representation is created using the knowledge of the index, which requires classical computation of all the $f(x)$ values, defeating the purpose of Grover search. Can someone show me exactly how to create in the matrix (in say pyQuil) when writing the algorithm from scratch without classically computing all of the $f(x)$ values?",<quantum-algorithms><programming><grovers-algorithm><pyquil>,1/31/2019 18:35,,,,
5422.0,Qiskit - How do we measure the same single qubit system multiple times while also getting the counts/results after each measurement?,"I am able to apply multiple measurements (2) to the same qubit system. However, I would like to get the counts right after each measurement is executed. I realize that the counts should be the same after every measurement of the same system. I would just like to see empirical proof of the so-called ""repeated measurement principle"" without any evolution of the system. I attempted to write a program which would achieve this, but had no success: import time from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute, IBMQ, Aer from qiskit.backends.ibmq import least_busy from qiskit import compile as q_compile counter = 0 def generate_circuits(num_q): # Create a Quantum Register with 1 qubits. q = QuantumRegister(num_q, 'q') # Create a Classical Register with 1 bits. c = ClassicalRegister(num_q, 'c') # Create a Quantum Circuit qc = QuantumCircuit(q, c) if counter == 0: # Add a H gate on qubit 0, putting this qubit in superposition. qc.h(q[0]) # Add a Measure gate to see the state. qc.measure(q, c) qc.barrier(q) return qc else: qc.measure(q, c) return qc backend = Aer.get_backend('qasm_simulator') qc_gen = generate_circuits(1) qobj = q_compile(qc_gen, backend, shots=1000) job = backend.run(qobj) result = job.result() data = result.get_counts(qc_gen) print(data) counter += 1 qobj = q_compile(qc_gen, backend, shots=1000) job = backend.run(qobj) result = job.result() data = result.get_counts(qc_gen) print(data) which returned: {'0': 489, '1': 511} {'0': 491, '1': 509} Any ideas?",<programming><qiskit><ibm-q-experience>,02/07/2019 22:06,,,,
5489.0,Using parametrised values and 'Symbols' in Cirq,"I'm just wondering how one should go about using parametrised values and the Symbol object that gets resolved at runtime? For example, if I would like to implement the gate $R_x(\theta) = e^{-i\theta/2}$, but would like to leave $\theta$ as a Symbol to be resolved at the end of the simulation, what would be the best way to do this? Thanks in advance for any answers :)",<programming><cirq>,2/14/2019 18:34,,,,
5511.0,"Consistent QISkit error: ""All devices are currently unavailable""","I am attempting to run the following on a remote backend through QISkit: try: import math from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister from qiskit import execute, IBMQ, Aer from qiskit.backends.ibmq import least_busy q = QuantumRegister(1, 'q') c1 = ClassicalRegister(1, 'c1') c2 = ClassicalRegister(1, 'c2') qc1 = QuantumCircuit(q, c1) qc2 = QuantumCircuit(q, c2) qc1.ry(math.pi*0.25, q[0]) qc2.ry(math.pi*0.25, q[0]) qc1.measure(q, c1) qc2.measure(q, c2) backend_sim = Aer.get_backend('qasm_simulator') job_sim1 = execute(qc1, backend_sim) result_sim1 = job_sim1.result() job_sim2 = execute(qc2, backend_sim) result_sim2 = job_sim2.result() print(""simulation one: "", result_sim1) print(result_sim1.get_counts(qc1)) print(""simulation two: "", result_sim2) print(result_sim2.get_counts(qc2)) ibmq_backends = IBMQ.backends() print(""Remote backends: "", ibmq_backends) try: least_busy_device = least_busy(IBMQ.backends(simulator=False)) print(""Running on current least busy device: "", least_busy_device) job_exp = execute(qc, least_busy_device, shots=1024, max_credits=10) result_exp = job_exp.result() print(""experiment: "", result_exp) print(result_exp.get_counts(qc)) except: print(""all devices are unavailable."") except QiskitError as ex: print('an error occurred. Error = {}'.format(ex)) After the local qasm simulator runs, I receive: Remote backends: [] All devices are currently unavailable However, if I run the ""hello_quantum.py"" example given through IBMQ, I am able to access multiple backends and use the ibm_16_melbourne computer. Interestingly, there seems to be an error in this program specifically. Any ideas on what could be going wrong here?",<programming><qiskit><ibm-q-experience>,2/18/2019 3:38,,,,
5532.0,Cannot load account with Qiskit,"I just got started with Qiskit. When I tried to save my account with the API token from IBMQ website, I got the error: warnings.warn('Credentials already present. Set overwrite=True to overwrite.'). Then I set overwrite = True but the warning was still raised and I cannot save the account and connect to the server.",<programming><qiskit>,2/21/2019 6:24,,,,
5586.0,Which quantum computing programming language should I learn?,"Which quantum computing programming language should I learn? What are the benefits of said language? As of Wikipedia, there's quite a bit to choose from. I'm looking to develop end-user applications (when quantum computers become end-user ready).",<programming>,03/01/2019 15:51,,,,
5895.0,Graphing the decoherence of qubits being used to perform an algorithm,"How would I be able to graph the decoherence of qubits being used to perform an algorithm? I'm working with the IBMQ Qiskit framework and I'm trying to write a program that allows me to find the decoherence of qubits. But I do not know if IBMQ has a method to do that. Can anyone help me, or point me the right direction to implement such a thing?",<programming><qiskit><decoherence><ibm-quantum-devices>,04/11/2019 02:18,,,,
5945.0,How to build a quantum circuit representing the Ising Model?,Can someone explain to me how to build a quantum circuit representing the Ising Model? I just want to understand how to represent the Ising Model for the purposes of quantum state label classification.,<programming><circuit-construction><machine-learning>,4/19/2019 18:55,,,,
5979.0,What is the difference in computational power between qubit and bit (transistor)?,"If I use for example 5-qubit IBM-Q quantum computer and we accept the law of quantum parallelism ($n$ qubit = $2^n$ ordinary bits), so does it mean that computational power of this computer is equal to only $2^5 = 32$ bits (transistors)? For example in last Intel core processors â hundreds of millions transistors, so is it right that ordinary processors at this time faster than 5-qubit computer for millions of times?",<experimental-realization><classical-computing><ibm-quantum-devices>,4/25/2019 18:38,,,,
6034.0,Large size of matrices for little outcome,"I am stuck in a dilemma about how to proceed with a quantum computing algorithm that changes the original state of a system to another. Say I have a superposition of all $8$ bit integer values that are stored in the form of a $256\times 256$ matrix $A$. In total I would then need $8+16=24$ qubits to represent the matrix, with the first $8$ qubits representing the value in binary i.e $x\in \{0,1\}^8$ and similarly with index needing $8+8$ qubits. Suppose I write this matrix in a uniform superposition of all the initial states. If I don't want to perform any operation on this matrix; I need to multiply it with a unitary matrix of size $ 2^{24}\times 2^{24}$. Implementing such a huge matrix on classical computers just to do technically nothing seems weird. Does quantum computing just theorize this concept for the future? Is merely writing this sufficient when I use classical methods?",<quantum-algorithms><quantum-state><classical-computing>,05/01/2019 19:32,,,,
6126.0,Implementing piecewise functions on a quantum computer,I am curious about how to do implement functions like $$f(x)=\begin{cases} 2x &amp;\text{if} &amp;0\leq x &lt;0.5 \\ x/2 &amp;\text{if} &amp;0.5\leq x&lt;1 \end{cases}$$ Do we implement this like any other equation on a classical computer? What initial states and assumptions do we need to make for this computation? What gates do we need to use?,<circuit-construction><classical-computing>,05/12/2019 19:23,,,,
6198.0,What exactly makes quantum computers faster than classical computers?,What feature of a quantum algorithm makes it better than its classical counterpart? Are quantum computers faster than classical ones in all respects?,<quantum-algorithms><classical-computing><quantum-advantage>,5/20/2019 8:34,,,,
6295.0,How to run quantum SVM algorithm from Qiskit in real IBM Quantum Computer using IBMQ?,"I'm trying to run QSVM algorithm in IBMQ experience, want to run in one of those real quantum computers. from qiskit import IBMQ IBMQ.load_accounts() print(""Available backends:"") IBMQ.backends() [&lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ(ibm-q, open, main)&gt;, &lt;IBMQBackend('ibmqx4') from IBMQ(ibm-q, open, main)&gt;, &lt;IBMQBackend('ibmqx2') from IBMQ(ibm-q, open, main)&gt;, &lt;IBMQBackend('ibmq_16_melbourne') from IBMQ(ibm-q, open, main)&gt;, &lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ()&gt;] backend = BasicAer.get_backend('ibmq_qasm_simulator') With the BasicAer I realize I'm using IBMQ's simulator and not the actual IBMQ device. if I chose 'ibmq_qasm_simulator', it works!!! device = IBMQ.get_backend('ibmq_16_melbourne') # ibmx4 #Choose a real - device quantum_instance = QuantumInstance(device, shots=100, seed=seed, seed_transpiler=seed) result = qsvm.run(quantum_instance) The above code which is supposed to use real Quantum computer ""ibmq_16_melbourne"" throws me a --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-19-b7c0ec9bc7c4&gt; in &lt;module&gt; 1 ----&gt; 2 result = qsvm.run(quantum_instance) 3 print(""testing success ratio: "", result['testing_accuracy']) 4 end = timer() 5 print(""timedelta: "" , timedelta(seconds=end-start)) /opt/conda/lib/python3.7/site- packages/qiskit/aqua/algorithms/quantum_algorithm.py in run(self, quantum_instance, **kwargs) 62 quantum_instance.set_config(**kwargs) 63 self._quantum_instance = quantum_instance ---&gt; 64 return self._run() 65 66 @abstractmethod /opt/conda/lib/python3.7/site- packages/qiskit/aqua/algorithms/many_sample/qsvm/qsvm.py in _run(self) 306 307 def _run(self): --&gt; 308 return self.instance.run() 309 310 @property /opt/conda/lib/python3.7/site- packages/qiskit/aqua/algorithms/many_sample/qsvm/_qsvm_binary.py in run(self) 127 def run(self): 128 """"""Put the train, test, predict together."""""" --&gt; 129 self.train(self._qalgo.training_dataset[0], self._qalgo.training_dataset[1]) 130 if self._qalgo.test_dataset is not None: 131 self.test(self._qalgo.test_dataset[0], self._qalgo.test_dataset[1]) /opt/conda/lib/python3.7/site- packages/qiskit/aqua/algorithms/many_sample/qsvm/_qsvm_binary.py in train(self, data, labels) 71 """""" 72 scaling = 1.0 if self._qalgo.quantum_instance.is_statevector else None ---&gt; 73 kernel_matrix = self._qalgo.construct_kernel_matrix(data) 74 labels = labels * 2 - 1 # map label from 0 --&gt; -1 and 1 --&gt; 1 75 labels = labels.astype(np.float) /opt/conda/lib/python3.7/site- packages/qiskit/aqua/algorithms/many_sample/qsvm/qsvm.py in construct_kernel_matrix(self, x1_vec, x2_vec, quantum_instance) 243 num_processes=aqua_globals.num_processes) 244 --&gt; 245 results = self.quantum_instance.execute(circuits) 246 247 if logger.isEnabledFor(logging.DEBUG): /opt/conda/lib/python3.7/site-packages/qiskit/aqua/quantum_instance.py in execute(self, circuits, **kwargs) 192 qobjs = compile_circuits(circuits, self._backend, self._backend_config, self._compile_config, self._run_config, 193 show_circuit_summary=self._circuit_summary, circuit_cache=self._circuit_cache, --&gt; 194 **kwargs) 195 196 if self._measurement_error_mitigation_cls is not None: /opt/conda/lib/python3.7/site-packages/qiskit/aqua/utils/run_circuits.py in compile_circuits(circuits, backend, backend_config, compile_config, run_config, show_circuit_summary, circuit_cache, **kwargs) 195 transpiled_sub_circuits = compiler.transpile(sub_circuits, backend, **backend_config, 196 **compile_config) --&gt; 197 qobj = circuit_cache.load_qobj_from_cache(transpiled_sub_circuits, i, run_config=run_config) 198 else: 199 qobj = circuit_cache.load_qobj_from_cache(sub_circuits, i, run_config=run_config) /opt/conda/lib/python3.7/site-packages/qiskit/aqua/utils/circuit_cache.py in load_qobj_from_cache(self, circuits, chunk, run_config) 178 if not hasattr(compiled_gate, 'params') or len(compiled_gate.params) &lt; 1: continue 179 if compiled_gate.name == 'snapshot': continue --&gt; 180 cache_index = self.mappings[chunk][circ_num][gate_num] 181 (uncompiled_gate, regs, _) = raw_gates[cache_index] 182 KeyError: 0 This is my qiskit version via pip: qiskit 0.10.1 qiskit-aer 0.2.0 qiskit-aqua 0.5.0 qiskit-chemistry 0.5.0 qiskit-ibmq-provider 0.2.2 qiskit-ignis 0.1.1 qiskit-terra 0.8.0",<programming><qiskit><ibm-q-experience><machine-learning>,06/01/2019 03:32,,,,
6309.0,Defining qubit operator from scratch,"I'm a beginner with Qiskit and the Python language at all. Here is my question: One of the VQE function arguments is qubit operator (qubitOp). I saw some examples where the qubitOp object was produced by some already existing Qiskit module. For example, in the following fragment: qubitOp, offset = max_cut.get_max_cut_qubitops(w) qubitOp is an Ising Hamiltonian produced from the connection weights matrix. But how can I define the qubitOp entirely by myself, from the very beginning? (My actual goal is to enrich the Ising Hamiltonian with spin's interactions with the external magnetic field). Thanks!",<programming><qiskit><chemistry>,06/03/2019 08:03,,,,
6330.0,Converting a qubit's state to a binary value in Q#,"In Q#, How do I store a qubits state in a binary-based disk / hard drive for use by regular digital programs? Is this even possible?",<quantum-state><experimental-realization><q#>,06/04/2019 19:49,,,,
6357.0,Can't draw figures with Qiskit in Visual Studio,"I'm using Qiskit in Visual Studio 2019. I want to draw quantum circuits, but it only shows their sizes with text instead of figures. The output on the interactive window is like this. &gt;&gt;&gt; from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit ...: import numpy as np ...: %matplotlib inline In [2]: qr = QuantumRegister(1) ...: cr = ClassicalRegister(1) ...: circuit = QuantumCircuit(qr, cr) ...: circuit.h(qr[0]) Out [2]: &lt;qiskit.extensions.standard.h.HGate at 0x2c9b16b8e80&gt; In [3]: circuit.draw(output=""mpl"") Out [3]: &lt;Figure size 240.8x138.46 with 1 Axes&gt; Is there any way to draw circuits correctly, or is it simply that Qiskit doesn't work in Visual Studio? &lt;edited&gt; the qiskit version In [6]: print(qiskit.__version__) 0.8.1",<programming><qiskit>,06/06/2019 11:10,,,,
6362.0,Measurement inconsistency in Qiskit,"I am using Qiskit in an algorithm. In the end, I am measuring exactly a register of 4 qubits but the histograms show states with 5 qubits. This is the code I used: qwc = QuantumCircuit(qnodes, qnodes2, cqnodes, cqnodes2) qwc.measure(qnodes, cnodes) qwc.draw(output=""mpl"") and finally qnodes2 is measured and represented in the plot as states qubits? Any ideas what the problem might be?",<programming><qiskit>,06/06/2019 13:59,,,,
6418.0,Plotting Bloch sphere in QuTiP,"Is there anyone who reproduced the Bloch sphere given in the paper QuTiP: An open-source Python framework for the dynamics of open quantum systems by J. R. Johansson, P. D. Nation, Franco Nori? I am trying to reproduce the Figure 10: Bloch sphere representation of the Landau-Zener transition. The code they used is given in the appendix of the paper. But when I am trying to plot this, I am getting an error: AttributeError: 'numpy.ndarray' object has no attribute 'indices' Can anyone please help me to correct this one to get the exact Bloch sphere plot?",<programming><simulation><bloch-sphere><qutip><open-quantum-systems>,06/12/2019 05:19,,,,
6454.0,Eliminating a term of a superposition state,"Is there a way of eliminating a term of a superposition state? Let's say I have the state $$\frac{1}{\sqrt 2}|00\rangle + \frac{1}{2}|01\rangle + \frac{1}{2}|10\rangle$$ What operation would I do to eliminate the state $|00\rangle$? And be left with only the terms $|01\rangle + |10\rangle$. I'm looking for a general solution, an idea, rather than one specific to this case.",<quantum-algorithms><quantum-state><programming>,6/14/2019 7:59,,,,
6464.0,How to find a common eigenstate of commuting operators?,"I have multiple different operators in matrix form and I need to find their common eigenstates. The challenge is that the common eigenstate is in a superposition of multiple states and isn't just a single eigenvector. Can someone give me an idea of how to do this? How would I figure out what a common eigenstate in the form of a linear combination of vectors is for multiple matrices? For context, I am using Python and NumPy.",<programming><quantum-state>,6/14/2019 20:59,,,,
6510.0,How to represent $|+\rangle$ in Python?,I am using state vectors and operator matrices to test out my knowledge in a Python program. How would I represent the state $|+\rangle$ in Python? I want to then perform several operations in a matrix form on it. I am pretty sure NumPy arrays don't allow for irrational numbers and $|+\rangle$ has a coefficient of $\frac{1}{\sqrt{2}}$ so I am unsure of how to represent this. Should I use fractions? I am new to QC and Python so if anyone has any good suggestions please help out! Thank you!,<quantum-state><programming>,6/19/2019 6:05,,,,
6511.0,How to add states on the Bloch sphere from a master equation?,"Can you please help me to find an answer to this question: I am using qutip for the study of quantum systems. suppose I have calculated the solution of the master equation using the mcsolve function and let it be output = mcsolve(H,psi0,tlist,c_op_list,exp_op_list,ntraj) If I want to plot the expectation value points on the Bloch sphere, I can use b.add_points(output.expect[0], output.expect[1], output.expect[2]) But how can I add the states on the Bloch sphere? I am sorry if there is anything wrong in the way I have asked the question because I am new to the programming.",<programming><bloch-sphere><qutip>,6/19/2019 6:30,,,,
6555.0,Comparing CPU to QPU In terms of processing power,"The current processors are limited by the speed of the electrons but quantum processors take advantage of the properties of subatomic particles. But the question is how to compare the processing power of these two processors. How to compare the processing power of CPU and QPU to solve and calculate mathematical and cryptographical equations? Like an ""Intel Core i9 CPU"" vs ""IBM Q 5 Tenerife QPU""?",<classical-computing><speedup><ibm-quantum-devices>,6/22/2019 2:12,,,,
6662.0,import error :No module named 'qiskit_aqua',I have an error when I use Quantum SVM kernel algorithm from Qiskit aqua. This is my code section with imports: from datasets import * import numpy as np from qiskit_aqua.utils import split_dataset_to_data_and_labels from qiskit_aqua.input import svminput from qiskit_aqua import run_algorithm from qiskit_aqua.utils import split_dataset_to_data_and_labels And here is the error I obtain: ModuleNotFoundError: No module named 'qiskit_aqua',<programming><qiskit><quantum-gate>,07/02/2019 09:32,,,,
6688.0,How does ControlledOnInt in Q# make it Grovers Oracle?,"I have an example with 6 qubits for names and 6 for telephones. I encoded their relation like this: (ControlledOnInt(1, SetRegisterToInt(6, _)))(rnames, rtels); (ControlledOnInt(3, SetRegisterToInt(2, _)))(rnames, rtels); So there are only 2 registers states(tel->name) in a BD with 64 possible states. When I ask the BD for a name from a telephone it works ok, 6 => 2 and 2 => 3 because only in these 2 values (6 and 2) the marked qbit entangled with telephones is One. So the important part is the oracle made with ControlledOnInt, and I need to know how does it, because I have my own Grovers in c++ and I want to know the details to make it, and also to learn what gates it uses and how it multiply the matrices. Thanks",<grovers-algorithm><q#>,07/05/2019 12:17,,,,
6704.0,Encoding Binary Data into Quantum Basis,I am working on implementing a paper on QNNs. I have successfully been able to resize a MNIST digit to be able to meet the size of quantum circuit. But I am not clear of how to convert the resized image into a format that will allow me to use it to apply to this circuit to see how label classification works in this quantum circuit. Any suggestions would be mostly appreciated.,<programming><hamiltonian-simulation><machine-learning>,07/07/2019 21:08,,,,
6719.0,Is it possible to change the oracle in Grover's search to ponderate probabilities in multiple values search?,"If I want to to search 2 values with Grover's algorithm, it outputs the same probability for both that is bigger that the no searched states that have the same lower percent. If I use an oracle matrix with all 1's in the diagonals except on the searched states that are -1. But suppose you are going to find the drink that you want. For example, I like coke 57% , and pepsi 10%, the rest are 1%. If I change the -1 in those two values in the oracle matrix for example to near 1.5 for coke and 0.5 for pepsi, it will output more probability from bigger to lower: coke module 0.57, pepsi module 0.39 and the others randomly to 0.13. So is it possible in real life to do this? I ask because I don't know how I can change it in Q# reflection. /// Reflection `RM` about the marked state. operation ReflectMarked (markedQubit : Qubit) : Unit { R1(PI(), markedQubit); } /// Reflection about the |00â¦0âª state. /// A register of n qubits initially in the |00â¦0âª state. operation ReflectZero (databaseRegister : Qubit[]) : Unit { let nQubits = Length(databaseRegister); for (idxQubit in 0 .. nQubits - 1) { X(databaseRegister[idxQubit]); } Controlled Z(databaseRegister[1 .. nQubits - 1], databaseRegister[0]); for (idxQubit in 0 .. nQubits - 1) { X(databaseRegister[idxQubit]); } }",<quantum-state><grovers-algorithm><q#>,07/09/2019 15:20,,,,
6738.0,Quantum Computing Qiskit - How to read data from classical registers,"from qiskit import * qr = QuantumRegister(3) cr = ClassicalRegister(3) circ = QuantumCircuit(qr,cr) circ.h(qr[0]) circ.h(qr[1]) circ.h(qr[2]) circ.measure(qr,cr) now cr[0] maybe 0 or 1 I want to know or copy its value to another normal variable to use it in my calculation, something like if(cr[0]==0) cr_val=0 else cr_val=1",<programming><qiskit>,07/11/2019 16:26,,,,
6764.0,How to reset classical register on QISKit,"I want to do a feedforward on a quantum circuit using the simulator of Qiskit. For example, measure qubit_1 to bit 1 and do some operator on qubit_2 if the result of measuring qubit_1 is 0 and if the result is 0, then another operator. Then measure qubit 3 and do some operator on qubit_4 if the result of measuring qubit_3 is 1. so far I know that I could use QuantumCurcuit.operator(Quantumregister[index]).c_if(classicalRegister, value) But the condition of c_if is depended on all value of all bit of classical register. I want to do feedforward depend on an individual bit just 0 or 1. I think it is not the right way to solve the issue by adding another addition qubit to be $|0\rangle$ and project it on the classical bit. Just to reset that bit to 0 again this way. So is there any way to reset the classical register?",<programming><qiskit>,7/13/2019 15:03,,,,
6774.0,"The most important quantum question , how to force a superposition qubit to collapses to an exact value?","Note: forcing a superposition qubit to collapses to 1, means cancel the other value 0 to get 1 appear Question details step by step: #If i have two qubits Qr = QuantumRegister(1) qr = QuantumRegister(1) #and two classical registers Cr = ClassicalRegister(1) cr = ClassicalRegister(1) #and one quantum circuit cc = QuantumCircuit(Qr,qr,Cr,cr) #And put Qr in superposition state cc.h(Qr[0]) #And copy Qr to qr cc.cx(Qr[0],qr[0]) # How to force qr[0] to collapses to a certain needed value (say 1) , # and after measuring Qr[0] it gives the same qr[0] value (gives 1 too) ######################################################################### # need to do some tricks to force qr[0] to be 1 # (force it to be 1 by changing the probability of being 1 to high, # not by changing the value of it to 1) # and Qr[0] measuring also gives 1 (without doing any operations to it) # all operations will done to qr[0] only # we can add/use any new registers ######################################################################### # and after measuring , we have to found that Cr[0] == cr[0] == 1 cc.measure(Qr[0],Cr[0]) # Cr==1 cc.measure(qr[0],cr[0]) # cr==1 # who can do it? and how? # or even increasing the probability of getting 1 like 90%:10% instead of 50%:50% Idea (1): when we do h(Qr), it will be in superposition state, it means it can be 0 and changed to 1 at any moment, i need some method to measure the probability of being 1 at this moment, if it is high then i do normal measure to catch it, if it is low, then i loop doing another things and test the probability again until it is changed to high, then we can do normal measure to catch and make it real, we will do this to all qubits one by one till get all our outputs match the known outputs, then our inputs will be the secret inputs that we want to know. . in another words: we want Qr still in superposition but after excute it 1000 shots and measure it,we get 990 times 1 and 10 times 0 or {'0': 10, '1': 990}",<programming><quantum-gate><quantum-algorithms>,7/14/2019 10:01,,,,
6776.0,How call from IBM Q Experience (Jupyter Notebook) cplex,"I have the latest version of cplex (12.9) installed on my computer. I use it very well with Jupyter notebook, but in IBM Q Experience, I did not get way to call it. IBM Q Experience warns me that the cplex is not installed. Any ideas? Many thanks Parfait",<programming><ibm-q-experience>,7/14/2019 11:59,,,,
6819.0,ERROR_RUNNING_JOB with 32 qubit circuit running on ibmq_qasm_simulator backend,"I recently made a quantum circuit that uses 32 qubits and try to run it on IBM Q Experience qasm_simulator backend. But it always ends with ERROR_RUNNING_JOB. When i retrieve the job and display the error, i only got ""The following experiments failed:\n"" without any details. How i can get more information about the error? The following is my qiskit version information: {'qiskit': None, 'qiskit-terra': '0.8.0', 'qiskit-ignis': '0.1.1', 'qiskit-aer': '0.2.0', 'qiskit-ibmq-provider': '0.2.2', 'qiskit-aqua': '0.5.2'} According to @Bram suggestion i run $ pip install qiskit Building wheels for collected packages: qiskit, qiskit-ibmq-provider Building wheel for qiskit (setup.py) ... error Complete output from command /home/userName/anaconda3/envs/quantum/bin/python -u -c ""import setuptools, tokenize;__file__='/tmp/pip-install-kavivdyx/qiskit/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))"" bdist_wheel -d /tmp/pip-wheel-eak_06_d --python-tag cp37: running bdist_wheel ---------------------------------------- Failed building wheel for qiskit Running setup.py clean for qiskit Building wheel for qiskit-ibmq-provider (setup.py) ... done Stored in directory: /home/userName/.cache/pip/wheels/0c/56/e7/b07b4d2f19fd4c5fff7fe334c72eb313fecf04fa693a7c558e Successfully built qiskit-ibmq-provider Failed to build qiskit Installing collected packages: qiskit-terra, qiskit-aer, nest-asyncio, qiskit-ibmq-provider, pyscf, qiskit-chemistry, qiskit, more-itertools Found existing installation: qiskit-terra 0.8.0 Uninstalling qiskit-terra-0.8.0: Successfully uninstalled qiskit-terra-0.8.0 Found existing installation: qiskit-aer 0.2.0 Uninstalling qiskit-aer-0.2.0: Successfully uninstalled qiskit-aer-0.2.0 Found existing installation: qiskit-ibmq-provider 0.2.2 Uninstalling qiskit-ibmq-provider-0.2.2: Successfully uninstalled qiskit-ibmq-provider-0.2.2 Running setup.py install for qiskit ... done Found existing installation: more-itertools 6.0.0 Uninstalling more-itertools-6.0.0: Successfully uninstalled more-itertools-6.0.0 Successfully installed more-itertools-5.0.0 nest-asyncio-1.0.0 pyscf-1.6.2 qiskit-0.11.0 qiskit-aer-0.2.3 qiskit-chemistry-0.5.0 qiskit-ibmq-provider-0.3.0 qiskit-terra-0.8.2 From this output i notice that wheel was failed in build, does that cause any problems? I then run $conda list | grep qiskit qiskit 0.11.0 pypi_0 pypi qiskit-aer 0.2.3 pypi_0 pypi qiskit-aqua 0.5.2 pypi_0 pypi qiskit-chemistry 0.5.0 pypi_0 pypi qiskit-ibmq-provider 0.3.0 pypi_0 pypi qiskit-ignis 0.1.1 pypi_0 pypi qiskit-terra 0.8.2 pypi_0 pypi enter preformatted text here and run the following in IPython console &gt;&gt;import qiskit &gt;&gt;qiskit.__qiskit_version__ Out[2]: {'qiskit': '0.11.0', 'qiskit-terra': '0.8.2', 'qiskit-ignis': '0.1.1', 'qiskit-aer': '0.2.3', 'qiskit-ibmq-provider': '0.3.0', 'qiskit-aqua': '0.5.2'} i will send another job and wait for the result. Edit: The same error , ERROR_RUNNING_JOB, still occur, appear after the above update.",<qiskit><programming><ibm-q-experience>,7/21/2019 5:12,,,,
6832.0,How to integrate Simulaqron on ProjectQ,"I am trying to simulate quantum teleportation on ProjectQ using simulaqron (enabling me to use quantum internet for teleportation) however I am not sure if my approach is right. In the working paper of simulaqron its written that programming via another backend like ProjectQ is very much possible. However when I am testing quantum teleporation I am not getting any output [Alice's code] followed by [Bob's code] from projectq.ops import All, CNOT, H, Measure, Rz, X, Z from projectq import MainEngine from projectq.meta import Dagger, Control from cqc.pythonLib import CQCConnection, qubit import simulaqron def main(): with CQCConnection(""Alice"") as Alice: eng = MainEngine() c1, c2 = create_bell_pair(eng) tel1 = eng.allocate_qubit() Alice.sendQubit((c1, ""Bob"")) H | tel1 CNOT | (tel1, c2) H | tel1 Measure | tel1 Measure | c2 to_print = ""App {}: Measurement outcomes are: a={}, b={}"".format(Alice.name, int(tel1), int(c2)) print(""|"" + ""-"" * (len(to_print) + 2) + ""|"") print(""| "" + to_print + "" |"") print(""|"" + ""-"" * (len(to_print) + 2) + ""|"") # Send corrections to Bob Alice.sendClassical(""Bob"", int(tel1), int(c2)) def create_bell_pair(eng): b1 = eng.allocate_qubit() b2 = eng.allocate_qubit() H | b1 CNOT | (b1, b2) return b1, b2 main() // new file for bob from projectq.ops import All, CNOT, H, Measure, Rz, X, Z from projectq import MainEngine from projectq.meta import Dagger, Control from cqc.pythonLib import CQCConnection, qubit import simulaqron ##################################################################################################### # # main # def main(): # Initialize the connection with CQCConnection(""Bob"") as Bob: # Make an EPR pair with Alice qB=Bob.recvQubit(c1, ""Alice"") # Receive info about corrections data=Bob.recvClassical() message=list(data) a=message[0] b=message[1] # Apply corrections if b==1: X | qB if a==1: Z | qB # Measure qubit Measure | qB to_print=""App {}: Measurement outcome is: {}"".format(Bob.name,int(qB)) print(""|""+""-""*(len(to_print)+2)+""|"") print(""| ""+to_print+"" |"") print(""|""+""-""*(len(to_print)+2)+""|"") ################################################################################################## main()",<programming><teleportation><projectq>,7/22/2019 6:32,,,,
7050.0,Software for Quantum Computing,"From what I read classical computing evolved so quickly because of the funding-applications cycle. Even though the cost to make denser IC's was increasing rapidly, the applications were also getting better and wider so people put lot more money. Thus they were able to scale well with Moore's law. We need to build such a cycle for Quantum computing since it won't happen naturally as we can't expect quantum supremacy to be the first step that draws a ton of money. So I was wondering how could I build applications for NISQ's or any basic few qubit systems practically implemented. For example what is the software that I can help build right now ? What kind of software are people looking for ? What has already been done and what can be done in next year or so ?",<quantum-algorithms><programming><ibm-q-experience><applications><nisq>,8/18/2019 20:42,,,,
7124.0,Qiskit - Renormalize the qubit after measurement,"I have a 2 qubits system, maximally entangled, and I performed measurement on one of the qubit. q = QuantumRegister(2) c = ClassicalRegister(1) qc = QuantumCircuit(q, c) ###create Bell State Qubit######## qc.h(q[1]) qc.cx(q[1],q[0]) ### Perform Measurement ########## qc.measure(q[0],c) job = execute(qc,simulator,shots = 1000) result = job.result() counts = result.get_counts(qc) print(&quot;\nTotal count for 0 and 1 are:&quot;,counts) Before measurement, the state of the 2 qubit is $|00\rangle+|11\rangle/\sqrt{2}$. After obtaining the measurement result, I measured another qubit. I expected the 2nd qubit to collapse to either 1 of the 2 states($|0\rangle$ or $|1\rangle$) after measurement, but the result shows it is still in the superposition state. How do I renormalise the qubit state after measurement? qc.measure(q[1],c) job = execute(qc,simulator,shots=1000) result = job.result() counts = result.get_counts(qc) print(&quot;\n Total count for 0 and 1 are:,counts&quot;)",<programming><qiskit>,8/30/2019 9:28,,,,
7137.0,Qiskit plot_histogram and count not working,"I'm trying to plot a histogram of my code but when I run plot_histogram(results.get_counts(circuit)) it gives me a traceback error. This is what I had before calling the histogram function: -result = execute(circuit, backend = simulator).result() and thereafter when I try to plot it by typing -plot_histogram(results.get_counts(circuit)) it doesn't work.",<qiskit><programming>,8/31/2019 23:21,,,,
7145.0,What is the point of building arithmetic circuits in a quantum computer?,"My question simply is the following: is there any interests in building arithmetic circuits such as adders or multiplier on a quantum computer? I'm asking this because it seems that classical computers are way better at doing arithmetic operations, so even if a quantum algorithm needs to do some arithmetics, wouldn't it be better to let a classical computer handle this part and then return the results to the quantum computer so it can then continue to run the algorithm?",<quantum-algorithms><programming><quantum-advantage>,09/01/2019 16:31,,,,
8221.0,"Overview of Cirq, qiskit, q#, ibmq(circuit board), other",What is the difference between these frameworks or languages? What are the pros and cons of each of these? Do you know any similar framework/platform/language that gives some more advantages?,<qiskit><programming><ibm-q-experience><q#><cirq>,09/11/2019 03:15,,,,
8272.0,Running HHL tutorial on real backend,"I tried to follow the HHL tutorial. Since the 8x8 problem is not realistically simulable (I stopped after a few minutes), I tried to make it run on another backend, starting on the easiest example: params = { 'problem': { 'name': 'linear_system' }, 'algorithm': { 'name': 'HHL' }, 'eigs': { 'expansion_mode': 'suzuki', 'expansion_order': 2, 'name': 'EigsQPE', 'num_ancillae': 3, 'num_time_slices': 50 }, 'reciprocal': { 'name': 'Lookup' } } provider = IBMQ.get_provider(hub='ibm-q') backend = provider.get_backend('ibmq_16_melbourne') matrix = [[1, 0], [0, 2]] vector = [1, 4] params['input'] = { 'name': 'LinearSystemInput', 'matrix': matrix, 'vector': vector } result = run_algorithm(params, backend = backend) print(""solution "", np.round(result['solution'], 5)) If I use run_algorithm(params, backend = BasicAer.get_backend('qasm_simulator')) It take a bit of time (30 seconds) but it works. However with 'ibmq_16_melbourne', it runs without any sign of ever stopping (close to an hour now). It doesn't seem to be queud or something, because it consume 20% of my processor and the quantum-computing.ibm.com page says I have no result pending. I tried to restart everything already. Can you help me and guess what is happening ? Thank you very much Edit 1: I've observed that the circuit generated by Aqua to use HHL on a diagonal matrix of size 2 has a depth of 29 000 . So it explains why the simulation is taking so damn long. This is much much bigger than what it should be. The tutorial (which i was running) says the the depth of the generated circut is 129. (I was running the exact same code). I suppose there was some change in the library after the tutorial was done. So my guess is there is some bug in HHL that makes it create a lagrely oversized circuit.",<programming><qiskit><ibm-q-experience><hhl-algorithm>,9/19/2019 14:14,,,,
8286.0,How do I start as a quantum computing programmer?,How do I learn Q#? What languages should I know prior to learning Q#? How do I get started with quantum computing?,<programming><resource-request><q#>,9/23/2019 2:16,,,,
8300.0,How can we construct a square root of NOT gate in Qiskit and IBMQ circuit composer using universal gates?,I have tried it with decomposing controlled S then conjugating with H gate. But I want to construct it using a minimum number of gates.,<quantum-gate><qiskit><programming>,9/24/2019 4:09,,,,
8428.0,Can quantum computer perform classical computation?,I was going through a paper in which protocol said that the party computes modulo 'd' sum of other party secrets directly. It was not mentioned that the computation is classical. Can I assume that it was done classically? Am I wrong?,<classical-computing>,10/07/2019 04:02,,,,
8441.0,Does a quantum computer have a clock signal and if yes how big is it?,"I think there can't be a computer running software without having a clock signal. A fast classical computer has a clock rate between 4 to 5 GHz. If quantum computers are so much faster they must have a clock rate which is a multiple of this. Is this true? Edit: I started programming Q# and I think I now understand. (For those who want to know). The quantum computer itself does not have a clock rate. But because a quantum computer always has a classical computer connected to it, there is always the clock rate of the classical computer.",<classical-computing>,10/09/2019 16:42,,,,
8460.0,'ERROR: QasmSimulator: Circuit cannot be run using available methods.',"I used the following code. Can anyone say what that error is about? from qiskit.aqua.circuits.gates import mct q = QuantumRegister(32) c = ClassicalRegister(11) qc = QuantumCircuit(q,c) ite = 5 #number of iteration #initialization qc.h(q[0:11]) qc.x(q[22]) qc.h(q[22]) qc.barrier() for i in range(ite): #oracle part ccheck(0,1,11) ccheck(0,2,12) ccheck(0,3,13) ccheck(0,4,14) ccheck(0,5,15) ccheck(0,6,16) ccheck(0,7,17) ccheck(0,8,18) ccheck(0,9,19) ccheck(0,10,20) qc.mct([q[11],q[12],q[13], q[14],q[15],q[16], q[17],q[18],q[19], q[20]], q[29] , [q[21], q[22], q[23], q[24], q[25], q[26], q[27], q[28]], mode='basic') iccheck(0,10,20) iccheck(0,9,19) iccheck(0,8,18) iccheck(0,7,17) iccheck(0,6,16) iccheck(0,5,15) iccheck(0,4,14) iccheck(0,3,13) iccheck(0,2,12) iccheck(0,1,11) qc.barrier() #diffusion part qc.h(q[0:11]) qc.barrier() qc.x(q[0:11]) qc.barrier() qc.h(q[10]) qc.mct([q[0],q[1],q[2], q[3],q[4],q[5], q[6],q[7],q[8], q[9]], q[10] , [q[21], q[22], q[23], q[24], q[25], q[26], q[27], q[28]], mode='basic') qc.h(q[10]) qc.barrier() qc.x(q[0:11]) qc.barrier() qc.h(q[0:11]) qc.barrier() qc.measure(q[0:11], c[0:11]) backend = Aer.get_backend('qasm_simulator') job = execute(qc, backend, shots=10000) result = job.result() count =result.get_counts() print(count) qc.draw(output='mpl') ```",<programming><qiskit>,10/11/2019 04:14,,,,
8484.0,Resources in Spanish to start learning quantum computing and quantum programming (Qiskit),"Iâm starting an engineering degree in computer systems and Iâm starting to get really interested in quantum computing. First of all, I donât know where or how to start and I would really like to learn about this. Second and last I think I have a good level of English but I would really like to give all this information and manuals to my friends and professors so it surely would be awesome to have information in Spanish too.",<programming><qiskit><resource-request>,10/15/2019 3:56,,,,
8493.0,Quantum computer vs. supercomputer performance,"Does anybody have any other comparisons between a universal quantum computer and a classical computer that might shed some light into how their performance compares? Below is what I've been able to come up with, so far. I am an electrical engineer and have been learning about quantum computing for the last year, and I can hardly believe what I read and hear. It is becoming clearer to me, but it's a very difficult subject. Why is there so much fuss about quantum computing? I will attempt here to show that a 19 qubit quantum computer could match the performance of a 200 petaflops IBM supercomputer, and also how its performance improves with more qubits. This discussion assumes that all of these qubits are what are termed 'logical qubits'. That is, they are fully error-corrected and have infinite 'coherence' times. These types of qubits are a LONG way off. Contemporary 2019 qubits are short-lived. First, the state of a quantum computer is defined by a vector of length 2^n complex values where n is the number of qubits in that quantum computer. For example: 1 qubit -> 2 values in the state vector 2 qubits -> 4 values in the state vector 3 qubits -> 8 values in the state vector ... ... 16 qubits -> 65,536 values in the state vector ... ... 100 qubits -> 1,267,650,600,228,229,401,496,703,205,376 values in the state vector ... ... and so on. The square of any one of the values in the state vector list indicates the probability that this particular list number (index) will be observed at the output of the quantum computer when the MEASURE logic gate (see below) is finally applied. To program the quantum computer, a person will apply what are called 'quantum logic gates' or just 'gates' to the system in order to achieve the processing that they desire. Some of the names of the 'gates' are Hadamard, CNOT, Pauli-X, and MEASURE (the last one applied). When a programmer starts to manipulate the quantum computer, the state of the qubits is initialized and the first value in the state vector list is set equal to 'one' and all of the other values are set equal to 'zero'. If the MEASURE gate were applied now then the output would always read 0b0...00000 since the probability of observing that first list number is 100%. The goal of the programmer is usually to apply the necessary quantum logic 'gates' in such a way that the 100% list value moves from list entry number 0b0...00000 to some other list entry number, and that number is what the scientists have been waiting for. Each logic gate takes less than one microsecond to complete, and what each gate does is to modify all of the 2^n current state vector values in order to create (evolve to) the next state vector list. This is equivalent to a 2^n by 2^n matrix multiplied with the 2^n current state vector. This is 2^n * 2^n = 2^2n multiply/accumulate (MAC) operations in one microsecond. A contemporary IBM supercomputer allegedly has 200 petaflops of performance. If we let one FLOP (floating-point operation) equal one MAC (multiply/accumulate) operation then the IBM classical computer can do 200*10^15 MACS/sec * 10^-6 sec = 200*10^9 MACs in one quantum computer gate time. So, equating the quantum computer to the IBM supercomputer's performance (for one quantum gate time): 2^2n = 200*10^9 or n = 18.7 qubits (19 qubits) in order for a quantum computer to match the MAC performance of an IBM 200 petaflop supercomputer. This is really amazing, and assuming that this is generally correct then each additional qubit means a 4x increase in MAC performance. Scientists are talking about applications requiring 500 qubits. It's going to be interesting.",<classical-computing><performance>,10/16/2019 6:09,,,,
8547.0,cirq.Ry complains that it needs one argument,"When I try to put an Ry gate into my circuit in cirq, I get an error saying that it only takes one argument. import cirq import numpy as np q = cirq.LineQubit(0) cirq.Circuit(cirq.Ry(np.pi / 2, q)) TypeError: Ry() takes 1 positional argument but 2 were given",<programming><cirq>,10/22/2019 23:24,,,,
8575.0,"If classical physics emerges in some limit of quantum mechanics, shouldn't there be intermediate classical-quantum computers?","Presumably quantum mechanics really is the way the universe works, and it appears we don't really understand where the boundary between quantum mechanical phenomena like interference end and classical phenomena begin, but presumably it is not a discrete transition but rather a smooth transition from quantum to classical. Therefore, shouldn't there be computers which are intermediate between ""fully quantum"" and ""fully classical"" devices? and might have some intermediate speed-up over fully classical?",<classical-computing><nonclassicality>,10/26/2019 21:12,,,,
8587.0,General mixed integer linear programming problem with quantum computers,"I was wondering if anyone had a sample code for running a general MILP problem. I saw some coding for some very specific problems and I thought they were kind of far away from what we needed. $$ \text{minimize } \, D^TX+E^TY \, \text{ s.t. }\\ AX + BY + C \le 0 \\ x_i \ge 0 \\ y_i \in \mathbb{Z} $$ If anyone has already started generalizations or would like to start I would love to be a part of that. I also tried to get on Slack but was unable to, could anyone help me with that?",<quantum-algorithms><programming><resource-request><optimization>,10/27/2019 23:59,,,,
8589.0,Can Quantum Voting Machine replace Electronic Voting Machine (EVM) in future?,"Some countries like India are using standalone electronic voting machines (EVM) for elections. They are not interconnected, use no power cables (run on battery), no wireless cards and are secure because after every voter votes he can tally his vote by looking at a printed paper slip (on The Voter Verifiable Paper Audit Trail (VVPAT) Unit) which has his/her candidate and party symbol displayed for 7 seconds and no one can take this paper slips out of the machine. If an attack happens on the EVM machine then votes counted on the machine won't get tallied with manual paper slips. Theoretically, we go for quantum voting because classical voting is based on Prime Factorization, Discrete Log Problem which can be broken by Shor's Algorithm. But can quantum voting machines (if developed) have any practical advantage over the EVM?",<classical-computing><applications>,10/28/2019 4:59,,,,
8759.0,How do you pass input to a circuit?,"I've implemented Grover's search algorithm in qiskit, and I'd like to pass in an input to run through the circuit. How is that done?",<programming><qiskit><grovers-algorithm>,11/13/2019 19:24,,,,
8886.0,Intro to quantum computing for programmers,"I'm looking for an entrypoint to learning about quantum computing to which I'm exposed only by popular science articles and some qiskit materials so far. I understand that it's entirely possible that I'm insulated from the underlying math and implementation details, but I'm not interested in that. Considering my background is in classical programming, mostly imperative languages, what's a good book or set of other materials to get me started but with a view to eventually go deep?",<programming><resource-request>,11/21/2019 15:03,,,,
8973.0,Are quantum gates analogous to ASSPs in classical computing?,"After reading some with regard to the quantum computing gates and the comparison to classic gates it seems that the quantum computer, at least for the time being, is not viewed as a programmable element of a ""hardware circuit"" but more as a hardware device that combines functions, as in what is termed in ""classical computing"" ASSP - application-specific signal processors. Is this view right?",<quantum-gate><classical-computing>,11/28/2019 0:47,,,,
8987.0,Couldn't connect to IBMQ server,"When I access IBM Q backend with qiskit code, an error occurs. from qiskit import IBMQ qt = 'xxxxxxxxx' IBMQ.save_account(qt) IBMQ.load_accounts() The error message is as follows: --------------------------------------------------------------------------- JSONDecodeError Traceback (most recent call last) /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/api/utils.py in obtain_token(self, config) 135 response.raise_for_status() --&gt; 136 self.data_credentials = response.json() 137 except (requests.HTTPError, ValueError) as ex: /usr/local/oss/anaconda3/lib/python3.6/site-packages/requests/models.py in json(self, **kwargs) 896 pass --&gt; 897 return complexjson.loads(self.text, **kwargs) 898 /usr/local/oss/anaconda3/lib/python3.6/json/__init__.py in loads(s, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw) 353 parse_constant is None and object_pairs_hook is None and not kw): --&gt; 354 return _default_decoder.decode(s) 355 if cls is None: /usr/local/oss/anaconda3/lib/python3.6/json/decoder.py in decode(self, s, _w) 338 """""" --&gt; 339 obj, end = self.raw_decode(s, idx=_w(s, 0).end()) 340 end = _w(s, end).end() /usr/local/oss/anaconda3/lib/python3.6/json/decoder.py in raw_decode(self, s, idx) 356 except StopIteration as err: --&gt; 357 raise JSONDecodeError(""Expecting value"", s, err.value) from None 358 return obj, end JSONDecodeError: Expecting value: line 1 column 1 (char 0) During handling of the above exception, another exception occurred: ApiError Traceback (most recent call last) /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqsingleprovider.py in _authenticate(cls, credentials) 94 ---&gt; 95 def _discover_remote_backends(self): 96 """"""Return the remote backends available. /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/api/ibmqconnector.py in __init__(self, token, config, verify) 103 self.req = Request(token, config=config, verify=verify) --&gt; 104 105 def _check_backend(self, backend_name): /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/api/utils.py in __init__(self, token, config, verify, retries, timeout_interval) 216 proxy_urls=self.proxy_urls, --&gt; 217 ntlm_credentials=self.ntlm_credentials) 218 /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/api/utils.py in __init__(self, token, config, verify, proxy_urls, ntlm_credentials) 67 if token: ---&gt; 68 self.obtain_token(config=self.config) 69 else: /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/api/utils.py in obtain_token(self, config) 137 except (requests.HTTPError, ValueError) as ex: --&gt; 138 raise ApiError('error during login: %s' % str(ex)) 139 ApiError: error during login: Expecting value: line 1 column 1 (char 0) The above exception was the direct cause of the following exception: ConnectionError Traceback (most recent call last) &lt;ipython-input-9-2e30fdf423aa&gt; in &lt;module&gt; 11 IBMQ.stored_accounts() 12 ---&gt; 13 IBMQ.load_accounts() 14 #IBMQ.enable_account(qt) /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqprovider.py in load_accounts(self, **kwargs) 197 198 def disable_accounts(self, **kwargs): --&gt; 199 """"""Disable accounts in the current session, subject to optional filtering. 200 201 The filter kwargs can be `token`, `url`, `hub`, `group`, `project`. /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqprovider.py in _append_account(self, credentials) 277 """""" 278 return all(getattr(credentials, key_, None) == value_ for --&gt; 279 key_, value_ in filter_dict.items()) /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqsingleprovider.py in __init__(self, credentials, ibmq_provider) 50 self.credentials = credentials 51 self._api = self._authenticate(self.credentials) ---&gt; 52 self._ibm_provider = ibmq_provider 53 54 # Populate the list of remote backends. /usr/local/oss/anaconda3/lib/python3.6/site-packages/qiskit/providers/ibmq/ibmqsingleprovider.py in _authenticate(cls, credentials) 101 """""" 102 ret = OrderedDict() --&gt; 103 configs_list = self._api.available_backends() 104 for raw_config in configs_list: 105 try: ConnectionError: Couldn't connect to IBMQ server: error during login: Expecting value: line 1 column 1 (char 0) How can I solve this problem ?",<programming><qiskit><ibm-q-experience>,11/28/2019 21:06,,,,
9012.0,Grover's search for solving TSP,"Consider the modified version of the Traveling Salesman Problem where you are searching for a path of length less than some $k$. We can solve this problem using Grover's search where we encode each one of the possible paths as a quantum state and then search for the ones that have length less than $k$. The oracle for this problem is supposed to add the weights of the edges in the given path, check if the total weight is less than $k$ and output 1 if it is the case. How can one construct an oracle for this problem? Is there a practical implementation? How and where to encode the weights of the edges?",<quantum-algorithms><programming><grovers-algorithm>,12/01/2019 13:35,,,,
9027.0,How to create a q# operation to generate a random number from 1 to max?,I have the following problem: I want to create a q# operation for generating a random integer from 1 to max and return the generated number. What algorithm do I need? What does the q# code look like? I am very new to quantum computing so sorry if this is a simple question!,<quantum-algorithms><programming><q#>,12/02/2019 12:38,,,,
9034.0,How does batching work in the optimizer loop of the VQC algorithm in Qiskit Aqua?,"I've playing around with a binary classification problem with a dataset of size 1000 examples and 5 features. I'm using the VQC algorithm from the Qiskit package the that uses a feature map and a parametrized variational circuit. The algorithm has a .train() ( most examples use run() as well) method that implements the optimization loop to find the optimal parameters of the variational form and accepts as argument a minibatch size parameter. I'm using the SPSA optimizer, how does batching work in this environment? Does it use a batch of examples to estimate the cost and update the parameters after the batch has been processed like in mini-batch stochastic gradient? I've also wanted to execute the learning phase of the VQC on the IBMQ experience platform. Taking into account that most real backend on the IBMQ accept a number of 75 experiments, i.e number of circuits to execute within a submitted job, I've thought that setting mini-batch size to the number of maximum experiments would be reasonable, although I know Aqua handles and manages jobs (splitting, waiting for results) at higher level, so you could set it to any number.",<programming><qiskit>,12/02/2019 16:48,,,,
9067.0,How is a quantum computer programmed?,"After lightly reading into quantum algorithms and the hardware of quantum computers, I subsequently started wondering how a quantum computer is programmed so it executes the desired quantum algorithm correctly. Cornering preliminary knowledge, this is what I know currently: A quantum computer is at the highest level of abstraction controlled by a classical computer. The classical computer processes input data from a user and passes this on to Qubit control- and measuring devices. Next, the qubit control- and measuring devices are able to manipulate and measure the desired qubits. Lastly, the quantum plane which is a partially isolated quantum register that contains all the required qubits. Questions: Would the hardware structure of a quantum computer, that I asserted above, be correct? And how is a classically written quantum code, such as Qiskit, able to instruct the quantum computer to run a certain quantum algorithm (where the algorithm is simply comprised of quantum logic 'gates' that cleverly manipulate the qubits)? PS: I've tried to limit the number of questions and keep the questions coherent.",<quantum-algorithms><programming><experimental-realization>,12/04/2019 22:42,,,,
9152.0,Number of columns mismatch in Qiskit,"So I have the following code qgan = QGAN(real_data, bounds, num_qubits, batch_size, num_epochs, snapshot_dir=None) with num qubits being defined as num_qubits = [2, 2] but it is outputting the following error on the qgan line: operands could not be broadcast together with shapes (9,) (2,) I suspect this is due to the fact that it is currently configured to handle a 2 dimensional data set with two columns but I am attempting to feed a 2 dimensional data set with 9 columns. How do I allow the qgan to support 9 columns?",<qiskit><programming><quantum-algorithms>,12/11/2019 02:05,,,,
9281.0,Is it possible to write a Q# teleportation code which returns a qubit?,Is it possible to write a Q# teleportation code which returns a qubit? Thanks.,<quantum-gate><quantum-state><programming><q#><teleportation>,12/21/2019 18:54,,,,
9302.0,Computing circuit depth in Cirq,"I ran into a problem of how to extract circuit depth from Cirq circuit object. In Cirq circuits consist of a list of Moments. Number of moments is not equal to the circuit depth in general case. I might be missing something, but I looked into documentation and source code and still wasn't able to find it. So, I am wondering if there is a simple way to extract circuit depth? This is one of the main circuit properties, it is very strange why it is not implemented directly. For example in Qiskit there are methods qc.depth() and qc.count_ops(). Thanks!",<quantum-gate><programming><circuit-construction><cirq>,12/23/2019 3:18,,,,
9310.0,Unit testing for quantum programs?,Does unit testing on real quantum computers make sense as any observation in the quantum system can cause the system to loose its superposition state?,<programming><q#>,12/24/2019 6:19,,,,
9478.0,Error during Forest OpenFermion installation,"I tried installing Forest OpenFermion by pip install forestopenfermion and I got the following long error message (cut): Building wheels for collected packages: scipy Building wheel for scipy (setup.py) ... error ERROR: Command errored out with exit status 1: command: /Users/michelle/anaconda/envs/py3/bin/python -u -c 'import sys, setuptools, tokenize; sys.argv[0] = '&quot;'&quot;'/private/var/folders/jl/jdqt56zx7nl6czhgp8qhdwd40000gn/T/pip-install-7odaoj4r/scipy/setup.py'&quot;'&quot;'; __file__='&quot;'&quot;'/private/var/folders/jl/jdqt56zx7nl6czhgp8qhdwd40000gn/T/pip-install-7odaoj4r/scipy/setup.py'&quot;'&quot;';f=getattr(tokenize, '&quot;'&quot;'open'&quot;'&quot;', open)(__file__);code=f.read().replace('&quot;'&quot;'\r\n'&quot;'&quot;', '&quot;'&quot;'\n'&quot;'&quot;');f.close();exec(compile(code, __file__, '&quot;'&quot;'exec'&quot;'&quot;'))' bdist_wheel -d /private/var/folders/jl/jdqt56zx7nl6czhgp8qhdwd40000gn/T/pip-wheel-8zcv76y9 --python-tag cp37 cwd: /private/var/folders/jl/jdqt56zx7nl6czhgp8qhdwd40000gn/T/pip-install-7odaoj4r/scipy/ Complete output (1015 lines): lapack_opt_info: lapack_mkl_info: customize UnixCCompiler FOUND: libraries = ['mkl_rt', 'pthread'] library_dirs = ['/Users/michelle/anaconda/envs/py3/lib'] define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)] include_dirs = ['/Users/michelle/anaconda/envs/py3/include'] FOUND: libraries = ['mkl_rt', 'pthread'] library_dirs = ['/Users/michelle/anaconda/envs/py3/lib'] define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)] include_dirs = ['/Users/michelle/anaconda/envs/py3/include'] Running from scipy source directory. non-existing path in 'scipy/integrate': 'quadpack.h' Splitting linalg.interpolative Fortran source files blas_opt_info: blas_mkl_info: customize UnixCCompiler FOUND: libraries = ['mkl_rt', 'pthread'] library_dirs = ['/Users/michelle/anaconda/envs/py3/lib'] define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)] include_dirs = ['/Users/michelle/anaconda/envs/py3/include'] FOUND: libraries = ['mkl_rt', 'pthread'] library_dirs = ['/Users/michelle/anaconda/envs/py3/lib'] define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)] include_dirs = ['/Users/michelle/anaconda/envs/py3/include'] non-existing path in 'scipy/sparse': 'sparsetools/sparsetools_impl.h' non-existing path in 'scipy/sparse': 'sparsetools/bsr_impl.h' non-existing path in 'scipy/sparse': 'sparsetools/csc_impl.h' non-existing path in 'scipy/sparse': 'sparsetools/csr_impl.h' non-existing path in 'scipy/sparse': 'sparsetools/other_impl.h' running bdist_wheel running build running config_cc unifing config_cc, config, build_clib, build_ext, build commands --compiler options running config_fc unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options running build_src build_src building py_modules sources creating build creating build/src.macosx-10.9-x86_64-3.7 creating build/src.macosx-10.9-x86_64-3.7/scipy building library &quot;dfftpack&quot; sources building library &quot;fftpack&quot; sources building library &quot;mach&quot; sources building library &quot;quadpack&quot; sources building library &quot;odepack&quot; sources building library &quot;dop&quot; sources building library &quot;fitpack&quot; sources building library &quot;fwrappers&quot; sources building library &quot;odrpack&quot; sources building library &quot;minpack&quot; sources building library &quot;rootfind&quot; sources building library &quot;superlu_src&quot; sources building library &quot;arpack_scipy&quot; sources building library &quot;sc_c_misc&quot; sources building library &quot;sc_cephes&quot; sources building library &quot;sc_mach&quot; sources building library &quot;sc_amos&quot; sources building library &quot;sc_cdf&quot; sources building library &quot;sc_specfun&quot; sources building library &quot;statlib&quot; sources building extension &quot;scipy.cluster._vq&quot; sources building extension &quot;scipy.cluster._hierarchy&quot; sources building extension &quot;scipy.fftpack._fftpack&quot; sources creating build/src.macosx-10.9-x86_64-3.7/scipy/fftpack creating build/src.macosx-10.9-x86_64-3.7/scipy/fftpack/src conv_template:&gt; build/src.macosx-10.9-x86_64-3.7/scipy/fftpack/src/dct.c conv_template:&gt; build/src.macosx-10.9-x86_64-3.7/scipy/fftpack/src/dst.c f2py options: [] f2py: scipy/fftpack/fftpack.pyf Reading fortran codes... Reading file 'scipy/fftpack/fftpack.pyf' (format:free) Line #86 in scipy/fftpack/fftpack.pyf:&quot; /* Single precision version */ &quot; crackline:2: No pattern for line Post-processing... And so on. Can someone please help me? Thanks.",<programming><openfermion><pyquil><rigetti>,01/10/2020 02:37,,,,
9493.0,How to invoke a C# method inside a Q# operation?,Suppose there is a Q# operation as follows: operation Op () : Bool { let result = CSharpMethod (); return result } where CSharpMethod () is a defined method in the Driver class as follows: public static bool CSharpMethod () { // ... // return a boolean value } So my question is how to call a method of a C# class inside a Q# operation and handle its returned value? Thanks.,<programming><q#>,01/11/2020 18:54,,,,
9496.0,Is it possible to create a Q# operation with optional parameters?,In C# it is possible to have: public void Fun (int n = 0){ // ... } then the following method call examples will be compiled: Fun() Fun(10) So I wonder whether or not such a useful facility is available in creating Q# operations with optional parameters?,<programming><q#>,01/12/2020 00:55,,,,
9567.0,Problems with Q# installing,"I don't know if this is the right place to ask this question. I just thought it would be a place where people knew what they are doing. If there is a better place to look for answers (stackoverflow for example), feel free to tell me. The problem is that .NET can't install iqsharp. It says it doesn't recognize the file even though it is in the PATH folder (user/.dotnet/tools). &gt; dotnet iqsharp install Could not execute because the specified command or file was not found. Possible reasons for this include: * You misspelled a built-in dotnet command. * You intended to execute a .NET Core program, but dotnet-iqsharp does not exist. * You intended to run a global tool, but a dotnet-prefixed executable with this name could not be found on the PATH. It shows the same behavior when I want to use other .NET packages. I have dotnet version 3.1.101. I can send dotnet --info if you want. I have looked on github and other websites for solutions but most of the problems were caused by Linux Ubuntu and most of the treads are still open. Thanks for reading and I hope you can help me.",<q#>,1/16/2020 20:44,,,,
9586.0,IBM qiskit vs Microsoft QDK,I am new to both IBM Qiskit and Microsoft QDK. I wish to understand which framework would be best suited for someone new to this field. I am lookig for the pros and cons of both frameworks.,<programming><qiskit><q#>,1/19/2020 5:49,,,,
9602.0,Can two intrinsic angular momentum directions (spin) be used for future entanglement after collapse?,"Persuant to all contributors, here I will use a coin toss analogy since the vector direction is either up or down (heads or tails). Two coins will be used for each of two tosses. It's assumed that the process will be one-shot (shots=1). Toss one: Superposition will be applied using Hadamard gates on two qubits. Collapse will result in the following possible binary results: [00,01,10,11] (HH,HT,TH,TT). For toss two: Of the four binary results of toss one, I will choose either 00 or 11. I want to know how to prepare two qubits in an entangled state after either 00 or 11 is measured on those two independent qubits prepared with Hadamards in toss one.",<quantum-algorithms><quantum-gate><quantum-state><programming>,1/20/2020 18:20,,,,
9867.0,Decomposition of an arbitrary gate using given matrix in Qiskit,"If I have an arbitrary non-unitary matrix of say $$ U = \begin{pmatrix} 1.5 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1.6 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ \end{pmatrix}, $$ is it possible to decompose it into gates implementable in qiskit? If so, how? If not, why not? Is is possible to have any arbitrary non-unitary matrix as an input and get the corresponding gates that implement this arbitrary matrix?",<quantum-gate><qiskit><programming>,2/14/2020 20:54,,,,
9878.0,How to decompose arbitrary gates in Qiskit?,"I have been exploring quantum computing, I have no idea of decomposing arbitrary gates in Qiskit. Can someone help me with an example?",<quantum-gate><qiskit><programming><quantum-algorithms><entanglement>,2/16/2020 18:58,,,,
9887.0,How to retrieve the parameters of a Q# operation?,How to retrieve the parameters of a Q# operation? Is it possible to do such a thing at all?,<programming><q#>,2/17/2020 17:12,,,,
9900.0,What are the different ways of representing unitary gates in terms of the matrix?,What are the different ways of representing unitary gates in terms of the matrix? In other words what would be the two different matrices which on multiplication give you unitary gate matrix?,<quantum-algorithms><quantum-gate><programming><entanglement>,2/19/2020 4:22,,,,
9940.0,Implementing QFT,"I would like to know if there is a way to: Implement Quantum 'Functions' e.g the QFT of QFT* containing several single-qubit operations? Implement such operations on an arbitrary number of qubits and in the same vein implement work-qubits. Not looking as responsive as pyquil, however, I noticed in the Qiskit documentation that implementing a 'CircuitFactory' with the 'ABC' package seems to be the way to go. I would just appreciate insights from experienced hands. Thank you kindly.",<qiskit><programming>,2/22/2020 2:24,,,,
9961.0,Regarding quantum support vector machine using qiskit,"I would like to ask, how can I add my own .csv data file to run a quantum support vector machine using qiskit ? I don't want to use already existing datasets in sklearn, scikit-learn library.",<qiskit><programming><quantum-enhanced-machine-learning>,2/24/2020 6:35,,,,
9974.0,"How can I implement partial transpose on a variable in Picos (Python, trying to solve an SDP)?","I try to optimise a quantity via an SDP. I optimise over all PPT measurement operators and hence have the constraints $\Pi_k^{T_B} \succeq 0$ (PPT) for my measurement operators. The part of the code where I define the SDP and constraints is: [...] # Defining the SDP p = pic.Problem() pic.new_param(""rho_0"", rho_0) pic.new_param(""rho_1"", rho_1) pic.new_param(""rho_2"", rho_2) # Measurement operators P_0 = p.add_variable(""P_0"", (9,9), ""hermitian"") P_1 = p.add_variable(""P_1"", (9,9), ""hermitian"") P_2 = p.add_variable(""P_2"", (9,9), ""hermitian"") P_inc = p.add_variable(""P_inc"", (9,9), ""hermitian"") # Partial transposes p.add_constraint(PT_B(P_0, 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(P_1, 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(P_2, 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(P_inc, 3, 3) &gt;&gt; 0) [...] where PT_B is a function implementing the partial transpose, i.e. def PT_B(M, d1, d2): """""" Partial Transpose map of M Input: Matrix M, Dimension d1 of subsystem 1, Dimension d2 of subsystem 2 Output: Partial Transpose M_TB """""" assert M.shape == (d1 * d2, d1 * d2) # Reshape into 4 tensor M = M.reshape(d1, d2, d1, d2) # Transpose 2nd system M = M.transpose((0, 3, 2, 1)) # Reshape back into a density matrix return M.reshape(d1 * d2, d1 * d2) However, Picos doesn't let me manipulate the variable expressions. I also tried to implement the partial transpose by setting the elements of a new variable by hand to the elements of $\Pi_k^{T_B}$. But then Picos tells me that I can't slice variable expressions. The error message for the above SDP code snippet I get is: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-38-36083f3fb159&gt; in &lt;module&gt; 12 13 # Partial transposes ---&gt; 14 p.add_constraint(PT_B(P_0, 3, 3) &gt;&gt; 0) 15 p.add_constraint(PT_B(P_1, 3, 3) &gt;&gt; 0) 16 p.add_constraint(PT_B(P_2, 3, 3) &gt;&gt; 0) &lt;ipython-input-34-2327f6ca6850&gt; in PT_B(M, d1, d2) 5 Output: Partial Transpose M_TB 6 """""" ----&gt; 7 assert M.shape == (d1 * d2, d1 * d2) 8 9 # Reshape into 4 tensor AttributeError: 'Variable' object has no attribute 'shape' If I try to force the variable expression into an np.array: [...] # Partial transposes p.add_constraint(PT_B(np.array(P_0), 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(np.array(P_1), 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(np.array(P_2), 3, 3) &gt;&gt; 0) p.add_constraint(PT_B(np.array(P_inc), 3, 3) &gt;&gt; 0) [...] Then I get the error message: --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-39-c6e549dceb23&gt; in &lt;module&gt; 12 13 # Partial transposes ---&gt; 14 p.add_constraint(PT_B(np.array(P_0), 3, 3) &gt;&gt; 0) 15 p.add_constraint(PT_B(P_1, 3, 3) &gt;&gt; 0) 16 p.add_constraint(PT_B(P_2, 3, 3) &gt;&gt; 0) /usr/local/lib/python3.7/site-packages/picos/expressions.py in __getitem__(self, index) 3973 JJ = rangeT 3974 VV = [1.] * nsz -&gt; 3975 newfacs = {self: spmatrix(VV, II, JJ, (nsz, sz))} 3976 if not self.constant is None: 3977 newcons = self.constant[rangeT] /usr/local/lib/python3.7/site-packages/picos/tools.py in spmatrix(*args, **kwargs) 2187 """""" 2188 try: -&gt; 2189 return cvx.spmatrix(*args, **kwargs) 2190 except TypeError as error: 2191 # CVXOPT does not like NumPy's int64 scalar type for indices, so attempt TypeError: dimension too small Does anyone have an idea how to implement the PPT constraint in the SDP in Python? Mathematica doesn't allow complex matrix SDPs, and Picos and CVXPY give me a hard time implementing the PPT constraint. Thanks for any suggestions!",<programming><optimization><semidefinite-programming><partial-transpose>,2/24/2020 17:03,,,,
10016.0,How can I get the entire histogram in a 5 qubit program done in IBM quantum experience machine?,"I have run a program on an IBM quantum experience machine which involves 5 qubits. Obviously when I measure the whole system I have 32 results but the machine only represents 20 in the histogram. In this situation the program tells you to download the results. The problem is that when I pick ""Download PNG"" or ""Download SVG"" it continues to show me a 20 results histogram. There is another option that is to pick ""Download results"" but it downloads two .json documents which I'm not sure I know how to change into a histogram.",<programming><ibm-q-experience>,2/27/2020 10:08,,,,
10023.0,Is there a limited number of features for QSVM in Qiskit-Aqua?,Why do all tutorials that use QSVM from qiskit Aqua library have the number of features equal to 2?,<qiskit><programming>,2/28/2020 9:40,,,,
10154.0,Numerical methods for finding an eigen basis of a degenerate Liouvillian,"I'm trying to find the steady-state of a master equation, $$\dot{\rho}(t) = \mathcal{L}\rho(t),\tag{1}\label{1}$$ In the form where we vectorise the density matrix and matrixify (??) the Liouvillian super operator $\rho$ is a vector representing a state, $\mathcal{L}$ is the Liouvillian, a complex matrix describing the evolution, which is not necessarily symmetric and $\dot{\rho}$ is the rate of change of $\rho$. To find the steady-state we need to set the LHS of the equation to 0 and solve for $\rho$. This is just the eigenvector problem, $(\mathcal{L}-\lambda\pmb{I})\rho=0$ for the case where the eigenvalue, $\lambda=0$. In many systems I am studying the 0 eigenvalue of $\mathcal{L}$ is degenerate so there should be more than one solution for the original master equation. Ideally, we could find a basis for the degenerate subspace (I assume that this subspace of $\mathcal{L}$ is diagonalizable). Qutip has the function steadystate() which, given a system Hamiltonian and some jump operators uses various numerical methods to find the steadystate. I am relatively new to using numerical methods but the systems I am dealing with are large so requires it. I have tried using the GMRES method to solve equation \eqref{1} with $\dot{\rho}=0$ but this only produces a single solution and does not help me find a basis. An alternative approach is to use the function liouvillian() which given the same parameters as steadystate() returns the Liouvillian, L, of the system in matrix form. We can then use L.eigenstate() to find the eigenvectors associated with the zero eigenvalues. A few issues with this is that the zero eigenvalues are never quite zero but just very small, however I'm not sure this is necessarily a problem. The eigenvectors produced appear to be linearly independent, at least in the simple case I'm looking at where the system is only doubly degenerate in the zero eigenvalue, so they could form a basis for this degenerate subspace. Finally, when the Liouvillian is applied to any linear combination of these eigenvectors (as long as the cofactors are not too large) the result is zero. My only problem is that when I apply the Liouvillian to the steadystate produced by the GMRES approach the result is not zero and after some simple checks it does not appear to be in the space spanned by the eigenvectors. Is this necessarily a problem or just an issue of numerical accuracy. Is my approach of using the eigenvectors of the zero eigenvalue as a basis for the steadystate valid? Any advice on solving this problem would be much appreciated! Thanks.",<programming><density-matrix><qutip>,03/10/2020 18:47,,,,
10174.0,qiskit: IQFT acting on subsystem of reversed-ordered qubits state,"I have a state psi as an ndarray of shape (2 ** 3,) s.t. psi[0]= amplitude of 000 psi[1] = amplitude of 001. So my qubit ordering is reversed w.r.t. qiskit's. To initialize the circuit correctly and apply the IQFT on the first 2 qubits from the left I tried the following code: import qiskit as qt from qiskit.aqua.circuits import FourierTransformCircuits as QFT circuit = qt.QuantumCircuit(3) circuit.initialize( psi, [i for i in reversed(circuit.qubits)]) QFT.construct_circuit(circuit=circuit, qubits=circuit.qubits[:2], inverse=True) backend = qt.Aer.get_backend('statevector_simulator') final_state = qt.execute(circuit, backend, shots=1).result().get_statevector() From the tests I've run, final_state is not what I expected: defining exact = np.kron(IQFT_matrix(2),np.eye(2)).dot(state) with IQFT_matrix(2)= IQFT_matrix for 2 qubits. np.testing.assert_array_almost_equal(final_state, exact) fails. Can you please help me find the problem?",<qiskit><programming><quantum-fourier-transform>,3/13/2020 14:30,,,,
10275.0,May I deploy my C# code to Q# Azure quantum computing?,"I have a code like this public string CalculateMD5Hash(string input) { MD5 md5 = System.Security.Cryptography.MD5.Create(); byte[] inputBytes = System.Text.Encoding.ASCII.GetBytes(input); byte[] hash = md5.ComputeHash(inputBytes); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; hash.Length; i++) { sb.Append(hash[i].ToString(""X2"")); } return sb.ToString(); } public bool checkHash(){ List&lt;string&gt; charset = new List&lt;string&gt;{""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""i"",""j"",""k"",""l"",""m"",""n"",""o"",""p"",""q"",""r"",""s"",""t"",""u"",""v"",""w"",""x"",""y"",""z""}; foreach(var a in charset) { foreach(var b in charset){ foreach(var c in charset){ foreach(var d in charset){ foreach(var e in charset) { string result = a+b+c+d+e; if(CalculateMD5Hash(result).StartWiths(""9A4F2E9567F170C5"")) return true; } } } } } return false; } Is this possible to bring this into Q# &amp; run them on Azure Quantum using some of the Q# quantum method?",<quantum-algorithms><programming><q#>,3/24/2020 3:12,,,,
10312.0,A bug during CIRQ installation,"I had the following problem with an installation of the Cirq. When I typed python -m pip install cirq, I got the following line: ""Cannot uninstall 'sympy'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall."" The source of this issue was in a new version of 'sympy' (1.23 instead of 1.22). I found a simple solution to remove 'sympy' conda uninstall sympy and then wrote this code python -m pip install cirq again. After that, everything works fine. Could you correct this bug in the future?",<programming><cirq>,3/27/2020 18:20,,,,
11408.0,Qiskit - Z expectation value from counts?,"For a given state $|\psi\rangle$, how would I work out $\langle\psi|Z|\psi\rangle$ ? If I run a quantum circuit and get the counts dictionary on qiskit, I get observables in the Z basis. For n=1 qubits, the basis states returned are $|0\rangle$ &amp; $|1\rangle$ with the counts for each state. I would assign +1 to the counts for $|0\rangle$ and -1 to the counts for $|1\rangle$ and work out the Z expectation value. For n=2 qubits, $|00\rangle$ &amp; $|11\rangle$ have eigenvalues +1 and $|01\rangle$ &amp;$|10\rangle$ have eigenvalues -1. The Z expectation value is thus [counts(00) + counts(11) - counts(01) - counts (10) ]/ shots where counts(00) is the counts returned for the $|00\rangle$ state. This is extended to n = 3,4,5.. qubits. My question is how do I calculate this automatically in qiskit?",<qiskit><programming><measurement>,04/04/2020 22:37,,,,
11504.0,How can I use IF gate in IBM Q composer?,"I just want to use the ""if"" gate in IBM QX circuit composer, but I don't know how.",<programming><ibm-q-experience><qasm>,04/11/2020 21:11,,,,
11574.0,IBMQJob.result() returns KeyError: 'qObjectResult',"I'm running tomography job like I have done many times before. I send the job, and the job.status() is 'DONE'. But when I ask for job.results() I get the following traceback. I'm using version 0.18.0. --------------------------------------------------------------------------- KeyError Traceback (most recent call last) /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/providers/ibmq/api/clients/account.py in job_result(self, job_id, use_object_storage) 245 try: --&gt; 246 return self.job_get(job_id)['qObjectResult'] 247 except KeyError as err: KeyError: 'qObjectResult' The above exception was the direct cause of the following exception: ApiIBMQProtocolError Traceback (most recent call last) /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/providers/ibmq/job/ibmqjob.py in _retrieve_result(self, refresh) 675 try: --&gt; 676 result_response = self._api.job_result(self.job_id(), self._use_object_storage) 677 self._result = Result.from_dict(result_response) /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/providers/ibmq/api/clients/account.py in job_result(self, job_id, use_object_storage) 248 raise ApiIBMQProtocolError( --&gt; 249 'Unexpected return value received from the server: {}'.format(str(err))) from err 250 ApiIBMQProtocolError: ""Unexpected return value received from the server: 'qObjectResult'"" The above exception was the direct cause of the following exception: IBMQJobApiError Traceback (most recent call last) &lt;ipython-input-50-0a8321076fbb&gt; in &lt;module&gt; ----&gt; 1 experimental_state = StateTomographyFitter(best_full_tomography_job.result(), best_full_tomography_transpiled).fit() 2 plot_state_hinton(experimental_state) /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/providers/ibmq/job/ibmqjob.py in result(self, timeout, wait, partial, refresh) 253 'Use job.error_message() to get more details.'.format(self.job_id())) 254 --&gt; 255 return self._retrieve_result(refresh=refresh) 256 257 def cancel(self) -&gt; bool: /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/providers/ibmq/job/ibmqjob.py in _retrieve_result(self, refresh) 687 raise IBMQJobApiError( 688 'Unable to retrieve result for ' --&gt; 689 'job {}: {}'.format(self.job_id(), str(err))) from err 690 finally: 691 # In case partial results are returned or job failure, an error message is cached. IBMQJobApiError: 'Unable to retrieve result for job 5e984c5e6ad41d00184b12c1: ""Unexpected return value received from the server: \'qObjectResult\'""' What does it mean, and what went EDIT: I now see that when I retrieve a previously ran job, I get a warning message: /anaconda3/envs/quantum/lib/python3.7/site-packages/qiskit/qobj/qasm_qobj.py:497: DeprecationWarning: qiskit.qobj.Qobj is deprecated use either QasmQobj or PulseQobj depending on your application instead. experiments=experiments, header=header)",<qiskit><programming><state-tomography>,4/16/2020 12:28,,,,
11584.0,Does a classical computer really require $2^n$ complex numbers to represent the state of $n$ qubit quantum computer?,"One often reads that the key reason why classical computers (probabilistic or deterministic) are unable to simulate quantum algorithms such as Simon's or Shor's efficiently is that a classical computer needs $2^n$ complex numbers to represent an $n$ qubit state of a quantum computer. While it is true that the dimensionality of the Hilbert space spanned by an $n$ qubit computational basis is $2^n$, it seems to me that the subspaces reachable by many quantum algorithms that employ fixed sequence of unitary gates are substantially smaller. Let $n$ be the number of qubits in a quantum computer. Consider an algorithm that starts from some simple initial state (say the 0 for all qubits) and employs a sequence of $kn$ unitary gates ($k$ being some factor), each involving no more than 1 or 2 qubits. One may ask: What is the size of the Hilbert subspace reachable by this algorithm from the initial state? A 2 qubit gate should not need more than 16 complex numbers for its representation and $kn$ such gates in a fixed sequence will not need more than $16kn$ such numbers (in reality the factor will be smaller). The fact that the sequence of gates is a fixed one is important in this argument to avoid branching. Many algorithms including Shor's, Grover's, Simon's are based on fixed gate sequences like this. If the number of gates scales as a polynomial of $n$, the ""size"" of the Hilbert subspace reachable from the initial state should scale as polynomial of $n$ as well. Therefore, I do not see why we would need $2^n$ complex numbers as would be needed to describe the entire Hilbert space. Can someone help explain why? If my thinking is correct, wouldn't this logic be a generalization of Gottesman-Knill theorem and wouldn't it also imply that there exists ""classical"", possibly probabilistic computing, algorithms capable of equalling Simon's and Shor's in efficiency? What am I missing?",<quantum-algorithms><simulation><classical-computing><nonclassicality><interpretations>,4/17/2020 16:40,,,,
11741.0,Angle in qiskit,"I have been working on Qiskit. Is it possible to display just the angle of each gate in a circuit as an output? For example, if the below code is my circuit is it possible to just print the angle of the gate. We have function QuantumCircuit.count_ops() to display the gate counts similarly is there a way to do so? q2 = QuantumRegister(2) circuit = QuantumCircuit(q2) circuit.cu1(math.pi/2, q2[0], q2[1]) print(circuit)",<quantum-gate><quantum-algorithms><qiskit><programming><entanglement>,4/29/2020 4:42,,,,
11916.0,Is it right to think of superposition as just angle?,"Based on my current understanding, a qubit is represented as a vector $(a, b)$ which satisfy $a^2 + b^2 = 1$. Classical bit one can be represented as $(0, 1)$ and bit zero can be represented as $(1, 0)$. And then we can have things that cannot be described isomorphically in classical computing such as $(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}})$. Then, I came to a realization where this is quite similar to trigonometry identity where $\sin^2(t) + \cos^2(t) = 1$. Thus, I'm wondering if a qubit is a point $p$ that lies anywhere on the circumference of a unit circle, can a qubit $(a, b)$ be described as $(\sin(t), \cos(t))$ where $t$ is the angle measured from positive $x$-axis to the line formed between $p$ and center of the circle? Is this analogy faulty?",<mathematics><classical-computing><superposition>,05/08/2020 15:04,,,,
11920.0,SPSA max_trials,"I'm using SPSA as an optimizer in VQE algorithm. The code runs on ibmq-qasm-simulator. I've set SPSA max_trials parameter to 500, but, when I run the code, it makes 1000 iterations. I've tried with COBYLA optimizer too, and it makes correctly 500 iterations. Does someone know why? Thanks",<qiskit><programming><optimization><vqe>,05/08/2020 16:35,,,,
11966.0,Trying to get a provider from IBMQ but get 'No provider matches the criteria.',"I have created a circuit and then run the following: provider = IBMQ.get_provider('ibm-q') And this is what I get: IBMQProviderError Traceback (most recent call last) &lt;ipython-input-24-d651cdcd236d&gt; in &lt;module&gt; ----&gt; 1 provider = IBMQ.get_provider('ibm-q') ~\anaconda3\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in get_provider(self, hub, group, project) 352 353 if not providers: --&gt; 354 raise IBMQProviderError('No provider matches the criteria.') 355 if len(providers) &gt; 1: 356 raise IBMQProviderError('More than one provider matches the criteria.') IBMQProviderError: 'No provider matches the criteria.'",<qiskit><programming><ibm-q-experience><ibm-quantum-devices>,05/11/2020 12:49,,,,
12051.0,Do I have to upgrade to personal computer or laptop computer in order to be able to use the IBM Quantum Experience website or run code locally?,I currently have a tablet I don't have a desktop or laptop to access the IBM Quantum Experience. Do I have to upgrade to personal computer or laptop computer in order to be able to use the website or run code locally?,<programming><ibm-q-experience>,5/16/2020 13:57,,,,
12067.0,Creating Hamiltonian Simulation Operator in Q#,"I am trying to create a unitary operator $U = \sum^{T - 1}_{k=0}$ $|k\rangle$ $\langle k |$ $ \otimes$ $e^{i A k}$ in Q#, where A is a Hermitian matrix. For the beginning, I just want A to be a combination of 2 Pauli matrices, say $A = X + 2Z$. This is the code that I have, where input is of type Qubit[3] and register of Qubit[2]: ... let SIZE_OF_MATRIX = 2; let unitaryGenerator = (2 ^ SIZE_OF_MATRIX, ConstructU); let registerLE = LittleEndian(register); MultiplexOperationsFromGenerator(unitaryGenerator, registerLE, input); ... function ConstructU (j : Int) : (Qubit[] =&gt; Unit is Adj + Ctl) { let generatorSystem = GeneratorSystem(2, MapToGeneratorIndex); let evolutionGenerator = EvolutionGenerator(PauliEvolutionSet(), generatorSystem); let unitaryOperator = TrotterStep(evolutionGenerator, 1, - IntAsDouble(j)); return unitaryOperator; } // The purpose of this function is to map each part of the Hamiltonian generator // to a generator index. // Initially, we want to test the matrix A = X + 2Z. function MapToGeneratorIndex (index : Int) : GeneratorIndex { // We only have 2 terms, hence index can only be 0 or 1 if (index == 0) { // Here we just want X return GeneratorIndex(([1], [1.0]), [0]); } elif (index == 1) { // Here we want 2Z return GeneratorIndex(([3], [2.0]), [0]); } // TODO: throw an error return GeneratorIndex( ([1000], [1000.0]), [0]); } Does anyone know what am I doing incorrectly? I am not getting the result that I am expecting. I know the code is messy but I am just trying to make it work for a basic 2x2 matrix first. Thanks for the help!",<programming><hamiltonian-simulation><q#>,5/18/2020 15:58,,,,
12096.0,How to get running time for each circuit executed on IBM's quantum processors in one round?,"I want to execute multiple circuits in one round on IBM's backends, especially the 16-qubit one, to save time. For instance, execute([grover_1, grover_2, grover_3], backend). However, I found result given by that quantum processor contain only one overall time like this: {'backend_version': '2.1.0', 'backend_name': 'ibmq_16_melbourne', 'results': [{'header': ..., 'success': True, 'shots': 1024, 'meas_level': 2, 'data': {'counts': {}}, 'memory': False}],}, {'header': ..., 'success': True, 'shots': 1024, 'meas_level': 2, 'data': {'counts': {}}, 'memory': False}], 'qobj_id': ..., 'status': 'Successful completion', 'date': '...', 'header': {'backend_version': '2.1.0', 'backend_name': 'ibmq_16_melbourne'}, 'success': True, 'job_id': '...', 'execution_id': '...', 'time_taken': 7.73473865282683} while simulators can provide time counted for each circuit in the result of one instance like: {'date': '...', 'results': [{'shots': 1024, 'header': ..., 'data': {}, 'success': True, 'status': 'DONE', 'time_taken': 0.00136636000000000003, ...}, {'shots': 1024, 'header': ..., 'data': {}, 'success': True, 'status': 'DONE', 'time_taken': 0.00263673800000000008, ...}], 'header': {'backend_version': '0.1.547', 'backend_name': 'ibmq_qasm_simulator'}, 'backend_version': '0.4.1', 'job_id': '...', 'success': True, 'status': 'COMPLETED', 'qobj_id': '...', 'backend_name': 'ibmq_qasm_simulator', 'time_taken': 0.00438376, 'metadata': {..., 'time_taken': 0.00438376}}. So anyone knows why and how to deal with the issue of counting time for each circuit executed on quantum processors without iteration which takes too much waiting time? Or alternatively, how to make circuits executed in distinct instances queued sequentially, instead of queueing one after finishing the previous one, if I can only do something like: for n in range(1,10): start = time.time() quantumAlgorithm(n) end = time.time()",<qiskit><programming><ibm-q-experience>,5/20/2020 14:05,,,,
12130.0,Are there patterns in the numbers created with qrng by entangled qubits?,"I want to examine the graph of 2 sets consisting of 1000 numbers created with quantum random number generator which were created by entangled qubits and see if there is a pattern in the randomly generated number series. How can I do this with Q#? So by doing that I think,I can entangle two qubits in Sample Quantum Random Number Generator operation SampleQuantumRandomNumberGenerator() : Result { // Allocate two qubits using ((q1, q2) = (Qubit(), Qubit())) { // Prepare Bell state (|00â© + |11â©) / sqrt(2) on them H(q1); CNOT(q1, q2); // The measurement results are going to be correlated: you get 0,0 in 50% of the cases and 1,1 in 50% return (MResetZ(q1) == Zero ? 0 | 1, MResetZ(q2) == Zero ? 0 | 1); } But how can I use qubits ( qs(0) for one set qs(1) for one set ) in here for getting 2 sets consisting of 1000 numbers between 0 and 100 ? operation SampleRandomNumberInRange(max : Int) : Int { mutable bits = new Result[0]; for (idxBit in 1..BitSizeI(max)) { set bits += [SampleQuantumRandomNumberGenerator()]; } let sample = ResultArrayAsInt(bits); return sample &gt; max ? SampleRandomNumberInRange(max) | sample; } @EntryPoint() operation SampleRandomNumber() : Int { let max = 100; Message($""Sampling a random number between 0 and {max}: ""); return SampleRandomNumberInRange(max); }",<programming><entanglement><q#>,5/22/2020 12:18,,,,
12136.0,Can't append multiple times with self-defined oracle,"import cirq def set_io_qubits(qubit_count): input_qubits = [cirq.GridQubit(i, 0) for i in range(qubit_count)] return (input_qubits) def debug_oracle(input_qubits): yield (cirq.H(input_qubits[0])) def make_grover_circuit(input_qubits, oracle): c = cirq.Circuit() c.append(oracle) c.append(oracle) c.append(oracle) c.append(cirq.measure(*input_qubits, key='result')) return c def main(): input_qubits = set_io_qubits(2) oracle = debug_oracle(input_qubits) circuit = make_grover_circuit(input_qubits, oracle) print('Circuit:') print(circuit) if __name__ == '__main__': main() I add c.append(oracle) three times in make_grover_circuit. However, when I print the circuit, it seems there is only one oracle. Is it a bug? Or just I can't .append my oracle more than once? Here is my result of the program. /Library/Frameworks/Python.framework/Versions/3.7/bin/python3 /Users/a123/Desktop/Cirq/test.py Circuit: (0, 0): âââHâââM('result')âââ â (1, 0): âââââââMâââââââââââââ Process finished with exit code 0",<quantum-gate><programming><cirq>,5/22/2020 19:09,,,,
12141.0,How to ignore spins is Qiskit chemistry package?,"Is it possible to use built-in qiskit.chemistry tools, such as VQE, UCCSD, etc., without using the notion of spins ('alpha'/'beta')? Let's say, I want to decsribe a system having 5 fermionic modes in the second-quantized formalism. I want to start from a state in which 3 of them are occupied. I can provide a second-quantized Hamiltonian written in terms of $h_1$ and $h_2$ coefficients and ladder operators. How do I do all that?",<qiskit><programming>,5/23/2020 3:51,,,,
12270.0,Passing an array of qubits into Q# using Python,"I am trying to learn Q# and have very limited knowledge in Q#. As the title suggests, I am trying to pass an array of qubits into an operation using a python script to call the operation which is written in Q#. For Example: Consider the following Q# code: operation SlightlyComplicated(register : Qubit[], pauli : String[]): Bool { // Does something and returns a bool value } The above operation is saved in a file called Program.qs which is saved in the same folder as the python code under the name TempQuant and then here's the python code that is responsible for calling this operation: import qsharp from qsharp import Result from Quantum.TempQuant import SlightlyComplicated res = SlightlyComplicated.simulate(register = , pauli = ['X', 'Y', 'Z', 'Z']) print(res) Since pauli is an array of Strings, it is easy to pass it through python since they share this type, but for types like qubit, Result, Pauli(which are exclusively present in Q#), how am I supposed to pass them through python into their respective counterparts in Q#? For reference, I am using Visual Studio Code to write the codes.",<programming><q#>,06/01/2020 13:29,,,,
12273.0,Problem with the API-token from IBM TypeError,"English/Englisch: Hi, could anyone help me please?I have a problem with the API-token line 8, in random_qubit IBMQ.load_account('API-token is normally standing here but I delete it for the question') TypeError: load_account() takes 1 positional argument but 2 were given If someone has the solution or the same problem, please comment it below this question And sorry for my bad english. German/Deutsch: Hey kÃ¶nnte mir wer bitte helfen? Ich hab ein Problem und zwar line 8, in random_qubit IBMQ.load_account('API-Token hab ich heraus gelÃ¶scht wegen Kommentar sonst wÃ¼rde hier der API-Token stehen') TypeError: load_account() takes 1 positional argument but 2 were given Falls jemand die LÃ¶sung bzw das gleiche Problem hat / hatte bitte unter diesen Kommentar kommentieren",<qiskit><programming>,06/01/2020 16:53,,,,
12277.0,How to obtain the density matrix using tomography in the real device?,"I am trying to run the QFT algorithm for n=5 (n number of qubits). The number of experiments that it generates is bigger than the one allowed by the IBM devices (i.e. 75). Therefore, I have tried to used the IBMQJobManager but this is not working as my result is not the counts but the density matrix obtain from the tomography process. Is it possible to make it work? I have made the following attempt (qft is a function that I have created that implements the QFT algorithm): n=5 beta=0.5*np.pi state=initial_state_QFT(n,beta) qr=QuantumRegister(n) cr=ClassicalRegister(n) qc=QuantumCircuit(qr) qc.initialize(state,qr) qft(qc,n) qst = tomo.state_tomography_circuits(qc, qr) job = job_manager.run(qst, backend=device, name='foo',shots=8192) statefit = tomo.StateTomographyFitter(job.results(), qst) p, M, weights = statefit._fitter_data(True, 0.5) M_dg = np.conj(M).T linear_inversion_matrix = np.linalg.inv(M_dg @ M) @ M_dg rho = linear_inversion_matrix @ p rho = np.reshape(rho, (2**n, 2**n)) Thank you in advance for your answer!",<qiskit><programming><ibm-q-experience><quantum-fourier-transform><state-tomography>,06/01/2020 17:33,,,,
12280.0,Install qiskit in django project,"I was wondering if it's possible to use qiskit inside a django project. I found some ways to install jupyter notebooks, but I am not sure what is happening with qiskit. Ideally I would like to import and use qiskit to a web app with a very simple user interface. I haven't found anything similar. Any ideas? Thank you!",<qiskit><programming><ibm-q-experience>,06/01/2020 20:52,,,,
12312.0,Software used for modelling quantum processors,"What kind of software is used for modelling quantum processor architectures? Not just simulate the output, but the one that is actually used in research.",<programming><resource-request><experimental-realization>,06/03/2020 08:52,,,,
12382.0,Unable to use qiskit_textbook module,"When I tried to use the Qiskit textbook module, it threw the following error: Command was: from qiskit_textbook.tools import array_to_latex array_to_latex(final_state, pretext=""\\text{Statevector} = "") Error was: --------------------------------------------------------------------------- ModuleNotFoundError Traceback (most recent call last) &lt;ipython-input-9-fe86c66f7ae0&gt; in &lt;module&gt; ----&gt; 1 from qiskit_textbook.tools import array_to_latex 2 array_to_latex(final_state, pretext=""\\text{Statevector} = "") ModuleNotFoundError: **No module named 'qiskit_textbook'** When I looked up the version I had, it showed the following: {'qiskit-terra': '0.12.0', 'qiskit-aer': '0.4.1', 'qiskit-ignis': '0.2.0', 'qiskit-ibmq-provider': '0.5.0', 'qiskit-aqua': '0.6.4', 'qiskit': '0.16.1'} Can someone help me in resolving the issue?",<qiskit><programming><textbook-and-exercises>,06/09/2020 06:51,,,,
12457.0,Q# Quantum.MachineLearning namespace doesn't exist error,"I am trying to use the HalfMoon Classifier in Quantum Machine Learning Sample Examples. I am trying to run it locally. However I keep getting this error. No namespace with the name ""Microsoft.Quantum.MachineLearning"" exists. This error is then followed by multiple errors of the identifiers under this namespace not existing. In my python Host.py file I have the following Import Lines import qsharp qsharp.packages.add(""Microsoft.Quantum.MachineLearning::0.11.2006.403"") qsharp.reload() Edit: Replacing Package Version and Making it same as dotnet iqsharp --version did work. However I still seem to getting fail: warnings saying identifiers don't exist and No namespace with the name ""Microsoft.Quantum.MachineLearning"" exists. The program runs correctly but the warnings don't go away. Hence I ask is there anyway to fix these warnings?",<programming><q#>,6/13/2020 10:46,,,,
12507.0,Compiling a classical function to a quantum circuit in practice,"It can be shown that any classical function $f$ can be implemented by a quantum circuit $Q_f$, so that $$ \sum_{x}|x,0^k\rangle \xrightarrow{\mathit{Q_f}} \sum_{x}|x,f(x)\rangle $$ where $f$ has $k$ output bits, and ingnoring normalization. I have seen such circuits called quantum oracles and treated as black boxes in quantum algorithms. If I want to write a quantum computer program that includes the circuit $Q_f$, it is convenient to write a classical program for $f$ in a high level language (like C or Java or python) and have it compiled to a quantum circuit. My question is: is there an implementation of a compiler (preferably open source) that will compile my classical high-level program for $f$ into some representation of the quantum circuit $Q_f$ (e.g. using OpenQASM)? If not, is there a compiler that will compile into reversible gates? Thanks! kgi",<programming><classical-computing>,6/16/2020 5:52,,,,
12547.0,How to assign values to the symbols in a parametrized Cirq circuit without running it?,"Is there a way to use a ParamResolver or Sweep to assign values to the symbols in a parameterized Cirq circuit without running it? For example, something like: #set up parameterized circuit simulator = cirq.Simulator() circuit = cirq.Circuit() alpha = sympy.Symbol('alpha') beta = sympy.Symbol('beta') circuit.append(one_step(alpha, beta)) circuit.append(cirq.measure(*qubits, key='x')) sweep = (cirq.Linspace(key='alpha', start=0.1, stop=0.9, length=5) * cirq.Linspace(key='beta', start=0.1, stop=0.9, length=5)) for param_resolver in study.to_resolvers(sweep): #resolve parameters *line that resolves the symbolic parameters in circuit using param_resolver* #run measurement simulations measurements = simulator.run(circuit=circuit, repetitions=100) Instead of: #set up parametrized circuit simulator = cirq.Simulator() circuit = cirq.Circuit() alpha = sympy.Symbol('alpha') beta = sympy.Symbol('beta') circuit.append(one_step(alpha, beta)) circuit.append(cirq.measure(*qubits, key='x')) sweep = (cirq.Linspace(key='alpha', start=0.1, stop=0.9, length=5) * cirq.Linspace(key='beta', start=0.1, stop=0.9, length=5)) for param_resolver in study.to_resolvers(sweep): #resolve parameters and run measurement simulations in one step measurements = simulator.run(circuit=circuit, param_resolver=param_resolver, repetitions=100)",<programming><cirq>,6/19/2020 7:01,,,,
12567.0,Difference between $Rz$ and $R1$ gate,You are given an operation that implements a single-qubit unitary transformation: either the Rz gate or the R1 gate. The operation will have Adjoint and Controlled variants defined. Your task is to perform necessary operations and measurements to figure out which unitary it was and to return 0 if it was the Rz gate or 1 if it was the R1 gate.,<quantum-gate><q#>,6/19/2020 19:48,,,,
12568.0,How do you decide which rotations to use in a Quantum Machine Learning model?,"I am trying to design a model using Q#'s machine learning library that takes in two features (real numbers from 0 to 1) and classifies as 0 or 1. So how do I decide which Rotations and what seeds to use? ControlledRotation((0, new Int[0]), PauliY, 0) I tried using this as the rotation gate but it gave an inaccurate model for many different seed values. I also tried combining gates: ControlledRotation((0, new Int[0]), PauliY, 0), ControlledRotation((0, new Int[0]), PauliX, 1) but this also gave an inaccurate model. There must surely be a way to analyse what kind of gates to use and not just trial and error. What kind of analysis would be appropriate?",<programming><q#><machine-learning>,6/19/2020 21:36,,,,
12611.0,STO-3G Basis Set,"Can someone please explain why STO-3G is considered to be a good basis set for quantum computing, while it does not help in classical computing? I would also be very grateful for any references to read about as I could not find the needed information.",<classical-computing><superconducting-quantum-computing>,6/22/2020 19:29,,,,
12630.0,How can I print out a state vector of a specific wire?,"Suppose we start from 2 wires (q0 and q1) and through some quantum gates, suppose we measure q1 wire only. As we measure the q1 wire, the state vector of this quantum state would be determined immediately. How can I print out this state vector? In addition, I would like to print out the state vector of q0 wire only. Does anyone know how to do this task via qiskit or cirq or pyquil? (Any other package language is also fine!)",<quantum-state><quantum-algorithms><programming><entanglement>,6/24/2020 7:18,,,,
12722.0,Algorithm to find stabilizer states,"I'm working on a project in which I have to find stabilizer states based on a few criteria, the main one being that it has to have a certain amount of coherence, I'm using the following equation to calculate my coherence based on the density matrix of the state. $$ C_r(\rho) = S_{VN}(\rho_{diag}) - S_{VN}(\rho) $$ Where S is the Von Neumann entropy and rho diag is the matrix with the main diagonal equal the density matrix's main diagonal, and every other term is zero. I'm also defining this to be a 5-qubit stabilizer state. I'm using python and qutip to do these calculations. Is there a better-than-brute-force algorithm to generate stabilizer states? Is there a way to generate stabilizer states at random based on some criteria?",<quantum-algorithms><programming><error-correction><stabilizer-code><stabilizer-state>,6/30/2020 17:41,,,,
12779.0,"Expectation value of an operator error: Composition is not defined over operators of different dimensions,","I am trying to calculate the expectation value of a customized operator on two similar but differently constructed states $\phi = \phi_2 =\frac{1}{\sqrt{2}}\left( |001â© + |011â©\right)$ which consist of more qubits than the operator. (via Qiskit) import numpy as np from qiskit import QuantumCircuit from qiskit.aqua.operators import CircuitOp, state_fns, Zero, One circuit = QuantumCircuit(2) circuit.z(0) circuit.z(1) op = CircuitOp(circuit) psi = QuantumCircuit(3) psi.h(1) psi.x(2) psi = state_fns.CircuitStateFn(circuit) psi2 = 1 / np.sqrt(2) * ((Zero ^ Zero ^ One) + (Zero ^ One ^ One)) print('Expectation for phi:', psi.adjoint().compose(op).compose(psi).eval().real) # Expectation for phi: 1.0 print('Expectation for phi2:', psi2.adjoint().compose(op).compose(psi2).eval().real) # Error The second expectation raises an error: ValueError: Composition is not defined over Operators of different dimensions, 3 and 2, respectively. Why is this happening? Why the first expectation is executed fine but not the second one?",<quantum-gate><quantum-state><qiskit><programming>,07/04/2020 11:10,,,,
12886.0,Can quantum computing help to recover a lost private key?,I lost a private key for an ethereum wallet. While seeking for information I found out that only quantum computers can decrypt a public key. Is this really a possibility? Thanks in advance.,<programming>,7/13/2020 19:04,,,,
12919.0,How do you turn the CX gate upside down on ibm-q-experience?,"I am learning how to make Grover's algorithm but the last cx gate needs to be the opposite way around. It always makes the top qubit the control, so how do you turn it around?",<programming><ibm-q-experience>,7/16/2020 6:47,,,,
12923.0,Defining a Grassmann Algebra in Python,"I am trying to implement a Grassmann algebra in Python and was wondering if anyone could recommend any packages or suggest how to do so? I want to define the following multiplication rules over $\Bbb{C}^{2n}$ with standard basis vectors $e_j$ via $$e_j^2=0 \text{ and the anti-commutation rule } e_ie_j+e_je_i=0$$ I then plan on defining an exponential function of quadratic terms in these basis vectors in a way that respects the relations above, ie $\exp{(ie_ae_b)}$, via the power series definition. I would be very grateful for any suggestions on how to program this!",<programming><clifford-group>,7/16/2020 10:49,,,,
12979.0,VQE jobs do not appear in queue,"I am trying to calculate the ground state energy of some simple molecules using 'MolecularGroundStateEnergy' tools in qiskit. When I run the calculations for very small molecules (e.g. H2, HeH+) the jobs appear in the queue very quickly and the calculations work independent of which backend I select. However, running the same code with slightly larger molecules (e.g. LiH, BeH2 and water) the jupyter notebook runs indefinitely and the jobs do not show in the IMBQ queue. Note: I have run successful calculations for all these molecules using the state-vector simulator with no issues. Here is the function i use to calculate energy via VQE given a molecule (created from PySCF driver): def calc_vqe_energy(molecule): driver = molecule energy = MolecularGroundStateEnergy(driver = driver, transformation=TransformationType('full'), qubit_mapping=QubitMappingType('parity'), two_qubit_reduction=True, freeze_core=False, z2symmetry_reduction='auto') solver = energy.get_default_solver(quantum_instance) #calculate energy using the above solver calc = energy.compute_energy(solver) return calc this is set up to run using the quantum instance: IBMQ.save_account(token) IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q') backend = provider.get_backend(&quot;ibmq_qasm_simulator&quot;) coupling_map = backend.configuration().coupling_map quantum_instance = QuantumInstance(backend=backend, shots=1000, coupling_map=coupling_map, measurement_error_mitigation_cls=CompleteMeasFitter, cals_matrix_refresh_period=30, skip_qobj_validation=False) Thanks for the help!",<qiskit><programming><ibm-q-experience><vqe><chemistry>,7/20/2020 12:51,,,,
13071.0,Making custom gate in Qiskit?,"I have been trying to make a gate in qiskit in terms of the basic gates, but I keep on getting an error when I apply it to a circuit. This is my gate: class LGate(Gate): def __init__(self, label=None): super().__init__('l', 1, [], label=label) def _define(self): from qiskit.circuit.quantumcircuit import QuantumCircuit from qiskit.circuit.library import U3Gate q = QuantumRegister(1, 'q') qc = QuantumCircuit(q, name=self.name) rules = [ (U3Gate(pi, 0, pi), [q[0]], []) ] qc._data = rules self.definition = qc Of course this is just an X gate, but I was just trying a basic example. Running the program: circ = QuantumCircuit(2) circ.l(0) print(circ) Error: AttributeError: 'QuantumCircuit' object has no attribute 'l'",<quantum-gate><qiskit><programming>,7/28/2020 13:17,,,,
13102.0,How can I load a probability distribution using a quantum circuit in Qiskit?,Can someone suggest me a way to load a distribution (for example a discretized Gaussian distribution) into a quantum computer using a quantum circuit? I tried to implement the code using Qiskit.,<qiskit><programming><circuit-construction><quantum-computing-for-finance>,7/30/2020 10:34,,,,
13130.0,What is the maximum circuit depth for Qiskit Aer Simulator?,"I'm running some simulator circuit on my computer, and I see that (using 3 qubits, and thousands of classical registers), the max cap seems to be about qc.depth() slightly less than 150000 before the kernel crash into oblivion (with or without optimization_level = 3, so I don't think that helps). I have plenty of RAM left and I don't see them filling up, and the circuits always only take a few seconds to run since I only do 1 shot so I doubt if it's a CPU problem. What is the cause of this, and is there any way to be able to run at higher depth? Thanks!",<qiskit><programming><circuit-construction>,08/01/2020 02:07,,,,
13200.0,How can I mesure a register of qubits and grab the index of the qubit with the highest probability in Q#?,"I have an array of qubits, with indices to represent each such that if we have 3 qubits, we have 0, 1, 2 representing each. From here I would like to measure the probability of our qubits after running it through some gates. How can I grab these probabilities and spit out one of the indices based on which has the highest probability? Cheers!",<programming><q#>,08/06/2020 19:15,,,,
13251.0,What is the right way to prepare a specific qubit state in Qiskit / Q#?,"There are two possibilities to prepare a qubit in a particular state like $ | - \rangle $ in Qiskit. The first approach is using the initialize function: qc = QuantumCircuit(1) initial_state = [1/sqrt(2),-1/sqrt(2)] qc.initialize(initial_state, 0) The second approach is using standard quantum gates: qreg_q = QuantumRegister(1, 'q') creg_c = ClassicalRegister(1, 'c') qc = QuantumCircuit(qreg_q, creg_c) qc.x(qreg_q[0]) qc.h(qreg_q[0]) Are these two possibilities different? What is the &quot;best practice&quot; for preparing an arbitrary qubit state? Is there a comparable initialize function in Q#?",<quantum-state><qiskit><programming><q#>,08/10/2020 19:18,,,,
13272.0,Qiskit Portfolio Optimization Application,"I recently got flung into the world of quantum computing and I'm a beginner at coding. I was assigned to do the Portfolio Optimization tutorial of the Qiskit Finance Tutorials and input real data. Truth be told, I'm clueless. It's my understanding that I have to replace the &quot;TICKER&quot; and &quot;RandomDataProvider&quot; parts of the code in order to generate a real-life portfolio. # Generate expected return and covariance matrix from (random) time-series stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)] data = RandomDataProvider(tickers=stocks, start=datetime.datetime(2016,1,1), end=datetime.datetime(2016,1,30)) data.run() mu = data.get_period_return_mean_vector() sigma = data.get_period_return_covariance_matrix() I've imported Quandl and WikipediaDataProvider. I want to keep the number of assets the same, using Microsoft &quot;MSFT&quot;, Disney &quot;DIS&quot;, Nike &quot;NKE&quot;, and Home Depot &quot;HD&quot; stocks. How might I apply this financial from Quandl to the tutorial? I've tried this so far: num_assets = 4 # Generate expected return and covariance matrix from (random) time-series stocks = [(&quot;MSFT%s&quot; , &quot;DIS%s&quot; , &quot;NKE%s&quot; , &quot;HD%s&quot; % i) for i in range(num_assets)] data = WikipediaDataProvider(tickers=stocks, token=&quot;xeesvko2fu6Bt9jg-B1T&quot;, start=datetime.datetime(2016,1,1), end=datetime.datetime(2016,1,30)) data.run() mu = data.get_period_return_mean_vector() sigma = data.get_period_return_covariance_matrix() But get the error: --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-59-19e4d9cde1e3&gt; in &lt;module&gt; 3 # Generate expected return and covariance matrix from (random) time-series 4 stocks = [(&quot;MSFT%s&quot; , &quot;DIS%s&quot; , &quot;NKE%s&quot; , &quot;HD%s&quot; % i) for i in range(num_assets)] ----&gt; 5 data = WikipediaDataProvider(tickers=stocks, 6 token=&quot;xeesvko2fu6Bt9jg-B1T&quot;, 7 start=datetime.datetime(2016,1,1), TypeError: Can't instantiate abstract class WikipediaDataProvider with abstract methods run I apologize for my limited coding skills - I'm very new to all of this! Thank you in advance.",<qiskit><programming><optimization><quantum-computing-for-finance>,08/12/2020 03:25,,,,
13279.0,Type object 'AllPairs' has no attribute 'params',"When I try QSVM over Iris data, it needs multiclass extension, but when I provide it, a following error is returned: AttributeError Traceback (most recent call last) &lt;ipython-input-18-86cd4e7dd846&gt; in &lt;module&gt; 2 3 feature_map = ZZFeatureMap(feature_dimension=feature_dim, reps=2, entanglement='linear') ----&gt; 4 qsvm = QSVM(feature_map, training_input, test_input, multiclass_extension=AllPairs) d:\anaconda\envs\ai\lib\site-packages\qiskit\aqua\algorithms\classifiers\qsvm\qsvm.py in __init__(self, feature_map, training_dataset, test_dataset, datapoints, multiclass_extension, quantum_instance) 148 else: 149 multiclass_extension.set_estimator(_QSVM_Estimator, [feature_map]) --&gt; 150 qsvm_instance = _QSVM_Multiclass(self, multiclass_extension) 151 152 self.instance = qsvm_instance d:\anaconda\envs\ai\lib\site-packages\qiskit\aqua\algorithms\classifiers\qsvm\_qsvm_multiclass.py in __init__(self, qalgo, multiclass_classifier) 37 super().__init__(qalgo) 38 self.multiclass_classifier = multiclass_classifier ---&gt; 39 self.multiclass_classifier.params.append(qalgo) 40 41 def train(self, data, labels): AttributeError: type object 'AllPairs' has no attribute 'params' The code is : seed = 10598 feature_map = ZZFeatureMap(feature_dimension=feature_dim, reps=2, entanglement='linear') qsvm = QSVM(feature_map, training_input, test_input, multiclass_extension=AllPairs) ```",<qiskit><programming><ibm-q-experience>,08/12/2020 11:45,,,,
13293.0,Simulating a Quantum Network over a real Classical Network Using Simulaqron,I'm trying to simulate a quantum network over a real classical network using the Simulaqron framework. I know the documentations says this is possible but I am having trouble finding examples of how to do this exactly. What are the steps to simulating a quantum network over a classical network in Simulaqron? Also are there other frameworks that can do this?,<programming><simulation><communication><quantum-networks>,8/13/2020 0:29,,,,
13298.0,Qiskit QSVM - Alphas and Support Vectors,"I just started using Qiskit and I have implemented the QSVM example. However, I having trouble with the return. The qsvm.predict() results are reasonable but when trying to calculate the margin myself, this does not make sense. I was hoping someone could help me: xData = qsvm_res['svm']['support_vectors'] yData = qsvm_res['svm']['yin'] qsvm_alphas = qsvm_res['svm']['alphas'] w = np.zeros(n_features) for n in range(len(qsvm_alphas)): w += qsvm_alphas[n]*yData[n]*xData[n] Thanks, Matthias",<qiskit><programming><quantum-enhanced-machine-learning>,8/13/2020 14:51,,,,
13340.0,Defining dimension of an operator in qutip,"My main question: Can someone please explain to me how the list of array is used to define the dimension in qutip? Context: If I have my density operator A = Qobj(np.arange(1,65).reshape(8,8)) of 3 qubits, how do I take the partial transpose such that I want to make bipartite entanglement between qubit 1 with qubit 2 and 3? I am guessing that I would have to define my mask as X.dims = [[2,4],[2,4]] and take qt.partial_transpose(X, [1,0]) which taking partial transposition over the second subsystem. But what does this X.dims = [[2,4],[2,4]] mean in qutip? If this is correct then how would I define my dimension for entanglement between qubit 1 and 3 and qubit 2?",<programming><quantum-state><entanglement><qutip><partial-transpose>,8/16/2020 2:25,,,,
13350.0,Qiskit IBMQ.load_account fails on version 0.20.0,"So when trying to load my account I get this error: ibmqfactory._initialize_providers:WARNING:2020-08-16 17:47:17,410: Unable to instantiate provider for {'hub': 'ibm-q', 'group': 'open', 'project': 'main'}: &quot;{'online_date': ['Not a valid datetime.']}&quot; ibmqfactory.load_account:WARNING:2020-08-16 17:47:17,411: No Hub/Group/Projects could be found for this account. I have tried changing the date format on my machine but other than that I'm lost.",<qiskit><programming>,8/16/2020 19:25,,,,
13416.0,Using QuantumCircuit.initialize() on a real quantum computer,Can the qiskit function QuantumCircuit.initialize be used to initiate any number of qubits (which exist currently on the quantum computers) and can it be used on a real quantum computer?,<qiskit><programming><initialization>,8/21/2020 6:40,,,,
13440.0,Trouble importing Qiskit,"When trying to import qiskit I obtain following error: /opt/anaconda3/lib/python3.8/site-packages/qiskit/__init__.py:63: RuntimeWarning: Could not import the Aer provider from the qiskit-aer package. Install qiskit-aer or check your installation. warnings.warn('Could not import the Aer provider from the qiskit-aer ' /opt/anaconda3/lib/python3.8/site-packages/qiskit/__init__.py:73: RuntimeWarning: Could not import the IBMQ provider from the qiskit-ibmq-provider package. Install qiskit-ibmq-provider or check your installation. warnings.warn('Could not import the IBMQ provider from the ' --------------------------------------------------------------------------- ModuleNotFoundError Traceback (most recent call last) &lt;ipython-input-3-578b7f7e9727&gt; in &lt;module&gt; ----&gt; 1 import qiskit /opt/anaconda3/lib/python3.8/site-packages/qiskit/__init__.py in &lt;module&gt; 78 # Moved to after IBMQ and Aer imports due to import issues 79 # with other modules that check for IBMQ (tools) ---&gt; 80 from qiskit.execute import execute # noqa 81 from qiskit.compiler import transpile, assemble, schedule # noqa 82 /opt/anaconda3/lib/python3.8/site-packages/qiskit/execute.py in &lt;module&gt; 24 import logging 25 from time import time ---&gt; 26 from qiskit.compiler import transpile, assemble, schedule 27 from qiskit.qobj.utils import MeasLevel, MeasReturnType 28 from qiskit.pulse import Schedule /opt/anaconda3/lib/python3.8/site-packages/qiskit/compiler/__init__.py in &lt;module&gt; 33 34 from .assemble import assemble ---&gt; 35 from .transpile import transpile 36 from .schedule import schedule /opt/anaconda3/lib/python3.8/site-packages/qiskit/compiler/transpile.py in &lt;module&gt; 22 from qiskit.providers.models import BackendProperties 23 from qiskit.providers.models.backendproperties import Gate ---&gt; 24 from qiskit.transpiler import Layout, CouplingMap, PropertySet, PassManager 25 from qiskit.transpiler.basepasses import BasePass 26 from qiskit.dagcircuit import DAGCircuit /opt/anaconda3/lib/python3.8/site-packages/qiskit/transpiler/__init__.py in &lt;module&gt; 412 &quot;&quot;&quot; 413 --&gt; 414 from .runningpassmanager import FlowController 415 from .passmanager import PassManager 416 from .passmanager_config import PassManagerConfig /opt/anaconda3/lib/python3.8/site-packages/qiskit/transpiler/runningpassmanager.py in &lt;module&gt; 21 from time import time 22 ---&gt; 23 from qiskit.dagcircuit import DAGCircuit 24 from qiskit.converters import circuit_to_dag, dag_to_circuit 25 from .propertyset import PropertySet /opt/anaconda3/lib/python3.8/site-packages/qiskit/dagcircuit/__init__.py in &lt;module&gt; 39 DAGCircuitError 40 &quot;&quot;&quot; ---&gt; 41 from .dagcircuit import DAGCircuit 42 from .dagnode import DAGNode 43 from .dagdepnode import DAGDepNode /opt/anaconda3/lib/python3.8/site-packages/qiskit/dagcircuit/dagcircuit.py in &lt;module&gt; 29 import math 30 ---&gt; 31 import retworkx as rx 32 import networkx as nx 33 /opt/anaconda3/lib/python3.8/site-packages/retworkx/__init__.py in &lt;module&gt; 7 # that they have been altered from the originals. 8 ----&gt; 9 from .retworkx import * 10 11 ModuleNotFoundError: No module named 'retworkx.retworkx' Have I installed Qiskit to the target directory incorrectly? I attempted to install Qiskit in Terminal using: python3 -m pip install qiskit -t /opt/anaconda3/lib/python3.8/site-packages.I navigated to the path manually and I could find all the qiskit modules, including the retworkx modules (whatever it may be). If anybody has experienced this sort of error before and happens to know a fix, I would appreciate it very much.",<qiskit><programming>,8/23/2020 14:21,,,,
13456.0,Can we measure the quantum circuit sequently when using Qiskit?,"In some quantum algorithms, the output of the quanutm circuit is probabilistic. For example. the measurement outcome (once) for a specific qubit &quot;0&quot; indicates success, which means that the resulting state is what we desired. Therefore, we can first measure that special qubit for once, if the outcome is &quot;0&quot;, then we measure the rest, othervise, we will not record this time. Can this be done in Qiskit? I tried to solve this in another way. I don't care the qubit, after the measurement is finished, the indicater and the working system will be a joint state $\rho_{is}$, where i and s represents the indicater and system. Then we can project this state as: $$\rho_s=P\rho_{is}P^{\dagger}$$ with $P=|0\rangle \langle 0|\otimes I_s$ the projector operator. But when I put this into a function called &quot;state_fidelity&quot; with one other density matrix, it is error with information that the input is not a valid. Is there any points that I was wrong? Thanks for help!",<qiskit><programming><measurement>,8/24/2020 13:15,,,,
13467.0,Create this state using CIRQ Coding language,I needed help with CIRQ coding as I'm quite new to Quantum Computing. I read the tutorials on CIRQ but don't really understand it. I'd be very thankful if someone could help. A program to create the state using CIRQ coding. A program to create the state $\frac{1}{\sqrt 2}(|00\rangle+|11\rangle)$.,<quantum-state><programming><mathematics><cirq>,8/25/2020 11:46,,,,
13472.0,Is there any way we get the state vector/density matrix of a noisy simulation in qiskit?,"In Qiskit we can't use noise models in the 'state vector_simulator' or the 'unitary simulator', hence making it impossible to compute fidelity of the output of the noisy circuit and the noiseless circuit. We can, of course, do a noisy simulation using the qasm simulator but it gives us the probability distribution instead of a state vector/density matrix. How do we compare the fidelity in this case? Or is there any other way to do it?",<qiskit><programming><noise><fidelity><qasm>,8/26/2020 11:57,,,,
13480.0,"Optimize chains of single-qubit u1, u2, u3 gates by combining them into a single gate in Qikist","Can anyone explain how Qiskit does the merging of single-qubit gates for the purpose of optimization? u1(lambda1) * u1(lambda2) = u1(lambda1 + lambda2) u1(lambda1) * u2(phi2, lambda2) = u2(phi2 + lambda1, lambda2) u2(phi1, lambda1) * u1(lambda2) = u2(phi1, lambda1 + lambda2) u1(lambda1) * u3(theta2, phi2, lambda2) = u3(theta2, phi2 + lambda1, lambda2) u3(theta1, phi1, lambda1) * u1(lambda2) = u3(theta1, phi1, lambda1 + lambda2) Using Ry(pi/2).Rz(2lambda).Ry(pi/2) = Rz(pi/2).Ry(pi 2lambda).Rz(pi/2), u2(phi1, lambda1) * u2(phi2,lambda2) = u3(pi - lambda1 - phi2, phi1 + pi/2, lambda2 + pi/2) For composing u3's or u2's with u3's,u2(phi,lambda) = u3(pi/2, phi, lambda) How do they come up with these equations? Is there a property to derive them?",<quantum-gate><quantum-state><qiskit><programming>,8/26/2020 19:11,,,,
13494.0,IBMQFactory object has not attribute backends,I try to run simple circuit measurement program using Qiskit in Visual Code. I received this error: AttributeError: 'IBMQFactory' object has no attribute 'backend' from the line of code print(IBMQ.backends()) Does anyone know what this mean and how to solve it?,<qiskit><programming><ibm-q-experience>,8/28/2020 0:09,,,,
13522.0,How to fix âQiskitChemistryError:PySCF is not installedâ,Iâm trying to simulate LiH using VQE. But I keep getting the error QiskitChemistryError:PySCF is not installed And I tried several ways to see whether my driver for the molecule was typed wrong. But couldnât find any. I again downloaded the VQE molecule Jupyter notebook from the qiskit documentation and tried running it without any modification. It still gives me the same error. (Running with the updated qiskit version 0.20.0 on Windows10),<qiskit><programming><simulation>,8/31/2020 13:56,,,,
13530.0,What is the best way to handle parametric circuits in Qiskit?,"What is the best way to handle parametric circuits in Qiskit? When I create a variational form like TwoLocal and then do var_form.parameters it returns a set but that is an unordered structure so I fear that it will give me different results upon different calls. Here is what I have: var_form = TwoLocal(num_qubits=4, rotation_blocks=[&quot;ry&quot;,&quot;rx&quot;], entanglement_blocks=[&quot;cx&quot;], entanglement=&quot;full&quot;, reps=1, skip_final_rotation_layer=False, insert_barriers=True) parameters=np.random.random(var_form.num_parameters) param_dict={} for i in range(var_form.num_parameters): param_dict[list(var_form.parameters)[i]]=parameters[i] Here is what I want: def get_var_form(parameters): &quot;&quot;&quot;parameters is a list like [0,1,2,3,4....]&quot;&quot;&quot; ## # DO MAGIC HERE var_form = TwoLocal(num_qubits=4, rotation_blocks=[&quot;ry&quot;,&quot;rx&quot;], entanglement_blocks=[&quot;cx&quot;], entanglement=&quot;full&quot;, reps=1, skip_final_rotation_layer=False, insert_barriers=True) #I want to insert parameters-----&gt;var_form ## return var_form #with given parameters How can I do this?",<qiskit><programming><circuit-construction><vqe>,09/01/2020 00:04,,,,
13558.0,How to add several parameters in qiskit circuit?,"I want to construct an ansatz circuit in Qiskit, so I need some parameters to act on the gates (e.g. RX(a), RY(b)). In the Qiskit tutorials I find a way to implement a parameter: import numpy as np theta_range = np.linspace(0, 2 * np.pi, 128) circuits = [qc.bind_parameters({theta: theta_val}) for theta_val in theta_range] circuits[-1].draw() There is only one parameter, theta. I want more parameters in the some range. How can I achieve that?",<qiskit><programming><vqe>,09/02/2020 08:44,,,,
13647.0,Getting an error running a program in IBM Q Experience Quantum lab,"Running the program in Quantum Lab, it shows error. I am looking for solution. Here is a code I run: circ = QuantumCircuit(3) circ.h(0) circ.cx(0, 1) circ.cx(0, 2) circ.draw('mpl') from qiskit import Aer backend = Aer.get_backend('statevector_simulator') job = execute(circ, backend) result = job.result() outputstate =result.get_statevector(circ, decimals=3) print(outputstate) An here is an error I got: NameError Traceback (most recent call last) &lt;ipython-input-3-17b8e431afa9&gt; in &lt;module&gt; ----&gt; 1 circ = QuantumCircuit(3) 2 # Add a H gate on qubit 0, putting this qubit in superposition. 3 circ.h(0) 4 # Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting 5 # the qubits in a Bell state. NameError: name 'QuantumCircuit' is not defined ```",<qiskit><programming><ibm-q-experience>,09/08/2020 10:09,,,,
13688.0,How to initialise a qubit in the state $\frac{1}{\sqrt2}(|0\rangle+|1\rangle)$ in qiskit?,"In qiskit, how can I initialise a qubit in a complex state, specifically in the state: $$\left|q\right&gt; = \frac{1}{\sqrt2} \left|0\right&gt; + i \frac{1}{\sqrt2} \left|1\right&gt;$$",<qiskit><programming>,09/11/2020 03:28,,,,
13715.0,What is the significance of varying the number of shots while running a circuit in a quantum machine and qasm simulator?,what is the significance of varying the number of shots while running a circuit in a quantum machine and qasm simulator? Does more number of shots give better/accurate result? I am running a simple 2 qubit measurement circuit after Hadamard gates on both qubits.,<qiskit><programming><ibm-q-experience>,09/12/2020 09:35,,,,
13733.0,Implementing a circuit that returns $|01\rangle$ and $|10\rangle$ with equal probability,"Using Python how can I implement a quantum circuit that returns $|01\rangle$ or $|10\rangle$ using only $CX$, $RX$ and $RY$ gates, starting with random parametric gates as parameters and optimizing it using gradient descent or other optimization algorithm?",<quantum-gate><programming><circuit-construction><optimization><random-quantum-circuit>,9/13/2020 18:39,,,,
13763.0,Why running time of qasm simulator is significantly smaller in comparison with quantum machines?,"I ran a 3-qubit measurement circuit on QASM simulator as well as on IBM Q Melbourne, Santiago and Vigo machines. The running time on the simulator is in few milliseconds (400-800) while in the case of all three quantum machines the running time is in seconds (4-13). Why such a large difference as it does not give a clear picture of simulators' accuracy in comparison to realized of quantum hardware?",<programming><ibm-q-experience><simulation><qasm>,9/16/2020 3:55,,,,
13777.0,Hadamard gate for three qubits; inconsistency between IBM and Matlab,"I am trying to build a large and quite complex three qubit quantum circuit on IBMs quantum computer. I have a specific unitary which I am trying to implement and I am building a circuit following the paper 'Realisation of a general three qubit quantum unitary'. I am checking the unitary at each stage of the circuit on Matlab, just to make sure I fully understand it, but I have come across something which I cannot explain. I have split the circuit into two unitaries, $U_a$ and $U_b$ and for each unitary separately my IBM unitary agrees with my Matlab unitary,however when I combine the two circuits in IBM and multiply the two unitaries in Matlab I get different results. The problem boils down to an issue I am having with the Hadamard gate. Consider the following two IBM circuits #both independently correct circuit2 = QuantumCircuit(3); circuit2.u3(1,1,1,2); job = execute(circuit2, backend) job.result().get_unitary(circuit2, decimals=6) i.e. a three qubit circuit where a unitary acts on the final qubit (IBM's final qubit is the first qubit in more widely used bra-ket notation), and the second circuit is: #both independently correct circuit2 = QuantumCircuit(3); circuit2.h(2) job = execute(circuit2, backend) job.result().get_unitary(circuit2, decimals=6) i.e. a three qubit circuit with a Hadamard gate on the final qubit. These produce the following two unitaries 0.8776 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.2590 - 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.8776 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.2590 - 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.8776 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.2590 - 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.8776 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.2590 - 0.4034i 0.2590 + 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.3652 + 0.7980i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.2590 + 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.3652 + 0.7980i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.2590 + 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.3652 + 0.7980i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.2590 + 0.4034i 0.0000 + 0.0000i 0.0000 + 0.0000i 0.0000 + 0.0000i -0.3652 + 0.7980i 0.7071 0 0 0 0.7071 0 0 0 0 0.7071 0 0 0 0.7071 0 0 0 0 0.7071 0 0 0 0.7071 0 0 0 0 0.7071 0 0 0 0.7071 0.7071 0 0 0 -0.7071 0 0 0 0 0.7071 0 0 0 -0.7071 0 0 0 0 0.7071 0 0 0 -0.7071 0 0 0 0 0.7071 0 0 0 -0.7071 I have taken these unitaries from my Matlab code, not the IBM output but they are the same in both softwares. Now the bizarre part is when I multiply these unitaries in Matlab using the following code function test=utottest(x) x1=[1,1,1]; Hadamard=1/sqrt(2)*[1 1;1 -1]; R1=kron(U1IBM(x1),eye(4)); R12=kron(Hadamard,eye(4)); test=R12*R1; function U1=U1IBM(x) % single qubit unitary th=x(1); phi=x(2); lam=x(3); U1=[cos(th/2) -exp(i*lam)*sin(th/2); exp(i*phi)*sin(th/2) exp(i*lam+i*phi)*cos(th/2)]; end end the unitary produced is different to that produced by the following IBM circuit circuit2 = QuantumCircuit(3); circuit2.u3(1,1,1,2); circuit2.h(2) job = execute(circuit2, backend) job.result().get_unitary(circuit2, decimals=6) I do not understand what is happening here. Can anyone explain/reconcile this difference?",<qiskit><programming><matrix-representation><unitarity><hadamard>,9/16/2020 22:57,,,,
13778.0,Implementing Cirq Coding Gates,Can someone please help me making these gates on CIRQ programming: Decrement Gate (-1) Splitter Gate (If possible) I was having trouble implementing these and was not sure if it's possible either. Thanks in advance.,<quantum-gate><programming><circuit-construction><cirq>,9/16/2020 23:58,,,,
13798.0,Custom Gate/Instruction with classical bits in Qiskit,"In Qiskit, I need to define a custom gate or instruction that, once decomposed, turns into a series of basis gates, including measurements and classically controlled gates (this is the part that I can't get around). I already tried using QuantumCircuit.to_gate(), but it does not work, maybe there is a way to it with the Instruction class? Edit 1 I tried to do something like this: from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister def mygate(): qr = QuantumRegister(4) cr1 = ClassicalRegister(1) cr2 = ClassicalRegister(1) qc = QuantumCircuit(qr, cr1, cr2, name='mygate') qc.measure(qr[0], cr1[0]) qc.measure(qr[1], cr2[0]) qc.x(qr[-2]).c_if(cr1, 1) qc.x(qr[-1]).c_if(cr2, 1) return qc.to_instruction() big = QuantumCircuit(5, 4) big.append(mygate(), range(4), range(2)) But it does not work. qiskit.exceptions.QiskitError: 'Cannot convert condition in circuit with multiple classical registers to instruction'",<quantum-gate><qiskit><programming>,9/17/2020 22:59,,,,
13846.0,Converting 'string' to a function/gate in QisKit,I want to give a list of Quantum gates in a .txt file from user an apply them to a Quantum circuit but the gates in notepad .txt file have 'string' type while in Qiskit I need functions/methods. For example: In .txt file: 'h(0)' In Qiskit: qc=QuantumCircuit(2) qc.h(0) Which is a method. What can I do?,<qiskit><programming><circuit-construction>,9/20/2020 19:09,,,,
13884.0,How to perform a time evolution of a quantum state with Qiskit Aqua?,How can we perform a time evolution of a quantum state for a given Hamiltonian with qiskit Aqua operator flow? I'm interested in it due to its higher efficiency.,<qiskit><programming><ibm-q-experience>,9/23/2020 8:37,,,,
13961.0,Initialising impure density matrices,"I wish to initalise the state $\rho=(1-\frac{p}{2})|0\rangle \langle0|+\frac{p}{2}|1\rangle\langle1|$, where p is some measure of decoherence. This is a mixed state. There are some suggestions on here for how to implement this with ancilla qubits and extra gates. However I am now trying to run a quantum circuit with this as my initial state on the actual IBM quantum computers. The problem is that to intialise two qubits in this state requires 6 ancilla qubits using my current approach, meaning I have to use the Melbourne quantum computer which has moderately high gate error rates. It also increases my circuit depth. In order to simplify my circuit I tried something like this r=random.choices([0,1],weights=(1-p/2,p/2),k=1) r.append((r[0]+1)%2) circuit2 = QuantumCircuit(3,3); circuit2.initialize(r,0) circuit2.initialize(r,1) Although this is statistically correct over many runs it does not give what I want. In each run of the quantum circuit (say 1000 shots), the same intial state is used for all 1000 shots. Is there any way I can make it so that the circuit reevaluates what the initial state should be for each shot? I do not wish to have to set the number of shots to 1 and evaluate the circuit thousands of times, as the queue time to get my circuit evaluated would be huge.",<qiskit><programming><density-matrix>,9/30/2020 7:57,,,,
13969.0,Wrong Expectation value when implementing a VQE for the Heisenberg Hamiltonian,"I tried to implement an extended Heisenberg-Hamiltonian as an extra exercise further than my homework. My Hamiltonian is the following: $H = \sum_{NN} \sigma_x\sigma_x + \sigma_z\sigma_z$ I try to implement this in Cirq on a GridQubit-square with 4 qubits. Following problem: I calculated the ground state via the matrices analytically and tried to implement the problem in a circuit: I used cirq.XXPow- Gates and cirq.ZZPow Gates and cirq.XPow, cirq.ZPow. I used an if condition to determine if I measure in Z,Y or X basis. In Z, I append just the measurement, In Y I append X**0.5 to the circuit and in X, I append a Hadamard-Gate. Now I let the simulator run and get the probabilities and signs from the histograms. I sum the probabilities times the sign. Now I sum the expectation values in X-, Y- and Z-basis and use a classical optimizer. My problem is that this does not work properly. Either the expectation value is way too big or way too small. Where is my error in reasoning? I think I did something wrong with the mechanism.",<programming><textbook-and-exercises><cirq><vqe>,9/30/2020 14:15,,,,
13981.0,Noise model for 3 Qubit $|GHZ \rangle$ state measurement circuit,"I found this example code in Qiskit documentation. Does this code signify that it is simulating noise as per the IBM Valencia quantum chip. If yes, what kinds of noise does it simulate? I executed the code below in the quantum lab and analyzed noise in qubit measurement in various quantum machines. from qiskit import QuantumCircuit, execute from qiskit import IBMQ, Aer from qiskit.visualization import plot_histogram from qiskit.providers.aer.noise import NoiseModel provider = IBMQ.load_account() backend = provider.get_backend('ibmq_valencia') noise_model = NoiseModel.from_backend(backend) coupling_map = backend.configuration().coupling_map basis_gates = noise_model.basis_gates circ = QuantumCircuit(3, 3) circ.h(0) circ.cx(0, 1) circ.cx(1, 2) circ.measure([0, 1, 2], [0, 1, 2]) result = execute(circ, Aer.get_backend('qasm_simulator'), coupling_map=coupling_map, basis_gates=basis_gates, noise_model=noise_model).result() counts = result.get_counts(0) plot_histogram(counts)",<programming><ibm-q-experience><measurement><noise>,10/01/2020 15:03,,,,
13988.0,qasm_simulator generating identical results repeatedly,"I wish to run a very simple circuit on the qasm_simulator backend. My circuit is circuit2 = QuantumCircuit(2,2); circuit2.u3(pi/2,pi,3*pi/4,1) circuit2.u3(pi/2,pi,7*pi/4,0) #u2 circuit2.cx(0,1) #u3 circuit2.rz(3*pi/4,1) #u4 circuit2.cx(1,0) #u5 circuit2.ry(pi/2,0) #u6 circuit2.cx(0,1) #u7 circuit2.u3(0,pi*0.8252172,-pi*0.4247820,1) circuit2.u3(pi/2,0,pi/2,0) circuit2.measure(0,0); circuit2.measure(1,1); The circuit works as I expect and generates the output I expect but I have a question about the workings of the simulator. When I run the following code: backend = BasicAer.get_backend('qasm_simulator') for x in range(10): Cfin=circuit2; job = execute(Cfin, backend, shots=1000) res=job.result().get_counts(Cfin) print(res) I get a series of results that look something like this {'11': 274, '10': 256, '01': 229, '00': 241} {'11': 274, '10': 256, '01': 229, '00': 241} {'11': 274, '10': 256, '01': 229, '00': 241} {'11': 274, '10': 256, '01': 229, '00': 241} {'11': 274, '10': 256, '01': 229, '00': 241} {'11': 274, '10': 256, '01': 229, '00': 241} {'10': 241, '01': 224, '00': 286, '11': 249} {'11': 240, '01': 246, '10': 233, '00': 281} {'11': 240, '01': 246, '10': 233, '00': 281} {'11': 240, '01': 246, '10': 233, '00': 281} I am curious as to why the simulator returns identical results for a few runs in a row. This happens regularly. The simulator appears to get stuck on one particular result for a while. Does anyone know what is the cause of this? Will there be a similar issue if I try to run this code on one of the real quantum computers?",<qiskit><programming><ibm-q-experience>,10/02/2020 00:31,,,,
13989.0,Qiskit - difference between qasm_simulator and statevector_simulator in terms of memory and speed?,"I'm trying to profile qiskit backends and I use randomized_benchmarking provided by qiskit.ignis. Initially I ran a circuit with 20 qubits 100 length on statevector_simulator, which takes around 180s and qubits can go up to 32 and then it runs out of memory. Then I tried qasm_simulator and it only takes 2s to finish and can run up to 54+ qubits. Why does qasm_simulator perform so much better than statevector_simulator? Does this happen because the circuit only contains simple gates?",<qiskit><programming>,10/02/2020 04:45,,,,
14026.0,Issue with running a circuit: Cannot read property 'idCode' of null,"I have been trying to run simple circuits from the Circuit Composer, both on a real quantum comp and on a simulator. Every time I get this error message: Could not run circuit &quot;&quot; Cannot read property 'idCode' of null Could you please clarify what this means? I tried logging out and in, but nothing seems to work.",<programming><circuit-construction>,10/05/2020 19:55,,,,
14040.0,Why VQE gives an incorrect ground state energy for a chain of 4 hydrogen atoms?,"I am a bit hesitant to ask this very specific question, as I feel other people need not benefit from it. But since I have struggled for a while, and I think I should get some help. So I am using VQE in qiskit to calculate the ground sate energy of a chain of hydrogen atoms, but it appears that the result is in-consistent with the result from exact diagonalization. The code works well for other molecules like H2, LiH, so this is confusing. I guess the question boils down to how to set the threshold for the VQE. I have attached the code below, and many thanks for the help! from qiskit import BasicAer import logging from qiskit.chemistry import set_qiskit_chemistry_logging set_qiskit_chemistry_logging(logging.ERROR) # chemistry related modules from qiskit.chemistry import FermionicOperator from qiskit.chemistry.drivers import PySCFDriver, UnitsType from qiskit.aqua.algorithms import VQE, NumPyEigensolver import numpy as np from qiskit.chemistry.components.variational_forms import UCCSD from qiskit.chemistry.components.initial_states import HartreeFock from qiskit.aqua.components.optimizers import L_BFGS_B from qiskit.aqua.operators import Z2Symmetries def get_qubit_op(atom,basis,map_type ): driver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, charge=0, spin=0, basis=basis) molecule = driver.run() num_particles = molecule.num_alpha + molecule.num_beta num_spin_orbitals = molecule.num_orbitals * 2 ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals) qubitOp = ferOp.mapping(map_type=map_type, threshold=0.00000001) qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles) return qubitOp, num_particles, num_spin_orbitals import timeit start = timeit.default_timer() atom = 'H .0 .0 .0; H .0 .0 1.5 ; H .0 .0 3.0 ; H .0 .0 4.5 ' basis='sto3g' map_type = 'parity' qubitOp, num_particles, num_spin_orbitals = get_qubit_op(atom,basis,map_type ) print('Ground state energy is' , NumPyEigensolver( qubitOp ).run().eigenvalues ) init_state = HartreeFock( num_spin_orbitals , num_particles , map_type ) # set the backend for the quantum computation= backend = BasicAer.get_backend('statevector_simulator') # setup a classical optimizer for VQE optimizer = L_BFGS_B() print( init_state.bitstr ) var_form_vqe = UCCSD( num_orbitals=num_spin_orbitals, num_particles=num_particles, initial_state=init_state, qubit_mapping=map_type ) algorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer ) result_vqe = algorithm_vqe.run(backend) print( 'eigenvalue = ' , result_vqe['eigenvalue' ] ) stop = timeit.default_timer() print('The run time of this part: ', stop - start) The output is below, and as you can see, they differ quite significantly. Ground state energy is [-3.52488449+5.88070795e-18j] [False False True False False True] eigenvalue = (-3.523526951494827+0j) The run time of this part: 57.303660957000034",<qiskit><programming><hamiltonian-simulation><vqe><chemistry>,10/06/2020 17:58,,,,
14077.0,An effective way to submit all the jobs for VQE/QAOA at a time to an IBMQ machine?,"In Qiskit, I am solving a VRP for 5 nodes and it creates 20 variables for a QUBO. It runs in a 65 qubit machines (any machine below that many fails). Now, in such a typical solvers for optimization (VQE, QAOA etc.) more than 100 circuits are run in a machine. With max_evals we can run a bunch of these in the IBMQ machines to gain on wait time. I am wondering if there is pros/cons of using 1 circuit at a time or max_evals set to max_iter or is there a thumb-rule to select the optimum max_evals? One pro is obviously we can avoid the wait-time in queue. But is there any other cons? Also, what is the most effective way to run such a QUBO, so that all the jobs cann be submitted at a time to the machine, so that there is no wait time?",<qiskit><programming><ibm-q-experience><vqe><qaoa>,10/09/2020 19:22,,,,
14082.0,"How to set 'max_parallel_threads', 'max_parallel_experiments' for BACKEND_OPTIONS in QuantumInstance","In QuantumInstance there are max_parallel_threads, max_parallel_experiments in BACKEND_OPTIONS - Wondering whether the backend I am using supports parallel-threads or experiments and how to use this features? How do I find out whether my backend supports this?",<qiskit><programming>,10/10/2020 10:08,,,,
14156.0,How to use VQE function in Qiskit,"As part of a project I'm working on, I want to use VQE algorithm to calculate the minimal eigenvalue for given Hamiltonian. I use Qiskit on IBM UI online. The Hamiltonian is given as a sum of tensor products $H = Z\otimes Z + Z \otimes X + ...$ I don't understand two main points: How should I pass the Hamiltonian to the VQE? should I pass it as a list? i.e. $ H = [Z\^Z, X\^Z]$? I understand that I need to create N circuits, where N is the number of tensor products which constitute the Hamiltonian, so that each circuit will handle another part of the Hamiltonian. Do I understand this correctly? Thank you.",<qiskit><programming><vqe>,10/14/2020 20:19,,,,
14193.0,JSONDecodeError with backend.run,"I'm trying to follow tutorial on pulse simulation described in qiskit.org. The generated PulseQobj is well executed with AER simulator, but it throws JSONDecodeError when using real backends (ex. ibmq-armonk). The PulseQobj passed the validation (validate_qobj_against_schema), so I'm struggling to find the reason. Qobj, generated by QuantumCircuit command, does not raise this error. I connected to real device with APItoken, and qiskit version is up to date (qiskit 0.22.0). Below is the trial code with real device, and log after backend.run(PulseQobj) %matplotlib inline import numpy as np from qiskit.ignis.characterization.calibrations import rabi_schedules, RabiFitter from qiskit.pulse import DriveChannel from qiskit.compiler import assemble from qiskit.qobj.utils import MeasLevel, MeasReturnType from qiskit import IBMQ IBMQ.enable_account(APItoken, proxies = ProxyConfig, verify = certPath) provider = IBMQ.get_provider(hub=hub, group=group, project=project) backend = provider.get_backend(device) # qubit list qubits = [0] # drive amplitudes to use num_exps = 64 drive_amps = np.linspace(0, 1.0, num_exps) # drive shape parameters drive_duration = 2048 drive_sigma = 256 # list of drive channels drive_channels = [DriveChannel(0)] # construct the schedules rabi_schedules, xdata = rabi_schedules(amp_list=drive_amps, qubits=qubits, pulse_width=drive_duration, pulse_sigma=drive_sigma, drives=drive_channels, inst_map=backend.defaults().instruction_schedule_map, meas_map=backend.configuration().meas_map) rabi_qobj = assemble(rabi_schedules, backend=backend, meas_level=1, meas_return='avg', shots=512) result = backend.run(rabi_qobj).result() --------------------------------------------------------------------------- JSONDecodeError Traceback (most recent call last) &lt;ipython-input-17-16f293a93614&gt; in &lt;module&gt; ----&gt; 1 result = backend.run(rabi_qobj).result() JSONDecodeError: Expecting value: line 1 column 1 (char 0)",<qiskit><programming><ibm-q-experience>,10/16/2020 10:12,,,,
14199.0,How can I convert arithmetic operations in a code to quantum format?,"def SSGSM(im): log_image=np.log(1+np.float32(im)) gx=cv2.Sobel(log_image,cv2.CV_64F,1,0,ksize=3) gy=cv2.Sobel(log_image,cv2.CV_64F,1,0,ksize=3) ex=np.exp(-1*abs(gx)) ey=np.exp(-1*abs(gy)) vx=np.multiply(gx,ex) vy=np.multiply(gy,ey) vx=np.multiply(vx,vx) vy=np.multiply(vy,vy) v_=vx+vy v=np.sqrt(v_) return v I need to convert this code into a quantum format..could anyone help me please?",<qiskit><programming><quantum-algorithms>,10/16/2020 14:52,,,,
14215.0,Simulation of Noise in a particular quantum computer,"I wish to be able to model a quantum computer with all the noise sources of an IBM quantum computer. For a given set of T1, T2, readout_errors, U2_errors and CNOT errors I want to know how to include all these errors. I can run a quantum circuit using the expected noise from a particular computer through the following code backend = provider.get_backend('ibmqx2') noise_model = NoiseModel.from_backend(backend) # Get coupling map from backend coupling_map = backend.configuration().coupling_map # Get basis gates from noise model basis_gates = noise_model.basis_gates This runs my code with the noise from ibmqx2. I then try to implement each noise source. For example if the single qubit U2 error rate is er1, I implement this as follows: error_1 = noise.depolarizing_error(er1, 1) noise_model.add_quantum_error(error_1, ['u1', 'u2', 'u3','h'],[0]) I implement the two qubit and readout errors in the same way. Is this correct? Also how do I implement the errors associated with the T1 and T2 values? I am asking because my current model when I add each noise source myself does not match when I simply import the noise model. I wish to reconcile this.",<qiskit><programming><noise>,10/17/2020 10:02,,,,
14224.0,Qiskit BasicAer & Aer,"While I'm simulating grover's algorithm, I found that with BasicAer backend it works well but with Aer it is not. What is the difference between qiskit.providers.BasicAer and qiskit.providers.Aer ?",<qiskit><programming><grovers-algorithm><simulation>,10/18/2020 6:00,,,,
14236.0,Grover's algorithm with matrix_product_state method,,<qiskit><programming><grovers-algorithm>,10/18/2020 14:07,,,,
14249.0,Simulating noise of googles quantum computers,Is there a way to simulate the noise of googles quantum computers using circ? In the same way that any of IBM's computers can be simulated using different backends? backend = provider.get_backend('ibmqx2') noise_model = NoiseModel.from_backend(backend) Ideally I would want something like above which allows me to easily call the noise properties of for example Bristlecone or Sycamore. If this is not possible does anyone know the best way to approach simulating the noise of any of googles quantum computers in qiskit? I am asking because I wish to compare Google and IBMs quantum computers for implementing a simple circuit.,<qiskit><programming><noise><ibm-quantum-devices><google-sycamore>,10/19/2020 7:13,,,,
14305.0,Partial Measurement of Quantum Circuit in Qiskit,"I want to do partial measurement of quantum circuit containing two qubits in entangled state. I want to first measure one qubit and record the result. Thereafter, record the measurement of second qubit and compare the two. Mathematically, the two should come out to be same. How to do the same on Qiskit using Python?",<qiskit><programming><measurement>,10/23/2020 7:18,,,,
14337.0,Cannot get the counts of a job in Qiskit with the usual command,When I use job.result().get_counts I am getting this result: &lt;bound method Result.get_counts of &lt;qiskit.result.result.Result object at ...&gt;&gt; but no counts at all. I have tested it both with a new job and with an old one and in both cases the counts are not shown.,<qiskit><programming>,10/26/2020 8:52,,,,
14470.0,What is the proper way of doing Pauli arithmetic in Qiskit?,"To my understanding, the WeightedPauliOperator class in discontinued, and should no longer be used when dealing with Pauli operators. So how should I perform arithmetic with paulis? $$ ( 3 X_1 Y_3 + 5 Z_2 X_0 ) (Z_3+2X_2X_4) = \ \text{(expanded version)} $$",<qiskit><programming>,11/03/2020 17:39,,,,
14497.0,How to get a molecular Hamiltonians in OpenFermion,I want to get a jordan_wigner_hamiltonians of a molecule-ion by using jordan_wignerget_fermion_operator(molecule.get_molecular_hamiltonian()). But I can only get the molecular Hamiltonians no matter how I set the charge and multiplicity. How I can get a molecular Hamiltonians which have more (or less) electrons for example HeH+?,<programming><hamiltonian-simulation><openfermion>,11/05/2020 13:45,,,,
14585.0,Usage of Tensorflow/Keras to train Qiskit circuits,"In order to explore whether it is possible to train a Qiskit Quantum circuit with tensorflow I built a small toy model. The purpose of this toy model is to find via tensorflow the correct angle to get &quot;zero&quot; output independent of the input. import numpy as np import qiskit from qiskit.circuit import QuantumCircuit, QuantumRegister import tensorflow as tf from tensorflow.keras.layers import Input, Dense, Layer def QuantumCircuit(thetas, n_qubits=1): simulator = qiskit.Aer.get_backend('qasm_simulator') shots=1024 circuit= qiskit.QuantumCircuit(n_qubits) circuit.h(0) circuit.ry(float(thetas),0) circuit.measure_all() job = qiskit.execute(circuit,backend=simulator,shots=shots) result = job.result().get_counts(circuit) counts = np.array(list(result.values())) states = np.array(list(result.keys())).astype(float) # Compute probabilities for each state probabilities = counts / shots # Get state expectation expectation = np.sum(states * probabilities) return np.array(expectation) class Linear(Layer): def __init__(self,units=1,input_dim=1): super(Linear,self).__init__() self.w = self.add_weight(shape=(input_dim,units),initializer='random_uniform', trainable=True) def call(self, inputs, input_dim=1): if (tf.executing_eagerly()): return QuantumCircuit(self.w) return inputs x_train = np.arange(10) y_train = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) inputs=Input(shape=(1,)) outputs=Linear()(inputs) model=tf.keras.models.Model(inputs=inputs,outputs=outputs) model.summary() model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.01), loss=tf.keras.losses.MeanSquaredError()) model.fit(x_train, y_train, epochs=100, batch_size=1, verbose=1) Unfortunately the toy model doesn't work and I get the following error: optimizer_v2.py:1219 _filter_grads ([v.name for _, v in grads_and_vars],)) ValueError: No gradients provided for any variable: ['Variable:0']. So I tried to calculate the gradient &quot;by myself&quot;: @tf.custom_gradient def custom_activation(w): result = QuantumCircuit(w) def grad(dy): eps=0.0001 result1=QuantumCircuit(w) result2=QuantumCircuit(w+eps) grad=(result2-result1)/eps return dy * [grad] return result, grad as an intermediate step before the Quantum circuit is called. But this works out neither :-( Does anybody have another idea to plug in Qiskit circuits into tensorflow and to deal with the fact that the automatic differentiation framework of tensorflow does not work in this case ? Thanks a lot !!",<qiskit><programming><quantum-enhanced-machine-learning>,11/11/2020 14:15,,,,
14596.0,Is there a quantum circuit to find the maximum of two inputs?,Is there a quantum circuit (preferably on Quirk as an example) that will enable me to find the maximum from two inputs? Example input A: 11011 input B: 11100 Expected output: 11100,<programming><circuit-construction><optimization>,11/12/2020 01:46,,,,
14597.0,Qiskit programming: convert qubit to quantum register,"When simulating quantum circuits in Qiskit, sometimes you need to build your own operation. And when you are doing so you would like to save the computational cost, but the QuantumCircuit object takes only QuantumRegister object as input(while rejects the qubit object) and this might be cumbersome. For instance, see the code: def swappedOp(obj,qr0,qr1,index): circ=QuantumCircuit(qr0,qr1) circ.swap(qr0[qr0.__len__()-1],qr1[index]) circ.append(obj,[qr0[i] for i in range(qr0.__len__())]+[qr1[i] for i in range(qr1.__len__())]) circ.swap(qr0[qr0.__len__()-1],qr1[index]) return Operator(circ) In this code, my input obj is a random unitary, and what this function does is to swap the action of two qubits(in this code, it swaps the last qubit of qr0 and qr1[index]) and the latter swap makes sure that in other operations the sequence is unchanged. The needed action of the random unitary(or say obj) is taken place between all qubits in qr0 and one qubit in qr1, but to actually implement this operation in Qiskit I have to expand it to action between all qubits of the two quantum registers because the QuantumCircuit object only takes QuantumRegsiter as input (not qubit) and this is computationally inefficient. So what I want to know is: is there a way to convert between qubit object and QuantumRegister object? If so, this can be time-saving!",<qiskit><programming>,11/12/2020 02:32,,,,
14617.0,"Is there an explanation for why, to search through an unstructured database, the average number of checks is $\frac{N}{2}$ in classical computation?","I have came across many books online that all explain that if $N$ is large enough, then the average number of checks in $N/2$ but is there a mathematical explanation or derivation for why this is true? I have considered when $N=2^n$ and tried to use logarithms but am not getting anywhere with this. Any help would be greatly appreciated Sorry, I should have made it clear... I was referring to Grover's search algorithm and how I can show that if $N$ is large enough, then the average number of checks is $N/2$. I know I will have to check $N$ objects in the worst-case scenario",<grovers-algorithm><classical-computing>,11/13/2020 11:41,,,,
14665.0,Parallel shots on Qiskit,"I am running variational algorithms using QuasmSimulator, which means I am performing a classical optimization where the cost function is computed running a quantum circuit. Moreover, for the optimizer to converge I need high accuracy, which implies a large number of shots. These two things combined make a run last for days on my laptop, even for a few qubits. Thus, I am trying to run shots in parallel to save some time. Qiskit has a backend option for this: from qiskit.providers.aer import QasmSimulator backend = QasmSimulator(method=&quot;automatic&quot;, max_parallel_threads=6, max_parallel_shots=6) ... the rest of the code... job = execute(circ, backend, shots=nshots) However, when setting this option I see no difference, neither in runtime nor in CPU usage from Window's task manager. I think the problem could be that normally a python script just uses one core, so when Qiskit runs it &quot;thinks&quot; that indeed you have one core only. Any suggestion? I am using Qiskit 0.23.0 (Note that I asking specifically about parallel shots and not parallel circuits, although that might also help with another issue I have)",<qiskit><programming>,11/16/2020 9:15,,,,
14728.0,Length / transpilation issues with Grover's algorithm,"I would like to discuss the discrepancies between what we see in the simulator versus what we see in the actual running of the code on any IBMQ machine for any qubits at 5 or above. I am doing a final project on grover's algorithm, and the premise would require an extremely large number of qubits. I have tested my theory on the simulators up to 26 qubits (took 6 hours), and they are ~100% accurate. When I went to test the theory using the exact same circuit, I couldn't get a circuit of 4 qubits to even deviate from statistical random distrubution. First of all, I have used Qiskit and Q# to create the exact same algorithm. If you could provide me with a methodology that would allow for easier work / do the work for the transpiler on qiskit, or the ability to utilize a real quantum computer in Q#, I would appreciate it. Currently the transpiler in qiskit / IBMQ for grover's algorithm is limited to around 6-7 qubits. I don't like that I don't have more gates available. Regardless of this issue, I get garbage results for an oracle / ancilla at or larger than 4 qubits total. Why is is that the transpiler / decoherance that is occuring within the circuit is so terrible that I cannot construct Grover's algorithm using gates at or larger than 4 qubits? The probabilties of the simulators themselves are upwards of 99%, but even after a two qubit Grover's algorithm, it shows as only 40ish %? When I go to three qubits, the entire algorithm is garbage, and I cannot provide ANY accuracy other than a random distribution, and when I tabulated it the accuracy was actually less than the statistical random distrubution. I'm not happy with what is going on here, as I cannot feasibly run anything of meaning on any IBMQ machine. I don't understand why the transpiler is inserting such a ludicrous range in the possible number of gates (about a hundred different possible gate configurations for 5 qubit Grover's algorithm) Is this an issue with the transpiler? Is this just an issue with general decoherance? I don't understand why the quantum computer can't peform a grover's algorithm of 5 or more. Please help me to understand what I am not getting here. Are the physical devices that far off from where I felt the technology was? I was hoping that a 15 qubit machine would be able to actually perform better, esp. in the 5 qubit realm. #initialization import matplotlib.pyplot as plt import math import numpy as np # importing Qiskit from qiskit import ClassicalRegister, QuantumRegister from qiskit.providers.ibmq import least_busy from qiskit.quantum_info import Statevector from qiskit.providers.aer import QasmSimulator # import basic plot tools from qiskit.visualization import plot_histogram def initialize_s(qc,qubits): &quot;&quot;&quot;Apply a H-gate to 'qubits' in qc&quot;&quot;&quot; for q in qubits: qc.h(q) return qc def numberofiterations(nqubits): temp = 2 ** nqubits; squareRoot = math.sqrt(temp) iterations = round(squareRoot) return iterations def oracle(nqubits): q = QuantumRegister(nqubits) qc = QuantumCircuit(q) #set the oracle's 0 bits qc.x(q[1]) qc.x(q[2]) #qc.x(q[5]) #qc.x(q[7]) #qc.x(q[8]) #qc.x(q[12]) #qc.x(q[13]) #qc.x(q[15]) #qc.x(q[19]) #qc.x(q[20]) #qc.x(q[21]) #qc.x(q[22]) #qc.x(q[24]) qc.h(q[nqubits-1]) #[0,3,4,6,9,10,11,14,16,17,18,23,26,27],30,ancilla_qubits=None, mode='noancilla') #qc.mcx([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],q[25],ancilla_qubits=None, mode='noancilla') #qc.cx([0],[1]) qc.mcx([0,1,2],q[nqubits-1],ancilla_qubits=None, mode='noancilla') qc.x(q[1]) qc.x(q[2]) #qc.x(q[5]) #qc.x(q[7]) #qc.x(q[8]) #qc.x(q[12]) #qc.x(q[13]) #qc.x(q[15]) #qc.x(q[19]) #qc.x(q[20]) #qc.x(q[21]) #qc.x(q[22]) #qc.x(q[24]) qc.h(q[nqubits-1]) #return the oracle as a gate. oracle = qc.to_gate() oracle.name = &quot;U$_\omega$&quot; return oracle def diffuser(nqubits): qc = QuantumCircuit(nqubits) # Apply transformation |s&gt; -&gt; |00..0&gt; (H-gates) for qubit in range(nqubits): qc.h(qubit) # Apply transformation |00..0&gt; -&gt; |11..1&gt; (X-gates) for qubit in range(nqubits): qc.x(qubit) # Do multi-controlled-Z gate qc.h(nqubits-1) qc.mcx(list(range(nqubits-1)), nqubits-1) # multi-controlled-toffoli #qc.cx([0],[1]) qc.h(nqubits-1) # Apply transformation |11..1&gt; -&gt; |00..0&gt; for qubit in range(nqubits): qc.x(qubit) # Apply transformation |00..0&gt; -&gt; |s&gt; for qubit in range(nqubits): qc.h(qubit) # We will return the diffuser as a gate U_s = qc.to_gate() U_s.name = &quot;$U_s$&quot; return U_s n = 4 qr = QuantumRegister(n-1, 'register') anc = QuantumRegister(1, 'ancilla') cr = ClassicalRegister(n-1, 'classical') grover_circuit = QuantumCircuit(qr,anc) grover_circuit = initialize_s(grover_circuit, list(range(n))) iterations = numberofiterations(n-1) for j in range(iterations ): grover_circuit.append(oracle(n), list(range(n))) grover_circuit.append(diffuser(n), list(range(n))) measure_circuit = QuantumCircuit(qr,cr) measure_circuit.measure(qr,cr) ```",<programming><ibm-q-experience><grovers-algorithm><simulation><compiling>,11/19/2020 21:22,,,,
14743.0,Recording the time taken by a VQE to find ground state energy,"I want to record the time that a VQE solver takes to find the ground state. At the moment I am using: %matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * import numpy as np import matplotlib.pyplot as plt import time # Loading your IBM Q account(s) and assigning backend IBMQ.load_account() provider = IBMQ.get_provider('ibm-q') qcomp = provider.get_backend('ibmq_valencia') #Imports for algorithm from qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule from qiskit.chemistry.transformations import FermionicTransformation, FermionicQubitMappingType from qiskit.aqua.algorithms import NumPyMinimumEigensolver from qiskit import BasicAer from qiskit.aqua import QuantumInstance from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory from qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver #Define molecule molecule = Molecule(geometry=[['H', [0., 0., 0.]], ['H', [0., 0., 0.735]]], charge=0, multiplicity=1) driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g') #Map fermionic hamiltonian to qubit hamiltonian transformation = FermionicTransformation(qubit_mapping=FermionicQubitMappingType.PARITY, two_qubit_reduction=True, freeze_core=True) #Initialize the VQE solver vqe_solver = VQEUCCSDFactory(QuantumInstance(backend = qcomp)) #Ground state algorithm calculation_VQE = GroundStateEigensolver(transformation, vqe_solver) #Calculate results start = time.time() VQE_result = calculation_VQE.solve(driver) end = time.time() time_difference = (end - start) print(VQE_result.total_energies) print(time_difference) However, after running this a few times on different IBM quantum machines, I am quite sure that the times I am recording are including the time spent waiting in queue to run the computations (but not completely certain on this). Is there any way to record the time taken by the VQE to compute the ground state energy without including queue time.",<programming><ibm-q-experience><vqe>,11/20/2020 14:48,,,,
14779.0,How to calculate the exponential of all elements in an input array using qiskit?,How can I perform an operation similar to Numpy.exp() in qiskit?,<qiskit><programming><quantum-algorithms><mathematics><measurement>,11/22/2020 5:29,,,,
14804.0,"How can I multiply two arrays like [1,2,3] and [4,5,6] in quantum computing aspects?",Multiplication of two arrays in quantum computing.,<quantum-gate><qiskit><programming><quantum-algorithms><measurement>,11/24/2020 4:54,,,,
14824.0,Error while trying to execute the Quantum Circuits in IBMQ,"I have been trying to execute the quantum circuit in the backend of the IBM 16 qubit Melbourne machine. I end up getting IBMQBackendApiError: 'Error submitting job: &quot;HTTPSConnectionPool(): Max retries exceeded with url: **** SignedHeaders= ** Signature= ****(Caused by SSLError(SSLError(1, \'[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:1108)\'))) but when I check my IBMQ account the status of the job is Creating. I do not understand why I get such an error. Can someone help to identify what exactly the issue is?",<qiskit><programming><ibm-q-experience><ibm-quantum-devices>,11/25/2020 3:24,,,,
14850.0,Quantum Circuit to inverse the probability distribution,"I'm using Qiskit and after running the circuit, as we all know, we get a count dictionary such as {'0000': 66, '0001': 71, '0010': 68, '0011': 70, '0100': 77, '0101': 64, '0110': 64, '0111': 51, '1000': 52, '1001': 67, '1010': 43, '1011': 64, '1100': 61, '1101': 59, '1110': 73, '1111': 74} Here the minimum count is 1010:43. I want the same output just reversed [1024-(count)]. I know this can be achieved by few lines of python, but I was curious if this is possible to do with a quantum circuit?",<programming><qiskit><quantum-algorithms><circuit-construction><probability>,11/26/2020 12:57,,,,
14865.0,Getting Choi-matrix of a subsystem,"In Qiskit, for a given QuantumCircuit object, you can compute its Choi-matrix via the corresponding Choi object, for example: myCircuit = QuantumCircuit(q1,q2) myChoi = Choi(myCircuit) My problem is, that code gives the Choi-matrix describing the whole system, but I'm interested to one subsystem, say the one associate to q1. What can I do? I would like to do something like myChoi = Choi(myCircuit, q1)",<programming><qiskit><quantum-operation>,11/27/2020 12:08,,,,
14867.0,Creating a parameterized Operator in Qiskit,"I'm trying to run a VQE for a specific custom Anzats. The Anzats is built up of an unitary matrix $U_H$, which I'm trying to created in this way: from qiskit import * from qiskit.circuit import Parameter from qiskit.quantum_info import Operator import math as m u_circuit = QuantumCircuit(2) # This does not work theta = Parameter('Î¸') U_H = Operator([ [m.cos(2 * theta) - 1j * m.sin(2 * theta), 0, 0, 0], [0, m.cos(2 * theta), -1j * m.sin(2 * theta), 0], [0, -1j * m.sin(2 * theta), m.cos(2 * theta), 0], [0, 0, 0, m.cos(2 * theta) - 1j * m.sin(2 * theta)] ]) u_circuit.unitary(U_H, [0, 1], label='U_H(Î¸)') U_H_gate = u_circuit.to_gate(label='U_H(Î¸)') However, for the VQE to work, the circuit needs to be parameterized, and because of that, so does the unitary gate U_H. Unfortunately, I'm not able to parameterize my variable Î¸ in my operator that I later transform into a 2-qubit gate. Also I can't find a way to bind theta so that it only exists between $0$ and $2\pi$. Whenever I try to build a circuit using this function to generate the gates in the Ansatz, I get the following error: ParameterExpression with unbound parameters ({Parameter(Î¸)}) cannot be cast to a float. Does anyone know how I can create a parameterized circuit consisting of parameterized gates of the form described by the matrix the U_H operator, where theta ranges from $0$ to $2\pi$?",<quantum-gate><programming><qiskit><vqe><unitarity>,11/27/2020 14:44,,,,
14917.0,How to measure a quantum circuit's execution time on a real IBM device?,"I am executing a quantum circuit on an IBM quantum device and I need to start a timer as soon as the job in the queue starts running. I have already used: result = job.result() execution_time = result.time_taken but in this particular case what I need is more like a &quot;signal&quot;, like a variable that is switched on as soon as the queue is over and causes the timer to start. I tried using the job status but it didn't seem to work.",<qiskit><programming><ibm-q-experience><ibm-quantum-devices>,12/01/2020 11:06,,,,
14926.0,Numerical optimization of QRAC,"I need to optimize a general version of 3$\rightarrow$1 QRAC where Bob is asked to retrieve one of the XOR combinations of the bits( If ABC is the given string to Alice, then Bob would be asked to retrieve one of the following functions, namely, A, B, C, A$\oplus$B, A$\oplus$c, B$\oplus$C, A$\oplus$B$\oplus$C). I know that build in optimization in Mathematica could be used for this kind of stuff, but I'm unsure how to proceed. Kindly ask if you have any confusion regarding my problem. Thanks",<programming><quantum-algorithms><bloch-sphere><qrac>,12/02/2020 07:54,,,,
14927.0,Maximum number of qubits supported by the Qasm simulator,"By using the Qiskit qasm-simulator, I want to simulate a quantum circuit of 40 qubits. However, the number of qubits 40 is greater than maximum number (24) for qasm-simulator. Is there any possibility to increase this number?",<qiskit><programming><resource-request>,12/02/2020 08:48,,,,
14938.0,Mechanism of measurement in IBM quantum devices,"I am trying to find out about the mechanism of measurement in IBM Q devices. To be specific, if I apply two Hadamard gates on the first qubit and identity on the second then is it possible to immediately measure so that the second qubit is not affected by the second Hadamard on the first qubit? Also, are measurements on qubits simultaneous? Does it differ with devices?",<quantum-gate><programming><qiskit><measurement><ibm-quantum-devices>,12/02/2020 23:32,,,,
14944.0,Classical optimisation of angles in QAOA for TSP gets stuck in local minima?,"I have been trying to implement a QAOA for solving a traveling salesman problem (TSP) using qulacs and python. However, even for 3 cities, the implementation fails. Within QAOA, we try to minimise $$ \begin{equation} F_p(\gamma,\beta) = \langle \gamma,\beta | C | \gamma,\beta\rangle, \end{equation} $$ where $C$ is the cost function of the TSP, and $|\gamma,\beta\rangle$ is a quantum state depending on these two angles. I had a closer look at my classical optimisation of the angles $\beta, \gamma$, for which I used the scipy.optimize.minimize function with the Nelder-Mead method. I realised that the resulting optimal angles are highly dependent on the initial angles. Additionally, I had a look at my cost function $C$. It seems like the optimisation got stuck in many local minima. I have seen several implementations of a QAOA TSP using other software frameworks, and most of them also used scipy.optimize.minimize for the angles optimisation. Is getting stuck in local minima a known issue for QAOA TSP, or do I have to search for another error source? If the first, how can I overcome this issue?",<programming><quantum-algorithms><qaoa>,12/03/2020 11:18,,,,
14997.0,Connectivity in Grover's algorithm on real quantum computers,"Everytime I execute Grover's search algorithm on IBM real quantum computers I get a wrong answer (it doesn't find the correct winner state) unless I use only 2 qubits. For any higher number of qubits it fails. I've already maximized the number of shots and tried with every free device. Also, the algorithm works perfectly in every simulation with any number of qubits. Could this be a connectivity problem? Do I need each qubit to be connected to all the other ones in the circuit for Grover's algorithm to work? Here is the Python code I am using. It implements a generalized Grover's algorithm for n qubits. import matplotlib.pyplot as plt import numpy as np from math import * from qiskit import * from qiskit.tools.visualization import circuit_drawer, plot_histogram from qiskit.quantum_info.operators import Operator def computational_basis(number_of_qubits, space_dimension): basis = [] for i in range(space_dimension): a = bin(i)[2:] l = len(a) b = str(0) * (number_of_qubits - l) + a basis.append(b) return basis def scalar_product(a, b): # Where a and b are two items of the &quot;basis&quot; list if a == b: return 1 else: return 0 def oracle_generator(space_dimension, winner_state): for i in range(space_dimension): if basis[i] == winner_state: mark = basis.index(basis[i]) oracle_matrix = np.identity(space_dimension) oracle_matrix[mark, mark] = -1 oracle = Operator(oracle_matrix) return oracle def diffuser_generator(space_dimension): diffuser_matrix = np.empty((space_dimension, space_dimension)) for i in range(space_dimension): for j in range(space_dimension): diffuser_matrix[i, j] = (2 * scalar_product(basis[i], basis[0]) * scalar_product(basis[0], basis[j])) - scalar_product(basis[i], basis[j]) diffuser = Operator(diffuser_matrix) return diffuser def grover_iteration(number_of_qubits, circuit, qr): all_qubits_list = [] for i in range(n): all_qubits_list.append(i) circuit.unitary(oracle, all_qubits_list, label='oracle') for i in range(number_of_qubits): circuit.h(qr[i]) circuit.unitary(diffuser, all_qubits_list, label='diffuser') for i in range(number_of_qubits): circuit.h(qr[i]) # Number of qubits n = 3 # Space dimension N = int(pow(2, n)) # Winner state winner = '111' # Make a list of computational basis vectors (strings) basis = computational_basis(n, N) # Build a quantum circuit for n-qubit Grover's algorithm oracle = oracle_generator(N, winner) diffuser = diffuser_generator(N) qr = QuantumRegister(n, 'q') cr = ClassicalRegister(n, 'c') grover_circuit = QuantumCircuit(qr, cr) for i in range(n): grover_circuit.h(qr[i]) if n == 2: grover_iteration(n, grover_circuit, qr) else: for i in range(int(sqrt(N))): grover_iteration(n, grover_circuit, qr) grover_circuit.measure(qr, cr) # Draw Grover circuit circuit_drawer(grover_circuit, output='mpl') plt.show() # Execute circuit IBMQ.load_account() provider = IBMQ.get_provider('ibm-q') qcomp = provider.get_backend('ibmq_valencia') job = execute(grover_circuit, backend=qcomp, shots=8192) result = job.result() # Results plot_histogram(result.get_counts(grover_circuit)) plt.show()",<qiskit><programming><grovers-algorithm><ibm-quantum-devices>,12/05/2020 19:21,,,,
15041.0,Get a sparse matrix of quantum circuit,"Is there a way that can obtain sparse matrix of quantum circuit? I used to check my quantum circuit with quantum_info.Operator, but for large number of qubits, it is difficult because of the memory allocation limit. Is it available in qiskit? or should I build elementary gates in sparse matrix format? Thank you!",<programming><qiskit><matrix-representation>,12/08/2020 00:13,,,,
15093.0,Transpiler in IBM Quantum devices,"I am having trouble understanding how the transpiler works in IBM quantum computers. I am studying the spatial noise correlation between two qubits in an IBM Q device. For that, I don't want the transpiler to change my input circuit. Is it possible to overwrite the transpiler? Can someone explain how the transpiler works?",<quantum-gate><programming><qiskit><quantum-algorithms>,12/10/2020 23:00,,,,
15216.0,Inequality constraints on D-Wave (using PyQUBO),"Inequalities cannot be directly converted into a QUBO form. By inequality, I mean something like this: 0â©½ Expression â©½ N. We can introduce a slack variable and convert it to an equality problem: â¹ Expression + s = N where: s â Z, s â [0,N] Since the slack variables, being encoded on a quantum computer, can hold only discrete values(0, 1, 2...N) the expression also must be of a discrete nature and be of the same values(0, 1, 2...N) to satisfy the constraint. How to encode inequality constraints when the expression is discrete but the values of the expression have sporadic (and maybe unknown) intervals(0, 1.2, 1.5, 3.8....N).",<programming><d-wave><qubo><pyqubo>,12/20/2020 17:24,,,,
15240.0,Qiskit: simulate a circuit using a backend noise model,"from qiskit import * def random_bitstring_generator(bit_number, backend): bitstring = &quot;&quot; one_qubit_random_bit_generator_circuit = QuantumCircuit(1, 1) one_qubit_random_bit_generator_circuit.h(0) one_qubit_random_bit_generator_circuit.measure(0, 0) for _ in range(bit_number): counts = execute(one_qubit_random_bit_generator_circuit, backend, shots=8192).result().get_counts() bit = list(counts.keys())[0] bitstring += bit return bitstring backend = BasicAer.get_backend('qasm_simulator') print(random_bitstring_generator(1024, backend)) How can i insert a noise model replicating IBM melbourne quantum machine for the circuit execution on simulator Is there a way to be able export the sequence received as output to an text/csv file",<programming><qiskit><ibm-q-experience><noise>,12/23/2020 8:41,,,,
15255.0,Differences between Extractors and Privacy Amplification for Quantum Random Generators,"We know that for the last step of QRNG: we need to separate quantum and classical noises from each other so we use extractors, after extractor we need privacy amplification step. At this point: if extractor is a strong extractor we can use it as a privacy amplification too. However I could not understand differences between extractor and privacy amplification. If I use the strong extractor for the second time, will I be able to complete my privacy amplification step? What will change in privacy amplification? If what happens, privacy amplification will be completed? Thanks",<programming><quantum-algorithms>,12/23/2020 22:33,,,,
15346.0,What is the best learning path for quantum computing?,Looking for a starter point for a professional training as a Quantum Computer programmer. Is a master in Computer Science XOR Applied Physics a good starting point?,<programming><resource-request>,12/31/2020 2:25,,,,
15387.0,How can I fix the BrokenProcessPool error in Qiskit?,"I'm running a set of quantum circuits using the ibmq_qasm_simulator. However, sometimes my code works for the simulation, but sometimes it doesn't, and the system shows me the following message: BrokenProcessPool: A process in the process pool was terminated abruptly while the future was running or pending. I don't know why am I always getting this error. My Python version is 3.7.8, is there a way I can fix this issue? Thanks!",<programming><qiskit><simulation>,01/03/2021 00:29,,,,
15417.0,Braket and Q# Simulators,"I have implemented Shor's algorithm in Qiskit, and everything works as expected within the IBM Q experience for both the IBM qasm_simulator and real hardware. However, after I've implemented Shors in both Q# and within Braket and attempt to run on either local simulator, the behavior is much more deterministic. On the Q# local simulator, Braket local simulator, Braket managed simulator, and Rigetti Aspen-8 hardware via Braket, however, I get the same results every time. Is this a difference in simulator behavior between IBM and others, or have I messed up somewhere in implementation? Any help would be greatly appreciated.",<programming><qiskit><ibm-q-experience><q#><shors-algorithm>,01/05/2021 02:47,,,,
15437.0,Random measurement of qubits,"from qiskit import * def qrng(bit_num, backend): bitstring = &quot;&quot; qrng_circuit = QuantumCircuit(5, 5) qrng_circuit.h(4) qrng_circuit.measure(4, 4) for _ in range(bit_num): counts = execute(qrng_circuit, backend, shots=8192).result().get_counts() bit = list(counts.keys())[0] bitstring += bit return bitstring backend = BasicAer.get_backend('qasm_simulator') print(qrng(1024, backend)) For the above code is supposed to generate a random sequence by measurement of some specific qubits. For example if i have a quantum circuit with 10 qubits which are all put in superposition using Hadamard gate but I want that the measurement method would be random (to be able to select say 2, 3, 5, 7, 8th qubit) leading to random bitstring being generated.",<programming><qiskit><ibm-q-experience><measurement>,01/07/2021 05:47,,,,
15442.0,Expectation value of operator - python,"I am suposed to solve following problem: Calculate the probability $P_n(x &gt; X)$ that a particle in then n-th eigenstate is found at a position with an x-value larger than X. Here it is convenient to formulate it as an expectation value of an operator. We make an operator $P(x &gt; X)$ which is a matrix with unity on the diagonal if $x &gt; X$. To do this I used the command &gt; which returns True if the number on the left is larger than the one on the right and False otherwise. To turn the True or False into 0 or 1 we use the method astype(int) on the NumPy array, which we then transform to an operator.T ake a few values of X, e.g. X= 3, 5, and 7, and plot $P_n(x &gt; X)$ as a function of $n$ (make sure that the box size $L$ is somewhat larger than $X$). The excercise continues as follow Explain what you see: Why is it low when $n$ is small? At which value ofnwould you expect $P_n(x &gt; X)$ to grow from a small to a large value? Hint :which energy would it require classically? My question is: How do I find the expectation value of the operator?",<programming><quantum-state><textbook-and-exercises>,01/07/2021 10:01,,,,
15459.0,Qiskit's c_if and conditioned operations on a real quantum computer,"Can Qiskit's c_if be used on a real quantum computer of IBM? And if it can, can it put a condition only on Qiskit gates like X, H, U1, U2, etc, or is there some way to make the conditioned operation to be a user defined operation, like a block of code, or a user defined gate? Is there other ways to do operations which are conditioned on the classical register measurements results, which will work on real quantum devices (or at least on a simulator)?",<programming><qiskit><ibm-quantum-devices>,01/10/2021 02:03,,,,
15543.0,"Why qiskit.execute runs much slower for inputs with multiple circuits, and how to speed it up?","I am using the &quot;execute&quot; in qiskit to run experiments for two circuits, and it turns out that &quot;execute&quot; runs much slower if the two circuits are run simultaneously, compared to if the circuits are run one at a time. Please see the codes below. Any idea why this happens and how to improve it? from qiskit import QuantumCircuit, Aer, execute import numpy as np import time pi = np.pi num_qubits = 2 theta = np.random.rand(1,2)[0] qc = QuantumCircuit(num_qubits) qc.u1( theta[0] , 0 ) qc.cx( 0,1 ) qc.u3( -pi/2 , -pi/2 , pi/2 , 0 ) qc.u2( 0 , pi , 1 ) qc.cx( 0,1 ) qc.u1( theta[1] , 1 ) qcz = qc.copy() qcz.measure_all() qcx = qc.copy() qcx.h(qcx.qubits) qcx.measure_all() # Using execute for the two circuits together start_time = time.time() results = execute([qcx,qcz], Aer.get_backend('qasm_simulator'), shots = 8192 ).result() print( results.get_counts() ) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) # Using execute for one circuit at a time start_time = time.time() resultx = execute(qcx, Aer.get_backend('qasm_simulator'), shots = 8192 ).result() resultz = execute(qcz, Aer.get_backend('qasm_simulator'), shots = 8192 ).result() print( resultx.get_counts() ) print( resultz.get_counts() ) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) and the outputs are [{'00': 4114, '01': 4063, '10': 9, '11': 6}, {'00': 2027, '01': 2055, '10': 2074, '11': 2036}] --- 11.244265079498291 seconds --- {'00': 4099, '01': 4084, '10': 5, '11': 4} {'00': 2047, '01': 2034, '10': 2073, '11': 2038} --- 0.29702305793762207 seconds ---",<programming><qiskit>,1/16/2021 3:56,,,,
15612.0,"How to convert a dataset of different values in [0,1000] to quantum data for training a model using Tensorflow QuantumHaving?","import sympy import cirq from cirq.contrib.svg import SVGCircuit import tensorflow_quantum as tfq import tensorflow as tf import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from tensorflow.keras.utils import to_categorical from tensorflow.keras import layers import os class CircuitLayerBuilder(): def __init__(self,data_qubits,readout): self.data_qubits=data_qubits self.readout=readout def add_layer(self,circuit,gate,prefix): for i,qubit in enumerate(self.data_qubits): symbol=sympy.Symbol(prefix+ '-' +str(i)) circuit.append(gate(qubit,self.readout)**symbol) demo_builder=CircuitLayerBuilder(data_qubits=cirq.GridQubit.rect(32,32),readout=cirq.GridQubit(-1,1)) circuit=cirq.Circuit() demo_builder.add_layer(circuit,gate=cirq.XX,prefix='xx') SVGCircuit(circuit) def create_quantum_model(): data_qubits=cirq.GridQubit.rect(32,32) readout=cirq.GridQubit(-1,1) circuit=cirq.Circuit() circuit.append(cirq.X(readout)) circuit.append(cirq.H(readout)) builder=CircuitLayerBuilder(data_qubits=data_qubits,readout=readout) builder.add_layer(circuit,cirq.XX, &quot;xx1&quot;) builder.add_layer(circuit,cirq.ZZ ,&quot;zz1&quot;) circuit.append(cirq.H(readout)) return circuit,cirq.Z(readout) def convert_to_circuit(filename): values=np.ndarray.flatten(filename) qubits=cirq.GridQubit.rect(32,32) circuit=cirq.Circuit() for i,value in enumerate(values): if value: circuit.append(cirq.X(qubits[i])) return circuit file =np.load('CWRU_48k_load_1_CNN_data.npz') data = file['data'] labels = file['labels'] category_labels = np.unique(labels) labels = pd.Categorical(labels, categories = category_labels).codes train_data, test_data, train_labels, test_labels = train_test_split(data, labels, test_size = 1000, random_state = 829, stratify = labels) # reshape data train_data = train_data.reshape(len(train_data),32,32,1) test_data = test_data.reshape(len(test_data),32,32,1) #train_labels = to_categorical(train_labels) #test_labels = to_categorical(test_labels) x_train_circ=[convert_to_circuit(x) for x in train_data] x_test_circ=[convert_to_circuit(x) for x in test_data] x_train_tfcirc=tfq.convert_to_tensor(x_train_circ) x_test_tfcirc=tfq.convert_to_tensor(x_test_circ) model_circuit,model_readout=create_quantum_model() model=tf.keras.Sequential([tf.keras.layers.Input(shape=(),dtype=tf.string), tfq.layers.PQC(model_circuit,model_readout), ]) index = np.random.permutation(len(train_labels)) trian_data, trian_labels = train_data[index], train_labels[index] SVGCircuit(x_train_circ[0]) y_train_hinge=2.0*test_data-1.0 y_test_hinge=2.0*test_labels-1.0 def hinge_accuracy(y_true, y_pred): y_true = tf.squeeze(y_true) &gt; 0.0 y_pred = tf.squeeze(y_pred) &gt; 0.0 result = tf.cast(y_true == y_pred, tf.float32) return tf.reduce_mean(result) model.compile(loss=tf.keras.losses.Hinge(), optimizer=tf.keras.optimizers.Adam(), metrics=[hinge_accuracy]) epochs=25 batch_size=16 num_examples=len(x_train_tfcirc) x_train_tfcirc_sub=x_train_tfcirc[:num_examples] y_train_hinge_sub=y_train_hinge[:num_examples] history = model.fit(x=x_train_tfcirc_sub, y=y_train_hinge_sub, batch_size=16, epochs=25, verbose=1,validation_data=(x_test_tfcirc,y_test_hinge)) print(model.summary()) qnn_results=model.evaluate(x_test_tfcirc,test_labels) print(qnn_results)",<quantum-gate><programming><circuit-construction><cirq><tfq>,1/20/2021 11:24,,,,
15661.0,Question on practical quantum computing programming code,Has anyone tried any quantum computing programming code that shows or demonstrates the advantage of a quantum computer over classical computers? Thanks a lot.,<programming><classical-computing><optimization>,1/24/2021 4:38,,,,
15741.0,What qiskit version?,How do I find out what version of qiskit I am running?,<programming><qiskit>,1/29/2021 16:20,,,,
15755.0,Simulation of a helium molecule using Qiskit,"I am trying to compute the ground state energy of He-He using VQE. For this purpose I have utilized Qiskit and have written the following script: from qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule from qiskit.chemistry.transformations import FermionicTransformation, FermionicQubitMappingType from qiskit.aqua.algorithms import NumPyMinimumEigensolver from qiskit import BasicAer from qiskit.aqua import QuantumInstance from qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory from qiskit.aqua.algorithms import VQE from qiskit.circuit.library import TwoLocal from qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver molecule = Molecule(geometry=[['He', [0., 0., 0.]], ['He', [0., 0., 3.1]]], charge=0, multiplicity=1) driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g') transformation = FermionicTransformation(qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER) numpy_solver = NumPyMinimumEigensolver() vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator'))) num_qubits = 4 tl_circuit = TwoLocal(num_qubits, ['h', 'rx'], 'cz', entanglement='full', reps=3, parameter_prefix = 'y') tl_circuit.draw(output = 'mpl') another_solver = VQE(var_form = tl_circuit, quantum_instance = QuantumInstance(BasicAer.get_backend('statevector_simulator'))) calc = GroundStateEigensolver(transformation, vqe_solver) res = calc.solve(driver) print(transformation) print(res) When I run it I get a following error message: Traceback (most recent call last): File &quot;test_remove.py&quot;, line 37, in &lt;module&gt; res = calc.solve(driver) File &quot;/Users/monica/miniconda3/lib/python3.7/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/ground_state_eigensolver.py&quot;, line 94, in solve solver = self._solver.get_solver(self.transformation) File &quot;/Users/monica/miniconda3/lib/python3.7/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/minimum_eigensolver_factories/vqe_uccsd_factory.py&quot;, line 212, in get_solver same_spin_doubles=self._same_spin_doubles) File &quot;/Users/monica/miniconda3/lib/python3.7/site-packages/qiskit/chemistry/components/variational_forms/uccsd.py&quot;, line 153, in __init__ excitation_type=self._excitation_type,) File &quot;/Users/monica/miniconda3/lib/python3.7/site-packages/qiskit/chemistry/components/variational_forms/uccsd.py&quot;, line 509, in compute_excitation_lists raise ValueError('No unoccupied orbitals') ValueError: No unoccupied orbitals Can anyone explain to me what is going on? What am I doing wrong?",<programming><qiskit><vqe><chemistry>,1/30/2021 13:48,,,,
15824.0,Preparing Bell state $(1/\sqrt{2}) (|01\rangle + |10\rangle)$ in Qiskit,"I'm working through the Qiskit textbook right now, and wanted to complete part 1 of exercise 3.4, which asks me to use qiskit to produce the Bell state: $$\frac{|01\rangle + |10\rangle}{\sqrt{2}}$$ which is equivalent to $$\begin{bmatrix} 0 \\ \frac{1}{\sqrt2} \\ \frac{1}{\sqrt2}\\ 0 \end{bmatrix}. $$ When you apply a CNOT to this, we get: $$\begin{bmatrix} 0 \\ 0 \\ \frac{1}{\sqrt2}\\ \frac{1}{\sqrt2} \end{bmatrix}$$ Which is just $|1\rangle\otimes |+\rangle$. However, I can't figure out how to set my qubits up in the right way. Any tips on how to use qiskit to get that last matrix?",<programming><qiskit><quantum-state><circuit-construction>,02/03/2021 18:32,,,,
15828.0,Get the gates after fusion optimization in Qiskit statevector simulator,"I tried to obtain the gates after fusion in Qiskit-aer statevector simulator. What I can find now is that it provides a backend option saying fusion_verbose (bool): Output gates generated in fusion optimization into metadata [Default: False]. While I set it, I couldn't figure out a way to get the &quot;metadata&quot;. simulator = aer.StatevectorSimulator(max_parallel_threads=128,fusion_verbose=True) result = execute(circuit,simulator).result() statevector = result.get_statevector(circuit) config = simulator.configuration() print(config.to_dict()) That information is not in the configuration. I am wondering how I can get those gates. Another related question is that if I set the highest optimization level in the qiskit transpile function, do I get the same circuits as I was running it in the statevector simulator? Thank you in advance.",<programming><qiskit><simulation>,02/03/2021 21:45,,,,
15900.0,Initial state definition for QAOA,"There are a few options already discussed and suggested how to pass the initial state to the QAOA module. I tried all but no one works in my case. Maybe, there are any other ideas? So, I created the initial state as: circ = QuantumCircuit(4) circ.h(0) circ.h(1) circ.h(2) circ.h(3) backend=Aer.get_backend('statevector_simulator') job = execute(circ, backend) result = job.result() init_state = result.get_statevector(circ) print(init_state) then, by passing it to QAOA: qaoa = QAOA(qubitOp, optimizer, p=3, initial_state=init_state, mixer=mixerop, initial_point=init_point, callback=store_intermediate_result, quantum_instance=qi) I got the error: ~\Anaconda3\lib\site-packages\qiskit\aqua\algorithms\minimum_eigen_solvers\qaoa\var_form.py in construct_circuit(self, parameters, q) 83 # initialize circuit, possibly based on given register/initial state 84 if self._initial_state is not None: ---&gt; 85 stateVector = CircuitStateFn(self._initial_state.construct_circuit('circuit')) 86 circuit = stateVector.to_circuit_op() 87 else: AttributeError: 'numpy.ndarray' object has no attribute 'construct_circuit' ```",<programming><qaoa>,02/07/2021 08:27,,,,
15988.0,processing between sequential executions,"Regarding real quantum computers of IBM, can one execute a circuit that contains measurements and afterwards get counts and then, based on the results of measurements (from counts), decide if to build circuit A or circuit B that will be executed on the same quantum register with init_qubits=False and with use of rep_delay parameter, so that the chosen circuit, A or B will run on the quantum register with output state of the first circuit?",<programming><qiskit><ibm-quantum-devices>,02/11/2021 13:22,,,,
16008.0,Qiskit CircuitStateFn.eval() on more than 16 qubits,"The definition of Qiskit CircuitStateFn.eval() is as follows: def eval(self, front: Union[str, dict, np.ndarray, OperatorBase] = None) -&gt; Union[OperatorBase, float, complex]: if not self.is_measurement and isinstance(front, OperatorBase): raise ValueError( 'Cannot compute overlap with StateFn or Operator if not Measurement. Try taking ' 'sf.adjoint() first to convert to measurement.') # pylint: disable=import-outside-toplevel from ..list_ops.list_op import ListOp from ..primitive_ops.pauli_op import PauliOp from ..primitive_ops.matrix_op import MatrixOp from ..primitive_ops.circuit_op import CircuitOp if isinstance(front, ListOp) and front.distributive: return front.combo_fn([self.eval(front.coeff * front_elem) for front_elem in front.oplist]) # Composable with circuit if isinstance(front, (PauliOp, CircuitOp, MatrixOp, CircuitStateFn)): new_front = self.compose(front) return new_front.eval() return self.to_matrix_op().eval(front) In the last line to_matrix_op() is called without any arguments. However, in order to work properly for more than 16 qubits, it has to be provided with an additional argument massive = True: def to_matrix(self, massive: bool = False) -&gt; np.ndarray: if self.num_qubits &gt; 16 and not massive: raise ValueError( 'to_vector will return an exponentially large vector, in this case {0} elements.' ' Set massive=True if you want to proceed.'.format(2 ** self.num_qubits)) So how do I use CircuitStateFn.eval() for more than 16 qubits??",<programming><qiskit>,02/12/2021 08:43,,,,
16058.0,Transpiler fails after 1000 iterations,"I'm transpiling a set of quantum circuits using ibmq_5_yorktown. However, as the number of circuits gets larger, it shows me the following error message: TranspilerError: 'Maximum iteration reached. max_iteration=1000' How can I fix this issue? Is it still possible for me to transpile more than 1,000 circuits? Thanks!",<programming><qiskit><ibm-q-experience><transpile>,2/16/2021 2:53,,,,
16060.0,How do qubits in quantum computers work?,"I was reading about quantum computers and qubits. While a classical bit can be either 0 or 1, a qubit can be 0 or 1 or both at the same time (can it be none too?). But how is this useful at all? If it is 0 and 1 at same time then this isn't helpful at all because I need exact value.",<quantum-state><classical-computing><quantum-parallelism>,2/16/2021 7:09,,,,
16197.0,Qiskit: how can you use a different state for each shot in a quantum circuit?,"I am trying to run a quantum circuit many times, each time using a different random state - a single qubit i.e. $|\psi\rangle= a|0\rangle + b|1\rangle$ with different $a$ and $b$. Once each qubit has gone through the circuit, I am saving the state vector of the final state, and converting this to spherical coordinates by calculating $\theta$ and $\phi$. I append each $\theta$ and $\phi$ value to a list and then plot them on a histogram (omitted below). Whilst this works, for large num_states it is very slow, so I am wondering if there is a way to use the 'shots' feature when executing the circuit, since you can write: job = execute(qc, backend, shots=1000) I tried playing around with this but found after the initial random state was generated, it repeated the circuit with the same state for the number of shots, rather than doing a different state each time. I'd like to use the shots feature as I believe this will be much quicker since OpenMP is built into Qiskit. Any ideas on how I might be able to implement a different state each time using shots would be much appreciated:) import numpy as np from qiskit import( QuantumCircuit, execute, Aer) from math import pi from qiskit.quantum_info import random_statevector #----------------------------------------------------------------------# backend = Aer.get_backend('statevector_simulator') def simulate_states(num_states): qc = QuantumCircuit(1) theta_vals = [] phi_vals = [] for i in range(num_states): random_state = random_statevector(2).data qc.initialize(random_state, 0) qc.z(0) job = execute(qc, backend) result = job.result() out_state = result.get_statevector() theta, phi, alpha_r, alpha_i, beta_r, beta_i = state_coords(out_state) theta += pi/2 theta_vals.append(theta) phi_vals.append(phi) return theta_vals, phi_vals def state_coords(statevector): &quot;&quot;&quot; determines the spherical coordinates of a state on the Bloch sphere i.e. calculates \theta and \phi. &quot;&quot;&quot; alpha = statevector[0] alpha_r = alpha.real alpha_i = alpha.imag beta = statevector[1] beta_r = beta.real beta_i = beta.imag theta = np.arcsin(2*((alpha_r*beta_r) - (alpha_i*beta_i))) phi = 2*np.arccos(2*((alpha_r**2)+(beta_r**2))-1) return theta, phi, alpha_r, alpha_i, beta_r, beta_i ```",<programming><quantum-gate><qiskit><quantum-state><quantum-circuit>,2/24/2021 10:37,,,,
16200.0,Qiskit: is there a quick way to work out the spherical coordinates for a given qubit statevector?,"I am trying to calculate the spherical coordinates of different qubit states (i.e. working out $\theta$ and $\phi$ from: $|\psi\rangle = e^{-i\phi/2}\cos(\theta/2)|0\rangle + e^{i\phi/2}\sin(\theta/2)|1\rangle$. At the moment I am using the below function although I don't think it's working properly since it breaks when theta is close to zero in this line: phi = np.arccos((1/np.sin(theta/2))*((alpha_r*beta_r) + (alpha_i*beta_i))) Is there a quick way to get the spherical coordinates for a state where $\theta$ is 0 to $\pi$ and $\phi$ is 0 to $2\pi$? I figure this must be built into Qiskit since when you do plot_bloch_multivector() it converts a state to a vector on a Bloch sphere. Any ideas would be much appreciated:) def state_coords(statevector): alpha = statevector[0] alpha_r = alpha.real alpha_i = alpha.imag beta = statevector[1] beta_r = beta.real beta_i = beta.imag theta = np.arccos((alpha_r**2)-(alpha_i**2)) if theta==0: phi=0 else: phi = np.arccos((1/np.sin(theta/2))*((alpha_r*beta_r) + (alpha_i*beta_i))) if ((alpha_r*beta_i) - (alpha_i*beta_r)) &lt; 0: phi += pi return theta, phi, alpha_r, alpha_i, beta_r, beta_i",<programming><quantum-gate><qiskit><quantum-circuit>,2/24/2021 17:32,,,,
16257.0,"Quantum Error Correction implementation in Qiskit, OpenQASM or other languages based on Python","Where can we find example(s) of implementation code in a programming language of Quantum Error Correction, whether with the standard method of measurement or the automatic method without measurement (with control operators) ?",<programming><qiskit><error-correction><resource-request><qasm>,2/28/2021 0:45,,,,
16261.0,How do I Initiate with my own alpha and beta values instead of starting form qubit in state zero in IBM Q?,Let's say I have normalized values of $\alpha$ and $\beta$ as $\alpha =(0.27524094128159016+0.8257228238447705j)$ $\beta =(-0.22019275302527214+0.4403855060505443j)$ How do I initialize my circuit starting from these values instead of qubit q[0] to be in state $|0\rangle$.,<programming><qiskit><ibm-q-experience>,2/28/2021 3:55,,,,
16268.0,Is it possible to see the probabilities values of qubit ( alpha and beta) while measuring on IBM Quantum experience?,Is it possible to see what are the values of $\alpha$ (probability of being in state zero) and $\beta$ (probability of being in state one) while running on IBM Quantum simulator (we can call it state vector).,<programming><ibm-q-experience><qasm>,2/28/2021 10:06,,,,
16293.0,Can I see Probability in complex form after measuring the state of the qubit on quantum computer?,"Let's say I have a qubit $$\left| \psi \right&gt; = (\alpha_1 + i\alpha_2 ) \left|0\right&gt; + (\beta_1 + i\beta_2 )\left|1\right&gt;$$ so when we measure it will calculate $|\alpha_1 + i\alpha_2|^2$ and $|\beta_1 + i\beta_2|^2$ ,and it will give the state with highest probability. enter preformatted text here vector = [159+625j,3+71j] print(vector) norm = np.linalg.norm(vector) print(norm) qc = QuantumCircuit(1) # Create a quantum circuit with one qubit initial_state = vector/np.linalg.norm(vector) print('initial state is') print(initial_state) qc.initialize(initial_state, 0) qc.x(0) ###### for not gate qc.h(0) ####### for hadamard gate a = qc.draw() print(a) simulator = Aer.get_backend('statevector_simulator') qobj = assemble(qc) # Create a Qobj from the circuit for the simulator to run result = simulator.run(qobj).result() # Do the simulation and return the result out_state = result.get_statevector() print(out_state) Now the code to run on Quantum computer is enter preformatted text here IBMQ.load_account() #provider = IBMQ.get_provider = ('ibm-q') provider = IBMQ.load_account() qcomp= provider.get_backend('ibmq_qasm_simulator') job = execute(qc,backend=qcomp) from qiskit.tools.monitor import job_monitor job_monitor(job) result = job.result() plot_histogram(result.get_counts(qc)) when we run this on Quantum computer we will get a graph with probabilities on it are those probabilities calculated using $|\alpha_1 + i\alpha_2|^2$ and $|\beta_1 + i\beta_2|^2$ these formulas? is it possible to extract in the form of a complex number like $a+ib$ not just like 0.865 or something like that, can I see what are my $\alpha$'s and $\beta$ 's after measuring?",<programming><qiskit><quantum-state>,03/01/2021 22:42,,,,
16294.0,How do I get state vector for each shot running on a quantum computer?,"I was running this code on a quantum computer. How can I generate a state vector for each shot while running on a quantum computer? qiskit code ## initiate alpha beta with own values vector = [alpha,beta] print('non normalised vector form a multi vector is') print(vector) norm = np.linalg.norm(vector) print(norm) qc = QuantumCircuit(1) # Create a quantum circuit with one qubit initial_state = vector/np.linalg.norm(vector) print('initial state is') print(initial_state) qc.initialize(initial_state, 0) qc.x(0) ###### for not gate qc.h(0) ####### for hadamard gate a = qc.draw() print(a) simulator = Aer.get_backend('statevector_simulator') qobj = assemble(qc) # Create a Qobj from the circuit for the simulator to run result = simulator.run(qobj).result() # Do the simulation and return the result out_state = result.get_statevector() print(out_state) from qiskit import IBMQ IBMQ.load_account() #provider = IBMQ.get_provider = ('ibm-q') provider = IBMQ.load_account() qcomp= provider.get_backend('ibmq_qasm_simulator') job = execute(qc,backend=qcomp) from qiskit.tools.monitor import job_monitor job_monitor(job) result = job.result() plot_histogram(result.get_counts(qc))",<programming><quantum-gate><qiskit><quantum-state>,03/01/2021 23:28,,,,
16354.0,Error while running Qiskit code on real quantum computer,"I was trying to run this code on a quantum computer but I was getting an error can anyone suggest how to resolve this error? enter preformatted text here vector = [(159+625j), (3+71j)] norm = np.linalg.norm(vector) qc = QuantumCircuit(1) # Create a quantum circuit with one qubit initial_state = vector/np.linalg.norm(vector) print('initial state is') print(initial_state) qc.initialize(initial_state, 0) qc.x(0) ###### for not gate qc.h(0) ####### for hadamard gate qc.snapshot('final', snapshot_type='statevector') a = qc.draw() print(a) IBMQ.load_account() #provider = IBMQ.get_provider = ('ibm-q') provider = IBMQ.load_account() qcomp= provider.get_backend('ibmq_belem') job = execute(qc,backend=qcomp) from qiskit.tools.monitor import job_monitor job_monitor(job) result = job.result() plot_histogram(result.get_counts(qc)) When I ran this through the quantum computer I am getting this error: Cannot unroll the circuit to the given basis, ['id', 'rz', 'sx', 'x', 'cx', 'reset']. No rule to expand instruction multiplex1_dg.",<programming><qiskit><ibm-quantum-devices>,03/04/2021 22:33,,,,
16387.0,How can I represent Pauli Measurements in Qiskit's QuantumCircuit object?,"Is there a way to represent measurements in other bases in Qiskit? The default measurement is in the Z (computational) basis. Can I also depict measurement in X, Y and general Pauli Measurements? I know that I can apply a suitable unitary and then measure in the Z basis, but I am looking for a way to add the measurements to the circuit almost like &quot;gates&quot;. I will be putting many such measurements in sequence in my circuits. I will be happy to use any external/in-development tool that allows this and interfaces well with Qiskit.",<programming><qiskit>,03/07/2021 06:45,,,,
16414.0,Are classical analogues of quantum computers using superposed waves possible?,"The trick of quantum computing is to take the advantage of wave mechanics (superposition) and entanglement. This allows to perform parallel computations/manipulations with $2^n$ superposed waves for $n$ bits. This principle does not rely on quantum mechanics. Superposed waves do also exist in classical mechanics (although I am not sure we can make the number of tones also scale exponentially with the size, but there could be some profit). Are there examples of efforts to create classic analogues of quantum computers that use superposed waves and manipulate those, instead of using bits in silicon chips? (I do not mean efforts to create a virtual quantum computer) This question might be generalized. Are/were there any efforts to try to move away from binary computers?",<experimental-realization><classical-computing><architecture>,03/09/2021 08:56,,,,
16423.0,How do I convert a Quantum Circuit into a qobj,"I have a Quantum Circuit launched but I want to convert it into a qobj to use the function .run from qiskit, I've tried to use the function: qobj = assemble(QuantumCircuit) but it returns 'QuantumCircuit' object has no attribute 'config' and I've failed to find the &quot;config&quot; needed on the qiskit instructions. Does anyone know's how do I convert it properly and fill's this configurations? Here is a print of the qobj after assemble: QASM Qobj: 3d6e9e20-290e-4c7d-a2e7-c0b5a8e38f2e: Config: {'init_qubits': True, 'memory': False, 'memory_slots': 3, 'n_qubits': 3, 'parameter_binds': [], 'shots': 1024} Header: {} Experiments: QASM Experiment: Header: {'clbit_labels': [['c', 0], ['c', 1], ['c', 2]], 'creg_sizes': [['c', 3]], 'global_phase': 0.0, 'memory_slots': 3, 'n_qubits': 3, 'name': 'circuit', 'qreg_sizes': [['q', 3]], 'qubit_labels': [['q', 0], ['q', 1], ['q', 2]]} Config: {'memory_slots': 3, 'n_qubits': 3} Instruction: ry params: [1.0] qubits: [0] Instruction: rz params: [2.0] qubits: [0] Instruction: h qubits: [0] Instruction: measure qubits: [0] memory: [0] Instruction: ry params: [1.0] qubits: [2] Instruction: rz params: [2.0] qubits: [2] Instruction: measure qubits: [2] memory: [2] Instruction: ry params: [1.0] qubits: [1] Instruction: rz params: [2.0] qubits: [1] Instruction: sdg qubits: [1] Instruction: h qubits: [1] Instruction: measure qubits: [1] memory: [1] it still's return the same error.",<programming><qiskit><quantum-circuit>,03/09/2021 14:46,,,,
16507.0,Running Qiskit Circuit Composer locally on Jupyer Notebook,"I was wondering if I could use Qiskit locally on Jupyter Notebook and thus loaded my IBM-Q account via API token. I could construct circuits execute jobs but when I tried to use circuit composer, it returned nothing like the interactive circuit-composer as it does in IBM Quantum Lab. I ran the following code: from qiskit import QuantumCircuit, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from ibm_quantum_widgets import * %matplotlib inline from ibm_quantum_widgets import CircuitComposer CircuitComposer() It returned the following: CircuitComposer(circuit=&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x15C528F8&gt;) Is there anything I am possibly missing out? p.s qiskit has the latest version installed.",<programming><qiskit><ibm-q-experience>,3/14/2021 17:45,,,,
16519.0,Qiskit not finding CPLEX,"I'm trying to use the CPLEX library alongside Qiskit but keep getting the error. File &quot;C:\Users\charl\.conda\envs\quantum\lib\site-packages\qiskit\optimization\algorithms\cplex_optimizer.py&quot;, line 58, in __init__ raise MissingOptionalLibraryError( qiskit.aqua.missing_optional_library_error.MissingOptionalLibraryError: &quot;The 'CPLEX' library is required to use 'CplexOptimizer'. You can install it with 'pip install qiskit-aqua[cplex]'.&quot; Now when of course run that command, I find that all these packages are already installed. When I tried manually updating docplex, I got a warning saying the latest version was incompatible with qiskit and so I downgraded using pip to docplex 2.15.194, yet I still get the error. What can I do to get docplex and Qiskit to talk to one another ? I am using a windows 10 installation of qiskit in a conda environment.",<programming><qiskit>,3/15/2021 12:10,,,,
16539.0,How to create an observable: 'Identity \tensor Pauli gate' in Cirq,"I am working on an implementation of the RQAOA algorithm on the Maxcut problem in Cirq. My graph G has n vertices. And after running a QAOA circuit with n qubits I obtain a state gammabeta (a vertical vector with 2^n entries). I want to calculate M(e) = &lt;gammabeta|Z(e)|gammabeta&gt; for all edges e of G. I want Z(e) to be an observable of the form $I\otimes \dots \otimes I \otimes Z_i \otimes I \otimes \dots \otimes I \otimes Z_j \otimes I \otimes \dots \otimes I$ (two dimensional $I$'s), with $i -1$ $I$'s in front if $Z_i$, $j -i -1$ in the middle and $n - j - 1$ behind $Z_j$. That way I can use Z(e).expectation_from_state_vector(gammabeta, qubit_map=qubit_map)) to calculate M(e) The problem I ran into is that I do not know how to do $I \otimes Z$ in cirq. If I write cirq.Z * cirq.Z I get $Z\otimes Z$, but if I do cirq.I * cirq.Z it does the regular product, and I get $Z$ back. Does any one know how to make observable Z(e)? Or altenatively how to compute the expectation value of a circuit B with state vector a: &lt;a|B|a&gt;? Building the Z(e) circuit is easier, but I don't know how to calculate the expectation value if a state vector from one circuit, on another circuit.",<programming><cirq><linear-algebra><qaoa>,3/17/2021 12:23,,,,
16581.0,How to divide one quantum circuit into multiple sub-circuits in qiskit?,"While I'm simulating one Big quantum circuit in Qiskit, I wonder how we can divide one big quantum circuit into several sub-circuits. I looked in Qiskit API documents, but I couldn't find it. Is there anyway that I can do that?",<programming><qiskit><quantum-circuit>,3/19/2021 14:17,,,,
16609.0,How to read QASM files for parametrized circuits (in QISKIT)? both from_qasm_file() and from_qasm_str() fail,"I am trying to work with parametrized circuits in QISKIT. I can simply create parameterized circuits, bind value(s) to parameter(s), and execute/run all instances (after binding values for parameters) on different backends like ibmq_manhattan, ibmq_paris, etc. To dump the resulting circuits to QASM files, I use the âqasm()â method of the QuantumCircuit objects, and I see no problem. Here is a simple (random) QASM file that I create: OPENQASM 2.0; include &quot;qelib1.inc&quot;; qreg q[3]; creg c[3]; h q[0]; h q[1]; h q[2]; barrier q[0],q[1],q[2]; rx(beta) q[0]; As you can see, the last line of the QASM file specifies a parameterized RX rotation, on qubit q[0] and the angle is (beta). As far as I am working with QuantumCircuit objects, I can deal with these parameters. However, after writing the circuit to a QASM file, I lose the functionality. More specifically, when I try to load/read the QASM file and create a QuantumCircuit, I face the following error: Code: circ = QuantumCircuit.from_qasm_file(filepath) Error: qiskit.qasm.exceptions.QasmError: &quot;Argument 'beta' in expression cannot be found, line 9 file â¦ I also tried the following alternative (just in case): Code: circ = QuantumCircuit.from_qasm_str(qasm_str) and faced the same error. Here the âfilepathâ specifies the path to the QASM file, and I obtain the âqasm_strâ via reading the QASM file. I checked the source code of the âfrom_qasm_file()â module in QISKIT, as well as âQasmâ class; however, I did not find any additional input argument/parameter to specify these parameters to the parser. I just need to read the (abovementioned) QASM file and re-create a QuantumCircuit object. I would appreciate it a lot if someone can help me in this regard. Thanks, Ramin",<programming><qiskit><quantum-circuit><qasm>,3/21/2021 4:15,,,,
16628.0,Source code for a Qiskit algorithm: HHL Algorithm,"Is it possible to view the source code of one of the Qiskit's algorithm? Actually, I am trying to find how Qiskit implements the HHL algorithm. I want to see the source code for this algorithm.",<programming><qiskit><quantum-algorithms><hhl-algorithm>,3/22/2021 13:11,,,,
16714.0,"How fast is qiskit to_gate() method, which is used to convert circuit to gate?","I have prepared a quantum circuit, which is using 13 qubits. Now, I am converting this circuit to gate but it is taking around avg. 35s for conversion. It would have have been fine, if I require only one such converison. But, I need to convert 30 such circuits. Why it is taking such amount of time? Is having 13 qubits have something to do with it? My code: import networkx as nx import math i_zero=[1,0] i_one=[0,1] #-----------Initiating the Graph---------------# G=nx.karate_club_graph() a=nx.to_numpy_array(G) c_nodes= len(list(G.nodes)) c_edges=len(G.edges()) #-----------Making the Edge List---------------# edge_list_tmp=list(G.edges()) edge_list=[] for i in range(0,c_edges): v_tmp=edge_list_tmp[i] li_tmp=[edge_list_tmp[i][0],edge_list_tmp[i][1],False,'coin_state'] edge_list.append(li_tmp) #-----------Calculating the Qubits Required---------------# c_pq=math.ceil(math.log2(c_nodes))+1 c_aq=c_pq-1 li_temp=sorted(G.degree, key=lambda x: x[1], reverse=True) h_deg=li_temp[0][1] c_cq=math.ceil(math.log2(h_deg)) #----------Making position Transition circuit-------------# qc_l3=[] rep_string=&quot;{0:0&quot;+str(c_pq-1)+&quot;b}&quot; for i in range(0,len(edge_list)): v1=rep_string.format(edge_list[i][0]) v2=rep_string.format(edge_list[i][1]) name=&quot; Transition: &quot;+str(edge_list[i][0])+'-&gt;'+str(edge_list[i][1]) qc_temp=QuantumCircuit(c_pq,name=name) for i in range(0,len(v1)): if(v1[i]!=v2[i]): qc_temp.x(c_pq-i-2) qc_temp.x(6) qc_l3.append(qc_temp) #-----------Assigning coin states to each edge------------# coin_edge={} curr_v=edge_list[0][0] rep_string=&quot;{0:0&quot;+str(c_cq)+&quot;b}&quot; for i in range(0,len(edge_list)): for j in range(0,int(math.pow(2,c_cq))-1): if not(edge_list[i][2]): if (edge_list[i][0],rep_string.format(j)) not in coin_edge: edge_list[i][2]=True edge_list[i][3]=rep_string.format(j) coin_edge[(edge_list[i][0],rep_string.format(j))]=1 coin_edge[(edge_list[i][1],rep_string.format(j))]=1 #------Assigning Transition circuit to position states-----# coin_states={} rep_string=&quot;{0:0&quot;+str(c_cq)+&quot;b}&quot; for i in range(0,int(math.pow(2,c_cq))-1): coin_states[rep_string.format(i)]=[] for i in range(0,len(edge_list)): coin_states[edge_list[i][3]].append(i) rep_string=&quot;{0:0&quot;+str(c_pq-1)+&quot;b}&quot; qc_l2=[] gate_apply=[] for i in range(c_pq,c_pq+c_aq): gate_apply.append(i) for i in range(0,c_pq): gate_apply.append(i) for coin_value,circs in coin_states.items(): if len(circs)==0: continue for i in circs: qc_temp=QuantumCircuit(c_pq+c_aq,name='Transition circuit: Coin state '+str(int(coin_value))) for j in range(0,c_pq-1): qc_temp.cx(j,c_pq+j) v1=rep_string.format(edge_list[i][0]) v1=v1[::-1] #string reverse for i in range(0,len(v1)): if(v1[i]=='0'): qc_temp.x(c_pq+i) gate_tmp=qc_l3[i].to_gate().control(c_aq) qc_temp.append(gate_tmp,gate_apply) for i in range(0,len(v1)): if(v1[i]=='0'): qc_temp.x(c_pq+i) v2=rep_string.format(edge_list[i][1]) v2=v2[::-1] for i in range(0,len(v2)): if(v2[i]=='0'): qc_temp.x(c_pq+i) qc_temp.cx(c_pq-1,c_pq) gate_tmp=qc_l3[i].to_gate().control(c_aq) qc_temp.append(gate_tmp,gate_apply) qc_l2.append([coin_value,qc_temp]) #-----------------Making Final Circuit with Coin assigned to each transition----------------&gt; qc_l3=QuantumCircuit(c_pq+c_aq+c_cq,c_pq-1) gate_apply=[] for i in range(c_pq+c_aq,c_pq+c_aq+c_cq): qc_l3.h(i) gate_apply.append(i) for i in range(0,c_pq+c_aq): gate_apply.append(i) for cc in qc_l2: #cc=coin_circuit coin_value=cc[0] print('ok') coin_value=coin_value[::-1] circ=cc[1] gate_tmp=circ.to_gate().control(c_cq) for j in range(c_pq,c_pq+c_aq): qc_temp.initialize(i_zero,j) for i in range(0,len(coin_value)): if(coin_value[i]=='0'): qc_l3.x(c_pq+c_aq+i) qc_l3.append(gate_tmp,gate_apply) for i in range(0,len(coin_value)): if(coin_value[i]=='0'): qc_l3.x(c_pq+c_aq+i) qc_l3.draw('mpl') ```",<programming><qiskit><quantum-gate>,3/27/2021 8:03,,,,
16715.0,Need Help in QGAN function to load higher dimensional data,"I have a query that I am using qiskit.aqua.algorithms.QGAN library and using the qgan function and I am having difficulty in loading data of dimension 1000 rows x 10 columns. I am following qiskit's github tutorial for qgan learning and loading, however I did tested out that the tutorial was with 1000 rows and 1 column and is working fine. It did works till 2 columns but for more than 2 columns the function returns error. I don't understand if the same dataset is of 1 or 2 column it works but as soon as the data is reshaped to 3 or more columns, it returns this error: AttributeError Traceback (most recent call last) &lt;ipython-input-36-1df19589f511&gt; in &lt;module&gt; 6 7 # Initialize qGAN ----&gt; 8 qgan = QGAN(real_data, bounds, num_qubits, batch_size, num_epochs, snapshot_dir=None) 9 qgan.seed = 1 D:\Users\Bro\anaconda3\lib\site-packages\qiskit\aqua\algorithms\distribution_learners\qgan.py in __init__(self, data, bounds, num_qubits, batch_size, num_epochs, seed, discriminator, generator, tol_rel_ent, snapshot_dir, quantum_instance) 126 self._num_qubits = np.array([3]) 127 self._data, self._data_grid, self._grid_elements, self._prob_data = \ --&gt; 128 discretize_and_truncate(self._data, self._bounds, self._num_qubits, 129 return_data_grid_elements=True, 130 return_prob=True, prob_non_zero=True) D:\Users\Bro\anaconda3\lib\site-packages\qiskit\aqua\utils\dataset_helper.py in discretize_and_truncate(data, bounds, num_qubits, return_data_grid_elements, return_prob, prob_non_zero) 214 for grid_element in grid_elements: 215 for element_current in elements_current_dim: --&gt; 216 temp.append(deepcopy(grid_element).append(element_current)) 217 grid_elements = deepcopy(temp) 218 data_grid.append(elements_current_dim) AttributeError: 'NoneType' object has no attribute 'append' Any solution for the same?? PS:- I am trying to load even bigger dimensional dataset so please help in this.",<programming><qiskit>,3/27/2021 8:38,,,,
16724.0,What's the difference between open-source QRNG and Quantis Device?,"qRNG is an open-source quantum random number generator written in python and Quantis RNG is a physical quantum random number generator. Both are capable of generating quantum random numbers, but how do they differ?",<programming><quantum-algorithms><classical-computing>,3/27/2021 19:05,,,,
16825.0,I can't see the results of my of my jobs,"New user here. I tried to run a test circuit which I submitted to ibmq_santiago to run, but now I cannot see my results. No histogram, no circuit, only the status timeline. I believe the problem is that my antivirus recognizes this URL as blacklisted and cancels the connection, because that's the message I get every time I try to view my results, but I don't get why it would do that. Has anyone had this problem before?",<programming><ibm-q-experience>,04/02/2021 14:59,,,,
16867.0,Calculating the expected value of a weighted Pauli Operator in Qiskit,"Following UT course on Quantum Machine Learning, they have a notebook on QAOA. As part of their lecture, they perform QAOA using Qiskit. Unfortunately, it seems the new versions of Qiskit have changed a lot since then and the code is not working anymore. Specifically, the instructions on the optimization / evaluation procedure say the following: We now create a function evaluate_circuit that takes a single vector gamma_beta (the concatenation of gamma and beta) and returns $\langle H_c \rangle = \langle \psi | H_c | \psi \rangle$ where $\psi$ is defined by the circuit created with the function above. In their code, evaluate_circuit looks like this: def evaluate_circuit(beta_gamma): n = len(beta_gamma)//2 circuit = create_circuit(beta_gamma[:n], beta_gamma[n:]) return np.real(Hc.eval(&quot;matrix&quot;, circuit, get_aer_backend('statevector_simulator'))[0]) So basically they're calculating the expected value of $H_c$ (the hamiltonian we expect to evolve to at the end) with respect to $\psi$, which in this case is constructed using the function create_circuit (which simulates the evolution from a superposition state based on the applicacion of Hc and Hm operators with angles beta and gamma, respectively): def create_circuit(beta, gamma): circuit_evolv = sum([evolve(Hc, beta[i], qr) + evolve(Hm, gamma[i], qr) for i in range(p)], evolve(identity, 0, qr)) circuit = circuit_init + circuit_evolv return circuit The problem here is that $H_c$ in this case is an object of WeightedPauliOperator, and it doesn't seem to have the function eval anymore. What's the best way to calculate $\langle \psi | H_c | \psi \rangle$ using WeightedPauliOperator objects?",<programming><qiskit>,04/05/2021 22:27,,,,
16872.0,How to solve TSP problem with more than 3 nodes in the tutorial of Max-Cut and Traveling Salesman Problem?,"I had to try the example of qiskitâs Traveling Salesman Problem with 3 nodes and executing it at IBM backend called simulator_statevector.Can execute and get the result normally. But when trying to solve the TSP problem with more than 3 nodes,I changed n = 3 to n = 4. # Generating a graph of 3 nodes n = 4 num_qubits = n ** 2 ins = tsp.random_tsp(n, seed=123) print('distance\n', ins.w) # Draw the graph G = nx.Graph() G.add_nodes_from(np.arange(0, ins.dim, 1)) colors = ['r' for node in G.nodes()] for i in range(0, ins.dim): for j in range(i+1, ins.dim): G.add_edge(i, j, weight=ins.w[i,j]) pos = {k: v for k, v in enumerate(ins.coord)} draw_graph(G, colors, pos) And I changed backend from Aer.get_backend ('statevector_simulator') running on my device to provider.backend.simulator_statevector running on the IBM backend. aqua_globals.random_seed = np.random.default_rng(123) seed = 10598 backend = provider.backend.simulator_statevector #backend = Aer.get_backend('statevector_simulator') quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed) But the result that comes out with an error. energy: -1303102.65625 time: 5626.549758911133 feasible: False solution: [1, 0, 2, []] solution objective: [] Traceback (most recent call last): File &quot;&lt;ipython-input-10-bc5619b5292f&gt;&quot;, line 14, in &lt;module&gt; draw_tsp_solution(G, z, colors, pos) File &quot;&lt;ipython-input-4-999185567031&gt;&quot;, line 29, in draw_tsp_solution G2.add_edge(order[i], order[j], weight=G[order[i]][order[j]]['weight']) File &quot;/opt/conda/lib/python3.8/site-packages/networkx/classes/coreviews.py&quot;, line 51, in __getitem__ return self._atlas[key] TypeError: unhashable type: 'list' Use %tb to get the full traceback. How should I fix it? Please give me some advice.",<programming><qiskit>,04/06/2021 06:18,,,,
16957.0,How to measure a qubit Hamiltonian in qiskit,I am using qiskit to get some measurement results of observables similar to the Hamiltonian. Can someone provide the way how qiskit measures the Hamiltonian (Jordan-Wigner transformed) when using VQE? Or can they just provide the source code link.,<programming><qiskit><measurement><vqe>,04/11/2021 15:22,,,,
17040.0,How to transform fermionic operators in qiskit,"I encountered some problems when using the qiskit pakage to define the 2-electron reduced density matrix (2-RDM), which is a 4-index tensor, $\langle a_i^\dagger a_j^\dagger a_k a_l\rangle$. I need to first transform each term in the tensor (2-RDM) to the qubit form by Jordan-Wigner transformation. Then, I can measure each term using the expectation feature of the VQE function in qiskit. However, the qiskit.chemistry.fermionic_operator class only support Hamiltonian to be transformed to the qubit form. Therefore, there are two questions here to finish the 2-RDM measurement job. The first is how to define general fermionic operators by qiskit, especially the one has the form of the 2-RDM. The second is that are there any build-in function in qiskit to tranform general fermionic operators to the qubit form.",<programming><qiskit><measurement>,4/14/2021 9:10,,,,
17066.0,Openfermion : `get_sparse_operator` issue,"I am trying to use operfermion to calculated the eigen values for different molecules. Tried for Hydrogen, LithiumHydride, Water. It works fine. When Itried to calculated the same thing for Ozone, Oxygen, HCN etc., the program finally got killed after consuming all the memory. Any help is deeply appreciated. Here is the sample code to reproduce the issue from numpy import pi from openfermion.chem import MolecularData geometry=[['O',[0,0,0]],['O',[0,1.0885,0.6697]],['O',[0,-1.0885,0.6697]]] basis='sto-3g' multiplicity=1 #singlet charge=0 #neutral ozone_molecule=MolecularData(geometry,basis,multiplicity,charge) from openfermionpsi4 import run_psi4 ozone_molecule = run_psi4(ozone_molecule, run_mp2=True, run_cisd=True, run_ccsd=True, run_fci=True) two_electron_integrals = ozone_molecule.two_body_integrals orbitals = ozone_molecule.canonical_orbitals ozone_filename = ozone_molecule.filename ozone_molecule.save() one_body_integrals = ozone_molecule.one_body_integrals from openfermion.transforms import get_fermion_operator, jordan_wigner ozone_qubit_hamiltonian = jordan_wigner(get_fermion_operator(ozone_molecule.get_molecular_hamiltonian())) from openfermion.linalg import get_sparse_operator from scipy.linalg import eigh ozone_matrix= get_sparse_operator(ozone_qubit_hamiltonian).todense() eigenvalues, eigenvectors = eigh(ozone_matrix) print(eigenvalues) This consumes roughly 128 GB of RAM and finally gets killed.",<programming><openfermion>,4/15/2021 13:41,,,,
17135.0,is it possible to eliminate a certain possibility of an outcome of 3+ qbits,"Let's say I have n qbits each in a superposition $\begin{pmatrix} \frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{2}} \end{pmatrix}$ so each possible outcome has a probability of $\frac{1}{2^n}$. Is it possible for me to suppress the probability of one outcome? E.g. I have 3qbits, I want to remove the possibility of reading 101 when I measure the qbits. Possible outcomes:$\begin{bmatrix} 000\\ 001\\010\\011\\100\\101\\110\\111 \end{bmatrix}$ probabilities of outcomes: $\begin{bmatrix} 0.125\\ 0.125\\0.125\\0.125\\0.125\\0.125\\0.125\\0.125\end{bmatrix}$ -&gt; $\begin{bmatrix} 0.143\\ 0.143\\0.143\\0.143\\0.143\\0\\0.143\\0.143\end{bmatrix}$ Is this possible? How could I do that? Furthermore, is it possible for me to remove the possibility of reading 2 outcomes: say 101 and 110. Possible outcomes:$\begin{bmatrix} 000\\ 001\\010\\011\\100\\101\\110\\111 \end{bmatrix}$ probabilities of outcomes: $\begin{bmatrix} 0.125\\ 0.125\\0.125\\0.125\\0.125\\0.125\\0.125\\0.125\end{bmatrix}$ -&gt; $\begin{bmatrix} 0.167\\ 0.167\\0.167\\0.167\\0.167\\0\\0\\0.167\end{bmatrix}$ Note: I don't actually care about the remaining probabilities of the outcomes, as long as they are nonzero.",<programming><quantum-gate><quantum-state><quantum-algorithms>,4/19/2021 0:09,,,,
17192.0,How to avoid Cirq: State_vector is not normalized error for Feedback-loop in optimizer?,"I am doing a VQE in Cirq, but sometimes I get this error while running steps of the classical optimization loop: State_vector is not normalized instead had norm 1.0000000010132789 And therefore the program interrupts. Is there anything I can do to avoid this? Because my state should be normalized the way I constructed the circuit.",<programming><cirq>,4/21/2021 16:20,,,,
17263.0,How accurate are Qiskitâs unitary and Statevector simulators for very large circuits?,"Background: I wrote a code that takes a Qiskit circuit C as an input and outputs a random circuit Câ such that C and Câ have the same unitaries. I tested my code using Qiskitâs Statevector simulator and Qiskitâs unitary simulator (using np.allclose). I tested over 20 circuits of various sizes, all passed the tests successfully, EXCEPT for one circuit, where sometimes I get the same unitaries and state vectors and sometimes I donât. The circuit is quite large, with 10 qubits, 20 CNOTâs and a bunch of non-Clifford gates. The random output for this circuit can be incredibly large (e.g., more than 300 layers and a ridiculous number of CNOTâs). Iâm pretty sure that thereâs no error in my code, which leads me to ask: Question: is there a certain size/complexity threshold of a circuit beyond which Qiskitâs unitary and Statevector simulators might return inaccurate results? In case that this never happens, is there any other explanation for the peculiar behavior that I described?",<programming><qiskit><simulation><unitarity>,4/27/2021 2:49,,,,
17315.0,What is the relationship between the (sx) error rate listed in calibration and the angle/amplitude errors calculated using the fitter?,"The IBM Quantum services website lists calibration statistics for their devices, including the (sx) error rate per qubit, which is listed as a single number. One can also manually calibrate a device using the ampcal_1Q_circuits and anglecal_1Q_circuits functions in Ignis, but doing so results in two different numbers for the sx amplitude error and angle error. What is the relationship between these two errors and the number listed on the website?",<programming><quantum-gate><ibm-q-experience>,05/01/2021 09:14,,,,
17423.0,Inverse of Statevector.from_label in Qiskit,"In Qiskit I can construct a computational basis statevector in the following fashion from qiskit.quantum_info import Statevector sv = Statevector.from_label('10') print(sv.data) which gives [0.+0.j 0.+0.j 1.+0.j 0.+0.j] . If I have the data for a statevector in the computation basis, is there a built-in way to return a corresponding string? For [0.+0.j 0.+0.j 1.+0.j 0.+0.j] I should get back '10'. More generally, if the state is not in the computational basis it would be nice to get a linear combination of the basis states.",<programming><qiskit>,05/10/2021 12:12,,,,
17453.0,How to simplify a circuit with repeated same parts?,"If I have a circuit with 3 qubits and repeated gates as follow: circ = QuantumCircuit(3, 3) for i in range(100): # some gates, details is not important circ.rx(0.1, 0) circ.ry(0.1, 1) circ.ccx(0,1,2) Clearly the repeated gates will be transpiled (and uploaded to IBMQ via Internet) 100 times. How can I change the code so that the repeated part only need to be transpiled (and uploaded) one time?",<programming><qiskit><ibm-q-experience>,05/11/2021 17:21,,,,
17459.0,How to import circuit libraries into qiskit,"Im trying to put the QFT circuit in my qiskit circuit but im having trouble: import numpy as np # Importing standard Qiskit libraries from qiskit import QuantumCircuit, transpile, Aer, IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from ibm_quantum_widgets import * from math import sqrt from qiskit.quantum_info import DensityMatrix from qiskit.circuit.library import QFT # Loading your IBM Q account(s) provider = IBMQ.load_account() qc = QuantumCircuit(1,1) init = [sqrt(3/4),-sqrt(1/4)] qc.initialize(init,0) qc.h(0) qc.x(0) qc.h(0) qc.QFT(0) display(qc.draw()) s0 = DensityMatrix(qc) sim = Aer.get_backend('unitary_simulator') job = transpile(qc,sim) state = sim.run(job).result().get_unitary() print(qc.qasm())",<programming><qiskit><ibm-q-experience><qasm>,05/12/2021 01:33,,,,
17478.0,How do you build the modified Toffoli gate using only local unitary and CNOT operations?,"How do you build a circuit for a modified Toffoli gate using only local unitary operations and CNOT operations? The two-qubit unitary operation is given by: $\text{diag}\{1, 1, 1, e^{i\phi}\}$.",<programming><quantum-gate><circuit-construction>,05/12/2021 17:20,,,,
17491.0,Add FreezeCoreOrbitals on ElectronicStructureProblem,"I want to freeze core orbitals of my molecule and I know ElectronicStructureProblem has the possibility (es_problem = ElectronicStructureProblem(driver=driver, q_molecule_transformers=FreezeCoreTransformer())). Then, when I run the code to calculate the ground state energy of my molecule (res = calc.solve(problem=es_problem)), it says that 'FreezeCoreTransformer' object is not iterable. Which is the way then to freeze core orbitals without using deprecated libraries of Qiskit? Thank you very much in advance!",<programming><qiskit><chemistry>,5/13/2021 17:37,,,,
17539.0,"Qiskit package installed locally, but not running in jupyter notebook",I believe I have installed qiskit on my computer. Running pip list or pip3 list in terminal returns: qiskit 0.26.0 qiskit-aer 0.8.2 qiskit-aqua 0.9.1 qiskit-ibmq-provider 0.13.1 qiskit-ignis 0.6.0 qiskit-terra 0.17.3 However when I then open a jupyter notebook and try import qiskit I get told that there is no module named qiskit available. Does anyone know what I am doing wrong?,<programming><qiskit>,5/17/2021 22:33,,,,
17552.0,How to code density matrix in python?,"how to do this in python using for loop $\rho = \sum_i p(x)|x\rangle\langle x|$ where $X = {x1,x2,....}$ and $P = {p1,p2,p3...}$ i have tried this loop but tis not working for x,y in zip(prob,kets): sum += x * np.outer(y,y) print(sum)",<programming>,5/18/2021 20:44,,,,
17576.0,Data embedding using IBM quantum composer,"How do you use the IBM quantum composer to encode some data $(a,b,c,d)$ represented by a vector ket in which $a,b,c,d$ have been normalized to one? $a|00\rangle + b|01\rangle + c|10\rangle + d|11\rangle$",<programming><ibm-q-experience><embedding>,5/20/2021 15:06,,,,
17598.0,Things that I can compare between QDK and Qiskit,"I am planning to write an article which compares QDK and Qiskit Mainly talking about the different interfaces, and difference in running few algorithms What all parameters should I compare and take into account, Would love some suggestions",<programming><qiskit><q#>,5/22/2021 13:52,,,,
17613.0,QAOA not returning solution for simple clustering problem,"I am following University's of toronto QML course and there's a section where QAOA is applied to cluster a set of vectors by mapping the clustering problem into a Maxcut problem. Unfortunately qiskit's QAOA is not returning the right solution (even within the course's notebook lecture), so I am a bit lost in the implementation. The (4) points are (top two are on the top left corner and bottom two on the bottom right corner) data = array([[ 0.11 , 0.143], [ 0.121, 0.109], [-1.515, 1.629], [-1.512, 1.678]]) And the distance matrix (used as the 'weight' matrix of the maxcut graph) is w = array([[0. , 0. , 2.202, 2.234], [0. , 0. , 2.233, 2.265], [2.202, 2.233, 0. , 0. ], [2.234, 2.265, 0. , 0. ]]) (distances &lt; 0.5 were mapped to 0 as pre-processing). Using Qiskit's max_cut class, we map w into an Ising problem. We also verify the best solution qubit_operators, offset = max_cut.get_max_cut_qubitops(-w) // checking for solutions (cleary 0011 and 1100 are the solutions) (0, 0, 0, 0) 4.466870101471442 (0, 0, 0, 1) 0.031168254348417523 (0, 0, 1, 0) -0.031168254348417523 (0, 0, 1, 1) -4.466870101471442 (0, 1, 0, 0) 0.03160476231770515 (0, 1, 0, 1) 0.0001477223286934226 (0, 1, 1, 0) -0.0001477223286934226 (0, 1, 1, 1) -0.03160476231770515 (1, 0, 0, 0) -0.03160476231770515 (1, 0, 0, 1) -0.0001477223286934226 (1, 0, 1, 0) 0.0001477223286934226 (1, 0, 1, 1) 0.03160476231770515 (1, 1, 0, 0) -4.466870101471442 (1, 1, 0, 1) -0.031168254348417523 (1, 1, 1, 0) 0.031168254348417523 (1, 1, 1, 1) 4.466870101471442 after inputting the mapped operator and running it on Qiskit's QAOA from qiskit.aqua import get_aer_backend, QuantumInstance from qiskit.aqua.algorithms import QAOA from qiskit.aqua.components.optimizers import COBYLA from qiskit.aqua.translators.ising import max_cut p = 1 #w = -w qubit_operators, offset = max_cut.get_max_cut_qubitops(-w) p = 1 optimizer = COBYLA() qaoa = QAOA(qubit_operators, optimizer, p) backend = get_aer_backend('statevector_simulator') quantum_instance = QuantumInstance(backend, shots=10) result = qaoa.run(quantum_instance) The output is the following: {'num_optimizer_evals': 13, 'min_val': 0.0, 'opt_params': array([0., 0.]), 'eval_time': 0.32109689712524414, 'eval_count': 13, 'energy': 0.0, 'eigvals': array([0.]), 'min_vector': array([0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j]), 'eigvecs': array([[0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j, 0.25+0.j]])} It seems as if the QAOA never evolves (optimal $\gamma$ and $\beta$ are 0) and stays in the mixer's ground state. Has anyone experienced the same problem? I'm using Qiskit's 0.9.0 (otherwise code is not compatible with the course).",<programming><qiskit><optimization><qaoa>,5/24/2021 0:33,,,,
17617.0,When is a Quantum Computer Slower Than a Classical Computer?,"Someone offhandedly mentioned to me that quantum computers are sometimes significantly (I guess they meant asymptotically) slower than classical computers. Unfortunately, I didn't get any arguments nor examples for this statement, and I'm not able to figure the limitations out myself. I tried to look up articles on the web and questions on StackExchange, but everything is about the problems where quantum computers are faster. None of them mention how solutions to the rest of the problems compare in speed, at least not what I could find. Question: What are examples where quantum computers are significantly/asymptotically slower than classical computers?",<complexity-theory><classical-computing><quantum-advantage><performance>,5/24/2021 12:56,,,,
17618.0,Can the difference between quantum and classical circuits be attributed to different paths in the Hilbert space?,"One of the explanations I have encountered for why quantum computation can provide speed-up over the classical is a picture that in the Hilbert space much more paths are allowed quantum-mechanically than classically. Indeed, it seems that we are only allowed to travel along computational axes classically, but quantum-mechanically we can take shortcuts. Is this picture morally correct? Is it possible to present some very explicit illustration? Say for the Deutsch problem or for the Grover algorithm with minimum qubits?",<quantum-algorithms><complexity-theory><classical-computing>,5/24/2021 14:01,,,,
17666.0,Implementing quDit algorithms in Qiskit using quBit,How do you implement any $d$-dimensional qudit circuit in qiskit using qubits to simulate on an actual quantum computer?,<programming><qiskit><quantum-state>,5/27/2021 6:30,,,,
17695.0,What are standard/most popular data formats to represent quantum circuits including hardware specifications?,"On an abstract level one draws a circuit diagram with wires and gates. Different software frameworks like qiskit, circ etc. probably have different ways to represent these circuits. My first question is if there is now a single standard (or highly compatible with others) format for representing &quot;textbook&quot; quantum circuits? If we are to run the circuit on an actual hardware we need to get much more specific about the abstract circuit representation. We need to tailor it to the native gates of the hardware, qubit connectivity, physical properties (time to perform gates, error rates etc.). This is called transpilation. The second question is if there is any standard extended format for quantum circuits that would take into account the hardware data. Or perhaps there is a clever way to separate device specification from the abstract description of a circuit?",<programming><quantum-algorithms><circuit-construction><quantum-circuit><transpile>,5/28/2021 12:10,,,,
17738.0,How does the pulse.Shiftphase instruction in Qiskit Pulse work?,"I have some questions regarding the mechanism of Qiskit pulse.ShiftPhase instruction: Does it work like a Phase Shift $P(\theta)=\begin{bmatrix} 1 &amp; 0 \\0 &amp; e^{i\theta} \end{bmatrix}$ gate, a Global Phase Shift $Ph(\theta)=\begin{bmatrix} e^{i\theta} &amp; 0 \\0 &amp; e^{i\theta} \end{bmatrix}$ gate, or a $R_z(\theta)=\begin{bmatrix} e^{-i\theta/2} &amp; 0 \\0 &amp; e^{i\theta/2} \end{bmatrix}$ gate? I read that when I apply a ShiftPhase it'd affect all the pulses following, meaning everytime I apply a pulse there will be a phase shift gate right? So if I only want to apply only one RZ/PS/Global PS gate should I apply a reversal phase shift after a pulse, or would that equivalently mean I have applied a PS/GPS/RZ($ -\theta$) gate? How is the free Z rotation tracked by software in the case of a qutrit (3 energy levels) or more, and how does ShiftPhase work in this case? Many thanks!",<programming><qiskit><quantum-gate><superconducting-quantum-computing><openpulse>,5/31/2021 5:16,,,,
17753.0,Apply readout error mitigation to mid-circuit measurement,"I'm trying to construct a quantum circuit with 3 mid-circuit measurements, here's an example: qrz = QuantumRegister(2,'q') crz = ClassicalRegister(3,'c') qc = QuantumCircuit(qrz,crz) for i in range (3): qc.append(qc1(...),[0,1]). # qc1 is some circuit segment. qc.measure(1,i) qc.barrier() qc = transpile(qc,backend=backend,optimization_level=2,initial_layout = [0,1]) I'm wondering if I could perform the readout error mitigation in this case. Here's what I'm trying to do: import matplotlib.pyplot as plt qlist = [1] # Suppose we want to perform the mid-circuit measurement on this qubit. cal_circuits, state_labels = complete_meas_cal(qubit_list= qlist,circlabel='mcal') print(len(cal_circuits)) cal_job = execute(cal_circuits, backend = backend, shots = 1024, optimization_level = 0 ) cal_results = cal_job.result() meas_fitter = CompleteMeasFitter(cal_results, state_labels) # Generate the complete fitter. fig, ax = plt.subplots(figsize=(10, 10)) meas_fitter.plot_calibration(ax) meas_filter = meas_fitter.filter Is there a way I can apply the filter to the qubit that I measured 3 times? Thanks for the help:)",<qiskit><programming><ibm-q-experience><quantum-circuit><error-mitigation>,5/31/2021 22:42,,,,
17820.0,Superposition of a subset of integers,I am trying to do the superposition of a subset of integers using qiskit. For instance: $|13\rangle + |14\rangle + ... |N\rangle$ (uniform superposition) without the part $|0\rangle + |1\rangle + ... + |12\rangle$. Is it possible? How can I proceed?,<programming><qiskit>,06/04/2021 08:09,,,,
17860.0,Transpilation into custom gate set in qiskit,"In qiskit, I can transpile a given circuit into a some predefined gate set as follows (just an example) from qiskit import QuantumCircuit from qiskit.compiler import transpile from qiskit.circuit.random import random_circuit basis_gates = ['id', 'u3', 'cx'] qc = random_circuit(3, 1, seed=0) qc_trans = transpile(qc, basis_gates=basis_gates) I have several related questions. Where can I find an exhaustive list of operators allowed as basis_gates? For any operator label from the list of allowed basis gates, how can I find the precise meaning of the corresponding gate, say as a matrix representation? Most importantly, can I add my own custom gates to use as basis gates? Can I add parametric gates? For examples as far as I can tell qiskit standard tools include Rxz and Ryz gates but no Rxy gate. Can I make one? Example of a (trivial) transpilation into custom gate set failing from qiskit import QuantumCircuit from qiskit.compiler import transpile qc = QuantumCircuit(2, name='mycx') qc.cx(0, 1) mycx = qc.to_gate() qc = QuantumCircuit(2) qc.cx(0, 1) transpile(qc, basis_gates=['id','mycx']) gives me a TranspileError.",<programming><qiskit><gate-synthesis><compiling><transpile>,06/08/2021 08:19,,,,
17881.0,Why can't quantum computation replace classical computation?,"I am not a total novice of quantum computation (have read the first 6 chapters of Nielsen and Chuang, though not familiar with every part), but there are some fundamental questions that I don't know answers well. One question that has bothered me is that I often hear comments which say that quantum computers can not be regarded as a replacement for classical ones. However, we also know that all classical circuits can be simulated by quantum circuits. Put it another way, every Boolean function $f:\{0,1\}^k\to\{0,1\}$ can be computed by using a quantum circuit. So, how to correctly understand the problems that a quantum computer might encounter when doing a classical computer's job? I know a strong restriction on quantum computing is that we can't read the resulting qubits state directly, but has to use quantum measurement so that we can only get one of the computational basis states probabilistically. However, I don't see this is a difficulty if what we want to do is only to compute a Boolean function. Following are some possible answers I've thought of: Quantum computers can do everything classical computers do, but no more efficiently if we only use the standard technique to simulate classical circuits. Quantum computers outperform classical ones only when special quantum algorithms exploiting superpositions of quantum states are applied, such as the quantum Fourier transform (QFT). In Nielsen and Chuang (Section 5.1), it says QFT cannot replace classical discrete Fourier transform. Besides the problem that the amplitudes cannot be directly accessed by measurement, it points out that the worse problem is that &quot;there is in general no way to efficiently prepare the original state to be Fourier transformed.&quot; Maybe such kind of problems is important for many applications. Are the above answers right? Are there other important reasons quantum computers cannot replace the classical ones?",<classical-computing><performance>,06/09/2021 08:58,,,,
17884.0,How to calculate Alpha and Beta values for QAOA Max-cut problem manually?,"I'm new to Quantum Computing. I came across solving the Max-cut problem using QAOA. For example, if I have a $U3$ gate with parameters $U3(0,0, \gamma_{XYZ})$ gamma parameter at $p=X$ between logical qubit Y and Z; and $Rz(\beta_X)$ beta parameter at $p=X$, how do I calculate the values of $\gamma$ and $\beta$?",<programming><quantum-algorithms><qaoa>,06/09/2021 15:22,,,,
17931.0,"Circuit to transform $|0\rangle$ into $\alpha|0\rangle + \beta|1\rangle$ for any $\alpha, \beta$",Hi I'm new to QC and doing some katas in Q#. I got stuck on this excercise and would appreciate help: Quantum circuit to get following state qubit: $\alpha|0\rangle + \beta|1\rangle$ when the input is $|0\rangle$ and of course $|\alpha|^2+|\beta|^2=1$. Thanks!,<quantum-gate><quantum-state><q#>,06/12/2021 16:47,,,,
17932.0,Is a black-box gate whose output is conditional on the value of an input amplitude possible?,"Suppose we have a qubit in the state $|q\rangle = a |0\rangle + b |1\rangle$, and another ancilla qubit $= |0\rangle$. I wish to have the following black-box gate: if |a| &gt; 0.8, then turn the ancilla to |1â© else leave the ancilla unchanged at |0â©. Is it possible to construct such a black-box gate? (Background information: I do not want to use measurement on $|q\rangle$ because that will terminate the quantum process. I need to continue the quantum process. In my case, the resulting ancilla state is used to control the subsequent quantum computing as part of a larger quantum system where computation process will differ depending on whether the ancilla qubit is 0 or 1.)",<programming><quantum-gate><quantum-state><simulation>,06/12/2021 17:40,,,,
17982.0,What are the types of models of computation aside from the quantum query model?,"It looks like in a lot of quantum algorithms, we use the quantum query model. I wanted to know what are the other types of models of computation, used in quantum computing as well as in classical computing? On what model of computation are algorithms (such as Binary Search, Sorting, etc.) based?",<quantum-algorithms><complexity-theory><classical-computing>,6/16/2021 9:00,,,,
18020.0,Why is sampling considered difficult on a classical computer but easy on a quantum computer?,"It is my understanding that classical computers have a hard time sampling results from an output from a quantum circuit, but quantum computers find it very easy to do so. Why is this?",<complexity-theory><classical-computing><fourier-sampling>,6/18/2021 16:02,,,,
18053.0,Issues in calculating exact runtime on ibmq_16_melbourne,"I am working on calculating the exact runtime of a quantum circuit on the ibmq_16_melbourne device. I am using the API result.time_taken to calculate the run time. result = execute(circuit, backend, shots=8000).result() counts = result.get_counts(circuit) print(counts) print(&quot;Time taken: &quot;, result.time_taken) I executed by python code on ibm quantum lab (which is a Jupyter notebook) and also using Pycharm on my laptop. I get huge variations in the results. So, I concluded that result.time_taken does not provide the run time correctly. I am going through the documentation, but still could not find the solution. Please provide some solution to calculate exact runtime.",<programming><qiskit>,6/20/2021 17:19,,,,
18055.0,IBMQ.load_account() is failing,"When I try IBMQ.load_account or IBMQ.delete_account gives an error in the ubuntu machine and the error is, Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/home/anaconda3/lib/python3.7/site-packages/qiskit/providers/ibmq/ibmqfactory.py&quot;, line 291, in delete_account stored_credentials, _ = read_credentials_from_qiskitrc() File &quot;/home/anaconda3/lib/python3.7/site-packages/qiskit/providers/ibmq/credentials/configrc.py&quot;, line 86, in read_credentials_from_qiskitrc new_credentials = Credentials(**single_credentials) # type: ignore[arg-type] TypeError: __init__() got an unexpected keyword argument 'efault_provider' The qiskit version I used is {'qiskit-terra': '0.17.4', 'qiskit-aer': '0.8.2', 'qiskit-ignis': '0.6.0', 'qiskit-ibmq-provider': '0.14.0', 'qiskit-aqua': '0.9.2', 'qiskit': '0.27.0', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}",<programming><qiskit>,6/20/2021 19:05,,,,
18060.0,Why qiskit transpiler makes different results everytime? (Non-deterministic),"I tried to do qubit mapping called 'SABRE' and execute transpiled quantum circuit. I use FakeTokyo backend which has some noise because it is mock version of IBMQ 20-Tokyo. I know using this backend makes some noise but will not change final result when I measure my circuit. But, when I transpile my quantum circuit like below code, the result is always different. I wonder why this happens. Source code: from qiskit.test.mock import FakeTokyo from qiskit.circuit.measure import measure from qiskit.execute_function import execute from qiskit.circuit.quantumcircuit import QuantumCircuit from qiskit.compiler import transpile backend = FakeTokyo() final_circuit = transpile(circuits=circuit, backend=backend, routing_method='sabre', layout_method='sabre', basis_gates=['u1', 'u2', 'u3', 'cx', 'id']) final_circuit.barrier() final_circuit.measure_all() results = execute(final_circuit, backend).result() counts = results.get_counts() print(&quot;result : &quot;, counts) circuits = circuit means I input list of quantum circuits into transpile function. I really don't know why the results always different.",<programming><qiskit><transpile>,6/21/2021 6:18,,,,
18092.0,Extract the Crosstalk noise of a circuit in Qiskit,I'm new to Quantum Computing. How to extract the cross-talk noise of a quantum circuit using qiskit? Can someone provide an example code for this?,<programming><qiskit><quantum-gate>,6/22/2021 15:50,,,,
18134.0,How does one access data from retired backends?,"I am having trouble retrieving data using Qiskit from jobs I ran on a currently retired system. However, I can still retrieve the same data from the dashboard (GUI), so I think the data are still there. For instance, the following code works just fine for retrieving counts data from an old job I ran on Melbourne (currently in service): BACKEND='ibmq_16_melbourne' JOB_ID='6009735f4ae4e567f432feca' my_backend = provider.get_backend(BACKEND) my_job = my_backend.retrieve_job(JOB_ID) COUNTS = my_job.result().get_counts() However, the same code but trying to retrieve data from a job that ran on Vigo fails: BACKEND='ibmq_vigo' JOB_ID='60037fbf2159c338e734e663' my_backend = provider.get_backend(BACKEND) my_job = my_backend.retrieve_job(JOB_ID) COUNTS = my_job.result().get_counts() The error message I get is QiskitBackendNotFoundError: 'No backend matches the criteria' Is there an alternative way to do this? Thank you! Jorge",<programming><qiskit>,6/24/2021 23:06,,,,
18180.0,Recover qubits used in an actual computation,"How do I recover from a certain job_id in the IBM backends which qubits where used? I would be interested to know if for instance, in a batch of say 50 jobs, 25 of them are run in qubits 0 and 1 but the other half in say 5 or 7.",<programming><ibm-q-experience>,6/29/2021 11:22,,,,
18204.0,Use of Data loaders or State Initialization Circuits,"I have recently started working on qiskit and I am struggling to use qc.initialize API in any practical or useful application. I have read at multiple places that they are used to feed data to the quantum circuits. For developing an understanding of the quantum computers, I executed the code of Bernstein Vazirani Algorithm(secret number detector) on qasm_simulator using Pycharm IDE as shown below without using any initialization circuit. import qiskit from qiskit import IBMQ import time from qiskit import * from qiskit.tools.visualization import plot_histogram from qiskit.tools.visualization import plot_bloch_multivector import matplotlib.pyplot as plt from qiskit.tools.monitor import job_monitor #IBMQ.save_account('Account key',overwrite=True) # Run it for once # 6 bit secret number secretNumber= '101001' circuit= QuantumCircuit(6+1,6) # 6 qubit for secret no. +1 qubit circuit. h([0,1,2,3,4,5]) circuit.x(6) circuit.h(6) circuit.barrier() # splitting the string into char splitSecretNumber= list(secretNumber) lengthofSecretNumber= len(splitSecretNumber) x=0 while(x&lt; lengthofSecretNumber): if(str(splitSecretNumber[x])=='1'): circuit.cx(int(x),6) x=x+1 circuit.barrier() circuit.h([0,1,2,3,4,5]) circuit.barrier() circuit.measure([0,1,2,3,4,5],[0,1,2,3,4,5]) circuit.draw(output=&quot;mpl&quot;) simulator= Aer.get_backend('qasm_simulator') simulationResult = execute(circuit,simulator, shots=1).result() counts= simulationResult.get_counts() print(counts) plot_histogram(simulationResult.get_counts(circuit)) plt.show() Please guide me to convert this code to take Input data using initialization circuit. Also, please suggest me some good papers to read on initialization. Thanks in advance.",<programming><qiskit><qasm>,6/30/2021 7:42,,,,
18221.0,Difference in HLL applications,"I am new to Qiskit and I have seen two types of simple 2X2 $Ax=b$ system solutions. I am wondering what the difference is exactly. They both occur on a simulator backend, but the first gives me a Euclidean norm and the second gives me a horrible state vector answer and associated (very low) probability. code 1 matrix = np.array([[1, -1/3], [-1/3, 1]]) vector = np.array([1, 0]) naive_hhl_solution = HHL().solve(matrix, vector) code 2 def create_eigs(matrix, num_ancillae, num_time_slices, negative_evals): ne_qfts = [None, None] if negative_evals: num_ancillae += 1 ne_qfts = [QFT(num_ancillae - 1), QFT(num_ancillae - 1).inverse()] #Construct the eigenvalues estimation using the PhaseEstimationCircuit return EigsQPE(MatrixOperator(matrix=matrix), QFT(num_ancillae).inverse(), num_time_slices=num_time_slices, num_ancillae=num_ancillae, expansion_mode='suzuki', expansion_order=2, evo_time=None, negative_evals=negative_evals, ne_qfts=ne_qfts) def HHLsolver(matrix, vector, backend, no_ancillas, no_time_slices): orig_size = len(vector_b) #adapt the matrix to have dimension 2^k matrix, vector, truncate_powerdim, truncate_hermitian = HHL.matrix_resize(matrix_A, vector_b) #find eigenvalues of the matrix wih phase estimation (i.e. calc. exponential of A, apply #phase estimation) to get exp(lamba) and then inverse QFT to get lambdas themselves eigs = create_eigs(matrix, no_ancillas, no_time_slices, False) #num_q â Number of qubits required for the matrix Operator instance #num_a â Number of ancillary qubits for Eigenvalues instance num_q, num_a = eigs.get_register_sizes() #construct circuit for finding reciprocals of eigenvalues reci = LookupRotation(negative_evals=eigs._negative_evals, evo_time=eigs._evo_time) #preparing init state for HHL, i.e. the state containing vector b init_state = Custom(num_q, state_vector=vector) #construct circuit for HHL based on matrix A, vector B and reciprocals of eigenvalues algo = HHL(matrix, vector, truncate_powerdim, truncate_hermitian, eigs, init_state, reci, num_q, num_a, orig_size) #solution on quantum computer result = algo.run(quantum_instance = backend) print(&quot;Solution:\t\t&quot;, np.round(result['solution'], 5)) print(&quot;Probability:\t\t %f&quot; % result['probability_result']) print(&quot;Quantun result storage:\t&quot;,result) #refence solution - NumPyLSsolver = Numpy LinearSystem algorithm (classical). result_ref = NumPyLSsolver(matrix, vector).run() print(&quot;Classical Solution:\t&quot;, np.round(result_ref['solution'], 5)) matrix_A = np.array([[1, -1/3], [-1/3, 1]]) vector_b = [1, 0] processor = Aer.get_backend('statevector_simulator') no_ancillas = 3 #number of ancilla qubits no_time_slices = 50 #number of timeslices in exponential of matrix A (exp(i*A*t)) HHLsolver(matrix_A, vector_b, processor, no_ancillas, no_time_slices)",<programming><qiskit><hhl-algorithm>,6/30/2021 22:38,,,,
18245.0,HLL Algorithm results interpretation,"I have the following HLL qiskit implementation and really need some help interpreting the results! CODE ------------------------------ from qiskit import QuantumRegister, QuantumCircuit t = 2 # This is not optimal; As an exercise, set this to the # value that will get the best results. See section 8 for solution. nqubits = 4 # Total number of qubits nb = 1 # Number of qubits representing the solution nl = 2 # Number of qubits representing the eigenvalues theta = 0 # Angle defining |b&gt; a = 1 # Matrix diagonal b = -1/3 # Matrix off-diagonal # Initialize the quantum and classical registers qr = QuantumRegister(nqubits) # Create a Quantum Circuit qc = QuantumCircuit(qr) qrb = qr[0:nb] qrl = qr[nb:nb+nl] qra = qr[nb+nl:nb+nl+1] # State preparation. qc.ry(2*theta, qrb[0]) # QPE with e^{iAt} for qu in qrl: qc.h(qu) qc.p(a*t, qrl[0]) qc.p(a*t*2, qrl[1]) qc.u(b*t, -np.pi/2, np.pi/2, qrb[0]) # Controlled e^{iAt} on \lambda_{1}: params=b*t qc.p(np.pi/2,qrb[0]) qc.cx(qrl[0],qrb[0]) qc.ry(params,qrb[0]) qc.cx(qrl[0],qrb[0]) qc.ry(-params,qrb[0]) qc.p(3*np.pi/2,qrb[0]) # Controlled e^{2iAt} on \lambda_{2}: params = b*t*2 qc.p(np.pi/2,qrb[0]) qc.cx(qrl[1],qrb[0]) qc.ry(params,qrb[0]) qc.cx(qrl[1],qrb[0]) qc.ry(-params,qrb[0]) qc.p(3*np.pi/2,qrb[0]) # Inverse QFT qc.h(qrl[1]) qc.rz(-np.pi/4,qrl[1]) qc.cx(qrl[0],qrl[1]) qc.rz(np.pi/4,qrl[1]) qc.cx(qrl[0],qrl[1]) qc.rz(-np.pi/4,qrl[0]) qc.h(qrl[0]) # Eigenvalue rotation t1=(-np.pi +np.pi/3 - 2*np.arcsin(1/3))/4 t2=(-np.pi -np.pi/3 + 2*np.arcsin(1/3))/4 t3=(np.pi -np.pi/3 - 2*np.arcsin(1/3))/4 t4=(np.pi +np.pi/3 + 2*np.arcsin(1/3))/4 qc.cx(qrl[1],qra[0]) qc.ry(t1,qra[0]) qc.cx(qrl[0],qra[0]) qc.ry(t2,qra[0]) qc.cx(qrl[1],qra[0]) qc.ry(t3,qra[0]) qc.cx(qrl[0],qra[0]) qc.ry(t4,qra[0]) qc.measure_all() #------------------------------- qc.draw(fold=-1) from qiskit import BasicAer, ClassicalRegister, IBMQ from qiskit.compiler import transpile from qiskit.ignis.mitigation.measurement import (complete_meas_cal,CompleteMeasFitter, MeasurementFilter) backend = provider.get_backend('ibmqx2') # calibrate using real hardware layout = [2,3,0,4] chip_qubits = 5 # Transpiled circuit for the real hardware qc_qa_cx = transpile(qc, backend=backend, initial_layout=layout) meas_cals, state_labels = complete_meas_cal(qubit_list=layout, qr=QuantumRegister(chip_qubits)) qcs = meas_cals + [qc_qa_cx] job = backend.run(qcs, shots=10) result = job.result() counts = result.get_counts() print(counts) # there are 17 of these ... why? OUTPUT ------------------------------- [{'0000': 7, '0001': 2, '0010': 1}, {'0001': 9, '1001': 1}, {'0010': 7, '0011': 3}, {'0001': 1, '0010': 1, '0011': 7, '0110': 1}, {'0000': 1, '0100': 8, '1100': 1}, {'0000': 1, '0100': 1, '0101': 8}, {'0010': 1, '0110': 7, '0111': 2}, {'0010': 2, '0110': 2, '0111': 6}, {'0000': 2, '1000': 5, '1100': 3}, {'0001': 4, '1000': 2, '1001': 3, '1010': 1}, {'0010': 2, '1010': 5, '1011': 3}, {'0001': 1, '0111': 1, '1010': 2, '1011': 5, '1111': 1}, {'0100': 1, '1000': 1, '1100': 5, '1101': 2, '1110': 1}, {'0001': 1, '0101': 1, '1001': 1, '1101': 7}, {'0110': 1, '1010': 1, '1110': 6, '1111': 2}, {'1010': 2, '1011': 1, '1111': 7}, {'0001': 2, '0011': 1, '0101': 1, '0110': 1, '1000': 1, '1100': 2, '1110': 1, '1111': 1}] Questions ---------------------------------- (1) It appears that each of terms {} are a superposition state where the count/prob amplitudes are given for the comprising 4 qubit states. Is this a correct way to read this? (2) If the above is true, why are there 17 states here? (3) Lastly, how can I relate these counts or the subsequent histogram back to the solution vector X = {1.125,0.375}? I can't seem to find a decent book on practical quantum computing for linear systems, so any recommendations are great there! Thanks in advance! -Corey",<programming><qiskit>,07/01/2021 22:20,,,,
18258.0,Trying to connect IBM Quantum to External API,Is it possible to connect a quantum computer to openlibary.org API? How do I find the public IP address to my quantum instance?,<programming><ibm-q-experience>,07/02/2021 17:30,,,,
18331.0,Error when computing the self-designed gradient in qiskit,"I had question with the way to define a new kind of gradient to improve the performance of VQE. The gradient formula I used consists of multiply energy (measurement result of the Hamiltonian) with the gradient of the energy. I follow the instruction of the qiskit gradient framework page, and take the following code as an example #General imports import numpy as np #Operator Imports from qiskit.opflow import Z, X, I, Y, StateFn, CircuitStateFn, SummedOp from qiskit.opflow.gradients import Gradient, NaturalGradient, QFI, Hessian #Circuit imports from qiskit.circuit import QuantumCircuit, QuantumRegister, Parameter, ParameterVector, ParameterExpression from qiskit.circuit.library import EfficientSU2 a = Parameter('a') b = Parameter('b') q = QuantumRegister(1) qc = QuantumCircuit(q) qc.h(q) qc.rz(a, q[0]) qc.rx(b, q[0]) # Instantiate the Hamiltonian observable H1 = (2 * X) + Z H2 = X+Y+Z # Combine the Hamiltonian observable and the state op1 = ~StateFn(H1) @ CircuitStateFn(primitive=qc, coeff=1.) op2 = ~StateFn(H2) @ CircuitStateFn(primitive=qc, coeff=1.) op = op1 @ op2 print('op is', op) params = [a, b] # Define the values to be assigned to the parameters value_dict = {a: np.pi / 4, b: np.pi} # Convert the operator and the gradient target params into the respective operator grad = Gradient().convert(operator = op1, params = params) # Print the operator corresponding to the Gradient grad = op1 @ grad The last line of the code pops an exception: Exception has occurred: ValueError Composition with a Statefunctions in the first operand is not defined. How to get rid of the exception in this case? Also, I need to get the result for the multiplication of two measured operator in the process (op1 and op2), does the code above op=op1@op2 can achieve this?",<programming><qiskit>,07/07/2021 11:46,,,,
18381.0,How to download from IBM Quantum lab folder of data .txt files all at once?,"I have a script in the IBM Quantum lab which runs several jobs and stores the result of each job as a .txt file in a results folder. All I want to do is to download the folder of files. I cannot figure out how to do this and so at the moment I have to open the folder in the Quantum Lab and then select each file and individually download it. This is getting very tiresome. I feel like I must be missing something really simple that would enable me to just download the folder, but when I click on the dropdown menu for the folder, all it allows me to do is to rename or delete it. Sorry for the stupid question!",<programming><ibm-q-experience>,07/10/2021 00:15,,,,
18420.0,Trouble when implement a self designed gradient in qiskit,"everyone! I have trouble when implement a self-designed gradient to the VQE algorithm. The following code will pop the 'ListOp' object is not callable exception to the last line of the code when executed. Can anybody tell me how to fix this? H2 = (-1.052373245772859 * I ^ I) + \ (0.39793742484318045 * I ^ Z) + \ (-0.39793742484318045 * Z ^ I) + \ (-0.01128010425623538 * Z ^ Z) + \ (0.18093119978423156 * X ^ X) optimizer = AQGD(maxiter=10) var_form = EfficientSU2(2, su2_gates=['ry', 'rz'], entanglement='linear', reps=2) op1 = ~StateFn(H2) @ CircuitStateFn(primitive=var_form, coeff=1.) op2 = ~StateFn((H2 @ H2).reduce()) @ CircuitStateFn(primitive=var_form, coeff=1.) op = 3 * op1 - 4 * op2 grad = Gradient().convert(operator = op, params = list(var_form.parameters)) vqe = VQE(var_form, optimizer, gradient=grad, quantum_instance=Aer.get_backend('aer_simulator_statevector')) result = vqe.compute_minimum_eigenvalue(operator=H2)",<programming><qiskit><vqe>,7/13/2021 7:53,,,,
18495.0,Thoughts in coding large and repetitive/non-repetitive quantum circuits?,"Just out of curiosity, are there advances or directions on how to write a program (e.g. in qiskit) for a large number of qubits? Assuming that the number of gates that can be applied can be &quot;arbitrary&quot; long along with the coherences, how would one code a circuit for maybe $2^{50}$ spins?* Obviously if the circuit is a bit &quot;repetitive&quot;, one can store the &quot;base&quot; circuit only once and applied as many times as needed. But right now does it exist already a tool for such cases? What will happen in the future if the code is fairly complex with few repetitions? *There are considerable more information in a circuit code that in just the lists of 1 and 0's of binary data...",<programming><qiskit>,7/19/2021 11:24,,,,
18580.0,How to Implement a noisy identity gate on qiskit?,"I can successfully implement the U gate (single qubit) on qiskit, but when I am trying for the identity operation it is not showing any differences with the ideal one .",<programming><qiskit><ibm-q-experience>,7/23/2021 13:09,,,,
18639.0,"Is it true that the way we must program Quantum Computers is through Total functions only, if so why?",I have read that the way we must program Quantum Computers is through Total functions only. Why is this the case? Is it because quantum circuits are less forgiving in terms of logical errors? Could you provide an academic reference?,<programming><quantum-algorithms>,7/28/2021 9:21,,,,
20692.0,Applying projectors with mid-circuit measurements,"I am trying to apply a non-unitary projector (see image) to my two-qubit quantum circuit using mid-circuit measurements. $$ \begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \ \end{pmatrix} $$ Since I am a bit stumped on whether I can apply this projector to qubits in the middle of the circuit, I am using conditional resets in the following way: for i in range(1, t): #print ('Measuring ' + str(i) + ' times') #do not apply unitary if the outcome is |00&gt; (1000) or |11&gt; (0001) qRandWalk.measure(qlist,creg) qRandWalk.x(qlist[1]).c_if(creg,5) #resets 1001 (|01&gt;) to (1010) |00&gt; qRandWalk.x(qlist[1]).c_if(creg,10) #resets 0110 (|10&gt;) to (0101) |11&gt; qRandWalk.append(unitary_operator, qlist).c_if(creg,6) # 6 in binary is 0110, |10&gt; qRandWalk.append(unitary_operator, qlist).c_if(creg,9) #9 in binary is 1001, |01&gt; I want to project the measured state onto a subspace, then append the unitary operator to the circuit depending on the measurement outcome. I am not sure whether that is what my current code is doing. Are there any other approaches I can take at the moment, running on QASM simulator?",<programming><qiskit><measurement><projection-operator>,08/02/2021 17:10,,,,
20817.0,AWS Braket Backend for Qiskit?,Is there a working AWS Braket backend provider for Qiskit 0.29 that can be used with the MinimumEigenOptimizer interface? The qiskit-aws-braket-provider package is unfortunately not working.,<programming><qiskit><amazon-braket>,08/11/2021 18:40,,,,
20894.0,Saving statevector on more than one location in a quantum circuit in Qiskit,"So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system? Below you can see the code idea: q1 = QuantumCircuit(2) q1.save_statevector() # Save initial state q1.h(0) q1.save_statevector() # Save state after Hadamard q1.cx(0, 1) q1.save_statevector() # Save state after CNOT (also a final state) job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024) statevectors = job.result().get_statevector() However, if I were to try and run this, an error occurs upon reaching execute command. If anyone can provide any insight on this, I would be very grateful.",<programming><qiskit><quantum-state><ibm-q-experience>,8/20/2021 15:17,,,,
20907.0,How to get information about 'qubit location' or 'variable of qubit location' in qiskit docs?,"I have something problem with using qiskit. I searched several qiskit docs to get 'qubit location' or 'variables' that represent qubit. I searched three documents below. qiskit.transpiler.passes.layout.sabre_layout qiskit.transpiler.passes.routing.sabre_swap qiskit.dagcircuit.DAGCircuit However, I couldn't get the information about qubit location in these docs. SABRE algorithm use qubit location to switch qubit's location to execute on the real quantum hardware with satisfying its coupling graph. That's why I'm sure that these docs will contain information about qubit location to use them. But I can't find it. Could you help me? If I need to find out some other docs, please let me know. Thank you.",<programming><qiskit><resource-request><sabre>,8/22/2021 6:37,,,,
20939.0,Pad get_counts() with zeros for unmeasured states? (Qiskit),"After executing a job on qiskit, the typically procedure to get the measurement data from the quantum computer is to call get_counts() like so... job = execute(qc, backend, shots=100) result = job.result() counts = result.get_counts() If the final state is, for example, $|01\rangle$ then '01' would be the only key in counts. Does Qiskit currently have a way to pad the returned counts dictionary with 0s for all other states? So, it'd return something like counts = results.get_counts(pad=True), and counts would then be counts = {'00':0, '01':100, '10':0, '11':0}? It'd be great if this was a native option.",<programming><qiskit><measurement>,8/23/2021 17:00,,,,
20997.0,"What is an example of numbers that when used for a Gaussian pulse, would result in a rotation about the x axis?","For the playing of a Gaussian pulse, what is an example of numbers that could be plugged in for duration, amp, and sigma that would result in the pulse rotating something about the x axis? Here is the code that I have so far: with pulse.build(backend, name='hadamard') as h_q0: pulse.play(Gaussian(duration=1200, amp=0.1409018732350299, sigma=32), pulse.drive_channel(0))",<programming><qiskit><openpulse>,8/27/2021 12:47,,,,
21066.0,Callback in VQC does not return correct float value for objective function evaluation,"The callback for the VQC class is defined as: callback (Optional[Callable[[ndarray, float], None]]) â a reference to a userâs callback function that has two parameters and returns None. The callback can access intermediate data during training. On each iteration, an optimizer invokes the callback and passes current weights as an array and a computed value as a float of the objective function being optimized. This allows to track how well the optimization / training process is going on. The function that I am passing to that argument is: weights = [] loss = [] def store_intermediate_result(current_weights, current_loss): print(current_loss) weights.append(np.copy(current_weights)) loss.append(current_loss) However, the loss value passed back is always the same. I had this issue before with the weights, however, when I printed the weights they were different. So it was a problem of just copying the array as you can see in the code sample. But with the loss values, they are always the same no matter what I do. The vqc code is as follows: vqc = VQC(feature_map=feature_map, ansatz=ansatz, loss='cross_entropy', optimizer=AQGD(maxiter=5), quantum_instance=QuantumInstance(Aer.get_backend('aer_simulator_statevector')), callback=store_intermediate_result) EDIT: The problem seemed to be the optimiser used. COBYLA works but AQGD does not. The issue has been raised on GitHub.",<programming><qiskit>,09/03/2021 17:41,,,,
21286.0,Decomposition of the multi-controlled gate in tensorflow quantum,"In TensorFlow Quantum 0.5.0, the support for Cirq gates that have arbitrary control via the gate.controlled_by function is added. I would like to know which kind of decomposition method is used for this operation? The current decomposition seems to be efficient and any information related to that is very welcomed.",<programming><quantum-gate><cirq><tfq>,9/22/2021 9:37,,,,
21359.0,"How to solve non-""cross-damping off"" Linblad equation in QuTiP?","As I understand from the official QuTiP guidlines, it is only capable of solving &quot;cross-damping off&quot; Master Equation in form: $\dot{\rho(t)} = -\dfrac{i}{\hbar}[H(t),\rho(t)] + \sum\limits_n\dfrac{1}{2}\left[ C_n\rho(t)C_n^{\dagger} - \rho(t)C_n^{\dagger}C_n - C_n^{\dagger}C_n\rho(t) \right].$ Where $C_n$ are collapse operators. However when we need to consider cross-damping, the ME takes the form like: $\dot{\rho(t)} = -\dfrac{i}{\hbar}[H(t),\rho(t)] + \sum\limits_{i,j}\dfrac{1}{2}\left[ C_i\rho(t)C_j^{\dagger} - \rho(t)C_i^{\dagger}C_j - C_i^{\dagger}C_j\rho(t) \right].$ Is QuTiP capable of solving this? And how one can manage to code this if it is?",<programming><optical-quantum-computing><qutip><master-equation>,9/28/2021 11:42,,,,
21364.0,The difference between the unitary matrix in ProjectQ and Qiskit,"Why are not the same unitary matrices in ProjectQ and Qiskit in the following codes: ProjectQ: drawing_engine = CircuitDrawerMatplotlib() eng = MainEngine(backend = UnitarySimulator(), engine_list = [drawing_engine]+get_engine_list()) qreg = eng.allocate_qureg(3) theta1 = pi/4 theta2 = pi/5 X | qreg[2] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta2) | qreg[0] X | qreg[1] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta1) | qreg[0] X | qreg[2] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta2) | qreg[0] X | qreg[1] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta1) | qreg[0] X | qreg[2] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta2) | qreg[0] X | qreg[1] with Control(eng, [qreg[2],qreg[1]]): Ry(2*theta1) | qreg[0] eng.flush() print(eng.backend.unitary.real) Qiskit: qreg = QuantumRegister(3) creg = ClassicalRegister(3) circuit = QuantumCircuit(qreg,creg) theta1 = pi/4 theta2 = pi/5 circuit.x(qreg[2]) circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) circuit.x(qreg[1]) circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) circuit.x(qreg[2]) circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) circuit.x(qreg[1]) circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) circuit.x(qreg[2]) circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) circuit.x(qreg[1]) circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) job = execute(circuit,Aer.get_backend('unitary_simulator'),optimization_level=0) unitary_matrix=job.result().get_unitary(circuit,decimals=8) unitary_matrix.real",<qiskit><programming><projectq>,9/28/2021 18:49,,,,
21382.0,Qiskit noise model question (from textbook),"I'm reading the chapter Introduction to Quantum Error Correction using Repetition Codes and a code example demonstrates how to add depolarizing and pauli error. I have several questions. Is it not necessary to have an error_gate for the Pauli-I operator as defined in pauli_error? Does using .tensor on error_gate1 to create error_gate2 replicate the error_gate1 line for error_gate2? Why can't you simply use error_gate1 instead of a creating a second equivalent error_gate2? Is it necessary to have an error_gate for cx, or is that an arbitrary choice for this particular example? Code-wise, is it acceptable to have a noise_model with just an error_gate1 applied to the x_gate, or is there something impractical about that? def get_noise(p_meas,p_gate): error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)]) error_gate1 = depolarizing_error(p_gate, 1) error_gate2 = error_gate1.tensor(error_gate1) noise_model = NoiseModel() noise_model.add_all_qubit_quantum_error(error_meas, &quot;measure&quot;) # measurement error is applied to measurements noise_model.add_all_qubit_quantum_error(error_gate1, [&quot;x&quot;]) # single qubit gate error is applied to x gates noise_model.add_all_qubit_quantum_error(error_gate2, [&quot;cx&quot;]) # two qubit gate error is applied to cx gates return noise_model",<qiskit><programming><textbook-and-exercises><error-correction><depolarizing-channel>,10/01/2021 12:36,,,,
21421.0,How can extract reduced dynamics of a bipartite system from unitary evolution in quite,"Let us assume that I have a bipartite system $A\otimes B$ and an initial product state undergoing some evolution $H^{AB} = H^A+H^B+V^{AB}$, which is time independent. I want to simulate the reduced dynamics of $A$ only in qutip, and to do so I first generate the unitary dynamics of the full system as result = sesolve(H, psi0, times) where psi0 is the initial state and times is the discrete vector of times. From that I can extract the state at each time $t_i \in$times like result.states[i] and then do the partial trace like result.states[i].ptrace(0) and obtain the reduced state of $A$ at the corresponding time. Anyway, I would like to do that for all the time $t_i$ and having a vector of results like result.states[i] is. There is a nice and quick way to do that from the result object? Or I need to define a new function that takes the result.states object and that for me? I'm new to quit so I do not know if this exists by default. Then,",<programming><quantum-state><hamiltonian-simulation><unitarity><qutip>,10/05/2021 16:50,,,,
21427.0,How to create a quantum circuit to implement the same operations but acting on different qubits?,"I want the draw the quantum circuit of the following Hamiltonian: $$H = - 4 \times X\otimes X\otimes X\otimes X - 4\times Z\otimes Z\otimes Z \otimes Z$$. I have been able to draw the circuits of $ - X\otimes X\otimes X\otimes X$ and $- Z\otimes Z\otimes Z \otimes Z$. But adding them up using qiskit functions like compose, and combine did not give me the matrix I am looking for. I would like to recall that when looking at $ 4 \times X\otimes X\otimes X\otimes X$ for instance, the operator $ X\otimes X\otimes X\otimes X$ will be applied $4$ times but not on the same set of qubits and the matrix should $16\times 16$. Using compose and combine function, I still obtain the $16\times 16$ matrix by its components do not add up. Instead, the gates acted on the same set of qubits. It will be very helpful if someone can help me. Thanks",<qiskit><programming><quantum-circuit><stabilizer-code>,10/06/2021 08:34,,,,
21450.0,from hello_qiskit import run_puzzle results in error,"I am working my way through the beta version of the Qiskit textbook. Everything was going fine until I got to the Visualizing Entanglement section and had some exercises to complete. All of the exercises rely on the hello_qiskit package which doesn't seem available. I have also tried running the exercises in the IBM Quantum Lab but it resulted in similar issues. Traceback (most recent call last): File &quot;/tmp/ipykernel_426/3330317747.py&quot;, line 1, in &lt;module&gt; from hello_qiskit import run_puzzle ModuleNotFoundError: No module named 'hello_qiskit' Use %tb to get the full traceback.",<qiskit><programming><textbook-and-exercises>,10/07/2021 16:09,,,,
21492.0,Can error correction for a classical algorithm with bit flips be easier than for a general quantum circuit?,"Assume one runs a purely classical algorithm on $n$ logical qubits on a physical device with some bit flip probability. Can implementing error correction in this case be any easier than in the case of a general quantum circuit? I guess, given that the hardware is &quot;quantum&quot;, to answer this question we also need to make assumptions on probabilities of hardware errors other than bit flips. Basically I'm trying to understand whether quantum error correction has anything to offer to classical computation, at a cost less then the &quot;full&quot; quantum error correction.",<error-correction><classical-computing><cq-states>,10/10/2021 14:56,,,,
21497.0,Working with higher energy states in Qiskit Experiments,"I'm looking at the source code for the Qiskit Experiments module and see that the EFRabi class subclasses the Rabi class with the intent of calibrating rotations between the 1 and 2 states instead of between 0 and 1. The only change I see in the circuit is the addition of an X gate at the beginning. How could this be done for other calibration experiments, e.g. one of the FineAmplitude experiments? Why does the X gate allow us to calibrate on higher energy states?",<qiskit><programming><quantum-state><quantum-circuit><experimental-realization>,10/11/2021 00:33,,,,
21522.0,How to write a code to made envelope function equal to $\pi$ to result in an X gate?,$$ \hat U_d = \exp\Big( -i\underbrace{\frac{Q}{2}\int_0^T A(t^\prime)\mathop{dt^\prime}}_{\Theta(t)} \hat\sigma_x \Big) $$ This equation is a Unitary transformation applied to a qubit from time $t = 0$ to time $t=T$. I want the underlined envelope function $\Theta(t)$ to equal $\pi$ to result in an $X$ gate. What code should I write to accomplish this? Should I do frequency sweeps of multiple parameters? I know that a Gaussian pulse should be involved.,<qiskit><programming>,10/13/2021 14:51,,,,
21588.0,Are we using the real-time error information in simulating noise on qasm?,"I'm trying to run some quantum circuits on qasm simulator using the noise information from IBM Q quantum device: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_casablanca') noise_model = NoiseModel.from_backend(backend) coupling_map = backend.configuration().coupling_map basis_gates = noise_model.basis_gates As I print(noise_model), I got NoiseModel: Basis gates: ['cx', 'id', 'reset', 'rz', 'sx', 'x'] Instructions with noise: ['reset', 'measure', 'x', 'sx', 'id', 'cx'] Qubits with noise: [0, 1, 2, 3, 4, 5, 6] Specific qubit errors: [('id', [0]), ('id', [1]), ('id', [2]), ('id', [3]), ('id', [4]), ('id', [5]), ('id', [6]), ('sx', [0]), ('sx', [1]), ('sx', [2]), ('sx', [3]), ('sx', [4]), ('sx', [5]), ('sx', [6]), ('x', [0]), ('x', [1]), ('x', [2]), ('x', [3]), ('x', [4]), ('x', [5]), ('x', [6]), ('cx', [6, 5]), ('cx', [5, 6]), ('cx', [5, 4]), ('cx', [4, 5]), ('cx', [5, 3]), ('cx', [3, 5]), ('cx', [3, 1]), ('cx', [1, 3]), ('cx', [1, 2]), ('cx', [2, 1]), ('cx', [1, 0]), ('cx', [0, 1]), ('reset', [0]), ('reset', [1]), ('reset', [2]), ('reset', [3]), ('reset', [4]), ('reset', [5]), ('reset', [6]), ('measure', [0]), ('measure', [1]), ('measure', [2]), ('measure', [3]), ('measure', [4]), ('measure', [5]), ('measure', [6])] So I could see the source of errors as well as qubit connections. However, I wonder as I give this information to qasm simulator and run the experiments, am I using the real-time error rate as the noise model? result = execute(circ, Aer.get_backend('qasm_simulator'), coupling_map=coupling_map, basis_gates=basis_gates, noise_model=noise_model).result() If so, should we expect to see any difference between the qasm results and the results from real quantum devices? (I could not print out the noise information, so I'm a bit confused which error values we are using.) Thanks!",<qiskit><programming><ibm-q-experience><qasm>,10/19/2021 2:08,,,,
21592.0,Questions about OpenFermion,"I have some questions about OpenFermion. I'm exploring the code, does anybody knows how to implement triatomic molecules like Li-H2? How should I set the number of orbitals? Last but not least, once the molecular problem is mapped to the spinless Fermi Hubbard, how OpenFermion sets the number of sites and the number of particles (I suppose it depends on the number of orbitals..)? Thank you so much! Piero",<programming><openfermion>,10/19/2021 8:45,,,,
21596.0,Adding trainable weights to feature inputs for a CircuitQNN?,"Currently I'm trying to get together a QNN that can be trained to classify the normalized (-1, 1) IRIS Dataset on all 3 classes. For this I am using Qiskit's NeuralNetworkClassifier, and have a specific question regarding the circuit setup. My current idea for the circuit is that the weights influence the features, which in turn rotate the qubit a certain direction. With the CircuitQNN class, I have to use a feature map as well as an ansatz. Now, this is per se OK, but it doesn't allow me to specifically multiply the weights with the features themselfs - I can only do so by applying the weights in the ansatz. Is there a possibility for this or am I missing something? Code that currently works and is trainable (albeit results in an accuracy of ~0.5) would be as follows: feature_map = QuantumCircuit(1) ansatz = QuantumCircuit(1) for i in range(len(normalized_features[1])): feature_map.ry(Parameter('i_' + str(i)),0) ansatz.ry(Parameter('w_' + str(i)),0) qc = QuantumCircuit(1) qc.append(feature_map, range(1)) qc.append(ansatz, range(1)) display(qc.draw('mpl')) circuit_qnn = CircuitQNN(circuit=qc, input_params=feature_map.parameters, weight_params=ansatz.parameters, interpret=parity, output_shape=output_shape, quantum_instance=quantum_instance) Yes, I know this is only limited to one qubit, and I am currently only trying to figure out the different ways to construct the circuit. After figuring out the weight problem, I'd measure multiple vs single qubit circuits using it and compare the results.",<qiskit><programming><quantum-neural-network>,10/19/2021 18:59,,,,
21610.0,How does one get the right counts for the measurement of a single qubit in the presence of noise with qiskit?,"I am using a single qubit in the IBM quantum lab running on ibm_armonk and it is simulated with real noise, however when I try to measure out a state where the coefficient of the 0 state is less than 0.1 I get the wrong counts. I always get the result that there were roughly 1/10 of the counts in the 0 state and 9/10 in the 1 state (for example, if I try to initialize the state so that the probability of 0 is 0.01). I used 8192 shots but when I try to repeat the experiment I get the same results. This doesn't make sense to me because I would expect the effect of noise to lead to a more Gaussian type of distribution around the average, so after enough measurements the counts should lead to the average value. My code involves the following: initial_state = [0.1,math.sqrt(0.9)] # my code is a little different here, but this # should give an idea of the numbers I am # using circuit.initialize(initial_state,0) circuit.measure(0,0) job = execute(circuit,device,shots=8192) result = job.result() result = result.get_counts(circuit) print(counts)",<qiskit><programming>,10/20/2021 9:58,,,,
21625.0,How to add label to custom operator (from matrix) controlled gate?,"So here is what I'm trying to accomplish: I have made a gate out of a matrix, with a control: cG_p = Operator([[np.sqrt(p[j]), -np.sqrt(1-p[j])], [np.sqrt(1-p[j]), np.sqrt(p[j])]]).to_instruction().control(1) I then append it to a circuit in a loop: circ.append(cG_p, [j, j+1]) When I draw the circuit it by default labels the gate &quot;Unitary&quot;. I want to put a custom label on the gate instead I could put the custom label on when it wasn't a control (just a gate). That worked fine. Now that I've added the necessary control I can find no way to change the label.",<qiskit><programming>,10/21/2021 17:07,,,,
21667.0,Difference between Aer.get_backend('aer_simulator') and AerSimulator(),"In Qiskit, there are several ways to choose simulator: one is from qiskit import Aer backend = Aer.get_backend('aer_simulator') result = backend.run(circ).result() another one is from qiskit.providers.aer import AerSimulator backend = AerSimulator() result=backend.run(circ).result() ,where circ is QuantumCircuit(n). Do they always return the same result?",<qiskit><programming><simulation><ibm-quantum-devices>,10/25/2021 11:43,,,,
21707.0,How can I get the results from simulating noise models?,"I'm trying to run some simulations of my quantum circuits using qasm simulator. I first tried to import the noise data from a quantum device and then use that information on qasm. Here's part of my code: provider = IBMQ.load_account() backend = provider.get_backend('ibmq_casablanca') noise_model = NoiseModel.from_backend(backend) coupling_map = backend.configuration().coupling_map basis_gates = noise_model.basis_gates result = execute(circ, Aer.get_backend('qasm_simulator'), coupling_map = coupling_map, basis_gates = basis_gates, noise_model = noise_model).result() When I return type(result), it seems like the code is working, but I could not get any counts from here. It returns me QiskitError: 'No counts for experiment &quot;0&quot;' as I attempted counts = result.get_counts(0). I wonder am I really running the simulation? How can I get the counts? Thanks for the help!",<programming><ibm-q-experience><simulation><qasm>,10/28/2021 1:46,,,,
21717.0,QASM Files on Jupyter Notebook,Is it possible to run qasm files on jupyter notebook (like with the qasm_simulator)? I downloaded one code file and I would like to play around with it on jupyter notebook.,<programming><qasm>,10/28/2021 14:23,,,,
21731.0,Correct implementation of Qiskit QAOA,"I've been dealing with a QAOA implementation of a QUBO problem. In order to do this, I converted my QUBO matrix to a QuadraticModel. Once done, I have used Hamiltonian, offset = mdl.to_ising() to generate a Hamiltonian and offset, with mdl being my QuadraticProgram. Once done, I went on to verify theoretically that the ground state energy of this Hamiltonian tallies with results an annealer. In order to do this, I used: min_val = NumPyMinimumEigensolver(Hamiltonian) Sure enough, this matches. The ground state energy when added with the offset value brings the value to 0. Now when I am trying to implement a QAOA, I use the following lines of code. I am aware that I am using deprecated code but I'm not sure this contributes to the problem. aqua_globals.random_seed = np.random.default_rng(123) seed = 10598 backend = Aer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed) qaoa = QAOA(quantum_instance=quantum_instance, p = 1) qaoa_optimizer = MinimumEigenOptimizer(qaoa) result = qaoa_optimizer.solve(mdl) This gives me optimal function value: 2.0 which isn't the result I am looking for. I think I'm going wrong somewhere in the implementation of the QAOA, but I'm not sure where. Any help in this regard would be absolutely stellar!",<qiskit><programming><qaoa><qubo>,10/29/2021 15:57,,,,
21747.0,Problems when computing the two-electron reduced density matrix (2-RDM) by qiskit,"The definition of a 2-RDM is $D_{ijkl}=\langle\psi|a_i^{\dagger}a_j^{\dagger}a_k a_l|\psi\rangle,i,,j,k,l\in[0,N-1]$, where $N$ is the number of qubits/ orbitals in the quantum system.I am trying to use the following code to get the 2-RDM for a given state and the eigenvalue for the 2-RDM, from qiskit import * import numpy as np #Operator Imports from qiskit.opflow import Z, X, I #Circuit imports from qiskit_nature.circuit.library import HartreeFock from qiskit import Aer from qiskit_nature.mappers.second_quantization import JordanWignerMapper from qiskit_nature.converters.second_quantization import QubitConverter from qiskit.algorithms import VQE, NumPyMinimumEigensolver import matplotlib.pyplot as plt import matplotlib from qiskit.tools.visualization import circuit_drawer from qiskit_nature.operators.second_quantization import FermionicOp from qiskit.opflow import Z, X, I, StateFn, CircuitStateFn, SummedOp from qiskit.opflow.converters import CircuitSampler from qiskit.utils import QuantumInstance from qiskit.opflow import expectations import itertools matplotlib.use('Agg') mapper = JordanWignerMapper() converter = QubitConverter(mapper=mapper, two_qubit_reduction=False) num_particles = (2, 2) num_spin_orbitals = 6 init_state = HartreeFock(num_spin_orbitals, num_particles, converter) init_state1 = QuantumCircuit(num_spin_orbitals) init_state1.h(0) init_state1.h(1) print(init_state1) def get_rdm(init_state): two_rdm = np.zeros((num_spin_orbitals,) * 4) for i, j, k, l in itertools.product(range(num_spin_orbitals), repeat=4): # if i != j and k != l: s = &quot;+_{i} +_{j} -_{k} -_{l}&quot;.format(i=str(i),j=str(j),k=str(k),l=str(l)) fermi_term = FermionicOp(s, register_length=num_spin_orbitals) qubit_term = converter.convert(fermi_term, num_particles=num_particles) # Evaluate the Hamiltonian term w.r.t. the given state # temp = (~init_state @ qubit_term @ init_state).eval() temp = ~StateFn(qubit_term) @ CircuitStateFn(primitive=init_state, coeff=1.) temp = int(temp.eval()) two_rdm[i,j,k,l] = temp return two_rdm # rdm1 = rdm(init_state) # print('--------------') two_rdm = get_rdm(init_state1) # Transpose of the 2-RDM two_rdm = np.transpose(two_rdm, (0, 1, 3, 2)) two_rdm = two_rdm.reshape((num_spin_orbitals ** 2, num_spin_orbitals ** 2)) # SVD of the 2-RDM a, b = np.linalg.eig(two_rdm) print(a) u, s, vh = np.linalg.svd(two_rdm, full_matrices=True) print(s) print(s.sum()) For the Hartree Fock state, the eigenvalues of the corresponding 2-RDM output six non-zero elements, which all are $2$. In my opinion, the eigenvalues of the 2-RDM stand for the meaning that probability of two electron residing in the corresponding two orbitals. Therefore, the eigenvalue should be from zero to one.",<qiskit><programming>,11/01/2021 03:58,,,,
21829.0,Is it possible to construct a QuantumCircuit object which only shows the 5 qubits and the classical bit where I store the measurement outcome?,"I have a 5-qubit circuit on Qiskit, which applies some unitary. Then I have a second circuit which basically measures whether all the qubits are 1, and it does so through a 5-CNOT on an ancilla qubit, and then measuring the ancilla. I would like to use this circuit without having to care about the ancilla subspace everytime. Is it possible to construct a QuantumCircuit object which only shows the 5 qubits and the classical bit where I store the measurement outcome?",<qiskit><programming>,11/07/2021 13:01,,,,
21852.0,Ground state compute issue by qiskit,"I use the following code to calculate the ground state for the LiH molecule in an active space. I come across two problems. The first is I found that the Hartree Fock state gave energy that is far from the ground state energy. But the qc state is the true Hartree Fock state. The second problem is using the ground_state, it just outputs 0. Can anybody help me with that? from qiskit import * import numpy as np #Circuit imports from qiskit_nature.drivers import UnitsType from qiskit_nature.drivers.second_quantization import PySCFDriver from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem from qiskit_nature.circuit.library import HartreeFock from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer, ActiveSpaceTransformer from qiskit_nature.algorithms import GroundStateEigensolver from qiskit_nature.results import EigenstateResult from qiskit import Aer from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper from qiskit_nature.converters.second_quantization import QubitConverter from qiskit.algorithms import VQE, NumPyMinimumEigensolver from qiskit.opflow.state_fns import StateFn, CircuitStateFn import matplotlib from qiskit.tools.visualization import circuit_drawer from qiskit.quantum_info import state_fidelity, Statevector matplotlib.use('Agg') np.set_printoptions(threshold=np.inf) driver = PySCFDriver(atom='H .0, .0, .0; Li .0, .0, 0.5', unit=UnitsType.ANGSTROM, basis='sto3g') # set parameters molecule = &quot;LiH&quot; set_as = True # set the active space or not as_particle = 2 # number of particles in the active space as_mol_orbital = 3 # number of molecular orbitals in the active space at = ActiveSpaceTransformer(as_particle, as_mol_orbital, active_orbitals=[1,2,5]) ft = FreezeCoreTransformer() as_problem = ElectronicStructureProblem(driver, transformers=[at]) # generate the second-quantized operators for active space as_second_q_ops = as_problem.second_q_ops() as_main_op = as_second_q_ops[0] as_particle_number = as_problem.grouped_property_transformed.get_property(&quot;ParticleNumber&quot;) as_num_particles = (as_particle_number.num_alpha, as_particle_number.num_beta) as_num_spin_orbitals = as_particle_number.num_spin_orbitals as_qubit_op = converter.convert(main_op, num_particles=num_particles) as_init_state = HartreeFock(as_num_spin_orbitals, as_num_particles, converter) qc = QuantumCircuit(as_num_spin_orbitals) qc.x(1) qc.x(3) # calculate the energy numpy_solver = NumPyMinimumEigensolver() calc = GroundStateEigensolver(converter, numpy_solver) calc.returns_groundstate() as_res_ref = calc.solve(as_problem) ground_state = as_res_ref.eigenstates[0] print('G.S. energy is', as_res_ref.eigenenergies.min()) gse = (~ground_state @ as_qubit_op @ ground_state).eval() print('Second G.S. energy is',gse) e = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=as_init_state, coeff=1.) e = e.eval() print('HF state energy is',e) e2 = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=qc, coeff=1.) e2 = e2.eval() print('qc state energy is',e2) ```",<qiskit><programming><vqe>,11/09/2021 04:44,,,,
21863.0,How to multiply two vectors (kets) in qiskit?,Hi does anyone know how i could write a program to get the product of something like |1&gt;|0&gt;|0&gt;?,<qiskit><programming><quantum-state><ibm-q-experience><circuit-construction>,11/10/2021 01:25,,,,
21896.0,Getting the density matrix of a noisy state in Qiskit,"Currently, it seems that qiskit can only compute the density matrix for a pure state. On the other hand, for noisy state, the known way to deal with it is to do sampling, which can induce great cost. So, I want to know is there a way to get a density matrix for a given circuit with specific nosiy model in qiskit?",<qiskit><programming>,11/12/2021 08:52,,,,
21899.0,Plots of the result for the qiskit HHL tutorial,Could anyone make explicit the code which gives the two plots at the end of the HHL tutorial. They show the results of the jobs on a real IBM quantum device.,<qiskit><programming><hhl-algorithm>,11/12/2021 09:26,,,,
21926.0,QUBO defined in Qiskit/DOcplex: how to solve it using Pennylane?,"I have a complex Integer Linear Programming model defined in DOcplex/Qiskit representing a combinatorial optimization problem. Using the Qiskit utils, it is possible to covert it to either an Ising model or Pauli operators. For a particular reason, I need to use Pennylaneâs QAOA to solve the problem. Is there any easy way to convert the Qiskitâs Ising model/Pauli operators output to something that Pennylane âunderstandsâ? I can neither find something in the Pennylane documentation mor can I a find sth. like DOcplex or any other QUBO-related tools in the Pennylane ecosystem.",<qiskit><programming><qaoa><pennylane>,11/14/2021 20:13,,,,
21966.0,Tweak the parameter `p` of QAOA in qiskit,"I am solving a QUBO using QAOA. It works flawlessly with default parameters for smaller instances of the problem, but my RAM is saturated when I try to solve a problem of size 15. I suspect this can be resolved by changing the parameter p. Don't mind if it generates a wrong result as output, at least don't wanna run out of resources and end abruptly. I even checked with different simulators, but it didn't work. Mainly, want to know how to play around with the number of layers p. Here's the code for reference: from qiskit import Aer from qiskit.aqua import aqua_globals, QuantumInstance from qiskit.aqua.algorithms import QAOA from qiskit.optimization import QuadraticProgram qp=QuadraticProgram() qp.from_ising(op, offset, linear=True) aqua_globals.random_seed = 123 quantum_instance = QuantumInstance(Aer.get_backend('aer_simulator'), seed_simulator=aqua_globals.random_seed, seed_transpiler=aqua_globals.random_seed) qaoa_mes = QAOA(quantum_instance=quantum_instance, initial_point=[0., 0.]) qaoa = MinimumEigenOptimizer(qaoa_mes) result = qaoa.solve(qubo) Also, how to get the circuit?",<qiskit><programming><ibm-q-experience><quantum-circuit><qaoa>,11/17/2021 12:53,,,,
22014.0,"VQE from scratch, what have I got wrong?","I've been working on a code to run VQE with a grouped measurement. For some reason, my expectation values are slightly off from those computed by pennylane, the software I decided to use for this little project. I've been staring at my expectation value function exp_val, and I can't tell why it's wrong. This is the code: import pennylane as qml from pennylane import qchem import numpy as np symbols = [&quot;H&quot;, &quot;H&quot;] coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614]) h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates) n_shots = 1000 dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots) @qml.qnode(dev_noisy) def VQE_circuit(params, group = None, n_qubits = None): qml.StronglyEntanglingLayers(params, wires = range(n_qubits)) rotations = qml.grouping.diagonalize_qwc_pauli_words(group)[0] return qml.probs(wires=range(n_qubits)) import autograd.numpy as agnp drawer = qml.draw(VQE_circuit) def exp_val(results, coeffs, groupings): E = 0 for i, result in enumerate(results): #Process each list of counts (probs) ops = groupings[i] coeff_list = coeffs[i] #print(drawer(params, group = groupings[i], n_qubits = n_qubits)) for op_idx, op in enumerate(ops): ##calculate expval for each operator in group if op.name == 'Identity': E += coeff_list[op_idx] else: exp_val = 0 for c_idx, count in enumerate(result): #process bitstring in result idxs = op.wires.toarray() bits = format(c_idx, &quot;b&quot;).zfill(n_qubits) sub_bits = [bits[i] for i in idxs] par = sub_bits.count('1')%2 sign = (-1)**par exp_val += sign*count exp_val *= coeff_list[op_idx] E += exp_val return E print(&quot;\n&quot;, h2_ham, &quot;\n&quot;) groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf') param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=3, n_wires=n_qubits) params = np.random.normal(scale=0.1, size=param_shape) results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings] print(exp_val(results, coeffs, groupings)) ##VQE execution: def naive_cost(params): results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings] return exp_val(results, coeffs, groupings) sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray() gs_E = np.linalg.eigvalsh(sparse)[0] print(&quot;GSE: &quot;, gs_E) import scipy.optimize as opt param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits) params = np.random.normal(scale=0.1, size=param_shape) opt = qml.AdagradOptimizer(0.05) max_iteration = 100 conv_tol = 1e-6 energy = [naive_cost(params)] for n in range(max_iteration): params, prev_E = opt.step_and_cost(naive_cost, params) energy.append(naive_cost(params)) conv = np.abs(energy[-1]-prev_E) if n % 2 == 0: print(f&quot;Step = {n}, Energy = {energy[-1]:.8f} Ha&quot;) if conv &lt;= conv_tol: break #print(energy) print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy)) print(&quot;FINAL params: &quot;, params) print(&quot;REAL GROUND STATE E: &quot;, gs_E) Am I doing something obviously wrong? I've checked to ensure the endianness of the bits is correct, I made sure to calculate parities based on the active qubit indices for the desired observable, I made sure not to include a parity calculation when computing expected value of identity operators. I've triple checked that the coefficients are being applied to the correct operators, that the circuits are appended with the correct measurement circuits for the given operator in the group. Amongst these checks, I can't seem to find the flaw in my programming logic. Having an extra pair of eyes on this would be extremely helpful. All the best, cuhrazatee PS: Here's the code using Pennylane's built in exp_val. from openfermion.ops.operators.qubit_operator import QubitOperator import pennylane as qml from pennylane import qchem import numpy as np from functools import partial from pennylane.measure import state from pennylane.ops.qubit import observables from pennylane.templates import UCCSD import matplotlib.pyplot as plt symbols = [&quot;H&quot;, &quot;H&quot;] coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614]) h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates) n_electrons = 2 singles, doubles = qchem.excitations(n_electrons, n_qubits) s_wires, d_wires = qchem.excitations_to_wires(singles, doubles) ref_state = qchem.hf_state(n_electrons, n_qubits) ansatz = partial(UCCSD, init_state = ref_state, s_wires = s_wires, d_wires = d_wires) groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf') n_shots = 10000 dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots) sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray() gs_E = np.linalg.eigvalsh(sparse)[0] print(&quot;GSE: &quot;, gs_E) param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits) params = np.random.normal(scale=0.1, size=param_shape) optimal_params = [[[0.15300575748799206, 0.0802866250748122, 0.6612327808749161], [-0.012197292985330403, 1.0054708209216188, -0.5031298708940922], [0.4871116388974964, 0.8755791036972337, 0.15300349217856668], [0.2125674641016197, -0.3988028820299284, -0.5903810690276766]], [[-0.26227065702483116, 0.7762008921102848, 0.20421958031876591], [-0.11210374173720475, -0.7158851608015426, -0.945090563307313], [-0.20041447281024863, -0.43875447105339715, -0.10552844761324888], [0.017868138476782234, -0.4067704016345291, 0.19911933547123295]], [[-0.1170885274951583, -0.40203947157121894, -0.44851762637470327], [-0.2715291337140317, 0.6888494094283752, 0.5389027752311034], [-0.5191082830999312, 0.4426962606005164, -0.25932474764548114], [0.8138172470220708, -0.54678942509227, 0.4102491578027457]], [[0.7676993827422776, -0.47721469081406376, 0.6337393057184456], [-0.6553402727229024, 0.8955375499127577, 0.5789282160827474], [0.6570560582613835, -0.8518341967262695, -0.6023881439081624], [0.040387149769954125, 0.3040045252649316, -0.38193967606295326]], [[0.42336490227621815, -0.3869902716443922, 0.27822533007353994], [1.2170710775127433, 0.6959673154584948, -0.11538272838636159], [0.33436903989516936, -0.7268804688737179, 0.49919014014531526], [0.818911996077618, -0.6280017753881122, 0.553169606547251]]] cost = qml.ExpvalCost(qml.StronglyEntanglingLayers, h2_ham, dev_noisy, optimize=True) opt = qml.AdagradOptimizer(0.06) max_iteration = 100 conv_tol = 1e-6 energy = [cost(params)] for n in range(max_iteration): params, prev_E = opt.step_and_cost(cost, params) energy.append(cost(params)) conv = np.abs(energy[-1]-prev_E) if n % 2 == 0: print(f&quot;Step = {n}, Energy = {energy[-1]:.8f} Ha&quot;) if conv &lt;= conv_tol: break #print(energy) print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy)) print(&quot;REAL GROUND STATE E: &quot;, gs_E) ```",<programming><vqe><pennylane>,11/21/2021 22:23,,,,
22029.0,Is there any software package tracking Pauli errors in stabilizing circuits with GUI?,I want to track the Pauli errors propagating in stabilizer circuits like surface code. I wonder whether there is any developed package that can do this elegantly. It will be better if it has GUI that I can throw Pauli errors in conveniently.,<programming><error-correction>,11/23/2021 9:25,,,,
22047.0,"What is the difference between Qiskit Terra, Aer, Ignis and Aqua?","I am going through the Qiskit tutorials and they have an article on each of the above 4. however, As a beginner, I am not very clear. Could anyone share some insights on these?",<qiskit><programming>,11/24/2021 19:58,,,,
22091.0,queueinfo() module in Qiskit,"I want to know how to use queueinfo() module in IBM Qiskit. When I type job.QueueInfo(), it says &quot;QueueInfo&quot; is not defined. How to import it? I'm trying to use queueinfo() to know the time of start of execution of quantum circuit. Please help.",<qiskit><programming><ibm-q-experience>,11/26/2021 13:27,,,,
22137.0,Computing specific observable for a Clifford circuit,"Given a clifford circuit, how can I simulate it efficiently to get the 2-RDM (reduced density matrix) $D^2=\langle a_i^\dagger a_j^\dagger a_k a_l\rangle$ in the presence of deplorizing error? The simulation will take a lot of time, which seems conter-intuitive for simulation of clifford circuit. It seems that the cost is mainly caused by CircuitSampler. Is there a way to avoid the using of it while can get the noisy expectation result for the 2-RDM or other weighted pauli string-like observables, such as a Hamiltonian, in the Clifford case? from qiskit import * import numpy as np import itertools #Circuit imports import matplotlib # import cirq import qiskit.quantum_info as qi from qiskit.quantum_info import random_clifford matplotlib.use('Agg') from qiskit_nature.operators.second_quantization import FermionicOp from qiskit.opflow.converters import CircuitSampler from qiskit_nature.mappers.second_quantization import JordanWignerMapper from qiskit_nature.converters.second_quantization import QubitConverter from qiskit.utils import QuantumInstance from qiskit.opflow import Z, X, I, StateFn, CircuitStateFn from qiskit.opflow.expectations import PauliExpectation import qiskit.providers.aer.noise as noise from qiskit.providers.aer import AerSimulator np.set_printoptions(threshold=np.inf) prob_1 = 1e-3 # 1-qubit gate prob_2 = 1e-2 # 2-qubit gate # Depolarizing quantum errors error_1 = noise.depolarizing_error(prob_1, 1) error_2 = noise.depolarizing_error(prob_2, 2) # Add errors to noise model noise_model = noise.NoiseModel() noise_model.add_all_qubit_quantum_error(error_1, ['s', 'sdg', 'x', 'y', 'z', 'i', 'h']) noise_model.add_all_qubit_quantum_error(error_2, ['cx', 'cz', 'swap']) num_qubits = 10 two_rdm = np.zeros((num_qubits,) * 4) mapper = JordanWignerMapper() converter = QubitConverter(mapper=mapper, two_qubit_reduction=False) backend = AerSimulator(method='stabilizer', noise_model=noise_model) quantum_instance = QuantumInstance(backend=backend, shots=1000, noise_model=noise_model) circuit_sampler = CircuitSampler(quantum_instance) cliff = random_clifford(num_qubits) cliff = cliff.to_circuit() for i, j, k, l in itertools.product(range(num_qubits), repeat=4): s = &quot;+_{i} +_{j} -_{k} -_{l}&quot;.format(i=str(i),j=str(j),k=str(k),l=str(l)) fermi_term = FermionicOp(s, register_length=num_qubits) qubit_term = converter.convert(fermi_term, num_particles=(1,1)) # Evaluate the 2-RDM term w.r.t. the given circuit temp = ~StateFn(qubit_term) @ CircuitStateFn(primitive=cliff, coeff=1.) temp = circuit_sampler.convert( PauliExpectation().convert(temp) ).eval() two_rdm[i,j,k,l] = temp",<qiskit><programming><clifford-group>,11/30/2021 13:07,,,,
22148.0,How could I choose cost function in Qiskit TwoLayerQNN?,"So here is the problem, I've found that in a TwoLayerQNN, the backward gradient is only to minimize the expectation of observable I've chosen. But I'm not going to minimize the predict of the input, instead, I need to minimize the cost function. So how can I choose my own cost function without using NeuralNetworkClassifier? thanks.",<qiskit><programming><machine-learning><neural-network>,12/01/2021 14:03,,,,
22169.0,Applying QPE on a large matrix on amazon-braket,"I'm running a QPE algorithm on the amazon-braket but it can only apply on a 22 or 44 matrix, when I want to expand it into a 5*5 or more, it will come an error. As I know, there is no theoretical limitation on the size of matrix QPE can solve. Here is the main part of the code: def get_qpe_phases(measurement_counts, precision_qubits, items_to_keep=1): bitstrings_precision_register = [ substring(key, precision_qubits) for key in measurement_counts.keys() ] bitstrings_precision_register_set = set(bitstrings_precision_register) bitstrings_precision_register_list = list(bitstrings_precision_register_set) precision_results_dic = {key: 0 for key in bitstrings_precision_register_list} for key in measurement_counts.keys(): counts = measurement_counts[key] count_key = substring(key, precision_qubits) precision_results_dic[count_key] += counts c = Counter(precision_results_dic) topmost = c.most_common(items_to_keep) phases_decimal = [binaryToDecimal(item[0]) for item in topmost] return phases_decimal, precision_results_dic def run_qpe( unitary, precision_qubits, query_qubits, query_circuit, items_to_keep=1, shots=1000 ): circ = query_circuit circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False) # Add desired results_types number_precision_qubits = len(precision_qubits) num_qubits = len(precision_qubits) circ.probability(np.array(precision_qubits)) device = LocalSimulator() task=device.run(circ,shots=shots) result=task.result() metadata = result.task_metadata probs_values = result.values[0] measurements = result.measurements measured_qubits = result.measured_qubits measurement_counts = result.measurement_counts measurement_probabilities = result.measurement_probabilities format_bitstring = &quot;{0:0&quot; + str(num_qubits) + &quot;b}&quot; bitstring_keys = [format_bitstring.format(ii) for ii in range(2 ** num_qubits)] phases_decimal, precision_results_dic = get_qpe_phases( measurement_counts, precision_qubits, items_to_keep ) print('\nPhases:',phases_decimal) eigenvalues = [np.exp(2 * np.pi * 1j * phase) for phase in phases_decimal] # aggregate results out = { &quot;circuit&quot;: circ, &quot;task_metadata&quot;: metadata, &quot;measurements&quot;: measurements, &quot;measured_qubits&quot;: measured_qubits, &quot;measurement_counts&quot;: measurement_counts, &quot;measurement_probabilities&quot;: measurement_probabilities, &quot;probs_values&quot;: probs_values, &quot;bitstring_keys&quot;: bitstring_keys, &quot;precision_results_dic&quot;: precision_results_dic, &quot;phases_decimal&quot;: phases_decimal, &quot;eigenvalues&quot;: eigenvalues, } return out And when it comes to a 6*6 matrix, from scipy.stats import unitary_group import numpy as np np.random.seed(seed=3000) unitary1 = unitary_group.rvs(6) result = estimate_phase(4,unitary1,5,printcir=False) the error report is like: --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-21-4eae0beac402&gt; in &lt;module&gt; 4 5 unitary = unitary_group.rvs(6) ----&gt; 6 result = estimate_phase(4,unitary,5,printcir=False) &lt;ipython-input-9-30dffae9e6c6&gt; in estimate_phase(n, unitary, runit, shots, printcir) 15 query = Circuit().h(query_qubits) 16 ---&gt; 17 result = run_qpe(unitary, precision_qubits, query_qubits, query, items_to_keep=elen, shots = shots) 18 qeigvals= postprocess_qpe_results(result,printcir) 19 &lt;ipython-input-6-1875e0e5a610&gt; in run_qpe(unitary, precision_qubits, query_qubits, query_circuit, items_to_keep, shots) 92 ): 93 circ = query_circuit ---&gt; 94 circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False) 95 96 # Add desired results_types ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) &lt;ipython-input-6-1875e0e5a610&gt; in qpe(precision_qubits, query_qubits, unitary, control_unitary) 39 else: 40 for _ in range(2 ** power): ---&gt; 41 qpe_circ.controlled_unitary(qubit, query_qubits, unitary) 42 qpe_circ.inverse_qft(precision_qubits) 43 ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) &lt;ipython-input-6-1875e0e5a610&gt; in controlled_unitary(control, target_qubits, unitary) 21 targets = [control] + target_qubits 22 ---&gt; 23 circ.unitary(matrix=controlled_matrix, targets=targets) 24 25 return circ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs) 75 76 def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn: ---&gt; 77 return self.add(func, *args, **kwargs) 78 79 function_name = func.__name__ ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs) 495 self.add_circuit(item, *args, **kwargs) 496 elif callable(item): --&gt; 497 self.add(item(*args, **kwargs)) 498 else: 499 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;) ~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/gates.py in unitary(targets, matrix, display_name) 1339 &quot;&quot;&quot; 1340 if 2 ** len(targets) != matrix.shape[0]: -&gt; 1341 raise ValueError(&quot;Dimensions of the supplied unitary are incompatible with the targets&quot;) 1342 1343 return Instruction(Gate.Unitary(matrix, display_name), target=targets) ValueError: Dimensions of the supplied unitary are incompatible with the targets So I'm wondering if it's the packages' problem or the program problem or any other had met the similar problem as I? Thanks in advance!",<programming><hamiltonian-simulation><quantum-phase-estimation><amazon-braket>,12/03/2021 06:37,,,,
22187.0,QuTiP VS RK45: Which one gives the correct results for time-dependent systems?,"I am writing a code for a quantum thermal machine which includes both coherent and dissipative time evolutions in its different stages of operation. However, evolving the system with &quot;mesolve&quot; function of QuTiP (which uses either Adams or BDF methods) and Runge-Kutta gives different results. My code has time dependent Hamiltonians and collapse operators. For demonstration purposes I wrote a simple code which deals with the master equation of a time-dependent harmonic oscillator of mass and frequency equal to 1. The jump operator is the position operator times a time-dependent coefficient. import numpy as np import scipy as sp from qutip import * tend = 5 tvec = np.linspace(0,tend,1000) Ï1 = 1 #initial frequency Ï2 = 2 #final frequency gamma = 1 #dissipation rate def omg_fun(t, args): #time-dependent frequency s = t/tend Ï_t = Ï1 + 10*(Ï2-Ï1)*s**3 - 15*(Ï2-Ï1)*s**4 + 6*(Ï2-Ï1)*s**5 return Ï_t def col_fun(t, args): #time dependent collapse operator coefficient return np.sqrt(gamma * np.exp(-t)) def omg_fun_rk(t): #time-dependent frequency for RK45 s = t/tend Ï_t = Ï1 + 10*(Ï2-Ï1)*s**3 - 15*(Ï2-Ï1)*s**4 + 6*(Ï2-Ï1)*s**5 return Ï_t def col_fun_rk(t): #time dependent collapse operator coefficient for RK45 return np.sqrt(gamma * np.exp(-t)) N=10 m = 1 #mass Ä§ = 1 x = np.sqrt(Ä§/(2*m*Ï1))*(create(N)+destroy(N)) #position operator p = 1j*np.sqrt((Ä§*m*Ï1)/2)*(create(N)-destroy(N)) #momentum operator H = [(p**2)/(2*m), [(1/2)*m*x**2,omg_fun]] c_ops = [[x,col_fun]] rho_init = fock_dm(N,1) rhot_vec = mesolve(H,rho_init,tvec,c_ops) rhot_qutip = rhot_vec.states[-1] #Right hand side of the master equation def rhs(Ï,H,gamma,op): c_op = np.sqrt(gamma)*op res = -1j*(H*Ï - Ï*H)+(1/2)*(2*c_op*Ï*c_op.dag()-Ï*c_op.dag()*c_op-c_op*c_op.dag()*Ï) return res #Runge-Kutta Solver def rksolver(Ï,dt,H,gamma,op): k1 = rhs(Ï,H,gamma,op) k2 = rhs(Ï+(dt/2)*k1,H,gamma,op) k3 = rhs(Ï+(dt/2)*k2,H,gamma,op) k4 = rhs(Ï+dt*k3,H,gamma,op) rho = Ï+dt*(k1+2*k2+2*k3+k4)/6 return rho dt = tvec[1]-tvec[0] for i in range(len(tvec)): H_rk = (p**2)/(2*m) + (1/2)*m*x**2*omg_fun_rk(tvec[i]) gamma_rk = col_fun_rk(tvec[i]) rhot_rk = rksolver(rho_init,dt,H_rk,gamma_rk,x) rho_init = rhot_rk The final density matrix using mesolve is: \begin{equation*}\left(\begin{array}{*{11}c}0.212 &amp; 0.0 &amp; (0.004-0.052j) &amp; 0.0 &amp; (0.006+0.022j) &amp; 0.0 &amp; (-0.005-0.005j) &amp; 0.0 &amp; (0.002+9.285\times10^{-04}j) &amp; 0.0\\0.0 &amp; 0.384 &amp; 0.0 &amp; (-0.070+0.018j) &amp; 0.0 &amp; (0.009-0.004j) &amp; 0.0 &amp; (0.002+0.001j) &amp; 0.0 &amp; (-0.005-0.002j)\\(0.004+0.052j) &amp; 0.0 &amp; 0.195 &amp; 0.0 &amp; (-0.054+0.023j) &amp; 0.0 &amp; (0.011-0.010j) &amp; 0.0 &amp; (-0.001+0.003j) &amp; 0.0\\0.0 &amp; (-0.070-0.018j) &amp; 0.0 &amp; 0.082 &amp; 0.0 &amp; (-0.039+0.011j) &amp; 0.0 &amp; (0.015-0.008j) &amp; 0.0 &amp; (-0.012+0.011j)\\(0.006-0.022j) &amp; 0.0 &amp; (-0.054-0.023j) &amp; 0.0 &amp; 0.049 &amp; 0.0 &amp; (-0.019+0.009j) &amp; 0.0 &amp; (0.007-0.005j) &amp; 0.0\\0.0 &amp; (0.009+0.004j) &amp; 0.0 &amp; (-0.039-0.011j) &amp; 0.0 &amp; 0.039 &amp; 0.0 &amp; (-0.013-0.002j) &amp; 0.0 &amp; (0.008-0.004j)\\(-0.005+0.005j) &amp; 0.0 &amp; (0.011+0.010j) &amp; 0.0 &amp; (-0.019-0.009j) &amp; 0.0 &amp; 0.019 &amp; 0.0 &amp; (-0.006-0.002j) &amp; 0.0\\0.0 &amp; (0.002-0.001j) &amp; 0.0 &amp; (0.015+0.008j) &amp; 0.0 &amp; (-0.013+0.002j) &amp; 0.0 &amp; 0.008 &amp; 0.0 &amp; (-0.004+5.540\times10^{-04}j)\\(0.002-9.285\times10^{-04}j) &amp; 0.0 &amp; (-0.001-0.003j) &amp; 0.0 &amp; (0.007+0.005j) &amp; 0.0 &amp; (-0.006+0.002j) &amp; 0.0 &amp; 0.005 &amp; 0.0\\0.0 &amp; (-0.005+0.002j) &amp; 0.0 &amp; (-0.012-0.011j) &amp; 0.0 &amp; (0.008+0.004j) &amp; 0.0 &amp; (-0.004-5.540\times10^{-04}j) &amp; 0.0 &amp; 0.007\\\end{array}\right)\end{equation*} The final density matrix using RK45 is: \begin{equation*}\left(\begin{array}{*{11}c}0.243 &amp; 0.0 &amp; (-0.010-0.017j) &amp; 0.0 &amp; (0.003+0.006j) &amp; 0.0 &amp; (-0.001-0.001j) &amp; 0.0 &amp; (3.398\times10^{-04}+5.923\times10^{-05}j) &amp; 0.0\\0.0 &amp; 0.271 &amp; 0.0 &amp; (-0.038+0.003j) &amp; 0.0 &amp; (0.004+0.002j) &amp; 0.0 &amp; (0.002-0.002j) &amp; 0.0 &amp; (-0.004+0.003j)\\(-0.010+0.017j) &amp; 0.0 &amp; 0.186 &amp; 0.0 &amp; (-0.040+0.009j) &amp; 0.0 &amp; (0.008-0.003j) &amp; 0.0 &amp; (-0.001-1.722\times10^{-06}j) &amp; 0.0\\0.0 &amp; (-0.038-0.003j) &amp; 0.0 &amp; 0.105 &amp; 0.0 &amp; (-0.036+0.009j) &amp; 0.0 &amp; (0.013-0.008j) &amp; 0.0 &amp; (-0.013+0.010j)\\(0.003-0.006j) &amp; 0.0 &amp; (-0.040-0.009j) &amp; 0.0 &amp; 0.066 &amp; 0.0 &amp; (-0.020+0.006j) &amp; 0.0 &amp; (0.005-0.005j) &amp; 0.0\\0.0 &amp; (0.004-0.002j) &amp; 0.0 &amp; (-0.036-0.009j) &amp; 0.0 &amp; 0.046 &amp; 0.0 &amp; (-0.014-4.931\times10^{-04}j) &amp; 0.0 &amp; (0.002-0.006j)\\(-0.001+0.001j) &amp; 0.0 &amp; (0.008+0.003j) &amp; 0.0 &amp; (-0.020-0.006j) &amp; 0.0 &amp; 0.030 &amp; 0.0 &amp; (-0.010-0.003j) &amp; 0.0\\0.0 &amp; (0.002+0.002j) &amp; 0.0 &amp; (0.013+0.008j) &amp; 0.0 &amp; (-0.014+4.931\times10^{-04}j) &amp; 0.0 &amp; 0.016 &amp; 0.0 &amp; (-0.005+0.001j)\\(3.398\times10^{-04}-5.923\times10^{-05}j) &amp; 0.0 &amp; (-0.001+1.722\times10^{-06}j) &amp; 0.0 &amp; (0.005+0.005j) &amp; 0.0 &amp; (-0.010+0.003j) &amp; 0.0 &amp; 0.014 &amp; 0.0\\0.0 &amp; (-0.004-0.003j) &amp; 0.0 &amp; (-0.013-0.010j) &amp; 0.0 &amp; (0.002+0.006j) &amp; 0.0 &amp; (-0.005-0.001j) &amp; 0.0 &amp; 0.022\\\end{array}\right)\end{equation*} The fidelity of the final density matrices for these two methods is 0.9778358587429837. Basically they are not close enough. So the question is, which one is correct?! Note: Changing the solver options and subdividing the time into smaller intervals doesn't change anything. For example, here are the results for the same code but with the following time vector and mesolve options: tvec = np.linspace(0,tend,10000) options = Options(nsteps=5000) The result using mesolve is: \begin{equation*}\left(\begin{array}{*{11}c}0.212 &amp; 0.0 &amp; (0.004-0.052j) &amp; 0.0 &amp; (0.006+0.022j) &amp; 0.0 &amp; (-0.005-0.005j) &amp; 0.0 &amp; (0.002+9.285\times10^{-04}j) &amp; 0.0\\0.0 &amp; 0.384 &amp; 0.0 &amp; (-0.070+0.018j) &amp; 0.0 &amp; (0.009-0.004j) &amp; 0.0 &amp; (0.002+0.001j) &amp; 0.0 &amp; (-0.005-0.002j)\\(0.004+0.052j) &amp; 0.0 &amp; 0.195 &amp; 0.0 &amp; (-0.054+0.023j) &amp; 0.0 &amp; (0.011-0.010j) &amp; 0.0 &amp; (-0.001+0.003j) &amp; 0.0\\0.0 &amp; (-0.070-0.018j) &amp; 0.0 &amp; 0.082 &amp; 0.0 &amp; (-0.039+0.011j) &amp; 0.0 &amp; (0.015-0.008j) &amp; 0.0 &amp; (-0.012+0.011j)\\(0.006-0.022j) &amp; 0.0 &amp; (-0.054-0.023j) &amp; 0.0 &amp; 0.049 &amp; 0.0 &amp; (-0.019+0.009j) &amp; 0.0 &amp; (0.007-0.005j) &amp; 0.0\\0.0 &amp; (0.009+0.004j) &amp; 0.0 &amp; (-0.039-0.011j) &amp; 0.0 &amp; 0.039 &amp; 0.0 &amp; (-0.013-0.002j) &amp; 0.0 &amp; (0.008-0.004j)\\(-0.005+0.005j) &amp; 0.0 &amp; (0.011+0.010j) &amp; 0.0 &amp; (-0.019-0.009j) &amp; 0.0 &amp; 0.019 &amp; 0.0 &amp; (-0.006-0.002j) &amp; 0.0\\0.0 &amp; (0.002-0.001j) &amp; 0.0 &amp; (0.015+0.008j) &amp; 0.0 &amp; (-0.013+0.002j) &amp; 0.0 &amp; 0.008 &amp; 0.0 &amp; (-0.004+5.540\times10^{-04}j)\\(0.002-9.285\times10^{-04}j) &amp; 0.0 &amp; (-0.001-0.003j) &amp; 0.0 &amp; (0.007+0.005j) &amp; 0.0 &amp; (-0.006+0.002j) &amp; 0.0 &amp; 0.005 &amp; 0.0\\0.0 &amp; (-0.005+0.002j) &amp; 0.0 &amp; (-0.012-0.011j) &amp; 0.0 &amp; (0.008+0.004j) &amp; 0.0 &amp; (-0.004-5.540\times10^{-04}j) &amp; 0.0 &amp; 0.007\\\end{array}\right)\end{equation*} The result using RK45 is: \begin{equation*}\left(\begin{array}{*{11}c}0.243 &amp; 0.0 &amp; (-0.010-0.017j) &amp; 0.0 &amp; (0.003+0.006j) &amp; 0.0 &amp; (-0.001-0.001j) &amp; 0.0 &amp; (3.368\times10^{-04}+4.977\times10^{-05}j) &amp; 0.0\\0.0 &amp; 0.271 &amp; 0.0 &amp; (-0.038+0.003j) &amp; 0.0 &amp; (0.004+0.002j) &amp; 0.0 &amp; (0.002-0.002j) &amp; 0.0 &amp; (-0.004+0.003j)\\(-0.010+0.017j) &amp; 0.0 &amp; 0.186 &amp; 0.0 &amp; (-0.040+0.009j) &amp; 0.0 &amp; (0.007-0.003j) &amp; 0.0 &amp; (-0.001+4.236\times10^{-06}j) &amp; 0.0\\0.0 &amp; (-0.038-0.003j) &amp; 0.0 &amp; 0.105 &amp; 0.0 &amp; (-0.036+0.009j) &amp; 0.0 &amp; (0.013-0.008j) &amp; 0.0 &amp; (-0.013+0.010j)\\(0.003-0.006j) &amp; 0.0 &amp; (-0.040-0.009j) &amp; 0.0 &amp; 0.066 &amp; 0.0 &amp; (-0.020+0.006j) &amp; 0.0 &amp; (0.005-0.005j) &amp; 0.0\\0.0 &amp; (0.004-0.002j) &amp; 0.0 &amp; (-0.036-0.009j) &amp; 0.0 &amp; 0.046 &amp; 0.0 &amp; (-0.014-4.878\times10^{-04}j) &amp; 0.0 &amp; (0.002-0.006j)\\(-0.001+0.001j) &amp; 0.0 &amp; (0.007+0.003j) &amp; 0.0 &amp; (-0.020-0.006j) &amp; 0.0 &amp; 0.030 &amp; 0.0 &amp; (-0.010-0.003j) &amp; 0.0\\0.0 &amp; (0.002+0.002j) &amp; 0.0 &amp; (0.013+0.008j) &amp; 0.0 &amp; (-0.014+4.878\times10^{-04}j) &amp; 0.0 &amp; 0.016 &amp; 0.0 &amp; (-0.005+0.001j)\\(3.368\times10^{-04}-4.977\times10^{-05}j) &amp; 0.0 &amp; (-0.001-4.236\times10^{-06}j) &amp; 0.0 &amp; (0.005+0.005j) &amp; 0.0 &amp; (-0.010+0.003j) &amp; 0.0 &amp; 0.014 &amp; 0.0\\0.0 &amp; (-0.004-0.003j) &amp; 0.0 &amp; (-0.013-0.010j) &amp; 0.0 &amp; (0.002+0.006j) &amp; 0.0 &amp; (-0.005-0.001j) &amp; 0.0 &amp; 0.022\\\end{array}\right)\end{equation*} Their fidelity is 0.9778975808571535. So there is no convergence issue.",<programming><quantum-state><density-matrix><qutip><master-equation>,12/05/2021 18:22,,,,
22275.0,I can not extract the final statevector when using a binded Parametric Controlled gate,"I'm trying to implement a Parametric Hadamard Test. I have already my parametric evolution gate $\exp(-i\theta H)$ where $\theta$ is the parameter. When I defined the controlled-gate with Gate.control(1) and add it to the main circuit. I'm unable to correctly bind the parameters after and I can not get the state vector after the binded circuit. thetas = ParameterVector('T', length=1) it = iter(theta) # Define Hadamard Test qc = QuantumCircuit(3) qc.initialize(psi_0, [1,2]) qc.h(0) # Apply control gate tr_g_k = tr_g(dt=next(it)) # tr_g is the evolution gate $\exp(-i\theta H)$ tr_g_c = tr_g_k.control(1) qc.append(tr_g_c, [0,1,2]) qc.h(0) # -------------------------------------------------------- # Get the StateVector qc_b = qc.bind_parameters({theta: [np.pi]}) simulator = Aer.get_backend('aer_simulator') qc_bt = transpile(qc_b, simulator) qc_bt.save_statevector() result = simulator.run(qc_bt).result() statevector = result.get_statevector(qc_bt) When running the circuit I get: TypeError: ParameterExpression with unbound parameters ({ParameterVectorElement(T[0])}) cannot be cast to a float. I have tried without the control, i.e, only the evolution in the qubit 1 and 2 and it works. I think it's because the control, but so far, I have not been able to solve it. Thanks for any help !",<qiskit><programming><hadamard>,12/14/2021 12:31,,,,
23334.0,What does a statevector with 3 elements (in Qiskit) represent?,"I wasn't quite sure where to post this as I don't know if this is a Qiskit specific thing or not, but I'm not sure how to interpret this result I got from running a simulation. from result.data(): {'counts': {'0x0': 371, '0x1': 653}, 'statevector': [[0.6095190950364658, 0.00167238253077826], [0.6389605613454776, 0.46926856185163585], [0.0002864410240029574, -0.00010852146395313456]]} From result.get_statevector(): array([6.09519095e-01+1.67238253e-03j, 6.38960561e-01+4.69268562e-01j, 2.86441024e-04-1.08521464e-04j]) This is a 1-qubit system btw Also, I'm pretty new to QC, so pls be nice Here's the code I'm using to simulate the system: backend_sim = FakeArmonk() custom_gate = Gate('custom_gate', 1, []) qc1 = QuantumCircuit(1, 1) qc1.initialize([np.cos(a[0]/2), np.exp(a[1]*1.j)*np.sin(a[0]/2)], 0) qc1.append(custom_gate, [0]) qc1.measure(0, 0) with pulse.build(backend_sim, name='custom_gate') as my_schedule: pulse.play(Gaussian(duration=256+64, amp=.36, sigma=80), pulse.drive_channel(0)) qc1.add_calibration(custom_gate, [0], my_schedule) qc1 = transpile(qc1, backend_sim) pulse_sched = schedule(qc1, backend_sim) pulse_sched.draw() job1 = execute(pulse_sched, backend_sim, shots=1024) result1 = job1.result() result1.data() The initialize state doesn't matter, it is a random pure state, and the parameters of the Gaussian pulse are also arbitrary",<qiskit><programming><simulation>,12/19/2021 20:47,,,,
23367.0,"When I try to transpile circuit with Qiskit, how can I use $Ry(\pi/2)$ as a basis gate?","When I try to transpile circuit with Qiskit, I can use 'ry' as a basis gate. But I want to set one of the basis gate as $R_y(\pi/2)$. How can I do that? Edited: my_z2 = QuantumCircuit(1,name='z2') my_z2.rz(np.pi,0) z2_def = QuantumCircuit(1) z2_def.append(my_z2.to_gate(),[0]) StandardEquivalenceLibrary.add_equivalence(RZGate(np.pi), z2_def) qc = QuantumCircuit(1) qc.rz(np.pi,0) qc_trans = transpile(qc, basis_gates=['id','z2'],translation_method='translator') qc_trans.draw('mpl') This is my code and it throws CircuitError: CircuitError: 'Cannot bind parameters (rz[0]) not present in the circuit.' How can I fix this?",<qiskit><programming>,12/22/2021 8:31,,,,
23370.0,Why the pulse scheduler produces a different output from the original circuit?,"As part of a larger code, I have to convert a quantum circuit into a Pulse scheduler. The problem is that the scheduler output is incompatible with the circuit output. In particular, the difference between the circuit output and the expected output seems to be compatible with the statistical error, while the scheduler output does not converge to the target state for a large number of shots. This is an example: from qiskit import circuit, transpile, schedule from qiskit.test.mock import FakeAthens backend = FakeAthens() circ = circuit.QuantumCircuit(5) circ.h(0) circ.measure_all() circ_transpiled = transpile(circ, backend) #without scheduler counts = backend.run(circ_transpiled,shots=100000).result().get_counts() print(counts) #with scheduler scheds = schedule(circ_transpiled, backend) sched_counts = backend.run(scheds,shots=100000).result().get_counts() print(sched_counts) What is the source of this difference? And what can I do in order to produce the right result with the pulse scheduler? Thank you in advance.",<qiskit><programming><simulation><openpulse>,12/22/2021 11:40,,,,
23405.0,"Is there a software to simplify commutators such as $[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$?","Sometimes I need to simplify some commutators in the form $[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$. Doing it by hand is exhausting and boring. Is there software (Matlab, Python, Mathematica, etc) that can handle such commutators?",<programming>,12/24/2021 15:46,,,,
23453.0,How to make qiskit jupyter plot and draw properly,"The problem: You try to plot or draw more than once within a cell, or you try to plot or draw within a code block,but nothing comes out and you're going nuts... :)",<qiskit><programming>,12/28/2021 7:54,,,,
23481.0,How does one use the Qiskit CDMKRippleCarryAdder?,"How does one use (call from a main program) Qiskit's CDKMRippleCarryAdder in a quantum circuit, or for that matter, any other Qiskit library of a similar nature? For example, how do I create a 3 bit half adder module using the library to be used as part of an oracle for Grover's algorithm? Side-note: I've programmed for many years in traditional languages like C/C++ but I'm new to python and even newer to Qiskit and I'm very confused about how the parameters get passed in the case of the ripple carry adder library. I've tried searching for forums, but haven't found any other than this one. There also seems to be many tutorials on basics of quantum gates, but that's not what I'm looking for at the moment. Thanks in advance for your help.",<qiskit><programming>,12/30/2021 8:33,,,,
23608.0,QuTip - Is there a way to simulate more than one inital state in one simulation?,"I'm trying to use QuTip for a simulation of a qutrit system and I want to see how my system evolves under different initial states. Is there a way to do it using QuTip without running the simulation for each initial state separately? For example, I want to run a simulation for $|0\rangle$ state and $|1\rangle$ in the same run, but in mesolve method in QuTip one can insert only one initial state if I understand correctly.",<programming><simulation><qutip>,01/09/2022 08:53,,,,
23683.0,combine_results() attribute error,"When I tried to execute the below program, The attribute error hits me every time, which is; name 'combine_result' is not defined What is the problem here? Did I miss a module? cal_job = execute(cal_circuits, backend = real_device, shots= 1024, optimization_level = 0)) print(cal_job.job_id()) job_monitor(cal_job) cal_results = cal_job.result().combine_results() I'm not familiar with stack :)",<qiskit><programming>,1/13/2022 16:27,,,,
23848.0,How to use the csv dataset file imported as a dataframe in QSVM Qiskit code,"I am trying to run QSVM qiskit code with my custom dataset which I am loading as a pandas dataframe. When I execute the part below with my own dataset in the place of breast_cancer, it gives error &quot; Dataframe object not callable&quot; feature_dim = 2 sample_total, training_input, test_input, class_labels = breast_cancer( training_size=20, test_size=10, n=feature_dim, plot_data=True ) Please suggest how do i use my csv file as a dataset for QSVM qiskit code",<qiskit><programming><quantum-gate>,1/28/2022 10:58,,,,
24016.0,"Can a Hankel matrix $H$ be efficiently decomposed into a linear combination of unitaries (LCU), so that $H=\sum_k a_k U_k$","Suppose I have a Hankel matrix of arbitrary size $N\times M=2^n\times 2^m$ for integers $n&lt;m$ (the qubit numbers of two circuits I have at my possession), given by: $H=\begin{pmatrix}x_1&amp;x_2&amp;\cdots &amp; x_M\\x_2&amp;x_3&amp;\cdots&amp; x_1\\\vdots&amp;\vdots&amp;\ddots&amp; \vdots\\x_N&amp;x_{N+1}&amp;\cdots&amp; x_{M+N-1}\\ \end{pmatrix}$, with indices mod $N$. Does there exist an efficient method for decomposing this matrix into $H=\sum_{k=1}^T a_k U_k$ for certain unitaries $U_k$, such that $T\in\mathcal{O}(\text{poly}(m))$ at most? I know that you can take permutation matrices $P_k=\begin{pmatrix}1 &amp; 0 &amp; \cdots 0 &amp; 0\\0 &amp; 0 &amp; \cdots 0 &amp; 1\\\vdots &amp; \vdots &amp; \ddots 1 &amp; 0\\0 &amp; 0 &amp; \cdots 0 &amp; 0\\0 &amp; 1 &amp; \cdots 0 &amp; 0\\\end{pmatrix}$, such that $H=\sum_{k=1}^{2^m} x_k P_k$, but then $T\in\mathcal{O}(\text{exp}(m))$, which is inefficient. Any ideas?",<quantum-algorithms><matrix-representation><classical-computing>,02/09/2022 14:34,,,,
24055.0,What are some forums/resources/methods that help facilitate getting a job in quantum computing?,"I've been applying to a lot of jobs involving quantum computing on LinkedIn now but the applications all seem to end up getting lost to the void and I haven't had even one reply from any of them. I was wondering if there is a better more effective way to get a job in this field? Some background on myself: I have bachelor degrees in physics and astrophysics from UC Berkeley and took some of the first classes there offered in the field of quantum computing. I have mostly had professional experience with implementing post-quantum cryptography protocols and testing if existing ones have vulnerabilities that can be exploited. This sometimes involves implementing proof of concept demos which involve writing code for running quantum algorithms. I'm really passionate about the subject and feel like its where I should be professionally speaking but I don't really see any obvious window to get into the industry. Some helpful advice would be greatly appreciated, thank you. Also, apologies if this is the wrong board to ask this question. If such is the case let me know which one would be the best one.",<programming>,02/11/2022 22:36,,,,
24062.0,"From the $n$-qubit state $|Ï_0â©$, how do we find an orthonormal basis $\{|Ï_iâ©\}$ that includes $|Ï_0â©$ via the Gram-Schmidt process?","From the n-qubit pure state $|\psi_0\rangle$, how do we find an orthonormal basis $\{|\psi_i\rangle\},i\in[0,2nâ1]$ that includes the state $|\psi_0\rangle$ using the Gram-Schmidt process? Is there any program code which can we run on qiskit? I'm doing my masters and Quantum is a new topic for me so kindly guide me.",<qiskit><programming><textbook-and-exercises>,02/12/2022 15:24,,,,
24124.0,Projection and expected value in Qiskit?,"I want to make a circuit that measures the expected value of a projector. In this case I want to measure the expected value of the singlet projector operator, that is a non-unitary hermitian matrix. How can I do this in Qiskit? The singlet state is defines as: $\frac{|01&gt;-|10&gt;}{\sqrt{2}}$ And the matrix of the projector is: \begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1/2 &amp; -1/2 &amp; 0\\ 0 &amp; -1/2 &amp; 1/2 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 \end{pmatrix}",<qiskit><programming><matrix-representation>,2/16/2022 14:28,,,,
24192.0,How to flip qubit C if (A xor B)=1?,"Assume I have tree qubits (A,B, and C) I would like to flip qubit C if (A xor B)=1. The gate CCNOT(A,B,C) will flip C if A and B are both one. Please let me know if there is a solution.",<programming><quantum-circuit>,2/21/2022 0:28,,,,
24241.0,Qiskit QuantumCircuit.save_unitary() is showing an error,"OS: lubuntu 20.04 Mozilla Firefox browser jupyter-lab environment Error message: AttributeError: 'QuantumCircuit' object has no attribute 'save_unitary' Below is the code: from qiskit import QuantumCircuit, Aer, assemble from math import pi import numpy as np from qiskit.visualization import plot_bloch_multivector, plot_histogram, array_to_latex import matplotlib.pyplot as plt def show_figure(fig): # create a dummy figure and use its # manager to display &quot;fig&quot; dummy = plt.figure() #print(&quot;plt.figure is set&quot;) new_manager = dummy.canvas.manager #print(&quot;canvas.manager assigned&quot;) new_manager.canvas.figure = fig fig.set_canvas(new_manager.canvas) qc = QuantumCircuit(2) qc.x(0) qc.x(1) qc.h(0) qc.h(1) qc.cx(0,1) qc.h(0) qc.h(1) display(qc.draw(initial_state=True, output='mpl')) plt.show() print(qc) qc.save_unitary() usim = Aer.get_backend(&quot;aer_simulator&quot;) qobj = assemble(qc) unitary = usim.run(qobj).result().get_unitary() #array_to_latex(unitary, prefix=&quot;\\text{Circuit}\n&quot;) ```",<qiskit><programming>,2/24/2022 13:37,,,,
24257.0,Problem with fidelity value range obtained from this python code,"I'm calculating for instance the fidelity between two pure two qubit state, using the following python code: #calculate fidelity from scipy.linalg import fractional_matrix_power def fidelity(rho_pred , rho_trg): fid = np.trace( fractional_matrix_power((np.matmul((np.matmul(fractional_matrix_power(rho_pred, 0.5), rho_trg)) , fractional_matrix_power(rho_pred, 0.5)))), 0.5) return fid what I'm getting is bigger than 1 (like 6), is something wrong with the code? Also fidelity includes imaginary part!? Example Density Mtarix: A = np.matrix([[ 0.02759643+0.j , -1.24001054+0.31321969j, -0.65215435+0.64845159j, 0.27468692-0.06695888j], [-1.24001054-0.31321969j, 0.14355992+0.j , 2.26107285+3.80321405j, -0.71228114-0.36857898j], [-0.65215435-0.64845159j, 2.26107285-3.80321405j, 0.71370039+0.j , -2.5757435 +0.08429232j], [ 0.27468692+0.06695888j, -0.71228114+0.36857898j, -2.5757435 -0.08429232j, 0.11514326+0.j ]]) B = np.matrix([[ 0.02759643+0.j , 0.04772431+0.04103817j, -0.03512276+0.13587484j, 0.01716793-0.05369176j], [ 0.04772431-0.04103817j, 0.14355992+0.j , 0.14131705+0.2872077j , -0.05015446-0.1183828j ], [-0.03512276-0.13587484j, 0.14131705-0.2872077j , 0.71370039+0.j , -0.28620893-0.01619367j], [ 0.01716793+0.05369176j, -0.05015446+0.1183828j , -0.28620893+0.01619367j, 0.11514326+0.j ]])",<programming><fidelity>,2/25/2022 15:30,,,,
24263.0,Use parametrized quantum circuit output amplitudes for training in tensorflow,"I am trying to train a quantum neural network in tensorflow_quantum (tfq). Using cirq.Circuit I have set up my circuit. I now need to wrap it in a keras model for training. For this I must embed the circuit in a tfq.layers.PQC layer (according to the documentation: &quot;this layer is for training parameterized quantum models&quot;). However, when using PQC, I must specify a value for the parameter operators, which must be a cirq.PauliSum or Python list of cirq.PauliSum objects. I am unsure how to obtain the amplitudes via these kind of operators, but since I am dealing with a simulator I think it should not be necessary. Is there a way to train my circuit using the amplitudes of the circuit output? Thanks in advance.",<programming><quantum-circuit><cirq><tfq>,2/26/2022 6:37,,,,
24277.0,"transpiling a circuit in Qiskit results is ""configuration() missing 1 required positional argument""","I was learing about scheduling. So, to test scheduling for a 2 qubit circuit I tried to run this code but found error from qiskit.test.mock import FakeAlmaden from qiskit import QuantumCircuit, transpile qc2 = QuantumCircuit(2) backend = FakeAlmaden new_qc2 = transpile(qc2, backend) new_qc2.draw() TypeError: configuration() missing 1 required positional argument: 'self'",<qiskit><programming>,2/27/2022 7:35,,,,
24291.0,qutip.sesolve and qutip.optimize_pulse_unitary produce different results,"I'm currently trying out some things with qutip in the field of optimal control (state-to-state transfer) and have some trouble to reproduce my results from the optimization process with sesolve. My code for the optimization is: # define the main hamiltonian of our system H_0 = Qobj(w[0:dimension]*np.identity(dimension)) # define the drive-hamiltonian H_d = Qobj(matrix) # define the control-list for later optimization H_c = [H_d] # define the initial state of our system psi_0 = basis(dimension,0) # define the target state of our system psi_target = basis(dimension,1) # define the projector onto the inital state (|psi_0&gt;&lt;psi_0|) proj0 = ket2dm(psi_0) # define the projector onto the target state (|psi_target&gt;&lt;psi_target|) proj1 = ket2dm(psi_target) . . . result = cpo.optimize_pulse_unitary(H_0, H_c, psi_0, psi_target, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, init_pulse_type=p_type, log_level=log_level, gen_stats=True) Where I get a final fidelity error of 2.0313561943652303e-10. I wanted to verify this result by taking the optimized pulse and plugging it into the qutip.sesolve function but doing so gives me fidelity errors which are not compatible with the result from the optimization. My code for the sesolve function is: # define an evenly spaced list with the number of intervals being equal to the the time steps of our control pulse tlist = np.linspace(0, evo_time, n_ts) # define the optimized pulse optim_pulse = result.final_amps[:, 0] # define our &quot;Hamiltonian&quot; H = [H_0, [H_d, optim_pulse]] # define the e_ops list e_ops = [proj0, proj1] # define the intial state init_state = psi_0 options = Options() options.store_states = True # compute the time-evolution of the given Hamiltonian (including the drive term) from an inital state to a final state evolved_State = qutip.sesolve( H=H, psi0=init_state, tlist=tlist, e_ops=e_ops, options=options) Which produces a fidelity error of 0.0011998990068043947. I wondered if I'm doing something wrong with the application of the sesolve function or if its something else which produces this difference? Using other inital pulses I even sometimes get final populations of the target state lower then the inital state while the optimization result says it converged in the fidelity error. Would be awesome if anyone could share some input on this idea, thank you!",<programming><simulation><optimization><optical-quantum-computing><qutip>,2/28/2022 16:51,,,,
24324.0,How to convert Pennylane decompose_hamiltonian to Cirq PauliString?,"I have a matrix that I would like to decompose into a Pauli String. Pennylane's qml.utils.decompose_hamiltonian does this and returns a list of coefficients and a list of operations representing the decomposition. Is there any simple way to convert the format of the returned operations, i.e. from Identity(wires=[0]) @ PauliZ(wires=[1]) (Pennylane syntax) to cirq.PauliString(cirq.I(qubits[0]), cirq.Z(qubits[1]))?",<programming><hamiltonian-simulation><cirq><pennylane>,03/02/2022 17:37,,,,
24401.0,Qiskit CNOT matrix representation confusion,"I wanted to look at the matrix representation of CNOT gate as defined in Qiskit. from qiskit import Aer from qiskit.circuit import Gate from math import pi qc = QuantumCircuit(2) c = 0 t = 1 qc.cx(c,t) qc.draw() ____________________ Out[4]: q_0: âââ ââ âââ´ââ q_1: â¤ X â âââââ ____________________ import qiskit.quantum_info as qi op = qi.Operator(qc) print(op) ____________________ Operator([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]], input_dims=(2, 2), output_dims=(2, 2)) I am a bit confused, as I expected to see \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0 \end{matrix} What Qiskit output as the matrix representation of CNOT looks to me like CNOT with the first qubit as target and second qubit as control.",<qiskit><programming><quantum-gate>,03/06/2022 20:18,,,,
24421.0,Solving modified version of Simon's Algorithm with multiple secret strings,"I am stuck on the following question. Let $S$ be the $span${s1, s2, ... , sk} such that $S$ is a $k$-dimensional subspace of {0, 1}n. Let ð:{0,1}ðâ{0,1}ð be a function so that $f(x) = f(y)$ if and only if $x-y$ â $S$. Prove there is an algorithm that learns $S$ with $O(n)$ quantum queries to $f$. It seems like this is just like Simon's problem, except with multiple s instead of just one. The problem I'm having is solving it in $O(n)$. Wouldn't we have to run Simon's algorithm $k$ times since there are $k$ entries in $S$? In other words, there are $k$ number of s strings we have to find, right? Where am I going wrong?",<programming><quantum-algorithms><textbook-and-exercises><simons-algorithm>,03/07/2022 18:14,,,,
24458.0,Implementing the Oracle in Grover,"I need your expert opinions/comments on this problem. Suppose I have a database (say 16 entries), such that db[0] = 0.12, db[1] = 0.84, db[2] = 0.55, ..., db[15] = 0.91. I want the oracle to mark those indexes whose value is &gt; 0.8 (for example). In this case the oracle should mark the index of 1 &amp; 15 so that the Grover algo is able to pick out one of the desired index after a certain number of iterations. How should I go about doing this? My solution (I use Q#): I create 4 quantum registers; targetReg, yReg, x1Reg, x2Reg. x1Reg has 4 qubits, representing the database indices and in uniform superposition. x2Reg has qubits enough to represent the real numbers associated with each index. In this case, 7 qubits is suffice (I can simply multiply the values by 100 so that they become integers). yReg has the same number of qubits as x2Reg and initialized to 0.8 (or 80 after multiplication). targetReg has a single qubit. Start iteration { within {Compare yReg and x2Reg and set yReg to |0&gt; if x@Reg &gt; yReg.} apply {ControlledOnInt(0, X)(yReg, targetReg)}. Then perform the reflection. } End iteration. Measure x1Reg. Is this how it should be done? I have not actually tried it yet but I believe it should work although I have no clue how to implement Item 7 (the comparison). I was wondering if there are other alternate ways of doing it. Edit: I have written a Q# program that finds and marked entries that are equal to the desired entry. It seems to be working fine although my apologies if my code looks amateurish since I only started to learn Q# a month ago. Now I need to find out how to find and marked entries that are greater than the desired entry. operation GroverSearchIntDatabase() : Unit { let indexRegLength = 4; // number of qubits to represent the database indices let intRegLength = 7; // number of qubits to represent the integers // Generate the database randomly let databaseSize = 2 ^ indexRegLength; mutable database = [0, size = databaseSize]; for idx in 0 .. databaseSize - 1 { set database w/= idx &lt;- DrawRandomInt(0, (2 ^ intRegLength) - 1); } // Randomly select an index pointing to the desired integer let solutionIndex = DrawRandomInt(0, databaseSize - 1); let solutionInt = database[solutionIndex]; Message($&quot;The desired integer: {solutionInt}&quot;); // Find out how many indices have the same desired integer let predicate = EqualI(_, solutionInt); let nSolutions = Count(predicate, database); Message($&quot;Number of indices with the same integer: {nSolutions}&quot;); // Initiailize the quantum registers use indexReg = Qubit[indexRegLength]; use intReg = Qubit[intRegLength]; use desiredIntReg = Qubit[intRegLength]; use targetReg = Qubit(); let nIterations = Floor(Sqrt(IntAsDouble(databaseSize) / IntAsDouble(nSolutions)) * PI() / 4.0); mutable measuredIndex = 0; // Theoretical success probability let success_prob = Sin((2.0 * IntAsDouble(nIterations) + 1.0) * ArcSin(Sqrt(IntAsDouble(nSolutions)) / Sqrt(IntAsDouble(databaseSize)))) ^ 2.0; Message($&quot;Success probability: {success_prob}&quot;); // Grover Search ApplyToEach(H, indexReg); for _ in 1..nIterations { // This is the oracle within { X(targetReg); H(targetReg); // Associate the integers to the corresponding indices for idx in 0 .. databaseSize - 1 { ControlledOnInt(idx, ApplyXorInPlace)(indexReg, (database[idx], LittleEndian(intReg))); } // Set the desiredIntReg to |0&gt; if it is equal to solutionInt ApplyXorInPlace(solutionInt, LittleEndian(desiredIntReg)); for (q0, q1) in Zipped(intReg, desiredIntReg) { CNOT(q0, q1); } } apply { ControlledOnInt(0, X)(desiredIntReg, targetReg); } // This will be the reflect about uniform within { ApplyToEachA(H, indexReg); ApplyToEachA(X, indexReg); } apply { Controlled Z(Most(indexReg), Tail(indexReg)); } } set measuredIndex = MeasureInteger(LittleEndian(indexReg)); Message($&quot;Desired integer: {solutionInt}, Integer of measured index: {database[measuredIndex]}&quot;); }",<grovers-algorithm><q#><oracles>,03/10/2022 06:33,,,,
24501.0,Q# Application Template available for VS2022?,Implemented Grover Search Tutorial using Q# in VS2019. Moved to Windows 11 and also installed VS2022. Project opens and runs OK in VS2022. However code has no intellisense and color. i.e. program.qs appears as an ordinary text file. Attempting new Project in VS2022 does not find any Q# Templates. Is there something I need to do to install or is Q# Application Development not supported in VS2022 yet?,<q#>,03/12/2022 21:20,,,,
24551.0,How do I specify the coordinates of dephasing errors in the surface code using Stim,I am trying to find the threshold of a surface code for dephasing error using pymatching and stim. I am unable to apply the Z_ERROR onto the qubits using the given format since a surface code will require coordinates of the qubits. Format: Z_ERROR (probability) qubit_number Is there something I'm missing in terms of the syntax required to use Z_ERROR on the Stim generated surface code?,<programming><error-correction><stim>,3/17/2022 14:53,,,,
25729.0,Best classical algorithm for period finding on finite Abelian groups,"Given a finite Abelian group $G = \prod_{j=1}^n \mathbb{Z}_{m_j}$ with $m_j \geq 2$ and a function $h: G \to \mathbb{C}$ that is $s$-periodic. I have already proven that for all $\xi \in G$ we have $\hat h(\xi) = e^{2\pi i s \bullet \xi} \hat h(\xi)$, where $s \bullet \xi$ is an abbreviation for $\sum_{j=1}^n \frac{s_j\xi_j}{m_j}$. I now need to use this fact to construct a classical algorithm that could be used to find the period of $h$ given by oracle access. I am aware of the cases for $Z_2^n $ where the best classical algorithm uses $O(\sqrt{N})$ steps where $N = 2^n$ and for $Z_N$. Can anybody point me to a right direction to how to approach this problem in the case of arbitrary $G$ using a classical approach with FFT instead of a quantum algorithm?",<classical-computing><simons-algorithm>,3/31/2022 19:24,,,,
25733.0,"What's meaning of the expression like ""Qubit[] => Result""","In Q#,there are lots of expressions like &quot;Qubit[] =&gt; Result&quot;. It can be the type of return result,like this: function TailMeasurement(nQubits : Int) : (Qubit[] =&gt; Result) { ....... } Sometimes it can be type of arguements,like this: operation EstimateFrequency (preparation : (Qubit[] =&gt; Unit), measurement : (Qubit[] =&gt; Result), nQubits : Int, nMeasurements : Int) : Double {....} I think it's a method to declare the type of user-defined. But what's the meaning of it? After reading the documents, I think it means the left is a detailed explanation of the right. for example,preparation : (Qubit[] =&gt; Unit) means the type of preparation is Qubit[],and the element type of Qubit[] is Unit. It may like the List in Java? I just wondered if my understanding is right?",<programming><q#>,04/01/2022 02:43,,,,
25753.0,Calculating counts from statevector in Qiskit,"In Qiskit, how are counts calculated from statevectors ? For example ; backend = Aer.get_backend('aer_simulator') q = QuantumRegister(1,'q') c = ClassicalRegister(1,'c') a = 0.57045180 b = 0.82133108 circuit = QuantumCircuit(q,c) circuit.initialize([a,b], 0) circuit.h(q[0]) circuit.measure(q,c) print(circuit) job = execute(circuit, backend, shots=1024) counts = job.result().get_counts() circuit.save_statevector() qobj = assemble(circuit) state = backend.run(qobj).result().get_statevector() print(counts) print(state) Results in ; {'1': 32, '0': 992} Statevector([ 1.-7.22699275e-17j, -0.+0.00000000e+00j], dims=(2,)) How counts are calculated from statevectors ? I mean when statevector has a value, for single shot, how does it end up as an integer 1 or 0 (end state) ?",<qiskit><programming><quantum-state>,04/01/2022 19:06,,,,
26079.0,How does a quantum computer find the correct password faster than classical computers using brute-force?,"I didn't get this part right! For example, we have an online box with a 16-digit password, and we don't know what the password is! How can a quantum computer find the correct password faster than classical computers knowing that numbers are chosen at random? this makes both computers have 50/50 chance to guess the correct password if you are lucky enough right? Thanks.",<programming><quantum-gate><quantum-state><quantum-algorithms><ibm-q-experience>,4/21/2022 5:02,,,,
26109.0,Question about mock backends!,"I recently learned about the mock backends or the fake backends provided by Qiskit and I was wondering, do they behave the same way IBMQ systems backends like (ibmq_brooklyn)? also, can I depend on them? and what are the consequences? Thank you.",<qiskit><programming><quantum-gate><quantum-state><ibm-q-experience>,4/22/2022 18:51,,,,
26114.0,How do I use the quantum searching algorithm to loop search through a datafile in qiskit?,"I have a localhost index.html has a table contains names and address and balances etc... also there is a search bar on the home page to go through the pages, the interesting thing is, there is loooot of pages like 100 million pages (no kidding) it pretty crazy huge, i heard a quantum algorithm can search through a list much more quickly than an algorithm limited by the plodding pace of classical physics. I was wondering if it is possible to search through all these pages? or maybe just some of them? for instance i want to loop search through the pages for any names contains some funds on the balance section and the script will save the output on excel or txt file e.g: Name: Alan jackson City/Town: Wadebridge Balance: 0.00000$ Name: Leonard maguire City/Town: Paris Balance: 1445.00000$ Name: Ricardo gonzalez City/Town: San paolo Balance: 0.00000$ output: leonard maguire has a 1445$ on the balance. and then the script continues to search for more and save the output on the same file! if it possible can someone help me with the python script using Qiskit? sorry for my english. Thank you so much.",<qiskit><programming><ibm-q-experience><grovers-algorithm>,4/23/2022 1:11,,,,
26125.0,Generating a random 32-byte hex integer using Qiskit,"Hello I posted here yesterday about generating random 16 digits using Qiskit, and a gentle guy helped me but how about a string? How can I generate random 256 bit key in hex format in a superposition state and measure it? Anyway something like this but using Qiskit instead: def generate_key(): return binascii.hexlify(os.urandom(32)).decode('utf-8').upper() Output: CEF3A7BE7F95F3C27F393C74C99A2C1F1F8C658D3CD973C5FF3C266C7133AA38",<qiskit><programming><quantum-gate><quantum-state><ibm-q-experience>,4/24/2022 1:45,,,,
26174.0,How to implement a gate that generate a uniform superposition of all permutation of element,I'm looking for a quantum circuit that permits generating a uniform superposition of all possible permutations for example if we have as input $|0123\rangle$ the output will be the uniform superposition of all possible permutation $1/a(|0123\rangle+|1023\rangle+|0213\rangle+.....+|3210\rangle)$. I have already implemented a circuit with SWAP gates but the problem is I'm not getting the uniform superposition.,<qiskit><programming><quantum-state>,4/26/2022 23:39,,,,
26195.0,No module named 'qiskit.optimization' on Google Colab,"I have qiskit installed in my colab runtime and can import qiskit, but I can not import anything from qiskit.optimization. Am I missing something? EDIT: It seems that qiskit.optimization uses qiskit-aqua. Installing aqua resolved the import issues.",<qiskit><programming>,4/28/2022 22:16,,,,
26474.0,Is there a way to connect a IBM quantum lab code to an Unreal Engine project?,"I would like to know whether someone tried this before, I'm interested in be able to connect this tools. I know that Unreal Engine has a plugin to program with python, that all I know. I'll really appreciate your comments.",<programming><ibm-q-experience>,5/18/2022 21:03,,,,
26475.0,Converting data into a SHA256 hash using Qiskit quantum computer,"I was wondering how can we convert data into a hash using Qiskit quantum computer? e.g, this code below will generate a SHA256 hash based on random data. data = str(45) + &quot;f5a55af7ea98&quot; + &quot;8e84ad6f84f66&quot; hash = hashlib.sha256(data.encode()).hexdigest() print(hash) result: d73ee4cd204acb431745ba79154dac7d73bfe05608d3911bb432bc8b4a8addf9 I know the answer is not easy, although the question looks simple. Thank you",<qiskit><programming><quantum-gate><quantum-state><ibm-q-experience>,5/18/2022 21:10,,,,
26552.0,How well different featuremap encode the dataï¼,"Recently, I was doing research on QML. Qiskit gave detailed steps on how to encode data into quantum states, but I was confused about one point: there are different feature mapping methods under qiskit.circuit.library, such as : ZZFeatureMap, PauliFeatureMap, etc. I would like to ask if they have different applicability to different structured data? Are they a general way of feature mapping? For the study of regression datasets, which one is the best featuremap method?",<qiskit><programming><quantum-enhanced-machine-learning>,5/25/2022 7:05,,,,
26561.0,DIMACS Examples with few variables,"I am currently working on an SAT Solver using quantum computing. However, since current quantum computers are limited to a few qubits, I am in need of examples ranging from 4-30 variables. I know of a webpage that has DIMACS Files for 50+ variables but not less. Anyone know how to find ones with lesser variables?",<qiskit><programming>,5/25/2022 16:17,,,,
26566.0,AWS-Rigetti for beginners,"I'm interested in learning AWS Braket. Can someone help with basics like creating a circuit and sending a job to the hardware and at the same time how to automatically download the calibration data using python code. For example, IBMQ it is easy to download the calibration data so it is easy to automate the code for IBM. Is there something similar for AWS Braket? In other words I need a method to automate the process of sending jobs and downloading results and the calibration data. Also how to perform compilation to run circuits without further compilation? Thank you",<programming><quantum-gate><amazon-braket>,5/25/2022 20:46,,,,
26589.0,Whatâs the difference between the DriveChannel and the Control Channel?,"In my incredibly elementary understanding of superconducting qubits, a qubit is an LC circuit where the inductor has been replaced with a Josephson junction. In this system, microwave pulse operations to implement transformations on the qubit is achieved by a microwave drive line which coupled to the qubit with a capacitor. In Qiskit Pulse, we usually play our pulses on the DriveChannel, which I assume is directly related to the time varying voltage at the end of the microwave drive line (though Iâm a little unsure of where the AWGs come in?). In this big picture, Iâm not so sure where the ControlChannel comes into play. All the Qiskit docs say is that it is âassociated with multi-qubit gates,â but I am still unsure of how the ControlChannel is physically implemented or when to use it instead of the regular DriveChannel.",<qiskit><programming><openpulse><hardware>,5/27/2022 3:32,,,,
26744.0,"How to perform lattice surgery with initial state $|0\rangle+|1\rangle$, with qasm?","I am trying to perform a lattice surgery. Initial state is $|0\rangle+|1\rangle$ and when I perform a smooth merge and split, I think I get $|00\rangle+|11\rangle$ but it doesn't work. Is there something wrong with the code? include &quot;qelib1.inc&quot;; qreg q1[5]; qreg q2[5]; qreg q3[1]; qreg anc[6]; creg c1[5]; creg c2[5]; creg c3[1]; // initial state |+&gt; h q1[0]; cx q1[0],q1[3]; reset anc; h anc[0]; cx anc[0],q1[0]; cx anc[0],q1[1]; cx anc[0],q1[2]; h anc[0]; reset anc; h anc[0]; cx anc[0],q1[2]; cx anc[0],q1[3]; cx anc[0],q1[4]; h anc[0]; // int bit |+&gt; h q2[0]; cx q2[0],q2[3]; reset anc; h anc[0]; cx anc[0],q2[0]; cx anc[0],q2[1]; cx anc[0],q2[2]; h anc[0]; reset anc; h anc[0]; cx anc[0],q2[2]; cx anc[0],q2[3]; cx anc[0],q2[4]; h anc[0]; // smooth merge h q3[0]; // Z Stabilizer reset anc; h anc[0]; cz anc[0],q1[0]; cz anc[0],q2[3]; cz anc[0],q3[0]; h anc[0]; reset anc; h anc[0]; cz anc[0],q1[1]; cz anc[0],q2[4]; cz anc[0],q3[0]; h anc[0]; measure q3[0] -&gt; c3[0]; measure q1[0] -&gt; c1[0]; measure q1[1] -&gt; c1[1]; measure q1[2] -&gt; c1[2]; measure q1[3] -&gt; c1[3]; measure q1[4] -&gt; c1[4]; measure q2[0] -&gt; c2[0]; measure q2[1] -&gt; c2[1]; measure q2[2] -&gt; c2[2]; measure q2[3] -&gt; c2[3]; measure q2[4] -&gt; c2[4];",<programming><error-correction><qasm>,06/06/2022 04:54,,,,
27261.0,Is there any real world problem where I can see quantum computing being better than classical computing?,"Is there any paper or piece of code showing, on a REAL quantum computer, that a specific real world problem (possibly related to computer science, machine learning or finance and possibly NOT related to cryptography) is solved more efficiently than a classical computer ? In general, I'd be happy with any problem where a Quantum Computer can bring value, which does not need to be necessarily speedup. In fact, for me it's enough if the quantum version is better under any point of view (stability, robustness, energy consumption, model expressiveness ...) as long as this superiority is somehow showed and documented true actual comparisons and experiments. All the resources I looked at never make any comparison with the classical version and often claim quantum computing is powerful just showing it can solve a specific problem, without telling much about the classical counterpart.",<classical-computing><speedup><cq-states>,07/08/2022 14:06,,,,
27483.0,TranspilerError: 'The input circuit None is not scheduled',"The following error occurs when executing the code to measure the dephasing time(T2). I would appreciate it if someone could give me a solution to this problem. Among the two functions below, widthoutDelay() performs normally, and the function withDelay() fails with the attached error. Additionally, where can I find an example code to measure the time-dependent dephasing of the qubit? Some of the sample codes are from a few years ago, so there are a lot of contents that have been depreciated. --------------------------- Execution Code in jupyter --------------------------- from qiskit import QuantumRegister, ClassicalRegister from qiskit import QuantumCircuit, execute,IBMQ from qiskit.tools.monitor import job_monitor from qiskit import transpile import numpy pi = numpy.pi IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q') backend = provider.get_backend('ibm_nairobi') q = QuantumRegister(1,'q') c = ClassicalRegister(1,'c') def withoutDelay(): circuit = QuantumCircuit(q,c) circuit.h(q[0]) circuit.h(q[0]) circuit.measure(q[0],c[0]) #Measuring the qubit nShots = 8192 job = execute(circuit, backend, shots=nShots) job_monitor(job) counts = job.result().get_counts() print(""No delay: "",counts) def withDelay(): circuit = QuantumCircuit(q,c) circuit.h(q[0]) circuit.delay(283, unit=""us"") # Delay of 200.79 microseconds circuit.h(q[0]) circuit.measure(q[0],c[0]) #Measuring the qubit transpiled_circ = transpile(circuit, backend, scheduling_method='alap') nShots = 8192 job = execute(transpiled_circ, backend, shots=nShots) job_monitor(job) counts = job.result().get_counts() print(""With delay: "",counts) withoutDelay() withDelay() --------------------------- Error Message --------------------------- Job Status: job has successfully run No delay: {'0': 8111, '1': 81} --------------------------------------------------------------------------- TranspilerError Traceback (most recent call last) Input In [19], in () 49 print(""With delay: "",counts) 51 withoutDelay() ---> 52 withDelay() Input In [19], in withDelay() 40 transpiled_circ = transpile(circuit, backend, scheduling_method='alap') 42 nShots = 8192 ---> 44 job = execute(transpiled_circ, backend, shots=nShots) 45 job_monitor(job) 47 counts = job.result().get_counts() File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/execute_function.py:299, in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config) 296 experiments = pass_manager.run(experiments) 297 else: 298 # transpiling the circuits using given transpile options --> 299 experiments = transpile( 300 experiments, 301 basis_gates=basis_gates, 302 coupling_map=coupling_map, 303 backend_properties=backend_properties, 304 initial_layout=initial_layout, 305 seed_transpiler=seed_transpiler, 306 optimization_level=optimization_level, 307 backend=backend, 308 ) 310 if schedule_circuit: 311 experiments = schedule( 312 circuits=experiments, 313 backend=backend, (...) 316 method=scheduling_method, 317 ) File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:341, in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target) 338 for circuit, unique_args in zip(circuits, unique_transpile_args): 339 transpile_config, pass_manager = _combine_args(shared_args, unique_args) 340 output_circuits.append( --> 341 _serial_transpile_circuit( 342 circuit, 343 pass_manager, 344 transpile_config[""callback""], 345 transpile_config[""output_name""], 346 transpile_config[""backend_num_qubits""], 347 transpile_config[""faulty_qubits_map""], 348 transpile_config[""pass_manager_config""].backend_properties, 349 ) 350 ) 351 circuits = output_circuits 352 end_time = time() File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:434, in _serial_transpile_circuit(circuit, pass_manager, callback, output_name, num_qubits, faulty_qubits_map, backend_prop) 425 def _serial_transpile_circuit( 426 circuit, 427 pass_manager, (...) 432 backend_prop=None, 433 ): --> 434 result = pass_manager.run(circuit, callback=callback, output_name=output_name) 435 if faulty_qubits_map: 436 return _remap_circuit_faulty_backend( 437 result, 438 num_qubits, 439 backend_prop, 440 faulty_qubits_map, 441 ) File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:507, in StagedPassManager.run(self, circuits, output_name, callback) 500 def run( 501 self, 502 circuits: Union[QuantumCircuit, List[QuantumCircuit]], 503 output_name: str = None, 504 callback: Callable = None, 505 ) -> Union[QuantumCircuit, List[QuantumCircuit]]: 506 self._update_passmanager() --> 507 return super().run(circuits, output_name, callback) File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:224, in PassManager.run(self, circuits, output_name, callback) 222 return circuits 223 if isinstance(circuits, QuantumCircuit): --> 224 return self._run_single_circuit(circuits, output_name, callback) 225 if len(circuits) == 1: 226 return self._run_single_circuit(circuits[0], output_name, callback) File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:279, in PassManager._run_single_circuit(self, circuit, output_name, callback) 267 """"""Run all the passes on a ``circuit``. 268 269 Args: (...) 276 The transformed circuit. 277 """""" 278 running_passmanager = self._create_running_passmanager() --> 279 result = running_passmanager.run(circuit, output_name=output_name, callback=callback) 280 self.property_set = running_passmanager.property_set 281 return result File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:124, in RunningPassManager.run(***failed resolving arguments***) 122 for passset in self.working_list: 123 for pass_ in passset: --> 124 dag = self._do_pass(pass_, dag, passset.options) 126 circuit = dag_to_circuit(dag) 127 if output_name: File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:167, in RunningPassManager._do_pass(self, pass_, dag, options) 165 # Run the pass itself, if not already run 166 if pass_ not in self.valid_passes: --> 167 dag = self._run_this_pass(pass_, dag) 169 # update the valid_passes property 170 self._update_valid_passes(pass_) File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:221, in RunningPassManager._run_this_pass(self, pass_, dag) 218 elif pass_.is_analysis_pass: 219 # Measure time if we have a callback or logging set 220 start_time = time() --> 221 pass_.run(FencedDAGCircuit(dag)) 222 end_time = time() 223 run_time = end_time - start_time File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py:206, in ConstrainedReschedule.run(self, dag) 170 """"""Run rescheduler. 171 172 This pass should perform rescheduling to satisfy: (...) 202 TranspilerError: If circuit is not scheduled. 203 """""" 205 if ""node_start_time"" not in self.property_set: --> 206 raise TranspilerError( 207 f""The input circuit {dag.name} is not scheduled. Call one of scheduling passes "" 208 f""before running the {self.__class__.__name__} pass."" 209 ) 211 node_start_time = self.property_set[""node_start_time""] 213 for node in dag.topological_op_nodes(): TranspilerError: 'The input circuit None is not scheduled. Call one of scheduling passes before running the ConstrainedReschedule pass.'",<qiskit><programming>,7/26/2022 10:14,,,,
27544.0,Can there be an equivalent classical circuit for a quantum circuit?,"It is known that any classical circuit or algorithm can be implemented on a quantum computer using universal quantum gates. My question is, can there be a circuit with classical statistics which are equivalent to that of measurement probabilities of computational basis states in a quantum circuit? I understand my question might point to the simulability of quantum circuits classically as knowledge of the probabilities of the computational basis states can lead to the full reconstruction of the quantum states. In contrast to this, I was curious if there could be classical (or stochastic) circuits with equivalent transition probabilities.",<quantum-gate><circuit-construction><classical-computing>,7/30/2022 11:54,,,,
27615.0,Is there a way to get the controlled version of a AWS Braket Unitary?,"In qiskit we can simply define a custom unitary $U$ and get its controlled version $C-U$ with the method .control(). So, is there a way to do the same in AWS Braket??",<programming><amazon-braket>,08/03/2022 16:53,,,,
27622.0,Add a negative phase to selected states,"I have $n$ qubits in superposition. I want to add a negative phase to all states with more than $m$ $1$s, e.g. for $n=3$ qubits and $m=1$ I want to get: $\frac{1}{\sqrt{N}}(|000\rangle + |001\rangle + |010\rangle - |011\rangle + |100\rangle - |101\rangle - |110\rangle - |101\rangle - |111\rangle)$ I know that I can use CZ gate to add the negative phase, but if I have many qubits do I need to add CZ, C2Z, C3Z to cover any possible state? That would be $O(2^n)$ in the number of gates.",<programming><quantum-state><entanglement><circuit-construction>,08/04/2022 10:52,,,,
27734.0,What techniques can be used in order to debug a quantum program,I am programming in IBM tools like Qiskit and ProjectQ but have not found any examples/tutorials to debug a quantum program. I am interested in knowing the qbits value in-between the circuit within simulator (might be difficult for real quantum processors). I couldn't find any debug tag to make question more relevant.,<qiskit><programming><projectq>,08/11/2022 10:48,,,,
27771.0,"How does it work QasmSimulator with the option ""density matrix""?","I am making some simulations on IBM Quantum Lab and as backend I tried to use QasmSimulator(method = &quot;density_matrix&quot;) in order to simulate noise. I wanted to know how this method works in detail, because on the Qiskit Documentation I didn't find the details.",<qiskit><programming><noise><ibm-quantum-devices><qasm>,8/14/2022 10:39,,,,
27773.0,A path towards building quantum Computing graduation project for undergraduates,"I need help. I'm a computer science student with a Data science major. I have a final graduation project this year. With that, I want to create a project in the Quantum computing field. I'm already studying Quantum Computing for about two years. I have remarkably Experience in Qiskit. My question is, what exactly should I focus on in the field of Quantum to do in my graduation project? For example, should I make it with Quantum AI, or what would be good for me as a Computer Science student with a data science major? If you can suggest how I can find a good idea I can work on and develop would be great. Thank you so much for the help",<programming><quantum-gate><quantum-state><ibm-q-experience><quantum-enhanced-machine-learning>,8/14/2022 14:59,,,,
27980.0,qiskit transpile NameError,"I am a beginner in Quantum Computing programing and I need HELP. I do not know why the Python or Qiskit does not recognize the &quot;transpile&quot; command? For example, from qiskit import ( QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, transpile, ) simulator = Aer.get_backend('aer_simulator') qreg = QuantumRegister(2, 'q0') # greg is filled with two qubits creg = ClassicalRegister(2, 'c0') # creg is filled with two classical bits cir = QuantumCircuit(qreg,creg) # we put registers qreg and creg together to make our circuit, called entangled cir.h(0) # apply the Hadamard gate to the first qubit cir.cx(0,1) # apply the CNOT gate with the first as the control and the second qubit as the target cir.measure(0,0) cir.measure(1,1) cir=transpile(cir,simulator) --------------------------------------------------------------------------- NameError Traceback (most recent call last) Input In [1], in &lt;cell line: 1&gt;() ----&gt; 1 cir=transpile(cir,simulator) NameError: name 'transpile' is not defined I am using: Qiskit Version 0.21.2 Python Version 3.9.12 In the case the question cannot be answered by this group can you direct me to someone who can help me. Thank you in advance for your consideration. Full conda list: # packages in environment at C:\Users\Sirob\anaconda3: Note: you may need to restart the kernel to use updated packages. # # Name Version Build Channel _ipyw_jlab_nb_ext_conf 0.1.0 py39haa95532_0 aiohttp 3.8.1 py39h2bbff1b_1 aiosignal 1.2.0 pyhd3eb1b0_0 alabaster 0.7.12 pyhd3eb1b0_0 anaconda 2022.05 py39_0 anaconda-client 1.9.0 py39haa95532_0 anaconda-navigator 2.2.0 py39haa95532_0 anaconda-project 0.10.2 pyhd3eb1b0_0 anyio 3.5.0 py39haa95532_0 appdirs 1.4.4 pyhd3eb1b0_0 argon2-cffi 21.3.0 pyhd3eb1b0_0 argon2-cffi-bindings 21.2.0 py39h2bbff1b_0 arrow 1.2.2 pyhd3eb1b0_0 astroid 2.6.6 py39haa95532_0 astropy 5.0.4 py39h080aedc_0 asttokens 2.0.5 pyhd3eb1b0_0 async-timeout 4.0.1 pyhd3eb1b0_0 atomicwrites 1.4.0 py_0 attrs 21.4.0 pyhd3eb1b0_0 automat 20.2.0 py_0 autopep8 1.6.0 pyhd3eb1b0_0 babel 2.9.1 pyhd3eb1b0_0 backcall 0.2.0 pyhd3eb1b0_0 backports 1.1 pyhd3eb1b0_0 backports.functools_lru_cache 1.6.4 pyhd3eb1b0_0 backports.tempfile 1.0 pyhd3eb1b0_1 backports.weakref 1.0.post1 py_1 bcrypt 3.2.0 py39h196d8e1_0 beautifulsoup4 4.11.1 py39haa95532_0 binaryornot 0.4.4 pyhd3eb1b0_1 bitarray 2.4.1 py39h2bbff1b_0 bkcharts 0.2 py39haa95532_0 black 19.10b0 py_0 blas 1.0 mkl bleach 4.1.0 pyhd3eb1b0_0 blosc 1.21.0 h19a0ad4_0 bokeh 2.4.2 py39haa95532_0 boto3 1.21.32 pyhd3eb1b0_0 botocore 1.24.32 pyhd3eb1b0_0 bottleneck 1.3.4 py39h080aedc_0 brotli 1.0.9 ha925a31_2 brotlipy 0.7.0 py39h2bbff1b_1003 bzip2 1.0.8 he774522_0 ca-certificates 2022.3.29 haa95532_1 cachetools 4.2.2 pyhd3eb1b0_0 certifi 2021.10.8 py39haa95532_2 cffi 1.15.0 py39h2bbff1b_1 cfitsio 3.470 he774522_6 chardet 4.0.0 py39haa95532_1003 charls 2.2.0 h6c2663c_0 charset-normalizer 2.0.4 pyhd3eb1b0_0 click 8.0.4 py39haa95532_0 cloudpickle 2.0.0 pyhd3eb1b0_0 clyent 1.2.2 py39haa95532_1 colorama 0.4.4 pyhd3eb1b0_0 colorcet 2.0.6 pyhd3eb1b0_0 comtypes 1.1.10 py39haa95532_1002 conda 4.14.0 py39haa95532_0 conda-build 3.21.8 py39haa95532_2 conda-content-trust 0.1.1 pyhd3eb1b0_0 conda-env 2.6.0 haa95532_1 conda-pack 0.6.0 pyhd3eb1b0_0 conda-package-handling 1.8.1 py39h8cc25b3_0 conda-repo-cli 1.0.4 pyhd3eb1b0_0 conda-token 0.3.0 pyhd3eb1b0_0 conda-verify 3.4.2 py_1 console_shortcut 0.1.1 4 constantly 15.1.0 pyh2b92418_0 cookiecutter 1.7.3 pyhd3eb1b0_0 cryptography 3.4.8 py39h71e12ea_0 cssselect 1.1.0 pyhd3eb1b0_0 curl 7.82.0 h2bbff1b_0 cycler 0.11.0 pyhd3eb1b0_0 cython 0.29.28 py39hd77b12b_0 cytoolz 0.11.0 py39h2bbff1b_0 daal4py 2021.5.0 py39h8cb3d55_0 dal 2021.5.0 haa95532_796 dask 2022.2.1 pyhd3eb1b0_0 dask-core 2022.2.1 pyhd3eb1b0_0 dataclasses 0.8 pyh6d0b6a4_7 datashader 0.13.0 pyhd3eb1b0_1 datashape 0.5.4 py39haa95532_1 debugpy 1.5.1 py39hd77b12b_0 decorator 5.1.1 pyhd3eb1b0_0 defusedxml 0.7.1 pyhd3eb1b0_0 diff-match-patch 20200713 pyhd3eb1b0_0 dill 0.3.5.1 pypi_0 pypi distributed 2022.2.1 pyhd3eb1b0_0 docutils 0.17.1 py39haa95532_1 entrypoints 0.4 py39haa95532_0 et_xmlfile 1.1.0 py39haa95532_0 executing 0.8.3 pyhd3eb1b0_0 filelock 3.6.0 pyhd3eb1b0_0 flake8 3.9.2 pyhd3eb1b0_0 flask 1.1.2 pyhd3eb1b0_0 fonttools 4.25.0 pyhd3eb1b0_0 freetype 2.10.4 hd328e21_0 frozenlist 1.2.0 py39h2bbff1b_0 fsspec 2022.2.0 pyhd3eb1b0_0 future 0.18.2 py39haa95532_1 gensim 4.1.2 py39hd77b12b_0 giflib 5.2.1 h62dcd97_0 glob2 0.7 pyhd3eb1b0_0 google-api-core 1.25.1 pyhd3eb1b0_0 google-auth 1.33.0 pyhd3eb1b0_0 google-cloud-core 1.7.1 pyhd3eb1b0_0 google-cloud-storage 1.31.0 py_0 google-crc32c 1.1.2 py39h2bbff1b_0 google-resumable-media 1.3.1 pyhd3eb1b0_1 googleapis-common-protos 1.53.0 py39h2eaa2aa_0 greenlet 1.1.1 py39hd77b12b_0 grpcio 1.42.0 py39hc60d5dd_0 h5py 3.6.0 py39h3de5c98_0 hdf5 1.10.6 h7ebc959_0 heapdict 1.0.1 pyhd3eb1b0_0 holoviews 1.14.8 pyhd3eb1b0_0 hvplot 0.7.3 pyhd3eb1b0_1 hyperlink 21.0.0 pyhd3eb1b0_0 icc_rt 2019.0.0 h0cc432a_1 icu 58.2 ha925a31_3 idna 3.3 pyhd3eb1b0_0 imagecodecs 2021.8.26 py39ha1f97ea_0 imageio 2.9.0 pyhd3eb1b0_0 imagesize 1.3.0 pyhd3eb1b0_0 importlib-metadata 4.11.3 py39haa95532_0 importlib_metadata 4.11.3 hd3eb1b0_0 incremental 21.3.0 pyhd3eb1b0_0 inflection 0.5.1 py39haa95532_0 iniconfig 1.1.1 pyhd3eb1b0_0 intake 0.6.5 pyhd3eb1b0_0 intel-openmp 2021.4.0 haa95532_3556 intervaltree 3.1.0 pyhd3eb1b0_0 ipykernel 6.9.1 py39haa95532_0 ipython 8.2.0 py39haa95532_0 ipython_genutils 0.2.0 pyhd3eb1b0_1 ipywidgets 7.6.5 pyhd3eb1b0_1 isort 5.9.3 pyhd3eb1b0_0 itemadapter 0.3.0 pyhd3eb1b0_0 itemloaders 1.0.4 pyhd3eb1b0_1 itsdangerous 2.0.1 pyhd3eb1b0_0 jdcal 1.4.1 pyhd3eb1b0_0 jedi 0.18.1 py39haa95532_1 jinja2 2.11.3 pyhd3eb1b0_0 jinja2-time 0.2.0 pyhd3eb1b0_3 jmespath 0.10.0 pyhd3eb1b0_0 joblib 1.1.0 pyhd3eb1b0_0 jpeg 9e h2bbff1b_0 jq 1.6 haa95532_1 json5 0.9.6 pyhd3eb1b0_0 jsonschema 4.4.0 py39haa95532_0 jupyter 1.0.0 py39haa95532_7 jupyter_client 6.1.12 pyhd3eb1b0_0 jupyter_console 6.4.0 pyhd3eb1b0_0 jupyter_core 4.9.2 py39haa95532_0 jupyter_server 1.13.5 pyhd3eb1b0_0 jupyterlab 3.3.2 pyhd3eb1b0_0 jupyterlab_pygments 0.1.2 py_0 jupyterlab_server 2.10.3 pyhd3eb1b0_1 jupyterlab_widgets 1.0.0 pyhd3eb1b0_1 keyring 23.4.0 py39haa95532_0 kiwisolver 1.3.2 py39hd77b12b_0 lazy-object-proxy 1.6.0 py39h2bbff1b_0 lcms2 2.12 h83e58a3_0 lerc 3.0 hd77b12b_0 libaec 1.0.4 h33f27b4_1 libarchive 3.4.2 h5e25573_0 libcrc32c 1.1.1 ha925a31_2 libcurl 7.82.0 h86230a5_0 libdeflate 1.8 h2bbff1b_5 libiconv 1.16 h2bbff1b_2 liblief 0.11.5 hd77b12b_1 libpng 1.6.37 h2a8f88b_0 libprotobuf 3.19.1 h23ce68f_0 libspatialindex 1.9.3 h6c2663c_0 libssh2 1.10.0 hcd4344a_0 libtiff 4.2.0 hd0e1b90_0 libwebp 1.2.2 h2bbff1b_0 libxml2 2.9.12 h0ad7f3c_0 libxslt 1.1.34 he774522_0 libzopfli 1.0.3 ha925a31_0 llvmlite 0.38.0 py39h23ce68f_0 locket 0.2.1 py39haa95532_2 lxml 4.8.0 py39h1985fb9_0 lz4-c 1.9.3 h2bbff1b_1 lzo 2.10 he774522_2 m2w64-libwinpthread-git 5.0.0.4634.697f757 2 markdown 3.3.4 py39haa95532_0 markupsafe 2.0.1 py39h2bbff1b_0 matplotlib 3.5.1 py39haa95532_1 matplotlib-base 3.5.1 py39hd77b12b_1 matplotlib-inline 0.1.2 pyhd3eb1b0_2 mccabe 0.6.1 py39haa95532_1 menuinst 1.4.18 py39h59b6b97_0 mistune 0.8.4 py39h2bbff1b_1000 mkl 2021.4.0 haa95532_640 mkl-service 2.4.0 py39h2bbff1b_0 mkl_fft 1.3.1 py39h277e83a_0 mkl_random 1.2.2 py39hf11a4ad_0 mock 4.0.3 pyhd3eb1b0_0 mpmath 1.2.1 py39haa95532_0 msgpack-python 1.0.2 py39h59b6b97_1 msys2-conda-epoch 20160418 1 multidict 5.1.0 py39h2bbff1b_2 multipledispatch 0.6.0 py39haa95532_0 munkres 1.1.4 py_0 mypy_extensions 0.4.3 py39haa95532_1 navigator-updater 0.2.1 py39_1 nbclassic 0.3.5 pyhd3eb1b0_0 nbclient 0.5.13 py39haa95532_0 nbconvert 6.4.4 py39haa95532_0 nbformat 5.3.0 py39haa95532_0 nest-asyncio 1.5.5 py39haa95532_0 networkx 2.7.1 pyhd3eb1b0_0 nltk 3.7 pyhd3eb1b0_0 nose 1.3.7 pyhd3eb1b0_1008 notebook 6.4.8 py39haa95532_0 ntlm-auth 1.5.0 pypi_0 pypi numba 0.55.1 py39hf11a4ad_0 numexpr 2.8.1 py39hb80d3ca_0 numpy 1.21.5 py39h7a0a035_1 numpy-base 1.21.5 py39hca35cd5_1 numpydoc 1.2 pyhd3eb1b0_0 olefile 0.46 pyhd3eb1b0_0 openjpeg 2.4.0 h4fc8c34_0 openpyxl 3.0.9 pyhd3eb1b0_0 openssl 1.1.1n h2bbff1b_0 packaging 21.3 pyhd3eb1b0_0 pandas 1.4.2 py39hd77b12b_0 pandocfilters 1.5.0 pyhd3eb1b0_0 panel 0.13.0 py39haa95532_0 param 1.12.0 pyhd3eb1b0_0 paramiko 2.8.1 pyhd3eb1b0_0 parsel 1.6.0 py39haa95532_0 parso 0.8.3 pyhd3eb1b0_0 partd 1.2.0 pyhd3eb1b0_1 pathspec 0.7.0 py_0 patsy 0.5.2 py39haa95532_1 pbr 5.10.0 pypi_0 pypi pep8 1.7.1 py39haa95532_0 pexpect 4.8.0 pyhd3eb1b0_3 pickleshare 0.7.5 pyhd3eb1b0_1003 pillow 9.0.1 py39hdc2b20a_0 pip 21.2.4 py39haa95532_0 pkginfo 1.8.2 pyhd3eb1b0_0 plotly 5.6.0 pyhd3eb1b0_0 pluggy 1.0.0 py39haa95532_1 ply 3.11 pypi_0 pypi powershell_shortcut 0.0.1 3 poyo 0.5.0 pyhd3eb1b0_0 prometheus_client 0.13.1 pyhd3eb1b0_0 prompt-toolkit 3.0.20 pyhd3eb1b0_0 prompt_toolkit 3.0.20 hd3eb1b0_0 protego 0.1.16 py_0 protobuf 3.19.1 py39hd77b12b_0 psutil 5.8.0 py39h2bbff1b_1 ptyprocess 0.7.0 pyhd3eb1b0_2 pure_eval 0.2.2 pyhd3eb1b0_0 py 1.11.0 pyhd3eb1b0_0 py-lief 0.11.5 py39hd77b12b_1 pyasn1 0.4.8 pyhd3eb1b0_0 pyasn1-modules 0.2.8 py_0 pycodestyle 2.7.0 pyhd3eb1b0_0 pycosat 0.6.3 py39h2bbff1b_0 pycparser 2.21 pyhd3eb1b0_0 pyct 0.4.6 py39haa95532_0 pycurl 7.44.1 py39hcd4344a_1 pydispatcher 2.0.5 py39haa95532_2 pydocstyle 6.1.1 pyhd3eb1b0_0 pyerfa 2.0.0 py39h2bbff1b_0 pyflakes 2.3.1 pyhd3eb1b0_0 pygments 2.11.2 pyhd3eb1b0_0 pyhamcrest 2.0.2 pyhd3eb1b0_2 pyjwt 2.1.0 py39haa95532_0 pylatexenc 2.10 pypi_0 pypi pylint 2.9.6 py39haa95532_1 pyls-spyder 0.4.0 pyhd3eb1b0_0 pynacl 1.4.0 py39hbd8134f_1 pyodbc 4.0.32 py39hd77b12b_1 pyopenssl 21.0.0 pyhd3eb1b0_1 pyparsing 3.0.4 pyhd3eb1b0_0 pyqt 5.9.2 py39hd77b12b_6 pyreadline 2.1 py39haa95532_1 pyrsistent 0.18.0 py39h196d8e1_0 pysocks 1.7.1 py39haa95532_0 pytables 3.6.1 py39h56d22b6_1 pytest 7.1.1 py39haa95532_0 python 3.9.12 h6244533_0 python-dateutil 2.8.2 pyhd3eb1b0_0 python-fastjsonschema 2.15.1 pyhd3eb1b0_0 python-libarchive-c 2.9 pyhd3eb1b0_1 python-lsp-black 1.0.0 pyhd3eb1b0_0 python-lsp-jsonrpc 1.0.0 pyhd3eb1b0_0 python-lsp-server 1.2.4 pyhd3eb1b0_0 python-slugify 5.0.2 pyhd3eb1b0_0 python-snappy 0.6.0 py39hd77b12b_3 pytz 2021.3 pyhd3eb1b0_0 pyviz_comms 2.0.2 pyhd3eb1b0_0 pywavelets 1.3.0 py39h2bbff1b_0 pywin32 302 py39h2bbff1b_2 pywin32-ctypes 0.2.0 py39haa95532_1000 pywinpty 2.0.2 py39h5da7b33_0 pyyaml 6.0 py39h2bbff1b_1 pyzmq 22.3.0 py39hd77b12b_2 qdarkstyle 3.0.2 pyhd3eb1b0_0 qiskit 0.37.2 pypi_0 pypi qiskit-aer 0.10.4 pypi_0 pypi qiskit-ibmq-provider 0.19.2 pypi_0 pypi qiskit-terra 0.21.2 pypi_0 pypi qstylizer 0.1.10 pyhd3eb1b0_0 qt 5.9.7 vc14h73c81de_0 qtawesome 1.0.3 pyhd3eb1b0_0 qtconsole 5.3.0 pyhd3eb1b0_0 qtpy 2.0.1 pyhd3eb1b0_0 queuelib 1.5.0 py39haa95532_0 regex 2022.3.15 py39h2bbff1b_0 requests 2.27.1 pyhd3eb1b0_0 requests-file 1.5.1 pyhd3eb1b0_0 requests-ntlm 1.1.0 pypi_0 pypi retworkx 0.11.0 pypi_0 pypi rope 0.22.0 pyhd3eb1b0_0 rsa 4.7.2 pyhd3eb1b0_1 rtree 0.9.7 py39h2eaa2aa_1 ruamel_yaml 0.15.100 py39h2bbff1b_0 s3transfer 0.5.0 pyhd3eb1b0_0 scikit-image 0.19.2 py39hf11a4ad_0 scikit-learn 1.0.2 py39hf11a4ad_1 scikit-learn-intelex 2021.5.0 py39haa95532_0 scipy 1.7.3 py39h0a974cb_0 scrapy 2.6.1 py39haa95532_0 seaborn 0.11.2 pyhd3eb1b0_0 send2trash 1.8.0 pyhd3eb1b0_1 service_identity 18.1.0 pyhd3eb1b0_1 setuptools 61.2.0 py39haa95532_0 sip 4.19.13 py39hd77b12b_0 six 1.16.0 pyhd3eb1b0_1 smart_open 5.1.0 pyhd3eb1b0_0 snappy 1.1.9 h6c2663c_0 sniffio 1.2.0 py39haa95532_1 snowballstemmer 2.2.0 pyhd3eb1b0_0 sortedcollections 2.1.0 pyhd3eb1b0_0 sortedcontainers 2.4.0 pyhd3eb1b0_0 soupsieve 2.3.1 pyhd3eb1b0_0 sphinx 4.4.0 pyhd3eb1b0_0 sphinxcontrib-applehelp 1.0.2 pyhd3eb1b0_0 sphinxcontrib-devhelp 1.0.2 pyhd3eb1b0_0 sphinxcontrib-htmlhelp 2.0.0 pyhd3eb1b0_0 sphinxcontrib-jsmath 1.0.1 pyhd3eb1b0_0 sphinxcontrib-qthelp 1.0.3 pyhd3eb1b0_0 sphinxcontrib-serializinghtml 1.1.5 pyhd3eb1b0_0 spyder 5.1.5 py39haa95532_1 spyder-kernels 2.1.3 py39haa95532_0 sqlalchemy 1.4.32 py39h2bbff1b_0 sqlite 3.38.2 h2bbff1b_0 stack_data 0.2.0 pyhd3eb1b0_0 statsmodels 0.13.2 py39h2bbff1b_0 stevedore 4.0.0 pypi_0 pypi sympy 1.10.1 py39haa95532_0 tabulate 0.8.9 py39haa95532_0 tbb 2021.5.0 h59b6b97_0 tbb4py 2021.5.0 py39h59b6b97_0 tblib 1.7.0 pyhd3eb1b0_0 tenacity 8.0.1 py39haa95532_0 terminado 0.13.1 py39haa95532_0 testpath 0.5.0 pyhd3eb1b0_0 text-unidec",<qiskit><programming>,8/29/2022 12:48,,,,
28067.0,Seeding a stim.TableauSimulator,"When creating a sampler from a stim.Circuit (say, for example, using stim.Circuit.compile_sampler), one can provide a seed to the random number generator to make sure the simulation is reproducible. However, I am looking at an error model that requires me to manually apply operations to a stim.TableauSimulator instead. Is there a way/workaround to also allow me to seed the random number generator used by the stim.TableauSimulator.measure?",<programming><stim>,09/05/2022 12:42,,,,
28079.0,Why does method to_bqm not maintain variables order?,"When converting to bqm with .compile().to_bqm(), the original order of the variables is not maintained. To reproduce: from pyqubo import Array, Binary n=3 m=12 X = Array.create('x', shape=(n,m), vartype='BINARY') for i in range(n): a=0 for j in range(m): a += 2.0 * X[i,j] diff = a - 1.5 model = diff.compile() print(&quot;BEFORE: &quot;, model.variables) print(&quot;AFTER: &quot;, model.to_bqm().variables) The first two printed lines are: BEFORE: ['x[0][0]', 'x[0][1]', 'x[0][2]', 'x[0][3]', 'x[0][4]', 'x[0][5]', 'x[0][6]', 'x[0][7]', 'x[0][8]', 'x[0][9]', 'x[0][10]', 'x[0][11]'] AFTER: Variables(['x[0][6]', 'x[0][11]', 'x[0][10]', 'x[0][7]', 'x[0][4]', 'x[0][3]', 'x[0][2]', 'x[0][5]', 'x[0][8]', 'x[0][9]', 'x[0][1]', 'x[0][0]']) How can I preserve the original order of the variables?",<programming><d-wave><applications>,09/07/2022 07:12,,,,
28154.0,projectq code hangs with only 8 qibts,"I have written a simple projectq code with 8qbits in order to perform full addition but it gets stuck somewhere between without generating any error message. It worked fine for 4 qbits. def full_adder(eng,x,y,length,s,cin,cout): aux = eng.allocate_qureg(4) print(&quot;Going into loop to perform operations \n&quot;) for i in range(length): Toffoli | (x[i], y[i], aux[1]) CNOT | (x[i], s[i]) CNOT | (y[i], s[i]) Toffoli | (cin, s[i], aux[0]) CNOT | (cin, s[i]) CNOT | (aux[0], aux[2]) CNOT | (aux[1], aux[2]) Toffoli | (aux[0], aux[1], aux[3]) CNOT | (aux[2], cout) CNOT | (aux[3], cout) print(&quot;Addition completed going out of the loop \n&quot;) def main(eng): x = eng.allocate_qureg(8) # first y = eng.allocate_qureg(8) # second s = eng.allocate_qureg(8) # sum cout = eng.allocate_qureg(1) # carry out cin = eng.allocate_qureg(1) # carry in length=8 input1=0xab input2=0x12 Round_constant_XOR(eng,x,input1,length) Round_constant_XOR(eng,y,input2,length) print(&quot;About to start Addition \n&quot;) full_adder(eng,x,y,length,s,cin,cout) print(&quot;Addition Completed, printing results \n&quot;) print_state(eng,s,length) Simulate = MainEngine() main(Simulate) Simulate.flush() Below is the output (Note: This is the (slow) Python simulator.) About to start Addition Going into loop to perform operations Addition completed going out of the loop Once it gets out of the full_adder function, it gets stuck, and nothing happens after this.",<programming><simulation><projectq>,9/13/2022 6:59,,,,
28166.0,How to apply mid-circuit measurement and measurement based conditional operations in `amazon-braket`?,"Is there any method to apply mid circuit measurements in amazon-braket? I'm implementing a circuit that has few operations conditioned to measurement. In qiskit, it is possible. I'm wondering how to do it using braket?",<programming><quantum-gate><quantum-circuit><amazon-braket>,9/14/2022 6:23,,,,
28169.0,Why importing cirq_ionq gives an unexpected argument error,"I'm trying to install cirq_ionq, a python library for running cirq circuits on IonQ's quantum hardware. However, when I try importing it I get an unexpected argument error: !pip install cirq-ionq import cirq_ionq &lt;ipython-input-8-d96952276b12&gt; in &lt;module&gt; 1 get_ipython().system('pip install cirq-ionq') ----&gt; 2 import cirq_ionq 1 frames /usr/local/lib/python3.7/dist-packages/cirq_ionq/ionq_devices.py in &lt;module&gt; 32 cirq.MeasurementGate, 33 unroll_circuit_op=False, ---&gt; 34 accept_global_phase_op=False, 35 ) 36 TypeError: __init__() got an unexpected keyword argument 'accept_global_phase_op' I am confused why I am getting an unexpected argument error. I'm not calling a constructor, I am importing a library, right? Could someone please explain this to me? I appreciate it.",<cirq><ionq><programming>,9/14/2022 14:35,,,,
28219.0,How to add constraints to a BQM?,"BQM is unconstrained by definition. I need to submit a knapsack problem with two constraints (equality constraints + inequality constraints) to a quantum annealer (DWaveSampler). How would you set the problem as a BQM to be sampled fully quantum (no hybrid solver)? My understanding is that Pyqubo can convert equality constraints to bqm, but it is not clear to me if it can handle inequality constraints too. More in general, what would be the best strategy for solving a (large!) constrained optimization problem with quantum annealing?",<programming><d-wave><applications><pyqubo>,9/19/2022 6:31,,,,
28559.0,Why do computer scientists care about the phase of qubits?,"When I design some classical register, flip-flop, binary counter, small byte of RAM, etc from scratch with classical logic gate, I never deal with such binary direction because classical bit doesn't have direction. I only care about whether its state currently in 0 or 1. Yes in classical gate, the magnitude amplitude is always deterministic (magnitude=1 or magnitude=0). I accept the notion of this magnitude because it's useful for superposition state therefore it's useful for parallel computation. But why we need to know its phase angle too? What is the simple example of phase application? When I was designing full-adder that was discovered by Feynman as a simple example with just using Toffoli (CCNOT) and CNOT, I still don't have business with direction (phase angle). So why should we care about phase angle (direction) in qubit state? Update: As far as I understand from average answers, the most simple example of phase application is for distinguish superposition state from previous state. For example: To make a superposition state from a qubit, we put Hadamard gate H. If the previous state was |0&gt;, then it became superposition state |+&gt;. If the previous state was |1&gt;, then it became superposition state too, but with rotating phase (Ï). Hence the superposition state is |-&gt;. So if we put the Hadamard gate again, If the superposition state is |+&gt;, then it will became |0&gt; again. If the superposition state is |-&gt;, then it will became |1&gt; again. I'm as a computer engineer (not computer scientist), from explanation above I think in another word the phase is useful for storing previous state (memory) in case of Hadamard gate. What I mean with storing is, |+&gt; and |-&gt; are both superposition state with carrying information about its previous state (we can think it act as memory). |+&gt; the previous state was |0&gt;, while |-&gt; the previous state was |1&gt;. So when someone say hey, it's in superposition state., If we care about its previous state, we wouldn't know unless that someone write it mathematically with|+&gt; or |-&gt;. Or tells explicitly like hey, it's in superposition state with phase angle Ï. then we know that the previous state was |1&gt;. But Hadamard gate is playing with rotating phase to the Ï. How about rotating phase to the Ï/2?. What case can I do for rotating phase to the Ï/2.",<quantum-state><classical-computing>,10/16/2022 3:10,,,,
28581.0,Qubit reset using Grover iteration,"Suppose Iâm building a long circuit and I need to reuse a qubit from a previous step but I donât want to use the reset operation (or Iâm not using an IBM computer so I donât even have the reset option). Could I apply some Grover-style rotation of the qubit that I want to reset, like if I was searching for the state $|0\rangle$? I know that the Grover algorithm presumes you are starting from a qubit in a uniform superimposition - but what would happen if I tried to do a Grover-like search for $|0\rangle$ starting from any arbitrary state instead of a uniform superimposition? Would I still get to $|0\rangle$ or would something weird happen?",<programming><quantum-state><circuit-construction><grovers-algorithm>,10/17/2022 18:17,,,,
28589.0,Pymatching Toric Code vs Surface Code,"I am looking the example of toric code in Pymatching. Here is the code: import numpy as np import matplotlib.pyplot as plt from scipy.sparse import hstack, kron, eye, csr_matrix, block_diag def repetition_code(n): row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n))) data = np.ones(2*n, dtype=np.uint8) return csr_matrix((data, (row_ind, col_ind))) def toric_code_x_stabilisers(L): Hr = repetition_code(L) H = hstack( [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)], dtype=np.uint8 ) H.data = H.data % 2 H.eliminate_zeros() return csr_matrix(H) def toric_code_x_logicals(L): H1 = csr_matrix(([1], ([0],[0])), shape=(1,L), dtype=np.uint8) H0 = csr_matrix(np.ones((1, L), dtype=np.uint8)) x_logicals = block_diag([kron(H1, H0), kron(H0, H1)]) x_logicals.data = x_logicals.data % 2 x_logicals.eliminate_zeros() return csr_matrix(x_logicals) I want to test minumum weight perfect matching in Pymatching. I want to run this code in the absence of noise and I want to see what will be the result of pymatching. To do that, I use the following : H=toric_code_x_stabilisers(4) matching = pymatching.Matching(H) matching.draw() Is that correct? I see nothing, is it because I have no error in the system or is it because there is some issue with matching.draw() function? Then I tried the following code scripts: H=toric_code_x_stabilisers(4) noise = np.array([0,0,0,0]) #no error z = H@noise % 2 m=Matching(H) print(m) m.draw() c = m.decode(z) And I got the dimension mismatch error.. I want to simulate surface code in the absence of error. It is simply I will initialize my data qubits in zero states and I will use x and z stabilizer. I will measure the stabilizers and I will see the result. For example, when I measure the X stabilizer, they will commute with Z stabilizer etc.. In that case, I am not sure what should change in toric code to make it surface code. It seemed to me that, toric_code_x_stabilisers can stay same. Do we have a small example for surface code?",<programming><surface-code><toric-code><pymatching><minimum-weight-perfect-matching>,10/18/2022 12:46,,,,
28698.0,Symbolic library for qubit states,"Is there any symbolic package (in Python or Julia, for example) that can represent qubit state coefficients symbolically? For example, let's assume we have an initial two-qubit state: $$ | \psi \rangle = c_1 |01\rangle + c_2 |11\rangle + c_3 |00\rangle. $$ Maybe I want to act with $R_Y (\theta)$ on the first qubit and then act with a Hadamard on the second qubit and so on. Can I still get the final state in terms of symbols $c_1, c_2, c_3, \theta$, etc? Thanks in advance!",<programming><quantum-state>,10/27/2022 4:22,,,,
28840.0,Writing a qiskit code for a encryption problem,"Bob wants to send his friend Alice a message in the form of a string of bits, s. In order to make it harder for an eavesdropper to read s, Bob does the following: Defines a function $ f: \{0,1\}^n â \{0,1\}, f(x) = â s_ix_i \text{ } mod \text{ } 2$ Creates a quantum circuit $ U_f$ that takes the state $|xâ©_n|yâ©_1$ to $|xâ©_n|y \oplus f(x)â©_1$ Bob encapsulates $U_f$ into a black box and delivers it to Alice. Alice is able to query the black box with a quantum state and get the output, but she cannot look at the circuit itself.",<qiskit><programming>,11/06/2022 08:48,,,,
28849.0,How to create an arbitrary state for debugging purposes in the local computer?,Is there a way to create an arbitrary state in Q# just for debugging purposes in the local computer via the quantum full state simulator?,<q#><state-preparation>,11/06/2022 18:32,,,,
28854.0,Aray_to_latex not outputting anything in Jupyter Notebook,"Here is my basic code from qiskit import QuantumCircuit, execute, Aer, transpile, assemble from qiskit.visualization import plot_histogram, plot_bloch_multivector, array_to_latex from numpy.random import randint import numpy as np print(&quot;Imports Successful&quot;) def create_Entangled(qc): qc.h(0) #H-gate to the first qc.cx(0,1) #CNOT to the second display(qc.draw(output='mpl')) #Doublecheck that the bits are entangled through statevector backend = Aer.get_backend('statevector_simulator') job = execute(qc, backend=backend, shots=1, memory=True) job_result = job.result() final_state = job_result.get_statevector() array_to_latex(final_state, prefix=&quot;\\text{Statevector = }&quot;) print(final_state) qc = QuantumCircuit(2) create_Entangled(qc) I get the circuit drawn and I can see the &quot;print&quot; of the Statevector, but array_to_latex does not seem to produce anything!",<qiskit><programming>,11/06/2022 22:16,,,,
28957.0,Merge two Y**0.5 gate into a single Y gate,How can I merge two consecutive cirq.Y**0.5 gates into a single cirq.Y gate with a transformer? I can use cirq.merge_k_qubit_unitaries to merge the two gate but the result is not a cirq.EigenGate anymore. I want to keep the EigenGate type after the transformation.,<programming><cirq>,11/11/2022 09:07,,,,
29113.0,How to rewrite this Cirq problem into Qiskit?,"I have a following example problem in Cirq, representing a very simple operator given by $$ \hat{H} = a^\dagger_0a_2 + a_0a^\dagger_1 + 0.9\, a^\dagger_0a_1a^\dagger_2a^\dagger_3 + a^\dagger_0a_1a_2a_3 $$ and an example ansatz, obtaining the expectation value in the end. import cirq import numpy as np import openfermion as of import sympy H = of.FermionOperator('0^ 2', 1) + of.FermionOperator('0 1^', 1) + of.FermionOperator('0^ 1 2^ 3^', 0.9) \ + of.FermionOperator('0^ 1 2 3', -0.1) H = of.FermionOperator('0^ 1', 1) + of.FermionOperator('0 2^', 1) + of.FermionOperator('0^ 2 1^ 3^', 0.9) \ + of.FermionOperator('0^ 2 1 3', -0.1) Hmat = of.get_sparse_operator(H, n_qubits=4).A print(H) print(sorted(np.linalg.eig(Hmat)[0])) circuit = cirq.Circuit() qubits = cirq.LineQubit.range(4) alpha = sympy.Symbol('alpha') beta = sympy.Symbol('beta') gamma = sympy.Symbol('gamma') delta = sympy.Symbol('delta') circuit.append(cirq.ry(alpha).on(qubits[0])) circuit.append(cirq.ry(beta).on(qubits[1])) circuit.append(cirq.ry(gamma).on(qubits[2])) circuit.append(cirq.ry(delta).on(qubits[3])) circuit.append(cirq.X(qubits[2]).controlled_by(qubits[0])) full_circ = cirq.resolve_parameters(circuit, {'alpha': 1, 'beta': 1, 'gamma': 1, 'delta': 1}) sv = full_circ.final_state_vector() print(sv) print(sv.conj().T @ Hmat @ sv) This Cirq code is giving the following output: 1.0 [0 2^] + 1 [0^ 1] + -0.1 [0^ 2 1 3] + 0.9 [0^ 2 1^ 3^] [(-0.547722557505166+5.551115123125783e-17j), (-7.994927024450326e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)] [0.5931328 +0.j 0.32402992+0.j 0.32402992+0.j 0.17701835+0.j 0.32402992+0.j 0.17701835+0.j 0.17701835+0.j 0.09670557+0.j 0.17701835+0.j 0.09670557+0.j 0.32402992+0.j 0.17701835+0.j 0.09670557+0.j 0.05283049+0.j 0.17701835+0.j 0.09670557+0.j] (0.11040049624731614+0j) I'd like to be able to rewrite this example into an equivalent code in Qiskit, where, as I'm aware is a different spin-orbital mapping, so that I switched 1st and 2nd qubits in ansatz. The code looks like this: from qiskit import QuantumCircuit from qiskit.circuit import ParameterVector from qiskit.quantum_info import Statevector from qiskit_nature.operators.second_quantization import FermionicOp import numpy as np H = FermionicOp([('+_0 -_2', 1), ('-_0 +_1', 1), ('+_0 -_1 +_2 +_3', 0.9), ('+_0 -_1 -_2 -_3', -0.1)], register_length=4) print(H) print(sorted(np.linalg.eig(H.to_matrix().A)[0])) ansatz = QuantumCircuit(4) p = ParameterVector('theta', length=4) for i, q in enumerate(ansatz.qubits): ansatz.ry(p[i], q) ansatz.cx(0, 1) params = [1]*4 vecA = Statevector(ansatz.bind_parameters(params)).data print(vecA) print((vecA.conj().T @ H.to_matrix() @ vecA).real) But the output is different: Fermionic Operator register length=4, number terms=4 (1+0j) * ( +_0 -_2 ) + (1+0j) * ( -_0 +_1 ) + (0.9+0j) * ( +_0 -_1 +_2 +_3 ) + (-0.1+0j) * ( +_0 -_1 -_2 -_3 ) [(-0.547722557505166+5.551115123125783e-17j), (-7.997636868137208e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)] [0.5931328 +0.j 0.17701835+0.j 0.32402992+0.j 0.32402992+0.j 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j 0.17701835+0.j 0.05283049+0.j 0.09670557+0.j 0.09670557+0.j] -0.02401568533842704 Why are the expectation values different? Is the operator rewritten in an incorrect way or does the ansatz need different treatment, when rewritten to Qiskit?",<qiskit><programming><cirq><openfermion>,11/24/2022 2:12,,,,
29132.0,In what state is this 3-qubit state?,"So, I have a state of three qubits that is in one of the states below, with $\omega=e^{i\frac{2\pi}{3}}$: $$|\psi_0\rangle=\frac{1}{\sqrt 3}(|100\rangle+\omega^2|010\rangle+\omega|001\rangle),$$ $$|\psi_1\rangle=\frac{1}{\sqrt 3}(|100\rangle+\omega|010\rangle+\omega^2|001\rangle).$$ I tried to measure the qubits but the amplitudes are $1/3$ for each, so...",<programming><quantum-state>,11/25/2022 12:33,,,,
29139.0,How representative are Pauli errors of the complete set of errors that can occur on a quantum computer?,We know that Pauli errors (=channels?) can be simulated efficiently on a classical computer. How representative are Pauli errors of the complete set of errors that can occur on a quantum computer? Is this a pure representation convenience issue or is the Pauli error assumption hiding something?,<programming><hardware>,11/25/2022 18:51,,,,
29217.0,Pulse noisy simulation using Fake Jakarta (Qiskit),"I'm trying to use FakeJakarta from Qiskit to run the PulseObj for noisy simulation but I get error when I run the pulseobj in the noisy backend. It would be great if someone can provide an example to execute the pulseobj using Fake backend in Qiskit. from qiskit.providers.aer.noise import NoiseModel from qiskit import IBMQ, transpile from qiskit import QuantumCircuit from qiskit.providers.aer import AerSimulator from qiskit.tools.visualization import plot_histogram from qiskit.providers.fake_provider import FakeJakarta from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit from numpy import pi device_backend = FakeJakarta() simulator = Aer.get_backend('qasm_simulator') sim_jakarta = AerSimulator.from_backend(device_backend) backend = 'ibmq_jakarta' provider = IBMQ.load_account() devise = provider.get_backend(backend) noise_model = NoiseModel.from_backend(devise) coupling_map = devise.configuration().coupling_map basis_gates = noise_model.basis_gates qreg_cin = QuantumRegister(1, 'cin') qreg_a = QuantumRegister(1, 'a') qreg_b = QuantumRegister(1, 'b') qreg_cout = QuantumRegister(1, 'cout') creg_c = ClassicalRegister(2, 'c') original_circ = QuantumCircuit(qreg_cin, qreg_a, qreg_b, qreg_cout, creg_c) # set input states original_circ.x(qreg_a[0]) original_circ.x(qreg_b[0]) original_circ.cx(qreg_a[0], qreg_b[0]) original_circ.cx(qreg_a[0], qreg_cin[0]) original_circ.ccx(qreg_cin[0], qreg_b[0], qreg_a[0]) original_circ.cx(qreg_a[0], qreg_cout[0]) original_circ.ccx(qreg_cin[0], qreg_b[0], qreg_a[0]) original_circ.cx(qreg_a[0], qreg_cin[0]) original_circ.cx(qreg_cin[0], qreg_b[0]) original_circ.measure(qreg_b[0], creg_c[0]) original_circ.measure(qreg_cout[0], creg_c[1]) original_circ.draw(output='mpl',idle_wires=False, fold=-1) trans_circ = transpile(original_circ,backend=devise,optimization_level = 3) trans_circ_gate =trans_circ trans_circ.draw(output='mpl',idle_wires=False, fold=-1) sched_circ = schedule(trans_circ,backend=devise) sched_circ.instructions sched_circ.draw() result = sim_jakarta.run(sched_circ).result() Traceback: --------------------------------------------------------------------------- QiskitError Traceback (most recent call last) &lt;ipython-input-11-6ae2d75da147&gt; in &lt;module&gt; ----&gt; 1 result = sim_jakarta.run(sched_circ).result() ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/utils/deprecation.py in wrapper(*args, **kwargs) 26 if kwargs: 27 _rename_kwargs(func.__name__, kwargs, kwarg_map, category) ---&gt; 28 return func(*args, **kwargs) 29 30 return wrapper ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_aer/backends/aerbackend.py in run(self, circuits, validate, parameter_binds, **run_options) 185 qobj = self._assemble(circuits, **run_options) 186 else: --&gt; 187 qobj = self._assemble(circuits, parameter_binds=parameter_binds, **run_options) 188 189 # Optional validation ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_aer/backends/aerbackend.py in _assemble(self, circuits, parameter_binds, **run_options) 398 qobj = qobj_tmp 399 else: --&gt; 400 qobj = assemble(circuits, backend=self) 401 402 # Add optypes to qobj ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/compiler/assembler.py in assemble(experiments, backend, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, qubit_lo_freq, meas_lo_freq, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, meas_map, memory_slot_size, rep_time, rep_delay, parameter_binds, parametric_pulses, init_qubits, **run_config) 227 end_time = time() 228 _log_assembly_time(start_time, end_time) --&gt; 229 return assemble_schedules( 230 schedules=experiments, qobj_id=qobj_id, qobj_header=qobj_header, run_config=run_config 231 ) ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/assembler/assemble_schedules.py in assemble_schedules(schedules, qobj_id, qobj_header, run_config) 53 &quot;&quot;&quot; 54 if not hasattr(run_config, &quot;qubit_lo_freq&quot;): ---&gt; 55 raise QiskitError(&quot;qubit_lo_freq must be supplied.&quot;) 56 if not hasattr(run_config, &quot;meas_lo_freq&quot;): 57 raise QiskitError(&quot;meas_lo_freq must be supplied.&quot;) QiskitError: 'qubit_lo_freq must be supplied.' ```",<qiskit><programming>,12/02/2022 15:15,,,,
29230.0,Error in Implementing Quantum SVM,"I am getting Type error of invalid parameter in base sampler module. From what I know sampler is constructor and doesn't take any parameter values, on the qisit.org tutorial of svm they have even said it gets constructed by default. here is my code : import pandas as pd import matplotlib.pyplot as plt import numpy as np from sklearn.svm import SVC from sklearn.model_selection import train_test_split from qiskit import Aer from qiskit.circuit.library import ZZFeatureMap from qiskit_machine_learning.kernels import FidelityQuantumKernel from qiskit.algorithms.state_fidelities import ComputeUncompute from qiskit.primitives import Sampler from qiskit.utils import QuantumInstance from qiskit_machine_learning.algorithms import QSVC data=pd.read_csv('train.csv') X = data.loc[1:1000,[&quot;marital&quot;,&quot;balance&quot;,&quot;loan&quot;]].values Y = data.iloc[:1000,-1].values for i in range(0,1000): if Y[i]=='yes': Y[i]='1' else: Y[i]='0' x_train, x_test, y_train, y_test = train_test_split(X, Y) data_feature_map = ZZFeatureMap(feature_dimension=3, reps=2,entanglement='linear' ) sampler = Sampler() fidelity = ComputeUncompute(sampler=sampler) data_kernel = FidelityQuantumKernel(feature_map=data_feature_map,fidelity=fidelity) qsvc = QSVC(quantum_kernel=data_kernel) qsvc.fit(x_train, y_train) qsvc_score = QSVC.score(x_test, y_test) print(f&quot;Callable kernel classification test score: {qsvc_score}&quot;) and here is my error : File &quot;C:\Users\Dell\Desktop\SEM Project\qsvm.py&quot;, line 30, in &lt;module&gt; qsvc.fit(x_train, y_train) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 251, in fit fit(X, y, sample_weight, solver_type, kernel, random_seed=seed) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 314, in _dense_fit X = self._compute_kernel(X) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 512, in _compute_kernel kernel = self.kernel(X, self.__Xfit) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 121, in evaluate kernel_matrix = self._get_symmetric_kernel_matrix( File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 212, in _get_symmetric_kernel_matrix kernel_entries = self._get_kernel_entries(left_parameters, right_parameters) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 234, in _get_kernel_entries kernel_entries = np.real(job.result().fidelities) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\primitive_job.py&quot;, line 50, in result return self._future.result() File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 439, in result return self.__get_result() File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result raise self._exception File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\thread.py&quot;, line 58, in run result = self.fn(*self.args, **self.kwargs) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py&quot;, line 141, in _run job = self._sampler.run(circuits=circuits, parameter_values=values, **opts.__dict__) File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_sampler.py&quot;, line 172, in run parameter_values = self._validate_parameter_values( File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_primitive.py&quot;, line 108, in _validate_parameter_values raise TypeError(&quot;Invalid parameter values, expected Sequence[Sequence[float]].&quot;) TypeError: Invalid parameter values, expected Sequence[Sequence[float]].",<qiskit><programming><machine-learning>,12/04/2022 05:48,,,,
29238.0,Applying a clock in quantum computing?,"In quantum computing, I feel it mostly looks like designing hardware with Hardware Description Language (HDL) experience such as VHDL or Verilog. So the term program language for quantum computing such as QASM (Quantum Assembly) I prefer say it as Quantum HDL than QASM. In assembly, everything is sequential processing. While HDL may faster than assembly due to able processing data using combinational logic instead of sequential logic. Clock is basic of sequential computing. The most basic program of sequential computing is binary counter which count binary number from $0$ to $2^{n_{bit}}-1$ every time unit. So how do you implement binary counter in quantum computing? Will you just put all qubits with hadamard gate as an input as a replace binary counter? If so, then the data will not processed sequentially from $0$ to $2^{n_{bit}}-1$ because every shot of experiment the result maybe random hence result I will see is just probability diagram.",<classical-computing>,12/04/2022 14:51,,,,
29258.0,How many elements could a 64 qubit quantum computer hold hypothetically compared to a 32 qubit computer?,"I understand that for standard bits the difference between a 64 bit memory and a 32 bit memory is 2^64 divided by 2^32. This means that with 64 bits we can access approximately 4294967296 or about four billion times the physical memory than with 32 bits. Now I am wondering what the difference is for quantum computers, if theres is any. Can you explain this to me please? Thank you!",<programming>,12/06/2022 03:29,,,,
29302.0,Is there a method in pyQuil to create logical boolean gates,"is there another way to represent a boolean gate. The straight forward way would be to define a gate my a matrix and then apply this gate to the circuit. What i mean by that? For Example an AND-Gate is nothing Else then a CCX-Gate. So we want Qubit1 AND Qubit2 and store the result in Qubit3. Now instead of applying the AND gate on two qubits i want to apply it on multiply qubits. Now we could do it like mentioned above just defining the matrix for a Boolean Expression and then adding it to a cricuit but is there a different way to do it? For Example Qiskit supports a feature which is exactly that. TKet does also support a similar feature the &quot;ToffoliBox&quot; where one could create Boolean Gates by defining permutations. And finally Cirq also supports something similar i guess, its called the BooleanHamiltonianGate (i never tried it). So i wonder if pyquil support something like the other features.",<programming><cirq><compiling><pyquil>,12/08/2022 17:48,,,,
29336.0,How to write an entangled state in Strawberry Fields Quantum Computing Python Package?,In Strawberry Fields's own internet site they explain many kinds of states mathematically and then show how to implement the state in Python. Unfortunately I could not find how to implement a multi-mode state (e.g. $|0\rangle|1\rangle$).,<programming><strawberryfields>,12/12/2022 13:10,,,,
29347.0,Which method does pyQuil use to compile a Program?,I want to find out which method different compilers use to decompose a matrix into smaller gates. I went through the pyQuil code on github but could not find the answer there. Maybe i lost track of something. I would by highly interested in the methods used by PyQuil.,<programming><compiling><pyquil>,12/13/2022 11:39,,,,
29515.0,Generating and executing large Pauli rotations in Python,"I am interested in generating collective Pauli X, Y and Z spin operators for the purpose of rotating $2^N$ dimensional state vectors $|\psi\rangle$ (in the computational basis) for a quantum protocol. To this end I need to generate large Pauli operators of the form \begin{align} \hat{J_{x}}:= \frac{1}{2}\sum_{i=1}^{N}\hat{\sigma}_{i}^{x}, \end{align} where $\hat{\sigma}_{i}^{x}$ denotes the Pauli-X operator acting on the $i$-th qubit. These collective operators are used for exponential matrix rotations of the form $\text{exp}\big(-i \theta \hat{J}_{x}\big)|\psi\rangle$. I am able to do this with Numpy: from numpy import * import numpy as np import math from sympy.physics.quantum import TensorProduct from scipy.linalg import expm # Set System Size N = 4 # Pauli spin operators I = np.identity(2) px = array([[0, 1], [1, 0]]) px = mat(px) # Define initial spin up state as column vector S. S = zeros((2**N, 1), dtype=np.complex_) S[0, 0] = 1.0 S = mat(S) # Defining collective spin X rotation operator lists1 = [[] for _ in range(N)] # List used for calculating the exponential factor of exponential matrix. for i in range(N): for j in range(N): if i == j: lists1[i].append(px) else: lists1[i].append(I) # lists of tensor product exponential factors for collective spin X operator. tenex = [] for i in range(N): tens = TensorProduct(*lists1[i]) tenex.append(tens) Jx = (1/2)*np.sum(tenex, 0) Jx = mat(Jx) # Rotation of state vector using the collective rotation. S = expm((-1j*math.pi/2.)*Jx)*S print(Jx) print(S) But for large N this becomes inefficient. To this end I am looking at the Qutip library. Can anyone advise on how to generate the collective operators $\{\hat{J}_x, \hat{J}_{y}, \hat{J}_z\}$ and convert them to NumPy arrays, or alternatively can I apply the rotations using the Qutip module directly to an arbitrary state vector NumPy array and then convert the final state to a NumPy state vector? Lastly, is there maybe a different more efficient way of defining and executing these large collective rotations (maybe using sparse matrices)? Thanks for any assistance.",<pauli-gates><linear-algebra><qutip><programming>,12/31/2022 11:24,,,,
29722.0,Creating a gate which have multiple register as an input,"I'm trying to create a new gate in qiskit which the input is multiple register but the program output an error that says: 'The amount of qubit(1)/clbit(0) arguments does not match the gate expectation (13).' here is my code : def adder(): x=QuantumRegister(n) y=QuantumRegister(n+1) A=QuantumRegister(n) qc=QuantumCircuit(x,y,A) for i in range(n-1): qc.append(carry(),[A[i],x[i],y[i],A[i+1]]) qc.append(carry(),[A[n-1],x[n-1],y[n-1],y[n]]) qc.cx(x[n-1],y[n-1]) qc.append(circ_sum(),[A[n-1],x[n-1],y[n-1]]) for i in range(n-2,-1,-1): qc.append(invcarry(),[A[i],x[i],y[i],A[i+1]]) qc.append(circ_sum(),[A[i],x[i],y[i]]) qc=qc.to_gate() qc.name = &quot;adder&quot; return qc this is where I try to called the gate but resulting an error : x=QuantumRegister(n,'x') y=QuantumRegister(n+1,'y') A=QuantumRegister(n,'dump') nqc=QuantumCircuit(x,y,A) nqc.append(adder(),[x[:]+y[:]+A[:]]) I have count the number of qubit it's exactly same, can someone point out why it's giving me this error? and how to fix it",<qiskit><programming><quantum-operation>,1/17/2023 2:30,,,,
29921.0,"How to write a 9 qubit correction code using only python, without qiskit library or others","How can we compute a 9 qubit correction code using python, without qiskit library or others?",<programming>,1/28/2023 18:40,,,,
29990.0,Operating Hamiltonian on discrete variable state,"I have a hamiltonian consisting of combinations of a and a(dragger). i need to act this on discrete variable state like |0,0,0,1&gt; and so on. Is there any library to do these kinds of operations?",<quantum-state><qutip><programming><hamiltonian>,02/02/2023 11:02,,,,
29992.0,Using stim.TableauSimulator with python multiprocessing,I am trying to run some Monte-Carlo simulations whereby I have to call the TableauSimulator N times and use the measurement results to get an average. Is there any way to parallelise this loop? I am getting this sort of error: TypeError: cannot pickle 'stim._stim_sse2.TableauSimulator' object Much appreciated.,<stim><programming>,02/02/2023 12:26,,,,
30060.0,Error while installing Qiskit version 0.22.0,"I am getting following error while I write: pip3 install qiskit==0.22.0 in the terminal. note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed cleaning build dir for qiskit-aer Building wheel for qiskit-terra (pyproject.toml) ... error error: subprocess-exited-with-error Ã Building wheel for qiskit-terra (pyproject.toml) did not run successfully. â exit code: 1 â°â&gt; [814 lines of output] running bdist_wheel running build running build_py creating build creating build/lib.macosx-10.9-universal2-cpython-39 creating build/lib.macosx-10.9-universal2-cpython-39/qiskit . . . error: 'Python.h' file not found #include &quot;Python.h&quot; ^~~~~~~~~~ 1 error generated. error: command '/usr/bin/clang' failed with exit code 1 [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for qiskit-terra Failed to build qiskit-aer qiskit-terra ERROR: Could not build wheels for qiskit-terra, which is required to install pyproject.toml-based projects",<qiskit><programming>,02/06/2023 11:17,,,,
30198.0,"Did Feyman cite Yuri Manin in his paper ""Simulating Physics with Computers""?","In Feymanâs paper &quot;Simulating Physics with Computers&quot;, did he cite Yuri Manin as the idea of a quantum automaton that used superposition and entanglementÂ was mentioned in his book a year before?",<programming><quantum-algorithms><history>,2/13/2023 15:26,,,,
30286.0,Do I need a lab in order to test new ideas in designing quantum circuits,I would like to know how to test new ideas certainly on a circuit level. Do I require a lab? if so where can I find one I live in Houston. Does nt quantum eliminate the necessity of a lab and can I use this fact to create a virtual lab? Much appreciated for the help,<quantum-gate><programming><quantum-algorithms>,2/20/2023 3:18,,,,
31891.0,Is amplitude encoding a form of performing QRAM?,I'm still confused about what a QRAM should be. Is amplitude encoding a form of performing QRAM? Or are they related in a way ? What is today's state of the art about QRAM ?,<programming><quantum-state>,3/29/2023 10:03,,,,
31963.0,"What is reservoir computing in simple terms, and how can it be used with quantum computing?","For those who are familiar with the notion of Reservoir Computing, can you explain the concept with simple terms and how it can be used with quantum computing ?",<quantum-algorithms><classical-computing><computational-models>,04/03/2023 09:19,,,,
31999.0,Deutsch-Jozsa Algorithm - classical solution,"so I'm self-studying quantum computing and have a question about the proposed classical solution to the Deustch-Jozsa problem. So given your function $f: \{0,1\}^n \rightarrow \{0,1\}$ say you were to define a linear map $F: \mathbb C(\{0,1\}^n) \cong \mathbb C^{2n} \rightarrow \mathbb C$ by sending $x \mapsto (-1)^{f(x)}$. Now the oracle you use for the classical solution is an oracle for $F$ which is derived from your oracle for $f$. It only takes 1 call to this oracle to determine if $f$ is balanced or constant, using a similar argument to the quantum case. My question is why isn't this a valid classical solution? To me, when you implement a quantum oracle for $f$ you're basically doing the same thing I am doing here when constructing $F$ - i.e. you put all the 'magic' into this new oracle and hide it using the black box, and then claim the number of calls to this new oracle only needs to be one. Which is true basically by design of the oracle. But that seems like cheating to me and I can't see why the example I gave is any different to the quantum solution and so I don't see why the quantum case gives a speed up. Edit: Changed the definition of $F$ from $x \mapsto (-1)^{f(x)} x$. Edit 2: From discussions in the comments I think I can clarify my issue more coherently and without reference to Deutsch-Jozsa. I think it comes down to, from a complexity perspective, why it's valid to compare a classical solution to a quantum solution with them both using different oracles. To me this comparison isn't useful because we have to use different oracles and since it cannot be made in the real world the idea that one is faster than the other has no meaning.",<classical-computing><oracles><deutsch-jozsa-algorithm>,04/05/2023 14:51,,,,
32001.0,Any good software for fermionic operator algebra manipulation?,"Suppose I have some ground state $a^\dagger_{k_1,\sigma_1}a^\dagger_{k_2,\sigma_2}a^\dagger_{k_3,\sigma_3}|\emptyset\rangle$ where $|\emptyset\rangle$ is the vacuum, $k_i$ is some quantum number and $\sigma_i$ are the spins. Now suppose I want to calculate, for example something like this $$\langle A|\sum_{\sigma\sigma'\lambda\lambda'}\sum_{kk'p'p'qq' rr'}a^\dagger_{p\lambda}a^\dagger_{p'\lambda'}a_{q'\lambda'}a_{q'\lambda}a^\dagger_{q\sigma}a^\dagger_{q'\sigma'}a_{k'\sigma'}a_{k\sigma}|A\rangle$$ Clearly there are many ways to simplify this equation. What would be the best software (Mathematica or Python based) to ALGEBRAICALLY do so? If not how could I code something to simplify such an expression.",<programming><linear-algebra>,04/05/2023 17:03,,,,
32109.0,Do not understand error in if-else section,"I have tried to build a circuit for encryption. One function is: def selector(qc, a, b, c): qc.measure(a, 0) if a == 1: qc.cswap(a, b, c) else: qc.id(b) qc.id(c) When I run it in IBM quantum lab, only the else option appears to be working. Why is my a == 1 case never taking place?",<ibm-q-experience><programming>,4/13/2023 12:53,,,,
32194.0,Extracting a QUBO matrix from pyqubo,"I am benchmarking different QUBO solvers for a very simple instance of the knapsack problem. Some of these solvers require the matrix, Q, and offset, b, from the equation: $$ \begin{equation} x^{\top}Qx + b \end{equation} $$ I use pyqubo to construct the problem as a QUBO and solve it which returns the optimal solution. I then attempt to extract the qubo matrix and offset by doing: model = QUBO_equation.compile() qubo, offset = model.to_qubo() and convert the dictionary qubo into a numpy array. However, when I import this numpy array to other solvers, I get very different and wrong results. Manually comparing the different solutions by using the equation above, I see that these solutions I see that these wrong solutions have lower minimum energy than the correct optimal solution. (Note: I reformulated the knapsack problem to a minimisation problem) Is this the correct way to extract the QUBO matrix and if so why does the optimal solution that pyqubo returns not correspond to the minimum energy state of the QUBO matrix equation. EDIT - More code showing how the Q matrix is constructed as a numpy array: Q_matrix = np.zeros(shape = (len(binary_variables) + num_slack_bits, len(binary_variables) + num_slack_bits)) for i in range(len(binary_variables) + num_slack_bits): for j in range(len(binary_variables) + num_slack_bits): try: Q_matrix[i][j] = qubo[(&quot;x&quot;+str(i),&quot;x&quot;+str(j))] Q_matrix[j][i] = qubo[(&quot;x&quot;+str(i),&quot;x&quot;+str(j))] except KeyError: pass This creates a square symmetric matrix which is required for the other solvers.",<optimization><annealing><programming><qubo><pyqubo>,4/18/2023 11:27,,,,
32519.0,Shor's algorithm in Python with qiskit - How to implement the modular exponentiation step?,"I found this code for Shor's algorithm but it always was failing at the end of the modular_exponentiation routine because the keyvalue of '00000' was not found in the dictionary on the call to b_measure = result.get_counts()[format(i, '0{}b'.format(n+1))[-(n+1):]] Here is the original code in its entirety: from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer, execute # Function to perform modular exponentiation def modular_exponentiation(a, x, N): &quot;&quot;&quot;Calculate a^x mod N&quot;&quot;&quot; n = N.bit_length() qr = QuantumRegister(n + 1) cr = ClassicalRegister(n + 1) circuit = QuantumCircuit(qr, cr) for i in range(n): circuit.initialize([1, 0], qr[i]) circuit.initialize([1, 0], qr[n]) for i in range(n): if (x &gt;&gt; i) &amp; 1: circuit.cx(qr[n], qr[i]) for i in range(n): circuit.x(qr[i]) for i in range(2 ** n): b = bin(a * i % N)[2:].zfill(n) for j in range(n): if b[j] == '1': circuit.cx(qr[j], qr[n]) circuit.barrier() for j in range(n): circuit.measure(qr[j], cr[j]) circuit.measure(qr[n], cr[n]) backend = Aer.get_backend('qasm_simulator') result = execute(circuit, backend, shots=1).result() b_measure = result.get_counts()[format(i, '0{}b'.format(n))] for j in range(n): if b_measure[j] == '1': circuit.x(qr[j]) return circuit # Function to perform Shor's algorithm def shor(N): &quot;&quot;&quot;Find the factors of N using Shor's algorithm&quot;&quot;&quot; n = N.bit_length() M = 2 ** n t = 0 while M ** (t / 2) &lt; 2 * n ** 2: t += 1 a = 2 for i in range(t): a = pow(a, M // 2, N) if a == 0: return 0 if a == -1: a = N - 1 period = None while period is None: circuit = modular_exponentiation(a, 2 ** t, N) backend = Aer.get_backend('qasm_simulator') result = execute(circuit, backend, shots=1).result() for key, value in result.get_counts().items(): if value &gt; 0: x = int(key, 2) period = x // 2 ** (n - t) break factor1 = pow(a, period // 2, N) - 1 factor2 = pow(a, period // 2, N) + 1 return (factor1, factor2) # Example usage N = 15 factors = shor(N) print(&quot;Factors of&quot;, N, &quot;are&quot;, factors) I am doing this to learn, so I am not quantum computing expert. I made changes to roughly the last ten lines of modular_exponentiation routine to eliminate the runtime errors as best as I could infer that it should work. My changed code for the end of modular_exponentiation routine is as follows. This runs, the results are consistent between runs, but the results are wrong. For example, I tried a known prime of 419. The program says the factors are (335, 337). I tried increasing the number of shots to 10, but this does not seem to have any effect on the results. Other values of N, such as composite numbers, also get results that are not correct. Thanks in advance for any advice. circuit.measure(qr[n], cr[n]) backend = Aer.get_backend('qasm_simulator') result = execute(circuit, backend, shots=10).result() #print(&quot;n = &quot;, n) tempkey = format(i, '0{}b'.format(n+1))[-(n+1):] #print(&quot;two = &quot;, tempkey) if tempkey in result.get_counts(): b_measure = result.get_counts()[tempkey] for j in range(n): #print(&quot;b_measure, j = &quot;, b_measure, j) if tempkey[j] == '1': #if b_measure[j] == '1': circuit.x(qr[j]) else: b_measure = 0 return circuit",<qiskit><shors-algorithm><programming><modular-exponentiation>,05/10/2023 07:39,,,,
32613.0,How to add noise mode in Sampler (SamplerQNN) in qiskit for quantum neural network?,"I would like to add a noise model to one of the tutorial examples of quantum machine learning in the Qiskit site (PyTorch QGAN implementation). I used the following codes sampler_n = AerSampler() sampler_n.set_options(noise_model=noise_model) instead of sampler = Sampler(options={ &quot;shots&quot;: shots, &quot;seed&quot;: algorithm_globals.random_seed}) Whenever the quantum circuit is well-defined (does not have any parameters), such as weights_n = algorithm_globals.random.random(qc_zofal.num_parameters) def create_generator() -&gt; TorchConnector: p = qc_zofal.assign_parameters(weights_n) qnn = SamplerQNN( sampler = sampler_n, circuit= p, input_params=[], weight_params=p.parameters, sparse=False, ) return TorchConnector(qnn, []) generator_n = create_generator() print(generator_n) print(generator_n(torch.tensor([])).reshape(-1,1)) print(generator.parameters) Everything is ok. But if I put a parametric circuit in it, I encounter the following error: WARNING:qiskit_aer.backends.aerbackend:Simulation failed and returned the following error message: ERROR: Failed to load circuits: Invalid parameterized qobj: instruction param position out of range --------------------------------------------------------------------------- IndexError Traceback (most recent call last) /usr/local/lib/python3.10/dist-packages/qiskit/result/result.py in _get_experiment(self, key) 367 try: --&gt; 368 exp = self.results[key] 369 except IndexError as ex: IndexError: list index out of range The above exception was the direct cause of the following exception: QiskitError Traceback (most recent call last) 14 frames QiskitError: 'Result for experiment &quot;0&quot; could not be found.' The above exception was the direct cause of the following exception: QiskitMachineLearningError Traceback (most recent call last) /usr/local/lib/python3.10/dist-packages/qiskit_machine_learning/neural_networks/sampler_qnn.py in _forward(self, input_data, weights) 360 results = job.result() 361 except Exception as exc: --&gt; 362 raise QiskitMachineLearningError(&quot;Sampler job failed.&quot;) from exc 363 result = self._postprocess(num_samples, results) 364 QiskitMachineLearningError: 'Sampler job failed.' Could you please help me How can I fix this error? And my next question is: How can I access the QNN parameters after each training from pytorchconnector?",<qiskit><quantum-gate><programming><quantum-algorithms><quantum-neural-network>,5/17/2023 12:22,,,,
32719.0,"python code to approximate an arbitrary 2*2 unitary matrix with gates H,T and Z","I'm new to programming, tried different options, compiled programs myself, took them from websites, but they didn't work, for example, the program: import numpy as np from qiskit import QuantumCircuit from qiskit.extensions import HGate, TGate, SGate from qiskit.quantum_info import Operator from qiskit.compiler import transpile from qiskit.transpiler.passes import Unroller from qiskit.visualization import plot_histogram from qiskit import Aer # Ð²ÐµÐ½ÑÐ¸Ð»Ñ, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð½ÑÐ¶Ð½Ð¾ ÑÐ°Ð·Ð»Ð¾Ð¶Ð¸ÑÑ matrix = np.array([[1, 1j], [1j, 1]]) / np.sqrt(2) my_gate = Operator(matrix) # ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ñ Ð´Ð²ÑÑ ÐºÐ²Ð°Ð½ÑÐ¾Ð²ÑÑ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¹ def are_operators_close(op1, op2, eps=1e-8): return np.allclose(op1, op2, rtol=0, atol=eps, equal_nan=False) # Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ Solovay-Kitaev Ð´Ð»Ñ ÑÐ°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð²ÐµÐ½ÑÐ¸Ð»Ñ Ð² Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ H, T, S def sk_decomposition(gate, eps=0.01, depth=3): # Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ ÐºÐ²Ð°Ð½ÑÐ¾Ð²Ð¾Ð¹ ÑÑ ÐµÐ¼Ñ circuit = QuantumCircuit(1) gates = [HGate(), TGate(), SGate()] # Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼Ð° Solovay-Kitaev for d in range(depth): for gate in gates: for sign in [1, -1]: theta = sign * np.arccos(1 - 2 * eps) circuit.rz(theta, 0) circuit.append(gate, [0]) circuit.rz(-theta, 0) eps = eps / 2 # Ð¸Ð·Ð²Ð»ÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾ÑÑÐ¸ Ð²ÐµÐ½ÑÐ¸Ð»ÐµÐ¹ Ð¸Ð· ÑÐ°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð½Ð¾Ð¹ Ð¼Ð°ÑÑÐ¸ÑÑ backend = Aer.get_backend('statevector_simulator') decomposed_circuit = transpile(circuit, backend=backend, basis_gates=['u', 'h', 'cx', 'id']) decomposed_result = backend.run(decomposed_circuit).result() decomposed_state = decomposed_result.get_statevector() decomposed_matrix = np.outer(decomposed_state, np.conj(decomposed_state)) sequence = '' for gate in [HGate(), TGate(), SGate()]: if are_operators_close(decomposed_matrix, gate): sequence += '0' else: for i in range(3): decomp = np.linalg.matrix_power(gate.to_matrix(), i) if are_operators_close(decomposed_matrix, decomp): sequence += str(i) break # ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾ÑÑÐ¸ Ð¸Ð· ÑÐ¸ÑÑ Ð² Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ Ð¸Ð· Ð±ÑÐºÐ² H, T, S sequence_letters = ''.join(['HTS'[int(x)] for x in sequence]) return sequence_letters # Ð·Ð°Ð¿ÑÑÐº Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼Ð° Solovay-Kitaev Ð´Ð»Ñ Ð²ÐµÐ½ÑÐ¸Ð»Ñ my_gate sequence = sk_decomposition(my_gate) print(sequence) I get an error: ...,line 27, in sk_decomposition circuit.append(gate(), [0]) TypeError: 'module' object is not callable how to fix the program or where is there a working code with the Solovey-Kitaev algorithm?",<qiskit><programming>,5/25/2023 9:35,,,,
32858.0,Finding the number of Failure for Surface Code by using Pymatching (without STIM): ValueError: The shape of the syndrome vector z is not valid,"I run the surface code for distance-3 with 3 round. I am now trying to decode and find the number of failures. My error probability of 0.08. Here are my syndrome results: x_syndrome_1stround = [0, 0, 0, 1, 1, 1] x_syndrome_2ndround = [1, 1, 0, 1, 1, 1] x_syndrome_3rdround = [1, 1, 1, 0, 1, 0] z_syndrome_1stround = [1, 1, 0, 0, 1, 0] z_syndrome_2ndround = [1, 1, 1, 0, 1, 0] z_syndrome_3rdround = [1, 1, 1, 1, 0, 0] Here are the detector events: first_detector_xzstab = [1,1,0,0,0,0,0,0,1,0,0,0] # first 6 elements of the list corresponds detection event for the x stabilizers, the last 6 elements of the list corresponds detection event for the z stabilizers second_detector_xzstab = [0,0,1,1,0,1,0,0,0,1,1,0] The following matrices are the parity check matrix for the X and Z stabilizers: H_d3x = csr_matrix(np.array([ [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1] ])) H_d3z= csr_matrix(np.array([ [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1] ])) The result of measuring data qubits after the stabilizers is here: data_q_meas = np.array([0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0]) This is my function for calculating the error probabilities: import numpy as np from pymatching import matching H_d3x = np.array([ [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1] ]) x_syndrome_1stround = [0, 0, 0, 1, 1, 1] x_syndrome_2ndround = [1, 1, 0, 1, 1, 1] x_syndrome_3rdround = [1, 1, 1, 0, 1, 0] z_syndrome_1stround = [1, 1, 0, 0, 1, 0] z_syndrome_2ndround = [1, 1, 1, 0, 1, 0] z_syndrome_3rdround = [1, 1, 1, 1, 0, 0] actual_observables = np.array([0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0]) #here I am guessing that actual observables are the measurement results of the data qubits in the simulator observables = csc_matrix([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]) def surface_code_failures(error_rate, x_syndrome_rounds, z_syndrome_rounds): # Parity check matrix num_failures = 0 matching=Matching(H_d3x,weights=np.log((1-p)/p)) print(matching) for x_syndrome, z_syndrome in zip(x_syndrome_rounds, z_syndrome_rounds): # Calculate the total syndrome (X and Z syndromes combined) syndrome = np.concatenate((x_syndrome, z_syndrome)) #for i in range(syndrome.shape[0]): print(&quot;syndrome = &quot;,syndrome, syndrome.shape[0]) predicted = matching.decode(syndrome) print(&quot;predicted = &quot;,predicted) predicted_observables = observables@predicted % 2 #if not matching.decode(syndrome): #syndrome num_failures += not np.array_equal(predicted_observables, actual_observables) return num_failures # Error rate p = 0.08 # Combine syndromes for each round x_syndrome_rounds = [x_syndrome_1stround, x_syndrome_2ndround, x_syndrome_3rdround] z_syndrome_rounds = [z_syndrome_1stround, z_syndrome_2ndround, z_syndrome_3rdround] # Calculate the number of failures num_failures = surface_code_failures(p, x_syndrome_rounds, z_syndrome_rounds) print(&quot;Number of failures:&quot;, num_failures) And this is how I use the function: p = 0.08 # Combine syndromes for each round x_syndrome_rounds = [x_syndrome_1stround, x_syndrome_2ndround, x_syndrome_3rdround] z_syndrome_rounds = [z_syndrome_1stround, z_syndrome_2ndround, z_syndrome_3rdround] # Calculate the number of failures num_failures = surface_code_failures(p, x_syndrome_rounds, z_syndrome_rounds) print(&quot;Number of failures:&quot;, num_failures) I am having error in this line if not matching.decode(syndrome): #syndrome The error message is that: ValueError: The shape ((12,)) of the syndrome vector z is not valid. It(the program) probably did not like the dimensions, but I do not know what to give anymore. I thought I needed to give syndrome measurement results to decode the errors. Maybe I am doing wrong with syndromes? Does anyone can help me with the function?",<programming><surface-code><pymatching>,06/05/2023 06:28,,,,
32882.0,What is an initial state of a qubit in PennyLane?,"I just started trying to use the PennyLane Python package. It seems like the default.qubit device initializes each wire as an up-spin qubit. However, I am not certain and could not find information about this online. The documentation for PennyLane is a little bit unclear about the particulars (e.g. what state a default qubit is). Any suggestions of where to look to find information like this (or perhaps I am just missing it on the PennyLane site) would be greatly appreciated!",<quantum-state><pennylane><programming>,06/08/2023 03:24,,,,
32884.0,Implementing time evolution gate for density matrix in PennyLane circuit,"I am trying to create a circuit which time evolves a density matrix $\hat{\rho}$ with the parameterized Hamiltonian $$\hat{H}(\theta) = e^{(-i \sum_m \theta_m \Lambda_m)}\hat{H}_ce^{(i \sum_m \theta_m \Lambda_m)}$$ where $\hat{H}_c$ is some fixed Hamiltonian and the $\theta_m$ and $\Lambda_m$ represent the usual parameterization of $SU(N)$ with the generalized Gell-Mann matrices (a.k.a. generalized Pauli matrices). The ultimate goal is to perform an optimization w.r.t. the parameters. Hence, I would like a circuit which simply does $$e^{-i\tau \hat{H}(\theta)} \hat{\rho} e^{i\tau \hat{H}(\theta)}.$$ There are two problems. PennyLane functions like qml.prod and qml.sum return &quot;operators&quot; but not operators that work as gates when placed within a circuit. Hence, I am not sure how to properly define $\hat{H}(\theta)$ as a gate. There only seems to be qml.ApproxTimeEvolution() as a native function of PennyLane. But, I would like to implement exact time evolution. I feel like exact time evolution gates must exist since it is not computationally hard to time evolve my state of interest in usual python, QuTip, etc. Here is my code for computing $\hat{H}(\theta)$ as an &quot;operator&quot; that does not work as a gate. def constructTEO(H, thetas, wireList): U = qml.SpecialUnitary(thetas, wires = wireList) return qml.prod(U, H, qml.adjoint(U)) Ideally, I would be able to define $\hat{H}(\theta)$ and then run the following circuit @qml.qnode(devRho) def TE(H, tau, rho): qml.QubitDensityMatrix(rho, wires=wireList) qml.TimeEvolution(H, tau) return qml.state() where qml.TimeEvolution() is a (currently) fictitious function which implements a gate that exactly time evolves $\hat{\rho}$.",<pennylane><programming>,06/08/2023 09:23,,,,
33315.0,Tf.einsum vs matmul for computing density matrix from a set of Cholesky decomposed matrices,"I am trying to construct a density matrix of shape 256x256 from a set of T matrices. These T matrices are all Cholesky-decomposed matrices. But I am not sure if the code is right or my approach is right; one of the reasons is that when I change from tf.einsum to tf.matmul some error is raised. I am not very well used to use einsum, that is the main reason I am trying to change the following code: def density_matrix_from_T(tmatrix): &quot;&quot;&quot; Gets density matrices from T matrices and normalizes them. Args: tmatrix (`tf.Tensor`): A tensor (N, hilbert_size, hilbert_size) representing N valid T matrices. Returns: rho (`tf.Tensor`): A tensor of shape (N, hilbert_size, hilbert_size) representing N density matrices. &quot;&quot;&quot; T = tmatrix T_dagger = tf.transpose(T, perm=[0, 2, 1], conjugate=True) proper_dm = tf.matmul(T_dagger, T) all_traces = tf.linalg.trace(proper_dm) all_traces = tf.reshape(1 / all_traces, (-1, 1)) rho = tf.einsum(&quot;bij,bk-&gt;bij&quot;, proper_dm, all_traces) return rho where the T matrix came from: def clean_cholesky(img): &quot;&quot;&quot; Cleans an input matrix to make it the Cholesky decomposition matrix T Args: img (`tf.Tensor`): a tensor of shape (batch_size, hilbert_size, hilbert_size, 2) representing random outputs from a neural netowrk. The last dimension is for separating the real and imaginary part. Returns: T (`tf.Tensor`): a 3D tensor (N, hilbert_size, hilbert_size) representing N matrices used for Cholesky decomp. &quot;&quot;&quot; real = img[:, :, :, 0] imag = img[:, :, :, 1] diag_all = tf.linalg.diag_part(imag, k=0, padding_value=0) diags = tf.linalg.diag(diag_all) imag = imag - diags imag = tf.linalg.band_part(imag, -1, 0) real = tf.linalg.band_part(real, -1, 0) T = tf.complex(real, imag) return T When I use it like this, it works fine but when I compute Fidelity to compare the reconstructed density matrix with a given original matrix, it gives a very poor result (something like 0.01 when a good result is close to 1). Anyway, I believe the problem is with rho = tf.einsum(&quot;bij,bk-&gt;bij&quot;, proper_dm, all_traces) and then I tried to change it to rho = tf.matmul(proper_dm, all_traces) but it raises an error on incompatibility: InvalidArgumentError: Exception encountered when calling layer 'density_matrix_1' (type DensityMatrix). {{function_node __wrapped__BatchMatMulV2_device_/job:localhost/replica:0/task:0 device:CPU:0}} Matrix size-incompatible: In[0]: [1,256,256], In[1]: [1,1] [Op:BatchMatMulV2] Call arguments received by layer 'density_matrix_1' (type DensityMatrix): â¢ inputs=tf.Tensor(shape=(1, 256, 256, 2), dtype=float64) â¢ training=True The arguments bij, bk -&gt; bij are independent of the input size? I mean, does it matter if the input is a matrix of shape 5x5 or 459x459? Or it is just dependent on the shape of the array in the sense that if it is a 2D or 3D array? If I don't want (and I really don't want) to use tf.einsum how can I correctly change it to use matmul?",<density-matrix><programming>,07/07/2023 21:49,,,,
33381.0,Is there research on leveraging quantum computing in the theory component of classical SMT solvers?,"Satisfiability Modulo Theories (SMT) extends the concept of boolean satisfiability (SAT) by including theories such as arithmetic, arrays, bit vectors, and functions. In a typical SMT problem, a decision procedure based on a SAT solver handles the boolean structure of the formula, while a theory solver tackles the constraints specific to the given theory. In case of conflicts, the theory solver generates new conflict clauses which the decision procedure can use to refine its search. There is a significant amount of research on employing quantum algorithms to enhance the performance of SAT solvers. However, I'm intrigued by the idea of utilizing quantum computing in the theory component of classical SMT solvers. Has there been any exploration in this direction? Is it conceptually feasible to utilize quantum computing as a theory in an otherwise classical SMT? If so, could such a solver be advantageous for a certain class of problems? Any insights or references to relevant research would be greatly appreciated.",<classical-computing><research>,07/12/2023 08:20,,,,
33423.0,DumpRegister sometimes blank?,"I'm just getting into the baffling world of Quantum Computing so forgive me if this is straightforward... I'm using Microsoft's Q# simulator so I know I'm allowed to peek into the internals of a Qubit in the way hardware would not allow. Specifically using DumpRegister() to look into the Qubit state - however, I think that's not telling me anything about entanglement: If I CNOT two bits, the DumpRegister output is the same before as after, but the state machine must know about that relationship beyond just the current probabilities of values for the register If I MultiplyI two registers to a third, the DumpRegister output is entirely blank, it's not showing any Qubits at all Is there a way I can get a deeper snapshot view of the machine state? Why is it that MultiplyI causes the Qubits to be not reported at all by DumpRegister? Example code: operation CNot() : Unit { use reg=Qubit[2]; ApplyToEachCA(H,reg); DumpRegister((),reg); CNOT(reg[0],reg[1]); DumpRegister((),reg); ResetAll(reg); } operation Multiply() : Unit { use r1=Qubit[2]; use r2=Qubit[2]; use r3=Qubit[4]; ApplyToEachCA(H,r1); ApplyToEachCA(H,r2); for q in r3 { SetQubitState(Zero, q); } let le1=LittleEndian(r1); let le2=LittleEndian(r2); let le3=LittleEndian(r3); MultiplyI (le1,le2,le3); DumpRegister ((),r1); DumpRegister ((),r2); DumpRegister ((),r3); let m1=MeasureInteger (le1); let m2=MeasureInteger (le2); let m3=MeasureInteger (le3); Message($&quot;{m1} * {m2} = {m3}&quot;); ResetAll(r1); ResetAll(r2); ResetAll(r3); } CNot() produces 0.500000 + 0.000000 i for each value before and after - I can see DumpRegister() is just showing the probabilities of values in the register which I guess is the same before and after, but there's some other state it's not showing. DumpMachine() is no more informative. Multiply() produces an output like 3 * 2 = 6 but each DumpRegister() line only produces a blank line.",<entanglement><q#>,7/15/2023 10:05,,,,
33450.0,ImportError qiskit_ibm_runtime,When I try to import qiskit_ibm_runtime I get the following error: ImportError: cannot import name 'JSONDecodeError' from 'requests.exceptions' (C:\Users\hakan\anaconda3\lib\site-packages\requests\exceptions.py) How can I solve this,<qiskit><programming>,7/17/2023 13:52,,,,
33484.0,Converting Qubits to +-1/2 Spin System for Expectation Value Calculation,"I have a quantum system that consists of spin states with eigenvalues of +-1/2. However, in quantum computing, qubits are typically represented as states |0â© and |1â©. I want to calculate the expectation values of operators on this spin system using the given code: def find_expectation(op, psi): # Exact Exact = psi.adjoint().compose(op).compose(psi).eval().real # Sampled measurable_exp = StateFn(op, is_measurement=True).compose(psi) expectation = PauliExpectation().convert(measurable_exp) simulator = QasmSimulator() Sampled = CircuitSampler(simulator).convert(expectation).eval().real return (Exact, Sampled) How can I convert the spin states of my system to the qubit representation (|0â© and |1â©) so that I can use this code to calculate the expectation values correctly? (Or how can I convert my 0,1 system's results to spin system's results) Are there any specific transformations or considerations I need to take into account during the conversion process? I would greatly appreciate any insights or suggestions on how to approach this conversion and ensure accurate expectation value calculations in the context of this code. Thank you!",<qiskit><programming><quantum-state><measurement>,7/19/2023 12:26,,,,
33532.0,Does subtraction circuit have a class like full or half Carry adder circuit in qiskit? one subtraction circuit code-example in qiskit?,"I need a subtraction circuit to calculate Laplacian in edge processing, but I didn't find any class in qiskit.Do I have to write the code myself?",<qiskit><programming><quantum-algorithms><circuit-construction><quantum-circuit>,7/22/2023 7:12,,,,
33677.0,How to add a value of -1/2 on the amplitude of a quantum state?,"I have a quantum state which is in $ \cos(c*f(x) + \pi/4) |0\rangle + \sin(c*f(x) + \pi/4) |1\rangle$ by using bunch of RY gates. Now I want to measure the probability of getting the state at $|1\rangle$ , that I know will be: $ \sin^2(c*f(x) + \pi/4)$ but instead I want this state to be: $ \sin^2(c*f(x) + \pi/4) - 1/2$ What gate operation will add this to the amplitude of my quantum state?",<qiskit><quantum-gate><programming>,08/04/2023 08:06,,,,
33689.0,The Qiskit code's output doesn't seem to be what I expected,"from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer qreg = QuantumRegister(2) creg = ClassicalRegister(2) circuit = QuantumCircuit(qreg,creg) circuit.x(qreg[0]) #10 circuit.x(qreg[1]) #11 circuit.cx(qreg[0],qreg[1]) #? circuit.measure(qreg,creg) job = execute(circuit,Aer.get_backend('qasm_simulator'),shots=1024) counts = job.result().get_counts(circuit) print(counts) # CNOT gate: performs a NOT on the target whenever the control is in state 1. OUTPUT: {'01': 1024} MY EXPECTATION: {'10': 1024}",<qiskit><quantum-gate><programming><quantum-state><quantum-algorithms>,08/05/2023 14:08,,,,
33932.0,If Statement OpenQasm 2.0,"in the documentation for OpenQasm 2.0 it says one can use an if statement like so: if(c_reg==int) Quantum Operation. However, I would like to execute the following: if(creg ==int) measure qreg -&gt; creg; I get no compilation errors in IBM Quantum Computing Learning Lab and am currently using an OpenQasm2.0 string input. The string is then turned into a circuit using the following: QuantumCircuit.from_qasm_str(program_str) and executed on the 'qasm_simlulator' backend using this command: execute(circuit,runtime_backend, shots=1024). The problem I seem to have is that the measurement statement executes regardless of the if statement. Am I using the commands correctly? Thanks for your time.",<programming><ibm-q-experience><quantum-circuit><cirq><qasm>,8/25/2023 22:17,,,,
34005.0,Design a full adder to add two 4-bits integer and measuring on 4 quantum states,"I am trying to implement a full adder with minimum of 8 qubits to add two 4 bit integers. Integer 1 will be added on q[0-3] while integer 2 will be added on q[4-7]. The output will be measured on q[0-3]. So far I created a full adder to be measured on 2 states but I am having trouble manipulating this code to measure on 4 states. Below is qiskit code: qc = QuantumCircuit(8,2) # AND gate1 implementation qc.ccx(0,1,3) # OR gate1 implementation qc.cx(0,4) qc.cx(1,4) # OR gate2 implementation qc.cx(2,5) qc.cx(4,5) # AND gate2 implementation qc.ccx(2,4,6) # OR gate implementation qc.x(3) qc.x(6) qc.ccx(3,6,7) qc.x(7)",<qiskit><programming><ibm-q-experience>,8/31/2023 21:52,,,,
34298.0,"Is there a Qutip equivalent of ""expand_operator"" for superoperators?","I want to calculate a superoperator for a small noisy subsystem consisting of $k$ qubits, and expand it to $n &gt; k$ qubits, where the remaining $n-k$ qubits are not subject to any noise. Expand_operator only works for oper-types, and there is no expand_superoperator type of functionality in Qutip. How can I do this efficiently?",<programming><quantum-operation><qutip>,9/27/2023 15:45,,,,
34341.0,Error: module 'rustworkx' has no attribute 'visit' when trying to execute a quantum circuit in a real quantum computer from IBM,"I am trying to use a real quantum computer from IBM. I have the next code: qc = QuantumCircuit(2,2) qc.h(0) qc.cx(0, 1) qc.ry(np.pi/2, 0) qc.measure(1,0) IBMQ.save_account('MY TOKEN') IBMQ.load_account() provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main') backend = provider.get_backend('ibm_nairobi') mapped_circuit = transpile(qc, backend=backend) qobj = assemble(mapped_circuit, backend=backend, shots=1024) job = backend.run(qobj) result = job.result() counts = result.get_counts() print(counts) Instead of &quot;MY TOKEN&quot; I have wrote my token and that's not the problem. The problem is when my circuit try to execute in the real quantum computer that I get the error module 'rustworkx' has no attribute 'visit' in Python",<qiskit><programming><ibm-q-experience>,10/02/2023 20:54,,,,
34486.0,How can I pass multiple embeddings in my function?,"I have a problem with my code. I would like to try multiple embeddings in my kernel (I'm using the adjoint method). My idea is to pass them to the function and use them depending on what I pass. Unfortunately, it doesn't work as I think, or I can't program it. Help would be nice :) Code: from pennylane.templates import SqueezingEmbedding,QAOAEmbedding,IQPEmbedding,DisplacementEmbedding,AngleEmbedding, StronglyEntanglingLayers,BasisEmbedding,AmplitudeEmbedding,DisplacementEmbedding def kernel_matrix(A, B): &quot;&quot;&quot;Compute the matrix whose entries are the kernel evaluated on pairwise data from sets A and B.&quot;&quot;&quot; kernel = np.array([[kernel(a, b) for b in B] for a in A]) #how can I pass on the method? return kernel def Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method): n_qubits = len(train_X[0]) dev_kernel = qml.device('lightning.qubit', wires=n_qubits) projector = np.zeros((2**n_qubits, 2**n_qubits)) projector[0, 0] = 1 @qml.qnode(dev_kernel, interface=&quot;autograd&quot;) def kernel(x1, x2): &quot;&quot;&quot;The quantum kernel. We use the adjoint method. &quot;&quot;&quot; if method == qml.templates.embeddings.AmplitudeEmbedding: method(x1, wires=range(n_qubits), pad_with=0.4) qml.adjoint(method)(x2, wires=range(n_qubits), pad_with=0.4) return qml.expval(qml.Hermitian(projector, wires=range(n_qubits))) method(x1, wires=range(n_qubits)) qml.adjoint(method)(x2, wires=range(n_qubits)) return qml.expval(qml.Hermitian(projector, wires=range(n_qubits))) svm = SVC(kernel=kernel_matrix).fit(train_X, train_y) # here is the problem how can I pass on the method? predictions = svm.predict(test_X) print(accuracy_score(predictions, test_y)) def main(): methods = [IQPEmbedding, AngleEmbedding, AmplitudeEmbedding ] for method in methods: print(method) Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method)# I want to pass on the Method",<programming><pennylane><kernel-methods><quantum-kernel>,10/15/2023 16:29,,,,
34495.0,Advantage of quantum computers over classical computers in fully modeling interactions between atoms?,"I'm trying to better understand the advantage quantum computers offer in terms of their ability to more accurately model chemical reactions. As a way to come to a deeper understanding, my question is: How much computing power would a classical computer need to fully simulate the interaction between two carbon atoms versus how much computing power would a quantum computer need to do the same? Thanks in advance for any insight.",<simulation><classical-computing><quantum-advantage><chemistry>,10/17/2023 1:07,,,,
34517.0,Is it possible to simulate a quantum algorithm on a classical computer?,"I am designing a quantum algorithm that I would like to simulate and test, but I need to be able to simulate it on a classical computer.",<programming><quantum-algorithms><simulation>,10/18/2023 21:07,,,,
34543.0,How to use parameters in QuTiP?,"I am working with QuTiP to do some calculations based on my proposed Hamiltonian. The Hamiltonian of my system has some coupling constants that show the strength of coupling between matter and light(Suppose the Jaynes-Cummings Model). I have in mind to not specify any initial value to those parameters and let them be shown in my final results. Simply speaking, I do not want to obtain numeric results. Instead, I want to have the exact derivation of the result based on parameters. I know that we can do this in Matlab using syms to set variables. However is there any piece of code that I can use to use QuTiP instead of Matlab?",<programming><qutip><quantum-optics>,10/20/2023 18:08,,,,
34548.0,How to discard one of the states in a product state in qiskit?,"Suppose I have a state in qiskit which is a product of states, for example: $| \psi \rangle = \left(\frac{ \sqrt{2} | 000 \rangle + |111 \rangle} {\sqrt 3}\right) \left( \frac{ |00 \rangle + |11 \rangle}{\sqrt 2} \right) \left( |01 \rangle \right) $ I want to write a code which will return the state of qubit 4 and 5, i.e. $\frac{|00 \rangle + |11 \rangle}{\sqrt 2}$. One way to do this would be to use save_density_matrix(qubits = [4, 5]), and covert that to a statevector. However, that takes too much time if I am doing this many times. Given that I know that the qubits 4 and 5 are unentangled from the rest of the system, is there a way to extract their state directly? Even if I take the partial trace, the output is still a density matrix.",<qiskit><programming>,10/21/2023 11:23,,,,
34638.0,Is there a way to implement a noisy CNOT gate using CUGate in Qiskit,Wondering if there's a way to implement the noisy version of CNOT (or CX) gate via CUGate using qiskit library for a given fidelity p?,<qiskit><quantum-gate><programming><noise>,10/29/2023 5:17,,,,
34932.0,Simulator able to run SwitchCase in qiskit?,"I am trying to run my circuit (shown below) on a simulator. However, the execution of the circuits fails with (almost) all the simulators, raising error The control-flow construct 'switch_case' is not supported by the backend. I will let you informed as soon as possible&quot; My code is: from qiskit import QuantumCircuit, transpile from qiskit.tools.jupyter import * from qiskit.visualization import * from ibm_quantum_widgets import * from qiskit import * from qiskit_ibm_provider import IBMProvider from qiskit import QuantumCircuit, execute, Aer from qiskit.result import marginal_counts from qiskit.providers.ibmq.job import job_monitor from qiskit.tools.visualization import plot_histogram from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options from math import pi service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) provider = IBMProvider() backend = provider.get_backend('ibmq_qasm_simulator') from qiskit.circuit import QuantumCircuit, ClassicalRegister, QuantumRegister qreg = QuantumRegister(4) creg = ClassicalRegister(6) qc = QuantumCircuit(qreg, creg) qc.x(qreg[0]) qc.x(qreg[1]) qc.x(qreg[2]) qc.measure([0, 1, 2], [0, 1, 2]) with qc.switch(creg) as case: with case(7): qc.x(qreg[3]) qc.measure(qreg[3], creg[3]) job = execute(qc, backend = backend, shots = 1000) results = job.result() ```",<qiskit><quantum-gate><programming>,11/20/2023 18:06,,,,
34942.0,Are there libraries based on qiskit that can trace over unentangled qubits?,"Suppose I have a QuantumCircuit object qc, which contains some unentangled qubits, and a Hamiltonian whose expectation value I want to measure with respect to the state prepared by qc. Here is a minimum example : from qiskit import QuantumCircuit, QuantumRegister from qiskit.quantum_info import SparsePauliOp qr = QuantumRegister(2) qc = QuantumCircuit(qr) qc.x(1) Ham = SparsePauliOp([&quot;ZI&quot;], coeffs=[1]) As the two qubits of qc are not entangled, I can trace out either of them. For instance, since $\langle 1 | \sigma_Z | 1 \rangle =-1$, we can trace the leading qubit of the above circuit, and construct the reduced Hamiltonian from qiskit import QuantumCircuit, QuantumRegister from qiskit.quantum_info import SparsePauliOp qr_reduced = QuantumRegister(1) qc_reduced = QuantumCircuit(qr_reduced) Ham_reduced = SparsePauliOp([&quot;I&quot;], coeffs=[-1]) These two systems will have the same expectation values. I am curious to know, whether there are any python packages (ideally based on qiskit) that can trace out unentangled qubits this way?",<qiskit><programming>,11/21/2023 12:42,,,,
35073.0,Is qiskit.pulse.SamplePulse deprecated?,"I'm currently following along the book &quot;Learn Quantum Computing with Python and IBM Quantum Experience&quot; by Rodert Loredo and I am at chapter 8 - Generating pulse schedules on hardware. The book material imports something called a SamplePulse, which class however seems to be moved to a new location in the latest Qiskit versions or completely removed. Can anyone point to where I could find it, if it has been relocated, or with what can I replace it with in case it's been removed. Or if it doesn't matter and I should just chug along and not worry about the details so much.",<qiskit><programming><ibm-q-experience><textbook-and-exercises>,12/03/2023 11:17,,,,
35074.0,QISKIT Metal Saves Error Generating Python Code,"Background I'm testing out the ability of the Metal GUI to save a simple circuit but it keeps generating code that gives rise to various errors. In the below code for example generates an error show below the code. I'm running this in Jupyter Notebooks. Code Readout_1 = RoutePathfinder( design, name='Readout_1', options={'_actual_length': '4.018685284646162 ' 'mm', 'anchors': {0: array([ 1.65, -0.8 ])}, 'fillet': '90um', 'hfss_wire_bonds': True, 'lead': {'end_jogged_extension': '', 'end_straight': '200um', 'start_jogged_extension': '', 'start_straight': '200um'}, 'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1', 'pin': 'north_end'}, 'start_pin': {'component': 'Q_1', 'pin': 'B3'}}, 'trace_gap': 'cpw_gap'}, type='CPW', ) Error TypeError Traceback (most recent call last) Cell In[22], line 6 1 Readout_1 = RoutePathfinder( 2 design, 3 name='Readout_1', 4 options={'_actual_length': '4.018685284646162 ' 5 'mm', ----&gt; 6 'anchors': {0: array([ 1.65, -0.8 ])}, 7 'fillet': '90um', 8 'hfss_wire_bonds': True, 9 'lead': {'end_jogged_extension': '', 10 'end_straight': '200um', 11 'start_jogged_extension': '', 12 'start_straight': '200um'}, 13 'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1', 14 'pin': 'north_end'}, 15 'start_pin': {'component': 'Q_1', 16 'pin': 'B3'}}, 17 'trace_gap': 'cpw_gap'}, 18 19 type='CPW', 20 ) TypeError: array() argument 1 must be a unicode character, not list Question How can I fix this error? Is there a missing important statement or do I need to change the generated/saved code?",<qiskit><programming>,12/03/2023 12:06,,,,
35278.0,Who is currently working on coherent Ising machines (classical analog devices)?,Can you share some papers on that subject? Review papers would be highly appreciated. What are limitations in terms of connectivity between different spins?,<resource-request><classical-computing><d-wave><ising-model>,12/22/2023 0:45,,,,
35305.0,Semi-Definite Program to maximise $P(X)$ with a fixed CHSH value,"This question should be theoretically simple, yet I'm struggling as something may be incorrect about my code. I am trying to plot a graph of the maximum probability ($P(x)$) of a given system against CHSH violation values. We can do this using the expectation values through the NPA moment matrix and create an SDP where I maximise $(1+\langle A_0 \rangle)/2$. This should give me $P(0)$. The constraints lie in making sure the correct elements of the moment matrix sum up to a given CHSH value and the matrix is positive semi-definite. However, I get values of 1 for all values of the inequality. Rather the curve should be around 1 for values 2 or less and curve to 1/2 for maximum violations of the CHSH Bell inequality (this is for two measurements). Are there more constraints to be added or am I missing something? chsh_values = np.linspace(2, 2*np.sqrt(2), 100) max_px_values = [] for chsh in chsh_values: # Define the moment matrix (5x5 for this setup) M = cp.Variable((5, 5), symmetric=True) # Objective function: Maximize (1 + &lt;A0&gt;) / 2 objective = cp.Maximize((1 + M[0, 1]) / 2) # CHSH constraint constraints = [ M[1, 3] + M[2, 3] + M[1, 4] - M[2, 4] == chsh, M[0, 0] == 1, M[1, 1] == 1, M[2, 2] == 1, M[3, 3] == 1, M[4, 4] == 1, M &gt;&gt; 0, ] # Solve the problem prob = cp.Problem(objective, constraints) prob.solve(solver=cp.MOSEK) max_px_value = prob.value max_px_values.append(round(max_px_value, 3)) # Print the moment matrix and the maximum value print(f&quot;CHSH Value: {chsh}&quot;) print(&quot;Moment Matrix:\n&quot;, M.value) print(&quot;Maximum (1 + expectation of A0) / 2:&quot;, max_px_value) print(&quot;--------------------------------------------------&quot;) ```",<programming><probability><bell-experiment><semidefinite-programming>,12/25/2023 17:23,,,,
35364.0,Why are keys in the quasidistribution larger than the maximum number allowed by the number of qubits?,"I use the IBM' Qiskit Runtime Sampler on a 4 qubits circuit. with Session(backend=backend): sampler = Sampler() result = sampler.run(qc, shots=nshots).result() qd = result.quasi_dists[0] print(&quot;qd&quot;,qd) I get the following quasi-distribution: qd {44: 0.0830078125, 36: 0.060546875, 4: 0.0595703125, 56: 0.0673828125, 40: 0.0634765625, 52: 0.0576171875, 8: 0.0625, 0: 0.0673828125, 48: 0.0615234375, 60: 0.0634765625, 12: 0.07421875, 16: 0.0556640625, 28: 0.0634765625, 20: 0.0478515625, 32: 0.0546875, 24: 0.0576171875} How it is possible for some key values need more than 4 qubits? (same behavior with different backends)",<qiskit><programming>,01/02/2024 14:16,,,,
35374.0,How to use GPU with qiskit as default and then use parallel GPU setup in distributed computing?,"I have a GTX 1600 GPU on my computer and I am confused on how to use cuQuantum, Tensorflow or torch etc to enable GPU for qiskit. Further, one of my friends also have a GPU, we want to use both GPUs but on each of our computers to implement qiskit code in parallel. Some of the work I have done till now is, I have downloaded docker and cuQuantum. Also, pip installed Tensorflow, torch and nimba but all these have some dependencies issues. Where I'm stuck. I think a software called DASK can help perform parallel computing but i don't know how to use it, What I am looking for is, A step by step guide to use docker with cuQuantum or cuda to run qiskit. Also, if I need to install Tensorflow or qiskit-aer-gpu etc then how to know what dependencies to solve for.",<qiskit><programming><simulation>,01/04/2024 07:20,,,,
35380.0,Error: IBMJobFailureError: 'Job failed: Error while executing OpenQASM 3 circuit,I am running my circuit on ibm_osaka backend and it always brings me up this error: IBMJobFailureError: 'Job failed: Error while executing OpenQASM 3 circuit.' Does anyone know what is the cause of this error and how should I solve it?,<qiskit><programming><qiskit-runtime>,01/05/2024 10:05,,,,
35391.0,Understanding vs designing quantum algorithms,"I'm quite new to quantum computing (1 week) but I noticed that implementing the circuits of someone else is quite simple, while having a deep grasp on it is way harder. Moreover I definetly don't feel ready to design quantum algorithms, despite I mastered many classical ones. How much did you take to design your first quantum algorithms. Am I dumb or this is something that newbies experience frequently?",<programming>,01/06/2024 16:10,,,,
35424.0,What are problems so computationally difficult that they'll likely only be solved with quantum computers?,"Of course, there are the exceedingly well-known examples of this, eg. breaking RSI encryption, possibly protein folding, etc. What are some more obscure or overlooked ways that the greater computing power of quantum computers can be applied? What are problems that classical computers cannot handle but quantum computers could?",<classical-computing><quantum-advantage><applications>,01/10/2024 04:59,,,,
35468.0,Quantum Computing and Overhead,"Consider Grover's Algorithm, which identifies a specific $N$-bit string from the set of all $N$-bit strings. The string test function only has to be called $2^{\frac{N}{2}}$ times instead of $2^{N-1}$ times classically. But in the QC case, there is overhead: a pre-processing step of applying a Hadamard gate $N$ times, and then for each function call, another Hadamard gate is needed in addition to an &quot;Inversion about the mean&quot; step. The books I'm using never talk about these &quot;overhead&quot; steps. If they are considered, will it make the QC algorithm slower than the classical one?",<grovers-algorithm><classical-computing>,01/12/2024 22:09,,,,
35496.0,Instruction h is not supported,I'm new at quantum computing and I'm trying to run a script with IBM quantum. I'm using brisbane and getting that error &quot;Instruction h is not supported&quot;. I get the same error for cx gate as well. Are they really not supported or am I missing something? Regards,<programming><ibm-quantum-devices>,1/16/2024 14:39,,,,
35568.0,Qnode model gradient of inputs (not parameters!) question,"I am trying to use qml to do physics informed quantum machine learning within Tensorflow. I know with TF, to get derivatives of the network's inputs (df/dx, for example), you can use with tf.GradientTape() as tape and define a function representing a partial differential equation as: @tf.function def physic_loss(t, x): u0 = u(t, x) u_t = tf.gradients(u0, t)[0] u_x = tf.gradients(u0, x)[0] u_xx = tf.gradients(u_x, x)[0] F = u_t + u0*u_x - (0.01/np.pi)*u_xx return tf.reduce_mean(tf.square(F)) It doesnât seem like the qnode components are contributing to this loss. My guess is that I need to use quantum grad tape somehow to get derivatives w.r.t x and t. Any guidance would be great!!!",<programming><entanglement><machine-learning><pennylane><variational-quantum-algorithms>,1/23/2024 20:04,,,,
35588.0,Expectation values using qiskit,"Expectation values can be calculated using $\bf{Matrix}$ $\bf{mechanics}:$ $A$ has eigenvalues $\lambda_j$ and eigenstates $\Phi_j$. Then the expectation value of $A$ with respect to a state $\Psi=\sum_j c_j\Phi_j$ is calculated as $\left\langle A\right\rangle_{\Psi}=\left\langle \Psi |A|\Psi\right\rangle=\sum_j \lambda_j c_j|\left\langle\Psi|\Phi_j \right\rangle |^2=\sum_j \lambda_j |c_j|^2$, where $c_j=\left\langle\Phi_j|\Psi \right\rangle$ or $\bf{Quantum}$ $\bf{algorithms}:$ The state $\Psi$ is created by a unitary transform V, such that $|{\Psi}\rangle=V|0,0,0...\rangle$. Therefore $\left\langle A\right\rangle_{\Psi}=\left\langle \Psi |A|\Psi\right\rangle=\left\langle 0,0,0...|V^\dagger A V|0,0,0...\right\rangle$. So we repeatedly measure the state $V^\dagger A V|{0,0,0...}\rangle$ in the computational basis and determine the probabilty to measure $|{0,0,0...}\rangle$, which yields $\left\langle A\right\rangle_{\Psi}$. So I create a state $\Psi=V|{0,0,0...}\rangle$ and operator A and compute print(psi.adjoint().compose(A).compose(psi).eval().real) which agrees with results from Matrix Mechanics. However, if I build a circuit from operators $V^\dagger,A,V$ and measure the probabilities for $|{0,0,0...}\rangle$, the results do not agree. What am I doing wrong?",<programming><circuit-construction><matrix-representation>,1/25/2024 6:21,,,,
35637.0,How to implement a quantum_and() gate,"I have encoder() and decoder() functions as follows: def encoder(x: int=0, y: int=0, n=4): &quot;&quot;&quot; An encoder to convert two n-bit nonnegative integers (uint) x and y to a 2n-qubit QuantumCircuit. This encoder will be used by autograder. &quot;&quot;&quot; assert x &gt;= 0 and x &lt; 2**n and isinstance(n,int), f&quot;Your input x must be an integer in the range [0,{(2**n)-1}].&quot; assert y &gt;= 0 and y &lt; 2**n and isinstance(n,int), f&quot;Your input y must be an integer in the range [0,{(2**n)-1}].&quot; qc = QuantumCircuit(n*2) for i in range(n): if x &gt;= 2**(n-i-1): qc.x(n-i-1) x -= 2**(n-i-1) for i in range(n): if y &gt;= 2**(n-i-1): qc.x(2*n-i-1) y -= 2**(n-i-1) return qc def decoder(qc: QuantumCircuit, n=4): &quot;&quot;&quot; A decoder to convert a QuantumCircuit to an n-bit nonnegative integer from the simulation histogram by measuring the first n qubits in the quantum circuit. The result should be deterministic on a noise-free machine, hence shot=1 is used for simulation. This decoder will be used by autograder. &quot;&quot;&quot; assert n &gt;= 1 assert isinstance(qc, QuantumCircuit) assert qc.num_qubits &gt;= n n_qubits = qc.num_qubits n_clbits = max(n, qc.num_clbits) qr = QuantumRegister(n_qubits) cr = ClassicalRegister(n_clbits) qc_base = QuantumCircuit(qr, cr) qc = qc_base.compose(qc) simulator = QasmSimulator() qc.measure(list(range(n)), list(range(n))) cc = transpile(qc, simulator) job = simulator.run(cc, shots=1) result = list(job.result().get_counts(cc).keys())[0] z = 0 for i in range(n): z += int(result[i])*2**(n-i-1) return z How to implement the quantum_and gate? Any suggestions and clues would be helpful. def quantum_and(): &quot;&quot;&quot; An N-qubit quantum circuit which calculates the AND result of input1 on [q0] and input2 on [q1], The output will be measured on [q0]. You need to decide the amount of additional qubits needed to implement the function. The function must be compatible with the provided encoder(n=1) and decoder(n=1). N must be either 2 or 3. Args: None Return: qc: Your QuantumCircuit &quot;&quot;&quot;",<quantum-gate><programming>,1/29/2024 15:11,,,,
35678.0,Spin Hamiltonian to Quantum Circuits and are there any group theory associated with the quantum circuits?,"Can we think of Quantum Circuits as another representation to describe the dynamics of a system other than its Hamiltonian? How can we go from the spin Hamiltonian version (for eg: SSH Model Hamiltonian) to quantum circuits (It would be of great help if someone can suggest resources on how to get started with this, analytically without using user-friendly software packages) including how to come with relevant initial ansatz? Since the circuits are dimensionless quantities which I think seem to make sense to me as any observable quantity has physical significance only if they are dimensionless.",<quantum-gate><programming><hamiltonian-simulation><trotterization><quantum-phase-transition>,1/31/2024 18:13,,,,
35796.0,How to have seperate registers from scrach?,"I am very new to quantum computing, so this might be a really simple question. I am coding a quantum computer simulator in python from scrach and I'm not sure how to make registers work. I would just use a wavefunction which stored all of the qubits and when operations were needed to be made (for instance a Hadamard operator on some qubit), I would just scale the operator accordingly and apply it. This seemed to work quite fine, however now I need to implement a phase estimation algorithm, where two registers are used. At first I thought to treat them as seperate wavefunctions, but when It came to controls I had to combine seperate registers into one wavefunction. Finally, It shows to apply QFT and measure just the first register. So my question is: how do I go about implementing seperate registers and using them? Is there a smarter way than just to have one insanely large wavefunction? I have no idea since registers seem to have to be interconnected for things like controls to work.",<programming><simulation><quantum-phase-estimation>,02/11/2024 22:37,,,,
35937.0,ModuleNotFoundError: No module named 'qiskit.extensions',"Environment Qiskit Finance version: 0.5.0 Python version: Using the Qiskit Lab v1.0.0 Operating system: Windows 11 Hi, technically I am new to this quantum computing stuff. I see that an upgrade of Qiskit to 1.0 was made, and that this pretty much removed the qiskit.extensions. However, in the Qiskit_finance repository trying to make the tutorial, they say it runs even for this new version of Qiskit. I am trying with tutorial 09_credit_risk_analysis.ipynb but in this part: from qiskit_finance.circuit.library import GaussianConditionalIndependenceModel as GCI u = GCI(n_z, z_max, p_zeros, rhos) It should extract a Gaussian function previously located in qiskit_finance.circuit.library I get the error in the title. Is there something I need to install?",<qiskit><programming><quantum-algorithms><quantum-computing-for-finance>,2/24/2024 14:11,,,,
36977.0,Qiskit Noisy simulator sample code or documentation,I have to run some quantum circuits on Noisy simulator of qiskit? I tried searching some noisy simulator of qiskit but could not find anything. It would be great if someone can direct me to a qiskit noisy simulator documentation or some sample python code.,<qiskit><programming><noise>,2/27/2024 5:08,,,,
36985.0,cirq entanglement qubits,"The following code originates from a third-party, although, I have added the commented line containing &quot;UNCOMMENT THE START OF THIS LINE&quot;. import random import numpy as np import cirq # Create a circuit circuit = cirq.Circuit() (q0, q1) = cirq.LineQubit.range(2) # Apply the X-Pauli gate to each qubit circuit.append([cirq.X(q0), cirq.X(q1)]) # Apply the Hadamard gate to first qubit and CNOT gate to both qubits circuit.append([cirq.H(q0), cirq.CNOT(q0, q1)]) # Make a change to q1, to see if q0 shows a corresponding change #circuit.append([cirq.X(q1)]) # UNCOMMENT THE START OF THIS LINE #Measure both qubits circuit.append([cirq.measure(q0), cirq.measure(q1)]) #Print the Circuit print(&quot;Circuit:&quot;) print(circuit) # Simulate the circuit several times. simulator = cirq.Simulator() result = simulator.run(circuit, repetitions=10) #Print the results print(&quot;\nResults:&quot;) print(result) The code is intended to demonstrate entanglement, which the output suggests it achieves. Circuit: 0: âââXâââHâââ@âââMâââ â 1: âââXâââââââXâââMâââ Results: q(0)=1000000111 q(1)=0111111000 Yet, if the commented line I added is uncommented, and the code run, the output no longer suggests entanglement. Circuit: 0: âââXâââHâââ@âââMâââââââ â 1: âââXâââââââXâââXâââMâââ Results: q(0)=0100000001 q(1)=0100000001 I expected the q(0) results to be the opposite of those seen for q(1). That is what I understand entanglement would achieve; you change q(1) and q(0) changes too. As such, at the moment, the original code is not producing entanglement at all, but, merely, forcing the result to show opposite values; giving the illusion of entanglement. Is there something I'm missing that will further my understanding, or, perhaps, even some Python/cirq code that delivers a simulation of entanglement that sees qubits behave as I'm expecting them to?",<programming><entanglement><cirq>,2/27/2024 11:05,,,,
37189.0,How to convert a custom observable matrix to a Cirq observable for simulation?,"I aim to conduct a Cirq simulation using a custom observable. However, the measure_observables function in Cirq requires an Iterable of cirq.PauliString, making it challenging to directly use a custom observable matrix. Since the observable matrix may vary, hard-coding it with gates becomes impractical. Here's an example of what I'm trying to achieve import cirq import numpy as np from cirq.work.observable_measurement import measure_observables, RepetitionsStoppingCriteria # Custom observable matrix obs_matrix = np.array( [ [0.63, 0.5, 1, 1], [0.5, 0.82, 1, 1], [1, 1, 1, 0.33], [1, 1, 0.33, 0.3], ], dtype=float, ) # Create a Cirq circuit circuit = cirq.Circuit() qubits = cirq.LineQubit.range(2) circuit.append(cirq.H(0)) circuit.append(cirq.rx(1.76)(1)) circuit.append(cirq.measure(qubits, key='result')) # Run the simulation with custom observable simulator = cirq.Simulator() results = measure_observables( circuit, obs_matrix, simulator, stopping_criteria=RepetitionsStoppingCriteria(100) ) print(results) Can anyone advise me how to tackle the matrix hard-coding?",<programming><cirq>,03/11/2024 09:11,,,,
37191.0,How to remove or change the Coupling-Map limit is qiskit?,"I am trying to implement large qiskit circuits which give coupling map error as coupling map cannot exceed 31 is basic aer_simulator or even statevector_simulator. So, I want to increase the limit or use a simulator with high number of coupling map preferably 100.",<qiskit><programming><transpile>,03/11/2024 10:24,,,,
37194.0,AttributeError: 'ADAM' object has no attribute 'optimize',"I have imported ADAM optimizer in the following way: from qiskit.algorithms.optimizers import COBYLA, ADAM, SPSA, SLSQP, POWELL, L_BFGS_B, TNC, AQGD Afterwards, I declare optimizer = ADAM(maxiter=100), however when I write optimizer.optimize it gives me the error that ADAM object has not attribute optimize. I have checked the Qiskit documentation and I believe the method is correct. Can someone help?",<qiskit><programming><optimization>,03/11/2024 13:19,,,,
37227.0,Usage of qiskit API MatrixOp.to_pauli_op(),"I am quite confused with the MatrixOp.to_pauli_op() API. I have a hamiltonian, and it is given as input to a API MatrixOp. import numpy as np from qiskit.opflow import MatrixOp from qiskit.circuit.library import EfficientSU2 from qiskit.algorithms.optimizers import COBYLA from qiskit.utils import QuantumInstance from qiskit import IBMQ, transpile from qiskit import Aer from qiskit.algorithms import VQE # This Hamiltonian is not unitary.It is generated from matrix A and B (AX =B) Hamiltonian = np.array([[ 4.07981221, -3.6713615, 1.3943662, -1.05164319], [-3.6713615, 5.88262911, -4.14084507, 1.37558685], [ 1.3943662, -4.14084507, 5.83098592, -3.54929577], [-1.05164319, 1.37558685, -3.54929577, 3.79812207]]) H_op = MatrixOp(Hamiltonian).to_pauli_op() print(H_op) print(type(H_op)) How can a non-unitary matrix be given as input to a qiskit API?",<qiskit><programming><vqe>,3/13/2024 8:11,,,,
37246.0,How to add noise like depolarising errors in Qiskit SDK 1.0?,"I have a question about how to Add my own Noise like depolarising errors to Quantum gates like $H$ gate, $R_y$ gate and $R_{zz}$ gates in Qiskit SDK 1.0 and count it through qiskit_ibm_runtime and BasicSimulator in Qiskit SDK 1.0",<qiskit><programming><qiskit-runtime>,3/14/2024 5:36,,,,
37283.0,How to use qiskit.utils.QuantumInstance API of qiskit?,"I am quite struggling with the usage of QuantumInstance API. This API is present in qiskit version 0.32.1 Below is small code: from qiskit.utils import QuantumInstance from qiskit import Aer simulator_used = &quot;qasm_simulator&quot; backend = Aer.get_backend(simulator_used) quantum_instance = QuantumInstance(backend = backend, shots = 2000, seed_simulator= 28, seed_transpiler = 28, basis_gates = None, optimization_level =1) Suppose, I want to make a simulator as statevector_simulator. Then do I have to make shots =1? Suppose I want to use the QuantumInstance in the code below. Then how should I modify the code below? If QuantumInstance cannot be used in the code below, then where should it be used? from qiskit import Aer from qiskit import execute from qiskit import QuantumCircuit circ = QuantumCircuit(3,3) circ.h(0) circ.cx(0,1) circ.cx(0,2) backend = Aer.get_backend(&quot;qasm_simulator&quot;) job = execute(circ, backend, shots = 100000) result = job.result() counts = result.get_counts(circ) print(counts)",<qiskit><programming><simulation>,3/15/2024 21:42,,,,
37324.0,Can we train Parametric Quantum Circuits to map any probability distribution to Normal Distribution?,"I am trying to find any references to train PQCs to map any probability distribution to a Normal Distribution. Suppose I have MNIST dataset, I want to apply PQC and make the readout distribution to be close to a discrete Normal distribution. Is it possible ?",<programming><quantum-algorithms><random-quantum-circuit>,3/18/2024 10:35,,,,
37325.0,Quantum code for Substitution Box,How to write quantum code(qiskit) for n-bit Substitution Box with minimum number of gate and qubit.,<qiskit><classical-computing><quantum-advantage><computational-models>,3/18/2024 11:20,,,,
37351.0,Value error in variational quantum circuits,"I am working on a project to find a unitary gate that arrives at a specific density matrix at the end. The circuit construct is shown below: dev1 = qml.device(&quot;default.mixed&quot;, wires=2) @qml.qnode(dev1) def circuit(params_SU): qml.QubitDensityMatrix(identity_matrix/2, 0) qml.QubitDensityMatrix(rho, 1) qml.SpecialUnitary(params_SU, [0, 1]) return qml.density_matrix([0, 1]) And the cost function is: expected_result = rho / 2 + identity_matrix / 4 def cost(params_SU): cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result) return cost_value and def partial_trace_B(matrix): partial_trace_B = np.zeros([2, 2], dtype=complex) partial_trace_B[0][0] = matrix[0][0] + matrix[1][1] partial_trace_B[0][1] = matrix[0][2] + matrix[1][3] partial_trace_B[1][0] = matrix[2][0] + matrix[3][1] partial_trace_B[1][1] = matrix[2][2] + matrix[3][3] return partial_trace_B However, when running the optimisation: n_steps = 1500 theta = np.random.rand(1, 15, requires_grad=True) costs_list = [] opt = AdamOptimizer() for i in range(1, n_steps+1): if i%100==0: print(&quot;Running... Current step: &quot;, i) theta = opt.step(cost, theta) costs_list.append(cost(theta)) I kept getting this Value Error: --------------------------------------------------------------------------- TypeError Traceback (most recent call last) TypeError: float() argument must be a string or a real number, not 'ArrayBox' The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last) Cell In[6], line 8 6 for i in range(1, n_steps+1): 7 if i%100==0: print(&quot;Running... Current step: &quot;, i) ----&gt; 8 theta = opt.step(cost, theta) 9 costs_list.append(cost(theta)) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:88, in GradientDescentOptimizer.step(self, objective_fn, grad_fn, *args, **kwargs) 70 def step(self, objective_fn, *args, grad_fn=None, **kwargs): 71 &quot;&quot;&quot;Update trainable arguments with one step of the optimizer. 72 73 Args: (...) 85 If single arg is provided, list [array] is replaced by array. 86 &quot;&quot;&quot; ---&gt; 88 g, _ = self.compute_grad(objective_fn, args, kwargs, grad_fn=grad_fn) 89 new_args = self.apply_grad(g, args) 91 # unwrap from list if one argument, cleaner return File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:117, in GradientDescentOptimizer.compute_grad(objective_fn, args, kwargs, grad_fn) 99 r&quot;&quot;&quot;Compute gradient of the objective function at the given point and return it along with 100 the objective function forward pass (if available). 101 (...) 114 will not be evaluted and instead ``None`` will be returned. 115 &quot;&quot;&quot; 116 g = get_gradient(objective_fn) if grad_fn is None else grad_fn --&gt; 117 grad = g(*args, **kwargs) 118 forward = getattr(g, &quot;forward&quot;, None) 120 num_trainable_args = sum(getattr(arg, &quot;requires_grad&quot;, False) for arg in args) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:118, in grad.__call__(self, *args, **kwargs) 115 self._forward = self._fun(*args, **kwargs) 116 return () --&gt; 118 grad_value, ans = grad_fn(*args, **kwargs) # pylint: disable=not-callable 119 self._forward = ans 121 return grad_value File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:20, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f(*args, **kwargs) 18 else: 19 x = tuple(args[i] for i in argnum) ---&gt; 20 return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:136, in grad._grad_with_forward(fun, x) 130 @staticmethod 131 @unary_to_nary 132 def _grad_with_forward(fun, x): 133 &quot;&quot;&quot;This function is a replica of ``autograd.grad``, with the only 134 difference being that it returns both the gradient *and* the forward pass 135 value.&quot;&quot;&quot; --&gt; 136 vjp, ans = _make_vjp(fun, x) 138 if not vspace(ans).size == 1: 139 raise TypeError( 140 &quot;Grad only applies to real scalar-output functions. &quot; 141 &quot;Try jacobian, elementwise_grad or holomorphic_grad.&quot; 142 ) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\core.py:10, in make_vjp(fun, x) 8 def make_vjp(fun, x): 9 start_node = VJPNode.new_root() ---&gt; 10 end_value, end_node = trace(start_node, fun, x) 11 if end_node is None: 12 def vjp(g): return vspace(x).zeros() File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\tracer.py:10, in trace(start_node, fun, x) 8 with trace_stack.new_trace() as t: 9 start_box = new_box(x, t, start_node) ---&gt; 10 end_box = fun(start_box) 11 if isbox(end_box) and end_box._trace == start_box._trace: 12 return end_box._value, end_box._node File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:15, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f.&lt;locals&gt;.unary_f(x) 13 else: 14 subargs = subvals(args, zip(argnum, x)) ---&gt; 15 return fun(*subargs, **kwargs) Cell In[5], line 4 3 def cost(params_SU): ----&gt; 4 cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result) 5 return cost_value File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\qnode.py:1027, in QNode.__call__(self, *args, **kwargs) 1022 full_transform_program._set_all_argnums( 1023 self, args, kwargs, argnums 1024 ) # pylint: disable=protected-access 1026 # pylint: disable=unexpected-keyword-arg -&gt; 1027 res = qml.execute( 1028 (self._tape,), 1029 device=self.device, 1030 gradient_fn=self.gradient_fn, 1031 interface=self.interface, 1032 transform_program=full_transform_program, 1033 config=config, 1034 gradient_kwargs=self.gradient_kwargs, 1035 override_shots=override_shots, 1036 **self.execute_kwargs, 1037 ) 1039 res = res[0] 1041 # convert result to the interface in case the qfunc has no parameters File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:616, in execute(tapes, device, gradient_fn, interface, transform_program, config, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform) 614 # Exiting early if we do not need to deal with an interface boundary 615 if no_interface_boundary_required: --&gt; 616 results = inner_execute(tapes) 617 return post_processing(results) 619 _grad_on_execution = False File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:249, in _make_inner_execute.&lt;locals&gt;.inner_execute(tapes, **_) 247 if numpy_only: 248 tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes) --&gt; 249 return cached_device_execution(tapes) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:371, in cache_execute.&lt;locals&gt;.wrapper(tapes, **kwargs) 366 return (res, []) if return_tuple else res 368 else: 369 # execute all unique tapes that do not exist in the cache 370 # convert to list as new device interface returns a tuple --&gt; 371 res = list(fn(tuple(execution_tapes.values()), **kwargs)) 373 final_res = [] 375 for i, tape in enumerate(tapes): File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:81, in ContextDecorator.__call__.&lt;locals&gt;.inner(*args, **kwds) 78 @wraps(func) 79 def inner(*args, **kwds): 80 with self._recreate_cm(): ---&gt; 81 return func(*args, **kwds) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:460, in QubitDevice.batch_execute(self, circuits) 455 for circuit in circuits: 456 # we need to reset the device here, else it will 457 # not start the next computation in the zero state 458 self.reset() --&gt; 460 res = self.execute(circuit) 461 results.append(res) 463 if self.tracker.active: File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:685, in DefaultMixed.execute(self, circuit, **kwargs) 683 wires_list.append(m.wires) 684 self.measured_wires = qml.wires.Wires.all_wires(wires_list) --&gt; 685 return super().execute(circuit, **kwargs) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:279, in QubitDevice.execute(self, circuit, **kwargs) 276 self.check_validity(circuit.operations, circuit.observables) 278 # apply all circuit operations --&gt; 279 self.apply(circuit.operations, rotations=self._get_diagonalizing_gates(circuit), **kwargs) 281 # generate computational basis samples 282 if self.shots is not None or circuit.is_sampled: File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:699, in DefaultMixed.apply(self, operations, rotations, **kwargs) 693 raise DeviceError( 694 f&quot;Operation {operation.name} cannot be used after other Operations have already been applied &quot; 695 f&quot;on a {self.short_name} device.&quot; 696 ) 698 for operation in operations: --&gt; 699 self._apply_operation(operation) 701 # store the pre-rotated state 702 self._pre_rotated_state = self._state File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:617, in DefaultMixed._apply_operation(self, operation) 614 self._debugger.snapshots[len(self._debugger.snapshots)] = density_matrix 615 return --&gt; 617 matrices = self._get_kraus(operation) 619 if operation in diagonal_in_z_basis: 620 self._apply_diagonal_unitary(matrices, wires) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:308, in DefaultMixed._get_kraus(self, operation) 305 if isinstance(operation, Channel): 306 return operation.kraus_matrices() --&gt; 308 return [operation.matrix()] File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\operation.py:775, in Operator.matrix(self, wire_order) 755 def matrix(self, wire_order=None): 756 r&quot;&quot;&quot;Representation of the operator as a matrix in the computational basis. 757 758 If ``wire_order`` is provided, the numerical representation considers the position of the (...) 773 tensor_like: matrix representation 774 &quot;&quot;&quot; --&gt; 775 canonical_matrix = self.compute_matrix(*self.parameters, **self.hyperparameters) 777 if wire_order is None or self.wires == Wires(wire_order): 778 return canonical_matrix File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\ops\qubit\special_unitary.py:482, in SpecialUnitary.compute_matrix(theta, num_wires) 479 if interface == &quot;jax&quot; and qml.math.ndim(theta) &gt; 1: 480 # jax.numpy.expm does not support broadcasting 481 return qml.math.stack([qml.math.expm(1j * _A) for _A in A]) --&gt; 482 return qml.math.expm(1j * A) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:151, in multi_dispatch.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs) 148 interface = interface or get_interface(*dispatch_args) 149 kwargs[&quot;like&quot;] = interface --&gt; 151 return fn(*args, **kwargs) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:837, in expm(tensor, like) 834 return tf.linalg.expm(tensor) 835 from scipy.linalg import expm as scipy_expm --&gt; 837 return scipy_expm(tensor) File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\scipy\linalg\_matfuncs.py:299, in expm(A) 296 return np.exp(a) 298 if not np.issubdtype(a.dtype, np.inexact): --&gt; 299 a = a.astype(float) 300 elif a.dtype == np.float16: 301 a = a.astype(np.float32) ValueError: setting an array element with a sequence. It would be very kind if someone can provide some resolutions. Thank you so much!!! I believe the bug is due to the line in the cost function cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result) But it seems completely fine with me, and I do not know how to solve it.",<programming><optimization><pennylane>,3/19/2024 9:47,,,,
37374.0,Using GPUs with Statevector Simulator in Qiskit 1.0,"I'm trying to use the AerStatevector method with GPUs. I know that GPUs on my server are correctly configured, and indeed, if I use AerSimulator I'm able to use them with no problem. Now, by using the following code: AerStatevector(qc, device='GPU') where qc is a given quantum circuit, I'm getting the following error: RuntimeError: This program was not compiled for SM 61 : cudaErrorInvalidDevice: invalid device ordinal On the other hand, If I use just AerStatevector(qc), it works correctly. Any hints? More generally, I'm moving to qiskit 1.0, and I would like to perform statevector simulations by using GPUs. Where can I look for some tutorials?",<qiskit><programming><simulation>,3/20/2024 11:35,,,,
37519.0,ValueError: non-deterministic detectors while using Stim to simulate Toric code,"I am trying to simulate Toric code using Stim. Below is my simple circuit specification in Stim: QUBIT_COORDS(0, 0) 0 QUBIT_COORDS(1, 0) 1 QUBIT_COORDS(2, 0) 2 QUBIT_COORDS(3, 0) 3 QUBIT_COORDS(0, 1) 4 QUBIT_COORDS(1, 1) 5 QUBIT_COORDS(2, 1) 6 QUBIT_COORDS(3, 1) 7 QUBIT_COORDS(0, 2) 8 QUBIT_COORDS(1, 2) 9 QUBIT_COORDS(2, 2) 10 QUBIT_COORDS(3, 2) 11 QUBIT_COORDS(0, 3) 12 QUBIT_COORDS(1, 3) 13 QUBIT_COORDS(2, 3) 14 QUBIT_COORDS(3, 3) 15 R 1 3 4 6 9 11 12 14 0 2 5 7 8 10 13 15 TICK DEPOLARIZE1(0.2) 1 3 4 6 9 11 12 14 H 0 2 8 10 TICK CX 0 12 2 14 8 4 10 6 1 5 3 7 9 13 11 15 TICK CX 0 3 2 1 8 11 10 9 4 5 6 7 12 13 14 15 TICK CX 0 4 2 6 8 12 10 14 9 5 11 7 1 13 3 15 TICK CX 0 1 2 3 8 9 10 11 6 5 4 7 14 13 12 15 TICK H 0 2 8 10 TICK MR 0 2 5 7 8 10 13 15 DETECTOR(1, 1, 0) rec[-6] DETECTOR(3, 1, 0) rec[-5] DETECTOR(1, 3, 0) rec[-2] DETECTOR(3, 3, 0) rec[-1] REPEAT 2 { TICK DEPOLARIZE1(0.2) 1 3 4 6 9 11 12 14 H 0 2 8 10 TICK CX 0 12 2 14 8 4 10 6 1 5 3 7 9 13 11 15 TICK CX 0 3 2 1 8 11 10 9 4 5 6 7 12 13 14 15 TICK CX 0 4 2 6 8 12 10 14 9 5 11 7 1 13 3 15 TICK CX 0 1 2 3 8 9 10 11 6 5 4 7 14 13 12 15 TICK H 0 2 8 10 TICK MR 0 2 5 7 8 10 13 15 SHIFT_COORDS(0, 0, 1) DETECTOR(0, 0, 0) rec[-8] rec[-16] DETECTOR(2, 0, 0) rec[-7] rec[-15] DETECTOR(1, 1, 0) rec[-6] rec[-14] DETECTOR(3, 1, 0) rec[-5] rec[-13] DETECTOR(0, 2, 0) rec[-4] rec[-12] DETECTOR(2, 2, 0) rec[-3] rec[-11] DETECTOR(1, 3, 0) rec[-2] rec[-10] DETECTOR(3, 3, 0) rec[-1] rec[-9] TICK } M 1 3 4 6 9 11 12 14 DETECTOR(1, 1, 1) rec[-14] rec[-8] rec[-6] rec[-4] rec[-5] DETECTOR(3, 1, 1) rec[-13] rec[-7] rec[-5] rec[-3] rec[-6] DETECTOR(1, 3, 1) rec[-10] rec[-4] rec[-2] rec[-8] rec[-1] DETECTOR(3, 3, 1) rec[-9] rec[-3] rec[-1] rec[-7] rec[-2] OBSERVABLE_INCLUDE(0) rec[-8] rec[-7] I can not understand why this circuit should contain non-deterministic detectors. Ancilla qubits for measuring $X$-type stabilizers were conjugated with 'Hadamard'. From the circuit construction, there should not be any non-determinism. Can you please help me debug this? Here is the stack trace when I invoke detector_error_model: Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: The circuit contains non-deterministic detectors. (To allow non-deterministic detectors, use the `allow_gauge_detectors` option.) This was discovered while analyzing a Z-basis demolition measurement (MR) on: qubit 15 [coords (3, 3)] The collapse anti-commuted with these detectors/observables: D13 [coords (2, 0, 2)] D16 [coords (0, 2, 2)] The backward-propagating error sensitivity for D13 was: X1 [coords (1, 0)] Z2 [coords (2, 0)] X3 [coords (3, 0)] X5 [coords (1, 1)] X6 [coords (2, 1)] X14 [coords (2, 3)] X15 [coords (3, 3)] The backward-propagating error sensitivity for D16 was: X4 [coords (0, 1)] X5 [coords (1, 1)] Z8 [coords (0, 2)] X9 [coords (1, 2)] X11 [coords (3, 2)] X12 [coords (0, 3)] X15 [coords (3, 3)] Circuit stack trace: during TICK layer #15 of 24 at instruction #37 [which is a REPEAT 2 block] at block's instruction #15 [which is MR 0 2 5 7 8 10 13 15]",<programming><stim><toric-code>,3/28/2024 19:22,,,,
37561.0,How to create a qudit of any dimension $d$ in qiskit?,"How to create qudit, not qubit (which is a special case of qudit with $d = 2$) in qiskit of any dimension $d$? Actually, I searched this on chatgpt, but not-so-helpful info was found. It just uses qubits and tries to simulate it to behave like qudits, but it is not properly done. Also, it uses the QuantumCircuit function, which generates qubits only, not qudits, with some classical registers.",<qiskit><quantum-state><programming>,04/01/2024 10:33,,,,
37564.0,How can I get the state of my quantum circuit like save_statevector() in qiskit 1.0.2?,"Just as the title, I want to get the state of my quantum circuit when running simulation locally with fake provider. But I cannot use save_statevector since Aer has been removed from qiskit. My code is just as follows, any answer can be helpful. from qiskit import QuantumCircuit from qiskit import transpile from qiskit.visualization import plot_histogram from qiskit_ibm_runtime.fake_provider import FakeManilaV2 import matplotlib.pyplot as plt import numpy as np # Get a fake backend from the fake provider backend = FakeManilaV2() # Create a simple circuit circuit = QuantumCircuit(3) circuit.h(0) circuit.cx(0, 1) circuit.cx(0, 2) circuit.measure_all() circuit.draw('mpl') plt.show() # Transpile the ideal circuit to a circuit that can be directly executed by the backend transpiled_circuit = transpile(circuit, backend) transpiled_circuit.draw('mpl') plt.show() transpiled_circuit.save_statevector() # Run the transpiled circuit using the simulated fake backend job = backend.run(transpiled_circuit) result = job.result() outputstate = np.real(result.get_statevector(transpiled_circuit, decimals=100))",<qiskit><quantum-state><programming>,04/01/2024 12:21,,,,
37591.0,How to combine a VQE circuit with normal qiskit quantum circuit without parameters and give the measured set of qubits to the estimator?,"I want to use a parameterized quantum-circuit which is $\text{CNOT}$ with another quantum-circuit that has no parameters, then after a series of gates on the second quantum-circuit, I want to measure and give it to the estimator and optimizer for VQE. I have made a parameterized circuit and used it with a Hamiltonian containing constraint, but as soon as I add a non-parameterized circuit, I face two problems: How to give the measured set of qubits to the estimator? How to use VQE with or without generate_preset_pass_manager?",<qiskit><programming><quantum-algorithms><vqe><variational-quantum-algorithms>,04/03/2024 06:26,,,,
37603.0,How to generate the Bell state $\frac{1}{\sqrt{2}}(|01\rangle+|10\rangle)$ from the state $|00\rangle$ using Qiskit?,"I want to generate the Bell state $(|01\rangle+|10\rangle)/\sqrt{2}$ from the state $|00\rangle$ in qiskit, applying the Hadamard gate followed by the $\text{CNOT}$ gate. But it generates $(|11\rangle-|00\rangle)/\sqrt{2}$. What is the problem? sv1 = Statevector.from_label('01') mycircuit1 = QuantumCircuit(2) mycircuit1.h(0) mycircuit1.cx(0,1) new_sv1 = sv1.evolve(mycircuit1) print(new_sv1) plot_state_qsphere(new_sv1.data)",<qiskit><quantum-gate><quantum-state><programming><bell-basis>,04/03/2024 20:54,,,,
37651.0,Is it safe to assume that any hybrid algorithm can be transformed into a purely quantum form with comparable complexity?,"Suppose we have a definite function of interest from numbers to numbers (from a finite set). In general, we have a lot of options when we construct algorithms that compute it (with some errors, possibly). We can use classical processing, randomization, quantum tools such as oracles, measurements (in multiple rounds), quantum channels and any combinations of those. But as an input for quantum algorithms we usually require oracles which are just quantum unitaries, i.e. purely quantum algorithms. So, can we assume that any hybrid algorithm can be transformed into an oracle with a comparable complexity? If we have just a deterministic classical algorithm then the conversion is possible, this is well known. But I'm not sure about that if we're allowed to use multiple rounds of quantum measurements additionally.",<classical-computing><oracles>,04/05/2024 20:06,,,,
37659.0,Failed to load program into HAL component,"I'm getting this error message when I execute my qiskit code on one of the available quantum computers of IBM: qiskit_ibm_runtime.exceptions.RuntimeJobFailureError: 'Unable to retrieve job result. Failed to load program into HAL component' As additional information I'm trying to run my program in the quantum computer ibm_brisbane. The program uses 46 qubits. service = QiskitRuntimeService(channel='ibm_quantum') provider = IBMProvider() backend = provider.backends(name=&quot;ibm_brisbane&quot;)[0] session = Session(service=service, backend=&quot;ibm_brisbane&quot;) transpiled_circuit = transpile(circuit, backend=backend) result = Sampler(session=session).run(transpiled_circuit, shots=number_shots).result().quasi_dists[0] It does transpile the circuit, but when running, it gives back the error.",<qiskit><programming><qiskit-runtime>,04/06/2024 15:59,,,,
37663.0,Multiplying two real variables in D Wave,"I have two real variables from dimod: from dimod import Real A = Real(&quot;A&quot;) B = Real(&quot;B&quot;) However, when I try to multiply them (A*B) I get the following error: ValueError: REAL variables (e.g. 'A') cannot have interactions Anyway to resolve this? I understand that binary and integer variables can be multipled without an issue, so what seems to be the problem with real variables?",<programming><d-wave><quantum-computing-for-finance>,04/07/2024 00:34,,,,
37672.0,Calculating Nested Commutator using a program,"The $\tilde\alpha_{\text{comm}}$ mentioned in Theory of Trotter Error paper is calculated via the nested commutators. For a Hamiltonian $H = \sum_\gamma H_\gamma$, the formula for pth order is as follows: $$ \tilde\alpha_{\text{comm}} = \sum_{\gamma_1, \dots \gamma_{p+1}} \bigg|\bigg| \big[H_{\gamma_1}, \dots [H_{\gamma_{p}}, H_{\gamma_{p+1}}]\big]\bigg|\bigg|\,. $$ I can expand this manually for 1st order and 2nd order bound, but is there an efficient way that could give me the nested commutator $[H_{\gamma_1}, \dots \big[H_{\gamma_{p}}, H_{\gamma_{p+1}}]\big]$ for given $H_{\gamma_1}, \dots H_{\gamma_{p+1}}$? My approach to solving this question was to create a recursive function that would return $AB-BA$ in the following form: {&quot;ab&quot;: 1, &quot;ba&quot;: -1} I created a function in Python as follows: def _commute(terms): if len(terms) == 2: a, b = terms pa, ca = a pb, cb = b return {pa @ pb: ca * cb, pb @ pa: -ca * cb} first, rem = terms[0], terms[1:] tail = _commute(rem) new_tail = defaultdict(float) pa, ca = first for pb, cb in tail: new_tail[pa @ pb] += ca * cb new_tail[pb @ pa] -= ca * cb return new_tail Is there perhaps a way that would exploit the ordering or cyclical properties of the commutator terms and directly give me the positive and the negative terms that would compute it at a faster rate than my current code?",<programming><trotterization><pauli-group>,04/07/2024 12:27,,,,
37711.0,Where to find the Grover's algorithm for Qiskit 1.0.2?,"Can anyone please provide me with the latest version of qiskit 1.0.2 Grover's algorithm, as the earlier version is throwing an error.",<qiskit><programming><grovers-algorithm><resource-request>,04/09/2024 06:31,,,,
37720.0,IBM fake backend vs real backend,"It is claimed that the fake backends of IBM will have noise similar to the real backends. However, to what extent can we expect them to produce the same results? I have run my quantum circuit on the real backend, ibm_kyoto and the result differs vastly from the fake backends (FakeCairoV2, FakeTorino) which I test my algorithm with. Do the real backends have much more noise than the fake ones?",<qiskit><programming><ibm-quantum-devices>,04/09/2024 14:00,,,,
37726.0,CircuitTooWideForTarget error when using Clifford simulator in Qiskit,"I want to use the local Clifford AerSimulator with the Estimator primitive in Qiskit to calculate expectation values on Clifford circuits, but I am getting a CircuitTooWideForTarget error: from qiskit import QuantumCircuit from qiskit_aer import AerSimulator from qiskit_aer.primitives import Estimator as Estimator_Aer simulator_aer = AerSimulator(method=&quot;stabilizer&quot;) estimator_aer = Estimator_Aer() print(simulator_aer.num_qubits) print(simulator_aer.coupling_map) qc = QuantumCircuit(50) job = estimator_aer.run(qc, 'I'*50, backend=simulator_aer) print(job.status()) print(job.result()) outputs 10000 None JobStatus.ERROR [...] CircuitTooWideForTarget: 'Number of qubits (50) in circuit-165 is greater than maximum (30) in the coupling_map' This is strange to me, since the backend object simulator_aer doesn't have an associated coupling_map object, and should support thousands of qubits. Something under the hood is implicitly limiting the number to 30. Does anyone know how I might go about resolving this?",<qiskit><programming>,04/10/2024 08:05,,,,
37809.0,Are Quantum Computers Bad at Addition?,"I recently built a dynamic full adder gate with Qiskit. The gate essentially copies the classical computing method for a full adder by emulating the classical gates e.g. AND == Toffoli (Quantum AND gate). I ran a 5-bit adder with ibm_kyoto (127 qubits Eagle processor), with 10000 shots, expecting the highest result to be the correct one, but it was far from it, with many different combinations of bits being presented as the answer by the algorithm. Please can you help me understand why my algorithm is so bad at finding the addition of two binary numbers, or is Quantum just not suited for this due to NISQ or some fundamental flaw? My code is below: from qiskit import QuantumCircuit # a_input and b_input should be binary strings a_input = &quot;001&quot; # User input for A b_input = &quot;101&quot; # User input for B n = len(a_input) # Number of bits of numbers added # Define the full adder function using the provided circuit template def full_adder(qc, a_input, b_input): # Initialize the qubits based on user inputs in little-endian order a_input = a_input[::-1] b_input = b_input[::-1] for i in range(n): # Initialize qubits for &quot;A&quot; inputs (little-endian order) if a_input[i] == '1': qc.x(3 * i + 1) # Map a_input[i] to qubit at position 3*i # Initialize qubits for &quot;B&quot; inputs (little-endian order) if b_input[i] == '1': qc.x(3 * i + 2) # Map b_input[i] to qubit at position 3*i + 2 # Add the barriers as in the provided template qc.barrier() # Apply Toffoli (ccx) and CNOT (cx) gates for the full adder function qc.ccx(1, 2, 3) qc.cx(1, 2) qc.ccx(0, 2, 3) qc.cx(2, 0) qc.cx(1, 2) qc.barrier() # Repeat for n blocks of qubits as specified by the input `n` for offset in range(3, 3 * (n), 3): # Apply Toffoli (ccx) and CNOT (cx) gates for each block qc.ccx(1 + offset, 2 + offset, 3 + offset) qc.cx(1 + offset, 2 + offset) qc.ccx(0 + offset, 2 + offset, 3 + offset) qc.cx(2 + offset, 0 + offset) qc.cx(1 + offset, 2 + offset) qc.barrier() # Measure the specified qubits and store results in classical bits qc.measure([3 * i for i in range(n + 1)], [i for i in range(n + 1)]) # Return the circuit return qc # Example usage of the full adder function with user inputs qc = QuantumCircuit(n*n +1 ,n + 1) qc = full_adder(qc, a_input, b_input) qc.draw(plot_barriers=True, initial_state=True, scale=1, output='mpl') from qiskit_ibm_runtime import QiskitRuntimeService, EstimatorV2 as Estimator from qiskit import transpile service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;*******&quot;) realBackend = service.least_busy(simulator=False, operational=True) transpiled_qc = transpile(qc, backend=realBackend) counts = realBackend.run(transpiled_qc, shots=10000).result().get_counts() print(counts) import matplotlib.pyplot as plt def plot_histogram(counts): # Create a new figure with a wider size plt.figure(figsize=(15, 6)) # Adjust the width and height as needed # Plot the histogram plt.bar(counts.keys(), counts.values()) # Set labels and title plt.xlabel('Categories') plt.ylabel('Counts') plt.title('Histogram') # Rotate the x-axis labels by 45 degrees plt.xticks(rotation=45, ha='right') # Show the plot plt.show() plot_histogram(counts)",<qiskit><programming><classical-computing>,4/15/2024 20:10,,,,
37893.0,How to use stim to implement a specific circuit,"I'm doing a QEC job, and I want to apply an error like $U_{err}(\theta) = \prod_j e^{-i\frac{\theta_j}{2}P_j} = \prod_j (I\cos(\frac{\theta_j}{2}) - iP_j\sin(\frac{\theta_j}{2}))$, where $\theta_j$ is some given value, and $P_j$ is some Pauli operator. I know that only when $\theta_j = 0$ or $\theta_j = \pm \pi/2$, then $U_err$ is Clifford. I just want to have a function like def error(Theta, Pauli): error_circuit = stim.Circuit() TODO!!! return error_circuit to help me to get $U_{err}$, but I don't know how.",<programming><error-correction><stim>,4/20/2024 14:32,,,,
37894.0,Generating Equal Amplitude Superposition States from Another Equal Amplitude Superposition State,"Can we prepare a state regarding a transformation in quantum computing that seems to generate another equal amplitude superposition state when applying a Hadamard gate? Specifically, I observed that starting with an equal complex amplitude superposition of all possible state and applying a Hadamard gate resulted in another equal amplitude superposition state with different phases. $$\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^n-1}a_{x}\left|x\right&gt;\xrightarrow{\mathbb H^{\otimes n}}\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^n-1}b_{y}\left|y\right&gt;$$ I would like to discuss how can we prepare the initial state and explore its potential applications and implications for quantum algorithms.",<quantum-gate><programming><quantum-algorithms><error-correction><cryptography>,4/20/2024 15:32,,,,
37926.0,How to represent unitary evolution in Python?,How to represent $U(t)$ (a unitary operator) in a code? Is there any package available for that in Python?,<quantum-state><programming><unitarity>,4/23/2024 14:12,,,,
37978.0,Is there an up-to-date programming reference for qiskit?,Every example of code for qiskit that I've seen has one or more commands that don't work out of the box. Even the way to verify that qiskit is installed from qiskit.org failed. I've managed to either figure out or find the correct syntax in a lot of these cases but it is not without effort. This is like my experience with MVC in C#. The commands for MVC 1.0 changed considerably with the next version making the reference books obsolete. So my question: Is there a reference that is up-to-date for programming with qiskit?,<qiskit><programming><resource-request>,4/25/2024 15:29,,,,
37986.0,"How to add command `noise_model = get_noise ( 0.05,0.05 )` to my simulator in qiskit","I'm using qiskit online, and want to run my simulator with the following command: noise_model = get_noise ( 0.05,0.05 ) However, where previously I could insert lines of code to affect my circuit, I now only see the &quot;setup and run&quot; option. How can I add my command?",<qiskit><programming>,4/26/2024 10:51,,,,
38186.0,Why we do SWAP operations for applying a mode N function in Shor algorithms and How we do this swapping?,"I am working on implementing shor algorithm for finding prime factors of N = 15. I am trying to understand a code of qiskit, but i am confused how and why the code editor is using swap codes to define mode function. Here is the code: def c_amod15(a, power): &quot;&quot;&quot;Controlled multiplication by a mod 15&quot;&quot;&quot; if a not in [2,4,7,8,11,13]: raise ValueError(&quot;'a' must be 2,4,7,8,11 or 13&quot;) U = QuantumCircuit(4) for _iteration in range(power): if a in [2,13]: U.swap(2,3) U.swap(1,2) U.swap(0,1) if a in [7,8]: U.swap(0,1) U.swap(1,2) U.swap(2,3) if a in [4, 11]: U.swap(1,3) U.swap(0,2) if a in [7,11,13]: for q in range(4): U.x(q) U = U.to_gate() U.name = f&quot;{a}^{power} mod 15&quot; c_U = U.control() return c_U",<quantum-gate><programming><quantum-algorithms><shors-algorithm><entanglement-swapping>,05/07/2024 09:44,,,,
38201.0,Shorâs / qiskit.circuit.exceptions.CircuitError: 'duplicate qubit arguments',"All code for Quantum Realiazition Shor's algoritm P.S. I hope all operation almost correct. from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister from qiskit_aer import AerSimulator from qiskit.visualization import plot_histogram from math import pi Pcurve = 4294967311 Acurve = 0 Bcurve = 7 Gx, Gy = 2502914690, 3608000288 num_qubits = 32 def apply_kqft(circuit, qubits): num_qubits = len(qubits) for j in range(num_qubits): circuit.h(qubits[j]) for k in range(j + 1, num_qubits): angle = -pi / float(2 ** (k - j)) circuit.cp(angle, qubits[k], qubits[j]) def apply_inverse_kqft(circuit, qubits): &quot;&quot;&quot; Apply the inverse KQFT to a register of qubits. &quot;&quot;&quot; num_qubits = len(qubits) for j in range(num_qubits - 1, -1, -1): for k in range(num_qubits - 1, j, -1): angle = pi / float(2 ** (k - j)) circuit.cp(angle, qubits[k], qubits[j]) circuit.h(qubits[j]) def quantum_subtraction(circuit, qr_a, qr_b, qr_result, qr_borrow): &quot;&quot;&quot;Subtracts qr_b from qr_a and stores the result in qr_result.&quot;&quot;&quot; num_qubits = len(qr_a) for i in range(num_qubits): circuit.cx(qr_b[i], qr_a[i]) circuit.ccx(qr_borrow[i], qr_a[i], qr_b[i]) def controlled_subtraction(circuit, qr_a, qr_b, qr_control): num_qubits = len(qr_a) for i in range(num_qubits): # ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ Ð»Ð¾Ð³Ð¸ÐºÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð±ÐµÐ· Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÑ ÐºÑÐ±Ð¸ÑÐ¾Ð² if qr_control == qr_a[i] or qr_control == qr_b[i]: # ÐÑÐ¾Ð¿ÑÑÑÐ¸Ð¼ Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð² ÑÑÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ continue circuit.ccx(qr_control, qr_b[i], qr_a[i]) def quantum_division(circuit, qr_dividend, qr_divisor, qr_quotient, qr_remainder, qr_control): num_qubits = len(qr_dividend) for i in range(num_qubits): circuit.cx(qr_dividend[i], qr_remainder[i]) for i in range(num_qubits - 1, -1, -1): controlled_subtraction(circuit, qr_remainder, qr_divisor, qr_control) circuit.cx(qr_remainder[num_qubits - 1], qr_quotient[i]) controlled_subtraction(circuit, qr_remainder, qr_divisor, qr_control) def quantum_multiplication(circuit, qr_a, qr_b, qr_product): &quot;&quot;&quot;Multiplies qr_a and qr_b storing the result in qr_product.&quot;&quot;&quot; num_qubits = len(qr_a) qr_temp = QuantumRegister(num_qubits, 'temp') circuit.add_register(qr_temp) for i in range(num_qubits): for j in range(num_qubits): circuit.ccx(qr_a[i], qr_b[j], qr_temp[j]) circuit.cx(qr_temp[j], qr_product[i + j]) circuit.ccx(qr_a[i], qr_b[j], qr_temp[j]) def elliptic_curve_addition(circuit, qr_p, qr_q, qr_result, qr_borrow, qr_control): &quot;&quot;&quot; Performs elliptic curve addition on the quantum circuit. &quot;&quot;&quot; num_qubits = len(qr_p) // 2 qr_x1, qr_y1 = qr_p[:num_qubits], qr_p[num_qubits:] qr_x2, qr_y2 = qr_q[:num_qubits], qr_q[num_qubits:] qr_slope = QuantumRegister(num_qubits, 'slope') circuit.add_register(qr_slope) quantum_subtraction(circuit, qr_y2, qr_y1, qr_slope, qr_borrow) quantum_subtraction(circuit, qr_x2, qr_x1, qr_result, qr_borrow) quantum_division(circuit, qr_slope, qr_result, qr_slope, qr_result, qr_control) quantum_multiplication(circuit, qr_slope, qr_result, qr_slope) def create_modular_inversion_circuit(num_qubits): qr_a = QuantumRegister(num_qubits, 'a') qr_n = QuantumRegister(num_qubits, 'n') qr_inv = QuantumRegister(num_qubits, 'inv') qr_carry = QuantumRegister(num_qubits, 'carry') qr_control = QuantumRegister(1, 'control') qr_borrow = QuantumRegister(num_qubits, 'borrow') cr = ClassicalRegister(num_qubits, 'output') circuit = QuantumCircuit(qr_a, qr_n, qr_inv, qr_carry, qr_control, qr_borrow, cr) for i in range(num_qubits): circuit.h(qr_a[i]) circuit.h(qr_n[i]) elliptic_curve_addition(circuit, qr_a, qr_n, qr_inv, qr_borrow, qr_control[0]) apply_kqft(circuit, qr_inv) apply_inverse_kqft(circuit, qr_inv) circuit.measure(qr_inv, cr) return circuit circuit = create_modular_inversion_circuit(num_qubits) print(circuit.draw()) simulator = AerSimulator() job = simulator.run(circuit) result = job.result() counts = result.get_counts() print(&quot;Measurement results:&quot;, counts) plot_histogram(counts)",<qiskit><programming><shors-algorithm>,05/08/2024 10:12,,,,
38211.0,Qiskit Code error,"I am new to Qiskit syntax codes. I ran the following code below and I got an error. Please I need help. from qiskit import Aer, execute from qiskit.aqua.algorithms import Shor from qiskit.aqua import QuantumInstance Number to factor N = 15 Set up the quantum instance to run the algorithm backend = Aer.get_backend('qasm_simulator') quantum_instance = QuantumInstance(backend, shots=1024) Use Shor's Algorithm from Qiskit shor = Shor(N) result = shor.run(quantum_instance) print(f&quot;The factors of {N} as computed by Shor's algorithm are {result['factors'][0]}&quot;) ERROR MESSAGE &quot; ImportError Traceback (most recent call last) Cell In[4], line 1 ----&gt; 1 from qiskit import Aer, execute 2 from qiskit.aqua.algorithms import Shor 3 from qiskit.aqua import QuantumInstance ImportError: cannot import name 'Aer' from 'qiskit' (C:\Users\ZALMA\anaconda3\envs\qiskit_env\lib\site-packages\qiskit_init_.py) &quot;",<qiskit><programming><shors-algorithm>,05/08/2024 20:39,,,,
38288.0,Particle number expectation value in QuTip,"I am learning now to use QuTiP by going through their documentation site. I am trying to understand what does the argument - particle number expectation value in thermal density matrix do? How does it affect the density matrix? I tried for different values of n ranging from 0 to 10 and 100 for a 4X4 matrix. For n = 0, I get a density matrix with only the first entry being non-zero (takes the value of 1). For 100, it's a diagonal matrix - each diagonal element has a value of 0.25. For the remaining values, I noticed that it gives the max eigenvalue for the first entry (I am guessing its due to the singular value decomposition in which you arrange the eigenvalues in decreasing order). Any suggestions would be appreciated.",<quantum-gate><programming><density-matrix><hamiltonian-simulation><qutip>,5/14/2024 10:00,,,,
38308.0,Custom classical control in qiskit,"I'm generating a qiskit circuit and want to add an X gate to a qubit if the sum of some previous measurements modulo 2 is equal to 1. In cirq, I could just use a sympy expression that would look something like X(q(10)).with_classical_controls(Mod(q1 + q4 + q7, 2)), where q10 is the qubit I'm applying the X correction to, and q1, q4 and q7 are the measurement who's sum I'm using to control this correction. How can I do this in qiskit?",<qiskit><programming>,5/15/2024 9:16,,,,
,,,,,,,,
125.0,How to define quantum Turing machines?,,<quantum-computing><turing-machines><computation-models>,03/08/2012 04:51,,216.0,"As the notes indicate, the way to define a QTM is to define the transition function as a unitary transform of state and letter. So in each step, you imagine multiplying the (state,letter) vector by a transformation to get a new (state, letter). It's not particularly convenient, but it can be defined.",03/11/2012 07:01
289.0,Universality of the Toffoli gate,,<quantum-computing><circuits><turing-completeness>,3/13/2012 6:22,,345.0,"Toffoli is universal for classical computation (as shown by @Victor). However, Toffoli is NOT universal for quantum computation (unless we have something crazy like $P = BQP$). To be universal for quantum computation (under the usual definition), the group generated by your gates has to be dense in the unitaries. In other words, given an arbitrary $\epsilon$ and target unitary $U$ there is some way to apply a finite number of your quantum gates to get a unitary $U'$ such that $||U - U'|| &lt; \epsilon$. Toffoli by itself is clearly not universal under this definition since it always takes basis states to basis states, and thus, for example, it cannot implement something that takes $|0\rangle \rightarrow \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$. In other words, it cannot create superposition.",3/14/2012 2:15
1595.0,What is the difference between classical crypto and post-quantum crypto?,,<reference-request><cryptography><quantum-computing>,4/30/2012 17:11,,1598.0,"I'm by no means an expert (or even close to that) on the topic, but from what I know: Classical cryptography depends on the intractability of factoring (or the discrete log problem). However, factoring is not believed to be NP-complete, and it is indeed solvable in polynomial time by quantum computers. So any cryptography that depends on those operations would break (which is every kind of cryptography used out there that I know of). Quantum cryptography depends on quantum mechanics, and it's theoretically impossible to break it. It's not a matter of time at all -- it's simply based on randomness, and the fact that a state collapses upon being measured, so without the appropriate information, your best choice is to simply 'guess' the message... which is useless.",4/30/2012 19:42
2718.0,What is the difference between quantum TM and nondetermistic TM?,,<computability><turing-machines><quantum-computing><nondeterminism>,7/13/2012 5:56,,2721.0,"As a general preamble, QTMs, TMs and NTMs are all different things (taking huge liberties with a bunch of unspoken assumptions). I'll assume you know what a Turing Machine is. A NTM is a TM where, at any state, with any symbol, the transition function is allowed to have a number of choices of action that is not precisely $1$, i.e. $0$ or more than $1$ (a deterministic TM must have exactly one action for each symbol at each state, though the $0$ case is easy to deal with). When faced with a situation where there are several choices of transition a NTM will make the choice that will ultimately take it to an accepting state, if such an option exists. In contrast a QTM is a model of quantum computation, as detailed in the thread you linked. It is not nondeterministic, not all. Probably the key high level differences between a QTM and a TM is that a QTM has as its state a linear combination of the basis states (again, it's all in that other thread) and that it's probabilistic, that is, the accuracy of its ouput is bounded by some probability less than $1$ (broadly speaking). Just to be really really clear on a point that catches many people, nondeterminism is not randomness, it's not parallelism, it's a theoretical construct that has nothing to do with either of those. The full answer to this depends on some complexity theoretic assumptions. Taking a particular standpoint (that $QMA \supset BQP$ and $NP \supset P$), the answer is yes. $NP$-complete problems can be solved by a NTM in polynomial time, and it also seems that $NP\text{-complete} \cap BQP = \emptyset$, so they can't be solved by a QTM in polynomial time. Again, this is all dependent on which way the cards fall with a variety of complexity classes. If it turns out that $QMA = BQP$ then the answer is no, for example. The first thing to say here is to be careful about confusing TMs (of any kind) and computers. A TM is not a computer, a QTM is not a quantum computer. TMs (of any kind) model computation. What a given computer can do is governed by this, but this is quite different to saying that the thing I'm typing this on is a TM. Having said that, if we speak loosely and lazily identify QTMs with quantum computers and TMs with standard computers, then (again under certain complexity assumptions) it seems that quantum computers can quickly do certain tasks that seem hard for standard computers (factoring, discrete logs, a really particular type of searching, and a couple of others). However these problems aren't known to be hard in the $NP$-complete sense either, it seems quantum computers offer capabilities that extend a standard computer, but in a different direction to what would be needed to solve $NP$-complete problems quickly. Again just to be really clear, I've glossed over a lot of computational complexity here, if you really want to understand how everything fits together, you'll need start digging in to the literature.",7/13/2012 9:00
6334.0,Tensor Product in Quantum Computation,,<quantum-computing>,10/24/2012 4:15,,6335.0,"A tensor product of operations, $I\otimes J$ say, acts on each subsystem separately: if $\phi$ and $\psi$ are states and $I$ and $J$ are operators then $$(I\otimes J)(\phi\otimes \psi) = (I\phi) \otimes (J\psi)$$ In bra-ket notation the state $\phi\otimes \psi$ can be denoted $|\phi\rangle|\psi\rangle$. In your first equation, the $\langle i|0\rangle\langle 0|k\rangle$ factor and $\langle j|I|l\rangle$ factor just separate in this way. The algebra behind the second equation is basically: $$(1+x^{2^0})\dots(1+x^{2^{t-1}})=1+x+x^2+x^2+\dots+x^{2^t-1}$$ except that the ""1"" is replaced by $| 0\rangle$, and the $x$ is replaced by $\exp(2\pi i \phi |1\rangle)$ (clash of my notation: $\phi$ is now a number). The only difference is that the multiplication is really a tensor product, and with bosons $|1\rangle\otimes |1\rangle=|2\rangle$.",10/24/2012 9:02
6296.0,References on comparison between quantum computers and Turing machines,,<computability><reference-request><turing-machines><quantum-computing>,10/24/2012 20:44,,6298.0,"What is actually the case is that anything a quantum computer can compute, a Turing machine can also compute. (This is without commenting at all on how long it takes the Turing machine to compute the function compared to a quantum computer.) This is actually not difficult to see, provided you understand quantum computation. For a quantum circuit over a typical gate set, for example, the outcome is governed by a probability distribution, which is determined by the coefficients of a unitary matrix. That unitary matrix is just a matrix product of those of the gates, and can be computed â if you're patient enough â by a classical computer. So for sheer computability (as opposed to efficiency), there is no advantage to using quantum computers. The whole challenge arising from quantum mechanics is to determine whether such coefficients can be computed efficiently, which is a more demanding problem than whether they can be computed at all.",10/24/2012 22:16
6296.0,References on comparison between quantum computers and Turing machines,,<computability><reference-request><turing-machines><quantum-computing>,10/24/2012 20:44,,6305.0,"Consider a quantum gate. Smoothing out all the technical details, it can be represented as a matrix $G$. An input to the gate, say $\vert \phi \rangle$ is just a vector $v$, and the output of the gate is the vector $Gv$. Now, consider a circuit. A circuit is just a bunch of gates $\{G_1, G_2, ... \}$, and the circuit itself can be seen as a ""generalized gate"" $C=G_n \cdots G_2 G_1$, which operates on the input state (the vector $v$). [Again, this is a very coarse abstraction.] So basically, computing a circuit on an input $\vert \phi \rangle$, is merely computing the vector $Cv$ or $ G_n \cdots G_2 G_1 v$. It's clear that such a task (matrix multiplication and multiplication of matrix by vector) can be done by a classical TM, therefore, TM is at least as strong as a quantum-TM (QTM) [ok, classical circuits are as strong as quantum circuits. nevermind that.] On the other hand QTM is trivially as strong as TM, and therefore, both models are equivalent. EDIT due to comments In order to ask which ""computer"" is more powerful, we need to first clarify what it means to be more ""computationally powerful"". And this semi-philosophical discussion begins with the question What is computation? Is ""playing MP3"" files a computation? Is outputting random numbers a computation? The standard definition says that a computation is ""computing a function"". That is, for every input $x$ (which can be any string of any finite length), output $y=f(x)$, where again $y$ can be a string of arbitrary (finite) length. If your computer can output $y$ for any $x$, we say that it can compute $f$. Now, to say that computer ""A"" is more powerful than ""B"" just means that A computes more functions $f$ than $B$. Similarly, Two models, $A$ and $B$ are considered equivalent if, for any function $f$, $A$ computes $f$ if and only if $B$ computes $f$. OK, you say, but wait a second, there is randomization.. A quantum computer does not just output $y$. It outputs $y_1$ with probability $p_1$, or $y_2$ with probability $p_2$, or ....$^0$ Indeed.. And this extends the standard definition of computing a function. We can resolve it, and generalize our definitions in several ways. (1) one option is to say that the answer of $f(x)$ is that specific $y_i$ that has probability $p_i&gt;0.75$ (and there is at most one such value)$^1$. If we Assume that $f$ outputs only a single bit, then ""the output of $f(x)$ is always well defined$^2$. Otherwise, if no such value exists, and all the outputs have small probability we can say $f$ is not defined on that input; (2) A second option is to say that the output of $f(x)$ is the list $(y_1,p_1), (y_2,p_2),...$. For this to be well defined, we must have a finite list, since we required the output string to be finite. With the above, it should be clear that having probabilities doesn't change the power of the model, and a classical TM can just output the list of possible outputs along with the probability for each output. this is exactly what happens when a TM multiplies matrices and outputs a vector â the vector represents the probability of each and every possible measurement output. $^0$This issue is not unique to quantum computing. Classical probabilistic computing ""suffers"" from the same issue. $^1$Why $p=0.75$? No reason. Any constant larger than $1/2$ would work. $^2$Why assuming $f$ outputs one bit? because it is enough.. We can reduce any more complex function to one or more functions with a single-bit output. But this doesn't matter to our discussion.",10/25/2012 2:51
6408.0,Quantum computing 'amplitudes',,<quantum-computing><computation-models>,10/31/2012 21:53,,6409.0,"Let me answer by an example that might be helpful for understanding this issue (without formally answering your question). Assume that you put ""15"" as an input into a quantum-algorithm that factors numbers. Now, the output $\lvert \phi \rangle \in (\mathbb{C^2})^{\otimes3}$ is a 3-qubit state (representing an integer in [1,8] in the computational basis), which has the following probabilities (""amplitudes"") when measured ($M$) in that basis: $\lvert \phi \rangle \stackrel{M}{\to} 1$ w.p. $p_1=0$ $\lvert \phi \rangle \stackrel{M}{\to}2$ w.p. $p_2=0$ $\lvert \phi \rangle \stackrel{M}{\to}3$ w.p. $p_3=0.5$ $\lvert \phi \rangle \stackrel{M}{\to}4$ w.p. $p_4=0.001$ $\lvert \phi \rangle \stackrel{M}{\to}5$ w.p. $p_5=0.499$ $\lvert \phi \rangle \stackrel{M}{\to}6,7,8$ w.p $p_6=p_7=p_8=0$ (numbers are just for fun.. Not real numbers) Does it make sense how the output's probabilities are actually very relevant to the problem?",10/31/2012 22:02
6408.0,Quantum computing 'amplitudes',,<quantum-computing><computation-models>,10/31/2012 21:53,,6438.0,"The state of a qubit, or of a collection of qubits, is given by a state vector. However, most people would say that the output of a quantum computer is in fact the result of a measurement, which transforms the state into one which indicates a single outcome. There are many ways to approach this, but the simplest one to describe mathematically is complete measurement in the standard basis. In this case, you transform a quantum state on $n$ qubits into an $n$-bit string. Suppose that you have a state $|\psi\rangle \in \mathbb C^{2^n}$ on $n$ qubits, given by $$ |\psi\rangle \;=\; \sum_{x \in \{0,1\}^n} \!u_x \;|x_1 x_2 \cdots x_n \rangle \;, \quad \text{such that } \sum\limits_{x\in\{0,1\}^n} \!|u_x|^2 = 1 .$$ In order to get a classical output from a quantum computer, one thing you can do is to perform a complete measurement in the standard basis. What this means is that we collapse the state to some single output vector $y \in \{0,1\}^n$. We get different bit-strings $y$ with different probabilities, governed by the formula $$ \Pr\nolimits_\psi(y) \;=\; \Bigl| \langle y | \psi \rangle \Bigr|^2 \;=\; \left| \sum_{x \in \{0,1\}^n} \!u_x \; \langle y_1 y_2 \cdots y_n | x_1 x_2 \cdots x_n \rangle \right|^2 \;=\; \left| u_y \right|^2 \;. $$ The outcome is then just a random output string $y \in \{0,1\}^n$, where the probabilities are given by the non-negative real numbers $|u_y|^2$. Afterwards, you can compute with the measurement result $y \in \{0,1\}^n$ however you like, with a classical computer. It's possible to describe performing a measurement only on a single bit, or with respect to bases other than the standard basis, but that's not really necessary to answer your question; measuring all of the qubits is certainly something you can do, and it's enough to get classical outputs from quantum computations.",11/02/2012 00:20
10616.0,Controlled NOT gate a type of measurement?,,<quantum-computing>,3/18/2013 15:04,,10619.0,"A controlled-NOT gate is meant to be a reversible operation which, for ordered pairs of bits $(a,b) \in \{0,1\}^2$, performs the operation $$ \mathrm{CNOT} (a,b)\; = \;(a, b \oplus a)$$ where conventionally we represent the ""control"" by the first bit and the ""target"" by the second. (In a physical implementation, essentially the same physical interaction but in a different orientation would be used to implement the transformation $(a,b) \mapsto (a\oplus b, b)$ and so this is also called a ""controlled-NOT"", rarely with any distinction from the one described above.) This gate is obviously reversible, as one can easily verify that $\mathrm{CNOT} \circ \mathrm{CNOT} = \mathrm{id}\,$. As is usual in quantum computation, we ""lift"" reversible operations such as $\mathrm{CNOT}$ to distributions over inputs by describing it as a permutation of computational basis states. In particular, because $$\begin{align*} (0,0) \;&amp;\xrightarrow{\;\mathrm{CNOT}\;\;}\; (0,0) \\ (0,1) \;&amp;\xrightarrow{\;\phantom{\mathrm{CNOT}}\;\;}\; (0,1) \\ (1,0) \;&amp;\xrightarrow{\;\phantom{\mathrm{CNOT}}\;\;}\; (1,1) \\ (1,1) \;&amp;\xrightarrow{\;\phantom{\mathrm{CNOT}}\;\;}\; (1,0) \end{align*}$$ the permutation matrix which we use to represent $\mathrm{CNOT}$ is $$ \mathrm{CNOT} \;=\; \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\; .$$ It is easy to verify that this (and all other permutation matrices) are unitary. This is the operation which transforms the state of the first two qubits. Because the state of those two qubits just before the $\mathrm{CNOT}$ gate is given by $$ |\psi_1\rangle \;=\; (H \otimes \mathbf 1) |0\rangle |0\rangle \;=\; \tfrac{1}{\sqrt 2} \Bigl[ |0\rangle |0\rangle + |1\rangle |0\rangle \Bigr] \;=\; \tfrac{1}{\sqrt 2} \begin{bmatrix} 1 \\ 0 \\ 1 \\ 0 \end{bmatrix} \,,$$ the state that we obtain afterwards is given by $$ |\psi_2\rangle \;=\; \mathrm{CNOT} |\psi_1\rangle \;=\; \tfrac{1}{\sqrt 2} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \\ 1 \\ 0 \end{bmatrix} \;=\; \tfrac{1}{\sqrt 2} \begin{bmatrix} 1 \\ 0 \\ 0 \\ 1 \end{bmatrix} \;=\; \tfrac{1}{\sqrt 2} \Bigl[ |0\rangle |0\rangle + |1\rangle |1\rangle \Bigr] \,.$$ In this case, it's probably easiest to see that you can apply the action of $\mathrm{CNOT}$ on the standard basis states $|0\rangle|0\rangle$ and $|1\rangle|0\rangle$ separately, which form the components of $|\psi_1\rangle$, to obtain components $|0\rangle|0\rangle$ and $|1\rangle|1\rangle$ respectively; this is possible because the $\mathrm{CNOT}$ operation (and all other permutations and unitary operators) is linear.",3/19/2013 14:28
11026.0,What is the relation between P vs. NP and Nature's ability to solve NP problems efficiently?,,<complexity-theory><quantum-computing>,3/30/2013 19:28,,11037.0,"I had a neural computation professor once that pointed out an excellent example of how ""analog"" techniques could be used on embarrassingly parallel problems to reduce the asymptotic bound of a computation: Take a bundle of sticks of different sizes. There are many algorithmic ways to sort that bundle of sticks from longest to shortest with O(n*log(n)). An ""analog"" way to sort that bundle of sticks would be to stand them on end and let the sticks rest one end on a table (1 step). Now you have all the sticks with one end at the same level against the table. Take your hand and place it on top -- it will hit the longest, remove that stick and repeat for N steps. This process is O(N + 1) which is O(N). The key here was stacking the sticks on end -- a massively parallel solution to order the other ends of the sticks along the z-axis (up). This is a neat thought experiment and can give an idea how analog solutions can reduce the asymptotic bound of an algorithm in a simple manner. Two huge caveats here: 1) We haven't taken an NP problem to a P problem with this example (more on that later) and 2) if you used N processors to sort N items you could sort the numbers in O(log n) time (with a big constant), so the reduction is not magical. Sometimes the analog resources needed solve a problem in a highly parallel manner are cheap. Another example of a cheap resource would be neurons (biological) for complex learning and pattern recognition. Neurons can also put the apparent NP => P into perspective. NP problems are NP to find the optimal solution. You can find a ""good enough"" solution in P time that will work fine in nature. Evolution selects for highly efficient solutions that are ""good enough"". Think about how good the average person is at identifying objects in almost O(1) time. That's because there is a lot of parallel processing going on, and your brain still doesn't always come up with the optimal solution. For example, optical illusions, or forgetting where you put your keys (which would easily be O(1) for a computer!). Another point with NP vs P in nature: solving NP to find the optimal solution is not the same as identifying the optimal solution. Identification of an optimal solution to an NP problem can be done in P time. Again recognition of a ""good enough"" solution will work rather than an optimal solution. Take the example of protein folding -- this is an example of nature doing all of the above. It takes advantage of molecular interaction forces that all work in parallel (no need for the natural folding ""algorithm"" to address one atom at a time as a computational algorithm does). Also, there is no guarantee that the (functionally) optimal solution to the protein folding will be found. There are many examples of diseases due to protein misfolding. As @PeterShor pointed out sometimes the ""natural"" algorithm doesn't work at all (leading to a thermodynamically optimal solution, but not a functional one). That is where chaperone proteins come in -- they guide the folding into the correct functional form (a thermodynamic local minimum). Correctly formed proteins also interact with other proteins for transport to the right location so the ""bad"" ones (where the heuristic algorithm didn't actually solve the NP problem) are often degraded without being transported anywhere. All of these transports and folding mechanisms are happening with massive parallel pipes. Multiple transcription and processing mechanisms are simultaneously converting DNA->RNA->Protein at different points on a gene sequence. Every cell in your body is doing the same (but with different chemical messages about what to produce). So, in short: How does nature do it? Tricks and Parallelism. Generally it's not actually turning an NP problem into P, it's just making it look easy.",04/05/2013 03:46
11218.0,The physical implementation of quantum annealing algorithm,,<algorithms><randomized-algorithms><quantum-computing>,04/11/2013 07:05,,11455.0,"The approach to quantum computing that you are referring to is something called the adiabatic model. It's actually based on continuous time evolution of quantum systems, rather than on discretized-time models (i.e. no gates). It turns out that it is possible to approximate continuous time evolution with a discrete set of gates, and so the algorithm can be implemented in any universal model of quantum computation. In order to understand the algorithm and how it works, you need to know some physics. A Hamiltonian, $H$, is an observable which corresponds to the total energy of the system. Any eigenstate, $\psi$, of $H$ corresponds to a configuration of the system for which there is a definite energy, $E$, equal to the corresponding eigenvalue of $H$. The dynamics of a quantum system are determined by its Hamiltonian, and for a fixed Hamiltonian, the evolution is given by $\psi(t) = e^{-iHt/\hbar}\psi(0)$. The adiabatic algorithm is based on the adiabatic theorem, which roughly speaking, states that if you start in the ground state (the lowest energy state of the system) of some Hamiltonian $H_0$ and slowly change the Hamiltonian as a function of time, then you will continue to remain in the ground state (or rather very close to it) of the instantaneous Hamiltonian, provided that the speed at which the Hamiltonian changes is sufficiently slow. How slow this must be depends on the minimum gap between the ground state and the next lowest energy level, and varies from one Hamiltonian to the other. The adiabatic algorithm is simply to start in the ground state of some simple Hamiltonian, $H_0$, for which the ground state is easy to prepare, and slowly interpolate between it and some target Hamiltonian, $H_1$, which encodes in its ground state the solution to the problem you are trying to solve. Thus, the time varying Hamiltonian may look something like $H(t) = (1-t/T)H_0 + (t/T)H_1$, where $T$ is the total time for the adiabatic evolution. As long as $T$ is sufficiently large, the adiabatic theorem guarantees that the resulting state at time $T$ will be very close to the ground state of $H_1$. It should be noted that the linear interpolation above is certainly not the only possible choice, and indeed looking for better paths between $H_0$ and $H_1$ is an active area of research, since the path determines the minimum value which can be taken by $T$. None the less, the above should give you a taste of how the algorithm works.",4/20/2013 18:08
11471.0,The difference between a bit and a Qubit,,<terminology><quantum-computing>,4/21/2013 17:55,,11472.0,"In Quantum theory, a Qubit has an extra state (superposition) which differentiates it from a regular bit. A regular bit can have states 0 (""off"") or 1 (""on""). A Qubit, can have one extra state, which is a superposition of both 0 or 1. This is essentially a ""do not know"" state (or both), since we don't know whether it will be a 0 or a 1. However, there are probabilities in which it can be a 0, or can be a 1. When observed, it can be decided if it's a 0 or a 1.",4/21/2013 18:20
11471.0,The difference between a bit and a Qubit,,<terminology><quantum-computing>,4/21/2013 17:55,,11477.0,"Probably the easiest analogy is to probabilities. If your computer can flip fair coins, you can think of each coin being in state Tails with probability 1/2 and in state Heads with probability half. So it's appropriate to think of a coin not as a bit but as a vector of two elements $(p_T, p_H)$, where $p_T$ is the probability of tails, $p_H$ is the probability of heads and we have that $p_T \geq 0$, $p_H \geq 0$, and $p_T + p_H = 1$. Once we sample a coin its state ""collapses"" to either tails or heads. Just about the same happens with qubits. You can also think of quibit as being ""in between"" two states. It's also easiest to think of qubit not as a bit but as a vector of two elements $(q_0, q_1)$. Now, however, we allo $q_0$ and $q_1$ to be negative, and even further, to be any two complex numbers, as long as $|q_0|^2 + |q_1|^2 = 1$. Just as with sampling coins, once you measure a qubit, it collapses to either $0$ or $1$, and in fact you get $0$ with probability $|q_0|^2$ and $1$ with probability $|q_1|^2$. However, and this is the crucial part, these quantum probabilities can be made to cancel each other because they take negative values; this cannot happen with classical probability. This is the power of qubits. BTW these complex valued quantities describe amplitudes and are related to the wave-particle duality, i.e. the discovery that particles in fact behave as waves, until you measure them, and then they behave as particles. The cancelation I am talking about is in fact interference between waves. So another answer to your question is that a qubit is not a discrete object that's either in one state or not, it's a wave..until you measure it.",4/21/2013 21:03
12892.0,"Quantum computers, parallel computing and exponential time",,<complexity-theory><time-complexity><quantum-computing>,6/25/2013 15:36,,12894.0,"Why can't a quantum computer solve exponential problems in sub-exponential time? Factoring is believed (by some) to take classical time $2^{n^\epsilon}$ for some $\epsilon &gt; 0$, while Shor's algorithm takes time $O(n^3)$. Does that count? Is it at least theoretically possible to imagine a computer able to solve EXPTIME-complete problems in constant time? Sure, consider a Turing machine with oracle access to all EXPTIME problems (i.e. the oracle accepts the code of an EXPTIME machine and an input, and returns the output). This doesn't lead to any contradictions. Is this realizable in practice? Probably not. Can quantum computers do parallel computing? It is known that BQP$\subseteq$PP$\subseteq$EXPTIME, and most people expect these inclusions to be proper. Under this conjecture, there are problems solvable in classical exponential time but not quantum polynomial time. In particular, EXPTIME-complete problems shouldn't be in BQP.",6/25/2013 17:07
13513.0,Finding all marked elements using Grover's algorithm,,<algorithms><quantum-computing>,7/30/2013 11:06,,13554.0,"This approach suffers from a couple of problems. First of all, Grover's algorithm in its usual form depends on the fact that there is exactly one good item in the search space, so you'll need to modify it to account for the fact that there are now several. Second of all, you ought to justify whether or not you can easily delete arbitrary elements from the database. The oracle function $f$ need not be (indeed probably won't be) a literal lookup in a literal database. One good example might be an $f$ that tells you whether $x$ is a factor of $N$ for some $x$ and $N$ integers. You can't just stop $x$ from being a factor of $N$ once you find it, but you might well be able to use $f$ to manufacture a new function that tells you when $y$ is a factor of $N$ that is not $x$. If you can come up with a function that flips the $x$ component of the state, then you can just do $f$, which flips the $x$ component, and then flip it back, to get the desired modified indicator. You ought to think about whether you really need to do that, though. You're working with a probabilistic algorithm anyway, so it probably wouldn't hurt to get the same answer twice a few times.",08/01/2013 01:41
13513.0,Finding all marked elements using Grover's algorithm,,<algorithms><quantum-computing>,7/30/2013 11:06,,13615.0,"After discussing the problem with some people from my institute that work on quantum computing, it turns out that one can augment the oracle to not provide elements that have already been found in previous iterations of the search. The trick is to modify Grover's algorithm as follows: Say, we already know that 2 is an answer (from a previous iteration). After using the oracle to invert the phase of the marked elements within Grover's algorithm, we apply another operation that inverses the phase of the known answers again (thus cancelling the previous inversion for answers that are already known). Accordingly, the inversion about the mean in Grover's algorithm will not amplify the amplitude of these states.",08/05/2013 15:00
13528.0,What is meant by an oracle separation between classes $\mathsf{BPP}$ and $\mathsf{BQP}$?,,<complexity-theory><quantum-computing><oracle-machines>,7/30/2013 23:54,,13531.0,"An oracle is just a theoretical device which will provide the answer to a given class of decision problems in a single step. We say that a decision problem is in $BPP$ relative to the oracle if a turing machine (or whatever model of computation you are using) with access to the oracle can answer the decision problem in a polynomial amount of time with bounded probability of error. Similarly, a problem is in $BQP$ relative to the oracle if a quantum turing machine with access to the oracle can answer the decision problem in a polynomial amount of time with bounded probability of error. This is closely related to the notion of oracle you know. An oracle which can solve the halting problem is a (very powerful) example of an oracle. Usually when one is talking about such an oracle, one wants to know what problems are in $R$ relative to the oracle, i.e. are computable by a turing machine with access to the oracle.",7/31/2013 2:34
13528.0,What is meant by an oracle separation between classes $\mathsf{BPP}$ and $\mathsf{BQP}$?,,<complexity-theory><quantum-computing><oracle-machines>,7/30/2013 23:54,,13532.0,"No, an oracle is a black box that solves a problem in a single step. The problem that it solves can be any problem, it doesn't need to be the halting problem. What Scott is saying is that there is some black box that a BQP machine with it can do more than what a BPP machine can do with it. However, it doesn't mean that without that black box BQP is more powerful than BPP. A simpler case is P vs. NP. By Baker, Gill, and Solovay's result there is a black box that P with that black box is not equal to NP with that black box. But it doesn't tell us much about what should be the answer to P vs. NP.",7/31/2013 2:35
13528.0,What is meant by an oracle separation between classes $\mathsf{BPP}$ and $\mathsf{BQP}$?,,<complexity-theory><quantum-computing><oracle-machines>,7/30/2013 23:54,,97449.0,"It depends. If $\mathrm{BPP} = \mathrm{BQP} = \mathrm{EXP} = \mathrm{EXP}^\mathrm{NP}$, then any oracle separation result would necessarily go beyond $\mathrm{ELEMENTARY} = \cup_{k} k-\mathrm{EXP}$. Indeed, $\mathrm{BPP}^\mathrm{EXP} = \mathrm{BQP}^\mathrm{EXP} = \mathrm{PP}^\mathrm{EXP} = \mathrm{EXP}$. Going further, we also have $\mathrm{BPP}^\mathrm{EEXP} = \mathrm{BQP}^\mathrm{EEXP} = \mathrm{PP}^\mathrm{EEXP} = \mathrm{EEXP}$. And so on, and on, ad astra. So, with current mathematical arsenal, we can only hope to construct a separating oracle with at least some non-elementary logic. On the other hand, if $\mathrm{BPP} \neq \mathrm{BQP}$ holds, then a trivial separating oracle exists, namely $\emptyset$.",9/17/2018 12:50
14442.0,How does Grover's Quantum Sorting avoid reading the list?,,<algorithms><sorting><quantum-computing>,9/19/2013 14:55,,14445.0,"The list (or database) is given implicitly by an ""oracle"" function, which is called $\Theta(\sqrt{N})$ times throughout the algorithm. Suppose for example you're looking for a divisor of some number $N$. Then the function could map $k \leq \sqrt{N}$ to true if $k$ is a non-trivial divisor of $N$, and false otherwise. Grover's algorithm will then find a non-trivial divisor of $N$ in time $\tilde{O}(\sqrt[4]{N})$ instead of the usual $\tilde{O}(\sqrt{N})$ (note that better algorithms are available in this case, even for a classical computer).",9/19/2013 17:34
16684.0,Shor's Algorithm speed,,<time-complexity><quantum-computing><factoring>,11/04/2013 00:54,,16685.0,"What you are asking for does not exist, for good reasons. Today there is no existing computer that can execute Shor's algorithm. To run Shor's algorithm, you need a quantum computer, which doesn't exist yet. Therefore, you shouldn't expect precise estimates of its speed or running time, as that will depend upon the details of the computer that the algorithm is run on -- and we can't possibly know those details until we've successfully built one.",11/04/2013 01:13
19519.0,Simple explanation of Simon's Problem,,<algorithms><quantum-computing>,01/05/2014 23:55,,19521.0,"I think there are really three issues buried in your question. What's Simon's Problem? What's a plain english description of the function involved in Simon's Problem? Why isn't this problem a cryptographic primitive? I can't really speak to 3 as cryptography is not my area. I can take a crack at 1 and 2 for you though. The distinction between 1 and 2 is, I think, important. Simon's problem is one of discovering the parameter to a function given a black-box to that function and some basic information about the function. So, an algorithm to solve this problem takes as its input a black-box to a function and gives a output a binary string. Our goal is to reduce the number of queries to that black box. I think people tend to miss this point and focus on the internals of the function itself. All we know about the function $f$ is that our black-box can compute it for us in constant, $O(1)$, time, and that if $f(x) = f(y)$, then either $x=y$ or $x \oplus y = s$. We want to know the value of $s$. A brute force, classical computing solution might give you a better feel for the problem. Here it is: Feed all $n$ bit binary strings to the black-box and save each input-output pair to a table. If no two inputs produce the same output then it must be the case that the parameter $s$ is $n$ bit $0$. Otherwise, two inputs will produce the same output and $s$ is the result of XOR'ing those inputs together. In the worst case, we have to query all $2^n$ inputs leading to $O(2^n)$ query complexity. Querying the black-box is at the heart of Simon's problem. We need not concern ourselves with how to construct the black-box, i.e. how to compute $f$, as that is not what the problem is about. I don't believe that Simon's problem is practically useful beyond the fact that it helps establish some complexity results about Quantum Computers. It's main significance is that it was an inspiration for Peter Shor's factoring algorithm.",01/06/2014 00:57
19519.0,Simple explanation of Simon's Problem,,<algorithms><quantum-computing>,01/05/2014 23:55,,19522.0,"What the article means by $$f : \{0,1\}^n \rightarrow \{0,1\}^n$$ is that the input and output of the function is a binary string of length $n$. As for the problem itself, the idea is that we have such a function $f$ with the added property that there is a special string $s$ such that for any two binary strings of length $n$, if the function gives the same result when passed either of them, they are either (1) equal or (2) give $s$ when XOR'ed together. The actual problem is: given the function (as a black box), find what $s$ is. I can't say for certain why this isn't used as a cryptographic primitive, but there's at least one potential reason that I can see: we haven't taken into account the time it takes to actually construct such a function in the first place. If making such a function is equally (or even more) difficult; then it's much easier to imagine why it wouldn't be used.",01/06/2014 01:06
21727.0,Why and how is a quantum computer faster than a regular computer?,,<quantum-computing>,2/17/2014 7:41,,21732.0,"The basic idea is that quantum devices can be in several states at the same time. Typically, a particle can have its spin up and down at the same time. This is called superposition. If you combine n particle, you can have something that can superpose $2^n$ states. Then, if you manage to extend, say, bolean operations to superposed states (or superposed symbols) you can do several computations at the same time. This has constraints but can speed up some algorithms. One major physical problem is that it is harder to maintain superposition on larger systems.",2/17/2014 10:20
21727.0,Why and how is a quantum computer faster than a regular computer?,,<quantum-computing>,2/17/2014 7:41,,67571.0,"Think of it this way: There are problems that can be solved by solving a whole lot of individual sub-cases [example: factoring by trial division]. These problems take a long time to solve if one has to solve the sub-cases one after another. They can be solved much faster if one can provide enough hardware to solve all of the sub-cases in parallel, but that is not practical because the amount of hardware needed increases with the problem size. Quantum computing exploits the superposition-of-states feature of Quantum Mechanics to simulate providing enough hardware - i.e each state in the superposition is 'the machine' for one of the sub-cases. Note that this simulation is done NOT by software, but by Nature itself.",12/17/2016 22:43
21727.0,Why and how is a quantum computer faster than a regular computer?,,<quantum-computing>,2/17/2014 7:41,,116007.0,"A quantum system is a system that exists in a quantum state(s) at different probabilities determined by environmental constraints. Assuming that a quantum computer contains all the states of an n-bit quantum system the extraction of one of these states collapses the system to one of the states. This is akin to a hash function using O(1) to search for a bucket without iteration. Two things are needed, quantum storage of the n-bit systems and a hash-like function to collapse the state that is needed. The constrains play the role of different hashing functions for collapsing the n-bit system into the wanted state.",10/19/2019 16:41
21744.0,Qubits Related to RAM?,,<memory-management><quantum-computing>,2/17/2014 22:52,,21745.0,"This coincidence just shows that the function $n \mapsto 2^n$ shows up in many places. For example, an $n$ bit register can store up to $2^n$ different values. If wireless frequency is parametrized using $n$ bits, then there are up to $2^n$ possible frequencies (in fact, there are probably a bit less). If an IP address is $n$ bits, then there are at most $2^n$ possible IP addresses (in fact, there are fewer). If a cryptographic key is $n$ bits long, then there are $2^n$ possible keys. And so on.",2/18/2014 0:15
22856.0,Is Quantum Computer analog?,,<quantum-computing>,3/20/2014 9:01,,22868.0,"In general, a quantum computation is thought of as a digital computation, however there is a variant of quantum computer called a ""continuous variable quantum computer"" or CVQC, that can be considered an analog computer. I believe they are primarily used in quantum simulation, but they are not something I have studied, so I don't know much more about them than the acronym. With that said, there are things about ""digital"" quantum computers that seem very analog. For example, say you start with a quantum register in the ground state, and then you evolve the state unitarily, and finally measure the state. In some sense, you started with a zeroed out array of classical bits, and ended with an array of classical bits which were the result of the computation, but the unitary evolutions in-between seem very analog. They must be modeled with complex matrices, and the states resulting from the unitary transformations have real amplitudes, etc. But because the output is clearly digital, we consider it a digital computation. If we could ""measure"" electron spin wrt an axis (for instance) and get an arbitrary real value, then quantum computing would be analog... But then we would be living in some other universe, with even weirder physics :P",3/20/2014 15:14
22856.0,Is Quantum Computer analog?,,<quantum-computing>,3/20/2014 9:01,,104480.0,"I believe I understand the basis of your question: The information encoded in one bit in an ordinary modern computer can be described by two (binary) values, commonly written as 0 or 1 or (better for the point at issue) as +1 or -1. However, if you wish, this can be depicted graphically as something being at the north pole or the south pole of an Earth-like sphere. This would be a needlessly elaborate way of depicting how a bit holds information, but it is legitimate. Would navigators bother to use an analog globe if they existed only on the two poles? The information encoded in a quantum computer cannot be written as either a +1 or -1, fundamentally because the information encoded in a qubit (the quantum-computer equivalent of a bit) can have any value between +1 and -1. One way of depicting this is on a sphere that, like a globe, has analog latitude and longitude markings. Such a sphere can be the Bloch sphere, a unit sphere borrowed from solid spherical geometry and trigonometry. We can give such a sphere lines of latitude and longitude. The bad new is that encoding a point between the poles now entails less familiar trig and complex numbers. The good news is that any such point can be clearly evaluated, including for describing the information encoded in a qubit. Yes, in effect this Bloch sphere resembles an obviously analog globe! In this sense I agree; quantum computers can be envisioned as relying on analog mathematical tools.",2/17/2019 20:12
22856.0,Is Quantum Computer analog?,,<quantum-computing>,3/20/2014 9:01,,159120.0,"This is an interesting question. I partially agree and partially disagree with previous answers so maybe it is worth adding mine. Of course, a QC is different from old-time analog computers, but only because of its &quot;quantumness&quot;, which has little to do with its being analog vs digital. A QC is definitely not a digital system, in any meaningful way. It lacks all the fundamental characteristics that I would say characterize a digital system: Differently from an analog system, a digital one partitions the continuum of possible configurations in a set of discrete ranges (or logic levels if you like to think about 0s and 1s); The computing system continuously projects its configuration on one of the conventional discrete ones. This happens at every single logic gate. Take the NOT gate, whenever the input voltage is above V_IH, the gate interprets the input as &quot;1&quot; and projects the output to the conventional &quot;0&quot;; The crucial benefit (why do digital systems exist, in the end?) of this whole procedure is noise immunity, and one cost is dissipation. A QC does not fit well in any of these points. Forget about the existence of qubits: this is about irrelevant. The fact that the wavefunction of a QC is given by the product of the wavefunction of many qubits simply sets the basis of the Hilbert space, but a quantum memory can (and has to be able to) exist in an uncountable number of configurations represented by all the complex amplitudes that describe its wavefunction. Take even a one-qubit memory: it can exist in an infinite number of superpositions of 0 and 1, that are on a one-to-one correspondence with the points of the surface of the Bloch sphere... which are definitely uncountable. This is very different from a bit, which can only have two configurations. In addition, there is no projection at every quantum gate, and surely no dissipation. Quantum computing is even reversible, in principle: this is the opposite of a dissipative system. A QC indeed needs to preserve the full quantum information of its qubits, all the amplitudes, entanglements, and so on, which are pretty much continuous. It only projects its configuration on one of the classic states at the end of the calculation, at the read-out stage. In short, a QC is a (quantum) analog computing system. EDIT - About quantum parallelism. This is sometimes brought up, and summarized as &quot;a QC somehow is performing many (digital?) computations in parallel&quot;. This is a compelling and very communicative view, but I think it easily leans toward the misconception. This is a tricky concept. A QC performs its computation on a &quot;superposition&quot; of configurations of a digital classic computer. First of all, this is not the superposition most people think about: this is a quantum superposition and one has no access to the results of the individual calculation... actually, the result of the individual calculation does not even exist, since during the calculation intermediate and final results will be in quantum superposition and give rise to interference... One can only interrogate (statistically) the final result, which depends on the coefficients that describe the superposition. In my view, the only important question in the analog vs digital discussion is &quot;how information is encoded?&quot;. In a standard computer, it is encoded in the state of the memory, which is definitely digital. My DNA also encodes information in a digital form. A QC does not. To be direct, consider an 8-qubit quantum memory. The qubits just set the basis of the Hilbert space, which will be 00000000, 00000001, and so on: a 256-dimensional Hilber space. The information contained in the memory is encoded in the density matrix, which is a 256x256 hermitian matrix, with a very large number of analog amplitudes. Not digital, those amplitudes are not segmented in any way in a discrete set of conventional intervals. In the end, if a QC were digital, people would not fight so much with error correction. Noise immunity is the main reason for the existence of digital systems.",3/18/2023 17:13
22856.0,Is Quantum Computer analog?,,<quantum-computing>,3/20/2014 9:01,,159469.0,"Yes and No. Dictionary Definitions from Oxford Languages Â· Learn more anÂ·aÂ·log adjective adjective: analogue; adjective: analog relating to or using signals or information represented by a continuously variable physical quantity such as spatial position, voltage, etc. &quot;analog signals&quot; (of a clock or watch) showing the time by means of hands rather than displayed digits. not involving or relating to the use of computer technology, as a contrast to a digital counterpart. &quot;old-school analog paper map skills&quot; noun noun: analogue; plural noun: analogues; noun: analog; plural noun: analogs a person or thing seen as comparable to another. &quot;an interior analogue of the exterior world&quot; Chemistry a compound with a molecular structure closely similar to that of another. &quot;thioacids are sulfur analogues of oxyacids&quot; When we look at the meaning of analog, then when we apply it to computing, it just means using something analogous to the real world. Or a model. And as many have said, the model may have flaws, or not account for certain unknown aspects of reality. That being said, I recall reading in a magazine called Analog Computing in the 80's, that a true analog computer would be able to make use of the entire EM spectrum as inputs and outputs. I don't think we are there yet by that definition, but that may be a pipe dream.",04/04/2023 22:49
23162.0,Quantum Computing and Turing Machines: Are Turing Machines still an Accurate Measure?,,<turing-machines><quantum-computing>,3/28/2014 3:34,,23164.0,"You're mixing up computability theory (also known as recursion theory) and complexity theory (or computational complexity). Computability theory is a vast mathematical subject which studies the ramifications of the concept of computation. It does not deal with the complexity of computation. As your professor mentions, all (Turing-complete) computation models are the same from the point of view of computability theory. Computability theory, while an interesting mathematical subject, is not a good model for real-world computation for this reason, as you mention. Complexity theory started its life as an attempt to address this issue. Complexity theory studies how difficult it is, in terms of time and space, to compute certain predicates and functions. From the point of view of complexity theory, not all computation models are the same, and Turing machines are taken as the reference model. However, even complexity theory is not very realistic, since it treats all computational models polynomially equivalent to Turing machines in the same way (two models are polynomially equivalent if any problem solvable in time $T(n)$ and space $S(n)$ in one model can be solved in time $T(n)^c$ and space $S(n)^c$ in the other, where $n$ is the input size and $c$ is some positive constant). For example, Turing machines are not good models for real computers since they do not support random access (accessing an arbitrary point in memory in time $O(1)$). Of course, random access can be simulated by a Turing machine, but the simulation can be slow. It is often said that sorting can be done in time $O(n\log n)$, but this is not the case for Turing machines, which probably require $\Omega(n^2)$ or move even for sorting integers. Therefore in the area of algorithms, other models such as the RAM machine replace Turing machines. Finally, quantum computers can be modelled in several different ways, such as the quantum Turing machine. Everything computable using quantum computers is also computable using classical computers, and so from the point of view of computability theory, quantum Turing machines are just another equivalent model. However, quantum Turing machines are widely conjectured not to be polynomially equivalent to classical Turing machines: for example, factoring and discrete logarithm are ""easy"" for quantum Turing machines (solvable in polynomial time), while it is conjectured that they are ""hard"" for classical Turing machines (cannot be solved in polynomial time; though some people think that integer factoring might be solvable in polynomial time). So from the point of view of complexity theory, quantum Turing machines are different from classical Turing machines.",3/28/2014 4:10
23417.0,Quantum algorithms and quantum computation,,<quantum-computing><random-walks>,04/04/2014 12:43,,23418.0,"This is more-or-less a reasonable description of quantum computation. A few remarks are in order: Regarding ""quantum parallelism"": Quantum computers can process a massive amount of operations in parallel [...] Yet when we measure the qubits all the possible states collapse into a single state of either $|0\rangle$ or $|1\rangle$, which seems to negate the potential benefits of parallel operations. All we really know are the probabilities that the states will end up as. This description, as it stands, applies equally well to randomized computation. We don't assume that random bits have any special sort of state-space, of course &mdash; we can just flip coins rather than having to carefully manipulate ions, or photons, or what-have-you &mdash; but the mathematics behind probability distributions and quantum states are nearly identical. (Try out some computations involving probability vectors some time, replacing the unitary transformations with stochastic transformations.) Regarding ""quantum properties"": However, we can exploit quantum properties to increase the probability that we end up with a certain result. I believe Shor's algorithm is based on exploiting quantum properties too [...] e.g. in a quantum walk, quantum interference means the walk spreads faster than a classical random walk and hence can out-perform classical walks. We do increase the probability that we observe a given result &mdash; but this is a consequence of the fact that we decrease the probability of seeing unhelpful outcomes. Classical probability distributions ""interfere constructively"" too, though we just call it cumulated probability &mdash; one thing which is special to quantum computation is the fact that destructive interference (partial or total cancelling of amplitudes) occurs. This can be seen as one of the reasons why quantum computation is more powerful: the existence of amplitudes which would cancel if you simply added them, means that amplitudes sometimes do cancel when the computation calls for transitions involving both of those amplitudes. This is something which simply doesn't happen with probability distributions &mdash; in fact, it doesn't even happen in nondeterministic Turing machines. The trick, of course, is to find the particular ways in which you can conspire to have unhelpful outcomes partially cancel (or indeed, to determine which outcomes could be helpful to you, in order to arrange for the other outcomes to cancel). Simply recognising that amplitudes can possibly cancel is not in itself enough to figure out how to compute more quickly. Regarding Shor's algorithm: I believe Shor's algorithm is based on exploiting quantum properties too, although I'm not sure in what way? Shor's algorithm is an example of an algorithm which uses the quantum Fourier transform (or QFT), a unitary transformation which broadly speaking is helpful to find/expose periodic patterns. The fact that it can be performed unitarily means that certain simple periodic patterns which would otherwise be difficult to determine in a small number of trial calculations can be quickly discovered by looking at bulk properties. Using QFTs to expose periodic properties is one particular trick in the bag of quantum algorithms; there are others as well.",04/04/2014 12:52
23985.0,Is Simon's problem a good NP-intermediate candidate?,,<complexity-theory><complexity-classes><quantum-computing>,4/21/2014 12:57,,23989.0,"Simon's problem is not a pure NP problem, for two reasons: It is an oracle problem. We are given an oracle for some function $f$. That's not something that you can do within the definition of a NP problem. It is a promise problem. We are given the promise that $f$ will satisfy a particular property (it is two-to-one, and has a particular structure). That too is not something you can do within the definition of a NP problem. So Simon's problem is not a problem in the formal complexity class NP; it's just something different. For the same reasons, it's not NP-intermediate, either.",4/21/2014 14:52
28404.0,What happens to quantum algorithms such as BB84 if P=NP,,<complexity-theory><cryptography><quantum-computing><p-vs-np>,7/14/2014 14:10,,28406.0,"BB84 is simply a key exchange procedure. This procedure remains secure unless someone can figure out how to observe a quantum phenomenon without changing it, whether or not $P=NP$ will not change this. If the vulnerability of the algorithm was in key transmission, then it is safe if it uses BB84. If it is however somewhere else in the algorithm, then no matter how the key is transmitted it will be vulnerable. So really it depends on the algorithm and the exposed vulnerability. Most algorithms that could be broken by a drastic reduction in run time however are public key algorithms, private key algorithms are much more secure, however the key exchange is the risky part and usually uses some form of public key based encryption. With BB84 however the key exchange becomes relatively safe. So for the most part, the algorithms that would use BB84 are not vulnerable unless the key can be discovered, which requires breaking BB84 and therefor changing the modern understanding of physics. Unfortunately the infrastructure is not yet in place for BB84 to be realistically implemented.",7/14/2014 15:08
28404.0,What happens to quantum algorithms such as BB84 if P=NP,,<complexity-theory><cryptography><quantum-computing><p-vs-np>,7/14/2014 14:10,,57917.0,"BB84 is unconditionally secure under the assumed threat model. This means that no assumption is made on the computational power of your adversary and therefore it is irrelevant whether P=NP or not. Of course, implementing the protocol on actual hardware brings all sorts of other difficulties and vulnerabilities, but in the idealised mathematical model it is not breakable. To contrast this with the classical case - classical key distribution can attain at best computational security, which means that your adversary is guaranteed to recover the key, but he may be under a severe computational disadvantage and thus would need a lot of time to do it.",5/26/2016 22:53
29722.0,"Will the future quantum computers use the binary, ternary or quaternary numeral system?",,<computer-architecture><quantum-computing><numeral-representations>,09/06/2014 23:04,,29726.0,"Quantum computers use binary. But really, this is a simplification, and there is no simple answer of how quantum algorithms work that don't get into the mathematics of quantum physics and quantum computation. The best way for you to understand this subject area is to start by studying quantum computation. There are many excellent textbooks and tutorials out there. Whoever told you that qubits have 3 possible states, was wrong. That's not quite how quantum mechanics works. In some sense there are infinitely many possible states... but read about quantum computation to learn the real story.",09/07/2014 06:03
29722.0,"Will the future quantum computers use the binary, ternary or quaternary numeral system?",,<computer-architecture><quantum-computing><numeral-representations>,09/06/2014 23:04,,58138.0,"Quantum particles can be in four states. They can spin up, down and be right or left-handed. If you are measuring particles that are entangled, when you measure them they will be in some combination of those four states. If we could some how predict or use a eraser of some kind, it would seem like a good idea to use quarternary rather than binary. As it stands right now, binary is being used but in the future something different will likely take the place of binary. Quantum computers are like classical computers were in the 50s, they are HUGE, expensive and not practical. In fact they are hardly useful at this time. We still struggle with decoherence. The hope it to identify a topological quantum particle that can maintain coherence (is robust) and if that day comes, look out! The revolution with take off like a rocket. To be honest no one can tell you with certainty what Q-computers will be like in the future became when singularity occurs (about 30 years from now) all bets are off. No one can tell you what will happen past that point. Computers could take off in directions we have not even dreamed about.",06/01/2016 19:27
29722.0,"Will the future quantum computers use the binary, ternary or quaternary numeral system?",,<computer-architecture><quantum-computing><numeral-representations>,09/06/2014 23:04,,58188.0,"The other answers are nice, but none address the question: what numeric base(s) might quantum computers use? I will answer in two parts: first, the question is a little subtle, and second, you may use any numeric base, and then you work with qutrits or in general with qudits, which lead to qualitatively new intuitions! Or at any rate, I will try to make the case that they do. A quantum bit isn't just a $0$ or a $1$, it's a bit more complex than that. For example, a quantum bit may be in the state $\sqrt{\frac{1}{4}}|0\rangle+\sqrt{\frac{3}{4}}|1\rangle$. When measured, you will measure the outcome $0$ with probability $\frac{1}{4}$ and the outcome $1$ with probability $\frac{3}{4}$. The 'superposition' you talked about is $\sqrt{\frac{1}{2}}|0\rangle+\sqrt{\frac{1}{2}}|1\rangle$, but in general any pair of complex numbers $a$ and $b$ will do, as long as $a^2+b^2=1$. If you have three qubits, then you can entangle them, and the state will be $$a_0|000\rangle + a_1|001\rangle+a_2|010\rangle+a_3|011\rangle+a_4|100\rangle +a_5|101\rangle+a_6|110\rangle +a_7|111\rangle$$ But when you measure this three-qubit system, your measurement outcome is one out of these 8 states, that is, three bits. This is this really weird dichotomy where on the one hand quantum systems seem to have this exponential state space, but on the other hand we only seem to be able to 'get at' a logarithmic part of the state space. In 'Quantum Computing Since Democritus', Scott Aaronson probes this question by matching off several complexity classes to try and understand how much of this exponential state space we can exploit for computation. Having said that, there is an obvious complaint to the answer above: all the notation is in binary. Qubits are in a superposition of two base states, and entangling them doesn't change that much, because three qubits are in a superposition of $2^3$ base states. It's a legitimate complaint, because one usually thinks of $\texttt{unsigned int}$ as a number, and only remembers that it is implemented as a 32-bit string as an afterthought. Enter the qutrit. It is a vector in $\mathbb{C}^3$, in other words, it consists of three base states rather than two. You operate on this vector with a $3\times 3$ matrix, and all the usual things done in quantum computing don't change much, because any operation expressed in terms of qutrits can be expressed in terms of qudits, so it's really just syntactic sugar. But some problems are much easier to write down and/or think about when expressed as qudits instead of entangled qubits. For example, a variation of the Deutsch-Josza problem might ask, given an oracle for a function $f\colon \{0,\ldots, kn-1\}\rightarrow \{0,\ldots, k-1\}$, is this function constant or balanced, given that one is promised to be the case? This function naturally takes one $k$-qudit register as input. To solve it, you must apply a Fourier transform to this $k$-qudit, like so: (if this goes over your head, don't worry, it's just for illustration) $$|a\rangle \mapsto \sum_{u=0}^{k-1}e^{i2\pi\frac{au}{k}}|u\rangle$$ If you want to express this in binary, you end up with a gate that does this on numbers $0\ldots k-1$ and acts trivially (does nothing) on all numbers $\geq k$, which is slightly less contrived than doing it this way. Similarly, consider a Bernstein-Vazirani variation where the oracle computes an in-product in some radix $r$. If $r=2$, then we know how to do it. But if $r=5$, the problem is much easier to solve by hand using several $5$-qudit registers. Some problems are easier if you have several different qudit registers, e.g. one $5$-qudit register and one $2$-qudit register. In summary, yes, you are free to consider other numeric bases, and in the right setting that will make your life easier, for the same reason that thinking about numbers in terms other than their binary expansion helps you with normal computers. I felt compelled to answer because while most answers explained that a qubit has something to do with two base states when measuring but infinite in principle, no answer mentioned that the OPs suggestion of using other bases is legitimate and in fact really happens (for example, in Quantum walks on graphs, Aharonov et al. use a subroutine that takes a qubit and an $n$-qudit as input)",06/02/2016 22:36
32629.0,A Black Box Algorithm,,<algorithms><quantum-computing>,11/03/2014 03:11,,32640.0,"Regarding part (a): just like in the classical lower bound for sorting, any black box algorithm which queries $f$ can be described as a binary decision tree whose leaves contain the correct answer $\{j_1,j_2\}$. Every pair $\{j_1,j_2\}$ is possible, so the tree must have at least $\binom{n}{2}$ leaves, hence it must have height at least $\log_2 \binom{n}{2} = \Omega(\log n)$. If you don't understand the argument, look up the $\Omega(n\log n)$ lower bound on sorting in the comparison model (also known as the decision tree model). Can we do it with $O(\log n)$ queries? Suppose for simplicity that $n = 2^k$ is a power of $2$. If we feed the algorithm the bit string $x(b_{k-1}\ldots b_0) = b_i$ then we get the $i$th bit of $j_1 \oplus j_2$, so using $\log_2 n$ queries we can find $j_1 \oplus j_2$. Suppose for simplicity that $j_1 \oplus j_2 = 1$. If we feed the algorithm the bit string defined by $x(b_{k-1}\ldots b_1 0) = 0$, $x(b_{k-1}\ldots b_1 1) = b_i$, then we recover the $i$th bit of $j_1$ (or $j_2$), so using $\log_2 n - 1$ more queries, we recover $j_1,j_2$. In total, we used $2\log_2 n - 1$ queries, which practically matches the lower bound $\log_2 n + \log_2 (n-1) - 1$. Unfortunately I can't help you with part (b).",11/03/2014 15:35
33905.0,Can a CS grad student work on quantum field theory and string theory problems?,,<complexity-theory><quantum-computing>,12/05/2014 23:25,,33928.0,"There are plenty of computer scientists working on quantum computation and quantum information so, yes, there should be plenty of opportunities to work on that sort of thing as a CS grad student. I'm not aware of any computer scientists working on string theory but it's far from my area of expertise so it's possible it happens without my knowing about it. However, I've been to plenty of theoretical CS conferences where there were a couple of talks about quantum things but I don't remember any talks at all about string theory. And, of course, if you try to Google for something like ""string theory computer science"", Google thinks you mean strings of text.",12/06/2014 08:36
34065.0,Why $\theta/2$ in common qubit representation?,,<quantum-computing>,12/09/2014 15:53,,34076.0,"Short diagrammatic answer. Because states which are orthogonal as vectors, are represented as antipodal points on the Bloch sphere &mdash; orthogonal states of qubits are as far from each other as possible and represent a sort of 'opposite' of each other, and the Bloch sphere represents this idea. Longer mathematical answer. Consider the vector-valued function $\def\ket#1{|#1\rangle}$ $$ \ket{\psi_{\theta,\phi}} = \cos(\theta/2) \ket0 + \mathrm e^{i \phi} \sin(\theta/2) \ket{1}. $$ This function has a period of $4\pi$ in the argument $\theta$, as a result of that division by 2; this might be part of what you are finding strange. However, when we consider quantum state vectors, we are not actually interested in the vector itself, as we are in the equivalence class of all vectors which are the same up to scalar factors (i.e. global phases). Because $\ket{\psi_{\theta,\phi}} \ne \mathbf 0$, we always have $\ket{\psi_{\theta,\phi}} \ne \ket{\psi_{\theta+2\pi,\phi}} = -\ket{\psi_{\theta,\phi}}$; but we do have $\ket{\psi_{\theta,\phi}} \propto \ket{\psi_{\theta+2\pi,\phi}}$ instead. That is, adding $2\pi$ to the angle $\theta$ gives you a vector $\ket{\psi_{\theta+2\pi,\phi}}$ which represents the same state. Because we only care about the state-vector inasmuch as it represents a state, this vector-valued function with peridod $4\pi$ is used to stand for a state-valued function with period $2\pi$. This becomes clearer if we use density operators to represent states, because global phases of state vectors do not affect the density operator. Define the operator $$ \rho_{\theta,\phi} = |\psi_{\theta,\phi}\rangle\!\langle\psi_{\theta,\phi}| = \begin{bmatrix} \cos^2(\theta/2) &amp; \mathrm e^{-i\phi}\!\cos(\theta/2)\sin(\theta/2) \\ \mathrm e^{i\phi} \!\cos(\theta/2)\sin(\theta/2) &amp; \sin^2(\theta/2) \end{bmatrix};$$ using the double-angle formulae $$ \begin{gather*} \cos(\theta) = 2\cos(\theta/2)^2 - 1= 1 - 2\sin(\theta/2)^2\\ \sin(\theta) = 2\cos(\theta/2)\sin(\theta/2) \end{gather*} $$ we may re-write $\rho_{\theta,\phi}$ as $$ \rho_{\theta,\phi} = \frac{1}{2}\begin{bmatrix} \cos(\theta) + 1 \;&amp;\; \mathrm e^{-i\phi} \sin(\theta) \\ \mathrm e^{i\phi} \sin(\theta) \;&amp;\; 1 - \cos(\theta) \end{bmatrix} ,$$ which is not the best representation for thinking about qubits, but certainly makes it very clear that the density operator corresponding to $\ket{\psi_{\theta,\phi}}$ is periodic in $\theta$ with period $2\pi$. As icing on the cake, note that $\rho_{\theta,\phi}$ is Hermitian by construction. So are the Pauli spin operators $\mathbf 1, X, Y, Z$, and those four are linearly independent. That means that we can decompose $\rho_{\theta,\phi}$ as a linear combination of those four operators. We may easily show, from the last expression for $\rho_{\theta,\phi}$, that $$ \rho_{\theta,\phi} = \tfrac{1}{2}\Bigl(\mathbf 1 + \cos(\phi)\sin(\theta) X + \sin(\theta)\sin(\phi) Y + \cos(\theta) Z \Bigr).$$ If you take the coefficients for $X$, $Y$, and $Z$, and map them to coordinates in $\mathbb R^3$, what you obtain is the Bloch sphere representation: that is, the Bloch sphere not only represents qubit states, but it is specifically representing the decomposition of the density operator into spin matrices.",12/09/2014 18:15
34085.0,How to apply a 1-qubit gate to a single qubit from an entangled pair?,,<quantum-computing>,12/09/2014 21:28,,34090.0,"I came to a conclusion that we do not actually take away a single qubit from an entangled pair and operate it, but operate on both qubits with Identity operator on the one we do not want to change. So basically to apply Pauli X gate to the first qubit from an entangled pair, we apply X tensored with $I$ to the entangled pair to get the result. That is, to operate a not on the first qubit, we evolve the system by $$ \sigma_x \otimes I = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix} \otimes \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0&amp; 0 \end{pmatrix} $$ Intuitively it is like applying a single operation to the first qubit and identity to the second one (effectively not changing its state). Thus if we start with the entangled state $|\psi\rangle \frac{1}{\sqrt2}(|00\rangle + |11\rangle)$ we end up with $$ (\sigma_x \otimes I)|\psi\rangle = \begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0&amp; 0 \end{pmatrix} \cdot \frac1{\sqrt{2}} \begin{pmatrix}1 \\0 \\0 \\1 \end{pmatrix} = \frac1{\sqrt{2}} \begin{pmatrix}0 \\1 \\1 \\0 \end{pmatrix} = \frac1{\sqrt{2}}(|01\rangle+|10\rangle) $$",12/09/2014 22:24
34085.0,How to apply a 1-qubit gate to a single qubit from an entangled pair?,,<quantum-computing>,12/09/2014 21:28,,34114.0,"While you have found the answer to your main question yourself, let me answer the sub-question you asked as part of the main question: How can a single qubit from an entangled pair be represented? A single qubit from an entangled pair cannot be represented by a state vector, but has to be represented by a density matrix. More exactly, it is represented by the partial trace over the other qubit of the entangled state's density matrix. For example, for the state $$\left|\phi^+\right\rangle = \frac{1}{\sqrt{2}}\left(\left|00\right\rangle + \left|11\right\rangle\right)$$ the corresponding two-qubit density matrix is the projector onto that state: $$\rho_{\phi^+}=\begin{pmatrix} \color{green}{\tfrac{1}{2}} &amp; \color{green}{0} &amp; \color{red}{0} &amp; \color{red}{\tfrac{1}{2}}\\ \color{green}{0} &amp; \color{green}{0} &amp; \color{red}{0} &amp; \color{red}{0}\\ \color{blue}{0} &amp; \color{blue}{0} &amp; 0 &amp; 0\\ \color{blue}{\tfrac{1}{2}} &amp; \color{blue}{0} &amp; 0 &amp; \tfrac{1}{2} \end{pmatrix}$$ Here I've marked with the same colour the elements which belong to the same indices for the first qubit; for example, the $\color{green}{\text{green}}$ numbers are those matrix elements where both indices of the first qubit are $\color{green}{0}$. Now the partial trace over the second subsystem just means the trace over those submatrices: $$\operatorname{tr}_B \rho_{\phi^+} = \begin{pmatrix} \color{green}{\tfrac{1}{2}} &amp; \color{red}{0}\\ \color{blue}{0} &amp; \tfrac{1}{2} \end{pmatrix}$$ Note that this is the completely mixed one-qubit state. That is, the single qubit has a completely undetermined state. Note that also the state of the second qubit is completely mixed. Which shows that the information about the entangled state is not in the individual qubits. This can also be seen in the fact that the information in half of the density matrix elements is completely ignored by the partial trace (this includes in particular the upper-right and lower-left $\frac{1}{2}$ elements, which are exactly what distinguish that entangled state from a separable equal mixture of the states $\left|00\right\rangle$ and $\left|11\right\rangle$).",12/10/2014 21:36
35415.0,"Measure two qubits, one from entangled pair, in Bell basis?",,<quantum-computing>,12/17/2014 0:21,,35421.0,"I figured out that as we are operating on 3 qubits ($|v\rangle$ and $\beta_{00}\rangle$ pair) and we want to perform CNOT on the first two (if we enumerate like 1- $|v\rangle$, 2- first from pair, 3 - second from pair) it is just like we want to perform $CNOT \otimes I$ on $|v\rangle \otimes |\beta_{00}\rangle$. After performing the CNOT described above we need to perform H on the $|v\rangle$ qubit, which is now entangled (as CNOT is an entangling operation), so it is like we want to perform $H \otimes I$ on the three (where $I$ is 3 x 3 identity matrix). Beaing able to perform both steps described above we are able to perform a measurement of qubit $|v\rangle$ and the first qubit from the entangled pair $|\beta_{00}\rangle$ in the Bell basis.",12/17/2014 2:39
37080.0,Trying to understand how the first Hadamard gate in DeutschâJozsa algorithm works,,<algorithms><quantum-computing>,01/08/2015 21:22,,37081.0,"After studying the maths behind it, I realized that a linear algebraic expression for a quantum state may not appear to be intuitive at first sight (or prehaps it is only to the not mathematically gifted ones like myself). Apparently, this is how the expression in the Wikipedia page is derived: $$\begin{align} &amp;\frac{\left|0...0\right\rangle + \left|0...1\right\rangle + \left|1...1\right\rangle}{\sqrt2 ... \sqrt2} \cdot \frac{1}{\sqrt{2}} (\left|0\right\rangle - \left|1\right\rangle)\\ =&amp;\sum^{n}_{x=0}\frac{1}{\sqrt{2^n}} \left|x\right\rangle \cdot \frac{1}{\sqrt{2}} (\left|0\right\rangle - \left|1\right\rangle) \\=&amp;\sum^{n}_{x=0}\frac{1}{\sqrt{2^{n+1}}} \left|x\right\rangle \cdot (\left|0\right\rangle - \left|1\right\rangle) \\ =&amp;\frac{1}{\sqrt{2^{n+1}}} \sum^{n}_{x=0} \left|x\right\rangle (\left|0\right\rangle - \left|1\right\rangle) \end{align}$$ Now this explains why it is alright to have the four $\frac{1}{\sqrt{2^{3}}}$ probability amplitudes above, which is indeed just the product of $\frac{1}{\sqrt{2^{2}}}$ and $\frac{1}{\sqrt{2}}$. $\frac{\left|0...0\right\rangle + \left|0...1\right\rangle + \left|1...1\right\rangle}{\sqrt2 ... \sqrt2} \cdot \frac{1}{\sqrt{2}} (\left|0\right\rangle - \left|1\right\rangle)$ sure feels like we are having a superposition state within a superposition state (I'm not sure if that is the correct way to interpret it). And this is probably what makes an entangled system so magical when it comes to computation.",01/08/2015 21:22
37388.0,What happens to multi-qubit quantum state after one of qubits is measured?,,<quantum-computing>,1/19/2015 17:16,,37395.0,"The amplitudes are scaled so that their norm is 1. In your case, if the original amplitudes are $\alpha_{000},\ldots,\alpha_{111}$, then after measuring the second bit to be 1, which happens with probability $p = \alpha_{010}^2 + \alpha_{011}^2 + \alpha_{110}^2 + \alpha_{111}^2$, the quantum state is $$ \frac{\alpha_{010} \left|010\right\rangle + \alpha_{011} \left|011\right\rangle + \alpha_{110} \left|110\right\rangle + \alpha_{111} \left|111\right\rangle}{\sqrt{\alpha_{010}^2 + \alpha_{011}^2 + \alpha_{110}^2 + \alpha_{111}^2}}. $$",1/19/2015 19:20
37501.0,Multi-qubit gates matrix representation,,<quantum-computing>,1/23/2015 1:48,,37676.0,"So basically, such gates operate on a joined register (which may be looked at as joined high-part (control) and low-part (target). Let's say that HL represents the state of such joined register (and H is the part of bits representing the control state's index before join, and L is the part representing target state's index). The matrix representation of such gate would have 1 in row HL and column H(L xor f(H)) for every possible HL.",1/27/2015 23:44
37501.0,Multi-qubit gates matrix representation,,<quantum-computing>,1/23/2015 1:48,,38062.0,"The first thing to recognize is that this is a permutation matrix where each row and column contains a single $1$ entry with the remaining entries being $0$. This follows from the fact that $x$ and $y$ represent classical bit strings and $f$ is a classical boolean function. Let's take the basic case where $x$ is from the space of $n$ bit strings, $y$ is a single bit, and $\mathcal{f}$ maps $\{0,1\}^n$ to $\{0,1\}$. The operation then functions on $n+1$ bits and is represented by a $2^{n+1} \times 2^{n+1}$ matrix. If you let the binary number $xy$ index the matrix columns, then for column $xy$ set row $x(f(x) \oplus y)$ to 1 and all other rows to 0. Let's look at an example from Deutsch's algorithm. Let $x$ be from $\{0,1\}$ and $f$ be bit negation, i.e. $f(0) = 1$ and $f(1) = 0$. From here we compute, for each row, the column number containing the 1. $\begin{array}{cc} \mbox{column} &amp; \mbox{row with 1} \\ 00 &amp; 0(0 \oplus 1) = 01 \\ 01 &amp; 0(1 \oplus 1) = 00 \\ 10 &amp; 1(1 \oplus 1) = 10 \\ 11 &amp; 1(1 \oplus 0) = 11 \end{array} $ This gives us the matrix $ \left( \begin{array}{cc} 0 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{array} \right) $ This generalizes to when $y$ is more than a single bit.",02/06/2015 19:03
37688.0,Quantum state probabilities and amplitudes - absolute value squared?,,<quantum-computing>,1/28/2015 7:02,,37689.0,"Using $\alpha^2$ doesn't make sense since you get negative or even non-real probabilities! The correct ""recipe"" is indeed $|\alpha|^2$. This also meshes well with the fact that the operations you are allowed to apply are unitary.",1/28/2015 7:13
38096.0,Can a quantum computer (theoretically) do things a classical computer (literally) can't?,,<computability><undecidability><computation-models><quantum-computing>,02/06/2015 13:26,,38097.0,"No. Quantum computers cannot solve undecidable problems. A quantum computer can be simulated by a classical computer. So, if a quantum algorithm could solve an undecidable problem, then we could also solve it classically via simulation. However, we already know that if a problem has no classical solution, then it must not have a quantum solution either. Also, you said: that's ""just"" because the quantum computer is more powerful than the classical one. This is an open problem. We do not yet know if $BPP \subset BQP$.",02/06/2015 13:45
41603.0,How must Grovers algorithm be modified in order to solve 3-SAT?,,<quantum-computing><3-sat>,4/20/2015 15:51,,41606.0,"Grover's algorithm is already suitable. It promises that if there is at least one match, then it will output at least one match. It doesn't promise to output all matches, but you don't need all matches. It is usually described to work in the case where there is zero or one items that match, but that's just because those are the hardest cases. If there are multiple matches, the algorithm will still work and will still find a match; and the running time will remain the same.",4/20/2015 16:55
41663.0,Evaluating Grover's algorithm on 3-SAT,,<quantum-computing><3-sat>,4/21/2015 15:49,,41668.0,"""Measuring"", in quantum computation, is the act reading the quantum state along some basis. This will cause the the quantum state to collapse. The quantum state after grovers algorithm is such that it collapses with very high probability to the desired result (in this case an assignment). Perhaps you should check the result because it might just be a bad case, that is just unlikely, but you don't have to check the result to get the output of grovers algorithm. You just have to measure it. To determine with high probability weather or not the formula was SAT you should check the assignment that it gave out.",4/21/2015 16:51
43805.0,How is quantum function $f(x) = a^x \mod N$ constructed in Shor's algorithm?,,<quantum-computing>,6/21/2015 16:34,,49198.0,"The algorithm uses the functional superposition s of f. A state with 2q qubits (2q=Q, where Q is the same as in the Wikipedia article): s(xy) = Q-1/2 where y = f(x), else 0 You can see xy as the concatenation of x and y in binary form. x and y run from 0 to Q-1. Here is how it can be done with q ancillary qubits (3q qubits total): Start with 3q qubits in the zero state (1,0,0,...). I'll call the first q qubits x, the second q qubits y and the third q qubits z Apply the Hadamard transform to x Follow x to y with CNOT. This yields the state s(xyz) = Q-1/2 where x = y and z = 0, else 0 Apply f'(x,y) = (x,f(x) XOR y) to y and z. f' is invertible and has a unitary matrix. This yields the state s(xyz) = Q-1/2 where x = y and z = f(x), else 0 Apply g(x,y) = (x,x XOR y) to x and y. This yields the state s(xyz) = Q-1/2 where y = 0 and z = f(x), else 0 Swap x and y with swap gates. This yields the state s(xyz) = Q-1/2 where x = 0 and z = f(y), else 0. x is in the zero state (1,0,0,...) and can be separated from yz - which forms the functional superposition of f",11/07/2015 20:31
44317.0,How many inputs does the Hadamard gate have?,,<complexity-theory><quantum-computing><circuits><hamiltonian-circuit>,07/10/2015 21:46,,44318.0,"The $n$-ary Hadamard gate acts on $n$ qubits. The state of the $n$ qubits is a unit norm vector of dimension $2^n$. You can take as basis the vectors $|x\rangle$ for $x \in \{0,1\}^n$. As it happens, the $n$-ary Hadamard gate can be simulated by $n$ unary Hadamard gates acting on the individual qubits, which is what you see on page 6-3. The reason is that the $n$-dimensional Hadamard transform is the tensor product of $n$ one-dimensional Hadamard transforms. The usual convention in circuit complexity is that gates have bounded fan-in. Otherwise you can compute any function using a large gate! Consider the case $n=1$: $$ \begin{bmatrix} \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} = \begin{bmatrix} \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{bmatrix} \, . $$ This is where $|1\rangle$ comes from. The entire circuit involves initializing $n$ qubits at the state $|0\rangle$, applying $n$ unary Hadamard gates on the $n$ qubits, applying the black box function $f$, and then applying the Hadamard gates again on the $n$ qubits. The final state of the $i$th qubit turns out to be $|s_i\rangle$.",07/10/2015 22:18
44360.0,Question about the Simon's algorithm,,<complexity-theory><information-theory><quantum-computing>,07/12/2015 19:46,,44362.0,"I'm not sure I get all your questions. I'll try to answer according to my interpretation of what you are asking, and you can clarify if I got you wrong. Given this I want to understand why a measurement on the second qubit would necessarily collapse this to the state, $\psi_b = \frac{1}{\sqrt{2}} ( |j\rangle + |j \oplus s\rangle)|x_j\rangle$ for some $j \in \{0,1\}^n$? First, there is no second qubit, but a second system (of $n$ qubits). Next, consider $\psi_a$, and recall that for any $f(x_j)$ there are only two preimages $j$ and $j\oplus s$, then if you measure $f(x_j)$ at the second system, the first system must either be $j$ or $j\oplus s$. Is this measurement of the second qubit state trying to measure some observable/Hermitian operator whose eigenstates are precisely these $\psi_b$s? Then it would make some sense that the only things one sees are these $\psi_b$ states. Kind of. However, you don't measure $\vert\psi_a\rangle$ directly. There is another hadamard gate which is missing there. I.e., you measure $$(H\otimes I) \left\vert\psi_a\right\rangle = \frac1{2^n}\sum_x\sum_i (-1)^{i\cdot x}\left\vert i\right\rangle\left\vert f(x)\right\rangle$$ Now if you re-arrange it properly, it should give \begin{align*} \frac1{2^n}\sum_{x\in\{0,1\}^n}\sum_i (-1)^{i\cdot x}\left\vert i\right\rangle\left\vert f(x)\right\rangle &amp;= \frac1{2^n}\sum_{j\in XS}\sum_i (-1)^{i\cdot j}\left\vert i\right\rangle\left\vert f(j)\right\rangle + (-1)^{i\cdot (j\oplus s)}\left\vert f(j\oplus s)\right\rangle \\ &amp;= \frac1{2^n}\sum_{j\in XS}\sum_i \left ((-1)^{i\cdot j}+(-1)^{i\cdot j}(-1)^{i\cdot s}\right)\left\vert i\right\rangle\left\vert f(j)\right\rangle \\ &amp;= \frac1{2^n}\sum_{j\in XS}\sum_i (-1)^{i\cdot j}\left(1+(-1)^{i\cdot s}\right)\left\vert i\right\rangle\left\vert f(j)\right\rangle \end{align*} Where $XS\subseteq \{0,1\}^n$ is the largest subset such that if $j\in XS$ then $\forall j'\in XS, f(j)\ne f(j')$; so that the sum over $j$ is only over half the space and we don't count twice $x=j$ and $x=j\oplus s$. But note that $f(j)=f(j\oplus s)$ which we use in the second transition. The above shows that for any $i$ for which $s\cdot i=1 \mod 2$ there is a destructive interference that cancels these terms, and you are left with only $i$'s for which $s\cdot i=0 \mod 2$. Thus, any $i$ you will measure (at the first system) must satisfy $s\cdot i=0 \mod 2$.",07/12/2015 21:23
44823.0,Why is a quantum computer not capable of solving more problems than a classical computer?,,<computability><computation-models><quantum-computing><simulation>,7/29/2015 6:56,,44824.0,"Because a quantum computer can be simulated using a classical computer: it's essentially just linear algebra. Given a probability distribution for each of the qubits, you can keep track of how each quantum gate modifies those distributions as time progresses. This isn't very efficient (which is why people want to build actual quantum computers) but it works.",7/29/2015 7:16
44823.0,Why is a quantum computer not capable of solving more problems than a classical computer?,,<computability><computation-models><quantum-computing><simulation>,7/29/2015 6:56,,44832.0,"One thing that quantum computers should be able to do that regular computers will never do is to use quantum entanglement. Quantum entanglement is a property that allows to communicate instantly across the whole universe, without transmitting anything. The communication cannot be intercepted or tampered with. Also I can communicate several chips. This means that I can communicate the CPU with the RAM and with the SSD instantly. So you could have super fast computers. And if I buy some special chip, for example from Amazon Quantum Web Servers, then I could use their infrastructure to perform computations AS IF they were running on my machine... no communication overhead... at least theoretically... Having a CPU perform all computations in parallel like solving the traveling salesman problem... that makes no sense... if a CPU could do that, all possible results would come out at once... a giant map reduce done in a single chip... how do I pick the right answer? I mean if the correct answer is 5, but it spells out 5,6,7,8,9,10,15,20,30,40,50,60,70,80... etc. at the same time, how can I know that the correct value is 5?",7/29/2015 14:23
44823.0,Why is a quantum computer not capable of solving more problems than a classical computer?,,<computability><computation-models><quantum-computing><simulation>,7/29/2015 6:56,,44834.0,"Actually, it depends of what you mean by ""solving a problem"". As previously stated, a classical computer is already Turing complete and can decide any decidable problem in finite time. There is no such thing of a computer able to decide an undecidable problem in finite time (that would actually lead to a contradiction). [Edit: as David Richerby stated in the comments, that hasn't been proved (only conjectured) However most of the undecidability proofs can be repeated for any reasonable kind of computer (this doesn't prove the conjecture, but in my opinion it's a good hint) The good argument regarding why a quantum computer couldn't decide more problems than a classic Turing machine has already been given by David Richerby (you can simulate a quantum Turing machine with a classical Turing machine)] Hence a classical computer can theoretically solve any ""reasonable"" problem... given enough time (it will be finite, it doesn't mean it will be fast). The wikipedia quote doesn't talk about time at all, and a quantum computer is expected to solve some problems faster than a classical computer. By ""faster"", i mean that some problems which would have taken millenia to decide on a classical computer could be solved in minutes on a quantum computer (provided such a computer can be built, we don't know for sure yet, although there are promising results, and provided BQP != BPP which is a weaker hypothesis than NP != P if i'm not mistaken). For instance, the famous Shor's algorithm shows that factoring an integer in its prime factors is in BQP (Bounded error Quantum Polynomial time) whereas that problem isn't believed to be in P (Polynomial time) or BPP (Bounded error Probabilistic Polynomial time). That doesn't mean factoring an integer on a classical computer is impossible, but it will be a time consuming task, and for sufficiently big numbers the computation may exceed any reasonable time limit (like the age of the universe; of course that's true of almost any computation given a sufficiently big entry, but that would happen much faster for problems outside of BPP on a classical computer than for problems inside of BPP). So, even though all decidable problems can be solved on classical computers, some problems are still practically out of reach because of unreasonable computation times. A quantum computer may allow us to decide such problems in more reasonable time.",7/29/2015 14:52
45129.0,What can a quantum query to a function do?,,<complexity-theory><quantum-computing>,08/10/2015 00:34,,45132.0,"the gate $f$ performs the transformation $$\rvert x\rangle \rvert0\rangle \to \rvert x\rangle \rvert 0\oplus f(x)\rangle, $$ but $0$ is idempotent for $\oplus$ so you simply get $\rvert x\rangle \rvert f(x)\rangle$. Now, by linearity, if you input a superposition instead of a basis states, you'll get a superposition of the ""answers"", e.g., $$\frac1{\sqrt2}(\rvert 0\rangle \rvert0\rangle+\rvert1\rangle |0\rangle) \to \frac1{\sqrt2}(\rvert 0\rangle \rvert f(0)\rangle+\rvert 1\rangle \rvert f(1)\rangle)$$ Then, if you start with a Hadamard, and get an equal superposition of all basis states, you end up with a superposition of all possible ""answers"". $$\frac1{N} \sum_x \rvert x\rangle \rvert 0 \rangle \to \frac1{N} \sum_x \rvert x\rangle \rvert f(x) \rangle.$$ The fact that $x$ or $0$ are in fact a ""string"" over $\{0,1\}$ doesn't make any difference - treat them as a single quantum system of higher dimension (or treat each qubit as a separate function $f_i$ where $f_1()f_2()\cdots f_n()=f()$ are the bit-wise functions.",08/10/2015 03:21
47324.0,Quantum computer memory size,,<computation-models><quantum-computing>,9/18/2015 18:39,,47326.0,"No, quantum computers are not going to have an enormous number of operations per second, in fact they are probably going to be much slower in the foreseeable future. The situation with memory seems even bleaker â so far only a handful of bits. The big advantage of quantum computers is that they can run quantum algorithms, which work rather differently from classical algorithms. Very informally, they provide a way of going through many possibilities at the same time. This gives an exponential speed up for some tasks, and a polynomial speedup for others â in terms of the number of operations. Even though each individual operation is going to be slower, since you need to run drastically fewer, the overall algorithm would run much faster.",9/18/2015 19:15
48123.0,Where does entanglement fit into quantum computing?,,<quantum-computing>,10/11/2015 14:57,,48130.0,"The entanglement of quantum particles is, implicitly or explicitly, the reason why quantum computing is so fast. You will know by now that a qubit (implemented for example as a photon's polarization) can be represented as a unit vector of two complex numbers, and that it may be manipulated by a 2-by-2 matrix of complex numbers. If you have two quantum systems described by their respective state vectors $|a\rangle$ and $|b\rangle$, which describe the two systems in isolation, their composite state is described by the tensor product of these two vectors: $|a\rangle \otimes |b\rangle$. If you operate on $|a\rangle$ with matrix $U$, you get the composite state $(U|a\rangle) \otimes |b\rangle$, and so forth. Entanglement comes when you operate on this composite state and bring it to a state which cannot emerge as the tensor product of two state vectors. For example, the state $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$ is not the tensor product of any two vectors (verify this as an excercise). In such states, measuring qubit $|a\rangle$ has an effect on $|b\rangle$. For example, if you performed a partial measurement (that is, a measurement of ostensibly only one qubit) on the most significant bit of $\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)$, and you measured it to be $0$, then measuring the least significant bit will yield $0$ with certainty, too, and vice versa. A good first example for studying entanglement is Deutsch' problem, where the algorithm goes from $(|0\rangle+|1\rangle) \otimes (|0\rangle - |1\rangle)$, a state which can be expressed as the tensor product, to a state which can no longer be expressed as any tensor product, using an operator which cannot be expressed as the tensor product of two operators.",10/11/2015 17:23
48168.0,How do quantum computers find the global minimum?,,<optimization><quantum-computing>,10/12/2015 14:02,,48227.0,"You can condition quantum operations on unmeasured values, without measuring them. These are called controlled operations, and every quantum algorithm uses them. For example, a crucial step in Grover's algorithm is toggling the phase of the system only if all qubits are on. Doing so does not measure every qubit, or do an aggregate ""is it all on?"" measurement. The superposition survives. A more concrete example: take a system in the |00> state, hit the first qubit with a Hadamard gate so now we're in the |00>+|10> state, then hit the second qubit with a NOT controlled by the first qubit, so we go into the |00>+|11> state. Instead of destroying the superposition, the controlled operation helped us increase the amount of entanglement present. However, don't think of controlled operations as magic beyond measurement. Controlled operations are very very similar to measurements. In fact, in some interpretations of quantum mechanics, measurements are controlled operations. It's just that controlled operations can have small controllable/reversible effects, but ""measurement"" implies dissipation into the environment and thus thermodynamic irreversibility.",10/13/2015 16:23
48330.0,Does a Hadamard Gate have uses outside of pure and evenly mixed states?,,<quantum-computing>,10/16/2015 14:18,,48333.0,"I don't know of any explicit use of the Hadamard gate in circuits other than to introduce or take away superposition, but here are some interesting applications: The Hadamard gate is the single-qubit version of the Fourier Transform*, and the Fourier Transform is very useful. Instead of using the Hadamard at the end of a computation to get back the original basis, you can measure the system in the Hadamard basis instead of the standard basis. The set of $\{\text{CNOT}, \text{Hadamard}, \text{rotation by 45 degrees}, \frac{\pi}{8}\text{-gate} \}$ is a universal quantum gate set. That is to say, any quantum gate can be approximated arbitrarily well by repeated application of gates from this set. If you prepend and append two Hadamard gates to a CNOT gate, you reverse the role of control bit and target bit. *Demonstration: The quantum Fourier transform is defined as follows. Take a system of $n$ particles in the standard basis, and put it in state $|k\rangle, 0 \leq k \leq 2^n-1$. Then applying the Fourier Transform $F$ yields a big superposition: $$ F|k\rangle = \sum_{u=0}^{2^n-1}e^{i2\pi\frac{u\cdot k}{2^n-1}}|u\rangle $$ Take $n=1$ and $k\in\{0,1\}$, and you see that $F|0\rangle = |+\rangle$ and $F|1\rangle=|-\rangle$. As you can see, it is performs exactly the same transformation as a Hadamard gate. Moreover, for any number of qubits $n$, the Fourier still behaves as the Hadamard only for the state $0$, on which it acts as follows: $$ F|0\rangle_n = \sum_{u=0}^{2^n-1}e^{i2\pi\frac{u\cdot 0}{2^n-1}}|u\rangle_n = \sum_{u=0}^{2^n-1}e^{0}|u\rangle_n = \sum_{u=0}^{2^n-1}|u\rangle_n $$ I have not normalized my states in these examples, but you should definitely do so on an exam.",10/16/2015 14:47
48336.0,Must you work with all qubits in a circuit when applying a gate?,,<quantum-computing>,10/16/2015 17:26,,48337.0,"You can apply a quantum gate on any subset of the qubits, not affecting the rest. This can be formalized as evolving certain qubits via $U$ while the other qubits evolve via $I$, thus the joint unitary is $U \otimes I$.",10/16/2015 17:51
48336.0,Must you work with all qubits in a circuit when applying a gate?,,<quantum-computing>,10/16/2015 17:26,,72472.0,"I think you will need that in the case that your operation is not using qubits in sequence. That is if you have 4 qubits (1, 2, 3 and 4) and you want to apply a 2-qubit quantum operation on qubit 1 and 4, e.g. a CNOT then you should construct a matrix of size $2^4 \times 2^4$.",04/04/2017 13:26
48397.0,How do you apply a multi qubit gate to specific qubits in a multi qubit circuit?,,<quantum-computing>,10/18/2015 18:36,,48400.0,"Imagine that the qubits were $0$ and $1$ (or $1$ and $2$, depending on your numbering scheme). You want to apply the Hadamard gate on the first two coordinates, and nothing â the identity â on the rest. This leads to a block diagonal matrix whose second block is the $4\times 4$ identity. Now make the necessary arrangements for the qubits you're interesting it.",10/18/2015 19:20
48537.0,Why does the Toffoli gate output c XOR (a AND b) instead of just a AND b?,,<quantum-computing>,10/21/2015 14:55,,48884.0,"As the comments said, if it worked like i asked, it would neither be reversible, nor a unitary matrix. Both things are required for quantum computing!",10/29/2015 23:39
48538.0,"Is it possible to entangle more than 2 qubits? If so, is it useful?",,<quantum-computing>,10/21/2015 14:58,,48542.0,"Ok, entanglement just clicked for me and totally makes sense. Yes it is completely possible to entangle more than two qubits! Entanglement is a fancy word with a really simple meaning. In quantum computing, you can modify the probabilities of values being read. If you have two qubits, normally there is some probability for each of the possible states: reading a 0 for each qubit, reading a 1 for each qubit, reading a 0 for qubit a and a 1 for qubit b, and reading a 1 for qubit a and a 0 for qubit b. When you modify probabilities such that any of these probabilities drop to zero, it limits the possibilities of what can happen when you measure the qubits. Most specifically, in the two qubit case, you could eliminate the situations where they disagree (states $|01\rangle$ and $|10\rangle$), and make it a 50/50 chance between the states of them both being on, or both being off. Now, they have NO CHANCE of disagreeing when you read their values. Who knows how reality ""implements"" this situation, since distance doesn't matter, but there you go... it's pretty darn simple. A very simple 3 qubit entanglement would be this: $|000\rangle$, or this: $1/\sqrt{2}(|000\rangle + |111\rangle)$",10/21/2015 18:47
48781.0,Does entangling 100 qubits require a 2^100 X 2^100 Hadamard gate?,,<quantum-computing>,10/27/2015 21:29,,48823.0,"It does require that, but you get it for free. When you apply a 2x2 gate to a single qubit, the gate you are applying to the $n$-qubit system that qubit is in is automatically $2^n$ x $2^n$. If you apply an $H$ to the third qubit out of six, then the operation you applied to the six qubits is $I_2 \otimes I_2 \otimes H \otimes I_2 \otimes I_2 \otimes I_2$. That's a 64x64 matrix; exactly what you needed. So performing a Hadamard transform on $n$ qubits is actually very easy, even though some very large matrices are being thrown around if you think about what's happening in that way. Just independently hit each qubit with the usual single-qubit $H$ gate. Note that Hadamarding each qubit doesn't entangle them, though. It puts them in a superposition, but the state still factors. If you want to entangled all the qubits, you could instead hit one of them with a Hadamard then use Controlled-Nots to toggle each of the other qubits based on that Hadamard'ed qubit.",10/28/2015 21:58
48834.0,Applying a multi qubit quantum gate to specific qubits,,<quantum-computing>,10/29/2015 4:04,,90562.0,"Don't use the swap method, it's very inefficient. And the other person's answer is specific to the CNOT gate, and to be frank, over-complicates things. Here's a very simple algorithm that solves your problem for every single case, not just the CNOT gate, for any arbitrary bits. The algorithm: let sys = matrix representing the current state of the system let n = number of qubits being simulated let lgm = logic gate matrix of size 2^n by 2^n let f = our logic gate transformation function for i = 0 to (2^n) - 1: lgm[column = i] = f(i) sys = sys Ã lgg In classical computers, there's something known as the ""decoder"". Let's say I have only 3 wires, effectively, 3 bits. But I want to control 8 wires. Can that be done? Yes, because 3 bits has 8 different possibilities: 000, 001, 010, 011, 100, 101, 110, 111. So we can assign each possibility to one of our 8 output wires. This is called ""decoding"". If I pass in the number 101 and we have 3 bits, we know 101=5, so then I will be setting output wire 5 to a high voltage and the other 7 output wires will be 0, which we can represent like this: decode(101) = [0, 0, 0, 0, 0, 1, 0, 0]. In this algorithm, I mention the ""transformation function"" called ""f"". For classical computers, the transformation function is just taking in an input value and returning the ""decoded"" version of the output value. So if we have 3 bits, and the output is 4, then we will be returning [0, 0, 0, 0, 1, 0, 0, 0]. We then assign that as the column of our matrix for that value. Let's think of ""decoding"" in terms of qubits. How can we decode the qubits |101>? We know that for our qubit probability vectors, |0> is [1, 0] and |1> is [0, 1]. Decoding qubits can then be done what's called the Kronecker product. So if we convert each bit to the probability vector equivalent and take the Kronecker product of all of them, we get... |101&gt; = |1&gt; â |0&gt; â |1&gt; = [0, 1] â [1, 0] â [0, 1] = [0, 0, 0, 0, 0, 1, 0, 0] This is how we'd want to decode qubits. This algorithm can be applied to qubits just the same using this. Let's try this algorithm on a simpler problem. Let's assume we have a system with only 2 qubits. If we want to apply the Hadamard gate to just 1 qubit, we can generate a logic gate for both qubits that only applies the Hadamard gate to a single qubit. Let's assume the single qubit we want to apply it to is our most significant qubit and the least significant will be unaffected. We want a transformation function that for each of our possible inputs, produces the correct output. We have two qubits, this means there are four possible outputs. f(|00&gt;) = ? f(|01&gt;) = ? f(|10&gt;) = ? f(|11&gt;) = ? We know the least significant qubit will be unaffected, so we can fill that in. f(|00&gt;) = ? â |0&gt; f(|01&gt;) = ? â |1&gt; f(|10&gt;) = ? â |0&gt; f(|11&gt;) = ? â |1&gt; We also know what the Hadamard does to a qubit, such that: H(|0&gt;) = 1/sqrt(2)|0&gt; + 1/sqrt(2)|1&gt; H(|1&gt;) = 1/sqrt(2)|0&gt; - 1/sqrt(2)|1&gt; So our transformation function is simply: f(|00&gt;) = (1/sqrt(2)|0&gt; + 1/sqrt(2)|1&gt;) â |0&gt; f(|01&gt;) = (1/sqrt(2)|0&gt; + 1/sqrt(2)|1&gt;) â |1&gt; f(|10&gt;) = (1/sqrt(2)|0&gt; - 1/sqrt(2)|1&gt;) â |0&gt; f(|11&gt;) = (1/sqrt(2)|0&gt; - 1/sqrt(2)|1&gt;) â |1&gt; Expand this out to our normalized probability vector form... f(|00&gt;) = [ 1/sqrt(2), 1/sqrt(2) ] â [ 1, 0 ] f(|01&gt;) = [ 1/sqrt(2), 1/sqrt(2) ] â [ 0, 1 ] f(|10&gt;) = [ 1/sqrt(2), -1/sqrt(2) ] â [ 1, 0 ] f(|11&gt;) = [ 1/sqrt(2), -1/sqrt(2) ] â [ 0, 1 ] Now let's actually solve this... f(|00&gt;) = [ 1/sqrt(2), 0, 1/sqrt(2), 0 ] f(|01&gt;) = [ 0, 1/sqrt(2), 0, 1/sqrt(2) ] f(|10&gt;) = [ 1/sqrt(2), 0, -1/sqrt(2), 0 ] f(|11&gt;) = [ 0, 1/sqrt(2), 0, -1/sqrt(2) ] That's our transformation function. Our logic gate matrix, ""lgm"", is of size 2^n by 2^n where n = number of qubits being simulated, so in this case it's 2^2 by 2^2 or 4x4. Our algorithm tells us that for each column i, set the column equal to f(i). We've defined our probability transformation function, so we can easily fill out these columns. lgm = |00&gt; |01&gt; |10&gt; |11&gt; [ 1/sqrt(2), 0, 1/sqrt(2), 0 ] [ 0, 1/sqrt(2), 0, 1/sqrt(2) ] [ 1/sqrt(2), 0, -1/sqrt(2), 0 ] [ 0, 1/sqrt(2), 0, -1/sqrt(2) ] Now the final step in our algorithm is simply matrix-multiplying our matrix representing the entire quantum system, sys, by this logic gate, lgm. And that does what we want. It will apply the hadamard gate only to the most qubit and leave the least significant qubit alone. If you don't believe me, you can try it yourself and see that it works. The reason this is so powerful is because it applies to any case. Let's try this algorithm on your problem. Imagine we have a 3 qubit system and we want to apply a CNOT gate to qubit[0] and qubit[2]. If you look up the CNOT matrix on Wikipedia, that matrix only applies to a 2-qubit system. A naive solution would be to append identity matrices to it using the Kronecker product to make it work on systems with three qubits. But this fails here: qubit[0] and qubit[2] are not adjacent, so simply appending identity matrices won't work. We could swap qubit[0] with qubit[1], apply the CNOT gate, then swap them back. But that's slow. Instead, we could simply generate a non-adjacent CNOT gate for our problem using the algorithm above. We first need to come up with a transformation function for each case. f(|000&gt;) = |0&gt; â |0&gt; â |0&gt; f(|001&gt;) = |0&gt; â |0&gt; â |1&gt; f(|010&gt;) = |0&gt; â |1&gt; â |0&gt; f(|011&gt;) = |0&gt; â |1&gt; â |1&gt; f(|100&gt;) = |1&gt; â |0&gt; â |1&gt; f(|101&gt;) = |1&gt; â |0&gt; â |0&gt; f(|110&gt;) = |1&gt; â |1&gt; â |1&gt; f(|111&gt;) = |1&gt; â |1&gt; â |0&gt; If you understand the CNOT gate, you can understand why this is our function. Think of this like a truth table. Since our control qubit is the most significant qubit, qubit[2], only when that qubit is |1> will the least significant qubit, qubit[0], be negated. Expand this out to our normalized probability vector form... f(|000&gt;) = [ 1, 0 ] â [ 1, 0 ] â [ 1, 0 ] f(|001&gt;) = [ 1, 0 ] â [ 1, 0 ] â [ 0, 1 ] f(|010&gt;) = [ 1, 0 ] â [ 0, 1 ] â [ 1, 0 ] f(|011&gt;) = [ 1, 0 ] â [ 0, 1 ] â [ 0, 1 ] f(|100&gt;) = [ 0, 1 ] â [ 1, 0 ] â [ 0, 1 ] f(|101&gt;) = [ 0, 1 ] â [ 1, 0 ] â [ 1, 0 ] f(|110&gt;) = [ 0, 1 ] â [ 0, 1 ] â [ 0, 1 ] f(|111&gt;) = [ 0, 1 ] â [ 0, 1 ] â [ 1, 0 ] Now let's actually solve this... f(|000&gt;) = [ 1, 0, 0, 0, 0, 0, 0, 0 ] f(|001&gt;) = [ 0, 1, 0, 0, 0, 0, 0, 0 ] f(|010&gt;) = [ 0, 0, 1, 0, 0, 0, 0, 0 ] f(|011&gt;) = [ 0, 0, 0, 1, 0, 0, 0, 0 ] f(|100&gt;) = [ 0, 0, 0, 0, 0, 1, 0, 0 ] f(|101&gt;) = [ 0, 0, 0, 0, 1, 0, 0, 0 ] f(|110&gt;) = [ 0, 0, 0, 0, 0, 0, 0, 1 ] f(|111&gt;) = [ 0, 0, 0, 0, 0, 0, 1, 0 ] Let's make these the columns of our lgm matrix. lgm = [ 1, 0, 0, 0, 0, 0, 0, 0 ] [ 0, 1, 0, 0, 0, 0, 0, 0 ] [ 0, 0, 1, 0, 0, 0, 0, 0 ] [ 0, 0, 0, 1, 0, 0, 0, 0 ] [ 0, 0, 0, 0, 0, 1, 0, 0 ] [ 0, 0, 0, 0, 1, 0, 0, 0 ] [ 0, 0, 0, 0, 0, 0, 0, 1 ] [ 0, 0, 0, 0, 0, 0, 1, 0 ] Now if the matrix-multiply our entire system matrix, sys, by our logic gate matrix, lgm, our result will be the effect of applying the CNOT gate to qubit[2] and qubit[0] where qubit[2] is the control qubit.",04/11/2018 21:26
50366.0,Is there any proof that quantum computers are more efficient than classical computers?,,<algorithms><efficiency><quantum-computing>,12/05/2015 19:30,,50404.0,"It depends what you consider an actual proof, and what you mean by ""faster"". From a complexity theoretic perspective, the answer is no -- we don't have such a proof. BQP (the class of problems which can be solved efficiently by a quantum computer) is contained in PSPACE. Being able to prove a separation between BQP and PSPACE would also imply a separation between P and PSPACE, which is not known. Note that Grover's algorithm only gives a square root speedup, so there is no contradiction.",12/06/2015 13:15
50542.0,Are qubits written in a big-endian or little-endian order when grouped?,,<quantum-computing>,12/10/2015 01:35,,54752.0,"There's no convention. Usually the endian-ness doesn't matter, or else it's clear from the context which endian-ness is being used. (I'm also not aware of a convention for whether the wires in circuit diagrams are top-endian or bottom-endian. I just always infer from context.)",3/21/2016 19:17
50794.0,Constructing the matrix of a controlled quantum operation,,<quantum-computing>,12/16/2015 0:19,,50802.0,"For any gate $U_n$ on $n$-qubits, you can create a controlled version by taking $$\text{c-}U_n = \left (\begin{matrix} I_n &amp; 0 \\ 0 &amp; U_n \end{matrix}\right)$$ where $I_n$ is the identity matrix (of the same dimension as $U_n$). Note that this gate works on $n+1$ qubits, where the first serves as the control bit. This should work because the controlled gate is required to satisfy $\text{c-}U_n |0\rangle|x\rangle = |0\rangle|x\rangle $, and $\text{c-}U_n |1\rangle|x\rangle = |1\rangle(U_n|x\rangle) $ where $|x\rangle$ is an $n$-qubit state. You should be able to check that the above matrix satisfies exactly this.",12/16/2015 3:36
50921.0,How many operations to produce this superposition of 3 qubits?,,<quantum-computing>,12/18/2015 23:30,,50947.0,"You don't need a full 8x8 three-qubit operation, but you will need a two-qubit operation of some kind. If you only rotate each qubit independently, you'll find you can only make un-entangled states like: $(a_1 \left| 0 \right\rangle + b_1 \left| 1 \right\rangle) \otimes (a_2 \left| 0 \right\rangle + b_2 \left| 1 \right\rangle) \otimes (a_3 \left| 0 \right\rangle + b_3 \left| 1 \right\rangle)$ $= a_1 a_2 a_3 |000\rangle + a_1 a_2 b_3 |001\rangle + a_1 b_2 a_3 |010\rangle + a_1 b_2 b_3 |011\rangle + b_1 a_2 a_3 |100\rangle + b_1 a_2 b_3 |101\rangle + b_1 b_2 a_3 |110\rangle + b_1 b_2 b_3 |111\rangle$ But as soon as you have a non-trivial two-qubit operation, like a controlled-NOT, to go with your single qubit gates, you can approximate any larger operation or state arbitrarily well. (This is different from classical reversible computing, where you need a doubly-controlled-not before you get universality.) The basic idea of how it's done is: Break a large operation into lots of single-qubit operations, but allowing each to have lots of controls. Use the fact that all single-qubit operations have a square root to knock controls off of multi-controlled operations until you're left with singly-controlled operations. Replace controlled-whatevers with controlled-NOTs by finding $A$, $B$, $C$, $\theta$ such that $ABC = I$ but $AXBXC e^{i \theta} = U$ for each single-qubit operation $U$. The details of these kinds of constructions are covered in textbooks.",12/19/2015 18:29
51469.0,Are there any problems that require exponential time in quantum computing?,,<complexity-theory><quantum-computing>,01/04/2016 23:19,,51479.0,"Most problems that require exponential time on a classical computer also require exponential time on a quantum computer. For example EXPTIME-complete problems will require exponential time on either a classical or a quantum computer. The class of problems solvable in polynomial time on a quantum computer is called BQP. It is believed unlikely that BQP contains the NP-complete problems. Thus the NP-complete problems probably take exponential time on quantum computers. One of the most interesting problems that is known to be in BQP, but believed not to be in P is the integer factoring problem. But integer factoring is believed unlikely to be NP-complete.",01/05/2016 03:46
52905.0,"CNOT, Hadamard and Î¦ quantum gates",,<quantum-computing>,02/10/2016 00:10,,52944.0,"This is actually kind of complicated. Basically you can: Decompose a huge multi-qubit operation into many single-qubit gates, but with lots of controls allowed on each single-qubit gate. Think of it as doing Gaussian elimination: you're factoring the matrix into a bunch of simple row operations. Gradually reduce the number of controls to at-most-one-per-gate, by repeatedly using a construction based on the fact that every operation has a square root and an inverse. Factor each single-qubit operation $U$ into $A$, $B$, $C$, $\theta$ such that $ABC = I$ but $AXBXC e^{i \theta} = U$. Use that to replace controlled-$U$ gates with uncontrolled single-qubit operations separated by $CNOT$ gates. Approximate each uncontrolled single-qubit operation with a sequence of $H$ and $T$ gates (which is possible because they correspond to rotations that can approximate any other rotation). What you're left with is a circuit containing only $CNOT$, $H$, and $T$ gates that approximates the original operation. You need more gates to get a better approximation, but you can get as close as desired. Also the overhead isn't too terrible. For details of the constructions, and proofs that the errors don't compound in a way that destroys the efficiency of the approximation, you'll probably have to get a textbook or read papers. There's a lot of details.",02/10/2016 20:38
56129.0,Why does 9 qubit Shor code have distance 3?,,<quantum-computing>,4/18/2016 5:37,,56130.0,"Distance 3 means that an error operator acting on 3 qubits maps a valid code-state to another valid code-state. For the Shor code, an example would be a simultaneous phase flip on the 1st, 4th and 7th qubits ($Z_1Z_4Z_7$). You can easily check that $Z_1Z_4Z_7âS$, but that it commute with $S$, hence is part of $N(S)$.",4/18/2016 14:43
56129.0,Why does 9 qubit Shor code have distance 3?,,<quantum-computing>,4/18/2016 5:37,,56140.0,"Another way to see this is by using $$\frac{N(S)}{S} \cong P_k $$ Here $k=1$ and we actually know that $\bar{X}=ZZZZZZZZZ$ and $\bar{Z}=XXXXXXXXX$ also we know $S$ and thus we know $N(S)$ Hence we can directly find distance by ""minimum weight element in $N(S)-S$""",4/18/2016 21:21
57416.0,Quantum CNot algorithm problem,,<quantum-computing>,5/13/2016 15:50,,57417.0,"Your circuit is equivalent to first applying a Hadamard gate on the second qubit followed by a CNOT gate where the control is the second qubit. This cannot result in state $|00&gt;$ after execution. To help you further, why do you think it should end up in state $|00&gt;$?",5/13/2016 16:08
57416.0,Quantum CNot algorithm problem,,<quantum-computing>,5/13/2016 15:50,,57420.0,"(For convenience I'm omitting the normalization factors like $1/\sqrt2$ and $1/\sqrt4$.) The state after applying CNOT is $$\left|E\right\rangle=\left|00\right\rangle + \left|11\right\rangle.$$ This is not the same as $$\left|S\right\rangle=(\left|0\right\rangle+\left|1\right\rangle)(\left|0\right\rangle+\left|1\right\rangle)=\left|00\right\rangle+\left|01\right\rangle+\left|10\right\rangle+\left|11\right\rangle.$$ Only $(H\otimes H)\left|S\right\rangle=\left|00\right\rangle$, but $(H\otimes H)\left|E\right\rangle$ is something else. Physically we say $\left|E\right\rangle$ is an entangled state and $\left|S\right\rangle$ is a separable state. Being entangled means you cannot consider each qubit independently. Instead, to compute $(H\otimes H)\left|E\right\rangle$ you need to consider each possibility (linear component) separately: \begin{align} (H\otimes H)\left|00\right\rangle &amp;= (\left|0\right\rangle+\left|1\right\rangle)(\left|0\right\rangle+\left|1\right\rangle) &amp;&amp;= \left|00\right\rangle+\left|01\right\rangle+\left|10\right\rangle+\left|11\right\rangle \\ (H\otimes H)\left|11\right\rangle &amp;= (\left|0\right\rangle-\left|1\right\rangle)(\left|0\right\rangle-\left|1\right\rangle) &amp;&amp;= \left|00\right\rangle-\left|01\right\rangle-\left|10\right\rangle+\left|11\right\rangle \\ \hline \therefore\;(H\otimes H)\left|E\right\rangle &amp;&amp;&amp;= \left|00\right\rangle \phantom{\,-\left|01\right\rangle-\left|10\right\rangle} + \left|11\right\rangle. \end{align}",5/13/2016 17:35
57977.0,Hadamard gate on entangled qubit,,<quantum-computing>,5/28/2016 7:25,,65380.0,"You don't have to do the whole matrix multiplication to get the final result. A more intuitive way is two write $$|00\rangle +|11\rangle = |0\rangle|0\rangle + |1\rangle|1\rangle\,.$$ Now apply the Hadamard gate on all terms of the first qubit and keep the second untouched. Since for a single qubit we have $H|0\rangle = |0\rangle+|1\rangle$ and $H|1\rangle =|0\rangle -|1\rangle$, we can write: \begin{align*} \big(H|0\rangle\big)|0\rangle + \big(H|1\rangle\big)|1\rangle &amp;= \big(|0\rangle+|1\rangle\big)|0\rangle + \big(|0\rangle -|1\rangle\big)|1\rangle\\ &amp; = |0\rangle|0\rangle + |1\rangle|0\rangle + |0\rangle|1\rangle - |1\rangle|1\rangle\\ &amp;= |00\rangle + |01\rangle + |10\rangle -|11\rangle\,. \end{align*} I have dropped the normalizations.",11/01/2016 15:00
58170.0,Can Quantum Computing solve Problems not even a Turing Machine can solve?,,<quantum-computing><computability>,06/02/2016 12:21,,58202.0,"As far as we believe, a quantum Turing machine is able to simulate any quantum computer, and it is also equivalent to classical deterministic Turing machine in terms of computability. In other words, as far as we know the space of problems solvable by quantum computers is the same as space of problems solvable by classical computers. However, if we consider practical computability, things may look a bit different. Imagine a problem where we have a classical solution which runs with $O(2^n)$ complexity. It is definitely solvable, but for any reasonable data size it will require massive amounts of operations. In practice, it will run for thousands of years, even on the fastest computers. Now imagine we have a quantum algorithm solving the same problem, but with $O(n)$ complexity. Out of a sudden, exact same problem can be solved in minutes, which is very reasonable (especially compared to thousands of years). I think the original quote could be extended by adding ""in any reasonable time"", and we get a fair statement.",06/03/2016 11:59
59728.0,How is the oracle function for Grover's Search algorithm obtained?,,<search-algorithms><quantum-computing>,6/16/2016 11:37,,59732.0,"On re-reading I found the source of the confusion. in classical logic, an oracle function is introduced in the construction of an inverse function x=f_inv(y) when you have an efficient y=f(x). You don't know how the oracle produces the output f_inv(x), but you know that you can check y=f(oracle(y)). In Grover's algorithm, the term quantum oracle operator is used for the function that checks if the ""quantum oracle"" is right, not for the actual oracle making the predictions.",6/16/2016 12:36
64374.0,Inputting a superposition into a cNOT gate,,<logic><quantum-computing><linear-algebra>,10/08/2016 21:07,,64378.0,"This is more of a question on linear algebra rather than a question about quantum computation. You should probably have a firm grip on basic linear algebra (vector spaces, linear operators, inner product, etc) before delving into quantum computation (there's no way around it). CNOT is a linear operator in our vector space, $\mathbb{C}^4$ (were only dealing with linear transformations, specifically unitary). In order to specify how a linear transformation operates on an arbitrary vector, it is enough to specify how it operates on each member of a basis for our vector space. Suppose we apply some linear operator $T$ on an arbitrary superposition, then by linearity: $T\left(\alpha |00\rangle + \beta|01\rangle+\gamma|10\rangle+\delta|11\rangle\right)= \alpha T|00\rangle+\beta T|01\rangle + \gamma T|10\rangle + \delta T|11\rangle$ $T|ij\rangle$ is the application of the operator $T$ on the vector $|ij\rangle$. The application of a linear operator in a finite dimensional vector space can be described by matrix multiplication, so this means multiplying the matrix representing $T$ by the vector $|ij\rangle$. The ""order"" you refer to does not matter, because addition in a vector space is commutative. Since you know how to apply CNOT to the four basic states, the above equality shows you how to apply it on an arbitrary superposition. When talking about matrix representation, the vector $\alpha |00\rangle + \beta|01\rangle+\gamma|10\rangle+\delta|11\rangle$ is represented by $ \begin{pmatrix} \alpha\\ \beta\\ \gamma\\ \delta \end{pmatrix} \in\mathbb{C}^4$, so applying CNOT to this state means multiplying it's matrix by this vector, i.e. $CNOT\left(\alpha |00\rangle + \beta|01\rangle+\gamma|10\rangle+\delta|11\rangle\right)= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix} \begin{pmatrix} \alpha\\ \beta\\ \gamma\\ \delta \end{pmatrix}= \begin{pmatrix} \alpha\\ \beta\\ \delta\\ \gamma \end{pmatrix} $. This is obviously equivalent to applying CNOT to each of the four vectors in $\mathbb{C}^4$ and adding up the results.",10/08/2016 23:05
65300.0,Do quantum logic gates work differently than traditional logic gates?,,<logic><quantum-computing>,10/30/2016 20:14,,101974.0,"Yes quantum logic gates work differently than traditional logic gates, the fact that a logic gate operates in 2 logical states, whereas a quantum gate operates according to a quantum instance.",12/23/2018 18:58
66080.0,Does applying Hadamard gate is identical to applying a measurement gate that is perpendicular to the current qubit state?,,<quantum-computing><circuits>,11/15/2016 15:22,,66088.0,"As Yuval points out, you have already answered your own question. If I have a state $|q\rangle = a|0\rangle + b|1\rangle$ and I apply a Hadamard gate to that state, I end up with a new state: $$H\cdot|q\rangle = \frac{1}{\sqrt{2}}(a+b)|0\rangle + \frac{1}{\sqrt{2}}(a-b)|1\rangle$$ However, if I measure the state $|q\rangle$ in the standard basis, I get either $|0\rangle$ with probability $|a|^2$ or $|1\rangle$ with probability $|b|^2$. Notice that both $|0\rangle$ and $|1\rangle$ are different states than what you would have gotten had you applied the Hadamard transform instead of a measurement. I admit that a Hadamard-transformed state of 50% $0$ and 50% $1$ looks very much like having done a measurement, but this is not true: you haven't done the measurement yet, and the state is still in superposition. This matters if you do other transformations afterward, or if you work in a multi-qubit system. Then when measuring later, it matters whether you did a Hadamard transform or a measurement. A good thing to do to acquaint yourself with transformations and measurements is to just compute some by hand on one qubit and on two qubits, and to write out in full the intermediate states in Deutsch's algorithm. You'll get the hang of it.",11/15/2016 19:11
66155.0,is $P_{CTC} = BPP_{path}$?,,<complexity-theory><complexity-classes><quantum-computing>,11/17/2016 15:29,,66275.0,"I believe I have found the answer: The proof is wrong. BPP_PATH is not in P_CTC because P_CTC is required to give a single definite answer, while BPP_PATH is a probabilistic algorithm, so the second reduction does not work. For it to work, one would have to use the time-travel information to count the number of successes of the probabilistic algorithm vs the number of its failures. I have no idea how to do this, or if it even can be done (probably not).",11/21/2016 14:59
66782.0,Doesn't a quantum algorithm being deterministic contradict the superposition principle?,,<complexity-theory><quantum-computing><probabilistic-algorithms>,12/02/2016 00:00,,66801.0,"If the algorithm has no error, then the system is not in a superposition when it is measured, but it is possible it was in a superposition during the computation, after which it was cleverly interfered constructively on the right answer(s) and interfered destructively on the wrong one(s). For example, Deutsch's algorithm has this property, the way he initially introduced it: the system is put into a superposition without entanglement, then it is operated on to produce a superposition in which the two qubits are entangled, and then it is operated on some more so that the final measurement is deterministic. One way to understand why some deterministic quantum algorithms use superposition is to see that an algorithm is a map from input vectors to output vectors. A good algorithm goes from the input vector to the output vector via the shortest path. The only steps that it can take are elementary gates (Hadamard, CNOT, X, Y, Z, etc.). Sometimes, the shortest path happens to be one in which the intermediate states are in a superposition, even if the final state is not. If this is the case, if all shortest paths involve superposition, then this problem is solvable more quickly by a quantum computer than by a classical computer, which cannot take those paths.",12/02/2016 12:14
67526.0,How can a probability distribution across classical states be computed for the measurement of a Quantum State represented by a Complex Vector?,,<quantum-computing>,12/16/2016 15:15,,67528.0,"The quantum state is a vector $v$ of unit norm. The probability of measuring outcome $x$ is $\|v_x\|^2$, the squared magnitude of the corresponding coefficient in the vector. Since $v$ has unit norm, these probabilities add up to $1$.",12/16/2016 16:19
69233.0,Is it proven that quantum computation is no better at solving NP complete problems than classical computation?,,<np-complete><quantum-computing>,1/24/2017 7:14,,69234.0,"It is suspected that NP-complete problems cannot be solved in quantum polynomial time (i.e., that they are not in BQP), but this hasn't been proved. We don't expect a proof in the near future, since this would imply that P is different from NP.",1/24/2017 7:33
70903.0,Showing that Hadamard is its own inverse,,<quantum-computing>,2/27/2017 8:51,,70909.0,"Rewrite your final expression as $$ \sum_{z \in \{0,1\}^n} \left| z \right\rangle \cdot \frac{1}{2^n} \sum_{y \in \{0,1\}^n} (-1)^{y \cdot (x+z)}. $$ So to complete the proof, we need to show that $$ \sum_{y \in \{0,1\}^n} (-1)^{y \cdot (x+z)} = \begin{cases} 2^n &amp; \text{if } x=z, \\ 0 &amp; \text{otherwise}. \end{cases} $$ If $x=z$ then $x+z = 0$ (computing modulo 2!), and so $(-1)^{y \cdot (x+z)} = 1$ for all $y$, hence the sum equals $2^n$. If $x \neq z$ then pick some $i$ such that $x_i \neq z_i$. We can partition $y$ into the $i$th coordinate $y_i$ and all the rest $y_{-i}$. Now $$ \sum_{y \in \{0,1\}^n} (-1)^{y \cdot (x+z)} = \sum_{y_{-i} \in \{0,1\}^{n-1}} (-1)^{y_{-i} \cdot (x+z)_{-i}} \sum_{y_i \in \{0,1\}} (-1)^{y_i \cdot (x+z)_i} = 0, $$ since $x_i+z_i = 1$ (modulo 2) and $\sum_{y_i \in \{0,1\}} (-1)^{y_i} = 1-1=0$.",2/27/2017 13:26
71532.0,Help on the notation of the 2-bit operation: $\frac 12{(I+Z_1Z_0)}$,,<quantum-computing><notation>,3/14/2017 17:23,,71534.0,"The operation $I$ on two bits can be written as the identity matrix, $$ I = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; 1 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 1 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp;1 \end{pmatrix}\,. $$ The operation $Z_0Z_1$ that performs $Z$ on both qubits can be written as $$ Z_0Z_1 = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; -1 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; -1 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}\,. $$ Now, the operation that you ask about, $\frac12(I+Z_0Z_1)$ is simply the operation described by $$ \frac12(I+Z_0Z_1) = \frac12 \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; 1 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 1 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp;1 \end{pmatrix} + \frac12 \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; -1 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; -1 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 0 &amp;1 \end{pmatrix}\,. $$ This indeed performs as you describe. If the $1/2$ wasn't there, we would get that $|0\rangle$ becomes $2|0\rangle$. Note that his operator is not unitary (it returns ""$0$"" for $|01\rangle$ and $|10\rangle$, which means the qubit ""disappears"", this shouldn't be allowed by quantum mechanics.)",3/14/2017 18:56
71532.0,Help on the notation of the 2-bit operation: $\frac 12{(I+Z_1Z_0)}$,,<quantum-computing><notation>,3/14/2017 17:23,,71543.0,The concept you're missing is simply that the operators are matrices.,3/14/2017 22:22
72439.0,Matrix for modular exponentiation in Shor's algorithm,,<quantum-computing>,04/03/2017 17:51,,73768.0,"Note that Shor's algorithm doesn't require modular exponentiation. All you need is (controlled) modular multiplication. There are two steps to getting the matrix for modular multiplication: Write a function to turn any permutation into a matrix. Apply it to the permutation $a \rightarrow a \cdot k \pmod{r}$. (Optional) Instead of making that matrix and multiplying by it, save massive execution time by just applying the permutation directly. For step 1, just have a function like this: import numpy as np def make_permutation_matrix(n, permutation): r = np.zeros((n, n)) for i in range(n): r[permutation(i), i] = 1 return r Then for step 2, use it: import math k = pow(base, exponent, modulus) n = math.ceil(math.log(modulus, 2)) mul_matrix = make_permutation_matrix( 2**n, permutation=lambda x: x*k % modulus)",04/10/2017 23:39
72471.0,Interpreting quantum oracles that makes a quantum operation,,<quantum-computing>,04/04/2017 13:02,,72492.0,"I would leave this as a comment, but I don't have enough reputation. The interpretation of the tensor in (9) is not correct. The quantum states are being represented in the computational basis, meaning, any state will be represented as a mixture of $|0\rangle$ and $|1\rangle$, but this is not particularly important, it could be any basis, in this case is just notationally easier. Further, the tenor in (9) is over the $\Omega_{YX}^i$, not the $C_{YX}^i$ (is this a typo?), and each $\Omega_{YX}^i$ is an operator, and thus the tensor $\Omega_{YX} = \bigotimes^{q-1}_{i=0}\Omega_{YX}^i$ would again be an operator, on the $q$ qubits. It could be easier to think of as a matrix, but this is not particularly beneficial I think. There is a typo I think. If $C^i_{YX} = 1$, $\Omega_{YX}^i$ would be a $2n$-CNOT, and not $\Omega_{YX}$ as you have written. When $C_{YX}^i = 1$, $\Omega_{YX}^i|0\rangle = |1\rangle$. I don't know what $C_{YX}^i$ represents, and I'm not familiar with what a $2n$-CNOT gate is, but I think probably it will not always be an $8\times 8$ matrix, especially since it has the variable $n$ in it. Sorry to not fully answer your question, but I hope I helped a bit.",04/04/2017 20:32
72670.0,universality of quantum gates,,<complexity-theory><quantum-computing>,04/08/2017 14:51,,73685.0,"Yes, approximate-any-quantum-gate implies can-solve-BQP-efficiently. Even if the cost of approximating gates is very high, you only need to approximate Hadamard, CNOT, and $Z^{1/4}$ operations to some constant fidelity before error correction starts to work. So although you may pay a large constant overhead to get ""good enough"", once you get there the extra overhead to achieve better and better precision becomes reasonable.",04/08/2017 21:08
73864.0,Would the P vs. NP problem become trivial as a result of the development of universal quantum computers?,,<complexity-theory><complexity-classes><quantum-computing>,04/12/2017 16:11,,73868.0,"No, there will be absolutely no implication, for several reasons: The P vs. NP problem is about classical computation rather than quantum computation. Even if quantum computers could solve NP-hard problems in polynomial time (which we don't expect them to be able to do), it could still be the case that classical computers cannot solve them in polynomial time. Universal quantum computers, in a theoretical sense, are (to the best of my knowledge) already known to exist. These are just the quantum analogs of universal Turing machines: they can execute any given quantum ""program"". Both quantum computation and the P vs. NP problem are theoretical notions. What someone can construct in the physical world has absolutely no bearing on anything having to do with them. Lieuwe Vinkhuijzen gave a different interpretation of your question: Will quantum computers be able to solve NP-complete problems efficiently? The expected answer is: no. So even in this sense, physical quantum computers won't enable us to solve NP-complete problems at will.",04/12/2017 17:43
73864.0,Would the P vs. NP problem become trivial as a result of the development of universal quantum computers?,,<complexity-theory><complexity-classes><quantum-computing>,04/12/2017 16:11,,73906.0,"In one (considered unlikely) scenario, building a universal quantum computer would indeed have implications on the problem of P vs. NP. This is expanding on the case mentioned by Yuval Filmus, ""if quantum computers could solve NP-hard problems in polynomial time"". In such a situation, building a universal quantum computer vs just theoretically reasoning about one, would have implications for the P vs NP problem. It would allow for the possibility of just using quantum computers to search/find a proof that resolves P vs NP, which could then be verified by a classical computer. However, as mentioned by the other answers, while there is no proof separating BQP and NP-complete, currently the evidence and expectations are that quantum computers will not be able to solve NP-complete problems efficiently.",4/13/2017 17:59
73864.0,Would the P vs. NP problem become trivial as a result of the development of universal quantum computers?,,<complexity-theory><complexity-classes><quantum-computing>,04/12/2017 16:11,,156564.0,"If there would be an efficient quantum computer algorithm for $NP$-complete problems, then the $P$ vs. $NP$ problem would be still unsolved. But if one can show, that there is no quantum computer to solve an $NP$-hard problem in polynomial time, then $P$ is unequal $NP$, because $P\subseteq BQP$. It is unlikely, that an $NP$-complete problem is in $BQP$. Due to the BBBV-Theorem Grover's algorithm is optimal for search problems $\{ x \in\{0,1\}^n\mid f(x)=1\}$ where f is a computable black-box function. In this case we need $\Theta(\sqrt(2^n))$ steps. If $M$ is an arbitrary Turing machine, then $L(M)$ is undecidable. Assume there is an oracle to compute $M$. Then one need $\Theta(\sqrt(2^n))$ accesses to the oracle with a QC. The set $\{\langle M, x, 1^t \rangle \mid \text{ TM }M \text{ accepts }x\in \{0,1\}^n\text{ within }t\text{ steps} \}$ is $NP$-complete. If $t$ is big enough, then $M$ accepts an $x\in\{0,1\}^n$ within $t$ steps iff $x\in L(M)$. In this case a QC can not search faster than Grover-like algorithm. So, quantum computers still need exponential run time for $NP$-complete problems. There are good reasons to believe, that $NP$-hard problems are not in $BQP$.",01/03/2023 12:40
75107.0,How is Grover's Algorithm useful?,,<quantum-computing>,05/08/2017 16:23,,75133.0,"The thing you're missing is that you aren't search for $|3\rangle$, you're searching for ""the input that makes $f$ return true"" where $f$ is some function. For example, maybe $f$ is a discrete logarithm checker like $x \rightarrow 2^x \equiv^? 432821 \pmod{7438927891}$. Or $f$ could interpret its input as a claimed proof of the Riemann hypothesis, and check if that proof is correct. Anything you can imagine checking, $f$ could be that. So Grover's algorithm is very very widely applicable. But unfortunately it also only gives a quadratic advantage, so ""applicable"" often doesn't translate into ""useful"". For example, the space of (reasonably sized) possible Riemann-hypothesis proofs is so huge that it laughs at square roots.",05/09/2017 03:43
75202.0,What is the difference between quantum computing and parallel computing?,,<computation-models><parallel-computing><quantum-computing>,05/10/2017 17:29,,75206.0,"One big difference is that in parallel computation separate processors need not be executing copies the same instruction at the same time in lockstep; they may be more loosely synchronized or in some cases completely desynchronized. In fact, separate processors need not be executing the same sequence of instructions. This is the distinction between SIMD [Single Instruction, Multiple Data] and MIMD [Multiple Instruction, Multiple Data] parallelism. Quantum computers are by nature SIMD (interpreting quantum superposition as equivalent to processor replication). Phrased another way: With multi-core you can run all the different processes on a laptop simultaneously; you cannot do that with a quantum processor.",05/10/2017 18:14
76243.0,Applying a 1-qubit gate to entangled qubits,,<quantum-computing>,06/02/2017 21:28,,76251.0,"I think you're confusing people talking about what must be done theoretically (to compute operations on qubits on paper) with people talking about what must be done experimentally (to operate on qubits in the real world). Do the answers contradict themself? No. The person who appeared to be saying ""you can't apply the operation"" just meant that the algebra you do to apply the operation won't start by factoring the state. When doing algebra you can't apply the operation in the simple way that you'd use when the qubits factor. Why can't we just do $A|0\rangle \otimes B |0\rangle + A|1\rangle \otimes B |1\rangle$? You can! $A|0\rangle \otimes B |0\rangle + A|1\rangle \otimes B |1\rangle$ is equivalent to $(A \otimes B) (|00\rangle + |11\rangle)$. To apply a Hadamard operation to one qubit while leaving the other alone, set $A=H$ and $B=I$. Alice has only 1 qubit, but UâI acts on 2 qubits. How does it work physically? Alice just does whatever she would do to apply $U$ to her single qubit. That applies the operation $U \otimes I$ to the system of two qubits.",06/02/2017 23:55
76961.0,Addition modulo 2 notation (Quantum Computing),,<quantum-computing><notation>,6/18/2017 16:38,,76981.0,"The definition shows how $U$ is defined on the standard basis (that is, when $\psi$ and $\phi$ are pure states). You can extend it to general states in a linear way. Two more comments: $\psi$ could be one qubit, but it could also be longer. $f$ is probably a deterministic function.",6/18/2017 22:48
76961.0,Addition modulo 2 notation (Quantum Computing),,<quantum-computing><notation>,6/18/2017 16:38,,77098.0,"The question is about the general case, but the purpose of U can be explained more clearly with an example. You can find in the book Quantum Computation and Quantum Information of Michael Nielsen and Isaac Chuang an example about period finding. Then the Unitary gate with the same definition $ U|\psi\rangle|\phi\rangle = |\psi\rangle|\phi \oplus f(\psi)\rangle $ is used in an algorithm with output r or repetition rate with f(x) = x + r. In this case and for the most algorithms in quantum computers, the addition modulo addition is used for the purpose its name implies. It is a binary operation for adding two numbers with a XOR operation or with the CNOT quantum gate. It is used in the period finding algorithms for its property to recognize the same output value with two different input values. Suppose we have a function $ f(x) = f(x \oplus s) $ with s is an fixed binary string 101. For x = 000 and x = 101 the result is the same in both cases. So you can find similar values in a periodic function",6/22/2017 10:55
77235.0,"What does it mean for a problem to be solved in polynomial time ""relative to"" an oracle?",,<complexity-theory><terminology><quantum-computing><probabilistic-algorithms><oracle-machines>,6/26/2017 8:31,,77246.0,"Oracles have nothing to do with non-determinism. They are just a communication mechanism between the algorithm (or Turing machine) and an outside entity, the oracle $O$, which is just a language. In the classical case, the algorithm can query the oracle on a specific input $x$, and it immediately gets the (Boolean) value of the oracle at that input: 1 if $x \in O$, and 0 if $x \notin O$. I'm not quite sure how this works in the quantum case, but perhaps the PDF explains that. The theorem states that there is some oracle that allows quantum algorithms to solve some problems much faster than classical ones. That is, if a quantum algorithm is given access to this oracle, then it can solve some problem in time Q, but a classical algorithm which is given such access can only solve the problem in time C$\gg$Q.",6/26/2017 12:30
77686.0,Asserting Run Time From Big O Function,,<asymptotics><complexity-classes><quantum-computing>,07/07/2017 23:55,,77688.0,"The base of logarithms is irrelevant in big-O notation, since $$\log_b x = \frac{\log_a x}{\log_a b} = O(\log_a x)\,,$$ so $O(\log_a x)$ and $O(\log_b x)$ denote exactly the same class of functions. The assertions made by the paper about how long a certain computer would take to solve some problem don't appear to be well founded. As a minor issue, doesn't ""terahertz range computer"" mean $10^{12}$ operations per second, not one million per second? But the major point is that $O(n^2\log n\log\log n)$ is not the same thing as $n^2\log n\log\log n$: it's merely a statement that, there's some constant&nbsp;$c$ such that, for large enough&nbsp;$n$, the number of computation steps is at most $cn^2\log n\log\log n$. In particular, it doesn't tell us what the value of&nbsp;$c$ is: it could be $10^{-100}$ or $10^{100}$ or anything else. Further, the analysis is never sufficiently precise to equate some number of ""computation steps"" with an actual number of machine instructions. You simply cannot turn an asymptotic expression such as this into a running time in seconds without more information. One possible way to obtain the value of&nbsp;$c$ would be to time the actual execution of the program, but this isn't possible as we don't have any quantum computers that can run Shor's algorithm on $1000$-digit numbers. I don't see anything that would enable the authors of the paper to give precise wall-clock running times for a program on a computer that doesn't exist. It appears that the authors are using $\ln$ to denote base-$2$ logarithms, since they say that a $k$-digit number equates to $k\ln10$ bits. A 1000-digit number is about 3300 bits and $$3300^2\log_2 3300\log_2\log_2 3300\approx 451\times 10^6\,,$$ so that's certainly not where the $84$-second claim comes from. It seems, in fact, to come from interpreting $\ln$ as meaning the natural logarithm. Based on the incorrect claim that a $1000$-digit number has $1000\log_e 10\approx 2300$ bits, we get $$2300^2\log_e 2300\log_e\log_e2300\approx 84\times 10^6\,.$$ This calculation is not meaningful in any way.",07/08/2017 00:40
77686.0,Asserting Run Time From Big O Function,,<asymptotics><complexity-classes><quantum-computing>,07/07/2017 23:55,,77689.0,"No. You can't predict the concrete running time based on an asymptotic expression for the running time, as asymptotic analysis ignores constant factors. You don't know whether the big-O notation hides a factor of 3 or 3 million.",07/08/2017 00:40
77840.0,Can quantum computer compute the minimal intersection DFA of numerous minimal DFAs in polynomial time using polynomial number of qubits?,,<complexity-theory><formal-languages><finite-automata><quantum-computing>,07/12/2017 13:05,,77857.0,"No. The size of the minimal DFA for the intersection might be exponentially large. Therefore, no computer can compute it in polynomial time, not even a quantum computer -- it requires exponential time even to write down the answer. In particular, if you have $n$ languages, each of whose minimal DFA has size $m$, then the minimal DFA for their intersection can be as large as $\Theta(m^n)$. This is exponential in $n$. Separately: it is known that $\mathbf{BQP} \subseteq \mathbf{PSPACE}$. it is generally believed/conjectured that $\mathbf{BQP} \subsetneq \mathbf{PSPACE}$ (i.e., it is a proper subset); if that is correct, then it follows that no PSPACE-complete problem can be solved by a quantum computer in polynomial time.",07/12/2017 19:55
79855.0,How are Qubits useful?,,<computation-models><quantum-computing>,08/08/2017 10:00,,79872.0,"So you can't find out everything about the value of a qubit. That doesn't mean you know nothing about it. And, sure, quantum computing probably would be more powerful if you could find out everything about the value. But, again, the fact that you can't do everything doesn't mean that you can't do anything. In particular, you know that the measured value of a qubit drawn from a probability distribution constructed by some quantum algorithm. The algorithm will, presumably, construct a distribution that's quite tightly concentrated about the true answer. And you can always repeat the computation to get multiple samples.",08/08/2017 20:41
79990.0,Can quantum computer compute the sum of $n$ natural numbers in $\Theta(\log n)$ time?,,<complexity-theory><time-complexity><runtime-analysis><quantum-computing>,08/12/2017 17:46,,80052.0,"No, a quantum computer can't sum $n$ outputs from a black box function in $O(\lg n)$ queries. For example, you could use magic summing power to easily do asymptotically better than Grover's algorithm at searching for solutions to a predicate. Except Grover's algorithm is proven to be asymptotically optimal. Contradiction. Also, magic summing would trivially prove that $NP \subseteq BQP$. To determine if problem X has a solution or not, you'd simply sum up the outputs of the black box ""if input is a solution for problem X then output 1 else output 0"".",8/13/2017 22:14
80538.0,Is it possible to construct a C^5(U) with V^2=U and no work qubits (Nielsen & Chuang Exercise 4.28),,<quantum-computing><circuits>,8/28/2017 9:59,,138853.0,"It is not possible. We can consider the simpler case of constructing $C^3(U)$ using only $\tt{CNOT}$, Toffoli, $U$, $V$, $C(U)$, $C^2(U)$ and $C(V)$ where $V^2=1$. We consider the determinant of the matrix representation of the gates over only the first 3 qubits (so the outcome of the determinant is an operator on the last qubit), and we have: $$ C^3(U) = \left.\begin{array}{ccc}- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; U &amp; -\end{array}\right. = \left(\begin{array}{cccccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U\end{array}\right) \Rightarrow \det C^3(U) = U $$ $$ C^2(U) = \begin{array}{ccc}- &amp; - &amp; - \\ &amp; &amp; \\- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; U &amp; -\end{array} = \left(\begin{array}{cccccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U\end{array}\right) \Rightarrow \det C^2(U) = U^2 $$ $$ C(U) = \left.\begin{array}{ccc}- &amp; - &amp; - \\ &amp; &amp; \\- &amp; - &amp; - \\ &amp; &amp; \\- &amp; \bullet &amp; - \\ &amp; | &amp; \\- &amp; U &amp; -\end{array}\right. = \left(\begin{array}{cccccccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U\end{array}\right) \Rightarrow \det C(U) = U^4 $$ $$ U = \begin{array}{ccc}- &amp; - &amp; - \\ &amp; &amp; \\- &amp; - &amp; - \\ &amp; &amp; \\- &amp; - &amp; - \\ &amp; &amp; \\- &amp; U &amp; -\end{array} = \left(\begin{array}{cccccccc}U &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; U\end{array}\right) \Rightarrow \det U = U^8 $$ Similarly, we can prove $\det V = V^8 = U^4$ and $\det C(V) = V^4 = U^2$. The determinant of $\tt{CNOT}$ and Toffoli do not involve factors of $U$ so they will not affect the analysis below. Now suppose $C^3(U)$ can be constructed by the combinations $C^3(U) = G_1 G_2 \cdots$, where each $G_i$ is among the gates stated above, then we must have: $$ \det C^3(U) = \prod_i \det G_i \Rightarrow \prod_i \det G_i = U $$ This identity is however impossible to satisfy using the gates above because the determinants of $U$, $V$, $C(U)$, $C^2(U)$ and $C(V)$ all give even powers of $U$. The only possible way out is to include $C(\sqrt{V})$ because $\det C(\sqrt{V})=\sqrt{V}^4= U$. But $C(\sqrt{V})$ can be used to construct $C^2(V)$. If we can use $C^2(V)$, then the solution to (4.28) is rather obvious and we get the solution given by Bram. The proof for more qubits is similar. I am a physicist, not specialized in quantum computing. Question 4.28 was indeed frustrating. Up until that question, the underlying principle of the chapter was the construction of more complicated gates using more elementary gates. Had I known the authors wanted us to use $C^2(V)$ (which would require $C(\sqrt{V})$ gate, which may or may not exist, not previously constructed nor alluded to in the question), I would have solved the question in less than a minute. Perhaps proving once and for all there is no solution (the way most readers would interpret the question) will save others from the frustration.",04/12/2021 00:54
80548.0,Quantum Computing Superposition,,<quantum-computing>,8/28/2017 16:36,,80551.0,"Your assumptions are wrong, and I suggest picking up a textbook on quantum computing. The state of $n$ qubits can be described by $2^n$ complex numbers $\varphi_x$ whose squared magnitudes sum to 1. You can think of these $2^n$ complex numbers as indexed by $\{0,1\}^n$. When you ""read"" the $i$th qubit (the technical term is ""measure""), what happens is that with probability $p_b := \sum_{x\colon x_i=b} |\varphi_x|^2$ you see the value $b$. Moreover, from now on the value of this qubit will always be $b$ (unless you apply quantum operations to it). The rest of the state is updated accordingly: $\varphi_x := 0$ if $x_i \neq b$ and $\varphi_x := \varphi_x/\sqrt{p_b}$ if $x_i = b$.",8/28/2017 18:15
83379.0,Solving simultaneous multiple chinese remainder theorem on the quantum computer - possible?,,<quantum-computing>,11/03/2017 18:01,,83392.0,"If you prepare a superposition containing the various input problems, a quantum computer will allow you to compute a superposition containing the various outputs. That being said, I'm not sure why you would want to do this. You only get to sample one of the outputs, and you don't get to pick which one. You'll get one of them at random. Presumably you would instead do some quantum computation on the output superposition, perhaps use a QFT to sample from their frequency space... but just remember that this means you must erase the input! Otherwise you won't be able to interfere the various output cases.",11/04/2017 01:33
83871.0,Traveling Salesman -- number of qubits required?,,<algorithms><complexity-theory><quantum-computing><traveling-salesman>,11/09/2017 02:35,,83948.0,"The notebook describes how to solve combinatorial optimization problems by encoding them as minimizing a binary quadratic form, which can in turn be phrased as finding the minimal eigenvalue of a Hamiltonian, and so solved by a quantum computer. The number of qubits needed is the dimension of the Hamiltonian, which is also the number of bits in the encoding. In TSP, the optimization is over permutations. The notebook suggests encoding a permutation by encoding its permutation matrix, which is an $n\times n$ binary matrix. Since the rows and columns sum to 1, we can deduce the final row and column from the rest of the entry, and so need to keep only $(n-1)^2$ variables. In your example, $n = 4$ and so $(n-1)^2 = 9$.",11/15/2017 7:35
84138.0,How is it possible to compare $P$ class with $BQP$?,,<algorithms><complexity-theory><quantum-computing>,11/19/2017 15:03,,84142.0,"$\mathsf{P}$ and $\mathsf{BQP}$ are classes of languages, not algorithms. Namely, a language belongs to $\mathsf{P}$ if there exists a Turing machine that decides it in polynomial time, and to $\mathsf{BQP}$ if there exists a quantum Turing machine that decides it in polynomial time with up to $1/3$ two-sided error. Although their definitions invoke different computational models, both $\mathsf{P}$ and $\mathsf{BQP}$ are sets of languages, we compare them as we would compare any other pair of sets.",11/19/2017 15:50
84138.0,How is it possible to compare $P$ class with $BQP$?,,<algorithms><complexity-theory><quantum-computing>,11/19/2017 15:03,,84143.0,"BQP is simply a set of languages, i.e. $\mathsf{BQP}\subseteq 2^{\Sigma^*}$, and in that sense it can be compared with any other set of languages, such as $\mathsf{P, NP}$. It doesn't matter how those sets are defined, as we can always ask whether they are comparable under the inclusion relation. You can ask why does it make sense to compare classes obtained from different models of computation (e.g. uniform polynomial size quantum circuits vs polynomial time Turing machines). The idea is to try and capture the notion of ""efficiently computable"" relative to each model. If you agree that efficiency in quantum/classic computation is captured by BQP and P, then the question ""can quantum computers solve more problems efficiently"" translates to whether or not $\mathsf{P\subsetneq BQP}$.",11/19/2017 15:53
85845.0,Quantum computing - Difference between a binary bit and a Q-bit,,<complexity-theory><computer-architecture><quantum-computing>,12/23/2017 18:16,,85847.0,"The state of an $n$-bit quantum system is described by $2^n$ complex numbers $c_x$ â indexed by vectors in $\{0,1\}^n$ â such that $\sum_x |c_x|^2 = 1$. (Some people consider these numbers only up to ""rotation"", that is, up to multiplication by a complex number of unit modulus.) Compare this to an $n$-bit classical system, whose state is a single vector in $\{0,1\}^n$, and to an $n$-bit classical system with randomness, whose state is a probability distribution over $\{0,1\}^n$, that is, it is described by $2^n$ non-negative real numbers $r_x$ summing to 1, $\sum_x r_x = 1$. The state of a system is what you need to know in order to follow the evolution of the system, and eventually determine the output. The evolution of a quantum system is described by (local) unitary operations, which you can think of as $2^n \times 2^n$ complex unitary matrices which operate on the state by multiplying it. At the very end, the state of the system is measured, and then it collapses to the deterministic state $x$ with probability $|c_x|^2$ (you can also measure just some of the qubits during the computation, but let's ignore that). Notice how you need to know all $c_x$ in order to understand how the system evolves and what is its output. In contrast, to understand the evolution and output of a classical system, you just need to know the contents of all the bits, which is described by a vector in $\{0,1\}^n$.",12/23/2017 18:32
85845.0,Quantum computing - Difference between a binary bit and a Q-bit,,<complexity-theory><computer-architecture><quantum-computing>,12/23/2017 18:16,,85848.0,"I think something worth pointing out early on is the ambiguity of the word state. In quantum information most things have very strong (shall I say natural?) physical interpretations / origins. In classical information we represent information as bits. A bit might correspond to the state of some classical system, such as an electric sign in a circuit, etc. Evolution of classical bit vectors is arbitrary in the sense that its enforced by us humans. In quantum computing information is represented using states of a quantum system (for example polarization of a photon). The states of a quantum system can be identified with vectors of a Hilbert space. Qubits $|0\rangle, |1\rangle$ are just an arbitrary choice bases of a two dimensional space. A two-qubit state represents a quantum system which is a composite of two two-dimensional subsystems. Evolution of quantum state vectors are governed by the laws of physics. For a classical two-bit vector, the permissible values are $00,01,10,11$, whereas for a two-qubit system you can have any $a|00\rangle+b|01\rangle+c|10\rangle+d|11\rangle$ for $a,b,c,d\in\mathbb{C}$ provided that $|a|^2+|b|^2+|c|^2+|d|^2=1$. This, together with the postulates of quantum mechanics, permits a completely different range of behaviors of quantum systems (and qubit vectors), behaviors that are unseen in classical systems. This gives the above representation of information a lot more power compared to classical information representation. A number of physical phenomena allow various interesting information theoretic operations (such as teleportation, superdense coding, etc), which are not admissible using classical systems. The emphasis here really is on the fact that in quantum computing you can exploit a range of physical phenomena that is not typical in classical information theory.",12/23/2017 19:29
86913.0,How is this definition of the quantum Fourier transform to be understood?,,<quantum-computing><fourier-transform>,1/18/2018 7:05,,86924.0,"The index $\mathbf{k}$ goes over all vectors in $\{0,1\}^n$ (which can be identified with $\mathbb{Z}_2^n$). The index $\mathbf{x}$ also has the same range, and $\mathbf{k} \cdot \mathbf{x} = \sum_{i=1}^n k_i x_i$. You can think of this sum as being computed modulo 2 (or in $\mathbb{Z}_2$) if you wish, since $(-1)^2 = 1$. As an example, when $n = 2$ we get $$ \begin{align*} \tilde{a}_{00} &amp;= \frac{a_{00} + a_{01} + a_{10} + a_{11}}{2}, \\ \tilde{a}_{01} &amp;= \frac{a_{00} - a_{01} + a_{10} - a_{11}}{2}, \\ \tilde{a}_{10} &amp;= \frac{a_{00} + a_{01} - a_{10} - a_{11}}{2}, \\ \tilde{a}_{11} &amp;= \frac{a_{00} - a_{01} - a_{10} + a_{11}}{2}. \end{align*} $$ This is exactly the tensor square of the $2\times 2$ Hadamard matrix.",1/18/2018 14:05
87870.0,How $N$ qubits correspond to $2^N$ bits?,,<computation-models><quantum-computing>,02/08/2018 18:05,,155417.0,"You can think of $ \lvert 0 \rangle $ or $ \lvert 1 \rangle $ as the standard basis of $ \mathbb{C}^2 $. In this sense, a single qubit $ \lvert \psi \rangle $ is nothing more than a unit vector in $ \mathbb{C}^2 $, that is, a linear combination of $ \lvert 0 \rangle $ and $ \lvert 1 \rangle $ with length $1$. Now, a $N$ qubit is an element of $ \mathbb{C}^{2^N} $ since it is defined via the tensor product of single qubits. Maybe that is where (the absurdity) &quot;$N$ qubits correspond to $2^N$ bits&quot; comes from.",11/14/2022 2:38
87938.0,Difference between CNOT and 2nd bit bitflip,,<quantum-computing><bit-manipulation>,02/10/2018 12:13,,87942.0,"The controlled NOT gate is represented by the matrix $$ \begin{pmatrix} 1&amp;0&amp;0&amp;0\\ 0&amp;1&amp;0&amp;0\\ 0&amp;0&amp;0&amp;1\\ 0&amp;0&amp;1&amp;0 \end{pmatrix} $$ In contrast, the matrix corresponding to negating the second bit is $$ \begin{pmatrix} 0&amp;1&amp;0&amp;0\\ 1&amp;0&amp;0&amp;0\\ 0&amp;0&amp;0&amp;1\\ 0&amp;0&amp;1&amp;0 \end{pmatrix} $$",02/10/2018 13:11
88639.0,Question about H-gate on entangled qubits,,<quantum-computing>,2/26/2018 20:19,,88640.0,"Assuming that the initial quantum state is $\left| 00 \right\rangle$, the effect of the circuit is $$ \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; -1 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \cdot \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; -1 \end{bmatrix} \cdot \begin{bmatrix} 1\\0\\0\\0 \end{bmatrix} = \begin{bmatrix} 1/2\\1/2\\1/2\\-1/2 \end{bmatrix}, $$ where the rows and columns are indexed by $\left|q_0q_1\right\rangle = \left|00\right\rangle,\left|01\right\rangle,\left|10\right\rangle,\left|11\right\rangle$. When you measure the two qubits at the end, you should get each of the four possibilities with probability $(\pm 1/2)^2 = 1/4$, which is exactly what you have observed. If, however, you apply the CNOT gate with input roles reversed, you get $$ \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; -1 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix} \cdot \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; -1 \end{bmatrix} \cdot \begin{bmatrix} 1\\0\\0\\0 \end{bmatrix} = \begin{bmatrix} 1\\0\\0\\0 \end{bmatrix}, $$ so in this case you will always measure $\left|00\right\rangle$.",2/26/2018 20:35
89389.0,Should we always think of problems higher in the polynomial hierarchy as harder than problems lower in the hierarchy?,,<complexity-theory><np-complete><complexity-classes><quantum-computing>,3/15/2018 22:16,,89428.0,"The answer to your actual question is yes. The only thing I would (nitpickingly) change about the text you cite is that, when it talks about the $(k+1)$-st level, it should acknowledge that it includes the $k$-th level. So the ""one notch higher"" happens only for problems that are new in the $(k+1)$-st level. One thing the polynomial hierarchy does not do is encompass all problems. It ""classifies problems according to [...] complexity"", but only those problems, which it happens to contain. The popular conjecture seems to be that BQP is incomparable with PH. (There are problems in NP which are conjectured not to be in BQP and problems in BQP which are conjectured not to be in PH.) And that is not even surprising. PH and BQP extend P in different ways. PH by (bounded-alternation) nondeterminism, BQP by quantum. A priori there is no reason to assume the resulting classes to be comparable.",3/16/2018 21:14
92886.0,How to apply a Hadamard gate to one qubit in a 2-qubit system?,,<quantum-computing>,06/09/2018 01:55,,92902.0,"The problem is in the order of the transformations. The first transformation you apply in the circuit is $I\otimes X$, whereas in the computation of $M$ it is actually the last. Recall that the rightmost operator is the first to act on the state (matrix multiplication is not commutative). Fixing that we obtain: $$ M=(H\otimes I)(I\otimes X)CNOT(I\otimes X) = \begin{bmatrix} H &amp; 0 \\ 0 &amp; H \end{bmatrix} \begin{bmatrix} X &amp; 0 \\ 0 &amp; X \end{bmatrix} \begin{bmatrix} I &amp; 0 \\ 0 &amp; X \end{bmatrix} \begin{bmatrix} X &amp; 0 \\ 0 &amp; X \end{bmatrix}= \begin{bmatrix} H &amp; 0 \\ 0 &amp; H \end{bmatrix} \begin{bmatrix} X &amp; 0 \\ 0 &amp; X \end{bmatrix} \begin{bmatrix} X &amp; 0 \\ 0 &amp; I \end{bmatrix}= \begin{bmatrix} I &amp; I \\ I &amp; -I \end{bmatrix} \begin{bmatrix} I &amp; 0 \\ 0 &amp; X \end{bmatrix}= \begin{bmatrix} I &amp; X \\ I &amp; -X \end{bmatrix} $$ Now applying $M$ on $|00\rangle$ will yield the right result.",06/09/2018 14:33
93658.0,Reversible computation and no cloning theorem in quantum computing,,<quantum-computing><reversible-computing>,6/29/2018 15:17,,93661.0,"No-cloning theorem refers to creation of independent copies of a qubit. With CNOT gates youâll only create mirrors. For instance, if you have $\alpha \left| 0 \right&gt; + \beta \left| 1 \right&gt;$ and measure it, youâll get 0 with probability $p_a=|\alpha|^2$ and 1 with $p_b=|\beta|^2$. Now if you clone this qubit and measure both, you should get 00 with probability $p_a^2$, 01 with $p_a p_b$, 10 with $p_b p_a$ and 11 with $p_b^2$. Mirroring with CNOT gives a different picture: 00 with $p_a$, 11 with $p_b$ and zero probability for 01 and 10.",6/29/2018 19:05
93860.0,Shor's algorithm and offset elimination,,<quantum-computing>,07/04/2018 11:50,,93871.0,"Yes, if you could consistently eliminate the offset then that would be enough. But how are you going to do that? The state's offset is the discrete logarithm of the value in the ancilla register. But you don't know how to compute the discrete logarithm efficiently classically. And the offset changes from sample to sample. And there are so many possible offsets (assuming you picked a big number to factor) that you won't see the same one twice.",07/04/2018 17:50
93988.0,Rows and columns in quantum-gate matrices read the same - why?,,<quantum-computing><matrices>,07/07/2018 13:18,,96526.0,"A counter-example to your observation is the Pauli Y gate: $$Y = \begin{bmatrix} 0&amp;-i\\i&amp;0\end{bmatrix}$$ The first row is 0 then -i, but the first column is 0 then +i. Another example is the X->Y->Z->X gate (a 120 degree rotation around the X+Y+Z axis of the bloch sphere): $$\frac{1-i}{2} \begin{bmatrix} 1&amp;-i\\1&amp;i\end{bmatrix}$$ The reason the rows often look so much like the columns, particularly for self-inverse operations, is because quantum gates are unitary and the inverse of a unitary matrix is its conjugate transpose. But you can easily break the symmetry by multiplying an individual row (or column) by a phase factor, which produces a different but valid quantum operation.",8/22/2018 16:22
96014.0,Can hypercomputation compute all kinds of incomputable numbers/functions/problemsâ¦etc?,,<computability><quantum-computing><hypercomputation>,08/06/2018 01:21,,96035.0,"Not only is hypercomputation believed to be physically impossible, but even more ambitiously, some people working at the intersection of physics and computer science think that P!=NP might be a physical principle.",08/07/2018 01:41
96010.0,Is my interpretation correct?,,<algorithms><complexity-theory><quantum-computing>,08/06/2018 12:19,,96011.0,"Given a matrix $A$, you can form another matrix by taking only some of the rows and columns of $A$, possibly repeated. For example, suppose that $A$ is the following matrix: $$ \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix} $$ If we take only rows 1,2 and columns 1,3, then we get the matrix $$ \begin{bmatrix} 1 &amp; 3 \\ 4 &amp; 6 \end{bmatrix} $$ For your second question, $\mathcal{D}_x$ is a distribution on column indices. You don't choose a column directly â you only choose an index. This corresponds to 1,3 in the example above.",08/06/2018 12:59
96816.0,Proof that a quantum computer is equivalent to some logical circuit,,<computability><quantum-computing><circuits>,8/30/2018 21:51,,96817.0,It's not a valid proof (yet) because you haven't described how you plan to do step 3. You also haven't described how you plan to deal with superpositions of states.,8/30/2018 22:36
97452.0,whatâs wrong with this quantum key distribution scheme?,,<quantum-computing>,9/17/2018 13:36,,97454.0,"No, not really. The main problem with this protocol is that it is less practical than BB84. Less practical Bob is a benign party. To measure a q-bit, you need to know what basis to measure it in before you can measure it (e.g., before you can measure a photon, you need to have your measurement apparatus set up in the appropriate basis). Ordinarily, we'd like to measure it as soon as we receive it. Your protocol doesn't allow that. Your protocol requires Bob to receive the q-bit and then decide later what basis to use to measure it. That means Bob will need some way to store the q-bit for later measurement. There might be a way to do that (e.g., put the photon into a long delay loop), but it will probably increase complexity and expense. It's not reasonable to expect legitimate parties to have to do that just to communicate. And in any case, BB84 doesn't require parties to jump through those hoops. So your scheme is less practical than BB84. Side note on security: With your protocol, it is important that step 4 (including Bob's confirmation) be over an authenticated channel. Without that, there is a security problem. BB84 provides the following security property: if the final reconciliation phase is done over an authenticated channel (not necessarily secret; it can be public communication; but it does need to be authenticated), and if the parties don't abort, then the resulting secret will be known only to Alice and Bob. In particular, no adversary -- not even an active man-in-the-middle attacker -- can arrange to learn the secret. Your protocol doesn't offer that guarantee, if step 4 happens over an insecure channel. With your protocol, there's a trivial way that a man-in-the-middle can arrange to learn the secret, with zero chance of being detected. When Alice sends the q-bits, the adversary Mallet intercepts and stores them. Mallet then sends a confirmation that the q-bits were received to Alice (pretending that this came from Bob). When Alice sends $y$, Mallet intercepts and learns $y$. Now Mallet decodes all the q-bits using $y$, and learns $x$. In the second phase, Mallet encodes $x$ into new q-bits and sends those q-bits to Bob (pretending they came from Alice). When Bob responds that he has received them, Mallet sends $y$ to Bob (pretending it came from Alice). Now Bob will decode his q-bits, obtain the same value $x$, send back some of the bits of $x$ to Alice, everything will match, and both Alice and Bob will think that they have obtained a secure key -- but Mallet actually knows that secret key, since Mallet has learned $x$. This attack works even if steps 5 and 6 are done over an authenticated channel. I suspect it suffices to require step 4 to also go over an authenticated channel (I'm not 100% sure; that would require proof; but it looks like it to me).",9/17/2018 14:19
97593.0,Why canât a qbit be both entangled and in a pure state?,,<quantum-computing>,9/21/2018 5:02,,97595.0,"First, let's look at the density matrix for A in the two cases. When A is in the pure state $|+\rangle$, we have \begin{align} \rho_+ = |+\rangle\langle+| = \frac{1}{2}\left(|0\rangle + |1\rangle\right)\left(\langle0| + \langle1|\right) \end{align} As a matrix, we'd write this \begin{align} \rho_{+} = \frac{1}{2} \begin{pmatrix} 1 &amp; 1\\1&amp; 1 \end{pmatrix}. \end{align} When A is entangled with B, we can obtain the (reduced) density matrix for A by tracing over all B states: \begin{align} \rho_A &amp;= \frac{1}{2}\text{Tr}_B\left[\left(|0\rangle\otimes|0\rangle + |1\rangle\otimes|1\rangle\right)\left(\langle0|\otimes\langle0| + \langle1|\otimes\langle1|\right)\right]\\ &amp;= \frac{1}{2}\left(|0\rangle\langle0| + |1\rangle\langle1|\right), \end{align} or, as a matrix, \begin{align} \rho_{A} = \frac{1}{2} \begin{pmatrix} 1 &amp; 0\\0&amp; 1 \end{pmatrix}. \end{align} Ok, you say, the density matrices are different. Who cares? Well, we don't really care about states, because we can't measure states directly. But we can measure observables, and we can find the expectation value for those measurements using our states. Specifically, we can find the expectation value of $\mathcal{O}$ by taking $\langle\mathcal{O}\rangle = \text{Tr}\,(\rho\mathcal{O})$. Let's look at the example of the $X$ operator. We have \begin{align} \langle X\rangle_+ &amp;= \frac{1}{2}\text{Tr}\,(\rho_+ X)\\ &amp;= \frac{1}{2}\text{Tr}\,\left[ \begin{pmatrix}1&amp;1\\1&amp;1\end{pmatrix}\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix}\right]\\ &amp;=\frac{1}{2}\text{Tr}\,\begin{pmatrix}1&amp;1\\1&amp;1\end{pmatrix} = 1. \end{align} In the state $\rho_A$, however, we have \begin{align} \langle X\rangle_A &amp;= \frac{1}{2}\text{Tr}\,(\rho_A X)\\ &amp;= \frac{1}{2}\text{Tr}\,\left[ \begin{pmatrix}1&amp;0\\0&amp;1\end{pmatrix}\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix}\right]\\ &amp;=\frac{1}{2}\text{Tr}\,\begin{pmatrix}0&amp;1\\1&amp;0\end{pmatrix} = 0. \end{align} We obtain different experimental predictions for the outcome of measurements in these two states, and so we can distinguish between them. Edit: I didn't really answer your question beyond showing how states in the example you gave lead to different predictions. I would say the more broad lesson to draw is that when system A is entangled with system B, measurements on B can change the outcome of measurements on A. This leads to an additional, classical uncertainty in our measurements that is not present when A is in a pure, unentangled state.",9/21/2018 5:38
97593.0,Why canât a qbit be both entangled and in a pure state?,,<quantum-computing>,9/21/2018 5:02,,97603.0,"Let $A$ and $B$ be prepared and then put apart. First case: $A$ is in $|+\rangle$ state and $B$ is in $|0\rangle$. Now let's apply Hadamard gate to $A$ (I'll omit normalization): $$H_A(|00\rangle+|10\rangle) = |00\rangle$$ Then if we look at $A$ we'll observe it in $|0\rangle$, which is expected for such a superposition being hadamarded. Second case: $A$ and $B$ are entangled. Again, we apply Hadamard gate to $A$ only: $$H_A(|00\rangle+|11\rangle) = |00\rangle+|01\rangle+|10\rangle-|11\rangle$$ This means that if we look at $A$, we'll observe it either in $|0\rangle$ or $|1\rangle$ equiprobably. The difference is caused by positive and negative amplitudes contributing to the same $|10\rangle$ outcome in the first case (giving zero probability), while in the second case they go into different $|10\rangle$ and $|11\rangle$. Despite the fact that we didn't do anything to $B$ (not even measured it), there's detectable difference caused by the entanglement. That's what entanglement means: talking about individual qubits doesn't make sense anymore.",9/21/2018 8:45
97651.0,Simple question on the phrasing on a PBS Infinite Series video,,<quantum-computing>,9/22/2018 19:18,,97652.0,"The state of an $n$-qubit system is a superposition of the $2^n$ pure states $$ \sum_{x \in \{0,1\}^n} \alpha_x \left| x \right\rangle, $$ where the $\alpha_x$ are complex numbers satisfying $\sum_x |\alpha_x|^2 = 1$. The $2^n$-dimensional (complex) sphere is just $$ \{ (\alpha_{0\dots0},\ldots,\alpha_{1\dots1}) \in \mathbb{C}^{2^n} : \sum_x |\alpha_x|^2 = 1 \}. $$ I'm not sure what ""finding"" $\left|010001\right\rangle$ on the sphere means, though.",9/22/2018 19:37
99286.0,Hadamard transformation and measurement of one qubit,,<quantum-computing>,10/29/2018 19:26,,101010.0,"I'm not the best person to answer your question but I'll give it a try. 1st Question: You do not yet make a measurement after applying the Hadamard Operator on your first qubit. Afterwards say you make a measurement on your 1st qubit, the state you'll end up with is: $|\psi&gt;_{post-measurement}$ = $1/\sqrt{p_1(m)}$ $\sum_{j} c_{mj} |m&gt;_1 |j&gt;_2$ whereby $m$ is the measurement result of your 1st qubit (either 0 or 1) , $p_1(m)$ is the probability of getting that result on your 1st qubit, $c_{mj}$ the usual coefficient infront of your ket. 2nd Question: This will answer how to get ${p_1(m)}$. Write out the density matrix of $|\psi&gt;_{pre-measurement}$, then trace out the 2nd qubit. Then apply bra-ket to your reduced density matrix: ${p_1(m)}$ = $&lt;m|_{1}$ $\rho_{1} |m&gt;_{1}$ Or equivalently: ${p_1(m)}$ = $\sum_{n}|&lt;m|_1&lt;n|_2 \sum_{ij} c_{ij} |i&gt;_1|j&gt;_2|^2$",12/04/2018 14:43
99286.0,Hadamard transformation and measurement of one qubit,,<quantum-computing>,10/29/2018 19:26,,101013.0,"After applying $H$ to the first qubit you have this state: $$\frac{1}{2}(\left|00\right&gt;-\left|01\right&gt;+\left|10\right&gt;+\left|11\right&gt;)$$ You square the absolute values of the amplitudes to obtain probabilities of each of possible outcomes. In this case it is $1/4$ for each of the outcomes. Half of them has $\left|0\right&gt;$ for first qubit, so its sum probability is $1/2$.",12/04/2018 16:01
100864.0,"In the shor's quantum circuit, what is the transformation of the modular operating gates?",,<algorithms><quantum-computing>,12/02/2018 09:38,,101267.0,"It's a modular multiplication gate. It permutes the states such that, for all $k$ below $N$, state $|k\rangle$ becomes state $|k \cdot c \pmod{N}\rangle$ where $N$ is the number being factored and $c = b^{2^{2n-1}} \pmod{N}$ is a classically computed constant and $b$ is the base value chosen randomly at the start of the algorithm.",12/09/2018 08:54
103368.0,Grover's Algorithm result when the desired element is not present,,<search-algorithms><quantum-computing>,1/25/2019 7:20,,103377.0,"When it is absent, it will just output one arbitrary state. As it is not the desired element, you may repeat the search algorithm again (even in the case it was present, you could have measured another computational basis&nbsp;&ndash; the algorithm uses probability after all so that's why it may be necessary to repeat) and you will finally conclude that it is not present. The inversion about average operator changes the amplitudes of the states $\alpha_i$ to $$ - \alpha_i + 2 \langle\alpha\rangle\,, $$ where the last term is the average of the amplitudes. You see in the case of no marking, it has no effect, so all computational bases will have the same probability of being measured. You can check the explanation in Nielsen and Chuang's book.",1/25/2019 10:57
104995.0,How to perform measurement of a qubit?,,<quantum-computing>,03/01/2019 21:21,,105017.0,"You havenât specified the order of entries in your vector. In general, the $i$âth entry is obtained with probability $|x_i|^2$. Letâs consider two examples. In the first, the order of entries is $|00\rangle, |01\rangle, |10\rangle, |11\rangle$. The two final entries will be obtained with probability $1/2$ each, and so the first qubit will be measured as $|1\rangle$. If you measure only the first qubit, then you will still always get $|1\rangle$, and the other qubit will remain in the superposition $\frac{1}{\sqrt{2}}(|1\rangle-|0\rangle)$. If the order of entries is instead $|00\rangle, |10\rangle, |01\rangle, |11\rangle$, then once again the two final entries will be obtained with probability $1/2$ each. This means that the first qubit will be measured as $|0\rangle$ or $|1\rangle$ with equal probability.",03/02/2019 09:58
105246.0,Quantum NAND gate,,<quantum-computing><circuits>,03/06/2019 23:42,,105298.0,"The NAND gate is not reversible, you can't recover its inputs using its outputs, so it's not a well defined quantum gate. Or, at the very least, it must contain some sort of internal measurement mechanism that would cause decoherence. This would prevent it from being universal for quantum computation. A simple way to fix the reversibility problem is to have the gate work like a Toffoli. Instead of having two inputs a, b and producing one output a nand b, have three inputs a, b, c and toggle c based on a nand b thus producing the output a, b, c xor (a nand c). This gate is just a minor variation on the Toffoli gate, so it has the same universality properties as the Toffoli. It is universal for classical reversible computation, but not universal for quantum computation unless you add some sort of superposing gate such as the Hadamard.",03/07/2019 19:18
105246.0,Quantum NAND gate,,<quantum-computing><circuits>,03/06/2019 23:42,,105302.0,"The trick is, unlike classical gates, quantum gates have to be reversible (aka invertible). In other words, for every possible output, there must be one and only one possible input producing that output. This means the classical NAND gate can't possibly work in quantum computing: there are more inputs than outputs, so by the pigeonhole principle there must be some inputs that map to the same output. In particular, the inputs $(1,0)$, $(0,1)$, and $(0,0)$ all produce the output $1$. So first, let's focus on reversible classical computing: we force all gates to be reversible, but don't worry about qubits yet. By the pigeonhole principle, we see that each gate must have at least as many output bits as it has input bits. For one input bit and one output bit, there are only two reversible gates: ID (return the input unchanged) and NOT (return the opposite of the input). Neither of these are universal, as we can't build a NAND out of them. For two input bits and two output bits, there are a few different trivial gates (such as ""return both inputs unchanged"", ""return the first one unchanged and flip the second one"", etc). But the most interesting one is CNOT, defined something like this: $$CNOT(x, y) = (x, x \oplus y)$$ In other words, it flips $y$ if $x$ is true, and also outputs $x$ unchanged. Now we have an equivalent to XOR! But unfortunately, this still isn't universal: you can't build NAND out of CNOT, just like you can't build NAND out of XOR. (The proof works the same way, too.) Well, what about three inputs and three outputs? Once we've got three bits to work with, we can build CCNOT, which works like this: $$CCNOT(x, y, z) = (x, y, (x \wedge y) \oplus z)$$ And using this, you can build a reversible NAND! $$NAND(x, y) = CCNOT(x, y, 1)$$ So it turns out that CCNOT is indeed universal, for reversible classical computation. It's better-known as the Toffoli gate, after its discoverer. But you could certainly think of it as ""reversible NAND"". But once we bring in quantum computing, things get more complicated. CCNOT can implement all classical computations, but it can never create superpositions: you need something like a Hadamard gate for that. It turns out no single gate can ever be universal for quantum computing. So while ""reversible NAND"" is an important part of quantum computing, it can't stand alone: you need other operators too.",03/07/2019 20:31
105328.0,Deustch algorithm using one qubit,,<quantum-computing>,03/08/2019 12:14,,105346.0,"You can't. If the algorithm needs two qubits, you can't implement it with just one qubit.",03/08/2019 18:59
105328.0,Deustch algorithm using one qubit,,<quantum-computing>,03/08/2019 12:14,,105348.0,"Unfortunately, as D.W. says, it's not possible to do Deutsch's Algorithm with only a single qubit. The key is the line you quoted in your question: the quantum oracle for the function $f$ returns $\mid x\rangle \mid y \oplus f(x)\rangle$. This only works with two qubits. Why can't we just make the oracle return $\mid f(x) \rangle$? Well, in quantum computing, all functions must be reversible (you can reconstruct the input from the output), and we have no guarantee that $f(x)$ is reversible. And if we force $f(x)$ to be reversible, then we know it's balanced, and the problem becomes trivial (return ""balanced"" every time). The only way to make a reversible function out of a function that may not be reversible is to add ""ancillary"" or ""garbage"" qubits; this is how the Toffoli gate implements the non-reversible AND function. That's basically what the second qubit is doing here: without it, we can't even necessarily call the function.",03/08/2019 19:09
106954.0,On the robustness of BQP class,,<complexity-classes><quantum-computing>,4/14/2019 18:38,,111946.0,"After a while I look back on this problem. It turns out using universal gates to generate constant-qubit gates would make no difference to BQP class. The gate complexity, however, depends on $\epsilon$ for the error we try to bound, but precision could be reached in $poly(-\log{\epsilon})$ number of operations.",7/18/2019 2:52
108757.0,"Does this article imply that Turing-Computability is not the same as ""effectively computable""?",,<turing-machines><quantum-computing><church-turing-thesis>,4/30/2019 13:24,,108778.0,"There are many different meanings of the word ""can"". Is there an algorithm that can break AES-512 encryption? One strategy would be to take all 2^512 possible blocks of 512 bits, encrypt all of them with the public key, and for each of them check whether they match the ciphertext. In a purely abstract sense, this is an algorithm that ""can"" break AES-512. From a practical point of view, converting all the matter in the known universe into computers, and running the program on them until the heat death of the universe, would not be able to check all 2^512 blocks. Thus, there's an abstract, theoretical concept of ""can"" that does not take into account the amount of resources required, and a practical meaning that does. Turing Computability is concerned with the first type of ""can"". A Turing machine is a device that is allowed to run for unlimited time with unlimited memory. It is an abstract model used to formulate theoretical claims. No true TM actually exists in the real world. Thus, there is no contradiction between claiming, on the one hand, that anything a quantum computer can do, a TM can also do, and on the other hand claiming that there are problems that a quantum computer can solve, but no classical computer can solve; an actual computer will have computer power restrictions that a TM does not have.",4/30/2019 19:34
109136.0,Why have quantum circuits won out over quantum Turing machines?,,<quantum-computing>,05/09/2019 09:42,,119016.0,"I've popped up here 7 months too late but in response to the question here's my short-ish answer: Quantum Turing machines are physically unreasonable. Prof. Peter Shor originally wrote his factoring algorithm using a Turing machine and so from a theoretical perspective they work just fine. However, it requires the tape heads to be entangled, which is why you couldn't realistically make it work. The Circuit model (which has been around longer than Turing machines) also has it's own problems which is why Turing needed his machine. One main reason (there are others) is that circuits are designed for a given input size whereas Turing machines are independent of input size. Therefore the circuit model is better suited to quantum computation as it is a more realistic reflection of the devices we could build.",12/29/2019 23:01
110448.0,Quantum vs classic in NP-hard problems,,<complexity-theory><time-complexity><np-hard><np><quantum-computing>,06/10/2019 04:10,,110464.0,"It is conjectured that the complexity of SAT on $n$ variables is $\tilde\Omega(2^n)$ (a version of this is SETH, the strong exponential time hypothesis). In contrast, Grover's algorithm solves it in $\tilde O(2^{n/2})$. On the other hand, it is conjectured that quantum computers cannot solve NP-hard problems in polynomial time, that is $\mathsf{NP} \not\subseteq \mathsf{BQP}$.",06/10/2019 09:22
111444.0,Uncomputing measurement gate?,,<complexity-theory><quantum-computing>,07/03/2019 05:41,,111467.0,"You seem to be under the impression that we need to measure a qubit in order to copy it. That is not the case because the copy operation is performed by the mapping $|a,b\rangle \mapsto |a,a \oplus b\rangle$ which, when $b = 0$, can be realized by a CNOT gate. There is no measurement involved at all. You only need to know how many ancilla bits (i.e., initialized to zero) you need beforehand so as to have an adequate quantum circuit size.",07/03/2019 15:51
111444.0,Uncomputing measurement gate?,,<complexity-theory><quantum-computing>,07/03/2019 05:41,,117855.0,"The fact that you can simulate intermediate measurements is only used to argue that BQP_WITH_MEASUREMENTS equals BQP. Once having this established, you just forget about it. Yes, you canât undo a measurement. But the good thing is that you never have to.",11/30/2019 18:12
112098.0,Basic complexity theory (in Oracle Separation of BQP and PH),,<complexity-theory><quantum-computing><oracle-machines>,7/23/2019 4:12,,112099.0,"Let me answer your questions one by one. Black-box separations versus oracle separations Black-box algorithms are given access to a black box. For example, an algorithm might get black box access to a function $f\colon \{0,1\}^n \to \{0,1\}$. This means that the algorithm can obtain the value of $f(x)$ for any given $x \in \{0,1\}^n$, but is not otherwise given any explicit description of $f$. As an example, consider the following promise black box problem: given a function $f$ which is either the constant $0$ or balanced (that is, half its values are $0$ and half are $1$), determine which of these two cases $f$ belongs to. There is a very simple randomized algorithm which makes a constant number of queries and outputs the correct answer with constant probability; but every deterministic algorithm must make exponentially many queries in the worst case. This is an example of a black-box separation between promise versions of $\mathsf{P}$ and $\mathsf{BPP}$. Oracle separations also pertain to black-box algorithms, but now we want to fix the black box. In order to separate two relativizable complexity classes $A$ and $B$, we need to find a specific oracle $O$ such that $A^O \neq B^O$ (or prove that one exists). For every oracle $O$, the classes $A^O$ and $B^O$ consist of languages decided by algorithms with no auxiliary input. Rather, these algorithms have access to an $O$-oracle. But in contrast to the situation in the preceding paragraph, here the oracle is not part of the input. Rather, it is fixed. The standard example is Turing machines with access to an oracle to the halting problem. In contrast to the example given above for black-box algorithms, here the oracle is not an input but rather an additional mechanism that the machine can make use of. On randomness A language $L$ is in $\mathsf{BPP}$ if there is a randomized polytime machine $T$ such that: If $x \in L$ then $\Pr[T(x) = 1] \geq 2/3$. If $x \notin L$ then $\Pr[T(x) = 1] \leq 2/3$. When considering the black box version of $\mathsf{BPP}$, the definition remains exactly the same. The black box is not randomized; only the algorithm is randomized. As an example, consider the promise problem of determining whether an input black box is the constant zero function or is balanced. This problem can be solved in $\mathsf{BPP}$ by sampling a few points, or in $\mathsf{E}$ by querying the first $2^{n-1}+1$ values of the black box. Randomization is part of the algorithm, not the decision problem. Oracle circuits The paper you are reading doesn't actually use these &mdash; the oracles are only applied to $\mathsf{BQP}$ and $\mathsf{PH}$. But for completeness sake, let me mention that the most common model uses oracle gates, which are gates that provide access to the oracle. An advice Let me close with an advice. The paper you are trying to read is at the forefront of research. It would be extremely hard to appreciate it without having some background. This paper is probably not a good entry point into complexity theory. I suggest familiarizing yourself with complexity theory first, for example by reading parts of the textbook by Arora and Barak.",7/23/2019 5:50
113414.0,BosonSampling: $\# P \subseteq FBPP^{{NP}^{\mathcal{O}}}$ implies $P^{\#P}\subseteq BPP^{{NP}^{\mathcal{O}}}$,,<complexity-theory><decision-problem><quantum-computing>,09/04/2019 14:38,,113427.0,"I'm not an expert, and I have one blank space in my answer, hope someone might fill it in. $FBPP$ is the class of search problems $R = (B_x)_{x\in\{0,1\}^*}$ for which there exists a probabilistic polynomial-time algorithm $A$ that, given $\langle x, 0^ {1/\varepsilon}\rangle$ as input, produces an output $y$ such that $Pr [y \in B_x] â¥ 1 â \varepsilon$, where the probability is over $A$âs internal randomness. Suppose that $L$ is a $\# P-$hard problem, and $L \in FBPP^{NP^{\mathcal{O}}}$. Then, $$P^{\# P} \subseteq P^{L} \subseteq P^{FBPP^{NP^{\mathcal{O}}}} \subseteq BPP^{NP^{\mathcal{O}}}$$ The second inclusion is clear. The first inclusion: suppose $L_1 \in P^{\# P}$. It means that there exists some polynomial algorithm $\mathcal{A}$ which makes queries to some functions $f_1, f_2, \ldots$ from $\#P$. By the definition of $\#P-$hard problems, $f_i \in FP^{L}$, where $FP$ is the class of polynomially computed functions $f:\{0,1\}^*\rightarrow \{0,1\}^*$. It means that every $\mathcal{A}$'s query to $f_1, f_2, \ldots$ can be replaced by a polynomial program with (at most polynomial) number of queries to $L$, or simply speaking $\mathcal{A}$ is equivalent to some polynomial program $\mathcal{B}$ with queries to $L$. We've shown $$P^{\#P} \subseteq P^{FP^{L}} = P^L$$ We see that $P^{FP}$ can be replaced by $P$. The third inclusion: again, the same trick: here $P^{FBPP}$ turns to $BPP$. Suppose $L_2 \in P^{FBPP^{NP^{\mathcal{O}}}}$ and $\mathcal{A}$ is the corresponding algorithm for $L_2$. $\mathcal{A}$ makes at most $p(n)$ queries to the probabilistic polynomial programs $A_1, A_2, \ldots$ which solve some search problems. $\mathcal{A}$ uses randomness, but always gives the right answer. One can supposedly make $A_1, A_2\ldots $ a part of $\mathcal{A}$; the resulting probabilistic polynomial algorithm $B$ with queries to $NP^{\mathcal{O}}$ never errs and belongs to $BPP^{NP^{\mathcal{O}}}$. The only doubt that I have here is that there might be a polynomial number of queries to different functions $FBPP$, and $\mathcal{B}$ is supposed to know all the algorithms for them. It is widely known that if $\mathcal{C}$ is a complexity class with a complete problem $\mathcal{L}$, then $A^{\mathcal{L}} = A^{C}$ for class $P$. However, $BPP$ doesn't have complete problems, and I'm not sure about $FBPP$.",09/04/2019 20:30
116216.0,How do I search for Verification of Quantum Computing,,<quantum-computing>,10/24/2019 3:16,,141854.0,"My logic may be off, but here is my take. Consider the following: We want to find possible seeds for an existing and known hashed value. We have a superposition of all possible seed values. We run the superposition through the hashing algorithm to generate a waveform. Run grovers algorithm (or similar) on waveform to reveal likely hash values Verification process: 5. Remove values from the superposition that are not &quot;near&quot; a correct value. 6. Run the algorithm again. 7. Repeat until the waveform is a straight line representing the correct state. The seed values remaining in the superposition have a 100% chance of generating the desired hash value.",6/29/2021 21:36
116408.0,Why did Google not use an NP problem for their quantum supremacy experiment?,,<complexity-theory><quantum-computing>,10/28/2019 14:30,,116415.0,"there exist problems that are hard to solve, but for which it is easy to verify the validity of a given solution: the so called NP problems. This statement is wrong. There are many NP problems which are easy to solve. ""NP"" simply means ""easy to verify"". It does not mean hard to solve. What you are probably thinking of is NP-complete problems which is a subset of the NP problems for which we have very, very good evidence to think they are hard. However, quantum computers are not expected to be able to solve NP-complete problems significantly more ""easily"" than regular computers. Factoring is also thought to be hard, but the evidence for this is only ""very good"" and not ""very, very good"" (in other words: factoring is likely not NP-complete). Factoring is one of very few natural problems which falls in between not being NP-complete and not being easy. The list of problems that we know that are easy to verify, easy to solve on a quantum computer but hard classicly, is even shorter. In fact, I do not know of any problem other than factoring (and the very closely related discrete logarithm problem) with this property. Moreover, any easy to verify problem would likely have the same issue as factoring: $53$ qubits is not that many, and $2^{53}$ is huge, but just within reach of classical computing. $2^{53}$ less than $10^{16}$, and most classical computers can execute on the order of $10^9$ operations per second. We could run through all possibilities in about $1/3$rd of a year on a single classical desktop computer. Quantum computers have very few applications which they're known to be good at, and are essentially useless for most hard NP problems.",10/28/2019 17:27
116408.0,Why did Google not use an NP problem for their quantum supremacy experiment?,,<complexity-theory><quantum-computing>,10/28/2019 14:30,,116488.0,"Quantum computing is not a piece of magic, and there seems to be a widespread misconception about the power of quantum computers. I am by no means an expert in this field, but as far as I know QC is very suitable for computational problems that employ some kind of cyclic structure. This happens to be true for problems like the integer factoring problem and the discrete logarithm problem, thus, if quantum computers become practical, asymmetric ciphers like RSA and any kind of DSA (including ECDSA) will become obsolete. However, it is not known (or widely believed) that QC breaks symmetric ciphers (the key size has to be increased, though) or, more generally, inverts generic one-way functions. QC is also not known to break lattice-based asymmetric crypto, therefore, NTRU, McEliece etc. do apparently survive QC. Therefore, even if you have a fully functional QC, you cannot arbitrarily pick any computational problem and conjure the solution instantly.",10/30/2019 12:15
119389.0,Understanding the state vector in Quantum Computing,,<quantum-computing>,01/09/2020 22:36,,119390.0,"No, it's not correct. It's not true in general that one entry will be 1 and all others 0; that is true for the basis vectors, but there are other states (other vectors) where that isn't true. You can have linear combinations of the basis states, e.g., the following is a possible state: $${1 \over \sqrt{2}} |0\rangle + {1 \over \sqrt{2}} |1\rangle.$$ It corresponds to the following vector in the vector space: $${1 \over \sqrt{2}} (0,1) + {1 \over \sqrt{2}} (1,0) = (1/\sqrt{2},1/\sqrt{2}).$$ Because of this, you can have infinitely many possible states in this vector space. The vector space is not $N$-dimensional. The dimension of a vector space has a formal definition, and if you apply it, you will discover that the dimension of the vector space is $2^N$.",01/10/2020 01:13
120113.0,Can quantum computers really compute a vast number of possible solutions simultaneously?,,<quantum-computing>,1/30/2020 1:37,,120116.0,"They are not constrained to stepwise calculations As far as I know, all QC models are stepwise. Under the laws of nature, the ball spins either to the right or to the left, but never in both directions at the same time. The world of quantum computing is different: Here, the ball can revolve in both directions simultaneously I think this is the source from which comes all this âQC is a massive parallel computationâ. It is not exactly wrong to think of superposition $\frac{|0\rangle + |1\rangle}{\sqrt{2}}$ as âboth $|0\rangle$ and $|1\rangle$ at the same timeâ, but itâs confusing. It might make you think that both things are simultaneously available for arbitrary processing, which you can fully control. As if preparing a superposition is something like creating clones. A more precise way to think about superposition is interpreting it as uncertainty. So, less confusing statement would be âneither $|0\rangle$ nor $|1\rangle$, until the setup forces it to be definiteâ.",1/30/2020 5:33
121028.0,Can neural network process randomness?,,<algorithms><neural-networks><quantum-computing><randomness>,2/22/2020 19:49,,121033.0,"Purely randomness is not possible but in real-world the most randomness that a neural network can process is enough to discover an approximation pattern; the precision depends on the model of the context (exactitude of the Digital Twins) and processing power. To extract the exact pattern from the pure randomness (I think) is impossible even with a quantum computer and even having all the time and resources of the universe. The reason is that nothing in the universe happens randomly, every effect has a cause. So regarding to the third case (theoretically) if you can reproduce every cause of a ""twin universe"" you can predict the future.",2/22/2020 22:49
129761.0,What are analog and digital in computer science?,,<turing-machines><quantum-computing><message-passing>,09/02/2020 11:36,,129765.0,"There is a distinction between continuous phenomena and discrete. It's the former than is called analog in computer science and the latter, digital. After all, the digits 0 and 1 are discrete. Whilst [0,1], the interval between 0 and 1 is continuous and so analog. (I don't know if you are familiar with the notation [a,b]. It simply means all numbers between a and b).",09/02/2020 14:39
135196.0,How do two H gates act on two entangled qubits?,,<quantum-computing>,02/06/2021 14:08,,135199.0,"The Hadamard gate performs the following operation on a single qubit: \begin{align} |0\rangle &amp;\to \frac{|0\rangle + |1\rangle}{\sqrt{2}} \\ |1\rangle &amp;\to \frac{|0\rangle - |1\rangle}{\sqrt{2}} \end{align} This gives the action on pure states. The action extends linearly to mixed states: $$ \alpha|0\rangle + \beta|1\rangle \to \alpha\frac{|0\rangle + |1\rangle}{\sqrt{2}} + \beta\frac{|0\rangle - |1\rangle}{\sqrt{2}} $$ What happens when there are seveal qubits around? In this case, it is common to denote $|a\rangle \otimes |b\rangle$ by $|ab\rangle$, for brevity. If we apply a Hadamard gate on the first qubit, then it only affects the first qubit: \begin{align} |0b\rangle &amp;\to \frac{|0b\rangle + |1b\rangle}{\sqrt{2}} \\ |1b\rangle &amp;\to \frac{|0b\rangle - |1b\rangle}{\sqrt{2}} \end{align} Similarly, if we apply a Hadamard gate on the second qubit, then it only affects the second qubit: \begin{align} |a0\rangle &amp;\to \frac{|a0\rangle + |a1\rangle}{\sqrt{2}} \\ |a1\rangle &amp;\to \frac{|a0\rangle - |a1\rangle}{\sqrt{2}} \end{align} The two operations commute. What happens to a general mixed state? Denoting by $\stackrel{(i)}\to$ the application of $H$ on the $i$'th bit, we get \begin{align} &amp;\alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle \\ \stackrel{(1)}\to &amp;\alpha\frac{|00\rangle + |10\rangle}{\sqrt{2}} + \gamma\frac{|00\rangle - |10\rangle}{\sqrt{2}} + \beta\frac{|01\rangle + |11\rangle}{\sqrt{2}} + \delta\frac{|01\rangle - |11\rangle}{\sqrt{2}} \\ = &amp;\frac{\alpha+\gamma}{\sqrt{2}} |00\rangle + \frac{\beta+\delta}{\sqrt{2}} |01\rangle + \frac{\alpha-\gamma}{\sqrt{2}} |10\rangle + \frac{\beta-\delta}{\sqrt{2}} |11\rangle \\ \stackrel{(2)} \to &amp;\frac{\alpha+\gamma}{\sqrt{2}} \frac{|00\rangle + |01\rangle}{\sqrt{2}} + \frac{\beta+\delta}{\sqrt{2}} \frac{|00\rangle - |01\rangle}{\sqrt{2}} + \frac{\alpha-\gamma}{\sqrt{2}} \frac{|10\rangle + |11\rangle}{\sqrt{2}} + \frac{\beta-\delta}{\sqrt{2}} \frac{|10\rangle - |11\rangle}{\sqrt{2}} \\ = &amp;\frac{\alpha+\beta+\gamma+\delta}{2} |00\rangle + \frac{\alpha-\beta+\gamma-\delta}{2} |01\rangle + \frac{\alpha+\beta-\gamma-\delta}{2} |10\rangle + \frac{\alpha-\beta-\gamma+\delta}{2} |11\rangle \end{align} The Hadamard gate is Hermitian, and so applying it twice in a row results in the starting point: $HH = I$. Therefore if the oracle does nothing, you do get what you started from. But usually the oracle does change the qubits somehow.",02/06/2021 15:19
135259.0,Why are complex numbers needed to define qubits?,,<complexity-theory><quantum-computing><real-numbers>,02/08/2021 11:31,,135272.0,"You can run any standard quantum algorithm on a real-amplitude quantum computer with one additional qubit and only constant-factor slowdown (or perhaps linear-factor slowdown considering loss of parallelism) by replacing each $a{+}bi$ in your unitary matrices by $\big(\begin{smallmatrix}a&amp;-b\\b&amp;a\end{smallmatrix}\big)$. Likewise, you can simulate a quaternionic quantum computer on a standard quantum computer with one additional qubit by replacing $a{+}bi{+}cj{+}dk$ with $\big(\begin{smallmatrix}a+bi&amp;-c+di\\c+di&amp;a-bi\end{smallmatrix}\big)$. So these models are all polynomially equivalent. I doubt that there's a good non-physical argument for the appearance of complex numbers. In physics they're related to the duality between zeroth and first derivatives of position in harmonic oscillation (the same reason that complex numbers are used in modeling AC circuits), and that duality doesn't exist in the discrete quantum circuit model. Another argument from physics is that in Lagrangian QM the amplitude of a transition is $\int e^{iS(Î³)} \, \mathrm dÎ³$ (where $Î³$ ranges over &quot;histories&quot;), and there doesn't seem to be anything you can sensibly replace $i$ with in the real case. But this model, where each history contributes an amplitude with the same absolute value but a different phase, only works because of cancellation of nearby histories, and there aren't any &quot;nearby&quot; histories in the quantum circuit model.",02/08/2021 18:42
136398.0,What is the computer science interpretation of a qubit?,,<quantum-computing>,2/18/2021 18:20,,136399.0,"A qubit is a vector in a 2-state complex space. Its vector form is something like Qubit = $ax + by$, which by convention in Dirac notation is $|Q\rangle = a|0\rangle + b|1\rangle$, where $|0\rangle$ and $|1\rangle$ represent linearly independent basis vectors and the coefficients $a,b$ are complex numbers. $a^2$ and $b^2$ represent the probability of measuring 0 or 1, and they can take on any complex value as long as $|a|^2 + |b|^2 = 1$ (which must be true because we only have one qubit). In this framework, the qubit acts like a vector pointing from the origin which naturally evolves or rotates around the infinitely many surface points of a âBloch Sphereâ except when itâs measured it only ever tells you 0 or 1 (which represent the north and south poles of the sphere). In short, a qubit is a vector. The âinfinitely manyâ language comes from the ability of $a,b$ to take on any complex value so long as their squares equal 1. Measuring a qubit (meaning when you read it, touch it, look at it, record its value etc) only gives you 0 or 1, not both and not a decimal in between. If you also think of the qubit as a wave, then the goal of quantum computing is to take a superposition of all possible results of a qubit string (000, 001, 010, 011 etc), weight the components appropriately to constructively and destructively interfere with one another, so that at the very end youâre biased to get the right result... with a nonzero probability that you will get the wrong answer even if you do everything right. Incidentally a string of three qubits, youâll notice, is the tensor product of three qubit vectors. This creates a complex space with $2^3 = 8$ basis vectors which our 3-string qubit can happily explore.",2/22/2021 1:08
136398.0,What is the computer science interpretation of a qubit?,,<quantum-computing>,2/18/2021 18:20,,136676.0,"A QuBit is an element of a quantum circuit. Like regular bits, a QuBit has two states, 0 or 1. Unlike regular bits, a QuBit can be in a superposition of these states. Point 1: This gives us a terminology problem: What should be meant by &quot;state&quot; when talking about quantum systems. This is a problem only if classical terminology is stretched too far. Accept that new understandings are needed for quantum systems, and don't get stuck in terminology issues. Point 2: An understanding of &quot;superposition&quot; is needed. That would be a long topic to discuss by itself, and is not discussed here. A single QuBit system isn't very useful. Using an operator to put a single QuBit into a state which assigns equal probability to either state then examining the state of the QuBit gives you the same result as a fair coin toss. Point 3: &quot;Operator&quot; is another specific technical term. Loosely speaking, in a single bit system, operators might be &quot;1&quot; (set to the 1 state), &quot;0&quot; (set to the 0 state), &quot;1/2&quot; (set to the 1 state superimposed with the 0 state, with equal probabilities). Operators are more interesting when talking about more than one QuBit. In a quantum circuit which has multiple QuBits, the states of QuBits can be entangled with each other. The circuit is programmed by applying quantum operators to pairs of QuBits. This puts the entire circuit in an entangled state. At this point, meaningful computation becomes possible. Point 4: &quot;Entangled&quot; gives us the last technical term. This is another long topic which is not discussed here. That's a start. To understand how computation is done using QuBits, all of the above should be understood. That will require understanding a number of computer science concepts as well as a number of concepts from quantum physics. Point 5: Wait! What about complex numbers and probability amplitudes? Or 'ket notation? All of that is important when talking concretely about superposition, entanglement, and operators. But one step at a time. This answer is to provide a brief description of what is a QuBit.",3/15/2021 18:55
136398.0,What is the computer science interpretation of a qubit?,,<quantum-computing>,2/18/2021 18:20,,143415.0,"In the previous answer: &quot;weight the components appropriately to constructively and destructively interfere with one another, so that at the very end youâre biased to get the right result... with a nonzero probability that you will get the wrong answer even if you do everything right.&quot; Let's translate this. a. weight the components appropriately.. hmm b. to constructively and destructively interfere with one another... c. so that at the very end youâre biased to get the right result... d. with a nonzero probability that you will get the wrong answer... e. even if you do everything right. Let's think about this for a little more than a moment as you place your bet at a Roulette Table. I'm at the roulette table with 37 slots including TWO double-Zeros. The final answer, the winner, is decided by elements of a. The roughness of the track the ball runs in... b. the amount of oil on the spinners fingers... c. the flip of his/her hand and how many times the ball has been flipped... d. The nearly infinite ways the ball can bounce when it falls out of the track... e. and.. where the wheel started, and where it was when the ball left the track... You may notice the infinite amount of possible variations but really, only 37 answers. How hard can this be? These five listed variable are just the most obvious one out of a million others and is a micro description of &quot;Weight the components correctly.&quot; But... The 'Vectors within a Qubit cover all that so Let's let that be handled by ONE Qubit. Once the ball leaves the track and begins to bounce around inside the wheel... there is an infinite number of ways &quot;to constructively and destructively interfere with one another.&quot; Lets let that be handled by the ONE MORE Qubit. Omy, the power we have here! &quot;so that at the very end youâre biased to get the right result.&quot; meaning... we need to let some or all of our Qubits be biased in such a way as to always (most always) predict an outcome that matches the expected answer.. 1-37. Looks like we have to let Qubit one interact with Qubit two. Of course the non-zero probability of producing the right answer is STILL 1 out of 37 as the game is being played in the Casino and our money may be long gone before we can possibly change all the input required to help us win even one spin of the wheel. As admitted.. &quot;even if you do everything right.&quot; Odds are against being right the first time... Wanna take a Moon ride based on the output of this computer? The idea is that if you can bias up the input and provide the right entanglement and the right forces of constructive and destructive interaction... you might somehow resolve a 64 encryption code with a minimum number of 'readings' of the Qubits and more quickly produce the actual code out of 1.8446744e+19 possibilities. There you go. Enjoy. Finally... (I do have a little experience with the pre-cursors of Quantum computing.) I knew of a person that tried to simulate the mentioned inputs of our quantum computer by biasing the two sides of two flip-flops to simulate the multiple inputs of a given neuron in the human nervous system. The idea was to bias the two sides of a binary flip-flop and then power it up and see if it became a Binary One or Zero. The constructive/destructive part was simulated with positive and negative voltages. The interaction of Two flipflops was simulated with capacitive or inductive coupling between the inputs of the two flipflops. At power up time, the answer would be 00 01 10 or 11 from the two bits, exactly like the answer produced by two Qubits. That answer was completely dependent on INPUT and an expected result. Think about it. What kind of input is needed to resolve a 64bit encryption code. See the problem?? There is NO KNOWN input to do that. Is there anything about entanglement that will help get us to the right required input? Simply stated. No. Admittedly, the possibilities ARE limitless but so are the number of wrong answers. By the way... neurons are tiny little frequency generators... Each one only goes up or down in frequency.. with zero F being the unstimulated state and High F resulting when multiple inputs... of varying input frequency produce any one of an infinite number of output frequencies by the neuron. I would more likely spend my money in that direction if we are talking about how quickly the brain can identify a face in a crowd. The RGB sensors in our eyes can produce an infinite number of colors by producing just three frequency generators per pixel of color sensing. Effectively three bits per pixel. How many Qubits will be needed to tell if a car is maroon or beet colored? yikes! My daughter could do that when she was four. Just a thought.",8/24/2021 20:25
136189.0,"What is the ""formula"" for ""any cipher can be deciphered by a quantum computer""?",,<complexity-theory><time-complexity><complexity-classes><quantum-computing><encryption>,03/04/2021 18:21,,136191.0,"In general, if NP turns out to be the subset of any tractable class then that will be a black swan event for those who depend on cryptography as it exists today. $NP \subseteq BQP$ is one such example. But it need not be a fatal blow to use of cryptography. Quantum computers with a large number of qubits have yet to be built, and it is unknown whether they can be. So increasing key lengths may well put tractable decryption out of reach of the machines that can be built. And of course the polynomial exponent might turn out to be large enough to make polynomial-time &quot;efficient&quot; decryption infeasible in practice. E.g. an $O(n^{13})$ algorithm for SAT, while a beautiful thing to behold, probably isn't going to break use of cryptography.",03/04/2021 19:50
136494.0,How will Big O be with quantum computers?,,<algorithms><time-complexity><quantum-computing><big-o-notation>,03/11/2021 20:25,,136496.0,"Big-O has nothing to do with quantum computers. This should be obvious by the fact that Big-O notation was introduced in 1894, long before we had any knowledge of quantum theory â¦ or computers for that matter. Big-O is simply a convenient notation for classifying growth rates of functions. Big-O doesn't care how you interpret those functions. So, the definition of Big-O will not change for quantum computers for the simple reason that its definition has nothing to do with computers.",03/11/2021 20:47
138480.0,Can quantum computers be modelled as a classical computer with access to an oracle?,,<time-complexity><quantum-computing><oracle-machines><oracles>,04/03/2021 17:31,,138486.0,"Technically, the main differences between classical and quantum algorithms are super-position and entanglement that make the concept of oracle in quantum algorithms. As these two are only meaningful in quantum mechanics, you can't have that oracle with the same cost as the quantum algorithms, in classical algorithms.",04/03/2021 18:37
138480.0,Can quantum computers be modelled as a classical computer with access to an oracle?,,<time-complexity><quantum-computing><oracle-machines><oracles>,04/03/2021 17:31,,138492.0,"Vacuous answer: because $\text{BPP}^\text{BQP} = \text{BQP}$, giving a computer access to a $\text{BQP}$ oracle makes it equivalent to a quantum computer at solving decision problems in polynomial time. This is sort of like saying &quot;if your computer has access to a quantum computer, then you have access to a quantum computer&quot; but it does meet the criteria in your question. Also, quantum computers can't do a Fourier transform on $2^n$ bits in $O(n^2)$ time. Quantum computers can apply a Fourier transform to the state vector of $n$ qubits in $O(n^2)$ time. It's not at all the same thing.",04/03/2021 20:22
138480.0,Can quantum computers be modelled as a classical computer with access to an oracle?,,<time-complexity><quantum-computing><oracle-machines><oracles>,04/03/2021 17:31,,151597.0,"Let me add to the previous questions that BQP capture the power of quantum computers for decision problems, but there are other algorithmic tasks to consider. It is a reasonable conjecture that equipping a BPP computer with an oracle for BQP complete problems does not enable performing quantum sampling (or even just boson sampling). And perhaps this conjecture remains true if you equip it with a PH oracle as well!. It seems likely that equipping a classical computer with quantum sampling powers give it full BQP power. I don't know about other algorithmic tasks for quantum computers that leads to interesting complexity classes, e.g. even more powerful than quantum sampling.",5/15/2022 16:44
138978.0,Why is CNOT the only non-trivial reversible gate for two input bits?,,<quantum-computing><linear-algebra>,4/16/2021 5:22,,139115.0,"The CNOT gate is definitely not the only non-trivial reversible gate on two input bits. For example, you could switch the order of inputs or the order of outputs. What Wikipedia means is that CNOT is the only non-trivial reversible gate up to some allowed operations, which consist of permuting the inputs and outputs, and applying reversible one-bit gates on the inputs and outputs. If a two-input gate $G$ is reversible, then it is a permutation on $00,01,10,11$. By possibly negating the inputs (or the outputs), we can assume that $G(00) = 00$. By possibly switching the order of the inputs, we can assume that in $G(01) &lt; G(10)$. We are left with three possibilities: $$ 00 \to 00 \quad 00 \to 00 \quad 00 \to 00 \\ 01 \to 01 \quad 01 \to 01 \quad 01 \to 10 \\ 10 \to 10 \quad 10 \to 11 \quad 10 \to 11 \\ 11 \to 11 \quad 11 \to 10 \quad 11 \to 01 $$ The first possibility is the identity, which is trivial. The second possibility is CNOT. The third possibility is CNOT with outputs swapped.",4/19/2021 6:37
145744.0,"What happens if we change $\mathcal{BQP}$ to allow quantum bits, but not quantum gates?",,<complexity-theory><quantum-computing>,11/14/2021 14:22,,148662.0,"This is universal for BQP, unless you put strong restrictions on the allowed measurements. To start with, if you apply the Toffoli to a target qubit in the $\lvert-\rangle$ state, you get a Controlled-Z (CZ) gate. Using the CZ gate and initial $\lvert+\rangle$ states, you can create the cluster state (in fact, on any lattice of your liking). Once you have the cluster state, you can carry out universal quantum computations in you allow for measurements in a discrete set of directions in the XY-plane. (You don't need Z measurements if you create the cluster state on the right graph right away.) Finally, I suspect that you could even further restrict the required measurements - I would strongly suspect down to only an X measurement. The idea would be to create the cluster state &quot;on the fly&quot; as you measure, and then start from a suitably rotated state in the XY plane rather than the $\lvert+\rangle$ state; this should effectively give you the ability to measure in any direction in the XY plane you want. (There's a subtlety that you have to make this choice before you measure the preceding site, but I don't think this matters.) On the other hand, measuring in the Z basis only is indeed efficiently simulatable classically, since the Z measurement can be &quot;pushed&quot; through the Toffolis, to give another Z measurement on the initial product state with some classical relabeling of measurement outcomes.",1/24/2022 17:43
147914.0,What would be the conseuqences of BQP = NEXPTIME?,,<complexity-theory><time-complexity><quantum-computing>,12/23/2021 18:35,,148397.0,It is known that $BQP \subseteq PSPACE \subseteq EXP \subseteq NEXPTIME$. If $BQP = NEXPTIME$ then $PSPACE = EXP $ and $ EXP = NEXPTIME $. This would imply $L = P$ and $P = NP$.,1/14/2022 15:28
152506.0,What is different between two classes are 'incomparable' or two classes are 'not equal'?,,<complexity-theory><complexity-classes><quantum-computing>,6/20/2022 7:17,,152507.0,"Two sets $A$ and $B$ are comparable if $A \subseteq B$ or $B \subseteq A$. However, if $A \neq B$, it could be that $A \subsetneq B$ or $B \subsetneq A$. If $A \neq B$ and $A$Â and $B$Â are comparable, we know that (wlog) all elements of $A$ also are in $B$, and this is an interesting piece of information. If $A$Â and $B$Â are incomparable they are necessarily not equal ($A \neq B$). It also means that there is an element in $A$ that is not in $B$, and an element in $B$ that is not in $A$. For example, since $P \subseteq NP$, we know that every problem in $P$ has a polynomial-time verification since every fact about problems in $NP$ is also true about problems in $P$.",6/20/2022 7:35
154821.0,Does quantum computing imply LPO?,,<logic><quantum-computing>,10/20/2022 19:43,,154823.0,"No, this is not possible. It is known that Turing machines can simulate quantum machines (albeit very inefficiently). If there were a quantum machine that realized LPO then we could simulate it on a Turing machine â but a Turing machine cannot realize LPO, because doing so would give us the Halting Oracle.",10/20/2022 20:22
159084.0,Making statements about quantum complexity theory,,<quantum-computing><oracle-machines><factoring><oracles>,3/16/2023 15:35,,159086.0,Shor's algorithm does not use an oracle. The input is a number $n$ to be factored. $U$ is not an oracle; it is a computation that is done by the algorithm (akin to a subroutine).,3/16/2023 20:22
159094.0,Representing classical circuits with quantum gates,,<circuits><quantum-computing>,3/17/2023 8:58,,159095.0,"No, it's obviously not equivalent, because computation on a quantum computer is not known to be equivalent to computation on a classical computer. Also, it's not clear what you mean by a &quot;quantum gate&quot; or how it is specified on the input. Yes, depending on the notion of completeness - it may depend on under what notion of reduction you are using for completeness. If the notion of reduction you are using is polynomial time algorithms (as is common), then yes, it follows that. You should spend some time trying to prove it. It follows directly from the definitions -- so see what you can come up with.",3/17/2023 9:11
159722.0,"Are quantum computer strictly ""faster"" than any massively parallel computer in terms of computational complexity?",,<parallel-computing><quantum-computing>,4/20/2023 14:16,,159723.0,"Nope. For some problems, quantum computing is far more powerful than parallelization. If quantum computing can be made to work in practice and can scale (which is not yet known yet), then no, a massively parallel computer cannot do everything that a quantum computer can do. Intuitively, the reason is that for some problems, quantum computing gives us an exponential boost over non-quantum algorithms. You can't make up for that exponential with parallelization, once problem sizes get large: the exponential turns into a really large number. For instance, consider the problem of factoring large integers. Shor's algorithm allows to factor integers in polynomial time (approximately quadratic time in the size of the integer). The best non-quantum algorithms we know take sub-exponential time (approximately exponential in the cube-root of the size of the integer). The latter grows far faster than the former. So, if the integers are large enough, the gap between these two running times is tremendous and cannot be made up with a parallel computer. For instance, suppose we want to factor a 100,000 bit number (that is a product of two large primes). Then the best non-quantum algorithms that are known are expected to take more than $2^{361}$ steps of computation (probably a lot more than that, actually). Now if you somehow managed to program every atom in the known universe, so that each atom is its own separate mini-computer, executing $10^9$ steps per second, and you ran this parallel computer (which takes up the entire universe) for the lifetime of the known universe, then that still would not be long enough to factor such a number. So no real classical algorithm could ever hope to factor such a number, no matter how much parallelization you use. However, if quantum computing can be made to work in practice and if it scales, then in principle, we should be able to factor such a number. It might be difficult, but it is just a matter of engineering -- there is no fundamental limit preventing that. This assumes you are interested in the amount of resources needed to compute something. If you don't care about the amount of resources, and just what can be computed in theory given unlimited resources, then there is no difference between quantum vs classical algorithms. Anything that can be computed by a quantum algorithm can be computed by a classical algorithm -- possibly with an exponential slowdown, or with exponentially more resources (e.g., exponential parallelization). In particular, there are classical algorithms for simulating the evolution of any quantum system. They're just incredibly slow for complex systems. If that is your perspective, you don't even need a parallel computer -- it suffices to use a sequential algorithm and let it run exponentially long.",4/20/2023 17:02
14018.0,Quantum Algorithms and CT vs Classical counterparts,"How is Quantum Algorithms and Complexity Theory essentially different from Classical Counterparts? Also how are non-deterministic Turing Machines(NTM) different from Quantum Turing Machines(QTM)? More precisely, Is there an QTM that can solve the SAT 'fairly fast'? I wanted to know how are QTMs different from NTMs, for instance we have parallelism in NTMs which (i think) are not exhibited by QTMs, also there are certain class of problems (in linear optics) that the QTMs can solve easier than NTMs.. So, what are their limitations and computational powers?",<quantum-computing>,8/29/2013 10:52,,,,
39938.0,Quantum multi valued decision diagrams,"I recently came across the paper ""QMDD: A Decision Diagram Structure for Reversible and Quantum Circuits"" by Thornton and Miller. It deals with a way of compactly representing transformation matrix for a given quantum circuit or a quantum gate. I tried very hard to construct a QMDD of a Toffoli gate but I failed. Then I realized maybe I didn't understand QMDDs. Can anyone please explain me QMDDs and a way to construct a QMDD for a given circuit or gate?",<quantum-computing>,2/27/2015 13:48,,,,
49139.0,"2 qubits, correct way CNOT a 3rd qubit with the 1st?",Suppose I have 2 qubits in the state a|00>+b|01>+c|10>+d|11>. And suppose I want to perform some operation between only the 1st qubit and a 3rd qubit - for example a CNOT operation. What would be the correct way to do this multiplication?,<quantum-computing><linear-algebra>,11/06/2015 03:18,,,,
65719.0,TCS/Math/Quantum Information Advice,"I am currently a high school 12th grader and am very interested in computer theory and pure mathematics. I also have a strong interest in astronomy and a desire to study quantum information. However, physics and I really don't have a nice relationship. I am having trouble figuring out what major holds the topics I am interested in. Most university research on quantum information seems to be found in the physics/astronomy department, but I have also found joint computer theory/mathematics programs in their respective departments. I don't want to be a physics major, but how can I fulfill my curiosity with quantum information? I am having great difficulty finding a university that offers undergraduate research in these fields. Any tips on how to find research opportunities in these topics as an undergrad?",<algorithms><complexity-theory><computability><discrete-mathematics><quantum-computing>,11/08/2016 06:49,,,,
68297.0,Will quantum computers out-scale classical computers at P-problems?,"It is my understanding that quantum computers have gained interest, because some interesting problems are suspected to be in the BQP-class, but not in the P-class (integer factorization, ...). Quantum computers would then be able to solve these problems efficiently, while classical computers are not. However, I'm wondering if quantum computers will also be able to out-scale classical computers at P-problems. Part of my reasoning leading to this question is the idea that quantum computers might be able to solve ""classical"" P-problems with a relatively small number of qubits. Exponential scaling of the number of qubits over time, might lead to ""quantum suppremacy"", not only for BQP, but also for P-problems. Are quantum computers only useful to tackle specific problems, i.e. BQP-problems that are (potentially) not in the P-class? Or is it reasonable to assume that quantum computers might gain superiority for all types of problems?",<algorithm-analysis><quantum-computing>,01/05/2017 20:18,,,,
81752.0,Quantum algorithms for logical inference - reference request?,"Microsoft is committed to the building of the scalable, industrial size topological quantum computer, Visual Studio integrated programming language and SDK will be released by the end of this year (2017). From the other side, logical/symbolic methods in computer science (natural language processing, inference, knowledge management etc.) are considered to be impractical due to high complexity/computational time, that is why subsymbolic methods (neural networks, statistical methods) are used widely today. The question is - are there quantum algorityms for speedup of classical logical problems (i.e. all the non-quantum logics - classical, non-classical, modal, defeasible, linear, categorical, adaptable, etc.), like automated theorem proving, backward and forward reasoning and so on? I have heard that Grover search algorithm can be used for solving Boolean satisfiability problem but are there any other quantum algorityms for logics?",<algorithms><reference-request><logic><quantum-computing><reasoning>,9/27/2017 11:09,,,,
82265.0,Are there quantum algorithm that solve the boolean satisfiability problem in subexponential time?,"Are there quantum algorithms that solve the boolean satisfiability problem in subexponential time? Do they just give a determination as to whether an expression can ever evaluate to true, or can they also tell which input will cause the expression to evaluate to true?",<complexity-theory><quantum-computing><boolean-algebra>,10/10/2017 05:31,,,,
87049.0,How does this last step in Shor's algorithm work?,"Page 854 of The Nature of Computation states the following (This discussion has made the simplifying assumption that $M/r$ is an integer): If each of the observations gives us a random harmonic, how long does it take to learn the fundamental frequency? Suppose we observe the frequencies $k_1 = b_1 M/r$, $k_2 = b_2 M/r$, and so on. As soon as the $b_i$ are relatively prime, i.e., $\gcd(b_1, b_2,...) = 1$, then $\gcd(k_1, k_2,...) = M/r$. With constant probability even the first two observations suffice, since as Problem 10.26 shows, $b_1$ and $b_2$ are mutually prime with probability $6/\pi^2$ when $r$ is large. Thus we can determine $M/r$ from a constant number of observations on average, and we simply divide $M$ by $M/r$ to obtain $r$. But how can we figure out that we've reached the point that the $b_i$ are mutually prime? This procedure reads to me as if there was a deterministic way of detecting that and it was only the number of necessary observations that was random.",<quantum-computing><number-theory>,1/20/2018 20:44,,,,
98629.0,Quantum and classical time complexity,"Do we know any function which has same quantum and classical time complexity (bounded error), or at least same upper bound? Of course, let's rule out trivial functions like the constant function, and may be assume the time complexity of the desired function be at least polynomial in input size.",<complexity-theory><time-complexity><quantum-computing>,10/15/2018 16:51,,,,
108828.0,Computational power of quantum finite automata,"I am preparing some lecture notes on the computational power of quantum finite automata (QFA). I am a bit confused about which models of QFA are stronger and which models are weaker than standard finite automata (FA). There is one-way QFA (1QFA) and two-way QFA (2QFA). For each model, we can either have ""measure-once"" (MO) or ""measure-many"" (MM) version. I thought MO-1QFA was stronger than FA but apparently it is not. I also thought MM-1QFA is same as one-way probabilistic finite automata. Apparently, MO-1QFA is weaker than MM-1QFA. This is a little puzzling because measure-many quantum Turing machines are same as probabilistic Turing machines. However, measure-once Turing machines are stronger than the measure-many version. Could you please state which models are actually computationally stronger than the other? Where do we place 1-way and 2-way probabilistic finite automata (1PFA, 2PFA) in this picture? Thank you in advance.",<formal-languages><automata><finite-automata><quantum-computing>,05/01/2019 16:28,,,,
110392.0,Use Less Qubits to simulate More Qubits,"Lots of (quantum) applications need thousands of qubits. But suppose we are short of stable qubits, is it possible (in general) using more time (or classical computation resources) to made up this shortage? Or is there any lower bound for this proving it can't be done? Apology for phrasing the problem in just a few word, I just can't think of any technique for now.",<quantum-computing>,06/09/2019 04:22,,,,
112189.0,What is the complexity class of exponential parallelism?,Consider the class of problems that can be computed when you have access to exponentially many processors working in parallel. How does one capture that in a proper formalism? Is there some literature on it already? Would it be true that such a class would be a superset of BQP?,<complexity-theory><parallel-computing><quantum-computing>,7/25/2019 14:57,,,,
118631.0,NDFA has maximum states as 2^n the same for qubits in quantum computation.How they can be distinguished in means of computation?,"I am a Computer Engineer. I studied basics of Quantum Computation. In dealing with multiple states, I feel NDFA does similar to Quantum Computation but we preferred to convert NDFA to DFA and solved problems. But in era of Quantum we prefer this multiple state quantum property to deal with major NP problems. Why? Where they both looks similar and where they differ in terms of Computation",<finite-automata><quantum-computing>,12/17/2019 10:22,,,,
124042.0,Data structures for quantum computers,"In classical computers we have List,Queue,Tree &amp; etc data structures, since classical computers using 1's &amp; 0's on those data structures. Then what happens when it comes to quantum computers, Do they(computer scientists) need to create new data structures ? Or use existing data structures with some sort of optimization ? Thanks in advance.",<data-structures><quantum-computing>,4/13/2020 8:08,,,,
127169.0,What is the simplest quantum algorithm to visualize a quantum computation?,"I'm interested to visualize how a simple quantum computation can be done, step by step. Can you help me? I need any simple example of how qubits can be used to make a computation.",<quantum-computing>,6/13/2020 19:18,,,,
133465.0,Generalizing Quantum Computation,"When you first learn more about computation you can imagine it in terms of boolean circuits. That is you get a boolean vector $v \in \lbrace 0,1\rbrace ^n$ which you can then apply a circuit $C$ to which then produces an output boolean vector, and $C$ must be constructed from some basic gates (and or not). It's fascinating that if we assume our input vector is not a boolean vector $v \in \lbrace 0,1\rbrace ^n$ but rather an exponentially large complex vector $v \in \mathbb{C}^{2^n}$, BUT we also now restrict our circuits to strictly be complex unitary matrices, we end up with a stronger model of computation, BQP, which can solve problems that we currently don't know to be solvable in P. Subjectively what happened here, was we made the state of our program much larger. After all $\mathbb{C}^{2^n}$ is for most n way bigger state than $\lbrace 0,1 \rbrace^n$, but then we made our circuit much weaker, that is we can't do arbitrary circuits anymore we can ONLY multiply with complex unitary matrices. Between making the state bigger (obviously strengthening your computational power power), and the circuit choice smaller (which would weaken your computational power), we all said and done end up with a slight net gain in computational power (factoring is now polytime, but NP has not yet obviously become accessible!). So now this leads to the natural question, can the process: &quot;expand state size&quot;, &quot;reduce choice of operators&quot; yield other interesting complexity classes that are stronger than BQP but don't collapse NP to their P? An example of what I would look for could be the following: what if the state vector is $\mathbb{C}^{2^{2^n}}$ but the gates that we get to use are a much more restricted class than unitary matrices (ex: only unitary matrices with determinant 1). Does this model computation allow us to solve problems in polynomial time that are known to be intractable to a quantum computer? Perhaps the example I give may not clearly give an answer so feel free to swap out the underlying field $\mathbb{C}$ with some other ring of your choice, and then restrict the operators as you see fit.",<computation-models><circuits><quantum-computing>,12/18/2020 4:07,,,,
134328.0,BPP and BQP: Optimization Versions?,"For optimization problems, I found complexity classes analog to some classes for decision problems, e.g. PO and NPO, mirroring P and NP for decision problems in the sense that optimization problems in PO can be solved in polynomial time and verified in polynomial time, respectively. Are there similar class definitions mirroring BPP and BQP, i.e. classes of optimization problems that could be solved with a probabilistic algorithm or on a quantum computer efficiently?",<complexity-theory><quantum-computing>,1/13/2021 22:56,,,,
134788.0,Special Properties for Oracles in HSP,"Let $(G,+)$ be an abelian group, $X$ a finite set (of &quot;colors&quot;), and $f:G \to X$ a function such that there exists a subgroup $H&lt;G$ for which $f$ separates cosets of $H$, i.e. $\forall a,b\in G:f(a)=f(b)\iff a+H=b+H$. Using information gained from evaluations of $f$, determine a generating set for $H$. This is the hidden subgroup problem, that is solved in abelian groups using a quantum polynomial time algorithm. In many cases $f$ is actually an homomorphism. So, in fact, the subgroup $H$ corresponds to $\text{Ker}(f)$. For example, this is true in the cases of factoring, i.e. Shor's algorithm and also in the discrete log problem. More generally, I am interested in the cases where we can construct a mapping $M:X\times X\to X$ such that $\forall a,b\in G:M(f(a),f(b))=f(a+b)$ (e.g. when $f$ is an homomorphism $(x,y)\overset{M}{\mapsto} x\cdot_Xy$ is the mapping). However, $f$ is not necessarily an homomorphism and $X$ is not necessarily associated with a know group operation either. Clearly such $M$ always exists, by going through group $G$ using representatives from coset in $f^{-1}$. So, what is really interesting, even when restricting to the abelian case, is whether we can always find such $M$ classically and efficiently. Also, is there a known thing that is described somewhere in this direction?",<complexity-theory><quantum-computing><group-theory><oracles>,1/25/2021 20:01,,,,
143892.0,Is quantum computing a serious usable instrument for the IT industry?,"Following this latest and very exciting research object I can't find till now a usable computer. By computer I understand a definitive switchable Hardware. I would like to call actual &quot;quantum computing&quot; by the topic &quot;researching of quantum elements for computing&quot;. Till now I found only expensive and complex quantum circuits. We - till now - don't have usable, steerable elements to get definitive decisions by switches. We can't find that elements in that subatomic level. We cant find - till now - definitive usable switch-instruments like relays or bistabile chips - till now. We only follow mathematical rules coming from probability formulas.",<probability-theory><quantum-computing>,9/13/2021 10:34,,,,
149914.0,Quantum Boolean SAT algorithm?,"Is there a quantum SAT algorithm, a quantum analogue of the DPLL or CDCL algorithms? Note: I'm not looking for the quantum analogue of the Boolean satisfiability problem (though that would be interesting), but a quantum algorithm that solves Boolean SAT problems.",<algorithms><reference-request><satisfiability><quantum-computing><sat-solvers>,3/15/2022 19:43,,,,
152593.0,are computer errors inevitable?,"this is my First post,I apologize for my ignorance. The question is: Could a programmer (human or Ai) with all the computing power and infinite time create a simulation of a world with our same laws of physics without errors of any kind (both software and hardware errors)? Clarification:1) the simulation shouldn't simulate the computer running the simulation too, sorry for the pun. 2) if are used a quantum computer, which uses qubits, it would change something in terms of the mass of the computer or something else (like it is not as big as the universe). 3) if the computer did not simulate in real time but as a kind of movie (I think it says pre-rendered), something would change (such as the fact that it could require less computing power)",<optimization><artificial-intelligence><quantum-computing><simulation>,6/22/2022 21:18,,,,
153982.0,Quantum algorithms speedup illustration,"I know that to illustrate speed-up advantage of Grover's algorithm we can apply &quot;square root&quot;: if the brute force search takes 100 hours, Grover's quantum search algorithm should take about 10 hours. What would be similar numbers for Shor's algorithm for, say, 10-digit numbers?",<quantum-computing>,09/04/2022 17:13,,,,
159910.0,Is Quantum Search (SAT with only oracle access) NP-hard (and not NP-complete)?,"Quantum search differs from the standard boolean SAT as it is restricted to only oracle calls to a circuit (or CNF formula). Where SAT gives us the structure of a formula (however loosely defined that is), quantum search algorithms make queries to $U_f$. It seems pretty clear that this oracle-only SAT problem is NP-hard. Of course, it isn't a decision problem, but rather it is an oracle problem, so my notion of reduction is $A \leq B \iff$ &quot;an oracle to solve B can be used to solve A in polytime.&quot; (A Turing reduction). If we had an oracle that solved quantum search, then we could just use this oracle to solve SAT. But I'm curious on what is known about the inverse; i.e., if we had an oracle that solved SAT, could we solve quantum search? Has it been shown that this isn't true? Intuitively, this being true feels like it proves $P = NP$, but I'm not quite sure. Also, it's pretty easy to see how quantum search can be verified in polynomial (constant) time. But I am asking if it can reduce to SAT, which is my definition of NP here.",<turing-machines><quantum-computing><p-vs-np><oracle-machines><oracles>,4/30/2023 22:00,,,,
159965.0,Is the HSP with the symmetric group exactly equivalent to the Graph Isomorphism problem?,"It is well known that an algorithm to solve the Hidden Subgroup Problem (HSP) with the symmetric group can solve the Graph isomorphism problem. But is this true in reverse? Will an algorithm for graph isomorphism be useful in solving the HSP with the symmetric group? The HSP is only really useful for connecting applicable problems, but I am asking this for theory.",<complexity-theory><quantum-computing><group-theory>,05/03/2023 16:07,,,,
160137.0,The Hidden Subgroup Problem under different mappings,"The Hidden Subgroup Problem (HSP) is an extremely prevalent problem in quantum computation, especially for factorization in Shorâs algorithm. The problem is stated Given an oracle for some function, $f: G \mapsto X$, that is promised to satisfy $g_1 H = g_2 H \iff f(g_1) = f(g_2)$ But the HSP is often spoken of in terms of the group $G$, instead of the function $f$. For example, period finding (the foundation of Shorâs algorithm) is said to be the HSP on the cyclic group ($\mathbb{Z}_N$). The graph isomorphism problem is the HSP on the symmetric group. The shortest vector lattice problem is the HSP on the dihedral group. None of these reference the mapping. Does the complexity of the HSP change when the function is changed? Is it by a polynomial factor every time?",<complexity-theory><quantum-computing><factoring>,05/12/2023 15:37,,,,
88417.0,Grover's search on cryptographic hash functions - how can we build the oracle?,"Let's say I'd like to search a database and I have a function $f$ such that $f(x) = 0$ for all incorrect entries and $f(x) = 1$ for all target entries. The crux of Grover's search seems to be that there exists a way to construct a quantum operator $\hat{f}$ in a way that it takes a superposition of states as input and adds a phase only to the target elements from the superposition. What guarantee do we have that such a construction exists? For example, if I take a classical hashing function, how do I go about building the quantum equivalent that is able to simultaneously evaluate multiple inputs and assign the phase only to those inputs that fall below some target threshold?",<quantum-computing>,2/21/2018 15:44,,,,
75202.0,What is the difference between quantum computing and parallel computing?,Quantum computing essentially relies on the fact that qubits maintain multiple possible states simultaneously. Parallel computing too processes multiple states simultaneously. So what is the difference or how are they different?,<computation-models><parallel-computing><quantum-computing>,05/10/2017 17:29,,,,
,,,,,,,,
10922.0,"How would a quantum computer potentially facilitate artificial consciousness, assuming it is possible?","How would a quantum computer potentially facilitate artificial consciousness, assuming it is possible?",<philosophy><research><artificial-consciousness><quantum-computing>,2/27/2019 19:13,,,,
